
Ux_Device_MSC.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   0000034c  34180400  34180400  00000400  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0001da1c  3418074c  3418074c  0000074c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000328  3419e168  3419e168  0001e168  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  3419e490  3419e490  0001f640  2**0
                  CONTENTS, READONLY
  4 .ARM          00000008  3419e490  3419e490  0001e490  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  3419e498  3419e498  0001f640  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  3419e498  3419e498  0001e498  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .fini_array   00000004  3419e49c  3419e49c  0001e49c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .data         00000178  341c0000  3419e4a0  0001f000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .noncacheable 00000000  341c0178  341c0178  0001f640  2**0
                  CONTENTS
 10 .gnu.sgstubs  00000020  3419e620  3419e620  0001f620  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 11 .bss          000033cc  341c0178  341c0178  00020178  2**2
                  ALLOC
 12 ._user_heap_stack 00000a04  341c3544  341c3544  00020178  2**0
                  ALLOC
 13 .usbx_data    000004e4  341fc800  341fc800  0001f800  2**2
                  ALLOC
 14 .usbx_bss     00001c00  341fd800  341fd800  0001f800  2**2
                  ALLOC
 15 .ARM.attributes 00000040  00000000  00000000  0001f640  2**0
                  CONTENTS, READONLY
 16 .debug_info   0009ad9d  00000000  00000000  0001f680  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_abbrev 00013e69  00000000  00000000  000ba41d  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_aranges 00004310  00000000  00000000  000ce288  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_rnglists 00003850  00000000  00000000  000d2598  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_macro  00079a8b  00000000  00000000  000d5de8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_line   00086579  00000000  00000000  0014f873  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .debug_str    0026e6f5  00000000  00000000  001d5dec  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 23 .comment      00000fd2  00000000  00000000  004444e1  2**0
                  CONTENTS, READONLY
 24 .iar.rtmodel  000000d8  00000000  00000000  004454b3  2**0
                  CONTENTS, READONLY
 25 .iar_vfe_header 00000008  00000000  00000000  0044558c  2**2
                  CONTENTS, READONLY
 26 .debug_frame  0000ee98  00000000  00000000  00445594  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 27 .debug_line_str 00000134  00000000  00000000  0045442c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 28 .debug_loclists 000020cd  00000000  00000000  00454560  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

3418074c <__do_global_dtors_aux>:
3418074c:	b510      	push	{r4, lr}
3418074e:	4c05      	ldr	r4, [pc, #20]	@ (34180764 <__do_global_dtors_aux+0x18>)
34180750:	7823      	ldrb	r3, [r4, #0]
34180752:	b933      	cbnz	r3, 34180762 <__do_global_dtors_aux+0x16>
34180754:	4b04      	ldr	r3, [pc, #16]	@ (34180768 <__do_global_dtors_aux+0x1c>)
34180756:	b113      	cbz	r3, 3418075e <__do_global_dtors_aux+0x12>
34180758:	4804      	ldr	r0, [pc, #16]	@ (3418076c <__do_global_dtors_aux+0x20>)
3418075a:	f3af 8000 	nop.w
3418075e:	2301      	movs	r3, #1
34180760:	7023      	strb	r3, [r4, #0]
34180762:	bd10      	pop	{r4, pc}
34180764:	341c0178 	.word	0x341c0178
34180768:	00000000 	.word	0x00000000
3418076c:	3419e150 	.word	0x3419e150

34180770 <frame_dummy>:
34180770:	b508      	push	{r3, lr}
34180772:	4b03      	ldr	r3, [pc, #12]	@ (34180780 <frame_dummy+0x10>)
34180774:	b11b      	cbz	r3, 3418077e <frame_dummy+0xe>
34180776:	4903      	ldr	r1, [pc, #12]	@ (34180784 <frame_dummy+0x14>)
34180778:	4803      	ldr	r0, [pc, #12]	@ (34180788 <frame_dummy+0x18>)
3418077a:	f3af 8000 	nop.w
3418077e:	bd08      	pop	{r3, pc}
34180780:	00000000 	.word	0x00000000
34180784:	341c017c 	.word	0x341c017c
34180788:	3419e150 	.word	0x3419e150

3418078c <_tx_initialize_low_level>:
    .thumb_func
.type _tx_initialize_low_level, function
_tx_initialize_low_level:

    /* Disable interrupts during ThreadX initialization.  */
    CPSID   i
3418078c:	b672      	cpsid	i
    LDR     r1, =__RAM_segment_used_end__           // Build first free address
    ADD     r1, r1, #4                              //
    STR     r1, [r0]                                // Setup first unused memory pointer
#endif
    /* Setup Vector Table Offset Register.  */
    MOV     r0, #0xE000E000                         // Build address of NVIC registers
3418078e:	f04f 20e0 	mov.w	r0, #3758153728	@ 0xe000e000
    LDR     r1, =g_pfnVectors                           // Pickup address of vector table
34180792:	4917      	ldr	r1, [pc, #92]	@ (341807f0 <__tx_DBGHandler+0x4>)
    STR     r1, [r0, #0xD08]                        // Set vector table address
34180794:	f8c0 1d08 	str.w	r1, [r0, #3336]	@ 0xd08

    /* Enable the cycle count register.  */
    LDR     r0, =0xE0001000                         // Build address of DWT register
34180798:	4816      	ldr	r0, [pc, #88]	@ (341807f4 <__tx_DBGHandler+0x8>)
    LDR     r1, [r0]                                // Pickup the current value
3418079a:	6801      	ldr	r1, [r0, #0]
    ORR     r1, r1, #1                              // Set the CYCCNTENA bit
3418079c:	f041 0101 	orr.w	r1, r1, #1
    STR     r1, [r0]                                // Enable the cycle count register
341807a0:	6001      	str	r1, [r0, #0]

    /* Set system stack pointer from vector value.  */
    LDR     r0, =_tx_thread_system_stack_ptr        // Build address of system stack pointer
341807a2:	4815      	ldr	r0, [pc, #84]	@ (341807f8 <__tx_DBGHandler+0xc>)
    LDR     r1, =g_pfnVectors                           // Pickup address of vector table
341807a4:	4912      	ldr	r1, [pc, #72]	@ (341807f0 <__tx_DBGHandler+0x4>)
    LDR     r1, [r1]                                // Pickup reset stack pointer
341807a6:	6809      	ldr	r1, [r1, #0]
    STR     r1, [r0]                                // Save system stack pointer
341807a8:	6001      	str	r1, [r0, #0]

    /* Configure SysTick.  */
    MOV     r0, #0xE000E000                         // Build address of NVIC registers
341807aa:	f04f 20e0 	mov.w	r0, #3758153728	@ 0xe000e000
    LDR     r1, =SYSTICK_CYCLES
341807ae:	4913      	ldr	r1, [pc, #76]	@ (341807fc <__tx_DBGHandler+0x10>)
    STR     r1, [r0, #0x14]                         // Setup SysTick Reload Value
341807b0:	6141      	str	r1, [r0, #20]
    MOV     r1, #0x7                                // Build SysTick Control Enable Value
341807b2:	f04f 0107 	mov.w	r1, #7
    STR     r1, [r0, #0x10]                         // Setup SysTick Control
341807b6:	6101      	str	r1, [r0, #16]

    /* Configure handler priorities.  */
    LDR     r1, =0x00000000                         // Rsrv, UsgF, BusF, MemM
341807b8:	f04f 0100 	mov.w	r1, #0
    STR     r1, [r0, #0xD18]                        // Setup System Handlers 4-7 Priority Registers
341807bc:	f8c0 1d18 	str.w	r1, [r0, #3352]	@ 0xd18
    LDR     r1, =0xFF000000                         // SVCl, Rsrv, Rsrv, Rsrv
341807c0:	f04f 417f 	mov.w	r1, #4278190080	@ 0xff000000
    STR     r1, [r0, #0xD1C]                        // Setup System Handlers 8-11 Priority Registers
341807c4:	f8c0 1d1c 	str.w	r1, [r0, #3356]	@ 0xd1c
                                                    // Note: SVC must be lowest priority, which is 0xFF
    LDR     r1, =0x40FF0000                         // SysT, PnSV, Rsrv, DbgM
341807c8:	490d      	ldr	r1, [pc, #52]	@ (34180800 <__tx_DBGHandler+0x14>)
    STR     r1, [r0, #0xD20]                        // Setup System Handlers 12-15 Priority Registers
341807ca:	f8c0 1d20 	str.w	r1, [r0, #3360]	@ 0xd20
                                                    // Note: PnSV must be lowest priority, which is 0xFF

    /* Return to caller.  */
    BX      lr
341807ce:	4770      	bx	lr

341807d0 <__tx_BadHandler>:
    .eabi_attribute Tag_ABI_align_preserved, 1
    .global  __tx_BadHandler
    .thumb_func
.type __tx_BadHandler, function
__tx_BadHandler:
    B       __tx_BadHandler
341807d0:	f7ff bffe 	b.w	341807d0 <__tx_BadHandler>

341807d4 <__tx_IntHandler>:
    .thumb_func
.type __tx_IntHandler, function
__tx_IntHandler:
// VOID InterruptHandler (VOID)
// {
    PUSH    {r0,lr}     // Save LR (and dummy r0 to maintain stack alignment)
341807d4:	b501      	push	{r0, lr}
    /* Do interrupt handler work here */
    /* .... */
#if (defined(TX_ENABLE_EXECUTION_CHANGE_NOTIFY) || defined(TX_EXECUTION_PROFILE_ENABLE))
    BL      _tx_execution_isr_exit              // Call the ISR exit function
#endif
    POP     {r0,lr}
341807d6:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
    BX      lr
341807da:	4770      	bx	lr

341807dc <SysTick_Handler>:
    .thumb_func
.type SysTick_Handler, function
SysTick_Handler:
// VOID TimerInterruptHandler (VOID)
// {
    PUSH    {r0,lr}     // Save LR (and dummy r0 to maintain stack alignment)
341807dc:	b501      	push	{r0, lr}
#if (defined(TX_ENABLE_EXECUTION_CHANGE_NOTIFY) || defined(TX_EXECUTION_PROFILE_ENABLE))
    BL      _tx_execution_isr_enter             // Call the ISR enter function
#endif
    BL      _tx_timer_interrupt
341807de:	f000 f897 	bl	34180910 <_tx_timer_interrupt>
#if (defined(TX_ENABLE_EXECUTION_CHANGE_NOTIFY) || defined(TX_EXECUTION_PROFILE_ENABLE))
    BL      _tx_execution_isr_exit              // Call the ISR exit function
#endif
    POP     {r0,lr}
341807e2:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
    BX      lr
341807e6:	4770      	bx	lr

341807e8 <__tx_NMIHandler>:
    .eabi_attribute Tag_ABI_align_preserved, 1
    .global  __tx_NMIHandler
    .thumb_func
.type __tx_NMIHandler, function
__tx_NMIHandler:
    B       __tx_NMIHandler
341807e8:	f7ff bffe 	b.w	341807e8 <__tx_NMIHandler>

341807ec <__tx_DBGHandler>:
    .eabi_attribute Tag_ABI_align_preserved, 1
    .global  __tx_DBGHandler
    .thumb_func
.type __tx_DBGHandler, function
__tx_DBGHandler:
    B       __tx_DBGHandler
341807ec:	f7ff bffe 	b.w	341807ec <__tx_DBGHandler>
    LDR     r1, =g_pfnVectors                           // Pickup address of vector table
341807f0:	34180400 	.word	0x34180400
    LDR     r0, =0xE0001000                         // Build address of DWT register
341807f4:	e0001000 	.word	0xe0001000
    LDR     r0, =_tx_thread_system_stack_ptr        // Build address of system stack pointer
341807f8:	341c2de8 	.word	0x341c2de8
    LDR     r1, =SYSTICK_CYCLES
341807fc:	005b8d7f 	.word	0x005b8d7f
    LDR     r1, =0x40FF0000                         // SysT, PnSV, Rsrv, DbgM
34180800:	40ff0000 	.word	0x40ff0000

34180804 <_tx_thread_schedule>:
    /* This function should only ever be called on Cortex-M
       from the first schedule request. Subsequent scheduling occurs
       from the PendSV handling routine below. */

    /* Clear the preempt-disable flag to enable rescheduling after initialization on Cortex-M targets.  */
    MOV     r0, #0                                  // Build value for TX_FALSE
34180804:	f04f 0000 	mov.w	r0, #0
    LDR     r2, =_tx_thread_preempt_disable         // Build address of preempt disable flag
34180808:	4a2d      	ldr	r2, [pc, #180]	@ (341808c0 <_tx_vfp_access+0x4>)
    STR     r0, [r2, #0]                            // Clear preempt disable flag
3418080a:	6010      	str	r0, [r2, #0]

#ifdef __ARM_FP
    /* Clear CONTROL.FPCA bit so VFP registers aren't unnecessarily stacked.  */
    MRS     r0, CONTROL                             // Pickup current CONTROL register
3418080c:	f3ef 8014 	mrs	r0, CONTROL
    BIC     r0, r0, #4                              // Clear the FPCA bit
34180810:	f020 0004 	bic.w	r0, r0, #4
    MSR     CONTROL, r0                             // Setup new CONTROL register
34180814:	f380 8814 	msr	CONTROL, r0
#endif

    /* Enable interrupts */
    CPSIE   i
34180818:	b662      	cpsie	i

    /* Enter the scheduler for the first time.  */
    MOV     r0, #0x10000000                         // Load PENDSVSET bit
3418081a:	f04f 5080 	mov.w	r0, #268435456	@ 0x10000000
    MOV     r1, #0xE000E000                         // Load NVIC base
3418081e:	f04f 21e0 	mov.w	r1, #3758153728	@ 0xe000e000
    STR     r0, [r1, #0xD04]                        // Set PENDSVBIT in ICSR
34180822:	f8c1 0d04 	str.w	r0, [r1, #3332]	@ 0xd04
    DSB                                             // Complete all memory accesses
34180826:	f3bf 8f4f 	dsb	sy
    ISB                                             // Flush pipeline
3418082a:	f3bf 8f6f 	isb	sy

3418082e <__tx_wait_here>:

    /* Wait here for the PendSV to take place.  */

__tx_wait_here:
    B       __tx_wait_here                          // Wait for the PendSV to happen
3418082e:	e7fe      	b.n	3418082e <__tx_wait_here>

34180830 <PendSV_Handler>:
#else
    CPSIE   i                                       // Enable interrupts
#endif  /* TX_PORT_USE_BASEPRI */
#endif  /* EXECUTION PROFILE */

    LDR     r0, =_tx_thread_current_ptr             // Build current thread pointer address
34180830:	4824      	ldr	r0, [pc, #144]	@ (341808c4 <_tx_vfp_access+0x8>)
    LDR     r2, =_tx_thread_execute_ptr             // Build execute thread pointer address
34180832:	4a25      	ldr	r2, [pc, #148]	@ (341808c8 <_tx_vfp_access+0xc>)
    MOV     r3, #0                                  // Build NULL value
34180834:	f04f 0300 	mov.w	r3, #0
    LDR     r1, [r0]                                // Pickup current thread pointer
34180838:	6801      	ldr	r1, [r0, #0]

    /* Determine if there is a current thread to finish preserving.  */

    CBZ     r1, __tx_ts_new                         // If NULL, skip preservation
3418083a:	b191      	cbz	r1, 34180862 <__tx_ts_new>

    /* Recover PSP and preserve current thread context.  */

    STR     r3, [r0]                                // Set _tx_thread_current_ptr to NULL
3418083c:	6003      	str	r3, [r0, #0]
    MRS     r12, PSP                                // Pickup PSP pointer (thread's stack pointer)
3418083e:	f3ef 8c09 	mrs	ip, PSP
    STMDB   r12!, {r4-r11}                          // Save its remaining registers
34180842:	e92c 0ff0 	stmdb	ip!, {r4, r5, r6, r7, r8, r9, sl, fp}
#ifdef __ARM_FP
    TST     LR, #0x10                               // Determine if the VFP extended frame is present
34180846:	f01e 0f10 	tst.w	lr, #16
    BNE     _skip_vfp_save
3418084a:	d101      	bne.n	34180850 <_skip_vfp_save>
    VSTMDB  r12!,{s16-s31}                          // Yes, save additional VFP registers
3418084c:	ed2c 8a10 	vstmdb	ip!, {s16-s31}

34180850 <_skip_vfp_save>:
_skip_vfp_save:
#endif
    LDR     r4, =_tx_timer_time_slice               // Build address of time-slice variable
34180850:	4c1e      	ldr	r4, [pc, #120]	@ (341808cc <_tx_vfp_access+0x10>)
    STMDB   r12!, {LR}                              // Save LR on the stack
34180852:	f84c ed04 	str.w	lr, [ip, #-4]!
    STR     r12, [r1, #8]                           // Save the thread stack pointer
34180856:	f8c1 c008 	str.w	ip, [r1, #8]
_skip_secure_save:
#endif

    /* Determine if time-slice is active. If it isn't, skip time handling processing.  */

    LDR     r5, [r4]                                // Pickup current time-slice
3418085a:	6825      	ldr	r5, [r4, #0]
    CBZ     r5, __tx_ts_new                         // If not active, skip processing
3418085c:	b10d      	cbz	r5, 34180862 <__tx_ts_new>

    /* Time-slice is active, save the current thread's time-slice and clear the global time-slice variable.  */

    STR     r5, [r1, #24]                           // Save current time-slice
3418085e:	618d      	str	r5, [r1, #24]

    /* Clear the global time-slice.  */

    STR     r3, [r4]                                // Clear time-slice
34180860:	6023      	str	r3, [r4, #0]

34180862 <__tx_ts_new>:

#ifdef TX_PORT_USE_BASEPRI
    LDR     r1, =TX_PORT_BASEPRI                    // Mask interrupt priorities =< TX_PORT_BASEPRI
    MSR     BASEPRI, r1
#else
    CPSID   i                                       // Disable interrupts
34180862:	b672      	cpsid	i
#endif
    LDR     r1, [r2]                                // Is there another thread ready to execute?
34180864:	6811      	ldr	r1, [r2, #0]
    CBZ     r1, __tx_ts_wait                        // No, skip to the wait processing
34180866:	b1d1      	cbz	r1, 3418089e <__tx_ts_wait>

    /* Yes, another thread is ready for else, make the current thread the new thread.  */

    STR     r1, [r0]                                // Setup the current thread pointer to the new thread
34180868:	6001      	str	r1, [r0, #0]
#ifdef TX_PORT_USE_BASEPRI
    MOV     r4, #0                                  // Disable BASEPRI masking (enable interrupts)
    MSR     BASEPRI, r4
#else
    CPSIE   i                                       // Enable interrupts
3418086a:	b662      	cpsie	i

3418086c <__tx_ts_restore>:
#endif

    /* Increment the thread run count.  */

__tx_ts_restore:
    LDR     r7, [r1, #4]                            // Pickup the current thread run count
3418086c:	684f      	ldr	r7, [r1, #4]
    LDR     r4, =_tx_timer_time_slice               // Build address of time-slice variable
3418086e:	4c17      	ldr	r4, [pc, #92]	@ (341808cc <_tx_vfp_access+0x10>)
    LDR     r5, [r1, #24]                           // Pickup thread's current time-slice
34180870:	698d      	ldr	r5, [r1, #24]
    ADD     r7, r7, #1                              // Increment the thread run count
34180872:	f107 0701 	add.w	r7, r7, #1
    STR     r7, [r1, #4]                            // Store the new run count
34180876:	604f      	str	r7, [r1, #4]

    /* Setup global time-slice with thread's current time-slice.  */

    STR     r5, [r4]                                // Setup global time-slice
34180878:	6025      	str	r5, [r4, #0]
    POP     {r0,r1}                                 // Restore r1 (and dummy r0)
_skip_secure_restore:
#endif

    /* Restore the thread context and PSP.  */
    LDR     r12, [r1, #12]                          // Get stack start
3418087a:	f8d1 c00c 	ldr.w	ip, [r1, #12]
    MSR     PSPLIM, r12                             // Set stack limit
3418087e:	f38c 880b 	msr	PSPLIM, ip
    LDR     r12, [r1, #8]                           // Pickup thread's stack pointer
34180882:	f8d1 c008 	ldr.w	ip, [r1, #8]
    LDMIA   r12!, {LR}                              // Pickup LR
34180886:	f85c eb04 	ldr.w	lr, [ip], #4
#ifdef __ARM_FP
    TST     LR, #0x10                               // Determine if the VFP extended frame is present
3418088a:	f01e 0f10 	tst.w	lr, #16
    BNE     _skip_vfp_restore                       // If not, skip VFP restore
3418088e:	d101      	bne.n	34180894 <_skip_vfp_restore>
    VLDMIA  r12!, {s16-s31}                         // Yes, restore additional VFP registers
34180890:	ecbc 8a10 	vldmia	ip!, {s16-s31}

34180894 <_skip_vfp_restore>:
_skip_vfp_restore:
#endif
    LDMIA   r12!, {r4-r11}                          // Recover thread's registers
34180894:	e8bc 0ff0 	ldmia.w	ip!, {r4, r5, r6, r7, r8, r9, sl, fp}
    MSR     PSP, r12                                // Setup the thread's stack pointer
34180898:	f38c 8809 	msr	PSP, ip

    BX      lr                                      // Return to thread!
3418089c:	4770      	bx	lr

3418089e <__tx_ts_wait>:
__tx_ts_wait:
#ifdef TX_PORT_USE_BASEPRI
    LDR     r1, =TX_PORT_BASEPRI                    // Mask interrupt priorities =< TX_PORT_BASEPRI
    MSR     BASEPRI, r1
#else
    CPSID   i                                       // Disable interrupts
3418089e:	b672      	cpsid	i
#endif
    LDR     r1, [r2]                                // Pickup the next thread to execute pointer
341808a0:	6811      	ldr	r1, [r2, #0]
    STR     r1, [r0]                                // Store it in the current pointer
341808a2:	6001      	str	r1, [r0, #0]
    CBNZ    r1, __tx_ts_ready                       // If non-NULL, a new thread is ready!
341808a4:	b909      	cbnz	r1, 341808aa <__tx_ts_ready>

#ifdef TX_PORT_USE_BASEPRI
    MOV     r4, #0                                  // Disable BASEPRI masking (enable interrupts)
    MSR     BASEPRI, r4
#else
    CPSIE   i                                       // Enable interrupts
341808a6:	b662      	cpsie	i
#endif
    B       __tx_ts_wait                            // Loop to continue waiting
341808a8:	e7f9      	b.n	3418089e <__tx_ts_wait>

341808aa <__tx_ts_ready>:

    /* At this point, we have a new thread ready to go. Clear any newly pended PendSV - since we are
       already in the handler!  */
__tx_ts_ready:
    MOV     r7, #0x08000000                         // Build clear PendSV value
341808aa:	f04f 6700 	mov.w	r7, #134217728	@ 0x8000000
    MOV     r8, #0xE000E000                         // Build base NVIC address
341808ae:	f04f 28e0 	mov.w	r8, #3758153728	@ 0xe000e000
    STR     r7, [r8, #0xD04]                        // Clear any PendSV
341808b2:	f8c8 7d04 	str.w	r7, [r8, #3332]	@ 0xd04
    /* Re-enable interrupts and restore new thread.  */
#ifdef TX_PORT_USE_BASEPRI
    MOV     r4, #0                                  // Disable BASEPRI masking (enable interrupts)
    MSR     BASEPRI, r4
#else
    CPSIE   i                                       // Enable interrupts
341808b6:	b662      	cpsie	i
#endif
    B       __tx_ts_restore                         // Restore the thread
341808b8:	e7d8      	b.n	3418086c <__tx_ts_restore>
341808ba:	bf00      	nop

341808bc <_tx_vfp_access>:
.type _tx_vfp_access, function
_tx_vfp_access:
#if TX_ENABLE_FPU_SUPPORT
    VMOV.F32 s0, s0                                 // Simply access the VFP
#endif
    BX       lr                                     // Return to caller
341808bc:	4770      	bx	lr
341808be:	0000      	.short	0x0000
    LDR     r2, =_tx_thread_preempt_disable         // Build address of preempt disable flag
341808c0:	341c2e84 	.word	0x341c2e84
    LDR     r0, =_tx_thread_current_ptr             // Build current thread pointer address
341808c4:	341c2dec 	.word	0x341c2dec
    LDR     r2, =_tx_thread_execute_ptr             // Build execute thread pointer address
341808c8:	341c2df0 	.word	0x341c2df0
    LDR     r4, =_tx_timer_time_slice               // Build address of time-slice variable
341808cc:	341c33f0 	.word	0x341c33f0

341808d0 <_tx_thread_stack_build>:
                       pc          Initial value for pc
                       xPSR        Initial value for xPSR

    Stack Bottom: (higher memory address)  */

    LDR     r2, [r0, #16]                           // Pickup end of stack area
341808d0:	6902      	ldr	r2, [r0, #16]
    BIC     r2, r2, #0x7                            // Align frame for 8-byte alignment
341808d2:	f022 0207 	bic.w	r2, r2, #7
    SUB     r2, r2, #68                             // Subtract frame size
341808d6:	f1a2 0244 	sub.w	r2, r2, #68	@ 0x44
#ifdef TX_SINGLE_MODE_SECURE
    LDR     r3, =0xFFFFFFFD                         // Build initial LR value for secure mode
341808da:	f06f 0302 	mvn.w	r3, #2
#else
    LDR     r3, =0xFFFFFFBC                         // Build initial LR value to return to non-secure PSP
#endif
    STR     r3, [r2, #0]                            // Save on the stack
341808de:	6013      	str	r3, [r2, #0]

    /* Actually build the stack frame.  */

    MOV     r3, #0                                  // Build initial register value
341808e0:	f04f 0300 	mov.w	r3, #0
    STR     r3, [r2, #4]                            // Store initial r4
341808e4:	6053      	str	r3, [r2, #4]
    STR     r3, [r2, #8]                            // Store initial r5
341808e6:	6093      	str	r3, [r2, #8]
    STR     r3, [r2, #12]                           // Store initial r6
341808e8:	60d3      	str	r3, [r2, #12]
    STR     r3, [r2, #16]                           // Store initial r7
341808ea:	6113      	str	r3, [r2, #16]
    STR     r3, [r2, #20]                           // Store initial r8
341808ec:	6153      	str	r3, [r2, #20]
    STR     r3, [r2, #24]                           // Store initial r9
341808ee:	6193      	str	r3, [r2, #24]
    STR     r3, [r2, #28]                           // Store initial r10
341808f0:	61d3      	str	r3, [r2, #28]
    STR     r3, [r2, #32]                           // Store initial r11
341808f2:	6213      	str	r3, [r2, #32]

    /* Hardware stack follows.  */

    STR     r3, [r2, #36]                           // Store initial r0
341808f4:	6253      	str	r3, [r2, #36]	@ 0x24
    STR     r3, [r2, #40]                           // Store initial r1
341808f6:	6293      	str	r3, [r2, #40]	@ 0x28
    STR     r3, [r2, #44]                           // Store initial r2
341808f8:	62d3      	str	r3, [r2, #44]	@ 0x2c
    STR     r3, [r2, #48]                           // Store initial r3
341808fa:	6313      	str	r3, [r2, #48]	@ 0x30
    STR     r3, [r2, #52]                           // Store initial r12
341808fc:	6353      	str	r3, [r2, #52]	@ 0x34
    MOV     r3, #0xFFFFFFFF                         // Poison EXC_RETURN value
341808fe:	f04f 33ff 	mov.w	r3, #4294967295
    STR     r3, [r2, #56]                           // Store initial lr
34180902:	6393      	str	r3, [r2, #56]	@ 0x38
    STR     r1, [r2, #60]                           // Store initial pc
34180904:	63d1      	str	r1, [r2, #60]	@ 0x3c
    MOV     r3, #0x01000000                         // Only T-bit need be set
34180906:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
    STR     r3, [r2, #64]                           // Store initial xPSR
3418090a:	6413      	str	r3, [r2, #64]	@ 0x40

    /* Setup stack pointer.  */
    // thread_ptr -> tx_thread_stack_ptr =  r2;

    STR     r2, [r0, #8]                            // Save stack pointer in thread's
3418090c:	6082      	str	r2, [r0, #8]
                                                    //   control block
    BX      lr                                      // Return to caller
3418090e:	4770      	bx	lr

34180910 <_tx_timer_interrupt>:
       for use.  */

    /* Increment the system clock.  */
    // _tx_timer_system_clock++;

    LDR     r1, =_tx_timer_system_clock             // Pickup address of system clock
34180910:	4922      	ldr	r1, [pc, #136]	@ (3418099c <__tx_timer_nothing_expired+0x8>)
    LDR     r0, [r1, #0]                            // Pickup system clock
34180912:	6808      	ldr	r0, [r1, #0]
    ADD     r0, r0, #1                              // Increment system clock
34180914:	f100 0001 	add.w	r0, r0, #1
    STR     r0, [r1, #0]                            // Store new system clock
34180918:	6008      	str	r0, [r1, #0]

    /* Test for time-slice expiration.  */
    // if (_tx_timer_time_slice)
    // {

    LDR     r3, =_tx_timer_time_slice               // Pickup address of time-slice
3418091a:	4b21      	ldr	r3, [pc, #132]	@ (341809a0 <__tx_timer_nothing_expired+0xc>)
    LDR     r2, [r3, #0]                            // Pickup time-slice
3418091c:	681a      	ldr	r2, [r3, #0]
    CBZ     r2, __tx_timer_no_time_slice            // Is it non-active?
3418091e:	b13a      	cbz	r2, 34180930 <__tx_timer_no_time_slice>
                                                    // Yes, skip time-slice processing

       /* Decrement the time_slice.  */
       // _tx_timer_time_slice--;

    SUB     r2, r2, #1                              // Decrement the time-slice
34180920:	f1a2 0201 	sub.w	r2, r2, #1
    STR     r2, [r3, #0]                            // Store new time-slice value
34180924:	601a      	str	r2, [r3, #0]

       /* Check for expiration.  */
       // if (__tx_timer_time_slice == 0)

    CBNZ    r2, __tx_timer_no_time_slice            // Has it expired?
34180926:	b91a      	cbnz	r2, 34180930 <__tx_timer_no_time_slice>
                                                    // No, skip expiration processing

       /* Set the time-slice expired flag.  */
       // _tx_timer_expired_time_slice =  TX_TRUE;

    LDR     r3, =_tx_timer_expired_time_slice       // Pickup address of expired flag
34180928:	4b1e      	ldr	r3, [pc, #120]	@ (341809a4 <__tx_timer_nothing_expired+0x10>)
    MOV     r0, #1                                  // Build expired value
3418092a:	f04f 0001 	mov.w	r0, #1
    STR     r0, [r3, #0]                            // Set time-slice expiration flag
3418092e:	6018      	str	r0, [r3, #0]

34180930 <__tx_timer_no_time_slice>:

    /* Test for timer expiration.  */
    // if (*_tx_timer_current_ptr)
    // {

    LDR     r1, =_tx_timer_current_ptr              // Pickup current timer pointer address
34180930:	491d      	ldr	r1, [pc, #116]	@ (341809a8 <__tx_timer_nothing_expired+0x14>)
    LDR     r0, [r1, #0]                            // Pickup current timer
34180932:	6808      	ldr	r0, [r1, #0]
    LDR     r2, [r0, #0]                            // Pickup timer list entry
34180934:	6802      	ldr	r2, [r0, #0]
    CBZ     r2, __tx_timer_no_timer                 // Is there anything in the list?
34180936:	b122      	cbz	r2, 34180942 <__tx_timer_no_timer>
                                                    // No, just increment the timer

        /* Set expiration flag.  */
        // _tx_timer_expired =  TX_TRUE;

    LDR     r3, =_tx_timer_expired                  // Pickup expiration flag address
34180938:	4b1c      	ldr	r3, [pc, #112]	@ (341809ac <__tx_timer_nothing_expired+0x18>)
    MOV     r2, #1                                  // Build expired value
3418093a:	f04f 0201 	mov.w	r2, #1
    STR     r2, [r3, #0]                            // Set expired flag
3418093e:	601a      	str	r2, [r3, #0]
    B       __tx_timer_done                         // Finished timer processing
34180940:	e008      	b.n	34180954 <__tx_timer_done>

34180942 <__tx_timer_no_timer>:
__tx_timer_no_timer:

        /* No timer expired, increment the timer pointer.  */
        // _tx_timer_current_ptr++;

    ADD     r0, r0, #4                              // Move to next timer
34180942:	f100 0004 	add.w	r0, r0, #4

        /* Check for wrap-around.  */
        // if (_tx_timer_current_ptr == _tx_timer_list_end)

    LDR     r3, =_tx_timer_list_end                 // Pickup addr of timer list end
34180946:	4b1a      	ldr	r3, [pc, #104]	@ (341809b0 <__tx_timer_nothing_expired+0x1c>)
    LDR     r2, [r3, #0]                            // Pickup list end
34180948:	681a      	ldr	r2, [r3, #0]
    CMP     r0, r2                                  // Are we at list end?
3418094a:	4290      	cmp	r0, r2
    BNE     __tx_timer_skip_wrap                    // No, skip wrap-around logic
3418094c:	d101      	bne.n	34180952 <__tx_timer_skip_wrap>

            /* Wrap to beginning of list.  */
            // _tx_timer_current_ptr =  _tx_timer_list_start;

    LDR     r3, =_tx_timer_list_start               // Pickup addr of timer list start
3418094e:	4b19      	ldr	r3, [pc, #100]	@ (341809b4 <__tx_timer_nothing_expired+0x20>)
    LDR     r0, [r3, #0]                            // Set current pointer to list start
34180950:	6818      	ldr	r0, [r3, #0]

34180952 <__tx_timer_skip_wrap>:

__tx_timer_skip_wrap:

    STR     r0, [r1, #0]                            // Store new current timer pointer
34180952:	6008      	str	r0, [r1, #0]

34180954 <__tx_timer_done>:

    /* See if anything has expired.  */
    // if ((_tx_timer_expired_time_slice) || (_tx_timer_expired))
    // {

    LDR     r3, =_tx_timer_expired_time_slice       // Pickup addr of expired flag
34180954:	4b13      	ldr	r3, [pc, #76]	@ (341809a4 <__tx_timer_nothing_expired+0x10>)
    LDR     r2, [r3, #0]                            // Pickup time-slice expired flag
34180956:	681a      	ldr	r2, [r3, #0]
    CBNZ    r2, __tx_something_expired              // Did a time-slice expire?
34180958:	b912      	cbnz	r2, 34180960 <__tx_something_expired>
                                                    // If non-zero, time-slice expired
    LDR     r1, =_tx_timer_expired                  // Pickup addr of other expired flag
3418095a:	4914      	ldr	r1, [pc, #80]	@ (341809ac <__tx_timer_nothing_expired+0x18>)
    LDR     r0, [r1, #0]                            // Pickup timer expired flag
3418095c:	6808      	ldr	r0, [r1, #0]
    CBZ     r0, __tx_timer_nothing_expired          // Did a timer expire?
3418095e:	b1c8      	cbz	r0, 34180994 <__tx_timer_nothing_expired>

34180960 <__tx_something_expired>:
                                                    // No, nothing expired

__tx_something_expired:

    PUSH    {r0, lr}                                // Save the lr register on the stack
34180960:	b501      	push	{r0, lr}

    /* Did a timer expire?  */
    // if (_tx_timer_expired)
    // {

    LDR     r1, =_tx_timer_expired                  // Pickup addr of expired flag
34180962:	4912      	ldr	r1, [pc, #72]	@ (341809ac <__tx_timer_nothing_expired+0x18>)
    LDR     r0, [r1, #0]                            // Pickup timer expired flag
34180964:	6808      	ldr	r0, [r1, #0]
    CBZ     r0, __tx_timer_dont_activate            // Check for timer expiration
34180966:	b108      	cbz	r0, 3418096c <__tx_timer_dont_activate>
                                                    // If not set, skip timer activation

        /* Process timer expiration.  */
        // _tx_timer_expiration_process();

    BL      _tx_timer_expiration_process            // Call the timer expiration handling routine
34180968:	f017 fbd0 	bl	3419810c <_tx_timer_expiration_process>

3418096c <__tx_timer_dont_activate>:

    /* Did time slice expire?  */
    // if (_tx_timer_expired_time_slice)
    // {

    LDR     r3, =_tx_timer_expired_time_slice       // Pickup addr of time-slice expired
3418096c:	4b0d      	ldr	r3, [pc, #52]	@ (341809a4 <__tx_timer_nothing_expired+0x10>)
    LDR     r2, [r3, #0]                            // Pickup the actual flag
3418096e:	681a      	ldr	r2, [r3, #0]
    CBZ     r2, __tx_timer_not_ts_expiration        // See if the flag is set
34180970:	b172      	cbz	r2, 34180990 <__tx_timer_not_ts_expiration>
                                                    // No, skip time-slice processing

        /* Time slice interrupted thread.  */
        // _tx_thread_time_slice();

    BL      _tx_thread_time_slice                   // Call time-slice processing
34180972:	f017 fb1f 	bl	34197fb4 <_tx_thread_time_slice>
    LDR     r0, =_tx_thread_preempt_disable         // Build address of preempt disable flag
34180976:	4810      	ldr	r0, [pc, #64]	@ (341809b8 <__tx_timer_nothing_expired+0x24>)
    LDR     r1, [r0]                                // Is the preempt disable flag set?
34180978:	6801      	ldr	r1, [r0, #0]
    CBNZ    r1, __tx_timer_skip_time_slice          // Yes, skip the PendSV logic
3418097a:	b949      	cbnz	r1, 34180990 <__tx_timer_not_ts_expiration>
    LDR     r0, =_tx_thread_current_ptr             // Build current thread pointer address
3418097c:	480f      	ldr	r0, [pc, #60]	@ (341809bc <__tx_timer_nothing_expired+0x28>)
    LDR     r1, [r0]                                // Pickup the current thread pointer
3418097e:	6801      	ldr	r1, [r0, #0]
    LDR     r2, =_tx_thread_execute_ptr             // Build execute thread pointer address
34180980:	4a0f      	ldr	r2, [pc, #60]	@ (341809c0 <__tx_timer_nothing_expired+0x2c>)
    LDR     r3, [r2]                                // Pickup the execute thread pointer
34180982:	6813      	ldr	r3, [r2, #0]
    LDR     r0, =0xE000ED04                         // Build address of control register
34180984:	480f      	ldr	r0, [pc, #60]	@ (341809c4 <__tx_timer_nothing_expired+0x30>)
    LDR     r2, =0x10000000                         // Build value for PendSV bit
34180986:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
    CMP     r1, r3                                  // Are they the same?
3418098a:	4299      	cmp	r1, r3
    BEQ     __tx_timer_skip_time_slice              // If the same, there was no time-slice performed
3418098c:	d000      	beq.n	34180990 <__tx_timer_not_ts_expiration>
    STR     r2, [r0]                                // Not the same, issue the PendSV for preemption
3418098e:	6002      	str	r2, [r0, #0]

34180990 <__tx_timer_not_ts_expiration>:
__tx_timer_skip_time_slice:
    // }

__tx_timer_not_ts_expiration:

    POP     {r0, lr}                                // Recover lr register (r0 is just there for
34180990:	e8bd 4001 	ldmia.w	sp!, {r0, lr}

34180994 <__tx_timer_nothing_expired>:

    // }

__tx_timer_nothing_expired:

    DSB                                             // Complete all memory access
34180994:	f3bf 8f4f 	dsb	sy
    BX      lr                                      // Return to caller
34180998:	4770      	bx	lr
3418099a:	0000      	.short	0x0000
    LDR     r1, =_tx_timer_system_clock             // Pickup address of system clock
3418099c:	341c2e90 	.word	0x341c2e90
    LDR     r3, =_tx_timer_time_slice               // Pickup address of time-slice
341809a0:	341c33f0 	.word	0x341c33f0
    LDR     r3, =_tx_timer_expired_time_slice       // Pickup address of expired flag
341809a4:	341c2e94 	.word	0x341c2e94
    LDR     r1, =_tx_timer_current_ptr              // Pickup current timer pointer address
341809a8:	341c2f20 	.word	0x341c2f20
    LDR     r3, =_tx_timer_expired                  // Pickup expiration flag address
341809ac:	341c2f24 	.word	0x341c2f24
    LDR     r3, =_tx_timer_list_end                 // Pickup addr of timer list end
341809b0:	341c2f1c 	.word	0x341c2f1c
    LDR     r3, =_tx_timer_list_start               // Pickup addr of timer list start
341809b4:	341c2f18 	.word	0x341c2f18
    LDR     r0, =_tx_thread_preempt_disable         // Build address of preempt disable flag
341809b8:	341c2e84 	.word	0x341c2e84
    LDR     r0, =_tx_thread_current_ptr             // Build current thread pointer address
341809bc:	341c2dec 	.word	0x341c2dec
    LDR     r2, =_tx_thread_execute_ptr             // Build execute thread pointer address
341809c0:	341c2df0 	.word	0x341c2df0
    LDR     r0, =0xE000ED04                         // Build address of control register
341809c4:	e000ed04 	.word	0xe000ed04

341809c8 <USBPD_CAD_Init>:
341809c8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
341809cc:	2600      	movs	r6, #0
341809ce:	4681      	mov	r9, r0
341809d0:	460c      	mov	r4, r1
341809d2:	4690      	mov	r8, r2
341809d4:	461f      	mov	r7, r3
341809d6:	2803      	cmp	r0, #3
341809d8:	bf28      	it	cs
341809da:	2601      	movcs	r6, #1
341809dc:	d219      	bcs.n	34180a12 <??USBPD_CAD_Init_0>
341809de:	b90c      	cbnz	r4, 341809e4 <??USBPD_CAD_Init_1>
341809e0:	2602      	movs	r6, #2
341809e2:	e016      	b.n	34180a12 <??USBPD_CAD_Init_0>

341809e4 <??USBPD_CAD_Init_1>:
341809e4:	200c      	movs	r0, #12
341809e6:	f01d fab5 	bl	3419df54 <malloc>
341809ea:	0005      	movs	r5, r0
341809ec:	bf08      	it	eq
341809ee:	2603      	moveq	r6, #3
341809f0:	d00f      	beq.n	34180a12 <??USBPD_CAD_Init_0>
341809f2:	210c      	movs	r1, #12
341809f4:	f01d fba8 	bl	3419e148 <__aeabi_memclr>
341809f8:	602f      	str	r7, [r5, #0]
341809fa:	722e      	strb	r6, [r5, #8]
341809fc:	606c      	str	r4, [r5, #4]
341809fe:	493b      	ldr	r1, [pc, #236]	@ (34180aec <??DataTable2>)
34180a00:	464a      	mov	r2, r9
34180a02:	f841 5022 	str.w	r5, [r1, r2, lsl #2]
34180a06:	6863      	ldr	r3, [r4, #4]
34180a08:	463a      	mov	r2, r7
34180a0a:	4641      	mov	r1, r8
34180a0c:	4648      	mov	r0, r9
34180a0e:	f012 ff59 	bl	341938c4 <CAD_Init>

34180a12 <??USBPD_CAD_Init_0>:
34180a12:	4630      	mov	r0, r6
34180a14:	e8bd 83f2 	ldmia.w	sp!, {r1, r4, r5, r6, r7, r8, r9, pc}

34180a18 <USBPD_CAD_PortEnable>:
34180a18:	2803      	cmp	r0, #3
34180a1a:	d203      	bcs.n	34180a24 <??USBPD_CAD_PortEnable_0>
34180a1c:	4a33      	ldr	r2, [pc, #204]	@ (34180aec <??DataTable2>)
34180a1e:	f852 0020 	ldr.w	r0, [r2, r0, lsl #2]
34180a22:	7201      	strb	r1, [r0, #8]

34180a24 <??USBPD_CAD_PortEnable_0>:
34180a24:	4770      	bx	lr

34180a26 <USBPD_CAD_Process>:
34180a26:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
34180a28:	2100      	movs	r1, #0
34180a2a:	f88d 1000 	strb.w	r1, [sp]
34180a2e:	9101      	str	r1, [sp, #4]
34180a30:	f04f 35ff 	mov.w	r5, #4294967295
34180a34:	2600      	movs	r6, #0
34180a36:	4c2d      	ldr	r4, [pc, #180]	@ (34180aec <??DataTable2>)

34180a38 <??USBPD_CAD_Process_0>:
34180a38:	f854 0026 	ldr.w	r0, [r4, r6, lsl #2]
34180a3c:	2800      	cmp	r0, #0
34180a3e:	d04f      	beq.n	34180ae0 <??USBPD_CAD_Process_1>
34180a40:	7a00      	ldrb	r0, [r0, #8]
34180a42:	2801      	cmp	r0, #1
34180a44:	d14c      	bne.n	34180ae0 <??USBPD_CAD_Process_1>
34180a46:	aa01      	add	r2, sp, #4
34180a48:	4669      	mov	r1, sp
34180a4a:	b2f0      	uxtb	r0, r6
34180a4c:	f013 f85e 	bl	34193b0c <CAD_StateMachine>
34180a50:	42a8      	cmp	r0, r5
34180a52:	bf98      	it	ls
34180a54:	4605      	movls	r5, r0
34180a56:	f89d 0000 	ldrb.w	r0, [sp]
34180a5a:	2801      	cmp	r0, #1
34180a5c:	d004      	beq.n	34180a68 <??USBPD_CAD_Process_2>
34180a5e:	2802      	cmp	r0, #2
34180a60:	bf18      	it	ne
34180a62:	2804      	cmpne	r0, #4
34180a64:	d012      	beq.n	34180a8c <??USBPD_CAD_Process_3>
34180a66:	e02e      	b.n	34180ac6 <??USBPD_CAD_Process_4>

34180a68 <??USBPD_CAD_Process_2>:
34180a68:	f854 0026 	ldr.w	r0, [r4, r6, lsl #2]
34180a6c:	6801      	ldr	r1, [r0, #0]
34180a6e:	680a      	ldr	r2, [r1, #0]
34180a70:	f422 5280 	bic.w	r2, r2, #4096	@ 0x1000
34180a74:	600a      	str	r2, [r1, #0]
34180a76:	6801      	ldr	r1, [r0, #0]
34180a78:	680b      	ldr	r3, [r1, #0]
34180a7a:	f023 03c0 	bic.w	r3, r3, #192	@ 0xc0
34180a7e:	600b      	str	r3, [r1, #0]
34180a80:	6800      	ldr	r0, [r0, #0]
34180a82:	6801      	ldr	r1, [r0, #0]
34180a84:	f421 41c0 	bic.w	r1, r1, #24576	@ 0x6000
34180a88:	6001      	str	r1, [r0, #0]
34180a8a:	e01f      	b.n	34180acc <??USBPD_CAD_Process_5>

34180a8c <??USBPD_CAD_Process_3>:
34180a8c:	f854 0026 	ldr.w	r0, [r4, r6, lsl #2]
34180a90:	9901      	ldr	r1, [sp, #4]
34180a92:	6802      	ldr	r2, [r0, #0]
34180a94:	6813      	ldr	r3, [r2, #0]
34180a96:	f001 0103 	and.w	r1, r1, #3
34180a9a:	f361 1387 	bfi	r3, r1, #6, #2
34180a9e:	6013      	str	r3, [r2, #0]
34180aa0:	6801      	ldr	r1, [r0, #0]
34180aa2:	680a      	ldr	r2, [r1, #0]
34180aa4:	f442 5280 	orr.w	r2, r2, #4096	@ 0x1000
34180aa8:	600a      	str	r2, [r1, #0]
34180aaa:	6801      	ldr	r1, [r0, #0]
34180aac:	6808      	ldr	r0, [r1, #0]
34180aae:	f3c0 0080 	ubfx	r0, r0, #2, #1
34180ab2:	b920      	cbnz	r0, 34180abe <??USBPD_CAD_Process_6>
34180ab4:	7808      	ldrb	r0, [r1, #0]
34180ab6:	f000 00f7 	and.w	r0, r0, #247	@ 0xf7
34180aba:	7008      	strb	r0, [r1, #0]
34180abc:	e003      	b.n	34180ac6 <??USBPD_CAD_Process_4>

34180abe <??USBPD_CAD_Process_6>:
34180abe:	780a      	ldrb	r2, [r1, #0]
34180ac0:	f042 0208 	orr.w	r2, r2, #8
34180ac4:	700a      	strb	r2, [r1, #0]

34180ac6 <??USBPD_CAD_Process_4>:
34180ac6:	f89d 0000 	ldrb.w	r0, [sp]
34180aca:	b148      	cbz	r0, 34180ae0 <??USBPD_CAD_Process_1>

34180acc <??USBPD_CAD_Process_5>:
34180acc:	f854 3026 	ldr.w	r3, [r4, r6, lsl #2]
34180ad0:	9a01      	ldr	r2, [sp, #4]
34180ad2:	f89d 1000 	ldrb.w	r1, [sp]
34180ad6:	685f      	ldr	r7, [r3, #4]
34180ad8:	b2f0      	uxtb	r0, r6
34180ada:	f8d7 c000 	ldr.w	ip, [r7]
34180ade:	47e0      	blx	ip

34180ae0 <??USBPD_CAD_Process_1>:
34180ae0:	1c76      	adds	r6, r6, #1
34180ae2:	2e03      	cmp	r6, #3
34180ae4:	d3a8      	bcc.n	34180a38 <??USBPD_CAD_Process_0>
34180ae6:	4628      	mov	r0, r5
34180ae8:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
	...

34180aec <??DataTable2>:
34180aec:	0194 341c                                   ...4

34180af0 <USBPD_CAD_AssertRd>:
34180af0:	b510      	push	{r4, lr}
34180af2:	4604      	mov	r4, r0
34180af4:	f013 fe58 	bl	341947a8 <USBPDM1_DeAssertRp>
34180af8:	4620      	mov	r0, r4
34180afa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
34180afe:	f013 be5f 	b.w	341947c0 <USBPDM1_AssertRd>

34180b02 <USBPD_CAD_AssertRp>:
34180b02:	b510      	push	{r4, lr}
34180b04:	4604      	mov	r4, r0
34180b06:	f013 fee5 	bl	341948d4 <USBPDM1_DeAssertRd>
34180b0a:	4620      	mov	r0, r4
34180b0c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
34180b10:	f013 bdae 	b.w	34194670 <USBPDM1_AssertRp>

34180b14 <USBPD_CAD_EnterErrorRecovery>:
34180b14:	f012 bf96 	b.w	34193a44 <CAD_Enter_ErrorRecovery>

34180b18 <USBPD_CAD_GetMemoryConsumption>:
34180b18:	2024      	movs	r0, #36	@ 0x24
34180b1a:	4770      	bx	lr

34180b1c <USBPD_PE_SetTrace>:
34180b1c:	0001      	movs	r1, r0
34180b1e:	bf08      	it	eq
34180b20:	f20f 0021 	addweq	r0, pc, #33	@ 0x21
34180b24:	4904      	ldr	r1, [pc, #16]	@ (34180b38 <??DataTable1>)
34180b26:	6008      	str	r0, [r1, #0]
34180b28:	4770      	bx	lr

34180b2a <USBPD_PE_CheckLIB>:
34180b2a:	4601      	mov	r1, r0
34180b2c:	2000      	movs	r0, #0
34180b2e:	4a03      	ldr	r2, [pc, #12]	@ (34180b3c <??DataTable1_1>)
34180b30:	4291      	cmp	r1, r2
34180b32:	bf08      	it	eq
34180b34:	2001      	moveq	r0, #1
34180b36:	4770      	bx	lr

34180b38 <??DataTable1>:
34180b38:	0000 341c                                   ...4

34180b3c <??DataTable1_1>:
34180b3c:	0100 0041                                   ..A.

34180b40 <USBPD_PE_GetMemoryConsumption>:
34180b40:	f7ff bfea 	b.w	34180b18 <USBPD_CAD_GetMemoryConsumption>

34180b44 <PE_Trace_Empty>:
34180b44:	4770      	bx	lr

34180b46 <__aeabi_memset>:
34180b46:	b470      	push	{r4, r5, r6}
34180b48:	0784      	lsls	r4, r0, #30
34180b4a:	d046      	beq.n	34180bda <__aeabi_memset+0x94>
34180b4c:	1e4c      	subs	r4, r1, #1
34180b4e:	2900      	cmp	r1, #0
34180b50:	d041      	beq.n	34180bd6 <__aeabi_memset+0x90>
34180b52:	b2d5      	uxtb	r5, r2
34180b54:	4603      	mov	r3, r0
34180b56:	e002      	b.n	34180b5e <__aeabi_memset+0x18>
34180b58:	1e61      	subs	r1, r4, #1
34180b5a:	b3e4      	cbz	r4, 34180bd6 <__aeabi_memset+0x90>
34180b5c:	460c      	mov	r4, r1
34180b5e:	f803 5b01 	strb.w	r5, [r3], #1
34180b62:	0799      	lsls	r1, r3, #30
34180b64:	d1f8      	bne.n	34180b58 <__aeabi_memset+0x12>
34180b66:	2c03      	cmp	r4, #3
34180b68:	d92e      	bls.n	34180bc8 <__aeabi_memset+0x82>
34180b6a:	b2d5      	uxtb	r5, r2
34180b6c:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
34180b70:	2c0f      	cmp	r4, #15
34180b72:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
34180b76:	d919      	bls.n	34180bac <__aeabi_memset+0x66>
34180b78:	4626      	mov	r6, r4
34180b7a:	f103 0110 	add.w	r1, r3, #16
34180b7e:	3e10      	subs	r6, #16
34180b80:	2e0f      	cmp	r6, #15
34180b82:	f841 5c10 	str.w	r5, [r1, #-16]
34180b86:	f841 5c0c 	str.w	r5, [r1, #-12]
34180b8a:	f841 5c08 	str.w	r5, [r1, #-8]
34180b8e:	f841 5c04 	str.w	r5, [r1, #-4]
34180b92:	f101 0110 	add.w	r1, r1, #16
34180b96:	d8f2      	bhi.n	34180b7e <__aeabi_memset+0x38>
34180b98:	f1a4 0110 	sub.w	r1, r4, #16
34180b9c:	f021 010f 	bic.w	r1, r1, #15
34180ba0:	f004 040f 	and.w	r4, r4, #15
34180ba4:	3110      	adds	r1, #16
34180ba6:	2c03      	cmp	r4, #3
34180ba8:	440b      	add	r3, r1
34180baa:	d90d      	bls.n	34180bc8 <__aeabi_memset+0x82>
34180bac:	461e      	mov	r6, r3
34180bae:	4621      	mov	r1, r4
34180bb0:	3904      	subs	r1, #4
34180bb2:	2903      	cmp	r1, #3
34180bb4:	f846 5b04 	str.w	r5, [r6], #4
34180bb8:	d8fa      	bhi.n	34180bb0 <__aeabi_memset+0x6a>
34180bba:	1f21      	subs	r1, r4, #4
34180bbc:	f021 0103 	bic.w	r1, r1, #3
34180bc0:	3104      	adds	r1, #4
34180bc2:	440b      	add	r3, r1
34180bc4:	f004 0403 	and.w	r4, r4, #3
34180bc8:	b12c      	cbz	r4, 34180bd6 <__aeabi_memset+0x90>
34180bca:	b2d2      	uxtb	r2, r2
34180bcc:	441c      	add	r4, r3
34180bce:	f803 2b01 	strb.w	r2, [r3], #1
34180bd2:	42a3      	cmp	r3, r4
34180bd4:	d1fb      	bne.n	34180bce <__aeabi_memset+0x88>
34180bd6:	bc70      	pop	{r4, r5, r6}
34180bd8:	4770      	bx	lr
34180bda:	460c      	mov	r4, r1
34180bdc:	4603      	mov	r3, r0
34180bde:	e7c2      	b.n	34180b66 <__aeabi_memset+0x20>

34180be0 <strlen>:
34180be0:	4603      	mov	r3, r0
34180be2:	f813 2b01 	ldrb.w	r2, [r3], #1
34180be6:	2a00      	cmp	r2, #0
34180be8:	d1fb      	bne.n	34180be2 <strlen+0x2>
34180bea:	1a18      	subs	r0, r3, r0
34180bec:	3801      	subs	r0, #1
34180bee:	4770      	bx	lr

34180bf0 <tx_application_define>:
  * @brief  Define the initial system.
  * @param  first_unused_memory : Pointer to the first unused memory
  * @retval None
  */
VOID tx_application_define(VOID *first_unused_memory)
{
34180bf0:	b580      	push	{r7, lr}
34180bf2:	b086      	sub	sp, #24
34180bf4:	af02      	add	r7, sp, #8
34180bf6:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN  tx_application_define_1*/

  /* USER CODE END  tx_application_define_1 */
#if (USE_STATIC_ALLOCATION == 1)
  UINT status = TX_SUCCESS;
34180bf8:	2300      	movs	r3, #0
34180bfa:	60fb      	str	r3, [r7, #12]
  VOID *memory_ptr;

  if (tx_byte_pool_create(&tx_app_byte_pool, "Tx App memory pool", tx_byte_pool_buffer, TX_APP_MEM_POOL_SIZE) != TX_SUCCESS)
34180bfc:	2334      	movs	r3, #52	@ 0x34
34180bfe:	9300      	str	r3, [sp, #0]
34180c00:	f44f 6380 	mov.w	r3, #1024	@ 0x400
34180c04:	4a24      	ldr	r2, [pc, #144]	@ (34180c98 <tx_application_define+0xa8>)
34180c06:	4925      	ldr	r1, [pc, #148]	@ (34180c9c <tx_application_define+0xac>)
34180c08:	4825      	ldr	r0, [pc, #148]	@ (34180ca0 <tx_application_define+0xb0>)
34180c0a:	f017 fd29 	bl	34198660 <_txe_byte_pool_create>
34180c0e:	4603      	mov	r3, r0
34180c10:	2b00      	cmp	r3, #0
34180c12:	d001      	beq.n	34180c18 <tx_application_define+0x28>
  {
    /* USER CODE BEGIN TX_Byte_Pool_Error */
    while(1)
34180c14:	bf00      	nop
34180c16:	e7fd      	b.n	34180c14 <tx_application_define+0x24>
  {
    /* USER CODE BEGIN TX_Byte_Pool_Success */

    /* USER CODE END TX_Byte_Pool_Success */

    memory_ptr = (VOID *)&tx_app_byte_pool;
34180c18:	4b21      	ldr	r3, [pc, #132]	@ (34180ca0 <tx_application_define+0xb0>)
34180c1a:	60bb      	str	r3, [r7, #8]
    status = App_ThreadX_Init(memory_ptr);
34180c1c:	68b8      	ldr	r0, [r7, #8]
34180c1e:	f000 f84d 	bl	34180cbc <App_ThreadX_Init>
34180c22:	60f8      	str	r0, [r7, #12]
    if (status != TX_SUCCESS)
34180c24:	68fb      	ldr	r3, [r7, #12]
34180c26:	2b00      	cmp	r3, #0
34180c28:	d001      	beq.n	34180c2e <tx_application_define+0x3e>
    {
      /* USER CODE BEGIN  App_ThreadX_Init_Error */
      while(1)
34180c2a:	bf00      	nop
34180c2c:	e7fd      	b.n	34180c2a <tx_application_define+0x3a>

    /* USER CODE END  App_ThreadX_Init_Success */

  }

  if (tx_byte_pool_create(&ux_device_app_byte_pool, "Ux App memory pool", ux_device_byte_pool_buffer, UX_DEVICE_APP_MEM_POOL_SIZE) != TX_SUCCESS)
34180c2e:	2334      	movs	r3, #52	@ 0x34
34180c30:	9300      	str	r3, [sp, #0]
34180c32:	f44f 53e0 	mov.w	r3, #7168	@ 0x1c00
34180c36:	4a1b      	ldr	r2, [pc, #108]	@ (34180ca4 <tx_application_define+0xb4>)
34180c38:	491b      	ldr	r1, [pc, #108]	@ (34180ca8 <tx_application_define+0xb8>)
34180c3a:	481c      	ldr	r0, [pc, #112]	@ (34180cac <tx_application_define+0xbc>)
34180c3c:	f017 fd10 	bl	34198660 <_txe_byte_pool_create>
34180c40:	4603      	mov	r3, r0
34180c42:	2b00      	cmp	r3, #0
34180c44:	d001      	beq.n	34180c4a <tx_application_define+0x5a>
  {
    /* USER CODE BEGIN UX_Device_Byte_Pool_Error */
    while(1)
34180c46:	bf00      	nop
34180c48:	e7fd      	b.n	34180c46 <tx_application_define+0x56>
  {
    /* USER CODE BEGIN UX_Device_Byte_Pool_Success */

    /* USER CODE END UX_Device_Byte_Pool_Success */

    memory_ptr = (VOID *)&ux_device_app_byte_pool;
34180c4a:	4b18      	ldr	r3, [pc, #96]	@ (34180cac <tx_application_define+0xbc>)
34180c4c:	60bb      	str	r3, [r7, #8]
    status = MX_USBX_Device_Init(memory_ptr);
34180c4e:	68b8      	ldr	r0, [r7, #8]
34180c50:	f001 fa96 	bl	34182180 <MX_USBX_Device_Init>
34180c54:	60f8      	str	r0, [r7, #12]
    if (status != UX_SUCCESS)
34180c56:	68fb      	ldr	r3, [r7, #12]
34180c58:	2b00      	cmp	r3, #0
34180c5a:	d001      	beq.n	34180c60 <tx_application_define+0x70>
    {
      /* USER CODE BEGIN  MX_USBX_Device_Init_Error */
      while(1)
34180c5c:	bf00      	nop
34180c5e:	e7fd      	b.n	34180c5c <tx_application_define+0x6c>

    /* USER CODE BEGIN MX_USBX_Device_Init_Success */

    /* USER CODE END MX_USBX_Device_Init_Success */
  }
  if (tx_byte_pool_create(&usbpd_app_byte_pool, "USBPD App memory pool", usbpd_byte_pool_buffer, USBPD_DEVICE_APP_MEM_POOL_SIZE) != TX_SUCCESS)
34180c60:	2334      	movs	r3, #52	@ 0x34
34180c62:	9300      	str	r3, [sp, #0]
34180c64:	f44f 53a0 	mov.w	r3, #5120	@ 0x1400
34180c68:	4a11      	ldr	r2, [pc, #68]	@ (34180cb0 <tx_application_define+0xc0>)
34180c6a:	4912      	ldr	r1, [pc, #72]	@ (34180cb4 <tx_application_define+0xc4>)
34180c6c:	4812      	ldr	r0, [pc, #72]	@ (34180cb8 <tx_application_define+0xc8>)
34180c6e:	f017 fcf7 	bl	34198660 <_txe_byte_pool_create>
34180c72:	4603      	mov	r3, r0
34180c74:	2b00      	cmp	r3, #0
34180c76:	d10a      	bne.n	34180c8e <tx_application_define+0x9e>
    {
    /* USER CODE BEGIN USBPD_Byte_Pool_Success */

    /* USER CODE END USBPD_Byte_Pool_Success */

    memory_ptr = (VOID *)&usbpd_app_byte_pool;
34180c78:	4b0f      	ldr	r3, [pc, #60]	@ (34180cb8 <tx_application_define+0xc8>)
34180c7a:	60bb      	str	r3, [r7, #8]
    status = MX_USBPD_Init(memory_ptr);
34180c7c:	68b8      	ldr	r0, [r7, #8]
34180c7e:	f000 ff84 	bl	34181b8a <MX_USBPD_Init>
34180c82:	60f8      	str	r0, [r7, #12]
    if (status != USBPD_OK)
34180c84:	68fb      	ldr	r3, [r7, #12]
34180c86:	2b00      	cmp	r3, #0
34180c88:	d001      	beq.n	34180c8e <tx_application_define+0x9e>
    {
      /* USER CODE BEGIN  MX_USBPD_Init_Error */
      while(1)
34180c8a:	bf00      	nop
34180c8c:	e7fd      	b.n	34180c8a <tx_application_define+0x9a>
  /* USER CODE BEGIN DYNAMIC_MEM_ALLOC */
  (void)first_unused_memory;
  /* USER CODE END DYNAMIC_MEM_ALLOC */
#endif

}
34180c8e:	bf00      	nop
34180c90:	3710      	adds	r7, #16
34180c92:	46bd      	mov	sp, r7
34180c94:	bd80      	pop	{r7, pc}
34180c96:	bf00      	nop
34180c98:	341c01a0 	.word	0x341c01a0
34180c9c:	3419e168 	.word	0x3419e168
34180ca0:	341c05a0 	.word	0x341c05a0
34180ca4:	341fd800 	.word	0x341fd800
34180ca8:	3419e17c 	.word	0x3419e17c
34180cac:	341c1a08 	.word	0x341c1a08
34180cb0:	341c05d4 	.word	0x341c05d4
34180cb4:	3419e190 	.word	0x3419e190
34180cb8:	341c19d4 	.word	0x341c19d4

34180cbc <App_ThreadX_Init>:
  * @brief  Application ThreadX Initialization.
  * @param memory_ptr: memory pointer
  * @retval int
  */
UINT App_ThreadX_Init(VOID *memory_ptr)
{
34180cbc:	b480      	push	{r7}
34180cbe:	b085      	sub	sp, #20
34180cc0:	af00      	add	r7, sp, #0
34180cc2:	6078      	str	r0, [r7, #4]
  UINT ret = TX_SUCCESS;
34180cc4:	2300      	movs	r3, #0
34180cc6:	60fb      	str	r3, [r7, #12]

  /* USER CODE BEGIN App_ThreadX_Init */

  /* USER CODE END App_ThreadX_Init */

  return ret;
34180cc8:	68fb      	ldr	r3, [r7, #12]
}
34180cca:	4618      	mov	r0, r3
34180ccc:	3714      	adds	r7, #20
34180cce:	46bd      	mov	sp, r7
34180cd0:	f85d 7b04 	ldr.w	r7, [sp], #4
34180cd4:	4770      	bx	lr

34180cd6 <MX_ThreadX_Init>:
  * @brief  Function that implements the kernel's initialization.
  * @param  None
  * @retval None
  */
void MX_ThreadX_Init(void)
{
34180cd6:	b580      	push	{r7, lr}
34180cd8:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN  Before_Kernel_Start */

  /* USER CODE END  Before_Kernel_Start */

  tx_kernel_enter();
34180cda:	f014 fd7f 	bl	341957dc <_tx_initialize_kernel_enter>

  /* USER CODE BEGIN  Kernel_Start_Error */

  /* USER CODE END  Kernel_Start_Error */
}
34180cde:	bf00      	nop
34180ce0:	bd80      	pop	{r7, pc}
	...

34180ce4 <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
34180ce4:	b480      	push	{r7}
34180ce6:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
34180ce8:	4b04      	ldr	r3, [pc, #16]	@ (34180cfc <__NVIC_GetPriorityGrouping+0x18>)
34180cea:	68db      	ldr	r3, [r3, #12]
34180cec:	0a1b      	lsrs	r3, r3, #8
34180cee:	f003 0307 	and.w	r3, r3, #7
}
34180cf2:	4618      	mov	r0, r3
34180cf4:	46bd      	mov	sp, r7
34180cf6:	f85d 7b04 	ldr.w	r7, [sp], #4
34180cfa:	4770      	bx	lr
34180cfc:	e000ed00 	.word	0xe000ed00

34180d00 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
34180d00:	b480      	push	{r7}
34180d02:	b083      	sub	sp, #12
34180d04:	af00      	add	r7, sp, #0
34180d06:	4603      	mov	r3, r0
34180d08:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
34180d0a:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
34180d0e:	2b00      	cmp	r3, #0
34180d10:	db0b      	blt.n	34180d2a <__NVIC_EnableIRQ+0x2a>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
34180d12:	88fb      	ldrh	r3, [r7, #6]
34180d14:	f003 021f 	and.w	r2, r3, #31
34180d18:	4907      	ldr	r1, [pc, #28]	@ (34180d38 <__NVIC_EnableIRQ+0x38>)
34180d1a:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
34180d1e:	095b      	lsrs	r3, r3, #5
34180d20:	2001      	movs	r0, #1
34180d22:	fa00 f202 	lsl.w	r2, r0, r2
34180d26:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    __COMPILER_BARRIER();
  }
}
34180d2a:	bf00      	nop
34180d2c:	370c      	adds	r7, #12
34180d2e:	46bd      	mov	sp, r7
34180d30:	f85d 7b04 	ldr.w	r7, [sp], #4
34180d34:	4770      	bx	lr
34180d36:	bf00      	nop
34180d38:	e000e100 	.word	0xe000e100

34180d3c <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
34180d3c:	b480      	push	{r7}
34180d3e:	b083      	sub	sp, #12
34180d40:	af00      	add	r7, sp, #0
34180d42:	4603      	mov	r3, r0
34180d44:	6039      	str	r1, [r7, #0]
34180d46:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
34180d48:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
34180d4c:	2b00      	cmp	r3, #0
34180d4e:	db0a      	blt.n	34180d66 <__NVIC_SetPriority+0x2a>
  {
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
34180d50:	683b      	ldr	r3, [r7, #0]
34180d52:	b2da      	uxtb	r2, r3
34180d54:	490c      	ldr	r1, [pc, #48]	@ (34180d88 <__NVIC_SetPriority+0x4c>)
34180d56:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
34180d5a:	0112      	lsls	r2, r2, #4
34180d5c:	b2d2      	uxtb	r2, r2
34180d5e:	440b      	add	r3, r1
34180d60:	f883 2300 	strb.w	r2, [r3, #768]	@ 0x300
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
34180d64:	e00a      	b.n	34180d7c <__NVIC_SetPriority+0x40>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
34180d66:	683b      	ldr	r3, [r7, #0]
34180d68:	b2da      	uxtb	r2, r3
34180d6a:	4908      	ldr	r1, [pc, #32]	@ (34180d8c <__NVIC_SetPriority+0x50>)
34180d6c:	88fb      	ldrh	r3, [r7, #6]
34180d6e:	f003 030f 	and.w	r3, r3, #15
34180d72:	3b04      	subs	r3, #4
34180d74:	0112      	lsls	r2, r2, #4
34180d76:	b2d2      	uxtb	r2, r2
34180d78:	440b      	add	r3, r1
34180d7a:	761a      	strb	r2, [r3, #24]
}
34180d7c:	bf00      	nop
34180d7e:	370c      	adds	r7, #12
34180d80:	46bd      	mov	sp, r7
34180d82:	f85d 7b04 	ldr.w	r7, [sp], #4
34180d86:	4770      	bx	lr
34180d88:	e000e100 	.word	0xe000e100
34180d8c:	e000ed00 	.word	0xe000ed00

34180d90 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
34180d90:	b480      	push	{r7}
34180d92:	b089      	sub	sp, #36	@ 0x24
34180d94:	af00      	add	r7, sp, #0
34180d96:	60f8      	str	r0, [r7, #12]
34180d98:	60b9      	str	r1, [r7, #8]
34180d9a:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
34180d9c:	68fb      	ldr	r3, [r7, #12]
34180d9e:	f003 0307 	and.w	r3, r3, #7
34180da2:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
34180da4:	69fb      	ldr	r3, [r7, #28]
34180da6:	f1c3 0307 	rsb	r3, r3, #7
34180daa:	2b04      	cmp	r3, #4
34180dac:	bf28      	it	cs
34180dae:	2304      	movcs	r3, #4
34180db0:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
34180db2:	69fb      	ldr	r3, [r7, #28]
34180db4:	3304      	adds	r3, #4
34180db6:	2b06      	cmp	r3, #6
34180db8:	d902      	bls.n	34180dc0 <NVIC_EncodePriority+0x30>
34180dba:	69fb      	ldr	r3, [r7, #28]
34180dbc:	3b03      	subs	r3, #3
34180dbe:	e000      	b.n	34180dc2 <NVIC_EncodePriority+0x32>
34180dc0:	2300      	movs	r3, #0
34180dc2:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
34180dc4:	f04f 32ff 	mov.w	r2, #4294967295
34180dc8:	69bb      	ldr	r3, [r7, #24]
34180dca:	fa02 f303 	lsl.w	r3, r2, r3
34180dce:	43da      	mvns	r2, r3
34180dd0:	68bb      	ldr	r3, [r7, #8]
34180dd2:	401a      	ands	r2, r3
34180dd4:	697b      	ldr	r3, [r7, #20]
34180dd6:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
34180dd8:	f04f 31ff 	mov.w	r1, #4294967295
34180ddc:	697b      	ldr	r3, [r7, #20]
34180dde:	fa01 f303 	lsl.w	r3, r1, r3
34180de2:	43d9      	mvns	r1, r3
34180de4:	687b      	ldr	r3, [r7, #4]
34180de6:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
34180de8:	4313      	orrs	r3, r2
         );
}
34180dea:	4618      	mov	r0, r3
34180dec:	3724      	adds	r7, #36	@ 0x24
34180dee:	46bd      	mov	sp, r7
34180df0:	f85d 7b04 	ldr.w	r7, [sp], #4
34180df4:	4770      	bx	lr
	...

34180df8 <LL_AHB1_GRP1_EnableClock>:
  *         @arg @ref LL_AHB1_GRP1_PERIPH_GPDMA1
  *         @arg @ref LL_AHB1_GRP1_PERIPH_ADC12
  * @retval None
  */
__STATIC_INLINE void LL_AHB1_GRP1_EnableClock(uint32_t Periphs)
{
34180df8:	b480      	push	{r7}
34180dfa:	b085      	sub	sp, #20
34180dfc:	af00      	add	r7, sp, #0
34180dfe:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->AHB1ENSR, Periphs);
34180e00:	4a07      	ldr	r2, [pc, #28]	@ (34180e20 <LL_AHB1_GRP1_EnableClock+0x28>)
34180e02:	687b      	ldr	r3, [r7, #4]
34180e04:	f8c2 3a50 	str.w	r3, [r2, #2640]	@ 0xa50
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->AHB1ENR);
34180e08:	4b05      	ldr	r3, [pc, #20]	@ (34180e20 <LL_AHB1_GRP1_EnableClock+0x28>)
34180e0a:	f8d3 3250 	ldr.w	r3, [r3, #592]	@ 0x250
34180e0e:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34180e10:	68fb      	ldr	r3, [r7, #12]
}
34180e12:	bf00      	nop
34180e14:	3714      	adds	r7, #20
34180e16:	46bd      	mov	sp, r7
34180e18:	f85d 7b04 	ldr.w	r7, [sp], #4
34180e1c:	4770      	bx	lr
34180e1e:	bf00      	nop
34180e20:	56028000 	.word	0x56028000

34180e24 <LL_AHB3_GRP1_EnableClock>:
  *
  *         (*) value not defined in all devices.
  * @retval None
  */
__STATIC_INLINE void LL_AHB3_GRP1_EnableClock(uint32_t Periphs)
{
34180e24:	b480      	push	{r7}
34180e26:	b085      	sub	sp, #20
34180e28:	af00      	add	r7, sp, #0
34180e2a:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->AHB3ENSR, Periphs);
34180e2c:	4a07      	ldr	r2, [pc, #28]	@ (34180e4c <LL_AHB3_GRP1_EnableClock+0x28>)
34180e2e:	687b      	ldr	r3, [r7, #4]
34180e30:	f8c2 3a58 	str.w	r3, [r2, #2648]	@ 0xa58
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->AHB3ENR);
34180e34:	4b05      	ldr	r3, [pc, #20]	@ (34180e4c <LL_AHB3_GRP1_EnableClock+0x28>)
34180e36:	f8d3 3258 	ldr.w	r3, [r3, #600]	@ 0x258
34180e3a:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34180e3c:	68fb      	ldr	r3, [r7, #12]
}
34180e3e:	bf00      	nop
34180e40:	3714      	adds	r7, #20
34180e42:	46bd      	mov	sp, r7
34180e44:	f85d 7b04 	ldr.w	r7, [sp], #4
34180e48:	4770      	bx	lr
34180e4a:	bf00      	nop
34180e4c:	56028000 	.word	0x56028000

34180e50 <LL_AHB4_GRP1_EnableClock>:
  *         @arg @ref LL_AHB4_GRP1_PERIPH_PWR
  *         @arg @ref LL_AHB4_GRP1_PERIPH_CRC
  * @retval None
  */
__STATIC_INLINE void LL_AHB4_GRP1_EnableClock(uint32_t Periphs)
{
34180e50:	b480      	push	{r7}
34180e52:	b085      	sub	sp, #20
34180e54:	af00      	add	r7, sp, #0
34180e56:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34180e58:	4a07      	ldr	r2, [pc, #28]	@ (34180e78 <LL_AHB4_GRP1_EnableClock+0x28>)
34180e5a:	687b      	ldr	r3, [r7, #4]
34180e5c:	f8c2 3a5c 	str.w	r3, [r2, #2652]	@ 0xa5c
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->AHB4ENR);
34180e60:	4b05      	ldr	r3, [pc, #20]	@ (34180e78 <LL_AHB4_GRP1_EnableClock+0x28>)
34180e62:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
34180e66:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34180e68:	68fb      	ldr	r3, [r7, #12]
}
34180e6a:	bf00      	nop
34180e6c:	3714      	adds	r7, #20
34180e6e:	46bd      	mov	sp, r7
34180e70:	f85d 7b04 	ldr.w	r7, [sp], #4
34180e74:	4770      	bx	lr
34180e76:	bf00      	nop
34180e78:	56028000 	.word	0x56028000

34180e7c <LL_APB1_GRP2_EnableClock>:
  *         @arg @ref LL_APB1_GRP2_PERIPH_MDIOS
  *         @arg @ref LL_APB1_GRP2_PERIPH_UCPD1
  * @retval None
  */
__STATIC_INLINE void LL_APB1_GRP2_EnableClock(uint32_t Periphs)
{
34180e7c:	b480      	push	{r7}
34180e7e:	b085      	sub	sp, #20
34180e80:	af00      	add	r7, sp, #0
34180e82:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->APB1ENSR2, Periphs);
34180e84:	4a07      	ldr	r2, [pc, #28]	@ (34180ea4 <LL_APB1_GRP2_EnableClock+0x28>)
34180e86:	687b      	ldr	r3, [r7, #4]
34180e88:	f8c2 3a68 	str.w	r3, [r2, #2664]	@ 0xa68
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->APB1ENR2);
34180e8c:	4b05      	ldr	r3, [pc, #20]	@ (34180ea4 <LL_APB1_GRP2_EnableClock+0x28>)
34180e8e:	f8d3 3268 	ldr.w	r3, [r3, #616]	@ 0x268
34180e92:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34180e94:	68fb      	ldr	r3, [r7, #12]
}
34180e96:	bf00      	nop
34180e98:	3714      	adds	r7, #20
34180e9a:	46bd      	mov	sp, r7
34180e9c:	f85d 7b04 	ldr.w	r7, [sp], #4
34180ea0:	4770      	bx	lr
34180ea2:	bf00      	nop
34180ea4:	56028000 	.word	0x56028000

34180ea8 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
34180ea8:	b580      	push	{r7, lr}
34180eaa:	b084      	sub	sp, #16
34180eac:	af00      	add	r7, sp, #0
  /* Power settings */
  HAL_PWREx_EnableVddA();
34180eae:	f008 fd19 	bl	341898e4 <HAL_PWREx_EnableVddA>
  HAL_PWREx_EnableVddIO2();
34180eb2:	f008 fcd7 	bl	34189864 <HAL_PWREx_EnableVddIO2>
  HAL_PWREx_EnableVddIO3();
34180eb6:	f008 fce5 	bl	34189884 <HAL_PWREx_EnableVddIO3>
  HAL_PWREx_EnableVddIO4();
34180eba:	f008 fcf3 	bl	341898a4 <HAL_PWREx_EnableVddIO4>
  HAL_PWREx_EnableVddIO5();
34180ebe:	f008 fd01 	bl	341898c4 <HAL_PWREx_EnableVddIO5>
  /* USER CODE BEGIN 1 */
  UINT status;

  MPU_Config();
34180ec2:	f000 f975 	bl	341811b0 <MPU_Config>
  \details Turns on I-Cache
  */
__STATIC_FORCEINLINE void SCB_EnableICache (void)
{
  #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
    if (SCB->CCR & SCB_CCR_IC_Msk) return;  /* return if ICache is already enabled */
34180ec6:	4b46      	ldr	r3, [pc, #280]	@ (34180fe0 <main+0x138>)
34180ec8:	695b      	ldr	r3, [r3, #20]
34180eca:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
34180ece:	2b00      	cmp	r3, #0
34180ed0:	d11b      	bne.n	34180f0a <main+0x62>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
34180ed2:	f3bf 8f4f 	dsb	sy
}
34180ed6:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
34180ed8:	f3bf 8f6f 	isb	sy
}
34180edc:	bf00      	nop

    __DSB();
    __ISB();
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
34180ede:	4b40      	ldr	r3, [pc, #256]	@ (34180fe0 <main+0x138>)
34180ee0:	2200      	movs	r2, #0
34180ee2:	f8c3 2250 	str.w	r2, [r3, #592]	@ 0x250
  __ASM volatile ("dsb 0xF":::"memory");
34180ee6:	f3bf 8f4f 	dsb	sy
}
34180eea:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
34180eec:	f3bf 8f6f 	isb	sy
}
34180ef0:	bf00      	nop
    __DSB();
    __ISB();
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
34180ef2:	4b3b      	ldr	r3, [pc, #236]	@ (34180fe0 <main+0x138>)
34180ef4:	695b      	ldr	r3, [r3, #20]
34180ef6:	4a3a      	ldr	r2, [pc, #232]	@ (34180fe0 <main+0x138>)
34180ef8:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
34180efc:	6153      	str	r3, [r2, #20]
  __ASM volatile ("dsb 0xF":::"memory");
34180efe:	f3bf 8f4f 	dsb	sy
}
34180f02:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
34180f04:	f3bf 8f6f 	isb	sy
}
34180f08:	e000      	b.n	34180f0c <main+0x64>
    if (SCB->CCR & SCB_CCR_IC_Msk) return;  /* return if ICache is already enabled */
34180f0a:	bf00      	nop
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    uint32_t ccsidr;
    uint32_t sets;
    uint32_t ways;

    if (SCB->CCR & SCB_CCR_DC_Msk) return;  /* return if DCache is already enabled */
34180f0c:	4b34      	ldr	r3, [pc, #208]	@ (34180fe0 <main+0x138>)
34180f0e:	695b      	ldr	r3, [r3, #20]
34180f10:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
34180f14:	2b00      	cmp	r3, #0
34180f16:	d138      	bne.n	34180f8a <main+0xe2>

    SCB->CSSELR = 0U;                       /* select Level 1 data cache */
34180f18:	4b31      	ldr	r3, [pc, #196]	@ (34180fe0 <main+0x138>)
34180f1a:	2200      	movs	r2, #0
34180f1c:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
  __ASM volatile ("dsb 0xF":::"memory");
34180f20:	f3bf 8f4f 	dsb	sy
}
34180f24:	bf00      	nop
    __DSB();

    ccsidr = SCB->CCSIDR;
34180f26:	4b2e      	ldr	r3, [pc, #184]	@ (34180fe0 <main+0x138>)
34180f28:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34180f2c:	60bb      	str	r3, [r7, #8]

                                            /* invalidate D-Cache */
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
34180f2e:	68bb      	ldr	r3, [r7, #8]
34180f30:	0b5b      	lsrs	r3, r3, #13
34180f32:	f3c3 030e 	ubfx	r3, r3, #0, #15
34180f36:	607b      	str	r3, [r7, #4]
    do {
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
34180f38:	68bb      	ldr	r3, [r7, #8]
34180f3a:	08db      	lsrs	r3, r3, #3
34180f3c:	f3c3 0309 	ubfx	r3, r3, #0, #10
34180f40:	603b      	str	r3, [r7, #0]
      do {
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
34180f42:	687b      	ldr	r3, [r7, #4]
34180f44:	015a      	lsls	r2, r3, #5
34180f46:	f643 73e0 	movw	r3, #16352	@ 0x3fe0
34180f4a:	4013      	ands	r3, r2
                      ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
34180f4c:	683a      	ldr	r2, [r7, #0]
34180f4e:	0792      	lsls	r2, r2, #30
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
34180f50:	4923      	ldr	r1, [pc, #140]	@ (34180fe0 <main+0x138>)
34180f52:	4313      	orrs	r3, r2
34180f54:	f8c1 3260 	str.w	r3, [r1, #608]	@ 0x260
        #if defined ( __CC_ARM )
          __schedule_barrier();
        #endif
      } while (ways-- != 0U);
34180f58:	683b      	ldr	r3, [r7, #0]
34180f5a:	1e5a      	subs	r2, r3, #1
34180f5c:	603a      	str	r2, [r7, #0]
34180f5e:	2b00      	cmp	r3, #0
34180f60:	d1ef      	bne.n	34180f42 <main+0x9a>
    } while(sets-- != 0U);
34180f62:	687b      	ldr	r3, [r7, #4]
34180f64:	1e5a      	subs	r2, r3, #1
34180f66:	607a      	str	r2, [r7, #4]
34180f68:	2b00      	cmp	r3, #0
34180f6a:	d1e5      	bne.n	34180f38 <main+0x90>
  __ASM volatile ("dsb 0xF":::"memory");
34180f6c:	f3bf 8f4f 	dsb	sy
}
34180f70:	bf00      	nop
    __DSB();

    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
34180f72:	4b1b      	ldr	r3, [pc, #108]	@ (34180fe0 <main+0x138>)
34180f74:	695b      	ldr	r3, [r3, #20]
34180f76:	4a1a      	ldr	r2, [pc, #104]	@ (34180fe0 <main+0x138>)
34180f78:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
34180f7c:	6153      	str	r3, [r2, #20]
  __ASM volatile ("dsb 0xF":::"memory");
34180f7e:	f3bf 8f4f 	dsb	sy
}
34180f82:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
34180f84:	f3bf 8f6f 	isb	sy
}
34180f88:	e000      	b.n	34180f8c <main+0xe4>
    if (SCB->CCR & SCB_CCR_DC_Msk) return;  /* return if DCache is already enabled */
34180f8a:	bf00      	nop

  /* Enable D-Cache---------------------------------------------------------*/
  SCB_EnableDCache();

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
34180f8c:	f004 faec 	bl	34185568 <HAL_Init>

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */
  /* Configure the system clock */
  SystemClock_Config();
34180f90:	f000 f82e 	bl	34180ff0 <SystemClock_Config>

  RISAF_Config();
34180f94:	f000 fa90 	bl	341814b8 <RISAF_Config>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
34180f98:	f000 fa3e 	bl	34181418 <MX_GPIO_Init>
  MX_SDMMC2_SD_Init();
34180f9c:	f000 fa1a 	bl	341813d4 <MX_SDMMC2_SD_Init>
  MX_GPDMA1_Init();
34180fa0:	f000 f948 	bl	34181234 <MX_GPDMA1_Init>
  MX_UCPD1_Init();
34180fa4:	f000 f97e 	bl	341812a4 <MX_UCPD1_Init>
  /* USER CODE BEGIN 2 */
  /* Check if SD card is present */
  if(HAL_GPIO_ReadPin(SD_DETECT_GPIO_Port, SD_DETECT_Pin) == GPIO_PIN_SET)
34180fa8:	f44f 5180 	mov.w	r1, #4096	@ 0x1000
34180fac:	480d      	ldr	r0, [pc, #52]	@ (34180fe4 <main+0x13c>)
34180fae:	f006 fa3b 	bl	34187428 <HAL_GPIO_ReadPin>
34180fb2:	4603      	mov	r3, r0
34180fb4:	2b01      	cmp	r3, #1
34180fb6:	d101      	bne.n	34180fbc <main+0x114>
  {
    Error_Handler();
34180fb8:	f000 fb02 	bl	341815c0 <Error_Handler>
  }

  /* Get SD card info */
  status = HAL_SD_GetCardInfo(&hsd1, &USBD_SD_CardInfo);
34180fbc:	490a      	ldr	r1, [pc, #40]	@ (34180fe8 <main+0x140>)
34180fbe:	480b      	ldr	r0, [pc, #44]	@ (34180fec <main+0x144>)
34180fc0:	f00e fc7c 	bl	3418f8bc <HAL_SD_GetCardInfo>
34180fc4:	4603      	mov	r3, r0
34180fc6:	60fb      	str	r3, [r7, #12]

  if (status != HAL_OK)
34180fc8:	68fb      	ldr	r3, [r7, #12]
34180fca:	2b00      	cmp	r3, #0
34180fcc:	d001      	beq.n	34180fd2 <main+0x12a>
  {
    Error_Handler();
34180fce:	f000 faf7 	bl	341815c0 <Error_Handler>
  }
 /* Call PreOsInit function */
  USBPD_PreInitOs();
34180fd2:	f000 fdce 	bl	34181b72 <USBPD_PreInitOs>
  /* USER CODE END 2 */

  MX_ThreadX_Init();
34180fd6:	f7ff fe7e 	bl	34180cd6 <MX_ThreadX_Init>

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
34180fda:	bf00      	nop
34180fdc:	e7fd      	b.n	34180fda <main+0x132>
34180fde:	bf00      	nop
34180fe0:	e000ed00 	.word	0xe000ed00
34180fe4:	56023400 	.word	0x56023400
34180fe8:	341c1ab8 	.word	0x341c1ab8
34180fec:	341c1a3c 	.word	0x341c1a3c

34180ff0 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
34180ff0:	b580      	push	{r7, lr}
34180ff2:	f5ad 7d1a 	sub.w	sp, sp, #616	@ 0x268
34180ff6:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
34180ff8:	f507 73e8 	add.w	r3, r7, #464	@ 0x1d0
34180ffc:	2298      	movs	r2, #152	@ 0x98
34180ffe:	2100      	movs	r1, #0
34181000:	4618      	mov	r0, r3
34181002:	f01d f85d 	bl	3419e0c0 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
34181006:	f507 73c8 	add.w	r3, r7, #400	@ 0x190
3418100a:	2240      	movs	r2, #64	@ 0x40
3418100c:	2100      	movs	r1, #0
3418100e:	4618      	mov	r0, r3
34181010:	f01d f856 	bl	3419e0c0 <memset>
  /* Configure the power domain */
  if (HAL_PWREx_ConfigSupply(PWR_EXTERNAL_SOURCE_SUPPLY) != HAL_OK)
34181014:	2000      	movs	r0, #0
34181016:	f008 fbed 	bl	341897f4 <HAL_PWREx_ConfigSupply>
3418101a:	4603      	mov	r3, r0
3418101c:	2b00      	cmp	r3, #0
3418101e:	d001      	beq.n	34181024 <SystemClock_Config+0x34>
  {
    Error_Handler();
34181020:	f000 face 	bl	341815c0 <Error_Handler>
  }

  /* Get current CPU/System buses clocks configuration */
  /* and if necessary switch to intermediate HSI clock */
  /* to ensure target clock can be set                 */
  HAL_RCC_GetClockConfig(&RCC_ClkInitStruct);
34181024:	f507 73c8 	add.w	r3, r7, #400	@ 0x190
34181028:	4618      	mov	r0, r3
3418102a:	f009 fe15 	bl	3418ac58 <HAL_RCC_GetClockConfig>
  if ((RCC_ClkInitStruct.CPUCLKSource == RCC_CPUCLKSOURCE_IC1) ||
3418102e:	f8d7 3194 	ldr.w	r3, [r7, #404]	@ 0x194
34181032:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
34181036:	d004      	beq.n	34181042 <SystemClock_Config+0x52>
      (RCC_ClkInitStruct.SYSCLKSource == RCC_SYSCLKSOURCE_IC2_IC6_IC11))
34181038:	f8d7 3198 	ldr.w	r3, [r7, #408]	@ 0x198
  if ((RCC_ClkInitStruct.CPUCLKSource == RCC_CPUCLKSOURCE_IC1) ||
3418103c:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
34181040:	d112      	bne.n	34181068 <SystemClock_Config+0x78>
  {
    RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_CPUCLK | RCC_CLOCKTYPE_SYSCLK);
34181042:	2303      	movs	r3, #3
34181044:	f8c7 3190 	str.w	r3, [r7, #400]	@ 0x190
    RCC_ClkInitStruct.CPUCLKSource = RCC_CPUCLKSOURCE_HSI;
34181048:	2300      	movs	r3, #0
3418104a:	f8c7 3194 	str.w	r3, [r7, #404]	@ 0x194
    RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
3418104e:	2300      	movs	r3, #0
34181050:	f8c7 3198 	str.w	r3, [r7, #408]	@ 0x198
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct) != HAL_OK)
34181054:	f507 73c8 	add.w	r3, r7, #400	@ 0x190
34181058:	4618      	mov	r0, r3
3418105a:	f009 fad9 	bl	3418a610 <HAL_RCC_ClockConfig>
3418105e:	4603      	mov	r3, r0
34181060:	2b00      	cmp	r3, #0
34181062:	d001      	beq.n	34181068 <SystemClock_Config+0x78>
  {
    Error_Handler();
34181064:	f000 faac 	bl	341815c0 <Error_Handler>
  /* PLL2 off                                                */
  /* PLL3 off                                                */
  /* PLL4 off                                                */

  /* Enable HSE && HSI */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
34181068:	2301      	movs	r3, #1
3418106a:	f8c7 31d0 	str.w	r3, [r7, #464]	@ 0x1d0
  RCC_OscInitStruct.HSIState = RCC_HSI_OFF;
3418106e:	2300      	movs	r3, #0
34181070:	f8c7 31dc 	str.w	r3, [r7, #476]	@ 0x1dc
  RCC_OscInitStruct.HSIDiv = RCC_HSI_DIV1;
34181074:	2300      	movs	r3, #0
34181076:	f8c7 31e0 	str.w	r3, [r7, #480]	@ 0x1e0
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
3418107a:	2300      	movs	r3, #0
3418107c:	f8c7 31e4 	str.w	r3, [r7, #484]	@ 0x1e4
  RCC_OscInitStruct.HSEState = RCC_HSE_ON; /* 48 MHz */
34181080:	2310      	movs	r3, #16
34181082:	f8c7 31d4 	str.w	r3, [r7, #468]	@ 0x1d4

  RCC_OscInitStruct.PLL1.PLLState = RCC_PLL_ON;
34181086:	2302      	movs	r3, #2
34181088:	f8c7 31f8 	str.w	r3, [r7, #504]	@ 0x1f8
  RCC_OscInitStruct.PLL1.PLLSource = RCC_PLLSOURCE_HSE;
3418108c:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
34181090:	f8c7 31fc 	str.w	r3, [r7, #508]	@ 0x1fc
  RCC_OscInitStruct.PLL1.PLLM  = 3;
34181094:	2303      	movs	r3, #3
34181096:	f8c7 3200 	str.w	r3, [r7, #512]	@ 0x200
  RCC_OscInitStruct.PLL1.PLLN  = 75;  /* PLL1 VCO = 48/3 * 75 = 1200MHz */
3418109a:	234b      	movs	r3, #75	@ 0x4b
3418109c:	f8c7 3208 	str.w	r3, [r7, #520]	@ 0x208
  RCC_OscInitStruct.PLL1.PLLP1 = 1;   /* PLL output = PLL VCO frequency / (PLLP1 * PLLP2) */
341810a0:	2301      	movs	r3, #1
341810a2:	f8c7 320c 	str.w	r3, [r7, #524]	@ 0x20c
  RCC_OscInitStruct.PLL1.PLLP2 = 1;   /* PLL output = 1200 MHz */
341810a6:	2301      	movs	r3, #1
341810a8:	f8c7 3210 	str.w	r3, [r7, #528]	@ 0x210
  RCC_OscInitStruct.PLL1.PLLFractional = 0;
341810ac:	2300      	movs	r3, #0
341810ae:	f8c7 3204 	str.w	r3, [r7, #516]	@ 0x204

  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
341810b2:	f507 73e8 	add.w	r3, r7, #464	@ 0x1d0
341810b6:	4618      	mov	r0, r3
341810b8:	f008 feca 	bl	34189e50 <HAL_RCC_OscConfig>
341810bc:	4603      	mov	r3, r0
341810be:	2b00      	cmp	r3, #0
341810c0:	d001      	beq.n	341810c6 <SystemClock_Config+0xd6>
  {
    /* Initialization error */
    Error_Handler();
341810c2:	f000 fa7d 	bl	341815c0 <Error_Handler>
  /* CPUCLK = ic1_ck = PLL1 output/ic1_divider = 600 MHz */
  /* SYSCLK = ic2_ck = PLL1 output/ic2_divider = 400 MHz */
  /* Configure the HCLK clock divider */
  /* HCLK =  PLL1 SYSCLK/HCLK divider = 200 MHz */
  /* PCLKx = HCLK / PCLKx divider = 200 MHz */
  RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_CPUCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK  | \
341810c6:	237f      	movs	r3, #127	@ 0x7f
341810c8:	f8c7 3190 	str.w	r3, [r7, #400]	@ 0x190
                                 RCC_CLOCKTYPE_PCLK1  | RCC_CLOCKTYPE_PCLK2 | RCC_CLOCKTYPE_PCLK4  | RCC_CLOCKTYPE_PCLK5);
  RCC_ClkInitStruct.CPUCLKSource = RCC_CPUCLKSOURCE_IC1;
341810cc:	f44f 3340 	mov.w	r3, #196608	@ 0x30000
341810d0:	f8c7 3194 	str.w	r3, [r7, #404]	@ 0x194
  RCC_ClkInitStruct.IC1Selection.ClockSelection = RCC_ICCLKSOURCE_PLL1;
341810d4:	2300      	movs	r3, #0
341810d6:	f8c7 31b0 	str.w	r3, [r7, #432]	@ 0x1b0
  RCC_ClkInitStruct.IC1Selection.ClockDivider = 2;
341810da:	2302      	movs	r3, #2
341810dc:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_IC2_IC6_IC11;
341810e0:	f04f 7340 	mov.w	r3, #50331648	@ 0x3000000
341810e4:	f8c7 3198 	str.w	r3, [r7, #408]	@ 0x198
  RCC_ClkInitStruct.IC2Selection.ClockSelection = RCC_ICCLKSOURCE_PLL1;
341810e8:	2300      	movs	r3, #0
341810ea:	f8c7 31b8 	str.w	r3, [r7, #440]	@ 0x1b8
  RCC_ClkInitStruct.IC2Selection.ClockDivider = 3;
341810ee:	2303      	movs	r3, #3
341810f0:	f8c7 31bc 	str.w	r3, [r7, #444]	@ 0x1bc
  RCC_ClkInitStruct.IC6Selection.ClockSelection = RCC_ICCLKSOURCE_PLL1;
341810f4:	2300      	movs	r3, #0
341810f6:	f8c7 31c0 	str.w	r3, [r7, #448]	@ 0x1c0
  RCC_ClkInitStruct.IC6Selection.ClockDivider = 3;
341810fa:	2303      	movs	r3, #3
341810fc:	f8c7 31c4 	str.w	r3, [r7, #452]	@ 0x1c4
  RCC_ClkInitStruct.IC11Selection.ClockSelection = RCC_ICCLKSOURCE_PLL1;
34181100:	2300      	movs	r3, #0
34181102:	f8c7 31c8 	str.w	r3, [r7, #456]	@ 0x1c8
  RCC_ClkInitStruct.IC11Selection.ClockDivider = 3;
34181106:	2303      	movs	r3, #3
34181108:	f8c7 31cc 	str.w	r3, [r7, #460]	@ 0x1cc
  RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
3418110c:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
34181110:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
  RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV1;
34181114:	2300      	movs	r3, #0
34181116:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
  RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV1;
3418111a:	2300      	movs	r3, #0
3418111c:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
  RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV1;
34181120:	2300      	movs	r3, #0
34181122:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
  RCC_ClkInitStruct.APB5CLKDivider = RCC_APB5_DIV1;
34181126:	2300      	movs	r3, #0
34181128:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct) != HAL_OK)
3418112c:	f507 73c8 	add.w	r3, r7, #400	@ 0x190
34181130:	4618      	mov	r0, r3
34181132:	f009 fa6d 	bl	3418a610 <HAL_RCC_ClockConfig>
34181136:	4603      	mov	r3, r0
34181138:	2b00      	cmp	r3, #0
3418113a:	d001      	beq.n	34181140 <SystemClock_Config+0x150>
  {
    /* Initialization Error */
    Error_Handler();
3418113c:	f000 fa40 	bl	341815c0 <Error_Handler>
  }
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
34181140:	f507 731a 	add.w	r3, r7, #616	@ 0x268
34181144:	f5a3 731a 	sub.w	r3, r3, #616	@ 0x268
34181148:	4618      	mov	r0, r3
3418114a:	f44f 73c8 	mov.w	r3, #400	@ 0x190
3418114e:	461a      	mov	r2, r3
34181150:	2100      	movs	r1, #0
34181152:	f01c ffb5 	bl	3419e0c0 <memset>

  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_SDMMC2;
34181156:	f507 731a 	add.w	r3, r7, #616	@ 0x268
3418115a:	f5a3 711a 	sub.w	r1, r3, #616	@ 0x268
3418115e:	f04f 4200 	mov.w	r2, #2147483648	@ 0x80000000
34181162:	f04f 0300 	mov.w	r3, #0
34181166:	e9c1 2300 	strd	r2, r3, [r1]
  PeriphClkInit.Sdmmc2ClockSelection = RCC_SDMMC2CLKSOURCE_IC4;
3418116a:	f507 731a 	add.w	r3, r7, #616	@ 0x268
3418116e:	f5a3 731a 	sub.w	r3, r3, #616	@ 0x268
34181172:	4a0e      	ldr	r2, [pc, #56]	@ (341811ac <SystemClock_Config+0x1bc>)
34181174:	f8c3 2130 	str.w	r2, [r3, #304]	@ 0x130
  PeriphClkInit.ICSelection[RCC_IC4].ClockSelection = RCC_ICCLKSOURCE_PLL1;
34181178:	f507 731a 	add.w	r3, r7, #616	@ 0x268
3418117c:	f5a3 731a 	sub.w	r3, r3, #616	@ 0x268
34181180:	2200      	movs	r2, #0
34181182:	621a      	str	r2, [r3, #32]
  PeriphClkInit.ICSelection[RCC_IC4].ClockDivider = 6;
34181184:	f507 731a 	add.w	r3, r7, #616	@ 0x268
34181188:	f5a3 731a 	sub.w	r3, r3, #616	@ 0x268
3418118c:	2206      	movs	r2, #6
3418118e:	625a      	str	r2, [r3, #36]	@ 0x24
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
34181190:	463b      	mov	r3, r7
34181192:	4618      	mov	r0, r3
34181194:	f00a f9ba 	bl	3418b50c <HAL_RCCEx_PeriphCLKConfig>
34181198:	4603      	mov	r3, r0
3418119a:	2b00      	cmp	r3, #0
3418119c:	d001      	beq.n	341811a2 <SystemClock_Config+0x1b2>
  {
    Error_Handler();
3418119e:	f000 fa0f 	bl	341815c0 <Error_Handler>
  }
}
341811a2:	bf00      	nop
341811a4:	f507 771a 	add.w	r7, r7, #616	@ 0x268
341811a8:	46bd      	mov	sp, r7
341811aa:	bd80      	pop	{r7, pc}
341811ac:	0302041c 	.word	0x0302041c

341811b0 <MPU_Config>:

/* USER CODE BEGIN 4 */
/* MPU Configuration */
void MPU_Config(void)
{
341811b0:	b580      	push	{r7, lr}
341811b2:	b088      	sub	sp, #32
341811b4:	af00      	add	r7, sp, #0
  MPU_Region_InitTypeDef default_config = {0};
341811b6:	1d3b      	adds	r3, r7, #4
341811b8:	2200      	movs	r2, #0
341811ba:	601a      	str	r2, [r3, #0]
341811bc:	605a      	str	r2, [r3, #4]
341811be:	609a      	str	r2, [r3, #8]
341811c0:	60da      	str	r2, [r3, #12]
  MPU_Attributes_InitTypeDef attr_config = {0};
341811c2:	2300      	movs	r3, #0
341811c4:	803b      	strh	r3, [r7, #0]
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
341811c6:	f3ef 8310 	mrs	r3, PRIMASK
341811ca:	617b      	str	r3, [r7, #20]
  return(result);
341811cc:	697b      	ldr	r3, [r7, #20]
  uint32_t primask_bit = __get_PRIMASK();
341811ce:	61fb      	str	r3, [r7, #28]
  __ASM volatile ("cpsid i" : : : "memory");
341811d0:	b672      	cpsid	i
}
341811d2:	bf00      	nop
  __disable_irq();

  /* disable the MPU */
  HAL_MPU_Disable();
341811d4:	f005 fd8e 	bl	34186cf4 <HAL_MPU_Disable>

  /* create an attribute configuration for the MPU */
  attr_config.Attributes = INNER_OUTER(MPU_NOT_CACHEABLE);
341811d8:	2344      	movs	r3, #68	@ 0x44
341811da:	707b      	strb	r3, [r7, #1]
  attr_config.Number = MPU_ATTRIBUTES_NUMBER0;
341811dc:	2300      	movs	r3, #0
341811de:	703b      	strb	r3, [r7, #0]

  HAL_MPU_ConfigMemoryAttributes(&attr_config);
341811e0:	463b      	mov	r3, r7
341811e2:	4618      	mov	r0, r3
341811e4:	f005 fdb4 	bl	34186d50 <HAL_MPU_ConfigMemoryAttributes>

  /*Normal memory type, code execution allowed */
  default_config.Enable = MPU_REGION_ENABLE;
341811e8:	2301      	movs	r3, #1
341811ea:	713b      	strb	r3, [r7, #4]
  default_config.Number = MPU_REGION_NUMBER0;
341811ec:	2300      	movs	r3, #0
341811ee:	717b      	strb	r3, [r7, #5]
  default_config.BaseAddress = 0x341FC800;
341811f0:	4b0e      	ldr	r3, [pc, #56]	@ (3418122c <MPU_Config+0x7c>)
341811f2:	60bb      	str	r3, [r7, #8]
  default_config.LimitAddress =  0x341FFFFF;
341811f4:	4b0e      	ldr	r3, [pc, #56]	@ (34181230 <MPU_Config+0x80>)
341811f6:	60fb      	str	r3, [r7, #12]
  default_config.DisableExec = MPU_INSTRUCTION_ACCESS_ENABLE;
341811f8:	2300      	movs	r3, #0
341811fa:	747b      	strb	r3, [r7, #17]
  default_config.AccessPermission = MPU_REGION_ALL_RW;
341811fc:	2301      	movs	r3, #1
341811fe:	743b      	strb	r3, [r7, #16]
  default_config.IsShareable = MPU_ACCESS_NOT_SHAREABLE;
34181200:	2300      	movs	r3, #0
34181202:	74fb      	strb	r3, [r7, #19]
  default_config.AttributesIndex = MPU_ATTRIBUTES_NUMBER0;
34181204:	2300      	movs	r3, #0
34181206:	71bb      	strb	r3, [r7, #6]
  HAL_MPU_ConfigRegion(&default_config);
34181208:	1d3b      	adds	r3, r7, #4
3418120a:	4618      	mov	r0, r3
3418120c:	f005 fd92 	bl	34186d34 <HAL_MPU_ConfigRegion>

  /* enable the MPU */
  HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);
34181210:	2004      	movs	r0, #4
34181212:	f005 fd4d 	bl	34186cb0 <HAL_MPU_Enable>
34181216:	69fb      	ldr	r3, [r7, #28]
34181218:	61bb      	str	r3, [r7, #24]
  \details Assigns the given value to the Priority Mask Register.
  \param [in]    priMask  Priority Mask
 */
__STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)
{
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
3418121a:	69bb      	ldr	r3, [r7, #24]
3418121c:	f383 8810 	msr	PRIMASK, r3
}
34181220:	bf00      	nop

  /* Exit critical section to lock the system and avoid any issue around MPU mechanisme */
  __set_PRIMASK(primask_bit);
}
34181222:	bf00      	nop
34181224:	3720      	adds	r7, #32
34181226:	46bd      	mov	sp, r7
34181228:	bd80      	pop	{r7, pc}
3418122a:	bf00      	nop
3418122c:	341fc800 	.word	0x341fc800
34181230:	341fffff 	.word	0x341fffff

34181234 <MX_GPDMA1_Init>:
  * @brief GPDMA1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPDMA1_Init(void)
{
34181234:	b580      	push	{r7, lr}
34181236:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN GPDMA1_Init 0 */

  /* USER CODE END GPDMA1_Init 0 */

  /* Peripheral clock enable */
  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPDMA1);
34181238:	2010      	movs	r0, #16
3418123a:	f7ff fddd 	bl	34180df8 <LL_AHB1_GRP1_EnableClock>

  /* GPDMA1 interrupt Init */
  NVIC_SetPriority(GPDMA1_Channel0_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));
3418123e:	f7ff fd51 	bl	34180ce4 <__NVIC_GetPriorityGrouping>
34181242:	4603      	mov	r3, r0
34181244:	2200      	movs	r2, #0
34181246:	2100      	movs	r1, #0
34181248:	4618      	mov	r0, r3
3418124a:	f7ff fda1 	bl	34180d90 <NVIC_EncodePriority>
3418124e:	4603      	mov	r3, r0
34181250:	4619      	mov	r1, r3
34181252:	2054      	movs	r0, #84	@ 0x54
34181254:	f7ff fd72 	bl	34180d3c <__NVIC_SetPriority>
  NVIC_EnableIRQ(GPDMA1_Channel0_IRQn);
34181258:	2054      	movs	r0, #84	@ 0x54
3418125a:	f7ff fd51 	bl	34180d00 <__NVIC_EnableIRQ>
  NVIC_SetPriority(GPDMA1_Channel2_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));
3418125e:	f7ff fd41 	bl	34180ce4 <__NVIC_GetPriorityGrouping>
34181262:	4603      	mov	r3, r0
34181264:	2200      	movs	r2, #0
34181266:	2100      	movs	r1, #0
34181268:	4618      	mov	r0, r3
3418126a:	f7ff fd91 	bl	34180d90 <NVIC_EncodePriority>
3418126e:	4603      	mov	r3, r0
34181270:	4619      	mov	r1, r3
34181272:	2056      	movs	r0, #86	@ 0x56
34181274:	f7ff fd62 	bl	34180d3c <__NVIC_SetPriority>
  NVIC_EnableIRQ(GPDMA1_Channel2_IRQn);
34181278:	2056      	movs	r0, #86	@ 0x56
3418127a:	f7ff fd41 	bl	34180d00 <__NVIC_EnableIRQ>
  NVIC_SetPriority(GPDMA1_Channel3_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));
3418127e:	f7ff fd31 	bl	34180ce4 <__NVIC_GetPriorityGrouping>
34181282:	4603      	mov	r3, r0
34181284:	2200      	movs	r2, #0
34181286:	2100      	movs	r1, #0
34181288:	4618      	mov	r0, r3
3418128a:	f7ff fd81 	bl	34180d90 <NVIC_EncodePriority>
3418128e:	4603      	mov	r3, r0
34181290:	4619      	mov	r1, r3
34181292:	2057      	movs	r0, #87	@ 0x57
34181294:	f7ff fd52 	bl	34180d3c <__NVIC_SetPriority>
  NVIC_EnableIRQ(GPDMA1_Channel3_IRQn);
34181298:	2057      	movs	r0, #87	@ 0x57
3418129a:	f7ff fd31 	bl	34180d00 <__NVIC_EnableIRQ>

  /* USER CODE END GPDMA1_Init 1 */
  /* USER CODE BEGIN GPDMA1_Init 2 */

  /* USER CODE END GPDMA1_Init 2 */
}
3418129e:	bf00      	nop
341812a0:	bd80      	pop	{r7, pc}
	...

341812a4 <MX_UCPD1_Init>:
  * @brief UCPD1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_UCPD1_Init(void)
{
341812a4:	b580      	push	{r7, lr}
341812a6:	b0a6      	sub	sp, #152	@ 0x98
341812a8:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN UCPD1_Init 0 */

  /* USER CODE END UCPD1_Init 0 */
  LL_DMA_InitTypeDef DMA_InitStruct = {0};
341812aa:	463b      	mov	r3, r7
341812ac:	2298      	movs	r2, #152	@ 0x98
341812ae:	2100      	movs	r1, #0
341812b0:	4618      	mov	r0, r3
341812b2:	f01c ff05 	bl	3419e0c0 <memset>

  /* Peripheral clock enable */
  LL_APB1_GRP2_EnableClock(LL_APB1_GRP2_PERIPH_UCPD1);
341812b6:	f44f 2080 	mov.w	r0, #262144	@ 0x40000
341812ba:	f7ff fddf 	bl	34180e7c <LL_APB1_GRP2_EnableClock>

  /* UCPD1 DMA Init */

  /* GPDMA1_REQUEST_UCPD1_RX Init */
  DMA_InitStruct.SrcAddress = 0x00000000U;
341812be:	2300      	movs	r3, #0
341812c0:	603b      	str	r3, [r7, #0]
  DMA_InitStruct.DestAddress = 0x00000000U;
341812c2:	2300      	movs	r3, #0
341812c4:	607b      	str	r3, [r7, #4]
  DMA_InitStruct.Direction = LL_DMA_DIRECTION_MEMORY_TO_PERIPH;
341812c6:	f44f 6380 	mov.w	r3, #1024	@ 0x400
341812ca:	60bb      	str	r3, [r7, #8]
  DMA_InitStruct.BlkHWRequest = LL_DMA_HWREQUEST_SINGLEBURST;
341812cc:	2300      	movs	r3, #0
341812ce:	60fb      	str	r3, [r7, #12]
  DMA_InitStruct.DataAlignment = LL_DMA_DATA_ALIGN_ZEROPADD;
341812d0:	2300      	movs	r3, #0
341812d2:	613b      	str	r3, [r7, #16]
  DMA_InitStruct.SrcBurstLength = 1;
341812d4:	2301      	movs	r3, #1
341812d6:	617b      	str	r3, [r7, #20]
  DMA_InitStruct.DestBurstLength = 1;
341812d8:	2301      	movs	r3, #1
341812da:	61bb      	str	r3, [r7, #24]
  DMA_InitStruct.SrcDataWidth = LL_DMA_SRC_DATAWIDTH_BYTE;
341812dc:	2300      	movs	r3, #0
341812de:	61fb      	str	r3, [r7, #28]
  DMA_InitStruct.DestDataWidth = LL_DMA_DEST_DATAWIDTH_BYTE;
341812e0:	2300      	movs	r3, #0
341812e2:	623b      	str	r3, [r7, #32]
  DMA_InitStruct.SrcIncMode = LL_DMA_SRC_FIXED;
341812e4:	2300      	movs	r3, #0
341812e6:	627b      	str	r3, [r7, #36]	@ 0x24
  DMA_InitStruct.DestIncMode = LL_DMA_DEST_INCREMENT;
341812e8:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
341812ec:	62bb      	str	r3, [r7, #40]	@ 0x28
  DMA_InitStruct.Priority = LL_DMA_LOW_PRIORITY_LOW_WEIGHT;
341812ee:	2300      	movs	r3, #0
341812f0:	62fb      	str	r3, [r7, #44]	@ 0x2c
  DMA_InitStruct.BlkDataLength = 0x00000000U;
341812f2:	2300      	movs	r3, #0
341812f4:	633b      	str	r3, [r7, #48]	@ 0x30
  DMA_InitStruct.TriggerMode = LL_DMA_TRIGM_BLK_TRANSFER;
341812f6:	2300      	movs	r3, #0
341812f8:	63bb      	str	r3, [r7, #56]	@ 0x38
  DMA_InitStruct.TriggerPolarity = LL_DMA_TRIG_POLARITY_MASKED;
341812fa:	2300      	movs	r3, #0
341812fc:	63fb      	str	r3, [r7, #60]	@ 0x3c
  DMA_InitStruct.TriggerSelection = 0x00000000U;
341812fe:	2300      	movs	r3, #0
34181300:	643b      	str	r3, [r7, #64]	@ 0x40
  DMA_InitStruct.Request = LL_GPDMA1_REQUEST_UCPD1_RX;
34181302:	238b      	movs	r3, #139	@ 0x8b
34181304:	647b      	str	r3, [r7, #68]	@ 0x44
  DMA_InitStruct.TransferEventMode = LL_DMA_TCEM_BLK_TRANSFER;
34181306:	2300      	movs	r3, #0
34181308:	64bb      	str	r3, [r7, #72]	@ 0x48
  DMA_InitStruct.SrcAllocatedPort = LL_DMA_SRC_ALLOCATED_PORT0;
3418130a:	2300      	movs	r3, #0
3418130c:	65fb      	str	r3, [r7, #92]	@ 0x5c
  DMA_InitStruct.DestAllocatedPort = LL_DMA_DEST_ALLOCATED_PORT0;
3418130e:	2300      	movs	r3, #0
34181310:	663b      	str	r3, [r7, #96]	@ 0x60
  DMA_InitStruct.LinkAllocatedPort = LL_DMA_LINK_ALLOCATED_PORT1;
34181312:	f44f 3300 	mov.w	r3, #131072	@ 0x20000
34181316:	667b      	str	r3, [r7, #100]	@ 0x64
  DMA_InitStruct.LinkStepMode = LL_DMA_LSM_FULL_EXECUTION;
34181318:	2300      	movs	r3, #0
3418131a:	66bb      	str	r3, [r7, #104]	@ 0x68
  DMA_InitStruct.LinkedListBaseAddr = 0x00000000U;
3418131c:	2300      	movs	r3, #0
3418131e:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
  DMA_InitStruct.LinkedListAddrOffset = 0x00000000U;
34181322:	2300      	movs	r3, #0
34181324:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
  LL_DMA_Init(GPDMA1, LL_DMA_CHANNEL_3, &DMA_InitStruct);
34181328:	463b      	mov	r3, r7
3418132a:	461a      	mov	r2, r3
3418132c:	2103      	movs	r1, #3
3418132e:	4828      	ldr	r0, [pc, #160]	@ (341813d0 <MX_UCPD1_Init+0x12c>)
34181330:	f00f feae 	bl	34191090 <LL_DMA_Init>

  /* GPDMA1_REQUEST_UCPD1_TX Init */
  DMA_InitStruct.SrcAddress = 0x00000000U;
34181334:	2300      	movs	r3, #0
34181336:	603b      	str	r3, [r7, #0]
  DMA_InitStruct.DestAddress = 0x00000000U;
34181338:	2300      	movs	r3, #0
3418133a:	607b      	str	r3, [r7, #4]
  DMA_InitStruct.Direction = LL_DMA_DIRECTION_MEMORY_TO_PERIPH;
3418133c:	f44f 6380 	mov.w	r3, #1024	@ 0x400
34181340:	60bb      	str	r3, [r7, #8]
  DMA_InitStruct.BlkHWRequest = LL_DMA_HWREQUEST_SINGLEBURST;
34181342:	2300      	movs	r3, #0
34181344:	60fb      	str	r3, [r7, #12]
  DMA_InitStruct.DataAlignment = LL_DMA_DATA_ALIGN_ZEROPADD;
34181346:	2300      	movs	r3, #0
34181348:	613b      	str	r3, [r7, #16]
  DMA_InitStruct.SrcBurstLength = 1;
3418134a:	2301      	movs	r3, #1
3418134c:	617b      	str	r3, [r7, #20]
  DMA_InitStruct.DestBurstLength = 1;
3418134e:	2301      	movs	r3, #1
34181350:	61bb      	str	r3, [r7, #24]
  DMA_InitStruct.SrcDataWidth = LL_DMA_SRC_DATAWIDTH_BYTE;
34181352:	2300      	movs	r3, #0
34181354:	61fb      	str	r3, [r7, #28]
  DMA_InitStruct.DestDataWidth = LL_DMA_DEST_DATAWIDTH_BYTE;
34181356:	2300      	movs	r3, #0
34181358:	623b      	str	r3, [r7, #32]
  DMA_InitStruct.SrcIncMode = LL_DMA_SRC_INCREMENT;
3418135a:	2308      	movs	r3, #8
3418135c:	627b      	str	r3, [r7, #36]	@ 0x24
  DMA_InitStruct.DestIncMode = LL_DMA_DEST_FIXED;
3418135e:	2300      	movs	r3, #0
34181360:	62bb      	str	r3, [r7, #40]	@ 0x28
  DMA_InitStruct.Priority = LL_DMA_LOW_PRIORITY_LOW_WEIGHT;
34181362:	2300      	movs	r3, #0
34181364:	62fb      	str	r3, [r7, #44]	@ 0x2c
  DMA_InitStruct.BlkDataLength = 0x00000000U;
34181366:	2300      	movs	r3, #0
34181368:	633b      	str	r3, [r7, #48]	@ 0x30
  DMA_InitStruct.TriggerMode = LL_DMA_TRIGM_BLK_TRANSFER;
3418136a:	2300      	movs	r3, #0
3418136c:	63bb      	str	r3, [r7, #56]	@ 0x38
  DMA_InitStruct.TriggerPolarity = LL_DMA_TRIG_POLARITY_MASKED;
3418136e:	2300      	movs	r3, #0
34181370:	63fb      	str	r3, [r7, #60]	@ 0x3c
  DMA_InitStruct.TriggerSelection = 0x00000000U;
34181372:	2300      	movs	r3, #0
34181374:	643b      	str	r3, [r7, #64]	@ 0x40
  DMA_InitStruct.Request = LL_GPDMA1_REQUEST_UCPD1_TX;
34181376:	238a      	movs	r3, #138	@ 0x8a
34181378:	647b      	str	r3, [r7, #68]	@ 0x44
  DMA_InitStruct.TransferEventMode = LL_DMA_TCEM_BLK_TRANSFER;
3418137a:	2300      	movs	r3, #0
3418137c:	64bb      	str	r3, [r7, #72]	@ 0x48
  DMA_InitStruct.SrcAllocatedPort = LL_DMA_SRC_ALLOCATED_PORT0;
3418137e:	2300      	movs	r3, #0
34181380:	65fb      	str	r3, [r7, #92]	@ 0x5c
  DMA_InitStruct.DestAllocatedPort = LL_DMA_DEST_ALLOCATED_PORT0;
34181382:	2300      	movs	r3, #0
34181384:	663b      	str	r3, [r7, #96]	@ 0x60
  DMA_InitStruct.LinkAllocatedPort = LL_DMA_LINK_ALLOCATED_PORT1;
34181386:	f44f 3300 	mov.w	r3, #131072	@ 0x20000
3418138a:	667b      	str	r3, [r7, #100]	@ 0x64
  DMA_InitStruct.LinkStepMode = LL_DMA_LSM_FULL_EXECUTION;
3418138c:	2300      	movs	r3, #0
3418138e:	66bb      	str	r3, [r7, #104]	@ 0x68
  DMA_InitStruct.LinkedListBaseAddr = 0x00000000U;
34181390:	2300      	movs	r3, #0
34181392:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
  DMA_InitStruct.LinkedListAddrOffset = 0x00000000U;
34181396:	2300      	movs	r3, #0
34181398:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
  LL_DMA_Init(GPDMA1, LL_DMA_CHANNEL_2, &DMA_InitStruct);
3418139c:	463b      	mov	r3, r7
3418139e:	461a      	mov	r2, r3
341813a0:	2102      	movs	r1, #2
341813a2:	480b      	ldr	r0, [pc, #44]	@ (341813d0 <MX_UCPD1_Init+0x12c>)
341813a4:	f00f fe74 	bl	34191090 <LL_DMA_Init>

  /* UCPD1 interrupt Init */
  NVIC_SetPriority(UCPD1_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));
341813a8:	f7ff fc9c 	bl	34180ce4 <__NVIC_GetPriorityGrouping>
341813ac:	4603      	mov	r3, r0
341813ae:	2200      	movs	r2, #0
341813b0:	2100      	movs	r1, #0
341813b2:	4618      	mov	r0, r3
341813b4:	f7ff fcec 	bl	34180d90 <NVIC_EncodePriority>
341813b8:	4603      	mov	r3, r0
341813ba:	4619      	mov	r1, r3
341813bc:	20b0      	movs	r0, #176	@ 0xb0
341813be:	f7ff fcbd 	bl	34180d3c <__NVIC_SetPriority>
  NVIC_EnableIRQ(UCPD1_IRQn);
341813c2:	20b0      	movs	r0, #176	@ 0xb0
341813c4:	f7ff fc9c 	bl	34180d00 <__NVIC_EnableIRQ>

  /* USER CODE END UCPD1_Init 1 */
  /* USER CODE BEGIN UCPD1_Init 2 */

  /* USER CODE END UCPD1_Init 2 */
}
341813c8:	bf00      	nop
341813ca:	3798      	adds	r7, #152	@ 0x98
341813cc:	46bd      	mov	sp, r7
341813ce:	bd80      	pop	{r7, pc}
341813d0:	50021000 	.word	0x50021000

341813d4 <MX_SDMMC2_SD_Init>:
  * @brief SDMMC2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_SDMMC2_SD_Init(void)
{
341813d4:	b580      	push	{r7, lr}
341813d6:	af00      	add	r7, sp, #0
  /* USER CODE END SDMMC2_Init 0 */

  /* USER CODE BEGIN SDMMC2_Init 1 */

  /* USER CODE END SDMMC2_Init 1 */
  hsd1.Instance = SDMMC2;
341813d8:	4b0d      	ldr	r3, [pc, #52]	@ (34181410 <MX_SDMMC2_SD_Init+0x3c>)
341813da:	4a0e      	ldr	r2, [pc, #56]	@ (34181414 <MX_SDMMC2_SD_Init+0x40>)
341813dc:	601a      	str	r2, [r3, #0]
  hsd1.Init.ClockEdge = SDMMC_CLOCK_EDGE_RISING;
341813de:	4b0c      	ldr	r3, [pc, #48]	@ (34181410 <MX_SDMMC2_SD_Init+0x3c>)
341813e0:	2200      	movs	r2, #0
341813e2:	605a      	str	r2, [r3, #4]
  hsd1.Init.ClockPowerSave = SDMMC_CLOCK_POWER_SAVE_DISABLE;
341813e4:	4b0a      	ldr	r3, [pc, #40]	@ (34181410 <MX_SDMMC2_SD_Init+0x3c>)
341813e6:	2200      	movs	r2, #0
341813e8:	609a      	str	r2, [r3, #8]
  hsd1.Init.BusWide = SDMMC_BUS_WIDE_1B;
341813ea:	4b09      	ldr	r3, [pc, #36]	@ (34181410 <MX_SDMMC2_SD_Init+0x3c>)
341813ec:	2200      	movs	r2, #0
341813ee:	60da      	str	r2, [r3, #12]
  hsd1.Init.HardwareFlowControl = SDMMC_HARDWARE_FLOW_CONTROL_DISABLE;
341813f0:	4b07      	ldr	r3, [pc, #28]	@ (34181410 <MX_SDMMC2_SD_Init+0x3c>)
341813f2:	2200      	movs	r2, #0
341813f4:	611a      	str	r2, [r3, #16]
  hsd1.Init.ClockDiv = 0;
341813f6:	4b06      	ldr	r3, [pc, #24]	@ (34181410 <MX_SDMMC2_SD_Init+0x3c>)
341813f8:	2200      	movs	r2, #0
341813fa:	615a      	str	r2, [r3, #20]
  if (HAL_SD_Init(&hsd1) != HAL_OK)
341813fc:	4804      	ldr	r0, [pc, #16]	@ (34181410 <MX_SDMMC2_SD_Init+0x3c>)
341813fe:	f00d fbc7 	bl	3418eb90 <HAL_SD_Init>
34181402:	4603      	mov	r3, r0
34181404:	2b00      	cmp	r3, #0
34181406:	d001      	beq.n	3418140c <MX_SDMMC2_SD_Init+0x38>
  {
    Error_Handler();
34181408:	f000 f8da 	bl	341815c0 <Error_Handler>
  }
  /* USER CODE BEGIN SDMMC2_Init 2 */

  /* USER CODE END SDMMC2_Init 2 */

}
3418140c:	bf00      	nop
3418140e:	bd80      	pop	{r7, pc}
34181410:	341c1a3c 	.word	0x341c1a3c
34181414:	58026800 	.word	0x58026800

34181418 <MX_GPIO_Init>:
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
34181418:	b580      	push	{r7, lr}
3418141a:	b086      	sub	sp, #24
3418141c:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
3418141e:	1d3b      	adds	r3, r7, #4
34181420:	2200      	movs	r2, #0
34181422:	601a      	str	r2, [r3, #0]
34181424:	605a      	str	r2, [r3, #4]
34181426:	609a      	str	r2, [r3, #8]
34181428:	60da      	str	r2, [r3, #12]
3418142a:	611a      	str	r2, [r3, #16]

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOH_CLK_ENABLE();
3418142c:	2080      	movs	r0, #128	@ 0x80
3418142e:	f7ff fd0f 	bl	34180e50 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOC_CLK_ENABLE();
34181432:	2004      	movs	r0, #4
34181434:	f7ff fd0c 	bl	34180e50 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOA_CLK_ENABLE();
34181438:	2001      	movs	r0, #1
3418143a:	f7ff fd09 	bl	34180e50 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOB_CLK_ENABLE();
3418143e:	2002      	movs	r0, #2
34181440:	f7ff fd06 	bl	34180e50 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOC_CLK_ENABLE();
34181444:	2004      	movs	r0, #4
34181446:	f7ff fd03 	bl	34180e50 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOD_CLK_ENABLE();
3418144a:	2008      	movs	r0, #8
3418144c:	f7ff fd00 	bl	34180e50 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOG_CLK_ENABLE();
34181450:	2040      	movs	r0, #64	@ 0x40
34181452:	f7ff fcfd 	bl	34180e50 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOO_CLK_ENABLE();
34181456:	f44f 4080 	mov.w	r0, #16384	@ 0x4000
3418145a:	f7ff fcf9 	bl	34180e50 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOE_CLK_ENABLE();
3418145e:	2010      	movs	r0, #16
34181460:	f7ff fcf6 	bl	34180e50 <LL_AHB4_GRP1_EnableClock>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(LED_RED_GPIO_Port, LED_RED_Pin, GPIO_PIN_SET);
34181464:	2201      	movs	r2, #1
34181466:	f44f 6180 	mov.w	r1, #1024	@ 0x400
3418146a:	4811      	ldr	r0, [pc, #68]	@ (341814b0 <MX_GPIO_Init+0x98>)
3418146c:	f005 fff4 	bl	34187458 <HAL_GPIO_WritePin>

  /*Configure GPIO pin : LED_RED_Pin */
  GPIO_InitStruct.Pin = LED_RED_Pin;
34181470:	f44f 6380 	mov.w	r3, #1024	@ 0x400
34181474:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
34181476:	2301      	movs	r3, #1
34181478:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
3418147a:	2300      	movs	r3, #0
3418147c:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
3418147e:	2303      	movs	r3, #3
34181480:	613b      	str	r3, [r7, #16]
  HAL_GPIO_Init(LED_RED_GPIO_Port, &GPIO_InitStruct);
34181482:	1d3b      	adds	r3, r7, #4
34181484:	4619      	mov	r1, r3
34181486:	480a      	ldr	r0, [pc, #40]	@ (341814b0 <MX_GPIO_Init+0x98>)
34181488:	f005 fcdc 	bl	34186e44 <HAL_GPIO_Init>

  /*Configure GPIO pin : SD_DETECT_Pin */
  GPIO_InitStruct.Pin = SD_DETECT_Pin;
3418148c:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
34181490:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING_FALLING;
34181492:	f44f 1344 	mov.w	r3, #3211264	@ 0x310000
34181496:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_PULLUP;
34181498:	2301      	movs	r3, #1
3418149a:	60fb      	str	r3, [r7, #12]
  HAL_GPIO_Init(SD_DETECT_GPIO_Port, &GPIO_InitStruct);
3418149c:	1d3b      	adds	r3, r7, #4
3418149e:	4619      	mov	r1, r3
341814a0:	4804      	ldr	r0, [pc, #16]	@ (341814b4 <MX_GPIO_Init+0x9c>)
341814a2:	f005 fccf 	bl	34186e44 <HAL_GPIO_Init>

}
341814a6:	bf00      	nop
341814a8:	3718      	adds	r7, #24
341814aa:	46bd      	mov	sp, r7
341814ac:	bd80      	pop	{r7, pc}
341814ae:	bf00      	nop
341814b0:	56021800 	.word	0x56021800
341814b4:	56023400 	.word	0x56023400

341814b8 <RISAF_Config>:
/**
* @brief  RISAF Configuration.
* @retval None
*/
static void RISAF_Config(void)
{
341814b8:	b580      	push	{r7, lr}
341814ba:	b082      	sub	sp, #8
341814bc:	af00      	add	r7, sp, #0
  RIMC_MasterConfig_t     RIMC_master = {0};
341814be:	463b      	mov	r3, r7
341814c0:	2200      	movs	r2, #0
341814c2:	601a      	str	r2, [r3, #0]
341814c4:	605a      	str	r2, [r3, #4]

  __HAL_RCC_RIFSC_CLK_ENABLE();
341814c6:	f44f 7000 	mov.w	r0, #512	@ 0x200
341814ca:	f7ff fcab 	bl	34180e24 <LL_AHB3_GRP1_EnableClock>

  RIMC_master.MasterCID = RIF_CID_1;
341814ce:	2302      	movs	r3, #2
341814d0:	603b      	str	r3, [r7, #0]
  RIMC_master.SecPriv = RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV;
341814d2:	2303      	movs	r3, #3
341814d4:	607b      	str	r3, [r7, #4]

  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_OTG1, &RIMC_master);
341814d6:	463b      	mov	r3, r7
341814d8:	4619      	mov	r1, r3
341814da:	2004      	movs	r0, #4
341814dc:	f00d faca 	bl	3418ea74 <HAL_RIF_RIMC_ConfigMasterAttributes>
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_OTG2, &RIMC_master);
341814e0:	463b      	mov	r3, r7
341814e2:	4619      	mov	r1, r3
341814e4:	2005      	movs	r0, #5
341814e6:	f00d fac5 	bl	3418ea74 <HAL_RIF_RIMC_ConfigMasterAttributes>
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_SDMMC2, &RIMC_master);
341814ea:	463b      	mov	r3, r7
341814ec:	4619      	mov	r1, r3
341814ee:	2003      	movs	r0, #3
341814f0:	f00d fac0 	bl	3418ea74 <HAL_RIF_RIMC_ConfigMasterAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_OTG1HS, RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
341814f4:	2103      	movs	r1, #3
341814f6:	480a      	ldr	r0, [pc, #40]	@ (34181520 <RISAF_Config+0x68>)
341814f8:	f00d faf8 	bl	3418eaec <HAL_RIF_RISC_SetSlaveSecureAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_OTG2HS, RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
341814fc:	2103      	movs	r1, #3
341814fe:	4809      	ldr	r0, [pc, #36]	@ (34181524 <RISAF_Config+0x6c>)
34181500:	f00d faf4 	bl	3418eaec <HAL_RIF_RISC_SetSlaveSecureAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_SDMMC2 , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
34181504:	2103      	movs	r1, #3
34181506:	4808      	ldr	r0, [pc, #32]	@ (34181528 <RISAF_Config+0x70>)
34181508:	f00d faf0 	bl	3418eaec <HAL_RIF_RISC_SetSlaveSecureAttributes>

  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_ADC12, RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
3418150c:	2103      	movs	r1, #3
3418150e:	f04f 5000 	mov.w	r0, #536870912	@ 0x20000000
34181512:	f00d faeb 	bl	3418eaec <HAL_RIF_RISC_SetSlaveSecureAttributes>

}
34181516:	bf00      	nop
34181518:	3708      	adds	r7, #8
3418151a:	46bd      	mov	sp, r7
3418151c:	bd80      	pop	{r7, pc}
3418151e:	bf00      	nop
34181520:	10000018 	.word	0x10000018
34181524:	10000019 	.word	0x10000019
34181528:	10000016 	.word	0x10000016

3418152c <MX_USB1_OTG_HS_PCD_Init>:
  * @param None
  * @retval None
  */

void MX_USB1_OTG_HS_PCD_Init(void)
{
3418152c:	b580      	push	{r7, lr}
3418152e:	af00      	add	r7, sp, #0

  /* USER CODE END USB1_OTG_HS_Init 0 */

  /* USER CODE BEGIN USB1_OTG_HS_Init 1 */

  memset(&hpcd_USB1_OTG_HS, 0x0, sizeof(PCD_HandleTypeDef));
34181530:	f240 42e4 	movw	r2, #1252	@ 0x4e4
34181534:	2100      	movs	r1, #0
34181536:	4817      	ldr	r0, [pc, #92]	@ (34181594 <MX_USB1_OTG_HS_PCD_Init+0x68>)
34181538:	f01c fdc2 	bl	3419e0c0 <memset>

  /* USER CODE END USB1_OTG_HS_Init 1 */
  hpcd_USB1_OTG_HS.Instance = USB1_OTG_HS;
3418153c:	4b15      	ldr	r3, [pc, #84]	@ (34181594 <MX_USB1_OTG_HS_PCD_Init+0x68>)
3418153e:	4a16      	ldr	r2, [pc, #88]	@ (34181598 <MX_USB1_OTG_HS_PCD_Init+0x6c>)
34181540:	601a      	str	r2, [r3, #0]
  hpcd_USB1_OTG_HS.Init.dev_endpoints = 9;
34181542:	4b14      	ldr	r3, [pc, #80]	@ (34181594 <MX_USB1_OTG_HS_PCD_Init+0x68>)
34181544:	2209      	movs	r2, #9
34181546:	711a      	strb	r2, [r3, #4]
  hpcd_USB1_OTG_HS.Init.speed = PCD_SPEED_HIGH;
34181548:	4b12      	ldr	r3, [pc, #72]	@ (34181594 <MX_USB1_OTG_HS_PCD_Init+0x68>)
3418154a:	2200      	movs	r2, #0
3418154c:	71da      	strb	r2, [r3, #7]
  hpcd_USB1_OTG_HS.Init.dma_enable = DISABLE;
3418154e:	4b11      	ldr	r3, [pc, #68]	@ (34181594 <MX_USB1_OTG_HS_PCD_Init+0x68>)
34181550:	2200      	movs	r2, #0
34181552:	719a      	strb	r2, [r3, #6]
  hpcd_USB1_OTG_HS.Init.phy_itface = USB_OTG_HS_EMBEDDED_PHY;
34181554:	4b0f      	ldr	r3, [pc, #60]	@ (34181594 <MX_USB1_OTG_HS_PCD_Init+0x68>)
34181556:	2203      	movs	r2, #3
34181558:	725a      	strb	r2, [r3, #9]
  hpcd_USB1_OTG_HS.Init.Sof_enable = DISABLE;
3418155a:	4b0e      	ldr	r3, [pc, #56]	@ (34181594 <MX_USB1_OTG_HS_PCD_Init+0x68>)
3418155c:	2200      	movs	r2, #0
3418155e:	729a      	strb	r2, [r3, #10]
  hpcd_USB1_OTG_HS.Init.low_power_enable = DISABLE;
34181560:	4b0c      	ldr	r3, [pc, #48]	@ (34181594 <MX_USB1_OTG_HS_PCD_Init+0x68>)
34181562:	2200      	movs	r2, #0
34181564:	72da      	strb	r2, [r3, #11]
  hpcd_USB1_OTG_HS.Init.lpm_enable = DISABLE;
34181566:	4b0b      	ldr	r3, [pc, #44]	@ (34181594 <MX_USB1_OTG_HS_PCD_Init+0x68>)
34181568:	2200      	movs	r2, #0
3418156a:	731a      	strb	r2, [r3, #12]
  hpcd_USB1_OTG_HS.Init.vbus_sensing_enable = DISABLE;
3418156c:	4b09      	ldr	r3, [pc, #36]	@ (34181594 <MX_USB1_OTG_HS_PCD_Init+0x68>)
3418156e:	2200      	movs	r2, #0
34181570:	739a      	strb	r2, [r3, #14]
  hpcd_USB1_OTG_HS.Init.use_dedicated_ep1 = DISABLE;
34181572:	4b08      	ldr	r3, [pc, #32]	@ (34181594 <MX_USB1_OTG_HS_PCD_Init+0x68>)
34181574:	2200      	movs	r2, #0
34181576:	73da      	strb	r2, [r3, #15]
  hpcd_USB1_OTG_HS.Init.use_external_vbus = DISABLE;
34181578:	4b06      	ldr	r3, [pc, #24]	@ (34181594 <MX_USB1_OTG_HS_PCD_Init+0x68>)
3418157a:	2200      	movs	r2, #0
3418157c:	741a      	strb	r2, [r3, #16]
  if (HAL_PCD_Init(&hpcd_USB1_OTG_HS) != HAL_OK)
3418157e:	4805      	ldr	r0, [pc, #20]	@ (34181594 <MX_USB1_OTG_HS_PCD_Init+0x68>)
34181580:	f006 fe3d 	bl	341881fe <HAL_PCD_Init>
34181584:	4603      	mov	r3, r0
34181586:	2b00      	cmp	r3, #0
34181588:	d001      	beq.n	3418158e <MX_USB1_OTG_HS_PCD_Init+0x62>
  {
    Error_Handler();
3418158a:	f000 f819 	bl	341815c0 <Error_Handler>
  }
  /* USER CODE BEGIN USB1_OTG_HS_Init 2 */

  /* USER CODE END USB1_OTG_HS_Init 2 */

}
3418158e:	bf00      	nop
34181590:	bd80      	pop	{r7, pc}
34181592:	bf00      	nop
34181594:	341fc800 	.word	0x341fc800
34181598:	58040000 	.word	0x58040000

3418159c <HAL_TIM_PeriodElapsedCallback>:
  * a global variable "uwTick" used as application time base.
  * @param  htim : TIM handle
  * @retval None
  */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
3418159c:	b580      	push	{r7, lr}
3418159e:	b082      	sub	sp, #8
341815a0:	af00      	add	r7, sp, #0
341815a2:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN Callback 0 */

  /* USER CODE END Callback 0 */
  if (htim->Instance == TIM6) {
341815a4:	687b      	ldr	r3, [r7, #4]
341815a6:	681b      	ldr	r3, [r3, #0]
341815a8:	4a04      	ldr	r2, [pc, #16]	@ (341815bc <HAL_TIM_PeriodElapsedCallback+0x20>)
341815aa:	4293      	cmp	r3, r2
341815ac:	d101      	bne.n	341815b2 <HAL_TIM_PeriodElapsedCallback+0x16>
    HAL_IncTick();
341815ae:	f003 ffef 	bl	34185590 <HAL_IncTick>
  }
  /* USER CODE BEGIN Callback 1 */

  /* USER CODE END Callback 1 */
}
341815b2:	bf00      	nop
341815b4:	3708      	adds	r7, #8
341815b6:	46bd      	mov	sp, r7
341815b8:	bd80      	pop	{r7, pc}
341815ba:	bf00      	nop
341815bc:	50001000 	.word	0x50001000

341815c0 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
341815c0:	b480      	push	{r7}
341815c2:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  while (1)
341815c4:	bf00      	nop
341815c6:	e7fd      	b.n	341815c4 <Error_Handler+0x4>

341815c8 <LL_AHB4_GRP1_EnableClock>:
{
341815c8:	b480      	push	{r7}
341815ca:	b085      	sub	sp, #20
341815cc:	af00      	add	r7, sp, #0
341815ce:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB4ENSR, Periphs);
341815d0:	4a07      	ldr	r2, [pc, #28]	@ (341815f0 <LL_AHB4_GRP1_EnableClock+0x28>)
341815d2:	687b      	ldr	r3, [r7, #4]
341815d4:	f8c2 3a5c 	str.w	r3, [r2, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
341815d8:	4b05      	ldr	r3, [pc, #20]	@ (341815f0 <LL_AHB4_GRP1_EnableClock+0x28>)
341815da:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
341815de:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
341815e0:	68fb      	ldr	r3, [r7, #12]
}
341815e2:	bf00      	nop
341815e4:	3714      	adds	r7, #20
341815e6:	46bd      	mov	sp, r7
341815e8:	f85d 7b04 	ldr.w	r7, [sp], #4
341815ec:	4770      	bx	lr
341815ee:	bf00      	nop
341815f0:	56028000 	.word	0x56028000

341815f4 <LL_AHB5_GRP1_EnableClock>:
{
341815f4:	b480      	push	{r7}
341815f6:	b085      	sub	sp, #20
341815f8:	af00      	add	r7, sp, #0
341815fa:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB5ENSR, Periphs);
341815fc:	4a07      	ldr	r2, [pc, #28]	@ (3418161c <LL_AHB5_GRP1_EnableClock+0x28>)
341815fe:	687b      	ldr	r3, [r7, #4]
34181600:	f8c2 3a60 	str.w	r3, [r2, #2656]	@ 0xa60
  tmpreg = READ_REG(RCC->AHB5ENR);
34181604:	4b05      	ldr	r3, [pc, #20]	@ (3418161c <LL_AHB5_GRP1_EnableClock+0x28>)
34181606:	f8d3 3260 	ldr.w	r3, [r3, #608]	@ 0x260
3418160a:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
3418160c:	68fb      	ldr	r3, [r7, #12]
}
3418160e:	bf00      	nop
34181610:	3714      	adds	r7, #20
34181612:	46bd      	mov	sp, r7
34181614:	f85d 7b04 	ldr.w	r7, [sp], #4
34181618:	4770      	bx	lr
3418161a:	bf00      	nop
3418161c:	56028000 	.word	0x56028000

34181620 <LL_AHB5_GRP1_ForceReset>:
{
34181620:	b480      	push	{r7}
34181622:	b083      	sub	sp, #12
34181624:	af00      	add	r7, sp, #0
34181626:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB5RSTSR, Periphs);
34181628:	4a04      	ldr	r2, [pc, #16]	@ (3418163c <LL_AHB5_GRP1_ForceReset+0x1c>)
3418162a:	687b      	ldr	r3, [r7, #4]
3418162c:	f8c2 3a20 	str.w	r3, [r2, #2592]	@ 0xa20
}
34181630:	bf00      	nop
34181632:	370c      	adds	r7, #12
34181634:	46bd      	mov	sp, r7
34181636:	f85d 7b04 	ldr.w	r7, [sp], #4
3418163a:	4770      	bx	lr
3418163c:	56028000 	.word	0x56028000

34181640 <LL_AHB5_GRP1_ReleaseReset>:
{
34181640:	b480      	push	{r7}
34181642:	b083      	sub	sp, #12
34181644:	af00      	add	r7, sp, #0
34181646:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB5RSTCR, Periphs);
34181648:	4b06      	ldr	r3, [pc, #24]	@ (34181664 <LL_AHB5_GRP1_ReleaseReset+0x24>)
3418164a:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3418164e:	461a      	mov	r2, r3
34181650:	687b      	ldr	r3, [r7, #4]
34181652:	f8c2 3220 	str.w	r3, [r2, #544]	@ 0x220
}
34181656:	bf00      	nop
34181658:	370c      	adds	r7, #12
3418165a:	46bd      	mov	sp, r7
3418165c:	f85d 7b04 	ldr.w	r7, [sp], #4
34181660:	4770      	bx	lr
34181662:	bf00      	nop
34181664:	56028000 	.word	0x56028000

34181668 <LL_APB4_GRP2_EnableClock>:
  *         @arg @ref LL_APB4_GRP2_PERIPH_SYSCFG
  *         @arg @ref LL_APB4_GRP2_PERIPH_DTS
  * @retval None
  */
__STATIC_INLINE void LL_APB4_GRP2_EnableClock(uint32_t Periphs)
{
34181668:	b480      	push	{r7}
3418166a:	b085      	sub	sp, #20
3418166c:	af00      	add	r7, sp, #0
3418166e:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->APB4ENSR2, Periphs);
34181670:	4a07      	ldr	r2, [pc, #28]	@ (34181690 <LL_APB4_GRP2_EnableClock+0x28>)
34181672:	687b      	ldr	r3, [r7, #4]
34181674:	f8c2 3a78 	str.w	r3, [r2, #2680]	@ 0xa78
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->APB4ENR2);
34181678:	4b05      	ldr	r3, [pc, #20]	@ (34181690 <LL_APB4_GRP2_EnableClock+0x28>)
3418167a:	f8d3 3278 	ldr.w	r3, [r3, #632]	@ 0x278
3418167e:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34181680:	68fb      	ldr	r3, [r7, #12]
}
34181682:	bf00      	nop
34181684:	3714      	adds	r7, #20
34181686:	46bd      	mov	sp, r7
34181688:	f85d 7b04 	ldr.w	r7, [sp], #4
3418168c:	4770      	bx	lr
3418168e:	bf00      	nop
34181690:	56028000 	.word	0x56028000

34181694 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>:
  * @brief  Select the HSE divided by 2 as hse_div2_osc_ck output clock
  * @rmtoll HSECFGR      HSEDIV2SEL    LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock(void)
{
34181694:	b480      	push	{r7}
34181696:	af00      	add	r7, sp, #0
  SET_BIT(RCC->HSECFGR, RCC_HSECFGR_HSEDIV2SEL);
34181698:	4b05      	ldr	r3, [pc, #20]	@ (341816b0 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock+0x1c>)
3418169a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3418169c:	4a04      	ldr	r2, [pc, #16]	@ (341816b0 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock+0x1c>)
3418169e:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
341816a2:	6553      	str	r3, [r2, #84]	@ 0x54
}
341816a4:	bf00      	nop
341816a6:	46bd      	mov	sp, r7
341816a8:	f85d 7b04 	ldr.w	r7, [sp], #4
341816ac:	4770      	bx	lr
341816ae:	bf00      	nop
341816b0:	56028000 	.word	0x56028000

341816b4 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
341816b4:	b580      	push	{r7, lr}
341816b6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
341816b8:	2001      	movs	r0, #1
341816ba:	f7ff ffd5 	bl	34181668 <LL_APB4_GRP2_EnableClock>
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
341816be:	bf00      	nop
341816c0:	bd80      	pop	{r7, pc}
	...

341816c4 <HAL_PCD_MspInit>:
void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
341816c4:	b580      	push	{r7, lr}
341816c6:	b0e6      	sub	sp, #408	@ 0x198
341816c8:	af00      	add	r7, sp, #0
341816ca:	f507 73cc 	add.w	r3, r7, #408	@ 0x198
341816ce:	f5a3 73ca 	sub.w	r3, r3, #404	@ 0x194
341816d2:	6018      	str	r0, [r3, #0]
  if (pcdHandle->Instance==USB1_OTG_HS)
341816d4:	f507 73cc 	add.w	r3, r7, #408	@ 0x198
341816d8:	f5a3 73ca 	sub.w	r3, r3, #404	@ 0x194
341816dc:	681b      	ldr	r3, [r3, #0]
341816de:	681b      	ldr	r3, [r3, #0]
341816e0:	4a4d      	ldr	r2, [pc, #308]	@ (34181818 <HAL_PCD_MspInit+0x154>)
341816e2:	4293      	cmp	r3, r2
341816e4:	f040 8092 	bne.w	3418180c <HAL_PCD_MspInit+0x148>
  {
    /* USER CODE BEGIN USB_OTG_HS_MspInit 0 */

    /* USER CODE END USB_OTG_HS_MspInit 0 */
    /* Enable VDDUSB */
    __HAL_RCC_PWR_CLK_ENABLE();
341816e8:	f44f 2080 	mov.w	r0, #262144	@ 0x40000
341816ec:	f7ff ff6c 	bl	341815c8 <LL_AHB4_GRP1_EnableClock>
    HAL_PWREx_EnableVddUSBVMEN();
341816f0:	f008 f908 	bl	34189904 <HAL_PWREx_EnableVddUSBVMEN>
    while(__HAL_PWR_GET_FLAG(PWR_FLAG_USB33RDY));
341816f4:	bf00      	nop
341816f6:	4b49      	ldr	r3, [pc, #292]	@ (3418181c <HAL_PCD_MspInit+0x158>)
341816f8:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
341816fa:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
341816fe:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
34181702:	d0f8      	beq.n	341816f6 <HAL_PCD_MspInit+0x32>
    HAL_PWREx_EnableVddUSB();
34181704:	f008 f89e 	bl	34189844 <HAL_PWREx_EnableVddUSB>

    /** Initializes the peripherals clock */
    RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
34181708:	f507 73cc 	add.w	r3, r7, #408	@ 0x198
3418170c:	f5a3 73c8 	sub.w	r3, r3, #400	@ 0x190
34181710:	4618      	mov	r0, r3
34181712:	f44f 73c8 	mov.w	r3, #400	@ 0x190
34181716:	461a      	mov	r2, r3
34181718:	2100      	movs	r1, #0
3418171a:	f01c fcd1 	bl	3419e0c0 <memset>
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USBOTGHS1;
3418171e:	f507 73cc 	add.w	r3, r7, #408	@ 0x198
34181722:	f5a3 71c8 	sub.w	r1, r3, #400	@ 0x190
34181726:	f04f 0200 	mov.w	r2, #0
3418172a:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
3418172e:	e9c1 2300 	strd	r2, r3, [r1]
    PeriphClkInitStruct.UsbOtgHs1ClockSelection = RCC_USBPHY1REFCLKSOURCE_HSE_DIRECT;
34181732:	f507 73cc 	add.w	r3, r7, #408	@ 0x198
34181736:	f5a3 73c8 	sub.w	r3, r3, #400	@ 0x190
3418173a:	4a39      	ldr	r2, [pc, #228]	@ (34181820 <HAL_PCD_MspInit+0x15c>)
3418173c:	f8c3 217c 	str.w	r2, [r3, #380]	@ 0x17c

    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
34181740:	f107 0308 	add.w	r3, r7, #8
34181744:	4618      	mov	r0, r3
34181746:	f009 fee1 	bl	3418b50c <HAL_RCCEx_PeriphCLKConfig>
3418174a:	4603      	mov	r3, r0
3418174c:	2b00      	cmp	r3, #0
3418174e:	d001      	beq.n	34181754 <HAL_PCD_MspInit+0x90>
    {
      /* Initialization Error */
      Error_Handler();
34181750:	f7ff ff36 	bl	341815c0 <Error_Handler>
    }

    /** Set USB OTG HS PHY1 Reference Clock Source */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USBPHY1;
34181754:	f507 73cc 	add.w	r3, r7, #408	@ 0x198
34181758:	f5a3 71c8 	sub.w	r1, r3, #400	@ 0x190
3418175c:	f04f 0200 	mov.w	r2, #0
34181760:	f44f 2380 	mov.w	r3, #262144	@ 0x40000
34181764:	e9c1 2300 	strd	r2, r3, [r1]
    PeriphClkInitStruct.UsbPhy1ClockSelection = RCC_USBPHY1REFCLKSOURCE_HSE_DIRECT;
34181768:	f507 73cc 	add.w	r3, r7, #408	@ 0x198
3418176c:	f5a3 73c8 	sub.w	r3, r3, #400	@ 0x190
34181770:	4a2b      	ldr	r2, [pc, #172]	@ (34181820 <HAL_PCD_MspInit+0x15c>)
34181772:	f8c3 2178 	str.w	r2, [r3, #376]	@ 0x178

    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
34181776:	f107 0308 	add.w	r3, r7, #8
3418177a:	4618      	mov	r0, r3
3418177c:	f009 fec6 	bl	3418b50c <HAL_RCCEx_PeriphCLKConfig>
34181780:	4603      	mov	r3, r0
34181782:	2b00      	cmp	r3, #0
34181784:	d001      	beq.n	3418178a <HAL_PCD_MspInit+0xc6>
    {
      /* Initialization Error */
      Error_Handler();
34181786:	f7ff ff1b 	bl	341815c0 <Error_Handler>
    }

    __HAL_RCC_GPIOA_CLK_ENABLE();
3418178a:	2001      	movs	r0, #1
3418178c:	f7ff ff1c 	bl	341815c8 <LL_AHB4_GRP1_EnableClock>

    LL_AHB5_GRP1_ForceReset(0x00800000);
34181790:	f44f 0000 	mov.w	r0, #8388608	@ 0x800000
34181794:	f7ff ff44 	bl	34181620 <LL_AHB5_GRP1_ForceReset>
    __HAL_RCC_USB1_OTG_HS_FORCE_RESET();
34181798:	f04f 6080 	mov.w	r0, #67108864	@ 0x4000000
3418179c:	f7ff ff40 	bl	34181620 <LL_AHB5_GRP1_ForceReset>
    __HAL_RCC_USB1_OTG_HS_PHY_FORCE_RESET();
341817a0:	f04f 6000 	mov.w	r0, #134217728	@ 0x8000000
341817a4:	f7ff ff3c 	bl	34181620 <LL_AHB5_GRP1_ForceReset>

    LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock();
341817a8:	f7ff ff74 	bl	34181694 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
    LL_AHB5_GRP1_ReleaseReset(0x00800000);
341817ac:	f44f 0000 	mov.w	r0, #8388608	@ 0x800000
341817b0:	f7ff ff46 	bl	34181640 <LL_AHB5_GRP1_ReleaseReset>

    /* Peripheral clock enable */
    __HAL_RCC_USB1_OTG_HS_CLK_ENABLE();
341817b4:	f04f 6080 	mov.w	r0, #67108864	@ 0x4000000
341817b8:	f7ff ff1c 	bl	341815f4 <LL_AHB5_GRP1_EnableClock>

    /* Required few clock cycles before accessing USB PHY Controller Registers */
    HAL_Delay(1);
341817bc:	2001      	movs	r0, #1
341817be:	f003 ff07 	bl	341855d0 <HAL_Delay>

    USB1_HS_PHYC->USBPHYC_CR &= ~(0x7 << 0x4);
341817c2:	4b18      	ldr	r3, [pc, #96]	@ (34181824 <HAL_PCD_MspInit+0x160>)
341817c4:	681b      	ldr	r3, [r3, #0]
341817c6:	4a17      	ldr	r2, [pc, #92]	@ (34181824 <HAL_PCD_MspInit+0x160>)
341817c8:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
341817cc:	6013      	str	r3, [r2, #0]

    USB1_HS_PHYC->USBPHYC_CR |= (0x1 << 16) |
341817ce:	4b15      	ldr	r3, [pc, #84]	@ (34181824 <HAL_PCD_MspInit+0x160>)
341817d0:	681b      	ldr	r3, [r3, #0]
341817d2:	4a14      	ldr	r2, [pc, #80]	@ (34181824 <HAL_PCD_MspInit+0x160>)
341817d4:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
341817d8:	f043 0325 	orr.w	r3, r3, #37	@ 0x25
341817dc:	6013      	str	r3, [r2, #0]
                                (0x2 << 4)  |
                                (0x1 << 2)  |
                                 0x1U;

    __HAL_RCC_USB1_OTG_HS_PHY_RELEASE_RESET();
341817de:	f04f 6000 	mov.w	r0, #134217728	@ 0x8000000
341817e2:	f7ff ff2d 	bl	34181640 <LL_AHB5_GRP1_ReleaseReset>

    /* Required few clock cycles before Releasing Reset */
    HAL_Delay(1);
341817e6:	2001      	movs	r0, #1
341817e8:	f003 fef2 	bl	341855d0 <HAL_Delay>

    __HAL_RCC_USB1_OTG_HS_RELEASE_RESET();
341817ec:	f04f 6080 	mov.w	r0, #67108864	@ 0x4000000
341817f0:	f7ff ff26 	bl	34181640 <LL_AHB5_GRP1_ReleaseReset>

    /* Peripheral PHY clock enable */
    __HAL_RCC_USB1_OTG_HS_PHY_CLK_ENABLE();
341817f4:	f04f 6000 	mov.w	r0, #134217728	@ 0x8000000
341817f8:	f7ff fefc 	bl	341815f4 <LL_AHB5_GRP1_EnableClock>

    /* USB_OTG_HS interrupt Init */
    HAL_NVIC_SetPriority(USB1_OTG_HS_IRQn, 7, 0);
341817fc:	2200      	movs	r2, #0
341817fe:	2107      	movs	r1, #7
34181800:	20b1      	movs	r0, #177	@ 0xb1
34181802:	f005 fa29 	bl	34186c58 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USB1_OTG_HS_IRQn);
34181806:	20b1      	movs	r0, #177	@ 0xb1
34181808:	f005 fa43 	bl	34186c92 <HAL_NVIC_EnableIRQ>

    /* USER CODE BEGIN USB_OTG_HS_MspInit 1 */

    /* USER CODE END USB_OTG_HS_MspInit 1 */
  }
}
3418180c:	bf00      	nop
3418180e:	f507 77cc 	add.w	r7, r7, #408	@ 0x198
34181812:	46bd      	mov	sp, r7
34181814:	bd80      	pop	{r7, pc}
34181816:	bf00      	nop
34181818:	58040000 	.word	0x58040000
3418181c:	56024800 	.word	0x56024800
34181820:	01011014 	.word	0x01011014
34181824:	5803fc00 	.word	0x5803fc00

34181828 <HAL_SD_MspInit>:
  * @brief  Initializes the SD MSP.
  * @param  hsd  SD handle
  * @retval None
  */
void HAL_SD_MspInit(SD_HandleTypeDef* hsd)
{
34181828:	b580      	push	{r7, lr}
3418182a:	b088      	sub	sp, #32
3418182c:	af00      	add	r7, sp, #0
3418182e:	6078      	str	r0, [r7, #4]
    GPIO_InitTypeDef gpio_init_structure = {0};
34181830:	f107 030c 	add.w	r3, r7, #12
34181834:	2200      	movs	r2, #0
34181836:	601a      	str	r2, [r3, #0]
34181838:	605a      	str	r2, [r3, #4]
3418183a:	609a      	str	r2, [r3, #8]
3418183c:	60da      	str	r2, [r3, #12]
3418183e:	611a      	str	r2, [r3, #16]

    HAL_PWREx_EnableVddIO5();
34181840:	f008 f840 	bl	341898c4 <HAL_PWREx_EnableVddIO5>
    /* Enable SDMMC clock */
    __HAL_RCC_SDMMC2_CLK_ENABLE();
34181844:	2080      	movs	r0, #128	@ 0x80
34181846:	f7ff fed5 	bl	341815f4 <LL_AHB5_GRP1_EnableClock>

    /* Enable GPIOs clock */
    __HAL_RCC_GPIOC_CLK_ENABLE();
3418184a:	2004      	movs	r0, #4
3418184c:	f7ff febc 	bl	341815c8 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOE_CLK_ENABLE();
34181850:	2010      	movs	r0, #16
34181852:	f7ff feb9 	bl	341815c8 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOD_CLK_ENABLE();
34181856:	2008      	movs	r0, #8
34181858:	f7ff feb6 	bl	341815c8 <LL_AHB4_GRP1_EnableClock>

    /* Common GPIO configuration */
    gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
3418185c:	2302      	movs	r3, #2
3418185e:	613b      	str	r3, [r7, #16]
    gpio_init_structure.Pull      = GPIO_PULLUP;
34181860:	2301      	movs	r3, #1
34181862:	617b      	str	r3, [r7, #20]
    gpio_init_structure.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;
34181864:	2303      	movs	r3, #3
34181866:	61bb      	str	r3, [r7, #24]
    gpio_init_structure.Alternate = GPIO_AF11_SDMMC2;
34181868:	230b      	movs	r3, #11
3418186a:	61fb      	str	r3, [r7, #28]

    /* D2-CLK-CMD-D0-D1*/
    gpio_init_structure.Pin = GPIO_PIN_0 | GPIO_PIN_2 | GPIO_PIN_3 | GPIO_PIN_4  | GPIO_PIN_5 ;
3418186c:	233d      	movs	r3, #61	@ 0x3d
3418186e:	60fb      	str	r3, [r7, #12]
    HAL_GPIO_Init(GPIOC, &gpio_init_structure);
34181870:	f107 030c 	add.w	r3, r7, #12
34181874:	4619      	mov	r1, r3
34181876:	480b      	ldr	r0, [pc, #44]	@ (341818a4 <HAL_SD_MspInit+0x7c>)
34181878:	f005 fae4 	bl	34186e44 <HAL_GPIO_Init>

    /* D3*/
    gpio_init_structure.Pin = GPIO_PIN_4;
3418187c:	2310      	movs	r3, #16
3418187e:	60fb      	str	r3, [r7, #12]
    HAL_GPIO_Init(GPIOE, &gpio_init_structure);
34181880:	f107 030c 	add.w	r3, r7, #12
34181884:	4619      	mov	r1, r3
34181886:	4808      	ldr	r0, [pc, #32]	@ (341818a8 <HAL_SD_MspInit+0x80>)
34181888:	f005 fadc 	bl	34186e44 <HAL_GPIO_Init>

    /* NVIC configuration for SDMMC1 interrupts */
    HAL_NVIC_SetPriority(SDMMC2_IRQn, 5, 0);
3418188c:	2200      	movs	r2, #0
3418188e:	2105      	movs	r1, #5
34181890:	20af      	movs	r0, #175	@ 0xaf
34181892:	f005 f9e1 	bl	34186c58 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(SDMMC2_IRQn);
34181896:	20af      	movs	r0, #175	@ 0xaf
34181898:	f005 f9fb 	bl	34186c92 <HAL_NVIC_EnableIRQ>
}
3418189c:	bf00      	nop
3418189e:	3720      	adds	r7, #32
341818a0:	46bd      	mov	sp, r7
341818a2:	bd80      	pop	{r7, pc}
341818a4:	56020800 	.word	0x56020800
341818a8:	56021000 	.word	0x56021000

341818ac <LL_APB1_GRP1_EnableClock>:
{
341818ac:	b480      	push	{r7}
341818ae:	b085      	sub	sp, #20
341818b0:	af00      	add	r7, sp, #0
341818b2:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->APB1ENSR1, Periphs);
341818b4:	4a07      	ldr	r2, [pc, #28]	@ (341818d4 <LL_APB1_GRP1_EnableClock+0x28>)
341818b6:	687b      	ldr	r3, [r7, #4]
341818b8:	f8c2 3a64 	str.w	r3, [r2, #2660]	@ 0xa64
  tmpreg = READ_REG(RCC->APB1ENR1);
341818bc:	4b05      	ldr	r3, [pc, #20]	@ (341818d4 <LL_APB1_GRP1_EnableClock+0x28>)
341818be:	f8d3 3264 	ldr.w	r3, [r3, #612]	@ 0x264
341818c2:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
341818c4:	68fb      	ldr	r3, [r7, #12]
}
341818c6:	bf00      	nop
341818c8:	3714      	adds	r7, #20
341818ca:	46bd      	mov	sp, r7
341818cc:	f85d 7b04 	ldr.w	r7, [sp], #4
341818d0:	4770      	bx	lr
341818d2:	bf00      	nop
341818d4:	56028000 	.word	0x56028000

341818d8 <HAL_InitTick>:
  *         reset by HAL_Init() or at any time when clock is configured, by HAL_RCC_ClockConfig().
  * @param  TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
341818d8:	b580      	push	{r7, lr}
341818da:	b096      	sub	sp, #88	@ 0x58
341818dc:	af00      	add	r7, sp, #0
341818de:	6078      	str	r0, [r7, #4]
  RCC_ClkInitTypeDef    clkconfig;
  uint32_t              uwTimclock = 0;
341818e0:	2300      	movs	r3, #0
341818e2:	653b      	str	r3, [r7, #80]	@ 0x50
  uint32_t              uwPrescalerValue = 0;
341818e4:	2300      	movs	r3, #0
341818e6:	64fb      	str	r3, [r7, #76]	@ 0x4c
  HAL_StatusTypeDef     status;

  /* Enable TIM6 clock */
  __HAL_RCC_TIM6_CLK_ENABLE();
341818e8:	2010      	movs	r0, #16
341818ea:	f7ff ffdf 	bl	341818ac <LL_APB1_GRP1_EnableClock>

  /* Get clock configuration */
  HAL_RCC_GetClockConfig(&clkconfig);
341818ee:	f107 030c 	add.w	r3, r7, #12
341818f2:	4618      	mov	r0, r3
341818f4:	f009 f9b0 	bl	3418ac58 <HAL_RCC_GetClockConfig>

  /* Compute TIM6 clock */
  uwTimclock = HAL_RCC_GetPCLK1Freq();
341818f8:	f009 f999 	bl	3418ac2e <HAL_RCC_GetPCLK1Freq>
341818fc:	6538      	str	r0, [r7, #80]	@ 0x50

  /* Compute the prescaler value to have TIM6 counter clock equal to 1MHz */
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
341818fe:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
34181900:	4a20      	ldr	r2, [pc, #128]	@ (34181984 <HAL_InitTick+0xac>)
34181902:	fba2 2303 	umull	r2, r3, r2, r3
34181906:	0c9b      	lsrs	r3, r3, #18
34181908:	3b01      	subs	r3, #1
3418190a:	64fb      	str	r3, [r7, #76]	@ 0x4c

  /* Initialize TIM6 */
  htim6.Instance = TIM6;
3418190c:	4b1e      	ldr	r3, [pc, #120]	@ (34181988 <HAL_InitTick+0xb0>)
3418190e:	4a1f      	ldr	r2, [pc, #124]	@ (3418198c <HAL_InitTick+0xb4>)
34181910:	601a      	str	r2, [r3, #0]
  + Period = [(TIM6CLK/1000) - 1]. to have a (1/1000) s time base.
  + Prescaler = (uwTimclock/1000000 - 1) to have a 1MHz counter clock.
  + ClockDivision = 0
  + Counter direction = Up
  */
  htim6.Init.Period = (1000000U / 1000U) - 1U;
34181912:	4b1d      	ldr	r3, [pc, #116]	@ (34181988 <HAL_InitTick+0xb0>)
34181914:	f240 32e7 	movw	r2, #999	@ 0x3e7
34181918:	60da      	str	r2, [r3, #12]
  htim6.Init.Prescaler = uwPrescalerValue;
3418191a:	4a1b      	ldr	r2, [pc, #108]	@ (34181988 <HAL_InitTick+0xb0>)
3418191c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3418191e:	6053      	str	r3, [r2, #4]
  htim6.Init.ClockDivision = 0;
34181920:	4b19      	ldr	r3, [pc, #100]	@ (34181988 <HAL_InitTick+0xb0>)
34181922:	2200      	movs	r2, #0
34181924:	611a      	str	r2, [r3, #16]
  htim6.Init.CounterMode = TIM_COUNTERMODE_UP;
34181926:	4b18      	ldr	r3, [pc, #96]	@ (34181988 <HAL_InitTick+0xb0>)
34181928:	2200      	movs	r2, #0
3418192a:	609a      	str	r2, [r3, #8]

  status = HAL_TIM_Base_Init(&htim6);
3418192c:	4816      	ldr	r0, [pc, #88]	@ (34181988 <HAL_InitTick+0xb0>)
3418192e:	f00e fd93 	bl	34190458 <HAL_TIM_Base_Init>
34181932:	4603      	mov	r3, r0
34181934:	f887 3057 	strb.w	r3, [r7, #87]	@ 0x57
  if (status == HAL_OK)
34181938:	f897 3057 	ldrb.w	r3, [r7, #87]	@ 0x57
3418193c:	2b00      	cmp	r3, #0
3418193e:	d118      	bne.n	34181972 <HAL_InitTick+0x9a>
  {
    /* Start the TIM time Base generation in interrupt mode */
    status = HAL_TIM_Base_Start_IT(&htim6);
34181940:	4811      	ldr	r0, [pc, #68]	@ (34181988 <HAL_InitTick+0xb0>)
34181942:	f00e fdeb 	bl	3419051c <HAL_TIM_Base_Start_IT>
34181946:	4603      	mov	r3, r0
34181948:	f887 3057 	strb.w	r3, [r7, #87]	@ 0x57
    if (status == HAL_OK)
3418194c:	f897 3057 	ldrb.w	r3, [r7, #87]	@ 0x57
34181950:	2b00      	cmp	r3, #0
34181952:	d10e      	bne.n	34181972 <HAL_InitTick+0x9a>
    {
      if (TickPriority < (1UL << __NVIC_PRIO_BITS))
34181954:	687b      	ldr	r3, [r7, #4]
34181956:	2b0f      	cmp	r3, #15
34181958:	d808      	bhi.n	3418196c <HAL_InitTick+0x94>
      {
        /* Enable the TIM6 global Interrupt */
        HAL_NVIC_SetPriority(TIM6_IRQn, TickPriority, 0U);
3418195a:	2200      	movs	r2, #0
3418195c:	6879      	ldr	r1, [r7, #4]
3418195e:	2078      	movs	r0, #120	@ 0x78
34181960:	f005 f97a 	bl	34186c58 <HAL_NVIC_SetPriority>
        uwTickPrio = TickPriority;
34181964:	4a0a      	ldr	r2, [pc, #40]	@ (34181990 <HAL_InitTick+0xb8>)
34181966:	687b      	ldr	r3, [r7, #4]
34181968:	6013      	str	r3, [r2, #0]
3418196a:	e002      	b.n	34181972 <HAL_InitTick+0x9a>
      }
      else
      {
        status = HAL_ERROR;
3418196c:	2301      	movs	r3, #1
3418196e:	f887 3057 	strb.w	r3, [r7, #87]	@ 0x57
      }
    }
  }

  /* Enable the TIM6 global Interrupt */
  HAL_NVIC_EnableIRQ(TIM6_IRQn);
34181972:	2078      	movs	r0, #120	@ 0x78
34181974:	f005 f98d 	bl	34186c92 <HAL_NVIC_EnableIRQ>

 /* Return function status */
  return status;
34181978:	f897 3057 	ldrb.w	r3, [r7, #87]	@ 0x57
}
3418197c:	4618      	mov	r0, r3
3418197e:	3758      	adds	r7, #88	@ 0x58
34181980:	46bd      	mov	sp, r7
34181982:	bd80      	pop	{r7, pc}
34181984:	431bde83 	.word	0x431bde83
34181988:	341c1adc 	.word	0x341c1adc
3418198c:	50001000 	.word	0x50001000
34181990:	341c0094 	.word	0x341c0094

34181994 <LL_EXTI_IsActiveFallingFlag_0_31>:
  *         @arg @ref LL_EXTI_LINE_21
  * @note   Please check each device line mapping for EXTI Line availability
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_EXTI_IsActiveFallingFlag_0_31(uint32_t ExtiLine)
{
34181994:	b480      	push	{r7}
34181996:	b083      	sub	sp, #12
34181998:	af00      	add	r7, sp, #0
3418199a:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(EXTI->FPR1, ExtiLine) == (ExtiLine)) ? 1UL : 0UL);
3418199c:	4b07      	ldr	r3, [pc, #28]	@ (341819bc <LL_EXTI_IsActiveFallingFlag_0_31+0x28>)
3418199e:	691a      	ldr	r2, [r3, #16]
341819a0:	687b      	ldr	r3, [r7, #4]
341819a2:	4013      	ands	r3, r2
341819a4:	687a      	ldr	r2, [r7, #4]
341819a6:	429a      	cmp	r2, r3
341819a8:	d101      	bne.n	341819ae <LL_EXTI_IsActiveFallingFlag_0_31+0x1a>
341819aa:	2301      	movs	r3, #1
341819ac:	e000      	b.n	341819b0 <LL_EXTI_IsActiveFallingFlag_0_31+0x1c>
341819ae:	2300      	movs	r3, #0
}
341819b0:	4618      	mov	r0, r3
341819b2:	370c      	adds	r7, #12
341819b4:	46bd      	mov	sp, r7
341819b6:	f85d 7b04 	ldr.w	r7, [sp], #4
341819ba:	4770      	bx	lr
341819bc:	56025000 	.word	0x56025000

341819c0 <LL_EXTI_ClearFallingFlag_0_31>:
  *         @arg @ref LL_EXTI_LINE_21
  * @note   Please check each device line mapping for EXTI Line availability
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_ClearFallingFlag_0_31(uint32_t ExtiLine)
{
341819c0:	b480      	push	{r7}
341819c2:	b083      	sub	sp, #12
341819c4:	af00      	add	r7, sp, #0
341819c6:	6078      	str	r0, [r7, #4]
  WRITE_REG(EXTI->FPR1, ExtiLine);
341819c8:	4a04      	ldr	r2, [pc, #16]	@ (341819dc <LL_EXTI_ClearFallingFlag_0_31+0x1c>)
341819ca:	687b      	ldr	r3, [r7, #4]
341819cc:	6113      	str	r3, [r2, #16]
}
341819ce:	bf00      	nop
341819d0:	370c      	adds	r7, #12
341819d2:	46bd      	mov	sp, r7
341819d4:	f85d 7b04 	ldr.w	r7, [sp], #4
341819d8:	4770      	bx	lr
341819da:	bf00      	nop
341819dc:	56025000 	.word	0x56025000

341819e0 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
341819e0:	b480      	push	{r7}
341819e2:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
341819e4:	bf00      	nop
341819e6:	e7fd      	b.n	341819e4 <NMI_Handler+0x4>

341819e8 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
341819e8:	b480      	push	{r7}
341819ea:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
341819ec:	bf00      	nop
341819ee:	e7fd      	b.n	341819ec <HardFault_Handler+0x4>

341819f0 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
341819f0:	b480      	push	{r7}
341819f2:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
341819f4:	bf00      	nop
341819f6:	e7fd      	b.n	341819f4 <MemManage_Handler+0x4>

341819f8 <BusFault_Handler>:

/**
  * @brief This function handles Prefetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
341819f8:	b480      	push	{r7}
341819fa:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
341819fc:	bf00      	nop
341819fe:	e7fd      	b.n	341819fc <BusFault_Handler+0x4>

34181a00 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
34181a00:	b480      	push	{r7}
34181a02:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
34181a04:	bf00      	nop
34181a06:	e7fd      	b.n	34181a04 <UsageFault_Handler+0x4>

34181a08 <SecureFault_Handler>:

/**
  * @brief This function handles Secure fault.
  */
void SecureFault_Handler(void)
{
34181a08:	b480      	push	{r7}
34181a0a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SecureFault_IRQn 0 */

  /* USER CODE END SecureFault_IRQn 0 */
  while (1)
34181a0c:	bf00      	nop
34181a0e:	e7fd      	b.n	34181a0c <SecureFault_Handler+0x4>

34181a10 <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
34181a10:	b480      	push	{r7}
34181a12:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
34181a14:	bf00      	nop
34181a16:	46bd      	mov	sp, r7
34181a18:	f85d 7b04 	ldr.w	r7, [sp], #4
34181a1c:	4770      	bx	lr

34181a1e <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
34181a1e:	b480      	push	{r7}
34181a20:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
34181a22:	bf00      	nop
34181a24:	46bd      	mov	sp, r7
34181a26:	f85d 7b04 	ldr.w	r7, [sp], #4
34181a2a:	4770      	bx	lr

34181a2c <USB1_OTG_HS_IRQHandler>:
* @brief  This function handles USB-On-The-Go FS/HS global interrupt request.
* @param  None
* @retval None
*/
void USB1_OTG_HS_IRQHandler(void)
{
34181a2c:	b580      	push	{r7, lr}
34181a2e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN OTG_HS_IRQHandler 0 */

  /* USER CODE END OTG_HS_IRQHandler 0 */
  HAL_PCD_IRQHandler(&hpcd_USB1_OTG_HS);
34181a30:	4802      	ldr	r0, [pc, #8]	@ (34181a3c <USB1_OTG_HS_IRQHandler+0x10>)
34181a32:	f006 fd3a 	bl	341884aa <HAL_PCD_IRQHandler>
  /* USER CODE BEGIN OTG_HS_IRQHandler 1 */

  /* USER CODE END OTG_HS_IRQHandler 1 */
}
34181a36:	bf00      	nop
34181a38:	bd80      	pop	{r7, pc}
34181a3a:	bf00      	nop
34181a3c:	341fc800 	.word	0x341fc800

34181a40 <EXTI2_IRQHandler>:

/**
  * @brief This function handles EXTI line2 interrupt.
  */
void EXTI2_IRQHandler(void)
{
34181a40:	b580      	push	{r7, lr}
34181a42:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN EXTI14_IRQn 0 */

  /* USER CODE END EXTI14_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(SD_DETECT_Pin);
34181a44:	f44f 5080 	mov.w	r0, #4096	@ 0x1000
34181a48:	f005 fd1e 	bl	34187488 <HAL_GPIO_EXTI_IRQHandler>
  /* USER CODE BEGIN EXTI14_IRQn 1 */

  /* USER CODE END EXTI14_IRQn 1 */
}
34181a4c:	bf00      	nop
34181a4e:	bd80      	pop	{r7, pc}

34181a50 <SDMMC2_IRQHandler>:

/**
  * @brief This function handles SDMMC2 global interrupt.
  */
void SDMMC2_IRQHandler(void)
{
34181a50:	b580      	push	{r7, lr}
34181a52:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SDMMC2_IRQn 0 */

  /* USER CODE END SDMMC2_IRQn 0 */
  HAL_SD_IRQHandler(&hsd1);
34181a54:	4802      	ldr	r0, [pc, #8]	@ (34181a60 <SDMMC2_IRQHandler+0x10>)
34181a56:	f00d fb23 	bl	3418f0a0 <HAL_SD_IRQHandler>
  /* USER CODE BEGIN SDMMC2_IRQn 1 */

  /* USER CODE END SDMMC2_IRQn 1 */
}
34181a5a:	bf00      	nop
34181a5c:	bd80      	pop	{r7, pc}
34181a5e:	bf00      	nop
34181a60:	341c1a3c 	.word	0x341c1a3c

34181a64 <TIM6_IRQHandler>:

void TIM6_IRQHandler(void)
{
34181a64:	b580      	push	{r7, lr}
34181a66:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN TIM6_DAC_IRQn 0 */

  /* USER CODE END TIM6_DAC_IRQn 0 */
  HAL_TIM_IRQHandler(&htim6);
34181a68:	4802      	ldr	r0, [pc, #8]	@ (34181a74 <TIM6_IRQHandler+0x10>)
34181a6a:	f00e fe0f 	bl	3419068c <HAL_TIM_IRQHandler>
  /* USER CODE BEGIN TIM6_DAC_IRQn 1 */

  /* USER CODE END TIM6_DAC_IRQn 1 */
}
34181a6e:	bf00      	nop
34181a70:	bd80      	pop	{r7, pc}
34181a72:	bf00      	nop
34181a74:	341c1adc 	.word	0x341c1adc

34181a78 <UCPD1_IRQHandler>:

/**
  * @brief This function handles UCPD1 global interrupt.
  */
void UCPD1_IRQHandler(void)
{
34181a78:	b580      	push	{r7, lr}
34181a7a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UCPD1_IRQn 0 */

  /* USER CODE END UCPD1_IRQn 0 */
  USBPD_PORT0_IRQHandler();
34181a7c:	f012 fb64 	bl	34194148 <USBPD_PORT0_IRQHandler>
  /* USER CODE BEGIN UCPD1_IRQn 1 */

  /* USER CODE END UCPD1_IRQn 1 */
}
34181a80:	bf00      	nop
34181a82:	bd80      	pop	{r7, pc}

34181a84 <EXTI10_IRQHandler>:
  *         (Associated to FLGn line in case of TCPP0203 management)
  * @retval None
  */

void TCPP0203_PORT0_FLG_EXTI_IRQHANDLER(void)
{
34181a84:	b580      	push	{r7, lr}
34181a86:	af00      	add	r7, sp, #0
  /* Manage Flags */
  if (TCPP0203_PORT0_FLG_EXTI_IS_ACTIVE_FLAG() != RESET)
34181a88:	f44f 6080 	mov.w	r0, #1024	@ 0x400
34181a8c:	f7ff ff82 	bl	34181994 <LL_EXTI_IsActiveFallingFlag_0_31>
34181a90:	4603      	mov	r3, r0
34181a92:	2b00      	cmp	r3, #0
34181a94:	d006      	beq.n	34181aa4 <EXTI10_IRQHandler+0x20>

  {
    /* Call BSP USBPD PWR callback */
    BSP_USBPD_PWR_EventCallback(USBPD_PWR_TYPE_C_PORT_1);
34181a96:	2000      	movs	r0, #0
34181a98:	f002 ffac 	bl	341849f4 <BSP_USBPD_PWR_EventCallback>

    /* Clear Flag */
    TCPP0203_PORT0_FLG_EXTI_CLEAR_FLAG();
34181a9c:	f44f 6080 	mov.w	r0, #1024	@ 0x400
34181aa0:	f7ff ff8e 	bl	341819c0 <LL_EXTI_ClearFallingFlag_0_31>

  }
}
34181aa4:	bf00      	nop
34181aa6:	bd80      	pop	{r7, pc}

34181aa8 <_sbrk>:
 *
 * @param incr Memory size
 * @return Pointer to allocated memory
 */
void *_sbrk(ptrdiff_t incr)
{
34181aa8:	b580      	push	{r7, lr}
34181aaa:	b086      	sub	sp, #24
34181aac:	af00      	add	r7, sp, #0
34181aae:	6078      	str	r0, [r7, #4]
  extern uint8_t _end; /* Symbol defined in the linker script */
  extern uint8_t _estack; /* Symbol defined in the linker script */
  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
34181ab0:	4a14      	ldr	r2, [pc, #80]	@ (34181b04 <_sbrk+0x5c>)
34181ab2:	4b15      	ldr	r3, [pc, #84]	@ (34181b08 <_sbrk+0x60>)
34181ab4:	1ad3      	subs	r3, r2, r3
34181ab6:	617b      	str	r3, [r7, #20]
  const uint8_t *max_heap = (uint8_t *)stack_limit;
34181ab8:	697b      	ldr	r3, [r7, #20]
34181aba:	613b      	str	r3, [r7, #16]
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
34181abc:	4b13      	ldr	r3, [pc, #76]	@ (34181b0c <_sbrk+0x64>)
34181abe:	681b      	ldr	r3, [r3, #0]
34181ac0:	2b00      	cmp	r3, #0
34181ac2:	d102      	bne.n	34181aca <_sbrk+0x22>
  {
    __sbrk_heap_end = &_end;
34181ac4:	4b11      	ldr	r3, [pc, #68]	@ (34181b0c <_sbrk+0x64>)
34181ac6:	4a12      	ldr	r2, [pc, #72]	@ (34181b10 <_sbrk+0x68>)
34181ac8:	601a      	str	r2, [r3, #0]
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
34181aca:	4b10      	ldr	r3, [pc, #64]	@ (34181b0c <_sbrk+0x64>)
34181acc:	681a      	ldr	r2, [r3, #0]
34181ace:	687b      	ldr	r3, [r7, #4]
34181ad0:	4413      	add	r3, r2
34181ad2:	693a      	ldr	r2, [r7, #16]
34181ad4:	429a      	cmp	r2, r3
34181ad6:	d207      	bcs.n	34181ae8 <_sbrk+0x40>
  {
    errno = ENOMEM;
34181ad8:	f01c fb0a 	bl	3419e0f0 <__errno>
34181adc:	4603      	mov	r3, r0
34181ade:	220c      	movs	r2, #12
34181ae0:	601a      	str	r2, [r3, #0]
    return (void *)-1;
34181ae2:	f04f 33ff 	mov.w	r3, #4294967295
34181ae6:	e009      	b.n	34181afc <_sbrk+0x54>
  }

  prev_heap_end = __sbrk_heap_end;
34181ae8:	4b08      	ldr	r3, [pc, #32]	@ (34181b0c <_sbrk+0x64>)
34181aea:	681b      	ldr	r3, [r3, #0]
34181aec:	60fb      	str	r3, [r7, #12]
  __sbrk_heap_end += incr;
34181aee:	4b07      	ldr	r3, [pc, #28]	@ (34181b0c <_sbrk+0x64>)
34181af0:	681a      	ldr	r2, [r3, #0]
34181af2:	687b      	ldr	r3, [r7, #4]
34181af4:	4413      	add	r3, r2
34181af6:	4a05      	ldr	r2, [pc, #20]	@ (34181b0c <_sbrk+0x64>)
34181af8:	6013      	str	r3, [r2, #0]

  return (void *)prev_heap_end;
34181afa:	68fb      	ldr	r3, [r7, #12]
}
34181afc:	4618      	mov	r0, r3
34181afe:	3718      	adds	r7, #24
34181b00:	46bd      	mov	sp, r7
34181b02:	bd80      	pop	{r7, pc}
34181b04:	34200000 	.word	0x34200000
34181b08:	00000800 	.word	0x00000800
34181b0c:	341c1b28 	.word	0x341c1b28
34181b10:	341c3548 	.word	0x341c3548

34181b14 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_sstack
34181b14:	480f      	ldr	r0, [pc, #60]	@ (34181b54 <LoopForever+0x4>)
  msr   MSPLIM, r0
34181b16:	f380 880a 	msr	MSPLIM, r0
  ldr   r0, =_estack
34181b1a:	480f      	ldr	r0, [pc, #60]	@ (34181b58 <LoopForever+0x8>)
  mov   sp, r0          /* set stack pointer */
34181b1c:	4685      	mov	sp, r0
/* Call the clock system initialization function.*/
  bl  SystemInit
34181b1e:	f003 fa7f 	bl	34185020 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
34181b22:	480e      	ldr	r0, [pc, #56]	@ (34181b5c <LoopForever+0xc>)
  ldr r1, =_edata
34181b24:	490e      	ldr	r1, [pc, #56]	@ (34181b60 <LoopForever+0x10>)
  ldr r2, =_sidata
34181b26:	4a0f      	ldr	r2, [pc, #60]	@ (34181b64 <LoopForever+0x14>)
  movs r3, #0
34181b28:	2300      	movs	r3, #0
  b LoopCopyDataInit
34181b2a:	e002      	b.n	34181b32 <LoopCopyDataInit>

34181b2c <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
34181b2c:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
34181b2e:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
34181b30:	3304      	adds	r3, #4

34181b32 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
34181b32:	18c4      	adds	r4, r0, r3
  cmp r4, r1
34181b34:	428c      	cmp	r4, r1
  bcc CopyDataInit
34181b36:	d3f9      	bcc.n	34181b2c <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
34181b38:	4a0b      	ldr	r2, [pc, #44]	@ (34181b68 <LoopForever+0x18>)
  ldr r4, =_ebss
34181b3a:	4c0c      	ldr	r4, [pc, #48]	@ (34181b6c <LoopForever+0x1c>)
  movs r3, #0
34181b3c:	2300      	movs	r3, #0
  b LoopFillZerobss
34181b3e:	e001      	b.n	34181b44 <LoopFillZerobss>

34181b40 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
34181b40:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
34181b42:	3204      	adds	r2, #4

34181b44 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
34181b44:	42a2      	cmp	r2, r4
  bcc FillZerobss
34181b46:	d3fb      	bcc.n	34181b40 <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
34181b48:	f01c fad8 	bl	3419e0fc <__libc_init_array>
/* Call the application's entry point.*/
  bl main
34181b4c:	f7ff f9ac 	bl	34180ea8 <main>

34181b50 <LoopForever>:

LoopForever:
  b LoopForever
34181b50:	e7fe      	b.n	34181b50 <LoopForever>
34181b52:	0000      	.short	0x0000
  ldr   r0, =_sstack
34181b54:	341ff800 	.word	0x341ff800
  ldr   r0, =_estack
34181b58:	34200000 	.word	0x34200000
  ldr r0, =_sdata
34181b5c:	341c0000 	.word	0x341c0000
  ldr r1, =_edata
34181b60:	341c0178 	.word	0x341c0178
  ldr r2, =_sidata
34181b64:	3419e4a0 	.word	0x3419e4a0
  ldr r2, =_sbss
34181b68:	341c0178 	.word	0x341c0178
  ldr r4, =_ebss
34181b6c:	341c3544 	.word	0x341c3544

34181b70 <ADC1_2_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
34181b70:	e7fe      	b.n	34181b70 <ADC1_2_IRQHandler>

34181b72 <USBPD_PreInitOs>:
/* Private functions ---------------------------------------------------------*/

/* USER CODE BEGIN 2 */
/* USER CODE END 2 */
unsigned int USBPD_PreInitOs(void)
{
34181b72:	b580      	push	{r7, lr}
34181b74:	af00      	add	r7, sp, #0
 /* Initialize the Device Policy Manager */
  if (USBPD_OK != USBPD_DPM_InitCore())
34181b76:	f000 f81b 	bl	34181bb0 <USBPD_DPM_InitCore>
34181b7a:	4603      	mov	r3, r0
34181b7c:	2b00      	cmp	r3, #0
34181b7e:	d001      	beq.n	34181b84 <USBPD_PreInitOs+0x12>
  {
    return USBPD_ERROR;
34181b80:	2302      	movs	r3, #2
34181b82:	e000      	b.n	34181b86 <USBPD_PreInitOs+0x14>
  }

  return USBPD_OK;
34181b84:	2300      	movs	r3, #0
}
34181b86:	4618      	mov	r0, r3
34181b88:	bd80      	pop	{r7, pc}

34181b8a <MX_USBPD_Init>:

/* USBPD init function */
unsigned int MX_USBPD_Init(void *memory_ptr)
{
34181b8a:	b580      	push	{r7, lr}
34181b8c:	b084      	sub	sp, #16
34181b8e:	af00      	add	r7, sp, #0
34181b90:	6078      	str	r0, [r7, #4]
  unsigned int result = USBPD_OK;
34181b92:	2300      	movs	r3, #0
34181b94:	60fb      	str	r3, [r7, #12]

  /* USER CODE BEGIN 3 */
  /* USER CODE END 3 */

  if (USBPD_OK != USBPD_DPM_InitOS((void*)memory_ptr))
34181b96:	6878      	ldr	r0, [r7, #4]
34181b98:	f000 f842 	bl	34181c20 <USBPD_DPM_InitOS>
34181b9c:	4603      	mov	r3, r0
34181b9e:	2b00      	cmp	r3, #0
34181ba0:	d001      	beq.n	34181ba6 <MX_USBPD_Init+0x1c>
  {
    return USBPD_ERROR;
34181ba2:	2302      	movs	r3, #2
34181ba4:	e000      	b.n	34181ba8 <MX_USBPD_Init+0x1e>
  }
  return result;
34181ba6:	68fb      	ldr	r3, [r7, #12]
}
34181ba8:	4618      	mov	r0, r3
34181baa:	3710      	adds	r7, #16
34181bac:	46bd      	mov	sp, r7
34181bae:	bd80      	pop	{r7, pc}

34181bb0 <USBPD_DPM_InitCore>:
/**
  * @brief  Initialize the core stack (port power role, PWR_IF, CAD and PE Init procedures)
  * @retval USBPD status
  */
USBPD_StatusTypeDef USBPD_DPM_InitCore(void)
{
34181bb0:	b580      	push	{r7, lr}
34181bb2:	b082      	sub	sp, #8
34181bb4:	af00      	add	r7, sp, #0
  /* variable to get dynamique memory allocated by usbpd stack */
  uint32_t stack_dynamemsize;
  USBPD_StatusTypeDef _retr = USBPD_OK;
34181bb6:	2300      	movs	r3, #0
34181bb8:	71fb      	strb	r3, [r7, #7]

  /* Check the lib selected */
  if (USBPD_TRUE != USBPD_PE_CheckLIB(LIB_ID))
34181bba:	4815      	ldr	r0, [pc, #84]	@ (34181c10 <USBPD_DPM_InitCore+0x60>)
34181bbc:	f7fe ffb5 	bl	34180b2a <USBPD_PE_CheckLIB>
34181bc0:	4603      	mov	r3, r0
34181bc2:	2b01      	cmp	r3, #1
34181bc4:	d002      	beq.n	34181bcc <USBPD_DPM_InitCore+0x1c>
  {
    _retr = USBPD_ERROR;
34181bc6:	2302      	movs	r3, #2
34181bc8:	71fb      	strb	r3, [r7, #7]
    goto error;
34181bca:	e01c      	b.n	34181c06 <USBPD_DPM_InitCore+0x56>
  }

  /* to get how much memory are dynamically allocated by the stack
     the memory return is corresponding to 2 ports so if the application
     managed only one port divide the value return by 2                   */
  stack_dynamemsize = USBPD_PE_GetMemoryConsumption();
34181bcc:	f7fe ffb8 	bl	34180b40 <USBPD_PE_GetMemoryConsumption>
34181bd0:	6038      	str	r0, [r7, #0]

  /* done to avoid warning */
  (void)stack_dynamemsize;

  DPM_Params[USBPD_PORT_0].PE_PowerRole     = DPM_Settings[USBPD_PORT_0].PE_DefaultRole;
34181bd2:	4b10      	ldr	r3, [pc, #64]	@ (34181c14 <USBPD_DPM_InitCore+0x64>)
34181bd4:	781b      	ldrb	r3, [r3, #0]
34181bd6:	f3c3 0300 	ubfx	r3, r3, #0, #1
34181bda:	b2d9      	uxtb	r1, r3
34181bdc:	4a0e      	ldr	r2, [pc, #56]	@ (34181c18 <USBPD_DPM_InitCore+0x68>)
34181bde:	7813      	ldrb	r3, [r2, #0]
34181be0:	f361 0382 	bfi	r3, r1, #2, #1
34181be4:	7013      	strb	r3, [r2, #0]

  {
    static const USBPD_CAD_Callbacks CAD_cbs = { USBPD_DPM_CADCallback, USBPD_DPM_CADTaskWakeUp };
    /* Init CAD */
    CHECK_CAD_FUNCTION_CALL(USBPD_CAD_Init(USBPD_PORT_0, &CAD_cbs, (USBPD_SettingsTypeDef *)&DPM_Settings[USBPD_PORT_0],
34181be6:	4b0c      	ldr	r3, [pc, #48]	@ (34181c18 <USBPD_DPM_InitCore+0x68>)
34181be8:	4a0a      	ldr	r2, [pc, #40]	@ (34181c14 <USBPD_DPM_InitCore+0x64>)
34181bea:	490c      	ldr	r1, [pc, #48]	@ (34181c1c <USBPD_DPM_InitCore+0x6c>)
34181bec:	2000      	movs	r0, #0
34181bee:	f7fe feeb 	bl	341809c8 <USBPD_CAD_Init>
34181bf2:	4603      	mov	r3, r0
34181bf4:	2b00      	cmp	r3, #0
34181bf6:	d002      	beq.n	34181bfe <USBPD_DPM_InitCore+0x4e>
34181bf8:	2302      	movs	r3, #2
34181bfa:	71fb      	strb	r3, [r7, #7]
34181bfc:	e003      	b.n	34181c06 <USBPD_DPM_InitCore+0x56>
                                           &DPM_Params[USBPD_PORT_0]));

    /* Enable CAD on Port 0 */
    USBPD_CAD_PortEnable(USBPD_PORT_0, USBPD_CAD_ENABLE);
34181bfe:	2101      	movs	r1, #1
34181c00:	2000      	movs	r0, #0
34181c02:	f7fe ff09 	bl	34180a18 <USBPD_CAD_PortEnable>
  }

error :
  return _retr;
34181c06:	79fb      	ldrb	r3, [r7, #7]
}
34181c08:	4618      	mov	r0, r3
34181c0a:	3708      	adds	r7, #8
34181c0c:	46bd      	mov	sp, r7
34181c0e:	bd80      	pop	{r7, pc}
34181c10:	00410100 	.word	0x00410100
34181c14:	341c1b2c 	.word	0x341c1b2c
34181c18:	341c1c18 	.word	0x341c1c18
34181c1c:	3419e34c 	.word	0x3419e34c

34181c20 <USBPD_DPM_InitOS>:
/**
  * @brief  Initialize the OS parts (task, queue,... )
  * @retval USBPD status
  */
uint32_t USBPD_DPM_InitOS(void *MemoryPtr)
{
34181c20:	b580      	push	{r7, lr}
34181c22:	b08e      	sub	sp, #56	@ 0x38
34181c24:	af08      	add	r7, sp, #32
34181c26:	6078      	str	r0, [r7, #4]
  OS_INIT();
34181c28:	687b      	ldr	r3, [r7, #4]
34181c2a:	613b      	str	r3, [r7, #16]
34181c2c:	2300      	movs	r3, #0
34181c2e:	617b      	str	r3, [r7, #20]
  {
    OS_CREATE_QUEUE(CADQueueId, "QCAD", USBPD_PORT_COUNT, OS_ELEMENT_SIZE);
34181c30:	f107 010c 	add.w	r1, r7, #12
34181c34:	2300      	movs	r3, #0
34181c36:	2204      	movs	r2, #4
34181c38:	6938      	ldr	r0, [r7, #16]
34181c3a:	f016 fc9d 	bl	34198578 <_txe_byte_allocate>
34181c3e:	6178      	str	r0, [r7, #20]
34181c40:	697b      	ldr	r3, [r7, #20]
34181c42:	2b00      	cmp	r3, #0
34181c44:	d132      	bne.n	34181cac <USBPD_DPM_InitOS+0x8c>
34181c46:	68fb      	ldr	r3, [r7, #12]
34181c48:	2238      	movs	r2, #56	@ 0x38
34181c4a:	9201      	str	r2, [sp, #4]
34181c4c:	2204      	movs	r2, #4
34181c4e:	9200      	str	r2, [sp, #0]
34181c50:	2201      	movs	r2, #1
34181c52:	4919      	ldr	r1, [pc, #100]	@ (34181cb8 <USBPD_DPM_InitOS+0x98>)
34181c54:	4819      	ldr	r0, [pc, #100]	@ (34181cbc <USBPD_DPM_InitOS+0x9c>)
34181c56:	f016 ffeb 	bl	34198c30 <_txe_queue_create>
34181c5a:	6178      	str	r0, [r7, #20]
34181c5c:	697b      	ldr	r3, [r7, #20]
34181c5e:	2b00      	cmp	r3, #0
34181c60:	d124      	bne.n	34181cac <USBPD_DPM_InitOS+0x8c>
    OS_DEFINE_TASK(CAD, USBPD_CAD_Task, OS_CAD_PRIORITY, OS_CAD_STACK_SIZE, NULL);
    OS_CREATE_TASK(CADThread, CAD, USBPD_CAD_Task,  OS_CAD_PRIORITY, OS_CAD_STACK_SIZE, (int)NULL);
34181c62:	f107 010c 	add.w	r1, r7, #12
34181c66:	2300      	movs	r3, #0
34181c68:	f44f 6280 	mov.w	r2, #1024	@ 0x400
34181c6c:	6938      	ldr	r0, [r7, #16]
34181c6e:	f016 fc83 	bl	34198578 <_txe_byte_allocate>
34181c72:	6178      	str	r0, [r7, #20]
34181c74:	697b      	ldr	r3, [r7, #20]
34181c76:	2b00      	cmp	r3, #0
34181c78:	d118      	bne.n	34181cac <USBPD_DPM_InitOS+0x8c>
34181c7a:	68fb      	ldr	r3, [r7, #12]
34181c7c:	22b0      	movs	r2, #176	@ 0xb0
34181c7e:	9206      	str	r2, [sp, #24]
34181c80:	2201      	movs	r2, #1
34181c82:	9205      	str	r2, [sp, #20]
34181c84:	2200      	movs	r2, #0
34181c86:	9204      	str	r2, [sp, #16]
34181c88:	2201      	movs	r2, #1
34181c8a:	9203      	str	r2, [sp, #12]
34181c8c:	2201      	movs	r2, #1
34181c8e:	9202      	str	r2, [sp, #8]
34181c90:	f44f 6280 	mov.w	r2, #1024	@ 0x400
34181c94:	9201      	str	r2, [sp, #4]
34181c96:	9300      	str	r3, [sp, #0]
34181c98:	2300      	movs	r3, #0
34181c9a:	4a09      	ldr	r2, [pc, #36]	@ (34181cc0 <USBPD_DPM_InitOS+0xa0>)
34181c9c:	4909      	ldr	r1, [pc, #36]	@ (34181cc4 <USBPD_DPM_InitOS+0xa4>)
34181c9e:	480a      	ldr	r0, [pc, #40]	@ (34181cc8 <USBPD_DPM_InitOS+0xa8>)
34181ca0:	f017 fa3e 	bl	34199120 <_txe_thread_create>
34181ca4:	6178      	str	r0, [r7, #20]
34181ca6:	697b      	ldr	r3, [r7, #20]
34181ca8:	2b00      	cmp	r3, #0
  }

error:
34181caa:	bf00      	nop
  return _retr;
34181cac:	697b      	ldr	r3, [r7, #20]
}
34181cae:	4618      	mov	r0, r3
34181cb0:	3718      	adds	r7, #24
34181cb2:	46bd      	mov	sp, r7
34181cb4:	bd80      	pop	{r7, pc}
34181cb6:	bf00      	nop
34181cb8:	3419e1a8 	.word	0x3419e1a8
34181cbc:	341c1b30 	.word	0x341c1b30
34181cc0:	34181cf1 	.word	0x34181cf1
34181cc4:	3419e1b0 	.word	0x3419e1b0
34181cc8:	341c1b68 	.word	0x341c1b68

34181ccc <USBPD_DPM_CADTaskWakeUp>:
/**
  * @brief  WakeUp CAD task
  * @retval None
  */
static void USBPD_DPM_CADTaskWakeUp(void)
{
34181ccc:	b580      	push	{r7, lr}
34181cce:	b082      	sub	sp, #8
34181cd0:	af00      	add	r7, sp, #0
  OS_PUT_MESSAGE_QUEUE(CADQueueId, 0xFFFF, 0);
34181cd2:	f64f 73ff 	movw	r3, #65535	@ 0xffff
34181cd6:	607b      	str	r3, [r7, #4]
34181cd8:	1d3b      	adds	r3, r7, #4
34181cda:	2200      	movs	r2, #0
34181cdc:	4619      	mov	r1, r3
34181cde:	4803      	ldr	r0, [pc, #12]	@ (34181cec <USBPD_DPM_CADTaskWakeUp+0x20>)
34181ce0:	f017 f8a0 	bl	34198e24 <_txe_queue_send>
}
34181ce4:	bf00      	nop
34181ce6:	3708      	adds	r7, #8
34181ce8:	46bd      	mov	sp, r7
34181cea:	bd80      	pop	{r7, pc}
34181cec:	341c1b30 	.word	0x341c1b30

34181cf0 <USBPD_CAD_Task>:
  * @brief  Main task for CAD layer
  * @param  argument Not used
  * @retval None
  */
DEF_TASK_FUNCTION(USBPD_CAD_Task)
{
34181cf0:	b580      	push	{r7, lr}
34181cf2:	b084      	sub	sp, #16
34181cf4:	af00      	add	r7, sp, #0
34181cf6:	6078      	str	r0, [r7, #4]
#ifdef _LOW_POWER
  UTIL_LPM_SetOffMode(LPM_CAD, UTIL_LPM_DISABLE);
#endif /* _LOW_POWER */
  for (;;)
  {
    _timing = USBPD_CAD_Process();
34181cf8:	f7fe fe95 	bl	34180a26 <USBPD_CAD_Process>
34181cfc:	60f8      	str	r0, [r7, #12]
    OS_GETMESSAGE_QUEUE(CADQueueId, _timing);
34181cfe:	f107 0308 	add.w	r3, r7, #8
34181d02:	68fa      	ldr	r2, [r7, #12]
34181d04:	4619      	mov	r1, r3
34181d06:	4802      	ldr	r0, [pc, #8]	@ (34181d10 <USBPD_CAD_Task+0x20>)
34181d08:	f017 f842 	bl	34198d90 <_txe_queue_receive>
    _timing = USBPD_CAD_Process();
34181d0c:	bf00      	nop
34181d0e:	e7f3      	b.n	34181cf8 <USBPD_CAD_Task+0x8>
34181d10:	341c1b30 	.word	0x341c1b30

34181d14 <USBPD_DPM_CADCallback>:
  * @param  State     CAD state
  * @param  Cc        The Communication Channel for the USBPD communication
  * @retval None
  */
void USBPD_DPM_CADCallback(uint8_t PortNum, USBPD_CAD_EVENT State, CCxPin_TypeDef Cc)
{
34181d14:	b580      	push	{r7, lr}
34181d16:	b082      	sub	sp, #8
34181d18:	af00      	add	r7, sp, #0
34181d1a:	4603      	mov	r3, r0
34181d1c:	603a      	str	r2, [r7, #0]
34181d1e:	71fb      	strb	r3, [r7, #7]
34181d20:	460b      	mov	r3, r1
34181d22:	71bb      	strb	r3, [r7, #6]
#ifdef _TRACE
  USBPD_TRACE_Add(USBPD_TRACE_CADEVENT, PortNum, (uint8_t)State, NULL, 0);
#endif /* _TRACE */

  switch (State)
34181d24:	79bb      	ldrb	r3, [r7, #6]
34181d26:	3b01      	subs	r3, #1
34181d28:	2b03      	cmp	r3, #3
34181d2a:	d823      	bhi.n	34181d74 <USBPD_DPM_CADCallback+0x60>
34181d2c:	a201      	add	r2, pc, #4	@ (adr r2, 34181d34 <USBPD_DPM_CADCallback+0x20>)
34181d2e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
34181d32:	bf00      	nop
34181d34:	34181d5d 	.word	0x34181d5d
34181d38:	34181d45 	.word	0x34181d45
34181d3c:	34181d5d 	.word	0x34181d5d
34181d40:	34181d45 	.word	0x34181d45
    case USPPD_CAD_EVENT_VPD :
#endif /* USBPDCORE_VPD */
    case USBPD_CAD_EVENT_ATTEMC :
    case USBPD_CAD_EVENT_ATTACHED :
    {
      USBPD_DPM_UserCableDetection(PortNum, State);
34181d44:	79ba      	ldrb	r2, [r7, #6]
34181d46:	79fb      	ldrb	r3, [r7, #7]
34181d48:	4611      	mov	r1, r2
34181d4a:	4618      	mov	r0, r3
34181d4c:	f000 f8f0 	bl	34181f30 <USBPD_DPM_UserCableDetection>
      USBPD_DPM_Notification(PortNum, USBPD_NOTIFY_USBSTACK_START);
34181d50:	79fb      	ldrb	r3, [r7, #7]
34181d52:	2168      	movs	r1, #104	@ 0x68
34181d54:	4618      	mov	r0, r3
34181d56:	f000 f8f9 	bl	34181f4c <USBPD_DPM_Notification>
      break;
34181d5a:	e00c      	b.n	34181d76 <USBPD_DPM_CADCallback+0x62>
    }
    case USBPD_CAD_EVENT_DETACHED :
    case USBPD_CAD_EVENT_EMC :
    {
      USBPD_DPM_UserCableDetection(PortNum, State);
34181d5c:	79ba      	ldrb	r2, [r7, #6]
34181d5e:	79fb      	ldrb	r3, [r7, #7]
34181d60:	4611      	mov	r1, r2
34181d62:	4618      	mov	r0, r3
34181d64:	f000 f8e4 	bl	34181f30 <USBPD_DPM_UserCableDetection>
      USBPD_DPM_Notification(PortNum, USBPD_NOTIFY_USBSTACK_STOP);
34181d68:	79fb      	ldrb	r3, [r7, #7]
34181d6a:	2169      	movs	r1, #105	@ 0x69
34181d6c:	4618      	mov	r0, r3
34181d6e:	f000 f8ed 	bl	34181f4c <USBPD_DPM_Notification>
      break;
34181d72:	e000      	b.n	34181d76 <USBPD_DPM_CADCallback+0x62>
    }
    default :
      /* nothing to do */
      break;
34181d74:	bf00      	nop
  }
}
34181d76:	bf00      	nop
34181d78:	3708      	adds	r7, #8
34181d7a:	46bd      	mov	sp, r7
34181d7c:	bd80      	pop	{r7, pc}
34181d7e:	bf00      	nop

34181d80 <USBPD_PWR_IF_GetVBUSStatus>:
  * @param PortNum Port number
  * @param PowerTypeStatus  Power type status based on @ref USBPD_VBUSPOWER_STATUS
  * @retval UBBPD_TRUE or USBPD_FALSE
  */
uint8_t USBPD_PWR_IF_GetVBUSStatus(uint8_t PortNum, USBPD_VBUSPOWER_STATUS PowerTypeStatus)
{
34181d80:	b580      	push	{r7, lr}
34181d82:	b084      	sub	sp, #16
34181d84:	af00      	add	r7, sp, #0
34181d86:	4603      	mov	r3, r0
34181d88:	460a      	mov	r2, r1
34181d8a:	71fb      	strb	r3, [r7, #7]
34181d8c:	4613      	mov	r3, r2
34181d8e:	71bb      	strb	r3, [r7, #6]
/* USER CODE BEGIN USBPD_PWR_IF_GetVBUSStatus */
  uint8_t _status = USBPD_FALSE;
34181d90:	2300      	movs	r3, #0
34181d92:	73fb      	strb	r3, [r7, #15]
  uint32_t _vbus = HW_IF_PWR_GetVoltage(PortNum);
34181d94:	79fb      	ldrb	r3, [r7, #7]
34181d96:	4618      	mov	r0, r3
34181d98:	f012 fe06 	bl	341949a8 <HW_IF_PWR_GetVoltage>
34181d9c:	4603      	mov	r3, r0
34181d9e:	60bb      	str	r3, [r7, #8]

  switch(PowerTypeStatus)
34181da0:	79bb      	ldrb	r3, [r7, #6]
34181da2:	2b02      	cmp	r3, #2
34181da4:	d015      	beq.n	34181dd2 <USBPD_PWR_IF_GetVBUSStatus+0x52>
34181da6:	2b02      	cmp	r3, #2
34181da8:	dc1a      	bgt.n	34181de0 <USBPD_PWR_IF_GetVBUSStatus+0x60>
34181daa:	2b00      	cmp	r3, #0
34181dac:	d002      	beq.n	34181db4 <USBPD_PWR_IF_GetVBUSStatus+0x34>
34181dae:	2b01      	cmp	r3, #1
34181db0:	d008      	beq.n	34181dc4 <USBPD_PWR_IF_GetVBUSStatus+0x44>
    break;
  case USBPD_PWR_SNKDETACH:
    if (_vbus < USBPD_PWR_HIGH_VBUS_THRESHOLD) _status = USBPD_TRUE;
    break;
  default :
    break;
34181db2:	e015      	b.n	34181de0 <USBPD_PWR_IF_GetVBUSStatus+0x60>
    if (_vbus < USBPD_PWR_LOW_VBUS_THRESHOLD) _status = USBPD_TRUE;
34181db4:	68bb      	ldr	r3, [r7, #8]
34181db6:	f240 22ed 	movw	r2, #749	@ 0x2ed
34181dba:	4293      	cmp	r3, r2
34181dbc:	d812      	bhi.n	34181de4 <USBPD_PWR_IF_GetVBUSStatus+0x64>
34181dbe:	2301      	movs	r3, #1
34181dc0:	73fb      	strb	r3, [r7, #15]
    break;
34181dc2:	e00f      	b.n	34181de4 <USBPD_PWR_IF_GetVBUSStatus+0x64>
    if (_vbus >= USBPD_PWR_HIGH_VBUS_THRESHOLD) _status = USBPD_TRUE;
34181dc4:	68bb      	ldr	r3, [r7, #8]
34181dc6:	f5b3 6f2f 	cmp.w	r3, #2800	@ 0xaf0
34181dca:	d30d      	bcc.n	34181de8 <USBPD_PWR_IF_GetVBUSStatus+0x68>
34181dcc:	2301      	movs	r3, #1
34181dce:	73fb      	strb	r3, [r7, #15]
    break;
34181dd0:	e00a      	b.n	34181de8 <USBPD_PWR_IF_GetVBUSStatus+0x68>
    if (_vbus < USBPD_PWR_HIGH_VBUS_THRESHOLD) _status = USBPD_TRUE;
34181dd2:	68bb      	ldr	r3, [r7, #8]
34181dd4:	f5b3 6f2f 	cmp.w	r3, #2800	@ 0xaf0
34181dd8:	d208      	bcs.n	34181dec <USBPD_PWR_IF_GetVBUSStatus+0x6c>
34181dda:	2301      	movs	r3, #1
34181ddc:	73fb      	strb	r3, [r7, #15]
    break;
34181dde:	e005      	b.n	34181dec <USBPD_PWR_IF_GetVBUSStatus+0x6c>
    break;
34181de0:	bf00      	nop
34181de2:	e004      	b.n	34181dee <USBPD_PWR_IF_GetVBUSStatus+0x6e>
    break;
34181de4:	bf00      	nop
34181de6:	e002      	b.n	34181dee <USBPD_PWR_IF_GetVBUSStatus+0x6e>
    break;
34181de8:	bf00      	nop
34181dea:	e000      	b.n	34181dee <USBPD_PWR_IF_GetVBUSStatus+0x6e>
    break;
34181dec:	bf00      	nop
  }
  return _status;
34181dee:	7bfb      	ldrb	r3, [r7, #15]
/* USER CODE END USBPD_PWR_IF_GetVBUSStatus */
}
34181df0:	4618      	mov	r0, r3
34181df2:	3710      	adds	r7, #16
34181df4:	46bd      	mov	sp, r7
34181df6:	bd80      	pop	{r7, pc}

34181df8 <USBPD_USBIF_DeviceStart>:

/** @addtogroup USBPD_CORE_USBIF_Exported_Functions
  * @{
  */
void USBPD_USBIF_DeviceStart(uint32_t PortNum)
{
34181df8:	b580      	push	{r7, lr}
34181dfa:	b084      	sub	sp, #16
34181dfc:	af02      	add	r7, sp, #8
34181dfe:	6078      	str	r0, [r7, #4]
/* USER CODE BEGIN USBPD_USBIF_DeviceStart */
  USBPD_TRACE_Add(USBPD_TRACE_DEBUG, PortNum, 0, (uint8_t *) "USBIF Device start", 18);
34181e00:	687b      	ldr	r3, [r7, #4]
34181e02:	b2d9      	uxtb	r1, r3
34181e04:	2312      	movs	r3, #18
34181e06:	9300      	str	r3, [sp, #0]
34181e08:	4b0b      	ldr	r3, [pc, #44]	@ (34181e38 <USBPD_USBIF_DeviceStart+0x40>)
34181e0a:	2200      	movs	r2, #0
34181e0c:	2006      	movs	r0, #6
34181e0e:	f012 fddd 	bl	341949cc <USBPD_TRACE_Add>
  /* Set Device state */
  USB_Device_EVENT = START_USB_DEVICE;
34181e12:	4b0a      	ldr	r3, [pc, #40]	@ (34181e3c <USBPD_USBIF_DeviceStart+0x44>)
34181e14:	2202      	movs	r2, #2
34181e16:	701a      	strb	r2, [r3, #0]

  /* Send message to start device */
  if (tx_queue_send(&ux_app_MsgQueue, &USB_Device_EVENT, TX_WAIT_FOREVER) != TX_SUCCESS)
34181e18:	f04f 32ff 	mov.w	r2, #4294967295
34181e1c:	4907      	ldr	r1, [pc, #28]	@ (34181e3c <USBPD_USBIF_DeviceStart+0x44>)
34181e1e:	4808      	ldr	r0, [pc, #32]	@ (34181e40 <USBPD_USBIF_DeviceStart+0x48>)
34181e20:	f017 f800 	bl	34198e24 <_txe_queue_send>
34181e24:	4603      	mov	r3, r0
34181e26:	2b00      	cmp	r3, #0
34181e28:	d001      	beq.n	34181e2e <USBPD_USBIF_DeviceStart+0x36>
  {
    Error_Handler();
34181e2a:	f7ff fbc9 	bl	341815c0 <Error_Handler>
  }
/* USER CODE END USBPD_USBIF_DeviceStart */
}
34181e2e:	bf00      	nop
34181e30:	3708      	adds	r7, #8
34181e32:	46bd      	mov	sp, r7
34181e34:	bd80      	pop	{r7, pc}
34181e36:	bf00      	nop
34181e38:	3419e1c0 	.word	0x3419e1c0
34181e3c:	341c1c1c 	.word	0x341c1c1c
34181e40:	341c1d2c 	.word	0x341c1d2c

34181e44 <USBPD_USBIF_DeviceStop>:

void USBPD_USBIF_DeviceStop(uint32_t PortNum)
{
34181e44:	b580      	push	{r7, lr}
34181e46:	b084      	sub	sp, #16
34181e48:	af02      	add	r7, sp, #8
34181e4a:	6078      	str	r0, [r7, #4]
/* USER CODE BEGIN USBPD_USBIF_DeviceStop */
  USBPD_TRACE_Add(USBPD_TRACE_DEBUG, PortNum, 0, (uint8_t *) "USBIF Device stop", 17);
34181e4c:	687b      	ldr	r3, [r7, #4]
34181e4e:	b2d9      	uxtb	r1, r3
34181e50:	2311      	movs	r3, #17
34181e52:	9300      	str	r3, [sp, #0]
34181e54:	4b0b      	ldr	r3, [pc, #44]	@ (34181e84 <USBPD_USBIF_DeviceStop+0x40>)
34181e56:	2200      	movs	r2, #0
34181e58:	2006      	movs	r0, #6
34181e5a:	f012 fdb7 	bl	341949cc <USBPD_TRACE_Add>
  /* Set Device state */
  USB_Device_EVENT = STOP_USB_DEVICE;
34181e5e:	4b0a      	ldr	r3, [pc, #40]	@ (34181e88 <USBPD_USBIF_DeviceStop+0x44>)
34181e60:	2201      	movs	r2, #1
34181e62:	701a      	strb	r2, [r3, #0]

  /* Send message to stop device */
  if (tx_queue_send(&ux_app_MsgQueue, &USB_Device_EVENT, TX_WAIT_FOREVER) != TX_SUCCESS)
34181e64:	f04f 32ff 	mov.w	r2, #4294967295
34181e68:	4907      	ldr	r1, [pc, #28]	@ (34181e88 <USBPD_USBIF_DeviceStop+0x44>)
34181e6a:	4808      	ldr	r0, [pc, #32]	@ (34181e8c <USBPD_USBIF_DeviceStop+0x48>)
34181e6c:	f016 ffda 	bl	34198e24 <_txe_queue_send>
34181e70:	4603      	mov	r3, r0
34181e72:	2b00      	cmp	r3, #0
34181e74:	d001      	beq.n	34181e7a <USBPD_USBIF_DeviceStop+0x36>
  {
    Error_Handler();
34181e76:	f7ff fba3 	bl	341815c0 <Error_Handler>
  }
/* USER CODE END USBPD_USBIF_DeviceStop */
}
34181e7a:	bf00      	nop
34181e7c:	3708      	adds	r7, #8
34181e7e:	46bd      	mov	sp, r7
34181e80:	bd80      	pop	{r7, pc}
34181e82:	bf00      	nop
34181e84:	3419e1d4 	.word	0x3419e1d4
34181e88:	341c1c1c 	.word	0x341c1c1c
34181e8c:	341c1d2c 	.word	0x341c1d2c

34181e90 <USBPD_USBIF_HostStart>:

void USBPD_USBIF_HostStart(uint32_t PortNum)
{
34181e90:	b580      	push	{r7, lr}
34181e92:	b084      	sub	sp, #16
34181e94:	af02      	add	r7, sp, #8
34181e96:	6078      	str	r0, [r7, #4]
/* USER CODE BEGIN USBPD_USBIF_HostStart */
  USBPD_TRACE_Add(USBPD_TRACE_DEBUG, PortNum, 0, (uint8_t *) "USBIF host start", 16);
34181e98:	687b      	ldr	r3, [r7, #4]
34181e9a:	b2d9      	uxtb	r1, r3
34181e9c:	2310      	movs	r3, #16
34181e9e:	9300      	str	r3, [sp, #0]
34181ea0:	4b04      	ldr	r3, [pc, #16]	@ (34181eb4 <USBPD_USBIF_HostStart+0x24>)
34181ea2:	2200      	movs	r2, #0
34181ea4:	2006      	movs	r0, #6
34181ea6:	f012 fd91 	bl	341949cc <USBPD_TRACE_Add>
/* USER CODE END USBPD_USBIF_HostStart */
}
34181eaa:	bf00      	nop
34181eac:	3708      	adds	r7, #8
34181eae:	46bd      	mov	sp, r7
34181eb0:	bd80      	pop	{r7, pc}
34181eb2:	bf00      	nop
34181eb4:	3419e1e8 	.word	0x3419e1e8

34181eb8 <USBPD_USBIF_HostStop>:

void USBPD_USBIF_HostStop(uint32_t PortNum)
{
34181eb8:	b580      	push	{r7, lr}
34181eba:	b084      	sub	sp, #16
34181ebc:	af02      	add	r7, sp, #8
34181ebe:	6078      	str	r0, [r7, #4]
/* USER CODE BEGIN USBPD_USBIF_HostStop */
  USBPD_TRACE_Add(USBPD_TRACE_DEBUG, PortNum, 0, (uint8_t *) "USBIF host stop", 15);
34181ec0:	687b      	ldr	r3, [r7, #4]
34181ec2:	b2d9      	uxtb	r1, r3
34181ec4:	230f      	movs	r3, #15
34181ec6:	9300      	str	r3, [sp, #0]
34181ec8:	4b04      	ldr	r3, [pc, #16]	@ (34181edc <USBPD_USBIF_HostStop+0x24>)
34181eca:	2200      	movs	r2, #0
34181ecc:	2006      	movs	r0, #6
34181ece:	f012 fd7d 	bl	341949cc <USBPD_TRACE_Add>
/* USER CODE END USBPD_USBIF_HostStop */
}
34181ed2:	bf00      	nop
34181ed4:	3708      	adds	r7, #8
34181ed6:	46bd      	mov	sp, r7
34181ed8:	bd80      	pop	{r7, pc}
34181eda:	bf00      	nop
34181edc:	3419e1fc 	.word	0x3419e1fc

34181ee0 <USBPD_USBIF_Swap2Host>:
  USBPD_TRACE_Add(USBPD_TRACE_DEBUG, PortNum, 0, (uint8_t *) "USBIF device billboard", 22);
/* USER CODE END USBPD_USBIF_DeviceBillboard */
}

void USBPD_USBIF_Swap2Host(uint32_t PortNum)
{
34181ee0:	b580      	push	{r7, lr}
34181ee2:	b084      	sub	sp, #16
34181ee4:	af02      	add	r7, sp, #8
34181ee6:	6078      	str	r0, [r7, #4]
/* USER CODE BEGIN USBPD_USBIF_Swap2Host */
  USBPD_TRACE_Add(USBPD_TRACE_DEBUG, PortNum, 0, (uint8_t *) "USBIF swap to host", 18);
34181ee8:	687b      	ldr	r3, [r7, #4]
34181eea:	b2d9      	uxtb	r1, r3
34181eec:	2312      	movs	r3, #18
34181eee:	9300      	str	r3, [sp, #0]
34181ef0:	4b04      	ldr	r3, [pc, #16]	@ (34181f04 <USBPD_USBIF_Swap2Host+0x24>)
34181ef2:	2200      	movs	r2, #0
34181ef4:	2006      	movs	r0, #6
34181ef6:	f012 fd69 	bl	341949cc <USBPD_TRACE_Add>
/* USER CODE END USBPD_USBIF_Swap2Host */
}
34181efa:	bf00      	nop
34181efc:	3708      	adds	r7, #8
34181efe:	46bd      	mov	sp, r7
34181f00:	bd80      	pop	{r7, pc}
34181f02:	bf00      	nop
34181f04:	3419e224 	.word	0x3419e224

34181f08 <USBPD_USBIF_Swap2Device>:

void USBPD_USBIF_Swap2Device(uint32_t PortNum)
{
34181f08:	b580      	push	{r7, lr}
34181f0a:	b084      	sub	sp, #16
34181f0c:	af02      	add	r7, sp, #8
34181f0e:	6078      	str	r0, [r7, #4]
/* USER CODE BEGIN USBPD_USBIF_Swap2Device */
  USBPD_TRACE_Add(USBPD_TRACE_DEBUG, PortNum, 0, (uint8_t *) "USBIF swap to device", 20);
34181f10:	687b      	ldr	r3, [r7, #4]
34181f12:	b2d9      	uxtb	r1, r3
34181f14:	2314      	movs	r3, #20
34181f16:	9300      	str	r3, [sp, #0]
34181f18:	4b04      	ldr	r3, [pc, #16]	@ (34181f2c <USBPD_USBIF_Swap2Device+0x24>)
34181f1a:	2200      	movs	r2, #0
34181f1c:	2006      	movs	r0, #6
34181f1e:	f012 fd55 	bl	341949cc <USBPD_TRACE_Add>
/* USER CODE END USBPD_USBIF_Swap2Device */
}
34181f22:	bf00      	nop
34181f24:	3708      	adds	r7, #8
34181f26:	46bd      	mov	sp, r7
34181f28:	bd80      	pop	{r7, pc}
34181f2a:	bf00      	nop
34181f2c:	3419e238 	.word	0x3419e238

34181f30 <USBPD_DPM_UserCableDetection>:
  * @param  PortNum The handle of the port
  * @param  State CAD state
  * @retval None
  */
void USBPD_DPM_UserCableDetection(uint8_t PortNum, USBPD_CAD_EVENT State)
{
34181f30:	b480      	push	{r7}
34181f32:	b083      	sub	sp, #12
34181f34:	af00      	add	r7, sp, #0
34181f36:	4603      	mov	r3, r0
34181f38:	460a      	mov	r2, r1
34181f3a:	71fb      	strb	r3, [r7, #7]
34181f3c:	4613      	mov	r3, r2
34181f3e:	71bb      	strb	r3, [r7, #6]
/* USER CODE BEGIN USBPD_DPM_UserCableDetection */
   DPM_USER_DEBUG_TRACE(PortNum, "ADVICE: update USBPD_DPM_UserCableDetection");
/* USER CODE END USBPD_DPM_UserCableDetection */
}
34181f40:	bf00      	nop
34181f42:	370c      	adds	r7, #12
34181f44:	46bd      	mov	sp, r7
34181f46:	f85d 7b04 	ldr.w	r7, [sp], #4
34181f4a:	4770      	bx	lr

34181f4c <USBPD_DPM_Notification>:
  * @param  PortNum The current port number
  * @param  EventVal @ref USBPD_NotifyEventValue_TypeDef
  * @retval None
  */
void USBPD_DPM_Notification(uint8_t PortNum, USBPD_NotifyEventValue_TypeDef EventVal)
{
34181f4c:	b580      	push	{r7, lr}
34181f4e:	b082      	sub	sp, #8
34181f50:	af00      	add	r7, sp, #0
34181f52:	4603      	mov	r3, r0
34181f54:	460a      	mov	r2, r1
34181f56:	71fb      	strb	r3, [r7, #7]
34181f58:	4613      	mov	r3, r2
34181f5a:	71bb      	strb	r3, [r7, #6]
/* USER CODE BEGIN USBPD_DPM_Notification */
  /* Manage event notified by the stack? */
  switch(EventVal)
34181f5c:	79bb      	ldrb	r3, [r7, #6]
34181f5e:	3b01      	subs	r3, #1
34181f60:	2b68      	cmp	r3, #104	@ 0x68
34181f62:	f200 8105 	bhi.w	34182170 <USBPD_DPM_Notification+0x224>
34181f66:	a201      	add	r2, pc, #4	@ (adr r2, 34181f6c <USBPD_DPM_Notification+0x20>)
34181f68:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
34181f6c:	34182171 	.word	0x34182171
34181f70:	34182171 	.word	0x34182171
34181f74:	34182171 	.word	0x34182171
34181f78:	34182171 	.word	0x34182171
34181f7c:	34182171 	.word	0x34182171
34181f80:	34182171 	.word	0x34182171
34181f84:	34182171 	.word	0x34182171
34181f88:	34182171 	.word	0x34182171
34181f8c:	34182171 	.word	0x34182171
34181f90:	34182171 	.word	0x34182171
34181f94:	34182171 	.word	0x34182171
34181f98:	34182171 	.word	0x34182171
34181f9c:	34182171 	.word	0x34182171
34181fa0:	34182171 	.word	0x34182171
34181fa4:	34182171 	.word	0x34182171
34181fa8:	34182171 	.word	0x34182171
34181fac:	34182171 	.word	0x34182171
34181fb0:	34182171 	.word	0x34182171
34181fb4:	34182171 	.word	0x34182171
34181fb8:	34182171 	.word	0x34182171
34181fbc:	34182171 	.word	0x34182171
34181fc0:	34182171 	.word	0x34182171
34181fc4:	34182171 	.word	0x34182171
34181fc8:	34182171 	.word	0x34182171
34181fcc:	34182171 	.word	0x34182171
34181fd0:	34182171 	.word	0x34182171
34181fd4:	34182171 	.word	0x34182171
34181fd8:	34182171 	.word	0x34182171
34181fdc:	34182171 	.word	0x34182171
34181fe0:	34182171 	.word	0x34182171
34181fe4:	34182171 	.word	0x34182171
34181fe8:	34182171 	.word	0x34182171
34181fec:	34182171 	.word	0x34182171
34181ff0:	34182171 	.word	0x34182171
34181ff4:	34182171 	.word	0x34182171
34181ff8:	34182167 	.word	0x34182167
34181ffc:	3418215d 	.word	0x3418215d
34182000:	34182171 	.word	0x34182171
34182004:	34182171 	.word	0x34182171
34182008:	34182171 	.word	0x34182171
3418200c:	34182171 	.word	0x34182171
34182010:	34182171 	.word	0x34182171
34182014:	34182171 	.word	0x34182171
34182018:	34182171 	.word	0x34182171
3418201c:	34182171 	.word	0x34182171
34182020:	34182171 	.word	0x34182171
34182024:	34182171 	.word	0x34182171
34182028:	34182171 	.word	0x34182171
3418202c:	34182171 	.word	0x34182171
34182030:	34182171 	.word	0x34182171
34182034:	34182171 	.word	0x34182171
34182038:	34182171 	.word	0x34182171
3418203c:	34182171 	.word	0x34182171
34182040:	34182171 	.word	0x34182171
34182044:	34182171 	.word	0x34182171
34182048:	34182171 	.word	0x34182171
3418204c:	34182171 	.word	0x34182171
34182050:	34182171 	.word	0x34182171
34182054:	34182171 	.word	0x34182171
34182058:	34182171 	.word	0x34182171
3418205c:	34182171 	.word	0x34182171
34182060:	34182171 	.word	0x34182171
34182064:	34182171 	.word	0x34182171
34182068:	34182171 	.word	0x34182171
3418206c:	34182171 	.word	0x34182171
34182070:	34182171 	.word	0x34182171
34182074:	34182171 	.word	0x34182171
34182078:	34182171 	.word	0x34182171
3418207c:	34182171 	.word	0x34182171
34182080:	34182171 	.word	0x34182171
34182084:	34182171 	.word	0x34182171
34182088:	34182171 	.word	0x34182171
3418208c:	34182171 	.word	0x34182171
34182090:	34182171 	.word	0x34182171
34182094:	34182171 	.word	0x34182171
34182098:	34182171 	.word	0x34182171
3418209c:	34182171 	.word	0x34182171
341820a0:	34182171 	.word	0x34182171
341820a4:	34182171 	.word	0x34182171
341820a8:	34182171 	.word	0x34182171
341820ac:	34182171 	.word	0x34182171
341820b0:	34182171 	.word	0x34182171
341820b4:	34182171 	.word	0x34182171
341820b8:	34182171 	.word	0x34182171
341820bc:	34182171 	.word	0x34182171
341820c0:	34182171 	.word	0x34182171
341820c4:	34182171 	.word	0x34182171
341820c8:	34182171 	.word	0x34182171
341820cc:	34182171 	.word	0x34182171
341820d0:	34182171 	.word	0x34182171
341820d4:	34182171 	.word	0x34182171
341820d8:	34182171 	.word	0x34182171
341820dc:	34182171 	.word	0x34182171
341820e0:	34182171 	.word	0x34182171
341820e4:	34182171 	.word	0x34182171
341820e8:	34182171 	.word	0x34182171
341820ec:	34182171 	.word	0x34182171
341820f0:	34182171 	.word	0x34182171
341820f4:	34182171 	.word	0x34182171
341820f8:	34182171 	.word	0x34182171
341820fc:	34182171 	.word	0x34182171
34182100:	34182171 	.word	0x34182171
34182104:	34182171 	.word	0x34182171
34182108:	34182111 	.word	0x34182111
3418210c:	34182137 	.word	0x34182137
      break;
    case USBPD_NOTIFY_PE_DISABLED :
      break;
    case USBPD_NOTIFY_USBSTACK_START:
    {
      if (USBPD_PORTDATAROLE_DFP == DPM_Params[PortNum].PE_DataRole)
34182110:	79fb      	ldrb	r3, [r7, #7]
34182112:	4a1a      	ldr	r2, [pc, #104]	@ (3418217c <USBPD_DPM_Notification+0x230>)
34182114:	f812 3023 	ldrb.w	r3, [r2, r3, lsl #2]
34182118:	f3c3 03c0 	ubfx	r3, r3, #3, #1
3418211c:	b2db      	uxtb	r3, r3
3418211e:	2b01      	cmp	r3, #1
34182120:	d104      	bne.n	3418212c <USBPD_DPM_Notification+0x1e0>
      {
        USBPD_USBIF_HostStart(PortNum);
34182122:	79fb      	ldrb	r3, [r7, #7]
34182124:	4618      	mov	r0, r3
34182126:	f7ff feb3 	bl	34181e90 <USBPD_USBIF_HostStart>
      }
      else
      {
        USBPD_USBIF_DeviceStart(PortNum);
      }
      break;
3418212a:	e022      	b.n	34182172 <USBPD_DPM_Notification+0x226>
        USBPD_USBIF_DeviceStart(PortNum);
3418212c:	79fb      	ldrb	r3, [r7, #7]
3418212e:	4618      	mov	r0, r3
34182130:	f7ff fe62 	bl	34181df8 <USBPD_USBIF_DeviceStart>
      break;
34182134:	e01d      	b.n	34182172 <USBPD_DPM_Notification+0x226>
    }
    case USBPD_NOTIFY_USBSTACK_STOP:
    {
      if (USBPD_PORTDATAROLE_DFP == DPM_Params[PortNum].PE_DataRole)
34182136:	79fb      	ldrb	r3, [r7, #7]
34182138:	4a10      	ldr	r2, [pc, #64]	@ (3418217c <USBPD_DPM_Notification+0x230>)
3418213a:	f812 3023 	ldrb.w	r3, [r2, r3, lsl #2]
3418213e:	f3c3 03c0 	ubfx	r3, r3, #3, #1
34182142:	b2db      	uxtb	r3, r3
34182144:	2b01      	cmp	r3, #1
34182146:	d104      	bne.n	34182152 <USBPD_DPM_Notification+0x206>
      {
        USBPD_USBIF_HostStop(PortNum);
34182148:	79fb      	ldrb	r3, [r7, #7]
3418214a:	4618      	mov	r0, r3
3418214c:	f7ff feb4 	bl	34181eb8 <USBPD_USBIF_HostStop>
      }
      else
      {
        USBPD_USBIF_DeviceStop(PortNum);
      }
      break;
34182150:	e00f      	b.n	34182172 <USBPD_DPM_Notification+0x226>
        USBPD_USBIF_DeviceStop(PortNum);
34182152:	79fb      	ldrb	r3, [r7, #7]
34182154:	4618      	mov	r0, r3
34182156:	f7ff fe75 	bl	34181e44 <USBPD_USBIF_DeviceStop>
      break;
3418215a:	e00a      	b.n	34182172 <USBPD_DPM_Notification+0x226>
    }
    case USBPD_NOTIFY_DATAROLESWAP_DFP :
      {
        USBPD_USBIF_Swap2Host(PortNum);
3418215c:	79fb      	ldrb	r3, [r7, #7]
3418215e:	4618      	mov	r0, r3
34182160:	f7ff febe 	bl	34181ee0 <USBPD_USBIF_Swap2Host>
        break;
34182164:	e005      	b.n	34182172 <USBPD_DPM_Notification+0x226>
      }
    case USBPD_NOTIFY_DATAROLESWAP_UFP :
      {
        USBPD_USBIF_Swap2Device(PortNum);
34182166:	79fb      	ldrb	r3, [r7, #7]
34182168:	4618      	mov	r0, r3
3418216a:	f7ff fecd 	bl	34181f08 <USBPD_USBIF_Swap2Device>
        break;
3418216e:	e000      	b.n	34182172 <USBPD_DPM_Notification+0x226>
      }

    default:
      DPM_USER_DEBUG_TRACE(PortNum, "ADVICE: USBPD_DPM_Notification:%d", EventVal);
      break;
34182170:	bf00      	nop
  }
/* USER CODE END USBPD_DPM_Notification */
}
34182172:	bf00      	nop
34182174:	3708      	adds	r7, #8
34182176:	46bd      	mov	sp, r7
34182178:	bd80      	pop	{r7, pc}
3418217a:	bf00      	nop
3418217c:	341c1c18 	.word	0x341c1c18

34182180 <MX_USBX_Device_Init>:
  * @brief  Application USBX Device Initialization.
  * @param  memory_ptr: memory pointer
  * @retval status
  */
UINT MX_USBX_Device_Init(VOID *memory_ptr)
{
34182180:	b590      	push	{r4, r7, lr}
34182182:	b097      	sub	sp, #92	@ 0x5c
34182184:	af08      	add	r7, sp, #32
34182186:	6078      	str	r0, [r7, #4]
  UINT ret = UX_SUCCESS;
34182188:	2300      	movs	r3, #0
3418218a:	637b      	str	r3, [r7, #52]	@ 0x34
  ULONG string_framework_length;
  ULONG language_id_framework_length;
  UCHAR *string_framework;
  UCHAR *language_id_framework;
  UCHAR *pointer;
  TX_BYTE_POOL *byte_pool = (TX_BYTE_POOL*)memory_ptr;
3418218c:	687b      	ldr	r3, [r7, #4]
3418218e:	633b      	str	r3, [r7, #48]	@ 0x30
  /* USER CODE BEGIN MX_USBX_Device_Init0 */

  /* USER CODE END MX_USBX_Device_Init0 */

  /* Allocate the stack for USBX Memory */
  if (tx_byte_allocate(byte_pool, (VOID **) &pointer,
34182190:	f107 010c 	add.w	r1, r7, #12
34182194:	2300      	movs	r3, #0
34182196:	f44f 52a0 	mov.w	r2, #5120	@ 0x1400
3418219a:	6b38      	ldr	r0, [r7, #48]	@ 0x30
3418219c:	f016 f9ec 	bl	34198578 <_txe_byte_allocate>
341821a0:	4603      	mov	r3, r0
341821a2:	2b00      	cmp	r3, #0
341821a4:	d001      	beq.n	341821aa <MX_USBX_Device_Init+0x2a>
                       USBX_DEVICE_MEMORY_STACK_SIZE, TX_NO_WAIT) != TX_SUCCESS)
  {
    /* USER CODE BEGIN USBX_ALLOCATE_STACK_ERROR */
    return TX_POOL_ERROR;
341821a6:	2302      	movs	r3, #2
341821a8:	e0d2      	b.n	34182350 <MX_USBX_Device_Init+0x1d0>
    /* USER CODE END USBX_ALLOCATE_STACK_ERROR */
  }

  /* Initialize USBX Memory */
  if (ux_system_initialize(pointer, USBX_DEVICE_MEMORY_STACK_SIZE, UX_NULL, 0) != UX_SUCCESS)
341821aa:	68f8      	ldr	r0, [r7, #12]
341821ac:	2300      	movs	r3, #0
341821ae:	2200      	movs	r2, #0
341821b0:	f44f 51a0 	mov.w	r1, #5120	@ 0x1400
341821b4:	f017 fa4a 	bl	3419964c <_uxe_system_initialize>
341821b8:	4603      	mov	r3, r0
341821ba:	2b00      	cmp	r3, #0
341821bc:	d001      	beq.n	341821c2 <MX_USBX_Device_Init+0x42>
  {
    /* USER CODE BEGIN USBX_SYSTEM_INITIALIZE_ERROR */
    return UX_ERROR;
341821be:	23ff      	movs	r3, #255	@ 0xff
341821c0:	e0c6      	b.n	34182350 <MX_USBX_Device_Init+0x1d0>
    /* USER CODE END USBX_SYSTEM_INITIALIZE_ERROR */
  }

  /* Get Device Framework High Speed and get the length */
  device_framework_high_speed = USBD_Get_Device_Framework_Speed(USBD_HIGH_SPEED,
341821c2:	f107 031c 	add.w	r3, r7, #28
341821c6:	4619      	mov	r1, r3
341821c8:	2001      	movs	r0, #1
341821ca:	f000 f935 	bl	34182438 <USBD_Get_Device_Framework_Speed>
341821ce:	62f8      	str	r0, [r7, #44]	@ 0x2c
                                                                &device_framework_hs_length);

  /* Get Device Framework Full Speed and get the length */
  device_framework_full_speed = USBD_Get_Device_Framework_Speed(USBD_FULL_SPEED,
341821d0:	f107 0318 	add.w	r3, r7, #24
341821d4:	4619      	mov	r1, r3
341821d6:	2000      	movs	r0, #0
341821d8:	f000 f92e 	bl	34182438 <USBD_Get_Device_Framework_Speed>
341821dc:	62b8      	str	r0, [r7, #40]	@ 0x28
                                                                &device_framework_fs_length);

  /* Get String Framework and get the length */
  string_framework = USBD_Get_String_Framework(&string_framework_length);
341821de:	f107 0314 	add.w	r3, r7, #20
341821e2:	4618      	mov	r0, r3
341821e4:	f000 f96a 	bl	341824bc <USBD_Get_String_Framework>
341821e8:	6278      	str	r0, [r7, #36]	@ 0x24

  /* Get Language Id Framework and get the length */
  language_id_framework = USBD_Get_Language_Id_Framework(&language_id_framework_length);
341821ea:	f107 0310 	add.w	r3, r7, #16
341821ee:	4618      	mov	r0, r3
341821f0:	f000 f9e8 	bl	341825c4 <USBD_Get_Language_Id_Framework>
341821f4:	6238      	str	r0, [r7, #32]

  /* Install the device portion of USBX */
  if (ux_device_stack_initialize(device_framework_high_speed,
341821f6:	69f9      	ldr	r1, [r7, #28]
341821f8:	69b8      	ldr	r0, [r7, #24]
341821fa:	697b      	ldr	r3, [r7, #20]
341821fc:	693a      	ldr	r2, [r7, #16]
341821fe:	2400      	movs	r4, #0
34182200:	9404      	str	r4, [sp, #16]
34182202:	9203      	str	r2, [sp, #12]
34182204:	6a3a      	ldr	r2, [r7, #32]
34182206:	9202      	str	r2, [sp, #8]
34182208:	9301      	str	r3, [sp, #4]
3418220a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3418220c:	9300      	str	r3, [sp, #0]
3418220e:	4603      	mov	r3, r0
34182210:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34182212:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
34182214:	f019 f878 	bl	3419b308 <_ux_device_stack_initialize>
34182218:	4603      	mov	r3, r0
3418221a:	2b00      	cmp	r3, #0
3418221c:	d001      	beq.n	34182222 <MX_USBX_Device_Init+0xa2>
                                 language_id_framework,
                                 language_id_framework_length,
                                 UX_NULL) != UX_SUCCESS)
  {
    /* USER CODE BEGIN USBX_DEVICE_INITIALIZE_ERROR */
    return UX_ERROR;
3418221e:	23ff      	movs	r3, #255	@ 0xff
34182220:	e096      	b.n	34182350 <MX_USBX_Device_Init+0x1d0>
    /* USER CODE END USBX_DEVICE_INITIALIZE_ERROR */
  }

  /* Initialize the storage class parameters for the device */
  storage_parameter.ux_slave_class_storage_instance_activate   = USBD_STORAGE_Activate;
34182222:	4b4d      	ldr	r3, [pc, #308]	@ (34182358 <MX_USBX_Device_Init+0x1d8>)
34182224:	4a4d      	ldr	r2, [pc, #308]	@ (3418235c <MX_USBX_Device_Init+0x1dc>)
34182226:	601a      	str	r2, [r3, #0]
  storage_parameter.ux_slave_class_storage_instance_deactivate = USBD_STORAGE_Deactivate;
34182228:	4b4b      	ldr	r3, [pc, #300]	@ (34182358 <MX_USBX_Device_Init+0x1d8>)
3418222a:	4a4d      	ldr	r2, [pc, #308]	@ (34182360 <MX_USBX_Device_Init+0x1e0>)
3418222c:	605a      	str	r2, [r3, #4]

  /* Store the number of LUN in this device storage instance */
  storage_parameter.ux_slave_class_storage_parameter_number_lun = STORAGE_NUMBER_LUN;
3418222e:	4b4a      	ldr	r3, [pc, #296]	@ (34182358 <MX_USBX_Device_Init+0x1d8>)
34182230:	2201      	movs	r2, #1
34182232:	609a      	str	r2, [r3, #8]

  /* Initialize the storage class parameters for reading/writing to the Flash Disk */
  storage_parameter.ux_slave_class_storage_parameter_lun[0].
    ux_slave_class_storage_media_last_lba = USBD_STORAGE_GetMediaLastLba();
34182234:	f000 fe8c 	bl	34182f50 <USBD_STORAGE_GetMediaLastLba>
34182238:	4603      	mov	r3, r0
3418223a:	4a47      	ldr	r2, [pc, #284]	@ (34182358 <MX_USBX_Device_Init+0x1d8>)
3418223c:	60d3      	str	r3, [r2, #12]

  storage_parameter.ux_slave_class_storage_parameter_lun[0].
    ux_slave_class_storage_media_block_length = USBD_STORAGE_GetMediaBlocklength();
3418223e:	f000 fe99 	bl	34182f74 <USBD_STORAGE_GetMediaBlocklength>
34182242:	4603      	mov	r3, r0
34182244:	4a44      	ldr	r2, [pc, #272]	@ (34182358 <MX_USBX_Device_Init+0x1d8>)
34182246:	6113      	str	r3, [r2, #16]

  storage_parameter.ux_slave_class_storage_parameter_lun[0].
    ux_slave_class_storage_media_type = 0;
34182248:	4b43      	ldr	r3, [pc, #268]	@ (34182358 <MX_USBX_Device_Init+0x1d8>)
3418224a:	2200      	movs	r2, #0
3418224c:	615a      	str	r2, [r3, #20]

  storage_parameter.ux_slave_class_storage_parameter_lun[0].
    ux_slave_class_storage_media_removable_flag = STORAGE_REMOVABLE_FLAG;
3418224e:	4b42      	ldr	r3, [pc, #264]	@ (34182358 <MX_USBX_Device_Init+0x1d8>)
34182250:	2280      	movs	r2, #128	@ 0x80
34182252:	619a      	str	r2, [r3, #24]

  storage_parameter.ux_slave_class_storage_parameter_lun[0].
    ux_slave_class_storage_media_read_only_flag = STORAGE_READ_ONLY;
34182254:	4b40      	ldr	r3, [pc, #256]	@ (34182358 <MX_USBX_Device_Init+0x1d8>)
34182256:	2200      	movs	r2, #0
34182258:	61da      	str	r2, [r3, #28]

  storage_parameter.ux_slave_class_storage_parameter_lun[0].
    ux_slave_class_storage_media_read = USBD_STORAGE_Read;
3418225a:	4b3f      	ldr	r3, [pc, #252]	@ (34182358 <MX_USBX_Device_Init+0x1d8>)
3418225c:	4a41      	ldr	r2, [pc, #260]	@ (34182364 <MX_USBX_Device_Init+0x1e4>)
3418225e:	631a      	str	r2, [r3, #48]	@ 0x30

  storage_parameter.ux_slave_class_storage_parameter_lun[0].
    ux_slave_class_storage_media_write = USBD_STORAGE_Write;
34182260:	4b3d      	ldr	r3, [pc, #244]	@ (34182358 <MX_USBX_Device_Init+0x1d8>)
34182262:	4a41      	ldr	r2, [pc, #260]	@ (34182368 <MX_USBX_Device_Init+0x1e8>)
34182264:	635a      	str	r2, [r3, #52]	@ 0x34

  storage_parameter.ux_slave_class_storage_parameter_lun[0].
    ux_slave_class_storage_media_flush = USBD_STORAGE_Flush;
34182266:	4b3c      	ldr	r3, [pc, #240]	@ (34182358 <MX_USBX_Device_Init+0x1d8>)
34182268:	4a40      	ldr	r2, [pc, #256]	@ (3418236c <MX_USBX_Device_Init+0x1ec>)
3418226a:	639a      	str	r2, [r3, #56]	@ 0x38

  storage_parameter.ux_slave_class_storage_parameter_lun[0].
    ux_slave_class_storage_media_status = USBD_STORAGE_Status;
3418226c:	4b3a      	ldr	r3, [pc, #232]	@ (34182358 <MX_USBX_Device_Init+0x1d8>)
3418226e:	4a40      	ldr	r2, [pc, #256]	@ (34182370 <MX_USBX_Device_Init+0x1f0>)
34182270:	63da      	str	r2, [r3, #60]	@ 0x3c

  storage_parameter.ux_slave_class_storage_parameter_lun[0].
    ux_slave_class_storage_media_notification = USBD_STORAGE_Notification;
34182272:	4b39      	ldr	r3, [pc, #228]	@ (34182358 <MX_USBX_Device_Init+0x1d8>)
34182274:	4a3f      	ldr	r2, [pc, #252]	@ (34182374 <MX_USBX_Device_Init+0x1f4>)
34182276:	641a      	str	r2, [r3, #64]	@ 0x40
  /* USER CODE BEGIN STORAGE_PARAMETER */

  /* USER CODE END STORAGE_PARAMETER */

  /* Get storage configuration number */
  storage_configuration_number = USBD_Get_Configuration_Number(CLASS_TYPE_MSC, 0);
34182278:	2100      	movs	r1, #0
3418227a:	2003      	movs	r0, #3
3418227c:	f000 fa02 	bl	34182684 <USBD_Get_Configuration_Number>
34182280:	4603      	mov	r3, r0
34182282:	461a      	mov	r2, r3
34182284:	4b3c      	ldr	r3, [pc, #240]	@ (34182378 <MX_USBX_Device_Init+0x1f8>)
34182286:	601a      	str	r2, [r3, #0]

  /* Find storage interface number */
  storage_interface_number = USBD_Get_Interface_Number(CLASS_TYPE_MSC, 0);
34182288:	2100      	movs	r1, #0
3418228a:	2003      	movs	r0, #3
3418228c:	f000 f9bc 	bl	34182608 <USBD_Get_Interface_Number>
34182290:	4603      	mov	r3, r0
34182292:	461a      	mov	r2, r3
34182294:	4b39      	ldr	r3, [pc, #228]	@ (3418237c <MX_USBX_Device_Init+0x1fc>)
34182296:	601a      	str	r2, [r3, #0]

  /* Initialize the device storage class */
  if (ux_device_stack_class_register(_ux_system_slave_class_storage_name,
34182298:	4b37      	ldr	r3, [pc, #220]	@ (34182378 <MX_USBX_Device_Init+0x1f8>)
3418229a:	681a      	ldr	r2, [r3, #0]
3418229c:	4b37      	ldr	r3, [pc, #220]	@ (3418237c <MX_USBX_Device_Init+0x1fc>)
3418229e:	681b      	ldr	r3, [r3, #0]
341822a0:	492d      	ldr	r1, [pc, #180]	@ (34182358 <MX_USBX_Device_Init+0x1d8>)
341822a2:	9100      	str	r1, [sp, #0]
341822a4:	4936      	ldr	r1, [pc, #216]	@ (34182380 <MX_USBX_Device_Init+0x200>)
341822a6:	4837      	ldr	r0, [pc, #220]	@ (34182384 <MX_USBX_Device_Init+0x204>)
341822a8:	f018 f97a 	bl	3419a5a0 <_ux_device_stack_class_register>
341822ac:	4603      	mov	r3, r0
341822ae:	2b00      	cmp	r3, #0
341822b0:	d001      	beq.n	341822b6 <MX_USBX_Device_Init+0x136>
                                     storage_configuration_number,
                                     storage_interface_number,
                                     &storage_parameter) != UX_SUCCESS)
  {
    /* USER CODE BEGIN USBX_DEVICE_STORAGE_REGISTER_ERROR */
    return UX_ERROR;
341822b2:	23ff      	movs	r3, #255	@ 0xff
341822b4:	e04c      	b.n	34182350 <MX_USBX_Device_Init+0x1d0>
    /* USER CODE END USBX_DEVICE_STORAGE_REGISTER_ERROR */
  }

  /* Allocate the stack for device application main thread */
  if (tx_byte_allocate(byte_pool, (VOID **) &pointer, UX_DEVICE_APP_THREAD_STACK_SIZE,
341822b6:	f107 010c 	add.w	r1, r7, #12
341822ba:	2300      	movs	r3, #0
341822bc:	f44f 6280 	mov.w	r2, #1024	@ 0x400
341822c0:	6b38      	ldr	r0, [r7, #48]	@ 0x30
341822c2:	f016 f959 	bl	34198578 <_txe_byte_allocate>
341822c6:	4603      	mov	r3, r0
341822c8:	2b00      	cmp	r3, #0
341822ca:	d001      	beq.n	341822d0 <MX_USBX_Device_Init+0x150>
                       TX_NO_WAIT) != TX_SUCCESS)
  {
    /* USER CODE BEGIN MAIN_THREAD_ALLOCATE_STACK_ERROR */
    return TX_POOL_ERROR;
341822cc:	2302      	movs	r3, #2
341822ce:	e03f      	b.n	34182350 <MX_USBX_Device_Init+0x1d0>
    /* USER CODE END MAIN_THREAD_ALLOCATE_STACK_ERROR */
  }

  /* Create the device application main thread */
  if (tx_thread_create(&ux_device_app_thread, UX_DEVICE_APP_THREAD_NAME, app_ux_device_thread_entry,
341822d0:	68fb      	ldr	r3, [r7, #12]
341822d2:	22b0      	movs	r2, #176	@ 0xb0
341822d4:	9206      	str	r2, [sp, #24]
341822d6:	2201      	movs	r2, #1
341822d8:	9205      	str	r2, [sp, #20]
341822da:	2200      	movs	r2, #0
341822dc:	9204      	str	r2, [sp, #16]
341822de:	220a      	movs	r2, #10
341822e0:	9203      	str	r2, [sp, #12]
341822e2:	220a      	movs	r2, #10
341822e4:	9202      	str	r2, [sp, #8]
341822e6:	f44f 6280 	mov.w	r2, #1024	@ 0x400
341822ea:	9201      	str	r2, [sp, #4]
341822ec:	9300      	str	r3, [sp, #0]
341822ee:	2300      	movs	r3, #0
341822f0:	4a25      	ldr	r2, [pc, #148]	@ (34182388 <MX_USBX_Device_Init+0x208>)
341822f2:	4926      	ldr	r1, [pc, #152]	@ (3418238c <MX_USBX_Device_Init+0x20c>)
341822f4:	4826      	ldr	r0, [pc, #152]	@ (34182390 <MX_USBX_Device_Init+0x210>)
341822f6:	f016 ff13 	bl	34199120 <_txe_thread_create>
341822fa:	4603      	mov	r3, r0
341822fc:	2b00      	cmp	r3, #0
341822fe:	d001      	beq.n	34182304 <MX_USBX_Device_Init+0x184>
                       0, pointer, UX_DEVICE_APP_THREAD_STACK_SIZE, UX_DEVICE_APP_THREAD_PRIO,
                       UX_DEVICE_APP_THREAD_PREEMPTION_THRESHOLD, UX_DEVICE_APP_THREAD_TIME_SLICE,
                       UX_DEVICE_APP_THREAD_START_OPTION) != TX_SUCCESS)
  {
    /* USER CODE BEGIN MAIN_THREAD_CREATE_ERROR */
    return TX_THREAD_ERROR;
34182300:	230e      	movs	r3, #14
34182302:	e025      	b.n	34182350 <MX_USBX_Device_Init+0x1d0>
  }

  /* USER CODE BEGIN MX_USBX_Device_Init1 */

  /* Create the event flags group */
  if (tx_event_flags_create(&EventFlag, "Event Flag") != TX_SUCCESS)
34182304:	2224      	movs	r2, #36	@ 0x24
34182306:	4923      	ldr	r1, [pc, #140]	@ (34182394 <MX_USBX_Device_Init+0x214>)
34182308:	4823      	ldr	r0, [pc, #140]	@ (34182398 <MX_USBX_Device_Init+0x218>)
3418230a:	f016 fa49 	bl	341987a0 <_txe_event_flags_create>
3418230e:	4603      	mov	r3, r0
34182310:	2b00      	cmp	r3, #0
34182312:	d001      	beq.n	34182318 <MX_USBX_Device_Init+0x198>
  {
    return TX_GROUP_ERROR;
34182314:	2306      	movs	r3, #6
34182316:	e01b      	b.n	34182350 <MX_USBX_Device_Init+0x1d0>
  }
  /* Allocate Memory for the Queue */
  if (tx_byte_allocate(byte_pool, (VOID **) &pointer, APP_QUEUE_SIZE*sizeof(ULONG),
34182318:	f107 010c 	add.w	r1, r7, #12
3418231c:	2300      	movs	r3, #0
3418231e:	2214      	movs	r2, #20
34182320:	6b38      	ldr	r0, [r7, #48]	@ 0x30
34182322:	f016 f929 	bl	34198578 <_txe_byte_allocate>
34182326:	4603      	mov	r3, r0
34182328:	2b00      	cmp	r3, #0
3418232a:	d001      	beq.n	34182330 <MX_USBX_Device_Init+0x1b0>
                       TX_NO_WAIT) != TX_SUCCESS)
  {
    return TX_POOL_ERROR;
3418232c:	2302      	movs	r3, #2
3418232e:	e00f      	b.n	34182350 <MX_USBX_Device_Init+0x1d0>
  }

  /* Create the MsgQueue */
  if (tx_queue_create(&ux_app_MsgQueue, "Message Queue app", TX_1_ULONG,
34182330:	68fb      	ldr	r3, [r7, #12]
34182332:	2238      	movs	r2, #56	@ 0x38
34182334:	9201      	str	r2, [sp, #4]
34182336:	2214      	movs	r2, #20
34182338:	9200      	str	r2, [sp, #0]
3418233a:	2201      	movs	r2, #1
3418233c:	4917      	ldr	r1, [pc, #92]	@ (3418239c <MX_USBX_Device_Init+0x21c>)
3418233e:	4818      	ldr	r0, [pc, #96]	@ (341823a0 <MX_USBX_Device_Init+0x220>)
34182340:	f016 fc76 	bl	34198c30 <_txe_queue_create>
34182344:	4603      	mov	r3, r0
34182346:	2b00      	cmp	r3, #0
34182348:	d001      	beq.n	3418234e <MX_USBX_Device_Init+0x1ce>
                      pointer, APP_QUEUE_SIZE*sizeof(ULONG)) != TX_SUCCESS)
  {
    return TX_QUEUE_ERROR;
3418234a:	2309      	movs	r3, #9
3418234c:	e000      	b.n	34182350 <MX_USBX_Device_Init+0x1d0>
  }
  /* USER CODE END MX_USBX_Device_Init1 */

  return ret;
3418234e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
}
34182350:	4618      	mov	r0, r3
34182352:	373c      	adds	r7, #60	@ 0x3c
34182354:	46bd      	mov	sp, r7
34182356:	bd90      	pop	{r4, r7, pc}
34182358:	341c1c28 	.word	0x341c1c28
3418235c:	34182dc1 	.word	0x34182dc1
34182360:	34182dd5 	.word	0x34182dd5
34182364:	34182de9 	.word	0x34182de9
34182368:	34182e6d 	.word	0x34182e6d
3418236c:	34182ef1 	.word	0x34182ef1
34182370:	34182f11 	.word	0x34182f11
34182374:	34182f31 	.word	0x34182f31
34182378:	341c1c24 	.word	0x341c1c24
3418237c:	341c1c20 	.word	0x341c1c20
34182380:	3419be45 	.word	0x3419be45
34182384:	341c00d0 	.word	0x341c00d0
34182388:	341823a5 	.word	0x341823a5
3418238c:	3419e278 	.word	0x3419e278
34182390:	341c1c7c 	.word	0x341c1c7c
34182394:	3419e294 	.word	0x3419e294
34182398:	341c1d64 	.word	0x341c1d64
3418239c:	3419e2a0 	.word	0x3419e2a0
341823a0:	341c1d2c 	.word	0x341c1d2c

341823a4 <app_ux_device_thread_entry>:
  * @brief  Function implementing app_ux_device_thread_entry.
  * @param  thread_input: User thread input parameter.
  * @retval none
  */
static VOID app_ux_device_thread_entry(ULONG thread_input)
{
341823a4:	b580      	push	{r7, lr}
341823a6:	b082      	sub	sp, #8
341823a8:	af00      	add	r7, sp, #0
341823aa:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN app_ux_device_thread_entry */

  /* Initialization of USB device */
  USBX_APP_Device_Init();
341823ac:	f000 f824 	bl	341823f8 <USBX_APP_Device_Init>

  /* Wait for message queue to start/stop the device */
  while(1)
  {
    /* Wait for a device to be connected */
    if ( tx_queue_receive(&ux_app_MsgQueue, &USB_Device_State_Msg,
341823b0:	f04f 32ff 	mov.w	r2, #4294967295
341823b4:	490d      	ldr	r1, [pc, #52]	@ (341823ec <app_ux_device_thread_entry+0x48>)
341823b6:	480e      	ldr	r0, [pc, #56]	@ (341823f0 <app_ux_device_thread_entry+0x4c>)
341823b8:	f016 fcea 	bl	34198d90 <_txe_queue_receive>
341823bc:	4603      	mov	r3, r0
341823be:	2b00      	cmp	r3, #0
341823c0:	d001      	beq.n	341823c6 <app_ux_device_thread_entry+0x22>
                         TX_WAIT_FOREVER)!= TX_SUCCESS)
    {
      /*Error*/
      Error_Handler();
341823c2:	f7ff f8fd 	bl	341815c0 <Error_Handler>
    }
    /* Check if received message equal to USB_PCD_START */
    if (USB_Device_State_Msg == START_USB_DEVICE)
341823c6:	4b09      	ldr	r3, [pc, #36]	@ (341823ec <app_ux_device_thread_entry+0x48>)
341823c8:	781b      	ldrb	r3, [r3, #0]
341823ca:	2b02      	cmp	r3, #2
341823cc:	d103      	bne.n	341823d6 <app_ux_device_thread_entry+0x32>
    {
      /* Start device USB */
      HAL_PCD_Start(&hpcd_USB1_OTG_HS);
341823ce:	4809      	ldr	r0, [pc, #36]	@ (341823f4 <app_ux_device_thread_entry+0x50>)
341823d0:	f006 f821 	bl	34188416 <HAL_PCD_Start>
341823d4:	e7ec      	b.n	341823b0 <app_ux_device_thread_entry+0xc>
    }
    /* Check if received message equal to USB_PCD_STOP */
    else if (USB_Device_State_Msg == STOP_USB_DEVICE)
341823d6:	4b05      	ldr	r3, [pc, #20]	@ (341823ec <app_ux_device_thread_entry+0x48>)
341823d8:	781b      	ldrb	r3, [r3, #0]
341823da:	2b01      	cmp	r3, #1
341823dc:	d103      	bne.n	341823e6 <app_ux_device_thread_entry+0x42>
    {
      /* Stop device USB */
      HAL_PCD_Stop(&hpcd_USB1_OTG_HS);
341823de:	4805      	ldr	r0, [pc, #20]	@ (341823f4 <app_ux_device_thread_entry+0x50>)
341823e0:	f006 f83b 	bl	3418845a <HAL_PCD_Stop>
341823e4:	e7e4      	b.n	341823b0 <app_ux_device_thread_entry+0xc>
    }
    /* Else Error */
    else
    {
      /*Error*/
      Error_Handler();
341823e6:	f7ff f8eb 	bl	341815c0 <Error_Handler>
    if ( tx_queue_receive(&ux_app_MsgQueue, &USB_Device_State_Msg,
341823ea:	e7e1      	b.n	341823b0 <app_ux_device_thread_entry+0xc>
341823ec:	341c1d88 	.word	0x341c1d88
341823f0:	341c1d2c 	.word	0x341c1d2c
341823f4:	341fc800 	.word	0x341fc800

341823f8 <USBX_APP_Device_Init>:
  *         Initialization of USB device.
  * @param  none
  * @retval none
  */
VOID USBX_APP_Device_Init(VOID)
{
341823f8:	b580      	push	{r7, lr}
341823fa:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN USB_Device_Init_PreTreatment_0 */

  /* USER CODE END USB_Device_Init_PreTreatment_0 */

  /* USB_OTG_HS init function */
  MX_USB1_OTG_HS_PCD_Init();
341823fc:	f7ff f896 	bl	3418152c <MX_USB1_OTG_HS_PCD_Init>

  /* USER CODE BEGIN USB_Device_Init_PreTreatment_1 */
  /* Set Rx FIFO */
  HAL_PCDEx_SetRxFiFo(&hpcd_USB1_OTG_HS, 0x200);
34182400:	f44f 7100 	mov.w	r1, #512	@ 0x200
34182404:	480a      	ldr	r0, [pc, #40]	@ (34182430 <USBX_APP_Device_Init+0x38>)
34182406:	f007 f9b4 	bl	34189772 <HAL_PCDEx_SetRxFiFo>
  /* Set Tx FIFO 0 */
  HAL_PCDEx_SetTxFiFo(&hpcd_USB1_OTG_HS, 0, 0x40);
3418240a:	2240      	movs	r2, #64	@ 0x40
3418240c:	2100      	movs	r1, #0
3418240e:	4808      	ldr	r0, [pc, #32]	@ (34182430 <USBX_APP_Device_Init+0x38>)
34182410:	f007 f968 	bl	341896e4 <HAL_PCDEx_SetTxFiFo>
  /* Set Tx FIFO 1 */
  HAL_PCDEx_SetTxFiFo(&hpcd_USB1_OTG_HS, 1, 0x100);
34182414:	f44f 7280 	mov.w	r2, #256	@ 0x100
34182418:	2101      	movs	r1, #1
3418241a:	4805      	ldr	r0, [pc, #20]	@ (34182430 <USBX_APP_Device_Init+0x38>)
3418241c:	f007 f962 	bl	341896e4 <HAL_PCDEx_SetTxFiFo>
  /* USER CODE END USB_Device_Init_PreTreatment_1 */

  /* Initialize and link controller HAL driver */
  ux_dcd_stm32_initialize((ULONG)USB1_OTG_HS, (ULONG)&hpcd_USB1_OTG_HS);
34182420:	4b03      	ldr	r3, [pc, #12]	@ (34182430 <USBX_APP_Device_Init+0x38>)
34182422:	4619      	mov	r1, r3
34182424:	4803      	ldr	r0, [pc, #12]	@ (34182434 <USBX_APP_Device_Init+0x3c>)
34182426:	f01b fc13 	bl	3419dc50 <_ux_dcd_stm32_initialize>

  /* USER CODE BEGIN USB_Device_Init_PostTreatment */

  /* USER CODE END USB_Device_Init_PostTreatment */
}
3418242a:	bf00      	nop
3418242c:	bd80      	pop	{r7, pc}
3418242e:	bf00      	nop
34182430:	341fc800 	.word	0x341fc800
34182434:	58040000 	.word	0x58040000

34182438 <USBD_Get_Device_Framework_Speed>:
  * @param  Speed : HIGH or FULL SPEED flag
  * @param  length : length of HIGH or FULL SPEED array
  * @retval Pointer to descriptor buffer
  */
uint8_t *USBD_Get_Device_Framework_Speed(uint8_t Speed, ULONG *Length)
{
34182438:	b580      	push	{r7, lr}
3418243a:	b084      	sub	sp, #16
3418243c:	af00      	add	r7, sp, #0
3418243e:	4603      	mov	r3, r0
34182440:	6039      	str	r1, [r7, #0]
34182442:	71fb      	strb	r3, [r7, #7]
  uint8_t *pFrameWork = NULL;
34182444:	2300      	movs	r3, #0
34182446:	60fb      	str	r3, [r7, #12]
  /* USER CODE BEGIN Device_Framework0 */

  /* USER TAG BEGIN Device_Framework0 */

  if (USBD_FULL_SPEED == Speed)
34182448:	79fb      	ldrb	r3, [r7, #7]
3418244a:	2b00      	cmp	r3, #0
3418244c:	d113      	bne.n	34182476 <USBD_Get_Device_Framework_Speed+0x3e>
  {
    USBD_Device_Framework_Builder(&USBD_Device_FS, pDevFrameWorkDesc_FS,
3418244e:	4b16      	ldr	r3, [pc, #88]	@ (341824a8 <USBD_Get_Device_Framework_Speed+0x70>)
34182450:	6819      	ldr	r1, [r3, #0]
34182452:	79fb      	ldrb	r3, [r7, #7]
34182454:	4a15      	ldr	r2, [pc, #84]	@ (341824ac <USBD_Get_Device_Framework_Speed+0x74>)
34182456:	4816      	ldr	r0, [pc, #88]	@ (341824b0 <USBD_Get_Device_Framework_Speed+0x78>)
34182458:	f000 f974 	bl	34182744 <USBD_Device_Framework_Builder>
                                  UserClassInstance, Speed);

    /* Get the length of USBD_device_framework_full_speed */
    *Length = (ULONG)(USBD_Device_FS.CurrDevDescSz + USBD_Device_FS.CurrConfDescSz);
3418245c:	4b14      	ldr	r3, [pc, #80]	@ (341824b0 <USBD_Get_Device_Framework_Speed+0x78>)
3418245e:	f8d3 2120 	ldr.w	r2, [r3, #288]	@ 0x120
34182462:	4b13      	ldr	r3, [pc, #76]	@ (341824b0 <USBD_Get_Device_Framework_Speed+0x78>)
34182464:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
34182468:	441a      	add	r2, r3
3418246a:	683b      	ldr	r3, [r7, #0]
3418246c:	601a      	str	r2, [r3, #0]

    pFrameWork = pDevFrameWorkDesc_FS;
3418246e:	4b0e      	ldr	r3, [pc, #56]	@ (341824a8 <USBD_Get_Device_Framework_Speed+0x70>)
34182470:	681b      	ldr	r3, [r3, #0]
34182472:	60fb      	str	r3, [r7, #12]
34182474:	e012      	b.n	3418249c <USBD_Get_Device_Framework_Speed+0x64>
  }
  else
  {
    USBD_Device_Framework_Builder(&USBD_Device_HS, pDevFrameWorkDesc_HS,
34182476:	4b0f      	ldr	r3, [pc, #60]	@ (341824b4 <USBD_Get_Device_Framework_Speed+0x7c>)
34182478:	6819      	ldr	r1, [r3, #0]
3418247a:	79fb      	ldrb	r3, [r7, #7]
3418247c:	4a0b      	ldr	r2, [pc, #44]	@ (341824ac <USBD_Get_Device_Framework_Speed+0x74>)
3418247e:	480e      	ldr	r0, [pc, #56]	@ (341824b8 <USBD_Get_Device_Framework_Speed+0x80>)
34182480:	f000 f960 	bl	34182744 <USBD_Device_Framework_Builder>
                                  UserClassInstance, Speed);

    /* Get the length of USBD_device_framework_high_speed */
    *Length = (ULONG)(USBD_Device_HS.CurrDevDescSz + USBD_Device_HS.CurrConfDescSz);
34182484:	4b0c      	ldr	r3, [pc, #48]	@ (341824b8 <USBD_Get_Device_Framework_Speed+0x80>)
34182486:	f8d3 2120 	ldr.w	r2, [r3, #288]	@ 0x120
3418248a:	4b0b      	ldr	r3, [pc, #44]	@ (341824b8 <USBD_Get_Device_Framework_Speed+0x80>)
3418248c:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
34182490:	441a      	add	r2, r3
34182492:	683b      	ldr	r3, [r7, #0]
34182494:	601a      	str	r2, [r3, #0]

    pFrameWork = pDevFrameWorkDesc_HS;
34182496:	4b07      	ldr	r3, [pc, #28]	@ (341824b4 <USBD_Get_Device_Framework_Speed+0x7c>)
34182498:	681b      	ldr	r3, [r3, #0]
3418249a:	60fb      	str	r3, [r7, #12]
  }
  /* USER CODE Device_Framework1 */

  /* USER CODE Device_Framework1 */
  return pFrameWork;
3418249c:	68fb      	ldr	r3, [r7, #12]
}
3418249e:	4618      	mov	r0, r3
341824a0:	3710      	adds	r7, #16
341824a2:	46bd      	mov	sp, r7
341824a4:	bd80      	pop	{r7, pc}
341824a6:	bf00      	nop
341824a8:	341c0010 	.word	0x341c0010
341824ac:	341c0004 	.word	0x341c0004
341824b0:	341c1d8c 	.word	0x341c1d8c
341824b4:	341c0014 	.word	0x341c0014
341824b8:	341c1eb4 	.word	0x341c1eb4

341824bc <USBD_Get_String_Framework>:
  *         Return the language_id_framework
  * @param  Length : Length of String_Framework
  * @retval Pointer to language_id_framework buffer
  */
uint8_t *USBD_Get_String_Framework(ULONG *Length)
{
341824bc:	b580      	push	{r7, lr}
341824be:	b084      	sub	sp, #16
341824c0:	af00      	add	r7, sp, #0
341824c2:	6078      	str	r0, [r7, #4]
  uint16_t len = 0U;
341824c4:	2300      	movs	r3, #0
341824c6:	81bb      	strh	r3, [r7, #12]
  uint8_t count = 0U;
341824c8:	2300      	movs	r3, #0
341824ca:	73fb      	strb	r3, [r7, #15]
  /* USER CODE String_Framework0 */

  /* USER CODE String_Framework0 */

  /* Set the Manufacturer language Id and index in USBD_string_framework */
  USBD_string_framework[count++] = USBD_LANGID_STRING & 0xFF;
341824cc:	7bfb      	ldrb	r3, [r7, #15]
341824ce:	1c5a      	adds	r2, r3, #1
341824d0:	73fa      	strb	r2, [r7, #15]
341824d2:	461a      	mov	r2, r3
341824d4:	4b37      	ldr	r3, [pc, #220]	@ (341825b4 <USBD_Get_String_Framework+0xf8>)
341824d6:	2109      	movs	r1, #9
341824d8:	5499      	strb	r1, [r3, r2]
  USBD_string_framework[count++] = USBD_LANGID_STRING >> 8;
341824da:	7bfb      	ldrb	r3, [r7, #15]
341824dc:	1c5a      	adds	r2, r3, #1
341824de:	73fa      	strb	r2, [r7, #15]
341824e0:	461a      	mov	r2, r3
341824e2:	4b34      	ldr	r3, [pc, #208]	@ (341825b4 <USBD_Get_String_Framework+0xf8>)
341824e4:	2104      	movs	r1, #4
341824e6:	5499      	strb	r1, [r3, r2]
  USBD_string_framework[count++] = USBD_IDX_MFC_STR;
341824e8:	7bfb      	ldrb	r3, [r7, #15]
341824ea:	1c5a      	adds	r2, r3, #1
341824ec:	73fa      	strb	r2, [r7, #15]
341824ee:	461a      	mov	r2, r3
341824f0:	4b30      	ldr	r3, [pc, #192]	@ (341825b4 <USBD_Get_String_Framework+0xf8>)
341824f2:	2101      	movs	r1, #1
341824f4:	5499      	strb	r1, [r3, r2]

  /* Set the Manufacturer string in string_framework */
  USBD_Desc_GetString((uint8_t *)USBD_MANUFACTURER_STRING, USBD_string_framework + count, &len);
341824f6:	7bfb      	ldrb	r3, [r7, #15]
341824f8:	4a2e      	ldr	r2, [pc, #184]	@ (341825b4 <USBD_Get_String_Framework+0xf8>)
341824fa:	4413      	add	r3, r2
341824fc:	f107 020c 	add.w	r2, r7, #12
34182500:	4619      	mov	r1, r3
34182502:	482d      	ldr	r0, [pc, #180]	@ (341825b8 <USBD_Get_String_Framework+0xfc>)
34182504:	f000 f8d0 	bl	341826a8 <USBD_Desc_GetString>

  /* Set the Product language Id and index in USBD_string_framework */
  count += len + 1;
34182508:	89bb      	ldrh	r3, [r7, #12]
3418250a:	b2da      	uxtb	r2, r3
3418250c:	7bfb      	ldrb	r3, [r7, #15]
3418250e:	4413      	add	r3, r2
34182510:	b2db      	uxtb	r3, r3
34182512:	3301      	adds	r3, #1
34182514:	73fb      	strb	r3, [r7, #15]
  USBD_string_framework[count++] = USBD_LANGID_STRING & 0xFF;
34182516:	7bfb      	ldrb	r3, [r7, #15]
34182518:	1c5a      	adds	r2, r3, #1
3418251a:	73fa      	strb	r2, [r7, #15]
3418251c:	461a      	mov	r2, r3
3418251e:	4b25      	ldr	r3, [pc, #148]	@ (341825b4 <USBD_Get_String_Framework+0xf8>)
34182520:	2109      	movs	r1, #9
34182522:	5499      	strb	r1, [r3, r2]
  USBD_string_framework[count++] = USBD_LANGID_STRING >> 8;
34182524:	7bfb      	ldrb	r3, [r7, #15]
34182526:	1c5a      	adds	r2, r3, #1
34182528:	73fa      	strb	r2, [r7, #15]
3418252a:	461a      	mov	r2, r3
3418252c:	4b21      	ldr	r3, [pc, #132]	@ (341825b4 <USBD_Get_String_Framework+0xf8>)
3418252e:	2104      	movs	r1, #4
34182530:	5499      	strb	r1, [r3, r2]
  USBD_string_framework[count++] = USBD_IDX_PRODUCT_STR;
34182532:	7bfb      	ldrb	r3, [r7, #15]
34182534:	1c5a      	adds	r2, r3, #1
34182536:	73fa      	strb	r2, [r7, #15]
34182538:	461a      	mov	r2, r3
3418253a:	4b1e      	ldr	r3, [pc, #120]	@ (341825b4 <USBD_Get_String_Framework+0xf8>)
3418253c:	2102      	movs	r1, #2
3418253e:	5499      	strb	r1, [r3, r2]

  /* Set the Product string in USBD_string_framework */
  USBD_Desc_GetString((uint8_t *)USBD_PRODUCT_STRING, USBD_string_framework + count, &len);
34182540:	7bfb      	ldrb	r3, [r7, #15]
34182542:	4a1c      	ldr	r2, [pc, #112]	@ (341825b4 <USBD_Get_String_Framework+0xf8>)
34182544:	4413      	add	r3, r2
34182546:	f107 020c 	add.w	r2, r7, #12
3418254a:	4619      	mov	r1, r3
3418254c:	481b      	ldr	r0, [pc, #108]	@ (341825bc <USBD_Get_String_Framework+0x100>)
3418254e:	f000 f8ab 	bl	341826a8 <USBD_Desc_GetString>

  /* Set Serial language Id and index in string_framework */
  count += len + 1;
34182552:	89bb      	ldrh	r3, [r7, #12]
34182554:	b2da      	uxtb	r2, r3
34182556:	7bfb      	ldrb	r3, [r7, #15]
34182558:	4413      	add	r3, r2
3418255a:	b2db      	uxtb	r3, r3
3418255c:	3301      	adds	r3, #1
3418255e:	73fb      	strb	r3, [r7, #15]
  USBD_string_framework[count++] = USBD_LANGID_STRING & 0xFF;
34182560:	7bfb      	ldrb	r3, [r7, #15]
34182562:	1c5a      	adds	r2, r3, #1
34182564:	73fa      	strb	r2, [r7, #15]
34182566:	461a      	mov	r2, r3
34182568:	4b12      	ldr	r3, [pc, #72]	@ (341825b4 <USBD_Get_String_Framework+0xf8>)
3418256a:	2109      	movs	r1, #9
3418256c:	5499      	strb	r1, [r3, r2]
  USBD_string_framework[count++] = USBD_LANGID_STRING >> 8;
3418256e:	7bfb      	ldrb	r3, [r7, #15]
34182570:	1c5a      	adds	r2, r3, #1
34182572:	73fa      	strb	r2, [r7, #15]
34182574:	461a      	mov	r2, r3
34182576:	4b0f      	ldr	r3, [pc, #60]	@ (341825b4 <USBD_Get_String_Framework+0xf8>)
34182578:	2104      	movs	r1, #4
3418257a:	5499      	strb	r1, [r3, r2]
  USBD_string_framework[count++] = USBD_IDX_SERIAL_STR;
3418257c:	7bfb      	ldrb	r3, [r7, #15]
3418257e:	1c5a      	adds	r2, r3, #1
34182580:	73fa      	strb	r2, [r7, #15]
34182582:	461a      	mov	r2, r3
34182584:	4b0b      	ldr	r3, [pc, #44]	@ (341825b4 <USBD_Get_String_Framework+0xf8>)
34182586:	2103      	movs	r1, #3
34182588:	5499      	strb	r1, [r3, r2]

  /* Set the Serial number in USBD_string_framework */
  USBD_Desc_GetString((uint8_t *)USBD_SERIAL_NUMBER, USBD_string_framework + count, &len);
3418258a:	7bfb      	ldrb	r3, [r7, #15]
3418258c:	4a09      	ldr	r2, [pc, #36]	@ (341825b4 <USBD_Get_String_Framework+0xf8>)
3418258e:	4413      	add	r3, r2
34182590:	f107 020c 	add.w	r2, r7, #12
34182594:	4619      	mov	r1, r3
34182596:	480a      	ldr	r0, [pc, #40]	@ (341825c0 <USBD_Get_String_Framework+0x104>)
34182598:	f000 f886 	bl	341826a8 <USBD_Desc_GetString>
  /* USER CODE String_Framework1 */

  /* USER CODE String_Framework1 */

  /* Get the length of USBD_string_framework */
  *Length = strlen((const char *)USBD_string_framework);
3418259c:	4805      	ldr	r0, [pc, #20]	@ (341825b4 <USBD_Get_String_Framework+0xf8>)
3418259e:	f7fe fb1f 	bl	34180be0 <strlen>
341825a2:	4602      	mov	r2, r0
341825a4:	687b      	ldr	r3, [r7, #4]
341825a6:	601a      	str	r2, [r3, #0]

  return USBD_string_framework;
341825a8:	4b02      	ldr	r3, [pc, #8]	@ (341825b4 <USBD_Get_String_Framework+0xf8>)
}
341825aa:	4618      	mov	r0, r3
341825ac:	3710      	adds	r7, #16
341825ae:	46bd      	mov	sp, r7
341825b0:	bd80      	pop	{r7, pc}
341825b2:	bf00      	nop
341825b4:	341c216c 	.word	0x341c216c
341825b8:	3419e2b4 	.word	0x3419e2b4
341825bc:	3419e2c8 	.word	0x3419e2c8
341825c0:	3419e2e0 	.word	0x3419e2e0

341825c4 <USBD_Get_Language_Id_Framework>:
  *         Return the language_id_framework
  * @param  Length : Length of Language_Id_Framework
  * @retval Pointer to language_id_framework buffer
  */
uint8_t *USBD_Get_Language_Id_Framework(ULONG *Length)
{
341825c4:	b580      	push	{r7, lr}
341825c6:	b084      	sub	sp, #16
341825c8:	af00      	add	r7, sp, #0
341825ca:	6078      	str	r0, [r7, #4]
  uint8_t count = 0U;
341825cc:	2300      	movs	r3, #0
341825ce:	73fb      	strb	r3, [r7, #15]

  /* Set the language Id in USBD_language_id_framework */
  USBD_language_id_framework[count++] = USBD_LANGID_STRING & 0xFF;
341825d0:	7bfb      	ldrb	r3, [r7, #15]
341825d2:	1c5a      	adds	r2, r3, #1
341825d4:	73fa      	strb	r2, [r7, #15]
341825d6:	461a      	mov	r2, r3
341825d8:	4b0a      	ldr	r3, [pc, #40]	@ (34182604 <USBD_Get_Language_Id_Framework+0x40>)
341825da:	2109      	movs	r1, #9
341825dc:	5499      	strb	r1, [r3, r2]
  USBD_language_id_framework[count++] = USBD_LANGID_STRING >> 8;
341825de:	7bfb      	ldrb	r3, [r7, #15]
341825e0:	1c5a      	adds	r2, r3, #1
341825e2:	73fa      	strb	r2, [r7, #15]
341825e4:	461a      	mov	r2, r3
341825e6:	4b07      	ldr	r3, [pc, #28]	@ (34182604 <USBD_Get_Language_Id_Framework+0x40>)
341825e8:	2104      	movs	r1, #4
341825ea:	5499      	strb	r1, [r3, r2]

  /* Get the length of USBD_language_id_framework */
  *Length = strlen((const char *)USBD_language_id_framework);
341825ec:	4805      	ldr	r0, [pc, #20]	@ (34182604 <USBD_Get_Language_Id_Framework+0x40>)
341825ee:	f7fe faf7 	bl	34180be0 <strlen>
341825f2:	4602      	mov	r2, r0
341825f4:	687b      	ldr	r3, [r7, #4]
341825f6:	601a      	str	r2, [r3, #0]

  return USBD_language_id_framework;
341825f8:	4b02      	ldr	r3, [pc, #8]	@ (34182604 <USBD_Get_Language_Id_Framework+0x40>)
}
341825fa:	4618      	mov	r0, r3
341825fc:	3710      	adds	r7, #16
341825fe:	46bd      	mov	sp, r7
34182600:	bd80      	pop	{r7, pc}
34182602:	bf00      	nop
34182604:	341c226c 	.word	0x341c226c

34182608 <USBD_Get_Interface_Number>:
  * @param  class_type : Device class type
  * @param  interface_type : Device interface type
  * @retval interface number
  */
uint16_t USBD_Get_Interface_Number(uint8_t class_type, uint8_t interface_type)
{
34182608:	b480      	push	{r7}
3418260a:	b085      	sub	sp, #20
3418260c:	af00      	add	r7, sp, #0
3418260e:	4603      	mov	r3, r0
34182610:	460a      	mov	r2, r1
34182612:	71fb      	strb	r3, [r7, #7]
34182614:	4613      	mov	r3, r2
34182616:	71bb      	strb	r3, [r7, #6]
  uint8_t itf_num = 0U;
34182618:	2300      	movs	r3, #0
3418261a:	73fb      	strb	r3, [r7, #15]
  uint8_t idx = 0U;
3418261c:	2300      	movs	r3, #0
3418261e:	73bb      	strb	r3, [r7, #14]

  /* USER CODE BEGIN USBD_Get_Interface_Number0 */

  /* USER CODE BEGIN USBD_Get_Interface_Number0 */

  for(idx = 0; idx < USBD_MAX_SUPPORTED_CLASS; idx++)
34182620:	2300      	movs	r3, #0
34182622:	73bb      	strb	r3, [r7, #14]
34182624:	e021      	b.n	3418266a <USBD_Get_Interface_Number+0x62>
  {
    if ((USBD_Device_FS.tclasslist[idx].ClassType == class_type) &&
34182626:	7bbb      	ldrb	r3, [r7, #14]
34182628:	4a15      	ldr	r2, [pc, #84]	@ (34182680 <USBD_Get_Interface_Number+0x78>)
3418262a:	215c      	movs	r1, #92	@ 0x5c
3418262c:	fb01 f303 	mul.w	r3, r1, r3
34182630:	4413      	add	r3, r2
34182632:	330c      	adds	r3, #12
34182634:	781b      	ldrb	r3, [r3, #0]
34182636:	79fa      	ldrb	r2, [r7, #7]
34182638:	429a      	cmp	r2, r3
3418263a:	d113      	bne.n	34182664 <USBD_Get_Interface_Number+0x5c>
        (USBD_Device_FS.tclasslist[idx].InterfaceType == interface_type))
3418263c:	7bbb      	ldrb	r3, [r7, #14]
3418263e:	4a10      	ldr	r2, [pc, #64]	@ (34182680 <USBD_Get_Interface_Number+0x78>)
34182640:	215c      	movs	r1, #92	@ 0x5c
34182642:	fb01 f303 	mul.w	r3, r1, r3
34182646:	4413      	add	r3, r2
34182648:	3314      	adds	r3, #20
3418264a:	781b      	ldrb	r3, [r3, #0]
    if ((USBD_Device_FS.tclasslist[idx].ClassType == class_type) &&
3418264c:	79ba      	ldrb	r2, [r7, #6]
3418264e:	429a      	cmp	r2, r3
34182650:	d108      	bne.n	34182664 <USBD_Get_Interface_Number+0x5c>
    {
      itf_num = USBD_Device_FS.tclasslist[idx].Ifs[0];
34182652:	7bbb      	ldrb	r3, [r7, #14]
34182654:	4a0a      	ldr	r2, [pc, #40]	@ (34182680 <USBD_Get_Interface_Number+0x78>)
34182656:	215c      	movs	r1, #92	@ 0x5c
34182658:	fb01 f303 	mul.w	r3, r1, r3
3418265c:	4413      	add	r3, r2
3418265e:	335a      	adds	r3, #90	@ 0x5a
34182660:	781b      	ldrb	r3, [r3, #0]
34182662:	73fb      	strb	r3, [r7, #15]
  for(idx = 0; idx < USBD_MAX_SUPPORTED_CLASS; idx++)
34182664:	7bbb      	ldrb	r3, [r7, #14]
34182666:	3301      	adds	r3, #1
34182668:	73bb      	strb	r3, [r7, #14]
3418266a:	7bbb      	ldrb	r3, [r7, #14]
3418266c:	2b02      	cmp	r3, #2
3418266e:	d9da      	bls.n	34182626 <USBD_Get_Interface_Number+0x1e>

  /* USER CODE BEGIN USBD_Get_Interface_Number1 */

  /* USER CODE BEGIN USBD_Get_Interface_Number1 */

  return itf_num;
34182670:	7bfb      	ldrb	r3, [r7, #15]
34182672:	b29b      	uxth	r3, r3
}
34182674:	4618      	mov	r0, r3
34182676:	3714      	adds	r7, #20
34182678:	46bd      	mov	sp, r7
3418267a:	f85d 7b04 	ldr.w	r7, [sp], #4
3418267e:	4770      	bx	lr
34182680:	341c1d8c 	.word	0x341c1d8c

34182684 <USBD_Get_Configuration_Number>:
  * @param  class_type : Device class type
  * @param  interface_type : Device interface type
  * @retval configuration number
  */
uint16_t USBD_Get_Configuration_Number(uint8_t class_type, uint8_t interface_type)
{
34182684:	b480      	push	{r7}
34182686:	b085      	sub	sp, #20
34182688:	af00      	add	r7, sp, #0
3418268a:	4603      	mov	r3, r0
3418268c:	460a      	mov	r2, r1
3418268e:	71fb      	strb	r3, [r7, #7]
34182690:	4613      	mov	r3, r2
34182692:	71bb      	strb	r3, [r7, #6]
  uint8_t cfg_num = 1U;
34182694:	2301      	movs	r3, #1
34182696:	73fb      	strb	r3, [r7, #15]

  /* USER CODE BEGIN USBD_Get_CONFIGURATION_Number1 */

  /* USER CODE BEGIN USBD_Get_CONFIGURATION_Number1 */

  return cfg_num;
34182698:	7bfb      	ldrb	r3, [r7, #15]
3418269a:	b29b      	uxth	r3, r3
}
3418269c:	4618      	mov	r0, r3
3418269e:	3714      	adds	r7, #20
341826a0:	46bd      	mov	sp, r7
341826a2:	f85d 7b04 	ldr.w	r7, [sp], #4
341826a6:	4770      	bx	lr

341826a8 <USBD_Desc_GetString>:
  * @param  Unicode : Formatted string buffer (Unicode)
  * @param  len : descriptor length
  * @retval None
  */
static void USBD_Desc_GetString(uint8_t *desc, uint8_t *unicode, uint16_t *len)
{
341826a8:	b580      	push	{r7, lr}
341826aa:	b086      	sub	sp, #24
341826ac:	af00      	add	r7, sp, #0
341826ae:	60f8      	str	r0, [r7, #12]
341826b0:	60b9      	str	r1, [r7, #8]
341826b2:	607a      	str	r2, [r7, #4]
  uint8_t idx = 0U;
341826b4:	2300      	movs	r3, #0
341826b6:	75fb      	strb	r3, [r7, #23]
  uint8_t *pdesc;

  if (desc == NULL)
341826b8:	68fb      	ldr	r3, [r7, #12]
341826ba:	2b00      	cmp	r3, #0
341826bc:	d023      	beq.n	34182706 <USBD_Desc_GetString+0x5e>
  {
    return;
  }

  pdesc = desc;
341826be:	68fb      	ldr	r3, [r7, #12]
341826c0:	613b      	str	r3, [r7, #16]
  *len = (uint16_t)USBD_Desc_GetLen(pdesc);
341826c2:	6938      	ldr	r0, [r7, #16]
341826c4:	f000 f823 	bl	3418270e <USBD_Desc_GetLen>
341826c8:	4603      	mov	r3, r0
341826ca:	461a      	mov	r2, r3
341826cc:	687b      	ldr	r3, [r7, #4]
341826ce:	801a      	strh	r2, [r3, #0]

  unicode[idx++] = *(uint8_t *)len;
341826d0:	7dfb      	ldrb	r3, [r7, #23]
341826d2:	1c5a      	adds	r2, r3, #1
341826d4:	75fa      	strb	r2, [r7, #23]
341826d6:	461a      	mov	r2, r3
341826d8:	68bb      	ldr	r3, [r7, #8]
341826da:	4413      	add	r3, r2
341826dc:	687a      	ldr	r2, [r7, #4]
341826de:	7812      	ldrb	r2, [r2, #0]
341826e0:	701a      	strb	r2, [r3, #0]

  while (*pdesc != (uint8_t)'\0')
341826e2:	e00b      	b.n	341826fc <USBD_Desc_GetString+0x54>
  {
    unicode[idx++] = *pdesc;
341826e4:	7dfb      	ldrb	r3, [r7, #23]
341826e6:	1c5a      	adds	r2, r3, #1
341826e8:	75fa      	strb	r2, [r7, #23]
341826ea:	461a      	mov	r2, r3
341826ec:	68bb      	ldr	r3, [r7, #8]
341826ee:	4413      	add	r3, r2
341826f0:	693a      	ldr	r2, [r7, #16]
341826f2:	7812      	ldrb	r2, [r2, #0]
341826f4:	701a      	strb	r2, [r3, #0]
    pdesc++;
341826f6:	693b      	ldr	r3, [r7, #16]
341826f8:	3301      	adds	r3, #1
341826fa:	613b      	str	r3, [r7, #16]
  while (*pdesc != (uint8_t)'\0')
341826fc:	693b      	ldr	r3, [r7, #16]
341826fe:	781b      	ldrb	r3, [r3, #0]
34182700:	2b00      	cmp	r3, #0
34182702:	d1ef      	bne.n	341826e4 <USBD_Desc_GetString+0x3c>
34182704:	e000      	b.n	34182708 <USBD_Desc_GetString+0x60>
    return;
34182706:	bf00      	nop
  }
}
34182708:	3718      	adds	r7, #24
3418270a:	46bd      	mov	sp, r7
3418270c:	bd80      	pop	{r7, pc}

3418270e <USBD_Desc_GetLen>:
  *         return the string length
  * @param  buf : pointer to the ASCII string buffer
  * @retval string length
  */
static uint8_t USBD_Desc_GetLen(uint8_t *buf)
{
3418270e:	b480      	push	{r7}
34182710:	b085      	sub	sp, #20
34182712:	af00      	add	r7, sp, #0
34182714:	6078      	str	r0, [r7, #4]
  uint8_t  len = 0U;
34182716:	2300      	movs	r3, #0
34182718:	73fb      	strb	r3, [r7, #15]
  uint8_t *pbuff = buf;
3418271a:	687b      	ldr	r3, [r7, #4]
3418271c:	60bb      	str	r3, [r7, #8]

  while (*pbuff != (uint8_t)'\0')
3418271e:	e005      	b.n	3418272c <USBD_Desc_GetLen+0x1e>
  {
    len++;
34182720:	7bfb      	ldrb	r3, [r7, #15]
34182722:	3301      	adds	r3, #1
34182724:	73fb      	strb	r3, [r7, #15]
    pbuff++;
34182726:	68bb      	ldr	r3, [r7, #8]
34182728:	3301      	adds	r3, #1
3418272a:	60bb      	str	r3, [r7, #8]
  while (*pbuff != (uint8_t)'\0')
3418272c:	68bb      	ldr	r3, [r7, #8]
3418272e:	781b      	ldrb	r3, [r3, #0]
34182730:	2b00      	cmp	r3, #0
34182732:	d1f5      	bne.n	34182720 <USBD_Desc_GetLen+0x12>
  }

  return len;
34182734:	7bfb      	ldrb	r3, [r7, #15]
}
34182736:	4618      	mov	r0, r3
34182738:	3714      	adds	r7, #20
3418273a:	46bd      	mov	sp, r7
3418273c:	f85d 7b04 	ldr.w	r7, [sp], #4
34182740:	4770      	bx	lr
	...

34182744 <USBD_Device_Framework_Builder>:
  */
static uint8_t *USBD_Device_Framework_Builder(USBD_DevClassHandleTypeDef *pdev,
                                              uint8_t *pDevFrameWorkDesc,
                                              uint8_t *UserClassInstance,
                                              uint8_t Speed)
{
34182744:	b580      	push	{r7, lr}
34182746:	b088      	sub	sp, #32
34182748:	af02      	add	r7, sp, #8
3418274a:	60f8      	str	r0, [r7, #12]
3418274c:	60b9      	str	r1, [r7, #8]
3418274e:	607a      	str	r2, [r7, #4]
34182750:	70fb      	strb	r3, [r7, #3]
  static USBD_DeviceDescTypedef   *pDevDesc;
  static USBD_DevQualiDescTypedef *pDevQualDesc;
  uint8_t Idx_Instance = 0U;
34182752:	2300      	movs	r3, #0
34182754:	75fb      	strb	r3, [r7, #23]

  /* Set Dev and conf descriptors size to 0 */
  pdev->CurrConfDescSz = 0U;
34182756:	68fb      	ldr	r3, [r7, #12]
34182758:	2200      	movs	r2, #0
3418275a:	f8c3 2124 	str.w	r2, [r3, #292]	@ 0x124
  pdev->CurrDevDescSz = 0U;
3418275e:	68fb      	ldr	r3, [r7, #12]
34182760:	2200      	movs	r2, #0
34182762:	f8c3 2120 	str.w	r2, [r3, #288]	@ 0x120

  /* Set the pointer to the device descriptor area*/
  pDevDesc = (USBD_DeviceDescTypedef *)pDevFrameWorkDesc;
34182766:	4a73      	ldr	r2, [pc, #460]	@ (34182934 <USBD_Device_Framework_Builder+0x1f0>)
34182768:	68bb      	ldr	r3, [r7, #8]
3418276a:	6013      	str	r3, [r2, #0]

  /* Start building the generic device descriptor common part */
  pDevDesc->bLength = (uint8_t)sizeof(USBD_DeviceDescTypedef);
3418276c:	4b71      	ldr	r3, [pc, #452]	@ (34182934 <USBD_Device_Framework_Builder+0x1f0>)
3418276e:	681b      	ldr	r3, [r3, #0]
34182770:	2212      	movs	r2, #18
34182772:	701a      	strb	r2, [r3, #0]
  pDevDesc->bDescriptorType = UX_DEVICE_DESCRIPTOR_ITEM;
34182774:	4b6f      	ldr	r3, [pc, #444]	@ (34182934 <USBD_Device_Framework_Builder+0x1f0>)
34182776:	681b      	ldr	r3, [r3, #0]
34182778:	2201      	movs	r2, #1
3418277a:	705a      	strb	r2, [r3, #1]
  pDevDesc->bcdUSB = USB_BCDUSB;
3418277c:	4b6d      	ldr	r3, [pc, #436]	@ (34182934 <USBD_Device_Framework_Builder+0x1f0>)
3418277e:	681b      	ldr	r3, [r3, #0]
34182780:	2200      	movs	r2, #0
34182782:	709a      	strb	r2, [r3, #2]
34182784:	2200      	movs	r2, #0
34182786:	f042 0202 	orr.w	r2, r2, #2
3418278a:	70da      	strb	r2, [r3, #3]
  pDevDesc->bDeviceClass = 0x00;
3418278c:	4b69      	ldr	r3, [pc, #420]	@ (34182934 <USBD_Device_Framework_Builder+0x1f0>)
3418278e:	681b      	ldr	r3, [r3, #0]
34182790:	2200      	movs	r2, #0
34182792:	711a      	strb	r2, [r3, #4]
  pDevDesc->bDeviceSubClass = 0x00;
34182794:	4b67      	ldr	r3, [pc, #412]	@ (34182934 <USBD_Device_Framework_Builder+0x1f0>)
34182796:	681b      	ldr	r3, [r3, #0]
34182798:	2200      	movs	r2, #0
3418279a:	715a      	strb	r2, [r3, #5]
  pDevDesc->bDeviceProtocol = 0x00;
3418279c:	4b65      	ldr	r3, [pc, #404]	@ (34182934 <USBD_Device_Framework_Builder+0x1f0>)
3418279e:	681b      	ldr	r3, [r3, #0]
341827a0:	2200      	movs	r2, #0
341827a2:	719a      	strb	r2, [r3, #6]
  pDevDesc->bMaxPacketSize = USBD_MAX_EP0_SIZE;
341827a4:	4b63      	ldr	r3, [pc, #396]	@ (34182934 <USBD_Device_Framework_Builder+0x1f0>)
341827a6:	681b      	ldr	r3, [r3, #0]
341827a8:	2240      	movs	r2, #64	@ 0x40
341827aa:	71da      	strb	r2, [r3, #7]
  pDevDesc->idVendor = USBD_VID;
341827ac:	4b61      	ldr	r3, [pc, #388]	@ (34182934 <USBD_Device_Framework_Builder+0x1f0>)
341827ae:	681b      	ldr	r3, [r3, #0]
341827b0:	2200      	movs	r2, #0
341827b2:	f062 027c 	orn	r2, r2, #124	@ 0x7c
341827b6:	721a      	strb	r2, [r3, #8]
341827b8:	2200      	movs	r2, #0
341827ba:	f042 0204 	orr.w	r2, r2, #4
341827be:	725a      	strb	r2, [r3, #9]
  pDevDesc->idProduct = USBD_PID;
341827c0:	4b5c      	ldr	r3, [pc, #368]	@ (34182934 <USBD_Device_Framework_Builder+0x1f0>)
341827c2:	681b      	ldr	r3, [r3, #0]
341827c4:	2200      	movs	r2, #0
341827c6:	f042 0220 	orr.w	r2, r2, #32
341827ca:	729a      	strb	r2, [r3, #10]
341827cc:	2200      	movs	r2, #0
341827ce:	f042 0257 	orr.w	r2, r2, #87	@ 0x57
341827d2:	72da      	strb	r2, [r3, #11]
  pDevDesc->bcdDevice = 0x0200;
341827d4:	4b57      	ldr	r3, [pc, #348]	@ (34182934 <USBD_Device_Framework_Builder+0x1f0>)
341827d6:	681b      	ldr	r3, [r3, #0]
341827d8:	2200      	movs	r2, #0
341827da:	731a      	strb	r2, [r3, #12]
341827dc:	2200      	movs	r2, #0
341827de:	f042 0202 	orr.w	r2, r2, #2
341827e2:	735a      	strb	r2, [r3, #13]
  pDevDesc->iManufacturer = USBD_IDX_MFC_STR;
341827e4:	4b53      	ldr	r3, [pc, #332]	@ (34182934 <USBD_Device_Framework_Builder+0x1f0>)
341827e6:	681b      	ldr	r3, [r3, #0]
341827e8:	2201      	movs	r2, #1
341827ea:	739a      	strb	r2, [r3, #14]
  pDevDesc->iProduct = USBD_IDX_PRODUCT_STR;
341827ec:	4b51      	ldr	r3, [pc, #324]	@ (34182934 <USBD_Device_Framework_Builder+0x1f0>)
341827ee:	681b      	ldr	r3, [r3, #0]
341827f0:	2202      	movs	r2, #2
341827f2:	73da      	strb	r2, [r3, #15]
  pDevDesc->iSerialNumber = USBD_IDX_SERIAL_STR;
341827f4:	4b4f      	ldr	r3, [pc, #316]	@ (34182934 <USBD_Device_Framework_Builder+0x1f0>)
341827f6:	681b      	ldr	r3, [r3, #0]
341827f8:	2203      	movs	r2, #3
341827fa:	741a      	strb	r2, [r3, #16]
  pDevDesc->bNumConfigurations = USBD_MAX_NUM_CONFIGURATION;
341827fc:	4b4d      	ldr	r3, [pc, #308]	@ (34182934 <USBD_Device_Framework_Builder+0x1f0>)
341827fe:	681b      	ldr	r3, [r3, #0]
34182800:	2201      	movs	r2, #1
34182802:	745a      	strb	r2, [r3, #17]
  pdev->CurrDevDescSz += (uint32_t)sizeof(USBD_DeviceDescTypedef);
34182804:	68fb      	ldr	r3, [r7, #12]
34182806:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
3418280a:	f103 0212 	add.w	r2, r3, #18
3418280e:	68fb      	ldr	r3, [r7, #12]
34182810:	f8c3 2120 	str.w	r2, [r3, #288]	@ 0x120

  /* Check if USBx is in high speed mode to add qualifier descriptor */
  if (Speed == USBD_HIGH_SPEED)
34182814:	78fb      	ldrb	r3, [r7, #3]
34182816:	2b01      	cmp	r3, #1
34182818:	d162      	bne.n	341828e0 <USBD_Device_Framework_Builder+0x19c>
  {
    pDevQualDesc = (USBD_DevQualiDescTypedef *)(pDevFrameWorkDesc + pdev->CurrDevDescSz);
3418281a:	68fb      	ldr	r3, [r7, #12]
3418281c:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
34182820:	68ba      	ldr	r2, [r7, #8]
34182822:	4413      	add	r3, r2
34182824:	4a44      	ldr	r2, [pc, #272]	@ (34182938 <USBD_Device_Framework_Builder+0x1f4>)
34182826:	6013      	str	r3, [r2, #0]
    pDevQualDesc->bLength = (uint8_t)sizeof(USBD_DevQualiDescTypedef);
34182828:	4b43      	ldr	r3, [pc, #268]	@ (34182938 <USBD_Device_Framework_Builder+0x1f4>)
3418282a:	681b      	ldr	r3, [r3, #0]
3418282c:	220a      	movs	r2, #10
3418282e:	701a      	strb	r2, [r3, #0]
    pDevQualDesc->bDescriptorType = UX_DEVICE_QUALIFIER_DESCRIPTOR_ITEM;
34182830:	4b41      	ldr	r3, [pc, #260]	@ (34182938 <USBD_Device_Framework_Builder+0x1f4>)
34182832:	681b      	ldr	r3, [r3, #0]
34182834:	2206      	movs	r2, #6
34182836:	705a      	strb	r2, [r3, #1]
    pDevQualDesc->bcdDevice = 0x0200;
34182838:	4b3f      	ldr	r3, [pc, #252]	@ (34182938 <USBD_Device_Framework_Builder+0x1f4>)
3418283a:	681b      	ldr	r3, [r3, #0]
3418283c:	2200      	movs	r2, #0
3418283e:	709a      	strb	r2, [r3, #2]
34182840:	2200      	movs	r2, #0
34182842:	f042 0202 	orr.w	r2, r2, #2
34182846:	70da      	strb	r2, [r3, #3]
    pDevQualDesc->Class = 0x00;
34182848:	4b3b      	ldr	r3, [pc, #236]	@ (34182938 <USBD_Device_Framework_Builder+0x1f4>)
3418284a:	681b      	ldr	r3, [r3, #0]
3418284c:	2200      	movs	r2, #0
3418284e:	711a      	strb	r2, [r3, #4]
    pDevQualDesc->SubClass = 0x00;
34182850:	4b39      	ldr	r3, [pc, #228]	@ (34182938 <USBD_Device_Framework_Builder+0x1f4>)
34182852:	681b      	ldr	r3, [r3, #0]
34182854:	2200      	movs	r2, #0
34182856:	715a      	strb	r2, [r3, #5]
    pDevQualDesc->Protocol = 0x00;
34182858:	4b37      	ldr	r3, [pc, #220]	@ (34182938 <USBD_Device_Framework_Builder+0x1f4>)
3418285a:	681b      	ldr	r3, [r3, #0]
3418285c:	2200      	movs	r2, #0
3418285e:	719a      	strb	r2, [r3, #6]
    pDevQualDesc->bMaxPacketSize = 0x40;
34182860:	4b35      	ldr	r3, [pc, #212]	@ (34182938 <USBD_Device_Framework_Builder+0x1f4>)
34182862:	681b      	ldr	r3, [r3, #0]
34182864:	2240      	movs	r2, #64	@ 0x40
34182866:	71da      	strb	r2, [r3, #7]
    pDevQualDesc->bNumConfigurations = 0x01;
34182868:	4b33      	ldr	r3, [pc, #204]	@ (34182938 <USBD_Device_Framework_Builder+0x1f4>)
3418286a:	681b      	ldr	r3, [r3, #0]
3418286c:	2201      	movs	r2, #1
3418286e:	721a      	strb	r2, [r3, #8]
    pDevQualDesc->bReserved = 0x00;
34182870:	4b31      	ldr	r3, [pc, #196]	@ (34182938 <USBD_Device_Framework_Builder+0x1f4>)
34182872:	681b      	ldr	r3, [r3, #0]
34182874:	2200      	movs	r2, #0
34182876:	725a      	strb	r2, [r3, #9]
    pdev->CurrDevDescSz += (uint32_t)sizeof(USBD_DevQualiDescTypedef);
34182878:	68fb      	ldr	r3, [r7, #12]
3418287a:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
3418287e:	f103 020a 	add.w	r2, r3, #10
34182882:	68fb      	ldr	r3, [r7, #12]
34182884:	f8c3 2120 	str.w	r2, [r3, #288]	@ 0x120
  }

  /* Build the device framework */
  while (Idx_Instance < USBD_MAX_SUPPORTED_CLASS)
34182888:	e02a      	b.n	341828e0 <USBD_Device_Framework_Builder+0x19c>
  {
    if ((pdev->classId < USBD_MAX_SUPPORTED_CLASS) &&
3418288a:	68fb      	ldr	r3, [r7, #12]
3418288c:	685b      	ldr	r3, [r3, #4]
3418288e:	2b02      	cmp	r3, #2
34182890:	d823      	bhi.n	341828da <USBD_Device_Framework_Builder+0x196>
        (pdev->NumClasses < USBD_MAX_SUPPORTED_CLASS) &&
34182892:	68fb      	ldr	r3, [r7, #12]
34182894:	689b      	ldr	r3, [r3, #8]
    if ((pdev->classId < USBD_MAX_SUPPORTED_CLASS) &&
34182896:	2b02      	cmp	r3, #2
34182898:	d81f      	bhi.n	341828da <USBD_Device_Framework_Builder+0x196>
        (UserClassInstance[Idx_Instance] != CLASS_TYPE_NONE))
3418289a:	7dfb      	ldrb	r3, [r7, #23]
3418289c:	687a      	ldr	r2, [r7, #4]
3418289e:	4413      	add	r3, r2
341828a0:	781b      	ldrb	r3, [r3, #0]
        (pdev->NumClasses < USBD_MAX_SUPPORTED_CLASS) &&
341828a2:	2b00      	cmp	r3, #0
341828a4:	d019      	beq.n	341828da <USBD_Device_Framework_Builder+0x196>
    {
      /* Call the composite class builder */
      (void)USBD_FrameWork_AddClass(pdev,
                                    (USBD_CompositeClassTypeDef)UserClassInstance[Idx_Instance],
341828a6:	7dfb      	ldrb	r3, [r7, #23]
341828a8:	687a      	ldr	r2, [r7, #4]
341828aa:	4413      	add	r3, r2
      (void)USBD_FrameWork_AddClass(pdev,
341828ac:	7819      	ldrb	r1, [r3, #0]
                                    0, Speed,
                                    (pDevFrameWorkDesc + pdev->CurrDevDescSz));
341828ae:	68fb      	ldr	r3, [r7, #12]
341828b0:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
      (void)USBD_FrameWork_AddClass(pdev,
341828b4:	68ba      	ldr	r2, [r7, #8]
341828b6:	4413      	add	r3, r2
341828b8:	78fa      	ldrb	r2, [r7, #3]
341828ba:	9300      	str	r3, [sp, #0]
341828bc:	4613      	mov	r3, r2
341828be:	2200      	movs	r2, #0
341828c0:	68f8      	ldr	r0, [r7, #12]
341828c2:	f000 f83b 	bl	3418293c <USBD_FrameWork_AddClass>

      /* Increment the ClassId for the next occurrence */
      pdev->classId ++;
341828c6:	68fb      	ldr	r3, [r7, #12]
341828c8:	685b      	ldr	r3, [r3, #4]
341828ca:	1c5a      	adds	r2, r3, #1
341828cc:	68fb      	ldr	r3, [r7, #12]
341828ce:	605a      	str	r2, [r3, #4]
      pdev->NumClasses ++;
341828d0:	68fb      	ldr	r3, [r7, #12]
341828d2:	689b      	ldr	r3, [r3, #8]
341828d4:	1c5a      	adds	r2, r3, #1
341828d6:	68fb      	ldr	r3, [r7, #12]
341828d8:	609a      	str	r2, [r3, #8]
    }

    Idx_Instance++;
341828da:	7dfb      	ldrb	r3, [r7, #23]
341828dc:	3301      	adds	r3, #1
341828de:	75fb      	strb	r3, [r7, #23]
  while (Idx_Instance < USBD_MAX_SUPPORTED_CLASS)
341828e0:	7dfb      	ldrb	r3, [r7, #23]
341828e2:	2b02      	cmp	r3, #2
341828e4:	d9d1      	bls.n	3418288a <USBD_Device_Framework_Builder+0x146>
  }

  /* Check if there is a composite class and update device class */
  if (pdev->NumClasses > 1)
341828e6:	68fb      	ldr	r3, [r7, #12]
341828e8:	689b      	ldr	r3, [r3, #8]
341828ea:	2b01      	cmp	r3, #1
341828ec:	d90c      	bls.n	34182908 <USBD_Device_Framework_Builder+0x1c4>
  {
    pDevDesc->bDeviceClass = 0xEF;
341828ee:	4b11      	ldr	r3, [pc, #68]	@ (34182934 <USBD_Device_Framework_Builder+0x1f0>)
341828f0:	681b      	ldr	r3, [r3, #0]
341828f2:	22ef      	movs	r2, #239	@ 0xef
341828f4:	711a      	strb	r2, [r3, #4]
    pDevDesc->bDeviceSubClass = 0x02;
341828f6:	4b0f      	ldr	r3, [pc, #60]	@ (34182934 <USBD_Device_Framework_Builder+0x1f0>)
341828f8:	681b      	ldr	r3, [r3, #0]
341828fa:	2202      	movs	r2, #2
341828fc:	715a      	strb	r2, [r3, #5]
    pDevDesc->bDeviceProtocol = 0x01;
341828fe:	4b0d      	ldr	r3, [pc, #52]	@ (34182934 <USBD_Device_Framework_Builder+0x1f0>)
34182900:	681b      	ldr	r3, [r3, #0]
34182902:	2201      	movs	r2, #1
34182904:	719a      	strb	r2, [r3, #6]
34182906:	e00f      	b.n	34182928 <USBD_Device_Framework_Builder+0x1e4>
  }
  else
  {
    /* Check if the CDC ACM class is set and update device class */
    if (UserClassInstance[0] == CLASS_TYPE_CDC_ACM)
34182908:	687b      	ldr	r3, [r7, #4]
3418290a:	781b      	ldrb	r3, [r3, #0]
3418290c:	2b02      	cmp	r3, #2
3418290e:	d10b      	bne.n	34182928 <USBD_Device_Framework_Builder+0x1e4>
    {
      pDevDesc->bDeviceClass = 0x02;
34182910:	4b08      	ldr	r3, [pc, #32]	@ (34182934 <USBD_Device_Framework_Builder+0x1f0>)
34182912:	681b      	ldr	r3, [r3, #0]
34182914:	2202      	movs	r2, #2
34182916:	711a      	strb	r2, [r3, #4]
      pDevDesc->bDeviceSubClass = 0x02;
34182918:	4b06      	ldr	r3, [pc, #24]	@ (34182934 <USBD_Device_Framework_Builder+0x1f0>)
3418291a:	681b      	ldr	r3, [r3, #0]
3418291c:	2202      	movs	r2, #2
3418291e:	715a      	strb	r2, [r3, #5]
      pDevDesc->bDeviceProtocol = 0x00;
34182920:	4b04      	ldr	r3, [pc, #16]	@ (34182934 <USBD_Device_Framework_Builder+0x1f0>)
34182922:	681b      	ldr	r3, [r3, #0]
34182924:	2200      	movs	r2, #0
34182926:	719a      	strb	r2, [r3, #6]
    }
  }

  return pDevFrameWorkDesc;
34182928:	68bb      	ldr	r3, [r7, #8]
}
3418292a:	4618      	mov	r0, r3
3418292c:	3718      	adds	r7, #24
3418292e:	46bd      	mov	sp, r7
34182930:	bd80      	pop	{r7, pc}
34182932:	bf00      	nop
34182934:	341c2270 	.word	0x341c2270
34182938:	341c2274 	.word	0x341c2274

3418293c <USBD_FrameWork_AddClass>:
  */
uint8_t  USBD_FrameWork_AddClass(USBD_DevClassHandleTypeDef *pdev,
                                 USBD_CompositeClassTypeDef class,
                                 uint8_t cfgidx, uint8_t Speed,
                                 uint8_t *pCmpstConfDesc)
{
3418293c:	b580      	push	{r7, lr}
3418293e:	b082      	sub	sp, #8
34182940:	af00      	add	r7, sp, #0
34182942:	6078      	str	r0, [r7, #4]
34182944:	4608      	mov	r0, r1
34182946:	4611      	mov	r1, r2
34182948:	461a      	mov	r2, r3
3418294a:	4603      	mov	r3, r0
3418294c:	70fb      	strb	r3, [r7, #3]
3418294e:	460b      	mov	r3, r1
34182950:	70bb      	strb	r3, [r7, #2]
34182952:	4613      	mov	r3, r2
34182954:	707b      	strb	r3, [r7, #1]
  if ((pdev->classId < USBD_MAX_SUPPORTED_CLASS) &&
34182956:	687b      	ldr	r3, [r7, #4]
34182958:	685b      	ldr	r3, [r3, #4]
3418295a:	2b02      	cmp	r3, #2
3418295c:	d834      	bhi.n	341829c8 <USBD_FrameWork_AddClass+0x8c>
      (pdev->tclasslist[pdev->classId].Active == 0U))
3418295e:	687b      	ldr	r3, [r7, #4]
34182960:	685b      	ldr	r3, [r3, #4]
34182962:	687a      	ldr	r2, [r7, #4]
34182964:	215c      	movs	r1, #92	@ 0x5c
34182966:	fb01 f303 	mul.w	r3, r1, r3
3418296a:	4413      	add	r3, r2
3418296c:	3318      	adds	r3, #24
3418296e:	681b      	ldr	r3, [r3, #0]
  if ((pdev->classId < USBD_MAX_SUPPORTED_CLASS) &&
34182970:	2b00      	cmp	r3, #0
34182972:	d129      	bne.n	341829c8 <USBD_FrameWork_AddClass+0x8c>
  {
    /* Store the class parameters in the global tab */
    pdev->tclasslist[pdev->classId].ClassId = pdev->classId;
34182974:	687b      	ldr	r3, [r7, #4]
34182976:	685b      	ldr	r3, [r3, #4]
34182978:	687a      	ldr	r2, [r7, #4]
3418297a:	6852      	ldr	r2, [r2, #4]
3418297c:	6879      	ldr	r1, [r7, #4]
3418297e:	205c      	movs	r0, #92	@ 0x5c
34182980:	fb00 f303 	mul.w	r3, r0, r3
34182984:	440b      	add	r3, r1
34182986:	3310      	adds	r3, #16
34182988:	601a      	str	r2, [r3, #0]
    pdev->tclasslist[pdev->classId].Active = 1U;
3418298a:	687b      	ldr	r3, [r7, #4]
3418298c:	685b      	ldr	r3, [r3, #4]
3418298e:	687a      	ldr	r2, [r7, #4]
34182990:	215c      	movs	r1, #92	@ 0x5c
34182992:	fb01 f303 	mul.w	r3, r1, r3
34182996:	4413      	add	r3, r2
34182998:	3318      	adds	r3, #24
3418299a:	2201      	movs	r2, #1
3418299c:	601a      	str	r2, [r3, #0]
    pdev->tclasslist[pdev->classId].ClassType = class;
3418299e:	687b      	ldr	r3, [r7, #4]
341829a0:	685b      	ldr	r3, [r3, #4]
341829a2:	687a      	ldr	r2, [r7, #4]
341829a4:	215c      	movs	r1, #92	@ 0x5c
341829a6:	fb01 f303 	mul.w	r3, r1, r3
341829aa:	4413      	add	r3, r2
341829ac:	330c      	adds	r3, #12
341829ae:	78fa      	ldrb	r2, [r7, #3]
341829b0:	701a      	strb	r2, [r3, #0]

    /* Call configuration descriptor builder and endpoint configuration builder */
    if (USBD_FrameWork_AddToConfDesc(pdev, Speed, pCmpstConfDesc) != UX_SUCCESS)
341829b2:	787b      	ldrb	r3, [r7, #1]
341829b4:	693a      	ldr	r2, [r7, #16]
341829b6:	4619      	mov	r1, r3
341829b8:	6878      	ldr	r0, [r7, #4]
341829ba:	f000 f80a 	bl	341829d2 <USBD_FrameWork_AddToConfDesc>
341829be:	4603      	mov	r3, r0
341829c0:	2b00      	cmp	r3, #0
341829c2:	d001      	beq.n	341829c8 <USBD_FrameWork_AddClass+0x8c>
    {
      return UX_ERROR;
341829c4:	23ff      	movs	r3, #255	@ 0xff
341829c6:	e000      	b.n	341829ca <USBD_FrameWork_AddClass+0x8e>
    }
  }

  UNUSED(cfgidx);

  return UX_SUCCESS;
341829c8:	2300      	movs	r3, #0
}
341829ca:	4618      	mov	r0, r3
341829cc:	3708      	adds	r7, #8
341829ce:	46bd      	mov	sp, r7
341829d0:	bd80      	pop	{r7, pc}

341829d2 <USBD_FrameWork_AddToConfDesc>:
  * @param  pCmpstConfDesc: to composite device configuration descriptor
  * @retval status
  */
uint8_t  USBD_FrameWork_AddToConfDesc(USBD_DevClassHandleTypeDef *pdev, uint8_t Speed,
                                      uint8_t *pCmpstConfDesc)
{
341829d2:	b580      	push	{r7, lr}
341829d4:	b086      	sub	sp, #24
341829d6:	af00      	add	r7, sp, #0
341829d8:	60f8      	str	r0, [r7, #12]
341829da:	460b      	mov	r3, r1
341829dc:	607a      	str	r2, [r7, #4]
341829de:	72fb      	strb	r3, [r7, #11]
  uint8_t interface = 0U;
341829e0:	2300      	movs	r3, #0
341829e2:	75fb      	strb	r3, [r7, #23]
  /* USER CODE FrameWork_AddToConfDesc_0 */

  /* USER CODE FrameWork_AddToConfDesc_0 */

  /* The USB drivers do not set the speed value, so set it here before starting */
  pdev->Speed = Speed;
341829e4:	68fb      	ldr	r3, [r7, #12]
341829e6:	7afa      	ldrb	r2, [r7, #11]
341829e8:	701a      	strb	r2, [r3, #0]

  /* start building the config descriptor common part */
  if (pdev->classId == 0U)
341829ea:	68fb      	ldr	r3, [r7, #12]
341829ec:	685b      	ldr	r3, [r3, #4]
341829ee:	2b00      	cmp	r3, #0
341829f0:	d107      	bne.n	34182a02 <USBD_FrameWork_AddToConfDesc+0x30>
  {
    /* Add configuration and IAD descriptors */
    USBD_FrameWork_AddConfDesc((uint32_t)pCmpstConfDesc, &pdev->CurrConfDescSz);
341829f2:	687a      	ldr	r2, [r7, #4]
341829f4:	68fb      	ldr	r3, [r7, #12]
341829f6:	f503 7392 	add.w	r3, r3, #292	@ 0x124
341829fa:	4619      	mov	r1, r3
341829fc:	4610      	mov	r0, r2
341829fe:	f000 f889 	bl	34182b14 <USBD_FrameWork_AddConfDesc>
  }

  switch (pdev->tclasslist[pdev->classId].ClassType)
34182a02:	68fb      	ldr	r3, [r7, #12]
34182a04:	685b      	ldr	r3, [r3, #4]
34182a06:	68fa      	ldr	r2, [r7, #12]
34182a08:	215c      	movs	r1, #92	@ 0x5c
34182a0a:	fb01 f303 	mul.w	r3, r1, r3
34182a0e:	4413      	add	r3, r2
34182a10:	330c      	adds	r3, #12
34182a12:	781b      	ldrb	r3, [r3, #0]
34182a14:	2b03      	cmp	r3, #3
34182a16:	d14a      	bne.n	34182aae <USBD_FrameWork_AddToConfDesc+0xdc>
#if USBD_MSC_CLASS_ACTIVATED == 1U

    case CLASS_TYPE_MSC:

      /* Find the first available interface slot and Assign number of interfaces */
      interface = USBD_FrameWork_FindFreeIFNbr(pdev);
34182a18:	68f8      	ldr	r0, [r7, #12]
34182a1a:	f000 f84e 	bl	34182aba <USBD_FrameWork_FindFreeIFNbr>
34182a1e:	4603      	mov	r3, r0
34182a20:	75fb      	strb	r3, [r7, #23]
      pdev->tclasslist[pdev->classId].NumIf = 1U;
34182a22:	68fb      	ldr	r3, [r7, #12]
34182a24:	685b      	ldr	r3, [r3, #4]
34182a26:	68fa      	ldr	r2, [r7, #12]
34182a28:	215c      	movs	r1, #92	@ 0x5c
34182a2a:	fb01 f303 	mul.w	r3, r1, r3
34182a2e:	4413      	add	r3, r2
34182a30:	3320      	adds	r3, #32
34182a32:	2201      	movs	r2, #1
34182a34:	601a      	str	r2, [r3, #0]
      pdev->tclasslist[pdev->classId].Ifs[0] = interface;
34182a36:	68fb      	ldr	r3, [r7, #12]
34182a38:	685b      	ldr	r3, [r3, #4]
34182a3a:	68fa      	ldr	r2, [r7, #12]
34182a3c:	215c      	movs	r1, #92	@ 0x5c
34182a3e:	fb01 f303 	mul.w	r3, r1, r3
34182a42:	4413      	add	r3, r2
34182a44:	335a      	adds	r3, #90	@ 0x5a
34182a46:	7dfa      	ldrb	r2, [r7, #23]
34182a48:	701a      	strb	r2, [r3, #0]

      /* Assign endpoint numbers */
      pdev->tclasslist[pdev->classId].NumEps = 2; /* EP_IN, EP_OUT */
34182a4a:	68fb      	ldr	r3, [r7, #12]
34182a4c:	685b      	ldr	r3, [r3, #4]
34182a4e:	68fa      	ldr	r2, [r7, #12]
34182a50:	215c      	movs	r1, #92	@ 0x5c
34182a52:	fb01 f303 	mul.w	r3, r1, r3
34182a56:	4413      	add	r3, r2
34182a58:	331c      	adds	r3, #28
34182a5a:	2202      	movs	r2, #2
34182a5c:	601a      	str	r2, [r3, #0]

      /* Check the current speed to assign endpoints */
      if (pdev->Speed == USBD_HIGH_SPEED)
34182a5e:	68fb      	ldr	r3, [r7, #12]
34182a60:	781b      	ldrb	r3, [r3, #0]
34182a62:	2b01      	cmp	r3, #1
34182a64:	d10e      	bne.n	34182a84 <USBD_FrameWork_AddToConfDesc+0xb2>
      {
        /* Assign IN Endpoint */
        USBD_FrameWork_AssignEp(pdev, USBD_MSC_EPIN_ADDR,
34182a66:	f44f 7300 	mov.w	r3, #512	@ 0x200
34182a6a:	2202      	movs	r2, #2
34182a6c:	2181      	movs	r1, #129	@ 0x81
34182a6e:	68f8      	ldr	r0, [r7, #12]
34182a70:	f000 f87d 	bl	34182b6e <USBD_FrameWork_AssignEp>
                                USBD_EP_TYPE_BULK, USBD_MSC_EPIN_HS_MPS);

        /* Assign OUT Endpoint */
        USBD_FrameWork_AssignEp(pdev, USBD_MSC_EPOUT_ADDR,
34182a74:	f44f 7300 	mov.w	r3, #512	@ 0x200
34182a78:	2202      	movs	r2, #2
34182a7a:	2101      	movs	r1, #1
34182a7c:	68f8      	ldr	r0, [r7, #12]
34182a7e:	f000 f876 	bl	34182b6e <USBD_FrameWork_AssignEp>
34182a82:	e00b      	b.n	34182a9c <USBD_FrameWork_AddToConfDesc+0xca>
                                USBD_EP_TYPE_BULK, USBD_MSC_EPOUT_HS_MPS);
      }
      else
      {
        /* Assign IN Endpoint */
        USBD_FrameWork_AssignEp(pdev, USBD_MSC_EPIN_ADDR,
34182a84:	2340      	movs	r3, #64	@ 0x40
34182a86:	2202      	movs	r2, #2
34182a88:	2181      	movs	r1, #129	@ 0x81
34182a8a:	68f8      	ldr	r0, [r7, #12]
34182a8c:	f000 f86f 	bl	34182b6e <USBD_FrameWork_AssignEp>
                                USBD_EP_TYPE_BULK, USBD_MSC_EPIN_FS_MPS);

        /* Assign OUT Endpoint */
        USBD_FrameWork_AssignEp(pdev, USBD_MSC_EPOUT_ADDR,
34182a90:	2340      	movs	r3, #64	@ 0x40
34182a92:	2202      	movs	r2, #2
34182a94:	2101      	movs	r1, #1
34182a96:	68f8      	ldr	r0, [r7, #12]
34182a98:	f000 f869 	bl	34182b6e <USBD_FrameWork_AssignEp>
                                USBD_EP_TYPE_BULK, USBD_MSC_EPOUT_FS_MPS);
      }

      /* Configure and Append the Descriptor */
      USBD_FrameWork_MSCDesc(pdev, (uint32_t)pCmpstConfDesc, &pdev->CurrConfDescSz);
34182a9c:	6879      	ldr	r1, [r7, #4]
34182a9e:	68fb      	ldr	r3, [r7, #12]
34182aa0:	f503 7392 	add.w	r3, r3, #292	@ 0x124
34182aa4:	461a      	mov	r2, r3
34182aa6:	68f8      	ldr	r0, [r7, #12]
34182aa8:	f000 f8d4 	bl	34182c54 <USBD_FrameWork_MSCDesc>

      break;
34182aac:	e000      	b.n	34182ab0 <USBD_FrameWork_AddToConfDesc+0xde>

    default:
      /* USER CODE FrameWork_AddToConfDesc_2 */

      /* USER CODE FrameWork_AddToConfDesc_2 */
      break;
34182aae:	bf00      	nop
  }

  return UX_SUCCESS;
34182ab0:	2300      	movs	r3, #0
}
34182ab2:	4618      	mov	r0, r3
34182ab4:	3718      	adds	r7, #24
34182ab6:	46bd      	mov	sp, r7
34182ab8:	bd80      	pop	{r7, pc}

34182aba <USBD_FrameWork_FindFreeIFNbr>:
  *         Find the first interface available slot
  * @param  pdev: device instance
  * @retval The interface number to be used
  */
static uint8_t USBD_FrameWork_FindFreeIFNbr(USBD_DevClassHandleTypeDef *pdev)
{
34182aba:	b480      	push	{r7}
34182abc:	b087      	sub	sp, #28
34182abe:	af00      	add	r7, sp, #0
34182ac0:	6078      	str	r0, [r7, #4]
  uint32_t idx = 0U;
34182ac2:	2300      	movs	r3, #0
34182ac4:	617b      	str	r3, [r7, #20]

  /* Unroll all already activated classes */
  for (uint32_t i = 0U; i < pdev->NumClasses; i++)
34182ac6:	2300      	movs	r3, #0
34182ac8:	613b      	str	r3, [r7, #16]
34182aca:	e016      	b.n	34182afa <USBD_FrameWork_FindFreeIFNbr+0x40>
  {
    /* Unroll each class interfaces */
    for (uint32_t j = 0U; j < pdev->tclasslist[i].NumIf; j++)
34182acc:	2300      	movs	r3, #0
34182ace:	60fb      	str	r3, [r7, #12]
34182ad0:	e005      	b.n	34182ade <USBD_FrameWork_FindFreeIFNbr+0x24>
    {
      /* Increment the interface counter index */
      idx++;
34182ad2:	697b      	ldr	r3, [r7, #20]
34182ad4:	3301      	adds	r3, #1
34182ad6:	617b      	str	r3, [r7, #20]
    for (uint32_t j = 0U; j < pdev->tclasslist[i].NumIf; j++)
34182ad8:	68fb      	ldr	r3, [r7, #12]
34182ada:	3301      	adds	r3, #1
34182adc:	60fb      	str	r3, [r7, #12]
34182ade:	687a      	ldr	r2, [r7, #4]
34182ae0:	693b      	ldr	r3, [r7, #16]
34182ae2:	215c      	movs	r1, #92	@ 0x5c
34182ae4:	fb01 f303 	mul.w	r3, r1, r3
34182ae8:	4413      	add	r3, r2
34182aea:	3320      	adds	r3, #32
34182aec:	681b      	ldr	r3, [r3, #0]
34182aee:	68fa      	ldr	r2, [r7, #12]
34182af0:	429a      	cmp	r2, r3
34182af2:	d3ee      	bcc.n	34182ad2 <USBD_FrameWork_FindFreeIFNbr+0x18>
  for (uint32_t i = 0U; i < pdev->NumClasses; i++)
34182af4:	693b      	ldr	r3, [r7, #16]
34182af6:	3301      	adds	r3, #1
34182af8:	613b      	str	r3, [r7, #16]
34182afa:	687b      	ldr	r3, [r7, #4]
34182afc:	689b      	ldr	r3, [r3, #8]
34182afe:	693a      	ldr	r2, [r7, #16]
34182b00:	429a      	cmp	r2, r3
34182b02:	d3e3      	bcc.n	34182acc <USBD_FrameWork_FindFreeIFNbr+0x12>
    }
  }

  /* Return the first available interface slot */
  return (uint8_t)idx;
34182b04:	697b      	ldr	r3, [r7, #20]
34182b06:	b2db      	uxtb	r3, r3
}
34182b08:	4618      	mov	r0, r3
34182b0a:	371c      	adds	r7, #28
34182b0c:	46bd      	mov	sp, r7
34182b0e:	f85d 7b04 	ldr.w	r7, [sp], #4
34182b12:	4770      	bx	lr

34182b14 <USBD_FrameWork_AddConfDesc>:
  * @param  Conf: configuration descriptor
  * @param  pSze: pointer to the configuration descriptor size
  * @retval none
  */
static void  USBD_FrameWork_AddConfDesc(uint32_t Conf, uint32_t *pSze)
{
34182b14:	b480      	push	{r7}
34182b16:	b085      	sub	sp, #20
34182b18:	af00      	add	r7, sp, #0
34182b1a:	6078      	str	r0, [r7, #4]
34182b1c:	6039      	str	r1, [r7, #0]
  /* Intermediate variable to comply with MISRA-C Rule 11.3 */
  USBD_ConfigDescTypedef *ptr = (USBD_ConfigDescTypedef *)Conf;
34182b1e:	687b      	ldr	r3, [r7, #4]
34182b20:	60fb      	str	r3, [r7, #12]

  ptr->bLength = (uint8_t)sizeof(USBD_ConfigDescTypedef);
34182b22:	68fb      	ldr	r3, [r7, #12]
34182b24:	2209      	movs	r2, #9
34182b26:	701a      	strb	r2, [r3, #0]
  ptr->bDescriptorType = USB_DESC_TYPE_CONFIGURATION;
34182b28:	68fb      	ldr	r3, [r7, #12]
34182b2a:	2202      	movs	r2, #2
34182b2c:	705a      	strb	r2, [r3, #1]
  ptr->wDescriptorLength = 0U;
34182b2e:	68fb      	ldr	r3, [r7, #12]
34182b30:	2200      	movs	r2, #0
34182b32:	709a      	strb	r2, [r3, #2]
34182b34:	2200      	movs	r2, #0
34182b36:	70da      	strb	r2, [r3, #3]
  ptr->bNumInterfaces = 0U;
34182b38:	68fb      	ldr	r3, [r7, #12]
34182b3a:	2200      	movs	r2, #0
34182b3c:	711a      	strb	r2, [r3, #4]
  ptr->bConfigurationValue = 1U;
34182b3e:	68fb      	ldr	r3, [r7, #12]
34182b40:	2201      	movs	r2, #1
34182b42:	715a      	strb	r2, [r3, #5]
  ptr->iConfiguration = USBD_CONFIG_STR_DESC_IDX;
34182b44:	68fb      	ldr	r3, [r7, #12]
34182b46:	2200      	movs	r2, #0
34182b48:	719a      	strb	r2, [r3, #6]
  ptr->bmAttributes = USBD_CONFIG_BMATTRIBUTES;
34182b4a:	68fb      	ldr	r3, [r7, #12]
34182b4c:	22c0      	movs	r2, #192	@ 0xc0
34182b4e:	71da      	strb	r2, [r3, #7]
  ptr->bMaxPower = USBD_CONFIG_MAXPOWER;
34182b50:	68fb      	ldr	r3, [r7, #12]
34182b52:	2219      	movs	r2, #25
34182b54:	721a      	strb	r2, [r3, #8]
  *pSze += sizeof(USBD_ConfigDescTypedef);
34182b56:	683b      	ldr	r3, [r7, #0]
34182b58:	681b      	ldr	r3, [r3, #0]
34182b5a:	f103 0209 	add.w	r2, r3, #9
34182b5e:	683b      	ldr	r3, [r7, #0]
34182b60:	601a      	str	r2, [r3, #0]
}
34182b62:	bf00      	nop
34182b64:	3714      	adds	r7, #20
34182b66:	46bd      	mov	sp, r7
34182b68:	f85d 7b04 	ldr.w	r7, [sp], #4
34182b6c:	4770      	bx	lr

34182b6e <USBD_FrameWork_AssignEp>:
  * @param  Sze: Endpoint max packet size
  * @retval none
  */
static void  USBD_FrameWork_AssignEp(USBD_DevClassHandleTypeDef *pdev,
                                     uint8_t Add, uint8_t Type, uint32_t Sze)
{
34182b6e:	b490      	push	{r4, r7}
34182b70:	b086      	sub	sp, #24
34182b72:	af00      	add	r7, sp, #0
34182b74:	60f8      	str	r0, [r7, #12]
34182b76:	607b      	str	r3, [r7, #4]
34182b78:	460b      	mov	r3, r1
34182b7a:	72fb      	strb	r3, [r7, #11]
34182b7c:	4613      	mov	r3, r2
34182b7e:	72bb      	strb	r3, [r7, #10]
  uint32_t idx = 0U;
34182b80:	2300      	movs	r3, #0
34182b82:	617b      	str	r3, [r7, #20]

  /* Find the first available endpoint slot */
  while (((idx < (pdev->tclasslist[pdev->classId]).NumEps) && \
34182b84:	e002      	b.n	34182b8c <USBD_FrameWork_AssignEp+0x1e>
          ((pdev->tclasslist[pdev->classId].Eps[idx].is_used) != 0U)))
  {
    /* Increment the index */
    idx++;
34182b86:	697b      	ldr	r3, [r7, #20]
34182b88:	3301      	adds	r3, #1
34182b8a:	617b      	str	r3, [r7, #20]
  while (((idx < (pdev->tclasslist[pdev->classId]).NumEps) && \
34182b8c:	68fb      	ldr	r3, [r7, #12]
34182b8e:	685b      	ldr	r3, [r3, #4]
34182b90:	68fa      	ldr	r2, [r7, #12]
34182b92:	215c      	movs	r1, #92	@ 0x5c
34182b94:	fb01 f303 	mul.w	r3, r1, r3
34182b98:	4413      	add	r3, r2
34182b9a:	331c      	adds	r3, #28
34182b9c:	681b      	ldr	r3, [r3, #0]
34182b9e:	697a      	ldr	r2, [r7, #20]
34182ba0:	429a      	cmp	r2, r3
34182ba2:	d210      	bcs.n	34182bc6 <USBD_FrameWork_AssignEp+0x58>
          ((pdev->tclasslist[pdev->classId].Eps[idx].is_used) != 0U)))
34182ba4:	68fb      	ldr	r3, [r7, #12]
34182ba6:	6858      	ldr	r0, [r3, #4]
34182ba8:	68f9      	ldr	r1, [r7, #12]
34182baa:	697a      	ldr	r2, [r7, #20]
34182bac:	4613      	mov	r3, r2
34182bae:	005b      	lsls	r3, r3, #1
34182bb0:	4413      	add	r3, r2
34182bb2:	005b      	lsls	r3, r3, #1
34182bb4:	225c      	movs	r2, #92	@ 0x5c
34182bb6:	fb00 f202 	mul.w	r2, r0, r2
34182bba:	4413      	add	r3, r2
34182bbc:	440b      	add	r3, r1
34182bbe:	3328      	adds	r3, #40	@ 0x28
34182bc0:	781b      	ldrb	r3, [r3, #0]
  while (((idx < (pdev->tclasslist[pdev->classId]).NumEps) && \
34182bc2:	2b00      	cmp	r3, #0
34182bc4:	d1df      	bne.n	34182b86 <USBD_FrameWork_AssignEp+0x18>
  }

  /* Configure the endpoint */
  pdev->tclasslist[pdev->classId].Eps[idx].add = Add;
34182bc6:	68fb      	ldr	r3, [r7, #12]
34182bc8:	6858      	ldr	r0, [r3, #4]
34182bca:	68f9      	ldr	r1, [r7, #12]
34182bcc:	697a      	ldr	r2, [r7, #20]
34182bce:	4613      	mov	r3, r2
34182bd0:	005b      	lsls	r3, r3, #1
34182bd2:	4413      	add	r3, r2
34182bd4:	005b      	lsls	r3, r3, #1
34182bd6:	225c      	movs	r2, #92	@ 0x5c
34182bd8:	fb00 f202 	mul.w	r2, r0, r2
34182bdc:	4413      	add	r3, r2
34182bde:	440b      	add	r3, r1
34182be0:	3324      	adds	r3, #36	@ 0x24
34182be2:	7afa      	ldrb	r2, [r7, #11]
34182be4:	701a      	strb	r2, [r3, #0]
  pdev->tclasslist[pdev->classId].Eps[idx].type = Type;
34182be6:	68fb      	ldr	r3, [r7, #12]
34182be8:	6858      	ldr	r0, [r3, #4]
34182bea:	68f9      	ldr	r1, [r7, #12]
34182bec:	697a      	ldr	r2, [r7, #20]
34182bee:	4613      	mov	r3, r2
34182bf0:	005b      	lsls	r3, r3, #1
34182bf2:	4413      	add	r3, r2
34182bf4:	005b      	lsls	r3, r3, #1
34182bf6:	225c      	movs	r2, #92	@ 0x5c
34182bf8:	fb00 f202 	mul.w	r2, r0, r2
34182bfc:	4413      	add	r3, r2
34182bfe:	440b      	add	r3, r1
34182c00:	3325      	adds	r3, #37	@ 0x25
34182c02:	7aba      	ldrb	r2, [r7, #10]
34182c04:	701a      	strb	r2, [r3, #0]
  pdev->tclasslist[pdev->classId].Eps[idx].size = (uint16_t) Sze;
34182c06:	68fb      	ldr	r3, [r7, #12]
34182c08:	6858      	ldr	r0, [r3, #4]
34182c0a:	687b      	ldr	r3, [r7, #4]
34182c0c:	b29c      	uxth	r4, r3
34182c0e:	68f9      	ldr	r1, [r7, #12]
34182c10:	697a      	ldr	r2, [r7, #20]
34182c12:	4613      	mov	r3, r2
34182c14:	005b      	lsls	r3, r3, #1
34182c16:	4413      	add	r3, r2
34182c18:	005b      	lsls	r3, r3, #1
34182c1a:	225c      	movs	r2, #92	@ 0x5c
34182c1c:	fb00 f202 	mul.w	r2, r0, r2
34182c20:	4413      	add	r3, r2
34182c22:	440b      	add	r3, r1
34182c24:	3326      	adds	r3, #38	@ 0x26
34182c26:	4622      	mov	r2, r4
34182c28:	801a      	strh	r2, [r3, #0]
  pdev->tclasslist[pdev->classId].Eps[idx].is_used = 1U;
34182c2a:	68fb      	ldr	r3, [r7, #12]
34182c2c:	6858      	ldr	r0, [r3, #4]
34182c2e:	68f9      	ldr	r1, [r7, #12]
34182c30:	697a      	ldr	r2, [r7, #20]
34182c32:	4613      	mov	r3, r2
34182c34:	005b      	lsls	r3, r3, #1
34182c36:	4413      	add	r3, r2
34182c38:	005b      	lsls	r3, r3, #1
34182c3a:	225c      	movs	r2, #92	@ 0x5c
34182c3c:	fb00 f202 	mul.w	r2, r0, r2
34182c40:	4413      	add	r3, r2
34182c42:	440b      	add	r3, r1
34182c44:	3328      	adds	r3, #40	@ 0x28
34182c46:	2201      	movs	r2, #1
34182c48:	701a      	strb	r2, [r3, #0]
}
34182c4a:	bf00      	nop
34182c4c:	3718      	adds	r7, #24
34182c4e:	46bd      	mov	sp, r7
34182c50:	bc90      	pop	{r4, r7}
34182c52:	4770      	bx	lr

34182c54 <USBD_FrameWork_MSCDesc>:
  * @param  Sze: pointer to the current configuration descriptor size
  * @retval None
  */
static void  USBD_FrameWork_MSCDesc(USBD_DevClassHandleTypeDef *pdev,
                                    uint32_t pConf, uint32_t *Sze)
{
34182c54:	b480      	push	{r7}
34182c56:	b087      	sub	sp, #28
34182c58:	af00      	add	r7, sp, #0
34182c5a:	60f8      	str	r0, [r7, #12]
34182c5c:	60b9      	str	r1, [r7, #8]
34182c5e:	607a      	str	r2, [r7, #4]
  USBD_IfDescTypedef       *pIfDesc;
  USBD_EpDescTypedef       *pEpDesc;

  /* Append MSC Interface descriptor */
  __USBD_FRAMEWORK_SET_IF((pdev->tclasslist[pdev->classId].Ifs[0]), (0U), \
34182c60:	687b      	ldr	r3, [r7, #4]
34182c62:	681a      	ldr	r2, [r3, #0]
34182c64:	68bb      	ldr	r3, [r7, #8]
34182c66:	4413      	add	r3, r2
34182c68:	617b      	str	r3, [r7, #20]
34182c6a:	697b      	ldr	r3, [r7, #20]
34182c6c:	2209      	movs	r2, #9
34182c6e:	701a      	strb	r2, [r3, #0]
34182c70:	697b      	ldr	r3, [r7, #20]
34182c72:	2204      	movs	r2, #4
34182c74:	705a      	strb	r2, [r3, #1]
34182c76:	68fb      	ldr	r3, [r7, #12]
34182c78:	685b      	ldr	r3, [r3, #4]
34182c7a:	68fa      	ldr	r2, [r7, #12]
34182c7c:	215c      	movs	r1, #92	@ 0x5c
34182c7e:	fb01 f303 	mul.w	r3, r1, r3
34182c82:	4413      	add	r3, r2
34182c84:	335a      	adds	r3, #90	@ 0x5a
34182c86:	781a      	ldrb	r2, [r3, #0]
34182c88:	697b      	ldr	r3, [r7, #20]
34182c8a:	709a      	strb	r2, [r3, #2]
34182c8c:	697b      	ldr	r3, [r7, #20]
34182c8e:	2200      	movs	r2, #0
34182c90:	70da      	strb	r2, [r3, #3]
34182c92:	68fb      	ldr	r3, [r7, #12]
34182c94:	685b      	ldr	r3, [r3, #4]
34182c96:	68fa      	ldr	r2, [r7, #12]
34182c98:	215c      	movs	r1, #92	@ 0x5c
34182c9a:	fb01 f303 	mul.w	r3, r1, r3
34182c9e:	4413      	add	r3, r2
34182ca0:	331c      	adds	r3, #28
34182ca2:	681b      	ldr	r3, [r3, #0]
34182ca4:	b2da      	uxtb	r2, r3
34182ca6:	697b      	ldr	r3, [r7, #20]
34182ca8:	711a      	strb	r2, [r3, #4]
34182caa:	697b      	ldr	r3, [r7, #20]
34182cac:	2208      	movs	r2, #8
34182cae:	715a      	strb	r2, [r3, #5]
34182cb0:	697b      	ldr	r3, [r7, #20]
34182cb2:	2206      	movs	r2, #6
34182cb4:	719a      	strb	r2, [r3, #6]
34182cb6:	697b      	ldr	r3, [r7, #20]
34182cb8:	2250      	movs	r2, #80	@ 0x50
34182cba:	71da      	strb	r2, [r3, #7]
34182cbc:	697b      	ldr	r3, [r7, #20]
34182cbe:	2200      	movs	r2, #0
34182cc0:	721a      	strb	r2, [r3, #8]
34182cc2:	687b      	ldr	r3, [r7, #4]
34182cc4:	681b      	ldr	r3, [r3, #0]
34182cc6:	f103 0209 	add.w	r2, r3, #9
34182cca:	687b      	ldr	r3, [r7, #4]
34182ccc:	601a      	str	r2, [r3, #0]
                          (uint8_t)(pdev->tclasslist[pdev->classId].NumEps),
                          (0x08U), (0x06U), (0x50U), (0U));

  /* Append Endpoint descriptor to Configuration descriptor */
  __USBD_FRAMEWORK_SET_EP((pdev->tclasslist[pdev->classId].Eps[0].add),
34182cce:	687b      	ldr	r3, [r7, #4]
34182cd0:	681a      	ldr	r2, [r3, #0]
34182cd2:	68bb      	ldr	r3, [r7, #8]
34182cd4:	4413      	add	r3, r2
34182cd6:	613b      	str	r3, [r7, #16]
34182cd8:	693b      	ldr	r3, [r7, #16]
34182cda:	2207      	movs	r2, #7
34182cdc:	701a      	strb	r2, [r3, #0]
34182cde:	693b      	ldr	r3, [r7, #16]
34182ce0:	2205      	movs	r2, #5
34182ce2:	705a      	strb	r2, [r3, #1]
34182ce4:	68fb      	ldr	r3, [r7, #12]
34182ce6:	685b      	ldr	r3, [r3, #4]
34182ce8:	68fa      	ldr	r2, [r7, #12]
34182cea:	215c      	movs	r1, #92	@ 0x5c
34182cec:	fb01 f303 	mul.w	r3, r1, r3
34182cf0:	4413      	add	r3, r2
34182cf2:	3324      	adds	r3, #36	@ 0x24
34182cf4:	781a      	ldrb	r2, [r3, #0]
34182cf6:	693b      	ldr	r3, [r7, #16]
34182cf8:	709a      	strb	r2, [r3, #2]
34182cfa:	693b      	ldr	r3, [r7, #16]
34182cfc:	2202      	movs	r2, #2
34182cfe:	70da      	strb	r2, [r3, #3]
34182d00:	68fb      	ldr	r3, [r7, #12]
34182d02:	685b      	ldr	r3, [r3, #4]
34182d04:	68fa      	ldr	r2, [r7, #12]
34182d06:	215c      	movs	r1, #92	@ 0x5c
34182d08:	fb01 f303 	mul.w	r3, r1, r3
34182d0c:	4413      	add	r3, r2
34182d0e:	3326      	adds	r3, #38	@ 0x26
34182d10:	881a      	ldrh	r2, [r3, #0]
34182d12:	693b      	ldr	r3, [r7, #16]
34182d14:	809a      	strh	r2, [r3, #4]
34182d16:	68fb      	ldr	r3, [r7, #12]
34182d18:	781b      	ldrb	r3, [r3, #0]
34182d1a:	2b01      	cmp	r3, #1
34182d1c:	d103      	bne.n	34182d26 <USBD_FrameWork_MSCDesc+0xd2>
34182d1e:	693b      	ldr	r3, [r7, #16]
34182d20:	2200      	movs	r2, #0
34182d22:	719a      	strb	r2, [r3, #6]
34182d24:	e002      	b.n	34182d2c <USBD_FrameWork_MSCDesc+0xd8>
34182d26:	693b      	ldr	r3, [r7, #16]
34182d28:	2200      	movs	r2, #0
34182d2a:	719a      	strb	r2, [r3, #6]
34182d2c:	687b      	ldr	r3, [r7, #4]
34182d2e:	681b      	ldr	r3, [r3, #0]
34182d30:	1dda      	adds	r2, r3, #7
34182d32:	687b      	ldr	r3, [r7, #4]
34182d34:	601a      	str	r2, [r3, #0]
                          (USBD_EP_TYPE_BULK),
                          (uint16_t)(pdev->tclasslist[pdev->classId].Eps[0].size),
                          (0U), (0U));

  /* Append Endpoint descriptor to Configuration descriptor */
  __USBD_FRAMEWORK_SET_EP((pdev->tclasslist[pdev->classId].Eps[1].add),
34182d36:	687b      	ldr	r3, [r7, #4]
34182d38:	681a      	ldr	r2, [r3, #0]
34182d3a:	68bb      	ldr	r3, [r7, #8]
34182d3c:	4413      	add	r3, r2
34182d3e:	613b      	str	r3, [r7, #16]
34182d40:	693b      	ldr	r3, [r7, #16]
34182d42:	2207      	movs	r2, #7
34182d44:	701a      	strb	r2, [r3, #0]
34182d46:	693b      	ldr	r3, [r7, #16]
34182d48:	2205      	movs	r2, #5
34182d4a:	705a      	strb	r2, [r3, #1]
34182d4c:	68fb      	ldr	r3, [r7, #12]
34182d4e:	685b      	ldr	r3, [r3, #4]
34182d50:	68fa      	ldr	r2, [r7, #12]
34182d52:	215c      	movs	r1, #92	@ 0x5c
34182d54:	fb01 f303 	mul.w	r3, r1, r3
34182d58:	4413      	add	r3, r2
34182d5a:	332a      	adds	r3, #42	@ 0x2a
34182d5c:	781a      	ldrb	r2, [r3, #0]
34182d5e:	693b      	ldr	r3, [r7, #16]
34182d60:	709a      	strb	r2, [r3, #2]
34182d62:	693b      	ldr	r3, [r7, #16]
34182d64:	2202      	movs	r2, #2
34182d66:	70da      	strb	r2, [r3, #3]
34182d68:	68fb      	ldr	r3, [r7, #12]
34182d6a:	685b      	ldr	r3, [r3, #4]
34182d6c:	68fa      	ldr	r2, [r7, #12]
34182d6e:	215c      	movs	r1, #92	@ 0x5c
34182d70:	fb01 f303 	mul.w	r3, r1, r3
34182d74:	4413      	add	r3, r2
34182d76:	332c      	adds	r3, #44	@ 0x2c
34182d78:	881a      	ldrh	r2, [r3, #0]
34182d7a:	693b      	ldr	r3, [r7, #16]
34182d7c:	809a      	strh	r2, [r3, #4]
34182d7e:	68fb      	ldr	r3, [r7, #12]
34182d80:	781b      	ldrb	r3, [r3, #0]
34182d82:	2b01      	cmp	r3, #1
34182d84:	d103      	bne.n	34182d8e <USBD_FrameWork_MSCDesc+0x13a>
34182d86:	693b      	ldr	r3, [r7, #16]
34182d88:	2200      	movs	r2, #0
34182d8a:	719a      	strb	r2, [r3, #6]
34182d8c:	e002      	b.n	34182d94 <USBD_FrameWork_MSCDesc+0x140>
34182d8e:	693b      	ldr	r3, [r7, #16]
34182d90:	2200      	movs	r2, #0
34182d92:	719a      	strb	r2, [r3, #6]
34182d94:	687b      	ldr	r3, [r7, #4]
34182d96:	681b      	ldr	r3, [r3, #0]
34182d98:	1dda      	adds	r2, r3, #7
34182d9a:	687b      	ldr	r3, [r7, #4]
34182d9c:	601a      	str	r2, [r3, #0]
                          (USBD_EP_TYPE_BULK),
                          (uint16_t)(pdev->tclasslist[pdev->classId].Eps[1].size),
                          (0U), (0U));

  /* Update Config Descriptor and IAD descriptor */
  ((USBD_ConfigDescTypedef *)pConf)->bNumInterfaces += 1U;
34182d9e:	68bb      	ldr	r3, [r7, #8]
34182da0:	791a      	ldrb	r2, [r3, #4]
34182da2:	68bb      	ldr	r3, [r7, #8]
34182da4:	3201      	adds	r2, #1
34182da6:	b2d2      	uxtb	r2, r2
34182da8:	711a      	strb	r2, [r3, #4]
  ((USBD_ConfigDescTypedef *)pConf)->wDescriptorLength = *Sze;
34182daa:	687b      	ldr	r3, [r7, #4]
34182dac:	681a      	ldr	r2, [r3, #0]
34182dae:	68bb      	ldr	r3, [r7, #8]
34182db0:	b292      	uxth	r2, r2
34182db2:	805a      	strh	r2, [r3, #2]
}
34182db4:	bf00      	nop
34182db6:	371c      	adds	r7, #28
34182db8:	46bd      	mov	sp, r7
34182dba:	f85d 7b04 	ldr.w	r7, [sp], #4
34182dbe:	4770      	bx	lr

34182dc0 <USBD_STORAGE_Activate>:
  *         This function is called when insertion of a storage device.
  * @param  storage_instance: Pointer to the storage class instance.
  * @retval none
  */
VOID USBD_STORAGE_Activate(VOID *storage_instance)
{
34182dc0:	b480      	push	{r7}
34182dc2:	b083      	sub	sp, #12
34182dc4:	af00      	add	r7, sp, #0
34182dc6:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN USBD_STORAGE_Activate */
  UX_PARAMETER_NOT_USED(storage_instance);
  /* USER CODE END USBD_STORAGE_Activate */

  return;
34182dc8:	bf00      	nop
}
34182dca:	370c      	adds	r7, #12
34182dcc:	46bd      	mov	sp, r7
34182dce:	f85d 7b04 	ldr.w	r7, [sp], #4
34182dd2:	4770      	bx	lr

34182dd4 <USBD_STORAGE_Deactivate>:
  *         This function is called when extraction of a storage device.
  * @param  storage_instance: Pointer to the storage class instance.
  * @retval none
  */
VOID USBD_STORAGE_Deactivate(VOID *storage_instance)
{
34182dd4:	b480      	push	{r7}
34182dd6:	b083      	sub	sp, #12
34182dd8:	af00      	add	r7, sp, #0
34182dda:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN USBD_STORAGE_Activate */
  UX_PARAMETER_NOT_USED(storage_instance);
  /* USER CODE END USBD_STORAGE_Activate */

  return;
34182ddc:	bf00      	nop
}
34182dde:	370c      	adds	r7, #12
34182de0:	46bd      	mov	sp, r7
34182de2:	f85d 7b04 	ldr.w	r7, [sp], #4
34182de6:	4770      	bx	lr

34182de8 <USBD_STORAGE_Read>:
  *                       callback return value.
  * @retval status
  */
UINT USBD_STORAGE_Read(VOID *storage_instance, ULONG lun, UCHAR *data_pointer,
                       ULONG number_blocks, ULONG lba, ULONG *media_status)
{
34182de8:	b580      	push	{r7, lr}
34182dea:	b088      	sub	sp, #32
34182dec:	af02      	add	r7, sp, #8
34182dee:	60f8      	str	r0, [r7, #12]
34182df0:	60b9      	str	r1, [r7, #8]
34182df2:	607a      	str	r2, [r7, #4]
34182df4:	603b      	str	r3, [r7, #0]
  UINT status = UX_SUCCESS;
34182df6:	2300      	movs	r3, #0
34182df8:	617b      	str	r3, [r7, #20]
  /* USER CODE BEGIN USBD_STORAGE_Read */
  UX_PARAMETER_NOT_USED(storage_instance);
  UX_PARAMETER_NOT_USED(lun);
  UX_PARAMETER_NOT_USED(media_status);

  ULONG ReadFlags = 0U;
34182dfa:	2300      	movs	r3, #0
34182dfc:	613b      	str	r3, [r7, #16]

  /* Check if the SD card is present */
  if (HAL_GPIO_ReadPin(SD_DETECT_GPIO_Port, SD_DETECT_Pin) == GPIO_PIN_RESET)
34182dfe:	f44f 5180 	mov.w	r1, #4096	@ 0x1000
34182e02:	4817      	ldr	r0, [pc, #92]	@ (34182e60 <USBD_STORAGE_Read+0x78>)
34182e04:	f004 fb10 	bl	34187428 <HAL_GPIO_ReadPin>
34182e08:	4603      	mov	r3, r0
34182e0a:	2b00      	cmp	r3, #0
34182e0c:	d122      	bne.n	34182e54 <USBD_STORAGE_Read+0x6c>
  {
    /* Check id SD card is ready */
    if(check_sd_status() != HAL_OK)
34182e0e:	f000 f8eb 	bl	34182fe8 <check_sd_status>
34182e12:	4603      	mov	r3, r0
34182e14:	2b00      	cmp	r3, #0
34182e16:	d001      	beq.n	34182e1c <USBD_STORAGE_Read+0x34>
    {
      Error_Handler();
34182e18:	f7fe fbd2 	bl	341815c0 <Error_Handler>
    }

    /* Start the Dma write */
    status =  HAL_SD_ReadBlocks_DMA(&hsd1, data_pointer, lba, number_blocks);
34182e1c:	683b      	ldr	r3, [r7, #0]
34182e1e:	6a3a      	ldr	r2, [r7, #32]
34182e20:	6879      	ldr	r1, [r7, #4]
34182e22:	4810      	ldr	r0, [pc, #64]	@ (34182e64 <USBD_STORAGE_Read+0x7c>)
34182e24:	f00b ffec 	bl	3418ee00 <HAL_SD_ReadBlocks_DMA>
34182e28:	4603      	mov	r3, r0
34182e2a:	617b      	str	r3, [r7, #20]
    if(status != HAL_OK)
34182e2c:	697b      	ldr	r3, [r7, #20]
34182e2e:	2b00      	cmp	r3, #0
34182e30:	d001      	beq.n	34182e36 <USBD_STORAGE_Read+0x4e>
    {
      Error_Handler();
34182e32:	f7fe fbc5 	bl	341815c0 <Error_Handler>
    }

    /* Wait on readflag until SD card is ready to use for new operation */
    if (tx_event_flags_get(&EventFlag, SD_READ_FLAG, TX_OR_CLEAR,
34182e36:	f107 0310 	add.w	r3, r7, #16
34182e3a:	f04f 32ff 	mov.w	r2, #4294967295
34182e3e:	9200      	str	r2, [sp, #0]
34182e40:	2201      	movs	r2, #1
34182e42:	2101      	movs	r1, #1
34182e44:	4808      	ldr	r0, [pc, #32]	@ (34182e68 <USBD_STORAGE_Read+0x80>)
34182e46:	f015 fd3d 	bl	341988c4 <_txe_event_flags_get>
34182e4a:	4603      	mov	r3, r0
34182e4c:	2b00      	cmp	r3, #0
34182e4e:	d001      	beq.n	34182e54 <USBD_STORAGE_Read+0x6c>
                           &ReadFlags, TX_WAIT_FOREVER) != TX_SUCCESS)
    {
      Error_Handler();
34182e50:	f7fe fbb6 	bl	341815c0 <Error_Handler>
    }
  }

  /* USER CODE END USBD_STORAGE_Read */

  return status;
34182e54:	697b      	ldr	r3, [r7, #20]
}
34182e56:	4618      	mov	r0, r3
34182e58:	3718      	adds	r7, #24
34182e5a:	46bd      	mov	sp, r7
34182e5c:	bd80      	pop	{r7, pc}
34182e5e:	bf00      	nop
34182e60:	56023400 	.word	0x56023400
34182e64:	341c1a3c 	.word	0x341c1a3c
34182e68:	341c1d64 	.word	0x341c1d64

34182e6c <USBD_STORAGE_Write>:
  *                       callback return value.
  * @retval status
  */
UINT USBD_STORAGE_Write(VOID *storage_instance, ULONG lun, UCHAR *data_pointer,
                        ULONG number_blocks, ULONG lba, ULONG *media_status)
{
34182e6c:	b580      	push	{r7, lr}
34182e6e:	b088      	sub	sp, #32
34182e70:	af02      	add	r7, sp, #8
34182e72:	60f8      	str	r0, [r7, #12]
34182e74:	60b9      	str	r1, [r7, #8]
34182e76:	607a      	str	r2, [r7, #4]
34182e78:	603b      	str	r3, [r7, #0]
  UINT status = UX_SUCCESS;
34182e7a:	2300      	movs	r3, #0
34182e7c:	617b      	str	r3, [r7, #20]
  /* USER CODE BEGIN USBD_STORAGE_Write */
  UX_PARAMETER_NOT_USED(storage_instance);
  UX_PARAMETER_NOT_USED(lun);
  UX_PARAMETER_NOT_USED(media_status);

  ULONG WriteFlags = 0U;
34182e7e:	2300      	movs	r3, #0
34182e80:	613b      	str	r3, [r7, #16]

  /* Check if the SD card is present */
  if (HAL_GPIO_ReadPin(SD_DETECT_GPIO_Port, SD_DETECT_Pin) == GPIO_PIN_RESET)
34182e82:	f44f 5180 	mov.w	r1, #4096	@ 0x1000
34182e86:	4817      	ldr	r0, [pc, #92]	@ (34182ee4 <USBD_STORAGE_Write+0x78>)
34182e88:	f004 face 	bl	34187428 <HAL_GPIO_ReadPin>
34182e8c:	4603      	mov	r3, r0
34182e8e:	2b00      	cmp	r3, #0
34182e90:	d122      	bne.n	34182ed8 <USBD_STORAGE_Write+0x6c>
  {
    /* Check id SD card is ready */
    if(check_sd_status() != HAL_OK)
34182e92:	f000 f8a9 	bl	34182fe8 <check_sd_status>
34182e96:	4603      	mov	r3, r0
34182e98:	2b00      	cmp	r3, #0
34182e9a:	d001      	beq.n	34182ea0 <USBD_STORAGE_Write+0x34>
    {
      Error_Handler();
34182e9c:	f7fe fb90 	bl	341815c0 <Error_Handler>
    }

    /* Start the Dma write */
    status = HAL_SD_WriteBlocks_DMA(&hsd1, data_pointer, lba, number_blocks);
34182ea0:	683b      	ldr	r3, [r7, #0]
34182ea2:	6a3a      	ldr	r2, [r7, #32]
34182ea4:	6879      	ldr	r1, [r7, #4]
34182ea6:	4810      	ldr	r0, [pc, #64]	@ (34182ee8 <USBD_STORAGE_Write+0x7c>)
34182ea8:	f00c f852 	bl	3418ef50 <HAL_SD_WriteBlocks_DMA>
34182eac:	4603      	mov	r3, r0
34182eae:	617b      	str	r3, [r7, #20]

    if(status != HAL_OK)
34182eb0:	697b      	ldr	r3, [r7, #20]
34182eb2:	2b00      	cmp	r3, #0
34182eb4:	d001      	beq.n	34182eba <USBD_STORAGE_Write+0x4e>
    {
      Error_Handler();
34182eb6:	f7fe fb83 	bl	341815c0 <Error_Handler>
    }

    /* Wait on writeflag until SD card is ready to use for new operation */
    if (tx_event_flags_get(&EventFlag, SD_WRITE_FLAG, TX_OR_CLEAR,
34182eba:	f107 0310 	add.w	r3, r7, #16
34182ebe:	f04f 32ff 	mov.w	r2, #4294967295
34182ec2:	9200      	str	r2, [sp, #0]
34182ec4:	2201      	movs	r2, #1
34182ec6:	2102      	movs	r1, #2
34182ec8:	4808      	ldr	r0, [pc, #32]	@ (34182eec <USBD_STORAGE_Write+0x80>)
34182eca:	f015 fcfb 	bl	341988c4 <_txe_event_flags_get>
34182ece:	4603      	mov	r3, r0
34182ed0:	2b00      	cmp	r3, #0
34182ed2:	d001      	beq.n	34182ed8 <USBD_STORAGE_Write+0x6c>
                           &WriteFlags, TX_WAIT_FOREVER) != TX_SUCCESS)
    {
      Error_Handler();
34182ed4:	f7fe fb74 	bl	341815c0 <Error_Handler>
    }
  }

  /* USER CODE END USBD_STORAGE_Write */

  return status;
34182ed8:	697b      	ldr	r3, [r7, #20]
}
34182eda:	4618      	mov	r0, r3
34182edc:	3718      	adds	r7, #24
34182ede:	46bd      	mov	sp, r7
34182ee0:	bd80      	pop	{r7, pc}
34182ee2:	bf00      	nop
34182ee4:	56023400 	.word	0x56023400
34182ee8:	341c1a3c 	.word	0x341c1a3c
34182eec:	341c1d64 	.word	0x341c1d64

34182ef0 <USBD_STORAGE_Flush>:
  *                       callback return value.
  * @retval status
  */
UINT USBD_STORAGE_Flush(VOID *storage_instance, ULONG lun, ULONG number_blocks,
                        ULONG lba, ULONG *media_status)
{
34182ef0:	b480      	push	{r7}
34182ef2:	b087      	sub	sp, #28
34182ef4:	af00      	add	r7, sp, #0
34182ef6:	60f8      	str	r0, [r7, #12]
34182ef8:	60b9      	str	r1, [r7, #8]
34182efa:	607a      	str	r2, [r7, #4]
34182efc:	603b      	str	r3, [r7, #0]
  UINT status = UX_SUCCESS;
34182efe:	2300      	movs	r3, #0
34182f00:	617b      	str	r3, [r7, #20]
  UX_PARAMETER_NOT_USED(number_blocks);
  UX_PARAMETER_NOT_USED(lba);
  UX_PARAMETER_NOT_USED(media_status);
  /* USER CODE END USBD_STORAGE_Flush */

  return status;
34182f02:	697b      	ldr	r3, [r7, #20]
}
34182f04:	4618      	mov	r0, r3
34182f06:	371c      	adds	r7, #28
34182f08:	46bd      	mov	sp, r7
34182f0a:	f85d 7b04 	ldr.w	r7, [sp], #4
34182f0e:	4770      	bx	lr

34182f10 <USBD_STORAGE_Status>:
  *                       callback return value.
  * @retval status
  */
UINT USBD_STORAGE_Status(VOID *storage_instance, ULONG lun, ULONG media_id,
                         ULONG *media_status)
{
34182f10:	b480      	push	{r7}
34182f12:	b087      	sub	sp, #28
34182f14:	af00      	add	r7, sp, #0
34182f16:	60f8      	str	r0, [r7, #12]
34182f18:	60b9      	str	r1, [r7, #8]
34182f1a:	607a      	str	r2, [r7, #4]
34182f1c:	603b      	str	r3, [r7, #0]
  UINT status = UX_SUCCESS;
34182f1e:	2300      	movs	r3, #0
34182f20:	617b      	str	r3, [r7, #20]
  UX_PARAMETER_NOT_USED(lun);
  UX_PARAMETER_NOT_USED(media_id);
  UX_PARAMETER_NOT_USED(media_status);
  /* USER CODE END USBD_STORAGE_Status */

  return status;
34182f22:	697b      	ldr	r3, [r7, #20]
}
34182f24:	4618      	mov	r0, r3
34182f26:	371c      	adds	r7, #28
34182f28:	46bd      	mov	sp, r7
34182f2a:	f85d 7b04 	ldr.w	r7, [sp], #4
34182f2e:	4770      	bx	lr

34182f30 <USBD_STORAGE_Notification>:
  * @retval status
  */
UINT USBD_STORAGE_Notification(VOID *storage_instance, ULONG lun, ULONG media_id,
                               ULONG notification_class, UCHAR **media_notification,
                               ULONG *media_notification_length)
{
34182f30:	b480      	push	{r7}
34182f32:	b087      	sub	sp, #28
34182f34:	af00      	add	r7, sp, #0
34182f36:	60f8      	str	r0, [r7, #12]
34182f38:	60b9      	str	r1, [r7, #8]
34182f3a:	607a      	str	r2, [r7, #4]
34182f3c:	603b      	str	r3, [r7, #0]
  UINT status = UX_SUCCESS;
34182f3e:	2300      	movs	r3, #0
34182f40:	617b      	str	r3, [r7, #20]
  UX_PARAMETER_NOT_USED(notification_class);
  UX_PARAMETER_NOT_USED(media_notification);
  UX_PARAMETER_NOT_USED(media_notification_length);
  /* USER CODE END USBD_STORAGE_Notification */

  return status;
34182f42:	697b      	ldr	r3, [r7, #20]
}
34182f44:	4618      	mov	r0, r3
34182f46:	371c      	adds	r7, #28
34182f48:	46bd      	mov	sp, r7
34182f4a:	f85d 7b04 	ldr.w	r7, [sp], #4
34182f4e:	4770      	bx	lr

34182f50 <USBD_STORAGE_GetMediaLastLba>:
  *         Get Media last LBA.
  * @param  none
  * @retval last lba
  */
ULONG USBD_STORAGE_GetMediaLastLba(VOID)
{
34182f50:	b480      	push	{r7}
34182f52:	b083      	sub	sp, #12
34182f54:	af00      	add	r7, sp, #0
  ULONG LastLba = 0U;
34182f56:	2300      	movs	r3, #0
34182f58:	607b      	str	r3, [r7, #4]

  /* USER CODE BEGIN USBD_STORAGE_GetMediaLastLba */

  LastLba = (ULONG)(USBD_SD_CardInfo.BlockNbr - 1);
34182f5a:	4b05      	ldr	r3, [pc, #20]	@ (34182f70 <USBD_STORAGE_GetMediaLastLba+0x20>)
34182f5c:	691b      	ldr	r3, [r3, #16]
34182f5e:	3b01      	subs	r3, #1
34182f60:	607b      	str	r3, [r7, #4]

  /* USER CODE END USBD_STORAGE_GetMediaLastLba */

  return LastLba;
34182f62:	687b      	ldr	r3, [r7, #4]
}
34182f64:	4618      	mov	r0, r3
34182f66:	370c      	adds	r7, #12
34182f68:	46bd      	mov	sp, r7
34182f6a:	f85d 7b04 	ldr.w	r7, [sp], #4
34182f6e:	4770      	bx	lr
34182f70:	341c1ab8 	.word	0x341c1ab8

34182f74 <USBD_STORAGE_GetMediaBlocklength>:
  *         Get Media block length.
  * @param  none.
  * @retval block length.
  */
ULONG USBD_STORAGE_GetMediaBlocklength(VOID)
{
34182f74:	b480      	push	{r7}
34182f76:	b083      	sub	sp, #12
34182f78:	af00      	add	r7, sp, #0
  ULONG MediaBlockLen = 0U;
34182f7a:	2300      	movs	r3, #0
34182f7c:	607b      	str	r3, [r7, #4]

  /* USER CODE BEGIN USBD_STORAGE_GetMediaBlocklength */

  MediaBlockLen = (ULONG) USBD_SD_CardInfo.BlockSize;
34182f7e:	4b05      	ldr	r3, [pc, #20]	@ (34182f94 <USBD_STORAGE_GetMediaBlocklength+0x20>)
34182f80:	695b      	ldr	r3, [r3, #20]
34182f82:	607b      	str	r3, [r7, #4]

  /* USER CODE END USBD_STORAGE_GetMediaBlocklength */

  return MediaBlockLen;
34182f84:	687b      	ldr	r3, [r7, #4]
}
34182f86:	4618      	mov	r0, r3
34182f88:	370c      	adds	r7, #12
34182f8a:	46bd      	mov	sp, r7
34182f8c:	f85d 7b04 	ldr.w	r7, [sp], #4
34182f90:	4770      	bx	lr
34182f92:	bf00      	nop
34182f94:	341c1ab8 	.word	0x341c1ab8

34182f98 <HAL_SD_TxCpltCallback>:
  *         BSP Tx Transfer completed callbacks
  * @param  Instance
  * @retval none
  */
void HAL_SD_TxCpltCallback(SD_HandleTypeDef *hsd)
{
34182f98:	b580      	push	{r7, lr}
34182f9a:	b082      	sub	sp, #8
34182f9c:	af00      	add	r7, sp, #0
34182f9e:	6078      	str	r0, [r7, #4]
  if (tx_event_flags_set(&EventFlag, SD_WRITE_FLAG, TX_OR) != TX_SUCCESS)
34182fa0:	2200      	movs	r2, #0
34182fa2:	2102      	movs	r1, #2
34182fa4:	4805      	ldr	r0, [pc, #20]	@ (34182fbc <HAL_SD_TxCpltCallback+0x24>)
34182fa6:	f015 fce3 	bl	34198970 <_txe_event_flags_set>
34182faa:	4603      	mov	r3, r0
34182fac:	2b00      	cmp	r3, #0
34182fae:	d001      	beq.n	34182fb4 <HAL_SD_TxCpltCallback+0x1c>
  {
    Error_Handler();
34182fb0:	f7fe fb06 	bl	341815c0 <Error_Handler>
  }
}
34182fb4:	bf00      	nop
34182fb6:	3708      	adds	r7, #8
34182fb8:	46bd      	mov	sp, r7
34182fba:	bd80      	pop	{r7, pc}
34182fbc:	341c1d64 	.word	0x341c1d64

34182fc0 <HAL_SD_RxCpltCallback>:
  *         BSP Rx Transfer completed callbacks
  * @param  Instance
  * @retval None
  */
void HAL_SD_RxCpltCallback(SD_HandleTypeDef *hsd)
{
34182fc0:	b580      	push	{r7, lr}
34182fc2:	b082      	sub	sp, #8
34182fc4:	af00      	add	r7, sp, #0
34182fc6:	6078      	str	r0, [r7, #4]
  if (tx_event_flags_set(&EventFlag, SD_READ_FLAG, TX_OR) != TX_SUCCESS)
34182fc8:	2200      	movs	r2, #0
34182fca:	2101      	movs	r1, #1
34182fcc:	4805      	ldr	r0, [pc, #20]	@ (34182fe4 <HAL_SD_RxCpltCallback+0x24>)
34182fce:	f015 fccf 	bl	34198970 <_txe_event_flags_set>
34182fd2:	4603      	mov	r3, r0
34182fd4:	2b00      	cmp	r3, #0
34182fd6:	d001      	beq.n	34182fdc <HAL_SD_RxCpltCallback+0x1c>
  {
    Error_Handler();
34182fd8:	f7fe faf2 	bl	341815c0 <Error_Handler>
  }
}
34182fdc:	bf00      	nop
34182fde:	3708      	adds	r7, #8
34182fe0:	46bd      	mov	sp, r7
34182fe2:	bd80      	pop	{r7, pc}
34182fe4:	341c1d64 	.word	0x341c1d64

34182fe8 <check_sd_status>:
  *         check SD card Transfer Status.
  * @param  none
  * @retval BSP status
  */
static int32_t check_sd_status(VOID)
{
34182fe8:	b580      	push	{r7, lr}
34182fea:	b082      	sub	sp, #8
34182fec:	af00      	add	r7, sp, #0
  uint32_t start = tx_time_get();
34182fee:	f015 f86f 	bl	341980d0 <_tx_time_get>
34182ff2:	6078      	str	r0, [r7, #4]

  while (tx_time_get() - start < SD_TIMEOUT)
34182ff4:	e007      	b.n	34183006 <check_sd_status+0x1e>
  {
    if (HAL_SD_GetCardState(&hsd1) == HAL_SD_CARD_TRANSFER)
34182ff6:	480a      	ldr	r0, [pc, #40]	@ (34183020 <check_sd_status+0x38>)
34182ff8:	f00c fdae 	bl	3418fb58 <HAL_SD_GetCardState>
34182ffc:	4603      	mov	r3, r0
34182ffe:	2b04      	cmp	r3, #4
34183000:	d101      	bne.n	34183006 <check_sd_status+0x1e>
    {
      return HAL_OK;
34183002:	2300      	movs	r3, #0
34183004:	e007      	b.n	34183016 <check_sd_status+0x2e>
  while (tx_time_get() - start < SD_TIMEOUT)
34183006:	f015 f863 	bl	341980d0 <_tx_time_get>
3418300a:	4602      	mov	r2, r0
3418300c:	687b      	ldr	r3, [r7, #4]
3418300e:	1ad3      	subs	r3, r2, r3
34183010:	2b63      	cmp	r3, #99	@ 0x63
34183012:	d9f0      	bls.n	34182ff6 <check_sd_status+0xe>
    }
  }

  return HAL_ERROR;
34183014:	2301      	movs	r3, #1
}
34183016:	4618      	mov	r0, r3
34183018:	3708      	adds	r7, #8
3418301a:	46bd      	mov	sp, r7
3418301c:	bd80      	pop	{r7, pc}
3418301e:	bf00      	nop
34183020:	341c1a3c 	.word	0x341c1a3c

34183024 <TCPP0203_RegisterBusIO>:
  * @brief  Register Bus Io to component
  * @param  Component object pointer
  * @retval Status of execution
  */
int32_t TCPP0203_RegisterBusIO(TCPP0203_Object_t *pObj, TCPP0203_IO_t *pIO)
{
34183024:	b580      	push	{r7, lr}
34183026:	b084      	sub	sp, #16
34183028:	af00      	add	r7, sp, #0
3418302a:	6078      	str	r0, [r7, #4]
3418302c:	6039      	str	r1, [r7, #0]
  int32_t ret;

  if (pObj == NULL)
3418302e:	687b      	ldr	r3, [r7, #4]
34183030:	2b00      	cmp	r3, #0
34183032:	d103      	bne.n	3418303c <TCPP0203_RegisterBusIO+0x18>
  {
    ret = TCPP0203_ERROR;
34183034:	f04f 33ff 	mov.w	r3, #4294967295
34183038:	60fb      	str	r3, [r7, #12]
3418303a:	e02c      	b.n	34183096 <TCPP0203_RegisterBusIO+0x72>
  }
  else
  {
    pObj->IO.Init      = pIO->Init;
3418303c:	683b      	ldr	r3, [r7, #0]
3418303e:	681a      	ldr	r2, [r3, #0]
34183040:	687b      	ldr	r3, [r7, #4]
34183042:	601a      	str	r2, [r3, #0]
    pObj->IO.DeInit    = pIO->DeInit;
34183044:	683b      	ldr	r3, [r7, #0]
34183046:	685a      	ldr	r2, [r3, #4]
34183048:	687b      	ldr	r3, [r7, #4]
3418304a:	605a      	str	r2, [r3, #4]
    pObj->IO.Address   = pIO->Address;
3418304c:	683b      	ldr	r3, [r7, #0]
3418304e:	891a      	ldrh	r2, [r3, #8]
34183050:	687b      	ldr	r3, [r7, #4]
34183052:	811a      	strh	r2, [r3, #8]
    pObj->IO.WriteReg  = pIO->WriteReg;
34183054:	683b      	ldr	r3, [r7, #0]
34183056:	68da      	ldr	r2, [r3, #12]
34183058:	687b      	ldr	r3, [r7, #4]
3418305a:	60da      	str	r2, [r3, #12]
    pObj->IO.ReadReg   = pIO->ReadReg;
3418305c:	683b      	ldr	r3, [r7, #0]
3418305e:	691a      	ldr	r2, [r3, #16]
34183060:	687b      	ldr	r3, [r7, #4]
34183062:	611a      	str	r2, [r3, #16]
    pObj->IO.GetTick   = pIO->GetTick;
34183064:	683b      	ldr	r3, [r7, #0]
34183066:	695a      	ldr	r2, [r3, #20]
34183068:	687b      	ldr	r3, [r7, #4]
3418306a:	615a      	str	r2, [r3, #20]

    pObj->Ctx.ReadReg  = TCPP0203_ReadRegWrap;
3418306c:	687b      	ldr	r3, [r7, #4]
3418306e:	4a0c      	ldr	r2, [pc, #48]	@ (341830a0 <TCPP0203_RegisterBusIO+0x7c>)
34183070:	61da      	str	r2, [r3, #28]
    pObj->Ctx.WriteReg = TCPP0203_WriteRegWrap;
34183072:	687b      	ldr	r3, [r7, #4]
34183074:	4a0b      	ldr	r2, [pc, #44]	@ (341830a4 <TCPP0203_RegisterBusIO+0x80>)
34183076:	619a      	str	r2, [r3, #24]
    pObj->Ctx.handle   = pObj;
34183078:	687b      	ldr	r3, [r7, #4]
3418307a:	687a      	ldr	r2, [r7, #4]
3418307c:	621a      	str	r2, [r3, #32]

    if (pObj->IO.Init != NULL)
3418307e:	687b      	ldr	r3, [r7, #4]
34183080:	681b      	ldr	r3, [r3, #0]
34183082:	2b00      	cmp	r3, #0
34183084:	d004      	beq.n	34183090 <TCPP0203_RegisterBusIO+0x6c>
    {
      ret = pObj->IO.Init();
34183086:	687b      	ldr	r3, [r7, #4]
34183088:	681b      	ldr	r3, [r3, #0]
3418308a:	4798      	blx	r3
3418308c:	60f8      	str	r0, [r7, #12]
3418308e:	e002      	b.n	34183096 <TCPP0203_RegisterBusIO+0x72>
    }
    else
    {
      ret = TCPP0203_ERROR;
34183090:	f04f 33ff 	mov.w	r3, #4294967295
34183094:	60fb      	str	r3, [r7, #12]
    }
  }

  return ret;
34183096:	68fb      	ldr	r3, [r7, #12]
}
34183098:	4618      	mov	r0, r3
3418309a:	3710      	adds	r7, #16
3418309c:	46bd      	mov	sp, r7
3418309e:	bd80      	pop	{r7, pc}
341830a0:	341836bf 	.word	0x341836bf
341830a4:	341836f5 	.word	0x341836f5

341830a8 <TCPP0203_Init>:
  * @brief  Initializes the TCPP0203 interface
  * @param  pObj Pointer to component object
  * @retval Component status (TCPP0203_OK / TCPP0203_ERROR)
  */
int32_t TCPP0203_Init(TCPP0203_Object_t *pObj)
{
341830a8:	b580      	push	{r7, lr}
341830aa:	b084      	sub	sp, #16
341830ac:	af00      	add	r7, sp, #0
341830ae:	6078      	str	r0, [r7, #4]
  int32_t ret = 0;
341830b0:	2300      	movs	r3, #0
341830b2:	60fb      	str	r3, [r7, #12]
  uint8_t tmp;

  if (pObj->IsInitialized == 0U)
341830b4:	687b      	ldr	r3, [r7, #4]
341830b6:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
341830ba:	2b00      	cmp	r3, #0
341830bc:	d11d      	bne.n	341830fa <TCPP0203_Init+0x52>
  {
    /* Read TCPP Device type */
    ret += tcpp0203_read_reg(&pObj->Ctx, TCPP0203_READ_REG2, &tmp, 1);
341830be:	687b      	ldr	r3, [r7, #4]
341830c0:	f103 0018 	add.w	r0, r3, #24
341830c4:	f107 020b 	add.w	r2, r7, #11
341830c8:	2301      	movs	r3, #1
341830ca:	2102      	movs	r1, #2
341830cc:	f000 fb63 	bl	34183796 <tcpp0203_read_reg>
341830d0:	4602      	mov	r2, r0
341830d2:	68fb      	ldr	r3, [r7, #12]
341830d4:	4413      	add	r3, r2
341830d6:	60fb      	str	r3, [r7, #12]

    if (ret == TCPP0203_OK)
341830d8:	68fb      	ldr	r3, [r7, #12]
341830da:	2b00      	cmp	r3, #0
341830dc:	d106      	bne.n	341830ec <TCPP0203_Init+0x44>
    {
      TCPP0203_DeviceType = (tmp & TCPP0203_DEVICE_TYPE_MSK);
341830de:	7afb      	ldrb	r3, [r7, #11]
341830e0:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
341830e4:	b2da      	uxtb	r2, r3
341830e6:	4b0a      	ldr	r3, [pc, #40]	@ (34183110 <TCPP0203_Init+0x68>)
341830e8:	701a      	strb	r2, [r3, #0]
341830ea:	e002      	b.n	341830f2 <TCPP0203_Init+0x4a>
    }
    else
    {
      TCPP0203_DeviceType = TCPP0203_DEVICE_TYPE_02;
341830ec:	4b08      	ldr	r3, [pc, #32]	@ (34183110 <TCPP0203_Init+0x68>)
341830ee:	2280      	movs	r2, #128	@ 0x80
341830f0:	701a      	strb	r2, [r3, #0]
    }
    pObj->IsInitialized = 1U;
341830f2:	687b      	ldr	r3, [r7, #4]
341830f4:	2201      	movs	r2, #1
341830f6:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
  }

  if (ret != TCPP0203_OK)
341830fa:	68fb      	ldr	r3, [r7, #12]
341830fc:	2b00      	cmp	r3, #0
341830fe:	d002      	beq.n	34183106 <TCPP0203_Init+0x5e>
  {
    ret = TCPP0203_ERROR;
34183100:	f04f 33ff 	mov.w	r3, #4294967295
34183104:	60fb      	str	r3, [r7, #12]
  }

  return ret;
34183106:	68fb      	ldr	r3, [r7, #12]
}
34183108:	4618      	mov	r0, r3
3418310a:	3710      	adds	r7, #16
3418310c:	46bd      	mov	sp, r7
3418310e:	bd80      	pop	{r7, pc}
34183110:	341c2278 	.word	0x341c2278

34183114 <TCPP0203_DeInit>:
  * @brief  Deinitializes the TCPP0203 interface
  * @param  pObj Pointer to component object
  * @retval Component status (TCPP0203_OK / TCPP0203_ERROR)
  */
int32_t TCPP0203_DeInit(TCPP0203_Object_t *pObj)
{
34183114:	b580      	push	{r7, lr}
34183116:	b082      	sub	sp, #8
34183118:	af00      	add	r7, sp, #0
3418311a:	6078      	str	r0, [r7, #4]
  if (pObj->IsInitialized == 1U)
3418311c:	687b      	ldr	r3, [r7, #4]
3418311e:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
34183122:	2b01      	cmp	r3, #1
34183124:	d106      	bne.n	34183134 <TCPP0203_DeInit+0x20>
  {
    /* De-Initialize IO BUS layer */
    pObj->IO.DeInit();
34183126:	687b      	ldr	r3, [r7, #4]
34183128:	685b      	ldr	r3, [r3, #4]
3418312a:	4798      	blx	r3

    pObj->IsInitialized = 0U;
3418312c:	687b      	ldr	r3, [r7, #4]
3418312e:	2200      	movs	r2, #0
34183130:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
  }

  return TCPP0203_OK;
34183134:	2300      	movs	r3, #0
}
34183136:	4618      	mov	r0, r3
34183138:	3708      	adds	r7, #8
3418313a:	46bd      	mov	sp, r7
3418313c:	bd80      	pop	{r7, pc}

3418313e <TCPP0203_Reset>:
  * @brief  Resets TCPP0203 register (Reg0)
  * @param  pObj Pointer to component object
  * @retval Component status (TCPP0203_OK / TCPP0203_ERROR)
  */
int32_t TCPP0203_Reset(TCPP0203_Object_t *pObj)
{
3418313e:	b580      	push	{r7, lr}
34183140:	b084      	sub	sp, #16
34183142:	af00      	add	r7, sp, #0
34183144:	6078      	str	r0, [r7, #4]
  int32_t ret = TCPP0203_OK;
34183146:	2300      	movs	r3, #0
34183148:	60fb      	str	r3, [r7, #12]
  uint8_t tmp = TCPP0203_REG0_RST_VALUE;
3418314a:	2300      	movs	r3, #0
3418314c:	72fb      	strb	r3, [r7, #11]

  /* Write reset values in Reg0 register */
  if (tcpp0203_write_reg(&pObj->Ctx, TCPP0203_PROG_CTRL, &tmp, 1) != TCPP0203_OK)
3418314e:	687b      	ldr	r3, [r7, #4]
34183150:	f103 0018 	add.w	r0, r3, #24
34183154:	f107 020b 	add.w	r2, r7, #11
34183158:	2301      	movs	r3, #1
3418315a:	2100      	movs	r1, #0
3418315c:	f000 fb32 	bl	341837c4 <tcpp0203_write_reg>
34183160:	4603      	mov	r3, r0
34183162:	2b00      	cmp	r3, #0
34183164:	d002      	beq.n	3418316c <TCPP0203_Reset+0x2e>
  {
    ret = TCPP0203_ERROR;
34183166:	f04f 33ff 	mov.w	r3, #4294967295
3418316a:	60fb      	str	r3, [r7, #12]
#if defined(TCPP0203_REGISTER_CONSISTENCY_CHECK)
  Reg0_Expected_Value = TCPP0203_REG0_RST_VALUE;
  Reg1_LastRead_Value = TCPP0203_REG0_RST_VALUE;
#endif /* TCPP0203_REGISTER_CONSISTENCY_CHECK */

  return ret;
3418316c:	68fb      	ldr	r3, [r7, #12]
}
3418316e:	4618      	mov	r0, r3
34183170:	3710      	adds	r7, #16
34183172:	46bd      	mov	sp, r7
34183174:	bd80      	pop	{r7, pc}

34183176 <TCPP0203_SetVConnSwitch>:
  *          @arg TCPP0203_VCONN_SWITCH_CC1  VConn closed on CC1
  *          @arg TCPP0203_VCONN_SWITCH_CC2  VConn closed on CC2
  * @retval Component status
  */
int32_t TCPP0203_SetVConnSwitch(TCPP0203_Object_t *pObj, uint8_t VConnSwitch)
{
34183176:	b580      	push	{r7, lr}
34183178:	b084      	sub	sp, #16
3418317a:	af00      	add	r7, sp, #0
3418317c:	6078      	str	r0, [r7, #4]
3418317e:	460b      	mov	r3, r1
34183180:	70fb      	strb	r3, [r7, #3]
  int32_t ret = TCPP0203_OK;
34183182:	2300      	movs	r3, #0
34183184:	60fb      	str	r3, [r7, #12]

  if ((VConnSwitch != TCPP0203_VCONN_SWITCH_OPEN)
34183186:	78fb      	ldrb	r3, [r7, #3]
34183188:	2b00      	cmp	r3, #0
3418318a:	d009      	beq.n	341831a0 <TCPP0203_SetVConnSwitch+0x2a>
      && (VConnSwitch != TCPP0203_VCONN_SWITCH_CC1)
3418318c:	78fb      	ldrb	r3, [r7, #3]
3418318e:	2b01      	cmp	r3, #1
34183190:	d006      	beq.n	341831a0 <TCPP0203_SetVConnSwitch+0x2a>
      && (VConnSwitch != TCPP0203_VCONN_SWITCH_CC2))
34183192:	78fb      	ldrb	r3, [r7, #3]
34183194:	2b02      	cmp	r3, #2
34183196:	d003      	beq.n	341831a0 <TCPP0203_SetVConnSwitch+0x2a>
  {
    ret = TCPP0203_ERROR;
34183198:	f04f 33ff 	mov.w	r3, #4294967295
3418319c:	60fb      	str	r3, [r7, #12]
3418319e:	e009      	b.n	341831b4 <TCPP0203_SetVConnSwitch+0x3e>
  }
  else
  {
    /* Update VConn switch setting in Writing register Reg0 */
    ret += TCPP0203_ModifyReg0(pObj, VConnSwitch, TCPP0203_VCONN_SWITCH_MSK);
341831a0:	78fb      	ldrb	r3, [r7, #3]
341831a2:	2203      	movs	r2, #3
341831a4:	4619      	mov	r1, r3
341831a6:	6878      	ldr	r0, [r7, #4]
341831a8:	f000 fabf 	bl	3418372a <TCPP0203_ModifyReg0>
341831ac:	4602      	mov	r2, r0
341831ae:	68fb      	ldr	r3, [r7, #12]
341831b0:	4413      	add	r3, r2
341831b2:	60fb      	str	r3, [r7, #12]
  }

  return ret;
341831b4:	68fb      	ldr	r3, [r7, #12]
}
341831b6:	4618      	mov	r0, r3
341831b8:	3710      	adds	r7, #16
341831ba:	46bd      	mov	sp, r7
341831bc:	bd80      	pop	{r7, pc}

341831be <TCPP0203_SetGateDriverProvider>:
  *          @arg TCPP0203_GD_PROVIDER_SWITCH_OPEN    GDP Switch Load Open
  *          @arg TCPP0203_GD_PROVIDER_SWITCH_CLOSED  GDP Switch Load closed
  * @retval Component status
  */
int32_t TCPP0203_SetGateDriverProvider(TCPP0203_Object_t *pObj, uint8_t GateDriverProvider)
{
341831be:	b580      	push	{r7, lr}
341831c0:	b084      	sub	sp, #16
341831c2:	af00      	add	r7, sp, #0
341831c4:	6078      	str	r0, [r7, #4]
341831c6:	460b      	mov	r3, r1
341831c8:	70fb      	strb	r3, [r7, #3]
  int32_t ret = TCPP0203_OK;
341831ca:	2300      	movs	r3, #0
341831cc:	60fb      	str	r3, [r7, #12]

  if ((GateDriverProvider != TCPP0203_GD_PROVIDER_SWITCH_OPEN)
341831ce:	78fb      	ldrb	r3, [r7, #3]
341831d0:	2b00      	cmp	r3, #0
341831d2:	d006      	beq.n	341831e2 <TCPP0203_SetGateDriverProvider+0x24>
      && (GateDriverProvider != TCPP0203_GD_PROVIDER_SWITCH_CLOSED))
341831d4:	78fb      	ldrb	r3, [r7, #3]
341831d6:	2b04      	cmp	r3, #4
341831d8:	d003      	beq.n	341831e2 <TCPP0203_SetGateDriverProvider+0x24>
  {
    ret = TCPP0203_ERROR;
341831da:	f04f 33ff 	mov.w	r3, #4294967295
341831de:	60fb      	str	r3, [r7, #12]
341831e0:	e01a      	b.n	34183218 <TCPP0203_SetGateDriverProvider+0x5a>
  }
  else
  {
    /* Update GDP Switch Load setting in Writing register Reg0 */
    if (GateDriverProvider == TCPP0203_GD_PROVIDER_SWITCH_CLOSED)
341831e2:	78fb      	ldrb	r3, [r7, #3]
341831e4:	2b04      	cmp	r3, #4
341831e6:	d10d      	bne.n	34183204 <TCPP0203_SetGateDriverProvider+0x46>
    {
      /* If Gate Driver Provider is to be closed, Gate Driver Consumer should be open */
      ret += TCPP0203_ModifyReg0(pObj, (GateDriverProvider | TCPP0203_GD_CONSUMER_SWITCH_OPEN),
341831e8:	78fb      	ldrb	r3, [r7, #3]
341831ea:	f043 0308 	orr.w	r3, r3, #8
341831ee:	b2db      	uxtb	r3, r3
341831f0:	220c      	movs	r2, #12
341831f2:	4619      	mov	r1, r3
341831f4:	6878      	ldr	r0, [r7, #4]
341831f6:	f000 fa98 	bl	3418372a <TCPP0203_ModifyReg0>
341831fa:	4602      	mov	r2, r0
341831fc:	68fb      	ldr	r3, [r7, #12]
341831fe:	4413      	add	r3, r2
34183200:	60fb      	str	r3, [r7, #12]
34183202:	e009      	b.n	34183218 <TCPP0203_SetGateDriverProvider+0x5a>
                                 (TCPP0203_GD_PROVIDER_SWITCH_MSK | TCPP0203_GD_CONSUMER_SWITCH_MSK));
    }
    else
    {
      ret += TCPP0203_ModifyReg0(pObj, GateDriverProvider, TCPP0203_GD_PROVIDER_SWITCH_MSK);
34183204:	78fb      	ldrb	r3, [r7, #3]
34183206:	2204      	movs	r2, #4
34183208:	4619      	mov	r1, r3
3418320a:	6878      	ldr	r0, [r7, #4]
3418320c:	f000 fa8d 	bl	3418372a <TCPP0203_ModifyReg0>
34183210:	4602      	mov	r2, r0
34183212:	68fb      	ldr	r3, [r7, #12]
34183214:	4413      	add	r3, r2
34183216:	60fb      	str	r3, [r7, #12]
    }
  }

  return ret;
34183218:	68fb      	ldr	r3, [r7, #12]
}
3418321a:	4618      	mov	r0, r3
3418321c:	3710      	adds	r7, #16
3418321e:	46bd      	mov	sp, r7
34183220:	bd80      	pop	{r7, pc}
	...

34183224 <TCPP0203_SetGateDriverConsumer>:
  *          @arg TCPP0203_GD_CONSUMER_SWITCH_OPEN    GDC Switch Load Open
  *          @arg TCPP0203_GD_CONSUMER_SWITCH_CLOSED  GDC Switch Load closed
  * @retval Component status
  */
int32_t TCPP0203_SetGateDriverConsumer(TCPP0203_Object_t *pObj, uint8_t GateDriverConsumer)
{
34183224:	b580      	push	{r7, lr}
34183226:	b084      	sub	sp, #16
34183228:	af00      	add	r7, sp, #0
3418322a:	6078      	str	r0, [r7, #4]
3418322c:	460b      	mov	r3, r1
3418322e:	70fb      	strb	r3, [r7, #3]
  int32_t ret = TCPP0203_OK;
34183230:	2300      	movs	r3, #0
34183232:	60fb      	str	r3, [r7, #12]

  /* Check if TCPP type is TCPP03. Otherwise, return error */
  if (TCPP0203_DeviceType != TCPP0203_DEVICE_TYPE_03)
34183234:	4b16      	ldr	r3, [pc, #88]	@ (34183290 <TCPP0203_SetGateDriverConsumer+0x6c>)
34183236:	781b      	ldrb	r3, [r3, #0]
34183238:	2b00      	cmp	r3, #0
3418323a:	d002      	beq.n	34183242 <TCPP0203_SetGateDriverConsumer+0x1e>
  {
    return (TCPP0203_ERROR);
3418323c:	f04f 33ff 	mov.w	r3, #4294967295
34183240:	e022      	b.n	34183288 <TCPP0203_SetGateDriverConsumer+0x64>
  }

  if ((GateDriverConsumer != TCPP0203_GD_CONSUMER_SWITCH_OPEN)
34183242:	78fb      	ldrb	r3, [r7, #3]
34183244:	2b08      	cmp	r3, #8
34183246:	d006      	beq.n	34183256 <TCPP0203_SetGateDriverConsumer+0x32>
      && (GateDriverConsumer != TCPP0203_GD_CONSUMER_SWITCH_CLOSED))
34183248:	78fb      	ldrb	r3, [r7, #3]
3418324a:	2b00      	cmp	r3, #0
3418324c:	d003      	beq.n	34183256 <TCPP0203_SetGateDriverConsumer+0x32>
  {
    ret = TCPP0203_ERROR;
3418324e:	f04f 33ff 	mov.w	r3, #4294967295
34183252:	60fb      	str	r3, [r7, #12]
34183254:	e017      	b.n	34183286 <TCPP0203_SetGateDriverConsumer+0x62>
  }
  else
  {
    /* Update GDC Switch Load setting in Writing register Reg0 */
    if (GateDriverConsumer == TCPP0203_GD_CONSUMER_SWITCH_CLOSED)
34183256:	78fb      	ldrb	r3, [r7, #3]
34183258:	2b00      	cmp	r3, #0
3418325a:	d10a      	bne.n	34183272 <TCPP0203_SetGateDriverConsumer+0x4e>
    {
      /* If Gate Driver Consumer is to be closed, Gate Driver Provider should be open */
      ret += TCPP0203_ModifyReg0(pObj, (GateDriverConsumer | TCPP0203_GD_PROVIDER_SWITCH_OPEN),
3418325c:	78fb      	ldrb	r3, [r7, #3]
3418325e:	220c      	movs	r2, #12
34183260:	4619      	mov	r1, r3
34183262:	6878      	ldr	r0, [r7, #4]
34183264:	f000 fa61 	bl	3418372a <TCPP0203_ModifyReg0>
34183268:	4602      	mov	r2, r0
3418326a:	68fb      	ldr	r3, [r7, #12]
3418326c:	4413      	add	r3, r2
3418326e:	60fb      	str	r3, [r7, #12]
34183270:	e009      	b.n	34183286 <TCPP0203_SetGateDriverConsumer+0x62>
                                 (TCPP0203_GD_PROVIDER_SWITCH_MSK | TCPP0203_GD_CONSUMER_SWITCH_MSK));
    }
    else
    {
      ret += TCPP0203_ModifyReg0(pObj, GateDriverConsumer, TCPP0203_GD_CONSUMER_SWITCH_MSK);
34183272:	78fb      	ldrb	r3, [r7, #3]
34183274:	2208      	movs	r2, #8
34183276:	4619      	mov	r1, r3
34183278:	6878      	ldr	r0, [r7, #4]
3418327a:	f000 fa56 	bl	3418372a <TCPP0203_ModifyReg0>
3418327e:	4602      	mov	r2, r0
34183280:	68fb      	ldr	r3, [r7, #12]
34183282:	4413      	add	r3, r2
34183284:	60fb      	str	r3, [r7, #12]
    }
  }

  return ret;
34183286:	68fb      	ldr	r3, [r7, #12]
}
34183288:	4618      	mov	r0, r3
3418328a:	3710      	adds	r7, #16
3418328c:	46bd      	mov	sp, r7
3418328e:	bd80      	pop	{r7, pc}
34183290:	341c2278 	.word	0x341c2278

34183294 <TCPP0203_SetPowerMode>:
  *          @arg TCPP0203_POWER_MODE_LOWPOWER     Low Power
  *          @arg TCPP0203_POWER_MODE_NORMAL       Normal
  * @retval Component status
  */
int32_t TCPP0203_SetPowerMode(TCPP0203_Object_t *pObj, uint8_t PowerMode)
{
34183294:	b580      	push	{r7, lr}
34183296:	b084      	sub	sp, #16
34183298:	af00      	add	r7, sp, #0
3418329a:	6078      	str	r0, [r7, #4]
3418329c:	460b      	mov	r3, r1
3418329e:	70fb      	strb	r3, [r7, #3]
  int32_t ret = TCPP0203_OK;
341832a0:	2300      	movs	r3, #0
341832a2:	60fb      	str	r3, [r7, #12]

  if ((PowerMode != TCPP0203_POWER_MODE_HIBERNATE)
341832a4:	78fb      	ldrb	r3, [r7, #3]
341832a6:	2b00      	cmp	r3, #0
341832a8:	d009      	beq.n	341832be <TCPP0203_SetPowerMode+0x2a>
      && (PowerMode != TCPP0203_POWER_MODE_LOWPOWER)
341832aa:	78fb      	ldrb	r3, [r7, #3]
341832ac:	2b20      	cmp	r3, #32
341832ae:	d006      	beq.n	341832be <TCPP0203_SetPowerMode+0x2a>
      && (PowerMode != TCPP0203_POWER_MODE_NORMAL))
341832b0:	78fb      	ldrb	r3, [r7, #3]
341832b2:	2b10      	cmp	r3, #16
341832b4:	d003      	beq.n	341832be <TCPP0203_SetPowerMode+0x2a>
  {
    ret = TCPP0203_ERROR;
341832b6:	f04f 33ff 	mov.w	r3, #4294967295
341832ba:	60fb      	str	r3, [r7, #12]
341832bc:	e009      	b.n	341832d2 <TCPP0203_SetPowerMode+0x3e>
  }
  else
  {
    /* Update Power Mode setting in Writing register Reg0 */
    ret += TCPP0203_ModifyReg0(pObj, PowerMode, TCPP0203_POWER_MODE_MSK);
341832be:	78fb      	ldrb	r3, [r7, #3]
341832c0:	2230      	movs	r2, #48	@ 0x30
341832c2:	4619      	mov	r1, r3
341832c4:	6878      	ldr	r0, [r7, #4]
341832c6:	f000 fa30 	bl	3418372a <TCPP0203_ModifyReg0>
341832ca:	4602      	mov	r2, r0
341832cc:	68fb      	ldr	r3, [r7, #12]
341832ce:	4413      	add	r3, r2
341832d0:	60fb      	str	r3, [r7, #12]
  }

  return ret;
341832d2:	68fb      	ldr	r3, [r7, #12]
}
341832d4:	4618      	mov	r0, r3
341832d6:	3710      	adds	r7, #16
341832d8:	46bd      	mov	sp, r7
341832da:	bd80      	pop	{r7, pc}

341832dc <TCPP0203_SetVBusDischarge>:
  *          @arg TCPP0203_VBUS_DISCHARGE_OFF    VBUS Discharge Off
  *          @arg TCPP0203_VBUS_DISCHARGE_ON     VBUS Discharge On
  * @retval Component status
  */
int32_t TCPP0203_SetVBusDischarge(TCPP0203_Object_t *pObj, uint8_t VBusDischarge)
{
341832dc:	b580      	push	{r7, lr}
341832de:	b084      	sub	sp, #16
341832e0:	af00      	add	r7, sp, #0
341832e2:	6078      	str	r0, [r7, #4]
341832e4:	460b      	mov	r3, r1
341832e6:	70fb      	strb	r3, [r7, #3]
  int32_t ret = TCPP0203_OK;
341832e8:	2300      	movs	r3, #0
341832ea:	60fb      	str	r3, [r7, #12]

  if ((VBusDischarge != TCPP0203_VBUS_DISCHARGE_OFF)
341832ec:	78fb      	ldrb	r3, [r7, #3]
341832ee:	2b00      	cmp	r3, #0
341832f0:	d006      	beq.n	34183300 <TCPP0203_SetVBusDischarge+0x24>
      && (VBusDischarge != TCPP0203_VBUS_DISCHARGE_ON))
341832f2:	78fb      	ldrb	r3, [r7, #3]
341832f4:	2b40      	cmp	r3, #64	@ 0x40
341832f6:	d003      	beq.n	34183300 <TCPP0203_SetVBusDischarge+0x24>
  {
    ret = TCPP0203_ERROR;
341832f8:	f04f 33ff 	mov.w	r3, #4294967295
341832fc:	60fb      	str	r3, [r7, #12]
341832fe:	e009      	b.n	34183314 <TCPP0203_SetVBusDischarge+0x38>
  }
  else
  {
    /* Update VBUS Discharge setting in Writing register Reg0 */
    ret += TCPP0203_ModifyReg0(pObj, VBusDischarge, TCPP0203_VBUS_DISCHARGE_MSK);
34183300:	78fb      	ldrb	r3, [r7, #3]
34183302:	2240      	movs	r2, #64	@ 0x40
34183304:	4619      	mov	r1, r3
34183306:	6878      	ldr	r0, [r7, #4]
34183308:	f000 fa0f 	bl	3418372a <TCPP0203_ModifyReg0>
3418330c:	4602      	mov	r2, r0
3418330e:	68fb      	ldr	r3, [r7, #12]
34183310:	4413      	add	r3, r2
34183312:	60fb      	str	r3, [r7, #12]
  }

  return ret;
34183314:	68fb      	ldr	r3, [r7, #12]
}
34183316:	4618      	mov	r0, r3
34183318:	3710      	adds	r7, #16
3418331a:	46bd      	mov	sp, r7
3418331c:	bd80      	pop	{r7, pc}

3418331e <TCPP0203_SetVConnDischarge>:
  *          @arg TCPP0203_VCONN_DISCHARGE_OFF    VConn Discharge Off
  *          @arg TCPP0203_VCONN_DISCHARGE_ON     VConn Discharge On
  * @retval Component status
  */
int32_t TCPP0203_SetVConnDischarge(TCPP0203_Object_t *pObj, uint8_t VConnDischarge)
{
3418331e:	b580      	push	{r7, lr}
34183320:	b084      	sub	sp, #16
34183322:	af00      	add	r7, sp, #0
34183324:	6078      	str	r0, [r7, #4]
34183326:	460b      	mov	r3, r1
34183328:	70fb      	strb	r3, [r7, #3]
  int32_t ret = TCPP0203_OK;
3418332a:	2300      	movs	r3, #0
3418332c:	60fb      	str	r3, [r7, #12]

  if ((VConnDischarge != TCPP0203_VCONN_DISCHARGE_OFF)
3418332e:	78fb      	ldrb	r3, [r7, #3]
34183330:	2b00      	cmp	r3, #0
34183332:	d006      	beq.n	34183342 <TCPP0203_SetVConnDischarge+0x24>
      && (VConnDischarge != TCPP0203_VCONN_DISCHARGE_ON))
34183334:	78fb      	ldrb	r3, [r7, #3]
34183336:	2b80      	cmp	r3, #128	@ 0x80
34183338:	d003      	beq.n	34183342 <TCPP0203_SetVConnDischarge+0x24>
  {
    ret = TCPP0203_ERROR;
3418333a:	f04f 33ff 	mov.w	r3, #4294967295
3418333e:	60fb      	str	r3, [r7, #12]
34183340:	e009      	b.n	34183356 <TCPP0203_SetVConnDischarge+0x38>
  }
  else
  {
    /* Update VConn Discharge setting in Writing register Reg0 */
    ret += TCPP0203_ModifyReg0(pObj, VConnDischarge, TCPP0203_VCONN_DISCHARGE_MSK);
34183342:	78fb      	ldrb	r3, [r7, #3]
34183344:	2280      	movs	r2, #128	@ 0x80
34183346:	4619      	mov	r1, r3
34183348:	6878      	ldr	r0, [r7, #4]
3418334a:	f000 f9ee 	bl	3418372a <TCPP0203_ModifyReg0>
3418334e:	4602      	mov	r2, r0
34183350:	68fb      	ldr	r3, [r7, #12]
34183352:	4413      	add	r3, r2
34183354:	60fb      	str	r3, [r7, #12]
  }

  return ret;
34183356:	68fb      	ldr	r3, [r7, #12]
}
34183358:	4618      	mov	r0, r3
3418335a:	3710      	adds	r7, #16
3418335c:	46bd      	mov	sp, r7
3418335e:	bd80      	pop	{r7, pc}

34183360 <TCPP0203_GetVConnSwitchAck>:
  *          @arg TCPP0203_VCONN_SWITCH_CC1  VConn closed on CC1 Ack
  *          @arg TCPP0203_VCONN_SWITCH_CC2  VConn closed on CC2 Ack
  * @retval Component status
  */
int32_t TCPP0203_GetVConnSwitchAck(TCPP0203_Object_t *pObj, uint8_t *pVConnSwitchAck)
{
34183360:	b580      	push	{r7, lr}
34183362:	b084      	sub	sp, #16
34183364:	af00      	add	r7, sp, #0
34183366:	6078      	str	r0, [r7, #4]
34183368:	6039      	str	r1, [r7, #0]
  int32_t ret;
  uint8_t tmp;

  ret = tcpp0203_read_reg(&pObj->Ctx, TCPP0203_ACK_REG, &tmp, 1);
3418336a:	687b      	ldr	r3, [r7, #4]
3418336c:	f103 0018 	add.w	r0, r3, #24
34183370:	f107 020b 	add.w	r2, r7, #11
34183374:	2301      	movs	r3, #1
34183376:	2101      	movs	r1, #1
34183378:	f000 fa0d 	bl	34183796 <tcpp0203_read_reg>
3418337c:	60f8      	str	r0, [r7, #12]
  *pVConnSwitchAck = (tmp & TCPP0203_VCONN_SWITCH_ACK_MSK);
3418337e:	7afb      	ldrb	r3, [r7, #11]
34183380:	f003 0303 	and.w	r3, r3, #3
34183384:	b2da      	uxtb	r2, r3
34183386:	683b      	ldr	r3, [r7, #0]
34183388:	701a      	strb	r2, [r3, #0]

  return ret;
3418338a:	68fb      	ldr	r3, [r7, #12]
}
3418338c:	4618      	mov	r0, r3
3418338e:	3710      	adds	r7, #16
34183390:	46bd      	mov	sp, r7
34183392:	bd80      	pop	{r7, pc}

34183394 <TCPP0203_GetGateDriverProviderAck>:
  *          @arg TCPP0203_GD_PROVIDER_SWITCH_ACK_OPEN    Gate Driver Provider Open Ack
  *          @arg TCPP0203_GD_PROVIDER_SWITCH_ACK_CLOSED  Gate Driver Provider Closed Ack
  * @retval Component status
  */
int32_t TCPP0203_GetGateDriverProviderAck(TCPP0203_Object_t *pObj, uint8_t *pGateDriverProviderAck)
{
34183394:	b580      	push	{r7, lr}
34183396:	b084      	sub	sp, #16
34183398:	af00      	add	r7, sp, #0
3418339a:	6078      	str	r0, [r7, #4]
3418339c:	6039      	str	r1, [r7, #0]
  int32_t ret;
  uint8_t tmp;

  ret = tcpp0203_read_reg(&pObj->Ctx, TCPP0203_ACK_REG, &tmp, 1);
3418339e:	687b      	ldr	r3, [r7, #4]
341833a0:	f103 0018 	add.w	r0, r3, #24
341833a4:	f107 020b 	add.w	r2, r7, #11
341833a8:	2301      	movs	r3, #1
341833aa:	2101      	movs	r1, #1
341833ac:	f000 f9f3 	bl	34183796 <tcpp0203_read_reg>
341833b0:	60f8      	str	r0, [r7, #12]
  *pGateDriverProviderAck = (tmp & TCPP0203_GD_PROVIDER_SWITCH_ACK_MSK);
341833b2:	7afb      	ldrb	r3, [r7, #11]
341833b4:	f003 0304 	and.w	r3, r3, #4
341833b8:	b2da      	uxtb	r2, r3
341833ba:	683b      	ldr	r3, [r7, #0]
341833bc:	701a      	strb	r2, [r3, #0]

  return ret;
341833be:	68fb      	ldr	r3, [r7, #12]
}
341833c0:	4618      	mov	r0, r3
341833c2:	3710      	adds	r7, #16
341833c4:	46bd      	mov	sp, r7
341833c6:	bd80      	pop	{r7, pc}

341833c8 <TCPP0203_GetGateDriverConsumerAck>:
  *          @arg TCPP0203_GD_CONSUMER_SWITCH_ACK_OPEN    Gate Driver Consumer Open Ack
  *          @arg TCPP0203_GD_CONSUMER_SWITCH_ACK_CLOSED  Gate Driver Consumer Closed Ack
  * @retval Component status
  */
int32_t TCPP0203_GetGateDriverConsumerAck(TCPP0203_Object_t *pObj, uint8_t *pGateDriverConsumerAck)
{
341833c8:	b580      	push	{r7, lr}
341833ca:	b084      	sub	sp, #16
341833cc:	af00      	add	r7, sp, #0
341833ce:	6078      	str	r0, [r7, #4]
341833d0:	6039      	str	r1, [r7, #0]
  int32_t ret;
  uint8_t tmp;

  /* Check if TCPP type is TCPP03. Otherwise, return error */
  if (TCPP0203_DeviceType != TCPP0203_DEVICE_TYPE_03)
341833d2:	4b0e      	ldr	r3, [pc, #56]	@ (3418340c <TCPP0203_GetGateDriverConsumerAck+0x44>)
341833d4:	781b      	ldrb	r3, [r3, #0]
341833d6:	2b00      	cmp	r3, #0
341833d8:	d002      	beq.n	341833e0 <TCPP0203_GetGateDriverConsumerAck+0x18>
  {
    return (TCPP0203_ERROR);
341833da:	f04f 33ff 	mov.w	r3, #4294967295
341833de:	e010      	b.n	34183402 <TCPP0203_GetGateDriverConsumerAck+0x3a>
  }

  ret = tcpp0203_read_reg(&pObj->Ctx, TCPP0203_ACK_REG, &tmp, 1);
341833e0:	687b      	ldr	r3, [r7, #4]
341833e2:	f103 0018 	add.w	r0, r3, #24
341833e6:	f107 020b 	add.w	r2, r7, #11
341833ea:	2301      	movs	r3, #1
341833ec:	2101      	movs	r1, #1
341833ee:	f000 f9d2 	bl	34183796 <tcpp0203_read_reg>
341833f2:	60f8      	str	r0, [r7, #12]
  *pGateDriverConsumerAck = (tmp & TCPP0203_GD_CONSUMER_SWITCH_ACK_MSK);
341833f4:	7afb      	ldrb	r3, [r7, #11]
341833f6:	f003 0308 	and.w	r3, r3, #8
341833fa:	b2da      	uxtb	r2, r3
341833fc:	683b      	ldr	r3, [r7, #0]
341833fe:	701a      	strb	r2, [r3, #0]

  return ret;
34183400:	68fb      	ldr	r3, [r7, #12]
}
34183402:	4618      	mov	r0, r3
34183404:	3710      	adds	r7, #16
34183406:	46bd      	mov	sp, r7
34183408:	bd80      	pop	{r7, pc}
3418340a:	bf00      	nop
3418340c:	341c2278 	.word	0x341c2278

34183410 <TCPP0203_GetPowerModeAck>:
  *          @arg TCPP0203_POWER_MODE_ACK_LOWPOWER   Power Mode Low Power Ack
  *          @arg TCPP0203_POWER_MODE_ACK_NORMAL     Power Mode Normal Ack
  * @retval Component status
  */
int32_t TCPP0203_GetPowerModeAck(TCPP0203_Object_t *pObj, uint8_t *pPowerModeAck)
{
34183410:	b580      	push	{r7, lr}
34183412:	b084      	sub	sp, #16
34183414:	af00      	add	r7, sp, #0
34183416:	6078      	str	r0, [r7, #4]
34183418:	6039      	str	r1, [r7, #0]
  int32_t ret;
  uint8_t tmp;

  ret = tcpp0203_read_reg(&pObj->Ctx, TCPP0203_ACK_REG, &tmp, 1);
3418341a:	687b      	ldr	r3, [r7, #4]
3418341c:	f103 0018 	add.w	r0, r3, #24
34183420:	f107 020b 	add.w	r2, r7, #11
34183424:	2301      	movs	r3, #1
34183426:	2101      	movs	r1, #1
34183428:	f000 f9b5 	bl	34183796 <tcpp0203_read_reg>
3418342c:	60f8      	str	r0, [r7, #12]
  *pPowerModeAck = (tmp & TCPP0203_POWER_MODE_ACK_MSK);
3418342e:	7afb      	ldrb	r3, [r7, #11]
34183430:	f003 0330 	and.w	r3, r3, #48	@ 0x30
34183434:	b2da      	uxtb	r2, r3
34183436:	683b      	ldr	r3, [r7, #0]
34183438:	701a      	strb	r2, [r3, #0]

  return ret;
3418343a:	68fb      	ldr	r3, [r7, #12]
}
3418343c:	4618      	mov	r0, r3
3418343e:	3710      	adds	r7, #16
34183440:	46bd      	mov	sp, r7
34183442:	bd80      	pop	{r7, pc}

34183444 <TCPP0203_GetVBusDischargeAck>:
  *          @arg TCPP0203_VBUS_DISCHARGE_ACK_OFF   VBUS Discharge Off Ack
  *          @arg TCPP0203_VBUS_DISCHARGE_ACK_ON    VBUS Discharge On Ack
  * @retval Component status
  */
int32_t TCPP0203_GetVBusDischargeAck(TCPP0203_Object_t *pObj, uint8_t *pVBusDischargeAck)
{
34183444:	b580      	push	{r7, lr}
34183446:	b084      	sub	sp, #16
34183448:	af00      	add	r7, sp, #0
3418344a:	6078      	str	r0, [r7, #4]
3418344c:	6039      	str	r1, [r7, #0]
  int32_t ret;
  uint8_t tmp;

  ret = tcpp0203_read_reg(&pObj->Ctx, TCPP0203_ACK_REG, &tmp, 1);
3418344e:	687b      	ldr	r3, [r7, #4]
34183450:	f103 0018 	add.w	r0, r3, #24
34183454:	f107 020b 	add.w	r2, r7, #11
34183458:	2301      	movs	r3, #1
3418345a:	2101      	movs	r1, #1
3418345c:	f000 f99b 	bl	34183796 <tcpp0203_read_reg>
34183460:	60f8      	str	r0, [r7, #12]
  *pVBusDischargeAck = (tmp & TCPP0203_VBUS_DISCHARGE_ACK_MSK);
34183462:	7afb      	ldrb	r3, [r7, #11]
34183464:	f003 0340 	and.w	r3, r3, #64	@ 0x40
34183468:	b2da      	uxtb	r2, r3
3418346a:	683b      	ldr	r3, [r7, #0]
3418346c:	701a      	strb	r2, [r3, #0]

  return ret;
3418346e:	68fb      	ldr	r3, [r7, #12]
}
34183470:	4618      	mov	r0, r3
34183472:	3710      	adds	r7, #16
34183474:	46bd      	mov	sp, r7
34183476:	bd80      	pop	{r7, pc}

34183478 <TCPP0203_GetVConnDischargeAck>:
  *          @arg TCPP0203_VCONN_DISCHARGE_ACK_OFF   VConn Discharge Off Ack
  *          @arg TCPP0203_VCONN_DISCHARGE_ACK_ON    VConn Discharge On Ack
  * @retval Component status
  */
int32_t TCPP0203_GetVConnDischargeAck(TCPP0203_Object_t *pObj, uint8_t *pVConnDischargeAck)
{
34183478:	b580      	push	{r7, lr}
3418347a:	b084      	sub	sp, #16
3418347c:	af00      	add	r7, sp, #0
3418347e:	6078      	str	r0, [r7, #4]
34183480:	6039      	str	r1, [r7, #0]
  int32_t ret;
  uint8_t tmp;

  ret = tcpp0203_read_reg(&pObj->Ctx, TCPP0203_ACK_REG, &tmp, 1);
34183482:	687b      	ldr	r3, [r7, #4]
34183484:	f103 0018 	add.w	r0, r3, #24
34183488:	f107 020b 	add.w	r2, r7, #11
3418348c:	2301      	movs	r3, #1
3418348e:	2101      	movs	r1, #1
34183490:	f000 f981 	bl	34183796 <tcpp0203_read_reg>
34183494:	60f8      	str	r0, [r7, #12]
  *pVConnDischargeAck = (tmp & TCPP0203_VCONN_DISCHARGE_ACK_MSK);
34183496:	7afb      	ldrb	r3, [r7, #11]
34183498:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
3418349c:	b2da      	uxtb	r2, r3
3418349e:	683b      	ldr	r3, [r7, #0]
341834a0:	701a      	strb	r2, [r3, #0]

  return ret;
341834a2:	68fb      	ldr	r3, [r7, #12]
}
341834a4:	4618      	mov	r0, r3
341834a6:	3710      	adds	r7, #16
341834a8:	46bd      	mov	sp, r7
341834aa:	bd80      	pop	{r7, pc}

341834ac <TCPP0203_GetOCPVConnFlag>:
  *          @arg TCPP0203_FLAG_OCP_VCONN_RESET   OCP VConn flag not set
  *          @arg TCPP0203_FLAG_OCP_VCONN_SET     OCP VConn flag set
  * @retval Component status
  */
int32_t TCPP0203_GetOCPVConnFlag(TCPP0203_Object_t *pObj, uint8_t *pOCPVConnFlag)
{
341834ac:	b580      	push	{r7, lr}
341834ae:	b084      	sub	sp, #16
341834b0:	af00      	add	r7, sp, #0
341834b2:	6078      	str	r0, [r7, #4]
341834b4:	6039      	str	r1, [r7, #0]
  int32_t ret;
  uint8_t tmp;

  ret = tcpp0203_read_reg(&pObj->Ctx, TCPP0203_FLAG_REG, &tmp, 1);
341834b6:	687b      	ldr	r3, [r7, #4]
341834b8:	f103 0018 	add.w	r0, r3, #24
341834bc:	f107 020b 	add.w	r2, r7, #11
341834c0:	2301      	movs	r3, #1
341834c2:	2102      	movs	r1, #2
341834c4:	f000 f967 	bl	34183796 <tcpp0203_read_reg>
341834c8:	60f8      	str	r0, [r7, #12]
  *pOCPVConnFlag = (tmp & TCPP0203_FLAG_OCP_VCONN_MSK);
341834ca:	7afb      	ldrb	r3, [r7, #11]
341834cc:	f003 0301 	and.w	r3, r3, #1
341834d0:	b2da      	uxtb	r2, r3
341834d2:	683b      	ldr	r3, [r7, #0]
341834d4:	701a      	strb	r2, [r3, #0]

  return ret;
341834d6:	68fb      	ldr	r3, [r7, #12]
}
341834d8:	4618      	mov	r0, r3
341834da:	3710      	adds	r7, #16
341834dc:	46bd      	mov	sp, r7
341834de:	bd80      	pop	{r7, pc}

341834e0 <TCPP0203_GetOCPVBusFlag>:
  *          @arg TCPP0203_FLAG_OCP_VBUS_RESET   OCP VBUS flag not set
  *          @arg TCPP0203_FLAG_OCP_VBUS_SET     OCP VBUS flag set
  * @retval Component status
  */
int32_t TCPP0203_GetOCPVBusFlag(TCPP0203_Object_t *pObj, uint8_t *pGetOCPVBusFlag)
{
341834e0:	b580      	push	{r7, lr}
341834e2:	b084      	sub	sp, #16
341834e4:	af00      	add	r7, sp, #0
341834e6:	6078      	str	r0, [r7, #4]
341834e8:	6039      	str	r1, [r7, #0]
  int32_t ret;
  uint8_t tmp;

  ret = tcpp0203_read_reg(&pObj->Ctx, TCPP0203_FLAG_REG, &tmp, 1);
341834ea:	687b      	ldr	r3, [r7, #4]
341834ec:	f103 0018 	add.w	r0, r3, #24
341834f0:	f107 020b 	add.w	r2, r7, #11
341834f4:	2301      	movs	r3, #1
341834f6:	2102      	movs	r1, #2
341834f8:	f000 f94d 	bl	34183796 <tcpp0203_read_reg>
341834fc:	60f8      	str	r0, [r7, #12]
  *pGetOCPVBusFlag = (tmp & TCPP0203_FLAG_OCP_VBUS_MSK);
341834fe:	7afb      	ldrb	r3, [r7, #11]
34183500:	f003 0302 	and.w	r3, r3, #2
34183504:	b2da      	uxtb	r2, r3
34183506:	683b      	ldr	r3, [r7, #0]
34183508:	701a      	strb	r2, [r3, #0]

  return ret;
3418350a:	68fb      	ldr	r3, [r7, #12]
}
3418350c:	4618      	mov	r0, r3
3418350e:	3710      	adds	r7, #16
34183510:	46bd      	mov	sp, r7
34183512:	bd80      	pop	{r7, pc}

34183514 <TCPP0203_GetOVPVBusFlag>:
  *          @arg TCPP0203_FLAG_OVP_VBUS_RESET   OVP VBUS flag not set
  *          @arg TCPP0203_FLAG_OVP_VBUS_SET     OVP VBUS flag set
  * @retval Component status
  */
int32_t TCPP0203_GetOVPVBusFlag(TCPP0203_Object_t *pObj, uint8_t *pOVPVBusFlag)
{
34183514:	b580      	push	{r7, lr}
34183516:	b084      	sub	sp, #16
34183518:	af00      	add	r7, sp, #0
3418351a:	6078      	str	r0, [r7, #4]
3418351c:	6039      	str	r1, [r7, #0]
  int32_t ret;
  uint8_t tmp;

  ret = tcpp0203_read_reg(&pObj->Ctx, TCPP0203_FLAG_REG, &tmp, 1);
3418351e:	687b      	ldr	r3, [r7, #4]
34183520:	f103 0018 	add.w	r0, r3, #24
34183524:	f107 020b 	add.w	r2, r7, #11
34183528:	2301      	movs	r3, #1
3418352a:	2102      	movs	r1, #2
3418352c:	f000 f933 	bl	34183796 <tcpp0203_read_reg>
34183530:	60f8      	str	r0, [r7, #12]
  *pOVPVBusFlag = (tmp & TCPP0203_FLAG_OVP_VBUS_MSK);
34183532:	7afb      	ldrb	r3, [r7, #11]
34183534:	f003 0304 	and.w	r3, r3, #4
34183538:	b2da      	uxtb	r2, r3
3418353a:	683b      	ldr	r3, [r7, #0]
3418353c:	701a      	strb	r2, [r3, #0]

  return ret;
3418353e:	68fb      	ldr	r3, [r7, #12]
}
34183540:	4618      	mov	r0, r3
34183542:	3710      	adds	r7, #16
34183544:	46bd      	mov	sp, r7
34183546:	bd80      	pop	{r7, pc}

34183548 <TCPP0203_GetOVPCCFlag>:
  *          @arg TCPP0203_FLAG_OVP_CC_RESET   OVP CC flag not set
  *          @arg TCPP0203_FLAG_OVP_CC_SET     OVP CC flag set
  * @retval Component status
  */
int32_t TCPP0203_GetOVPCCFlag(TCPP0203_Object_t *pObj, uint8_t *pOVPCCFlag)
{
34183548:	b580      	push	{r7, lr}
3418354a:	b084      	sub	sp, #16
3418354c:	af00      	add	r7, sp, #0
3418354e:	6078      	str	r0, [r7, #4]
34183550:	6039      	str	r1, [r7, #0]
  int32_t ret;
  uint8_t tmp;

  ret = tcpp0203_read_reg(&pObj->Ctx, TCPP0203_FLAG_REG, &tmp, 1);
34183552:	687b      	ldr	r3, [r7, #4]
34183554:	f103 0018 	add.w	r0, r3, #24
34183558:	f107 020b 	add.w	r2, r7, #11
3418355c:	2301      	movs	r3, #1
3418355e:	2102      	movs	r1, #2
34183560:	f000 f919 	bl	34183796 <tcpp0203_read_reg>
34183564:	60f8      	str	r0, [r7, #12]
  *pOVPCCFlag = (tmp & TCPP0203_FLAG_OVP_CC_MSK);
34183566:	7afb      	ldrb	r3, [r7, #11]
34183568:	f003 0308 	and.w	r3, r3, #8
3418356c:	b2da      	uxtb	r2, r3
3418356e:	683b      	ldr	r3, [r7, #0]
34183570:	701a      	strb	r2, [r3, #0]

  return ret;
34183572:	68fb      	ldr	r3, [r7, #12]
}
34183574:	4618      	mov	r0, r3
34183576:	3710      	adds	r7, #16
34183578:	46bd      	mov	sp, r7
3418357a:	bd80      	pop	{r7, pc}

3418357c <TCPP0203_GetOTPFlag>:
  *          @arg TCPP0203_FLAG_OTP_RESET   Over Temperature flag not set
  *          @arg TCPP0203_FLAG_OTP_SET     Over Temperature flag set
  * @retval Component status
  */
int32_t TCPP0203_GetOTPFlag(TCPP0203_Object_t *pObj, uint8_t *pOTPFlag)
{
3418357c:	b580      	push	{r7, lr}
3418357e:	b084      	sub	sp, #16
34183580:	af00      	add	r7, sp, #0
34183582:	6078      	str	r0, [r7, #4]
34183584:	6039      	str	r1, [r7, #0]
  int32_t ret;
  uint8_t tmp;

  ret = tcpp0203_read_reg(&pObj->Ctx, TCPP0203_FLAG_REG, &tmp, 1);
34183586:	687b      	ldr	r3, [r7, #4]
34183588:	f103 0018 	add.w	r0, r3, #24
3418358c:	f107 020b 	add.w	r2, r7, #11
34183590:	2301      	movs	r3, #1
34183592:	2102      	movs	r1, #2
34183594:	f000 f8ff 	bl	34183796 <tcpp0203_read_reg>
34183598:	60f8      	str	r0, [r7, #12]
  *pOTPFlag = (tmp & TCPP0203_FLAG_OTP_MSK);
3418359a:	7afb      	ldrb	r3, [r7, #11]
3418359c:	f003 0310 	and.w	r3, r3, #16
341835a0:	b2da      	uxtb	r2, r3
341835a2:	683b      	ldr	r3, [r7, #0]
341835a4:	701a      	strb	r2, [r3, #0]

  return ret;
341835a6:	68fb      	ldr	r3, [r7, #12]
}
341835a8:	4618      	mov	r0, r3
341835aa:	3710      	adds	r7, #16
341835ac:	46bd      	mov	sp, r7
341835ae:	bd80      	pop	{r7, pc}

341835b0 <TCPP0203_GetVBusOkFlag>:
  *          @arg TCPP0203_FLAG_VBUS_OK_RESET   VBUS OK flag not set
  *          @arg TCPP0203_FLAG_VBUS_OK_SET     VBUS OK flag set
  * @retval Component status
  */
int32_t TCPP0203_GetVBusOkFlag(TCPP0203_Object_t *pObj, uint8_t *pVBusOkFlag)
{
341835b0:	b580      	push	{r7, lr}
341835b2:	b084      	sub	sp, #16
341835b4:	af00      	add	r7, sp, #0
341835b6:	6078      	str	r0, [r7, #4]
341835b8:	6039      	str	r1, [r7, #0]
  int32_t ret;
  uint8_t tmp;

  ret = tcpp0203_read_reg(&pObj->Ctx, TCPP0203_FLAG_REG, &tmp, 1);
341835ba:	687b      	ldr	r3, [r7, #4]
341835bc:	f103 0018 	add.w	r0, r3, #24
341835c0:	f107 020b 	add.w	r2, r7, #11
341835c4:	2301      	movs	r3, #1
341835c6:	2102      	movs	r1, #2
341835c8:	f000 f8e5 	bl	34183796 <tcpp0203_read_reg>
341835cc:	60f8      	str	r0, [r7, #12]
  *pVBusOkFlag = (tmp & TCPP0203_FLAG_VBUS_OK_MSK);
341835ce:	7afb      	ldrb	r3, [r7, #11]
341835d0:	f003 0320 	and.w	r3, r3, #32
341835d4:	b2da      	uxtb	r2, r3
341835d6:	683b      	ldr	r3, [r7, #0]
341835d8:	701a      	strb	r2, [r3, #0]

  return ret;
341835da:	68fb      	ldr	r3, [r7, #12]
}
341835dc:	4618      	mov	r0, r3
341835de:	3710      	adds	r7, #16
341835e0:	46bd      	mov	sp, r7
341835e2:	bd80      	pop	{r7, pc}

341835e4 <TCPP0203_ReadTCPPType>:
  *          @arg TCPP0203_DEVICE_TYPE_02   TCPP02 Type
  *          @arg TCPP0203_DEVICE_TYPE_03   TCPP03 Type
  * @retval Component status
  */
int32_t TCPP0203_ReadTCPPType(TCPP0203_Object_t *pObj, uint8_t *pTCPPType)
{
341835e4:	b580      	push	{r7, lr}
341835e6:	b084      	sub	sp, #16
341835e8:	af00      	add	r7, sp, #0
341835ea:	6078      	str	r0, [r7, #4]
341835ec:	6039      	str	r1, [r7, #0]
  int32_t ret;
  uint8_t tmp;

  ret = tcpp0203_read_reg(&pObj->Ctx, TCPP0203_FLAG_REG, &tmp, 1);
341835ee:	687b      	ldr	r3, [r7, #4]
341835f0:	f103 0018 	add.w	r0, r3, #24
341835f4:	f107 020b 	add.w	r2, r7, #11
341835f8:	2301      	movs	r3, #1
341835fa:	2102      	movs	r1, #2
341835fc:	f000 f8cb 	bl	34183796 <tcpp0203_read_reg>
34183600:	60f8      	str	r0, [r7, #12]
  *pTCPPType = (tmp & TCPP0203_DEVICE_TYPE_MSK);
34183602:	7afb      	ldrb	r3, [r7, #11]
34183604:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
34183608:	b2da      	uxtb	r2, r3
3418360a:	683b      	ldr	r3, [r7, #0]
3418360c:	701a      	strb	r2, [r3, #0]

  return ret;
3418360e:	68fb      	ldr	r3, [r7, #12]
}
34183610:	4618      	mov	r0, r3
34183612:	3710      	adds	r7, #16
34183614:	46bd      	mov	sp, r7
34183616:	bd80      	pop	{r7, pc}

34183618 <TCPP0203_ReadVCONNPower>:
  *          @arg TCPP0203_FLAG_VCONN_PWR_1W       OCP VConn flag not set
  *          @arg TCPP0203_FLAG_VCONN_PWR_0_1W     OCP VConn flag set
  * @retval Component status
  */
int32_t TCPP0203_ReadVCONNPower(TCPP0203_Object_t *pObj, uint8_t *pVCONNPower)
{
34183618:	b580      	push	{r7, lr}
3418361a:	b084      	sub	sp, #16
3418361c:	af00      	add	r7, sp, #0
3418361e:	6078      	str	r0, [r7, #4]
34183620:	6039      	str	r1, [r7, #0]
  int32_t ret;
  uint8_t tmp;

  ret = tcpp0203_read_reg(&pObj->Ctx, TCPP0203_FLAG_REG, &tmp, 1);
34183622:	687b      	ldr	r3, [r7, #4]
34183624:	f103 0018 	add.w	r0, r3, #24
34183628:	f107 020b 	add.w	r2, r7, #11
3418362c:	2301      	movs	r3, #1
3418362e:	2102      	movs	r1, #2
34183630:	f000 f8b1 	bl	34183796 <tcpp0203_read_reg>
34183634:	60f8      	str	r0, [r7, #12]
  *pVCONNPower = (tmp & TCPP0203_FLAG_VCONN_PWR_MSK);
34183636:	7afb      	ldrb	r3, [r7, #11]
34183638:	f003 0340 	and.w	r3, r3, #64	@ 0x40
3418363c:	b2da      	uxtb	r2, r3
3418363e:	683b      	ldr	r3, [r7, #0]
34183640:	701a      	strb	r2, [r3, #0]

  return ret;
34183642:	68fb      	ldr	r3, [r7, #12]
}
34183644:	4618      	mov	r0, r3
34183646:	3710      	adds	r7, #16
34183648:	46bd      	mov	sp, r7
3418364a:	bd80      	pop	{r7, pc}

3418364c <TCPP0203_WriteCtrlRegister>:
  * @param  pObj Pointer to component object
  * @param  pCtrlRegister Pointer on Ctrl register value
  * @retval Component status
  */
int32_t TCPP0203_WriteCtrlRegister(TCPP0203_Object_t *pObj, uint8_t *pCtrlRegister)
{
3418364c:	b580      	push	{r7, lr}
3418364e:	b084      	sub	sp, #16
34183650:	af00      	add	r7, sp, #0
34183652:	6078      	str	r0, [r7, #4]
34183654:	6039      	str	r1, [r7, #0]
  int32_t ret;

  /* Update value in writing register (reg0) */
  ret = tcpp0203_write_reg(&pObj->Ctx, TCPP0203_PROG_CTRL, pCtrlRegister, 1);
34183656:	687b      	ldr	r3, [r7, #4]
34183658:	f103 0018 	add.w	r0, r3, #24
3418365c:	2301      	movs	r3, #1
3418365e:	683a      	ldr	r2, [r7, #0]
34183660:	2100      	movs	r1, #0
34183662:	f000 f8af 	bl	341837c4 <tcpp0203_write_reg>
34183666:	60f8      	str	r0, [r7, #12]

#if defined(TCPP0203_REGISTER_CONSISTENCY_CHECK)
  Reg0_Expected_Value = *pCtrlRegister;
#endif /* TCPP0203_REGISTER_CONSISTENCY_CHECK */

  return ret;
34183668:	68fb      	ldr	r3, [r7, #12]
}
3418366a:	4618      	mov	r0, r3
3418366c:	3710      	adds	r7, #16
3418366e:	46bd      	mov	sp, r7
34183670:	bd80      	pop	{r7, pc}

34183672 <TCPP0203_ReadAckRegister>:
  * @param  pObj Pointer to component object
  * @param  pAckRegister Pointer on Ack register value
  * @retval Component status
  */
int32_t TCPP0203_ReadAckRegister(TCPP0203_Object_t *pObj, uint8_t *pAckRegister)
{
34183672:	b580      	push	{r7, lr}
34183674:	b084      	sub	sp, #16
34183676:	af00      	add	r7, sp, #0
34183678:	6078      	str	r0, [r7, #4]
3418367a:	6039      	str	r1, [r7, #0]
  int32_t ret;

  ret = tcpp0203_read_reg(&pObj->Ctx, TCPP0203_ACK_REG, pAckRegister, 1);
3418367c:	687b      	ldr	r3, [r7, #4]
3418367e:	f103 0018 	add.w	r0, r3, #24
34183682:	2301      	movs	r3, #1
34183684:	683a      	ldr	r2, [r7, #0]
34183686:	2101      	movs	r1, #1
34183688:	f000 f885 	bl	34183796 <tcpp0203_read_reg>
3418368c:	60f8      	str	r0, [r7, #12]

  return ret;
3418368e:	68fb      	ldr	r3, [r7, #12]
}
34183690:	4618      	mov	r0, r3
34183692:	3710      	adds	r7, #16
34183694:	46bd      	mov	sp, r7
34183696:	bd80      	pop	{r7, pc}

34183698 <TCPP0203_ReadFlagRegister>:
  * @param  pObj Pointer to component object
  * @param  pFlagRegister Pointer on Flag register value
  * @retval Component status
  */
int32_t TCPP0203_ReadFlagRegister(TCPP0203_Object_t *pObj, uint8_t *pFlagRegister)
{
34183698:	b580      	push	{r7, lr}
3418369a:	b084      	sub	sp, #16
3418369c:	af00      	add	r7, sp, #0
3418369e:	6078      	str	r0, [r7, #4]
341836a0:	6039      	str	r1, [r7, #0]
  int32_t ret;

  ret = tcpp0203_read_reg(&pObj->Ctx, TCPP0203_FLAG_REG, pFlagRegister, 1);
341836a2:	687b      	ldr	r3, [r7, #4]
341836a4:	f103 0018 	add.w	r0, r3, #24
341836a8:	2301      	movs	r3, #1
341836aa:	683a      	ldr	r2, [r7, #0]
341836ac:	2102      	movs	r1, #2
341836ae:	f000 f872 	bl	34183796 <tcpp0203_read_reg>
341836b2:	60f8      	str	r0, [r7, #12]

  return ret;
341836b4:	68fb      	ldr	r3, [r7, #12]
}
341836b6:	4618      	mov	r0, r3
341836b8:	3710      	adds	r7, #16
341836ba:	46bd      	mov	sp, r7
341836bc:	bd80      	pop	{r7, pc}

341836be <TCPP0203_ReadRegWrap>:
  * @param  pData   Buffer where Target register value should be stored
  * @param  Length  buffer size to be read
  * @retval error status
  */
static int32_t TCPP0203_ReadRegWrap(void *handle, uint8_t Reg, uint8_t *pData, uint8_t Length)
{
341836be:	b590      	push	{r4, r7, lr}
341836c0:	b087      	sub	sp, #28
341836c2:	af00      	add	r7, sp, #0
341836c4:	60f8      	str	r0, [r7, #12]
341836c6:	607a      	str	r2, [r7, #4]
341836c8:	461a      	mov	r2, r3
341836ca:	460b      	mov	r3, r1
341836cc:	72fb      	strb	r3, [r7, #11]
341836ce:	4613      	mov	r3, r2
341836d0:	72bb      	strb	r3, [r7, #10]
  TCPP0203_Object_t *pObj = (TCPP0203_Object_t *)handle;
341836d2:	68fb      	ldr	r3, [r7, #12]
341836d4:	617b      	str	r3, [r7, #20]

  return pObj->IO.ReadReg(pObj->IO.Address, Reg, pData, Length);
341836d6:	697b      	ldr	r3, [r7, #20]
341836d8:	691c      	ldr	r4, [r3, #16]
341836da:	697b      	ldr	r3, [r7, #20]
341836dc:	8918      	ldrh	r0, [r3, #8]
341836de:	7afb      	ldrb	r3, [r7, #11]
341836e0:	b299      	uxth	r1, r3
341836e2:	7abb      	ldrb	r3, [r7, #10]
341836e4:	b29b      	uxth	r3, r3
341836e6:	687a      	ldr	r2, [r7, #4]
341836e8:	47a0      	blx	r4
341836ea:	4603      	mov	r3, r0
}
341836ec:	4618      	mov	r0, r3
341836ee:	371c      	adds	r7, #28
341836f0:	46bd      	mov	sp, r7
341836f2:	bd90      	pop	{r4, r7, pc}

341836f4 <TCPP0203_WriteRegWrap>:
  * @param  pData  Target register value to be written
  * @param  Length Buffer size to be written
  * @retval error status
  */
static int32_t TCPP0203_WriteRegWrap(void *handle, uint8_t Reg, uint8_t *pData, uint8_t Length)
{
341836f4:	b590      	push	{r4, r7, lr}
341836f6:	b087      	sub	sp, #28
341836f8:	af00      	add	r7, sp, #0
341836fa:	60f8      	str	r0, [r7, #12]
341836fc:	607a      	str	r2, [r7, #4]
341836fe:	461a      	mov	r2, r3
34183700:	460b      	mov	r3, r1
34183702:	72fb      	strb	r3, [r7, #11]
34183704:	4613      	mov	r3, r2
34183706:	72bb      	strb	r3, [r7, #10]
  TCPP0203_Object_t *pObj = (TCPP0203_Object_t *)handle;
34183708:	68fb      	ldr	r3, [r7, #12]
3418370a:	617b      	str	r3, [r7, #20]

#if defined(TCPP0203_REGISTER_CONSISTENCY_CHECK)
  Reg0_Expected_Value = *pData;
#endif /* TCPP0203_REGISTER_CONSISTENCY_CHECK */

  return pObj->IO.WriteReg(pObj->IO.Address, Reg, pData, Length);
3418370c:	697b      	ldr	r3, [r7, #20]
3418370e:	68dc      	ldr	r4, [r3, #12]
34183710:	697b      	ldr	r3, [r7, #20]
34183712:	8918      	ldrh	r0, [r3, #8]
34183714:	7afb      	ldrb	r3, [r7, #11]
34183716:	b299      	uxth	r1, r3
34183718:	7abb      	ldrb	r3, [r7, #10]
3418371a:	b29b      	uxth	r3, r3
3418371c:	687a      	ldr	r2, [r7, #4]
3418371e:	47a0      	blx	r4
34183720:	4603      	mov	r3, r0
}
34183722:	4618      	mov	r0, r3
34183724:	371c      	adds	r7, #28
34183726:	46bd      	mov	sp, r7
34183728:	bd90      	pop	{r4, r7, pc}

3418372a <TCPP0203_ModifyReg0>:
  * @param  pData  Target register value to be written
  * @param  Length Buffer size to be written
  * @retval error status
  */
static int32_t TCPP0203_ModifyReg0(TCPP0203_Object_t *pObj, uint8_t Value, uint8_t Mask)
{
3418372a:	b580      	push	{r7, lr}
3418372c:	b084      	sub	sp, #16
3418372e:	af00      	add	r7, sp, #0
34183730:	6078      	str	r0, [r7, #4]
34183732:	460b      	mov	r3, r1
34183734:	70fb      	strb	r3, [r7, #3]
34183736:	4613      	mov	r3, r2
34183738:	70bb      	strb	r3, [r7, #2]
  int32_t ret;
  uint8_t tmp;

  /* Read current content of ACK register (reflects content of bits set to 1 in Writing register Reg0) */
  ret = tcpp0203_read_reg(&pObj->Ctx, TCPP0203_ACK_REG, &tmp, 1);
3418373a:	687b      	ldr	r3, [r7, #4]
3418373c:	f103 0018 	add.w	r0, r3, #24
34183740:	f107 020b 	add.w	r2, r7, #11
34183744:	2301      	movs	r3, #1
34183746:	2101      	movs	r1, #1
34183748:	f000 f825 	bl	34183796 <tcpp0203_read_reg>
3418374c:	60f8      	str	r0, [r7, #12]

  /* Update only the area dedicated to Mask */
  tmp &= ~(Mask);
3418374e:	f997 3002 	ldrsb.w	r3, [r7, #2]
34183752:	43db      	mvns	r3, r3
34183754:	b25a      	sxtb	r2, r3
34183756:	7afb      	ldrb	r3, [r7, #11]
34183758:	b25b      	sxtb	r3, r3
3418375a:	4013      	ands	r3, r2
3418375c:	b25b      	sxtb	r3, r3
3418375e:	b2db      	uxtb	r3, r3
34183760:	72fb      	strb	r3, [r7, #11]
  tmp |= (Value & Mask);
34183762:	78fa      	ldrb	r2, [r7, #3]
34183764:	78bb      	ldrb	r3, [r7, #2]
34183766:	4013      	ands	r3, r2
34183768:	b2da      	uxtb	r2, r3
3418376a:	7afb      	ldrb	r3, [r7, #11]
3418376c:	4313      	orrs	r3, r2
3418376e:	b2db      	uxtb	r3, r3
34183770:	72fb      	strb	r3, [r7, #11]
#if defined(TCPP0203_REGISTER_CONSISTENCY_CHECK)
  Reg0_Expected_Value = tmp;
#endif /* TCPP0203_REGISTER_CONSISTENCY_CHECK */

  /* Update value in writing register (reg0) */
  ret += tcpp0203_write_reg(&pObj->Ctx, TCPP0203_PROG_CTRL, &tmp, 1);
34183772:	687b      	ldr	r3, [r7, #4]
34183774:	f103 0018 	add.w	r0, r3, #24
34183778:	f107 020b 	add.w	r2, r7, #11
3418377c:	2301      	movs	r3, #1
3418377e:	2100      	movs	r1, #0
34183780:	f000 f820 	bl	341837c4 <tcpp0203_write_reg>
34183784:	4602      	mov	r2, r0
34183786:	68fb      	ldr	r3, [r7, #12]
34183788:	4413      	add	r3, r2
3418378a:	60fb      	str	r3, [r7, #12]

#if defined(TCPP0203_REGISTER_CONSISTENCY_CHECK)
  ret += TCPP0203_CheckReg0Reg1(pObj, Reg0_Expected_Value);
#endif /* TCPP0203_REGISTER_CONSISTENCY_CHECK */

  return ret;
3418378c:	68fb      	ldr	r3, [r7, #12]
}
3418378e:	4618      	mov	r0, r3
34183790:	3710      	adds	r7, #16
34183792:	46bd      	mov	sp, r7
34183794:	bd80      	pop	{r7, pc}

34183796 <tcpp0203_read_reg>:
  *                 I2C or SPI reading functions
  * Input         : Register Address, length of buffer
  * Output        : data Read
  *******************************************************************************/
int32_t tcpp0203_read_reg(TCPP0203_ctx_t *ctx, uint8_t reg, uint8_t *data, uint8_t length)
{
34183796:	b590      	push	{r4, r7, lr}
34183798:	b085      	sub	sp, #20
3418379a:	af00      	add	r7, sp, #0
3418379c:	60f8      	str	r0, [r7, #12]
3418379e:	607a      	str	r2, [r7, #4]
341837a0:	461a      	mov	r2, r3
341837a2:	460b      	mov	r3, r1
341837a4:	72fb      	strb	r3, [r7, #11]
341837a6:	4613      	mov	r3, r2
341837a8:	72bb      	strb	r3, [r7, #10]
  return ctx->ReadReg(ctx->handle, reg, data, length);
341837aa:	68fb      	ldr	r3, [r7, #12]
341837ac:	685c      	ldr	r4, [r3, #4]
341837ae:	68fb      	ldr	r3, [r7, #12]
341837b0:	6898      	ldr	r0, [r3, #8]
341837b2:	7abb      	ldrb	r3, [r7, #10]
341837b4:	7af9      	ldrb	r1, [r7, #11]
341837b6:	687a      	ldr	r2, [r7, #4]
341837b8:	47a0      	blx	r4
341837ba:	4603      	mov	r3, r0
}
341837bc:	4618      	mov	r0, r3
341837be:	3714      	adds	r7, #20
341837c0:	46bd      	mov	sp, r7
341837c2:	bd90      	pop	{r4, r7, pc}

341837c4 <tcpp0203_write_reg>:
  *                 I2C or SPI writing function
  * Input         : Register Address, data to be written, length of buffer
  * Output        : None
  *******************************************************************************/
int32_t tcpp0203_write_reg(TCPP0203_ctx_t *ctx, uint8_t reg, uint8_t *data, uint8_t length)
{
341837c4:	b590      	push	{r4, r7, lr}
341837c6:	b085      	sub	sp, #20
341837c8:	af00      	add	r7, sp, #0
341837ca:	60f8      	str	r0, [r7, #12]
341837cc:	607a      	str	r2, [r7, #4]
341837ce:	461a      	mov	r2, r3
341837d0:	460b      	mov	r3, r1
341837d2:	72fb      	strb	r3, [r7, #11]
341837d4:	4613      	mov	r3, r2
341837d6:	72bb      	strb	r3, [r7, #10]
  return ctx->WriteReg(ctx->handle, reg, data, length);
341837d8:	68fb      	ldr	r3, [r7, #12]
341837da:	681c      	ldr	r4, [r3, #0]
341837dc:	68fb      	ldr	r3, [r7, #12]
341837de:	6898      	ldr	r0, [r3, #8]
341837e0:	7abb      	ldrb	r3, [r7, #10]
341837e2:	7af9      	ldrb	r1, [r7, #11]
341837e4:	687a      	ldr	r2, [r7, #4]
341837e6:	47a0      	blx	r4
341837e8:	4603      	mov	r3, r0
}
341837ea:	4618      	mov	r0, r3
341837ec:	3714      	adds	r7, #20
341837ee:	46bd      	mov	sp, r7
341837f0:	bd90      	pop	{r4, r7, pc}
	...

341837f4 <LL_AHB4_GRP1_EnableClock>:
{
341837f4:	b480      	push	{r7}
341837f6:	b085      	sub	sp, #20
341837f8:	af00      	add	r7, sp, #0
341837fa:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB4ENSR, Periphs);
341837fc:	4a07      	ldr	r2, [pc, #28]	@ (3418381c <LL_AHB4_GRP1_EnableClock+0x28>)
341837fe:	687b      	ldr	r3, [r7, #4]
34183800:	f8c2 3a5c 	str.w	r3, [r2, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
34183804:	4b05      	ldr	r3, [pc, #20]	@ (3418381c <LL_AHB4_GRP1_EnableClock+0x28>)
34183806:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
3418380a:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
3418380c:	68fb      	ldr	r3, [r7, #12]
}
3418380e:	bf00      	nop
34183810:	3714      	adds	r7, #20
34183812:	46bd      	mov	sp, r7
34183814:	f85d 7b04 	ldr.w	r7, [sp], #4
34183818:	4770      	bx	lr
3418381a:	bf00      	nop
3418381c:	56028000 	.word	0x56028000

34183820 <LL_APB1_GRP1_EnableClock>:
{
34183820:	b480      	push	{r7}
34183822:	b085      	sub	sp, #20
34183824:	af00      	add	r7, sp, #0
34183826:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->APB1ENSR1, Periphs);
34183828:	4a07      	ldr	r2, [pc, #28]	@ (34183848 <LL_APB1_GRP1_EnableClock+0x28>)
3418382a:	687b      	ldr	r3, [r7, #4]
3418382c:	f8c2 3a64 	str.w	r3, [r2, #2660]	@ 0xa64
  tmpreg = READ_REG(RCC->APB1ENR1);
34183830:	4b05      	ldr	r3, [pc, #20]	@ (34183848 <LL_APB1_GRP1_EnableClock+0x28>)
34183832:	f8d3 3264 	ldr.w	r3, [r3, #612]	@ 0x264
34183836:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34183838:	68fb      	ldr	r3, [r7, #12]
}
3418383a:	bf00      	nop
3418383c:	3714      	adds	r7, #20
3418383e:	46bd      	mov	sp, r7
34183840:	f85d 7b04 	ldr.w	r7, [sp], #4
34183844:	4770      	bx	lr
34183846:	bf00      	nop
34183848:	56028000 	.word	0x56028000

3418384c <LL_APB1_GRP1_DisableClock>:
{
3418384c:	b480      	push	{r7}
3418384e:	b083      	sub	sp, #12
34183850:	af00      	add	r7, sp, #0
34183852:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->APB1ENCR1, Periphs);
34183854:	4b06      	ldr	r3, [pc, #24]	@ (34183870 <LL_APB1_GRP1_DisableClock+0x24>)
34183856:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3418385a:	461a      	mov	r2, r3
3418385c:	687b      	ldr	r3, [r7, #4]
3418385e:	f8c2 3264 	str.w	r3, [r2, #612]	@ 0x264
}
34183862:	bf00      	nop
34183864:	370c      	adds	r7, #12
34183866:	46bd      	mov	sp, r7
34183868:	f85d 7b04 	ldr.w	r7, [sp], #4
3418386c:	4770      	bx	lr
3418386e:	bf00      	nop
34183870:	56028000 	.word	0x56028000

34183874 <LL_APB1_GRP1_ForceReset>:
{
34183874:	b480      	push	{r7}
34183876:	b083      	sub	sp, #12
34183878:	af00      	add	r7, sp, #0
3418387a:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->APB1RSTSR1, Periphs);
3418387c:	4a04      	ldr	r2, [pc, #16]	@ (34183890 <LL_APB1_GRP1_ForceReset+0x1c>)
3418387e:	687b      	ldr	r3, [r7, #4]
34183880:	f8c2 3a24 	str.w	r3, [r2, #2596]	@ 0xa24
}
34183884:	bf00      	nop
34183886:	370c      	adds	r7, #12
34183888:	46bd      	mov	sp, r7
3418388a:	f85d 7b04 	ldr.w	r7, [sp], #4
3418388e:	4770      	bx	lr
34183890:	56028000 	.word	0x56028000

34183894 <LL_APB1_GRP1_ReleaseReset>:
{
34183894:	b480      	push	{r7}
34183896:	b083      	sub	sp, #12
34183898:	af00      	add	r7, sp, #0
3418389a:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->APB1RSTCR1, Periphs);
3418389c:	4b06      	ldr	r3, [pc, #24]	@ (341838b8 <LL_APB1_GRP1_ReleaseReset+0x24>)
3418389e:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
341838a2:	461a      	mov	r2, r3
341838a4:	687b      	ldr	r3, [r7, #4]
341838a6:	f8c2 3224 	str.w	r3, [r2, #548]	@ 0x224
}
341838aa:	bf00      	nop
341838ac:	370c      	adds	r7, #12
341838ae:	46bd      	mov	sp, r7
341838b0:	f85d 7b04 	ldr.w	r7, [sp], #4
341838b4:	4770      	bx	lr
341838b6:	bf00      	nop
341838b8:	56028000 	.word	0x56028000

341838bc <BSP_I2C2_Init>:
/**
  * @brief  Initializes I2C HAL.
  * @retval BSP status
  */
int32_t BSP_I2C2_Init(void)
{
341838bc:	b580      	push	{r7, lr}
341838be:	b082      	sub	sp, #8
341838c0:	af00      	add	r7, sp, #0
  int32_t ret = BSP_ERROR_NONE;
341838c2:	2300      	movs	r3, #0
341838c4:	607b      	str	r3, [r7, #4]

  hbus_i2c2.Instance = BUS_I2C2;
341838c6:	4b16      	ldr	r3, [pc, #88]	@ (34183920 <BSP_I2C2_Init+0x64>)
341838c8:	4a16      	ldr	r2, [pc, #88]	@ (34183924 <BSP_I2C2_Init+0x68>)
341838ca:	601a      	str	r2, [r3, #0]

  if (I2c2InitCounter == 0U)
341838cc:	4b16      	ldr	r3, [pc, #88]	@ (34183928 <BSP_I2C2_Init+0x6c>)
341838ce:	681b      	ldr	r3, [r3, #0]
341838d0:	2b00      	cmp	r3, #0
341838d2:	d11f      	bne.n	34183914 <BSP_I2C2_Init+0x58>
  {
    I2c2InitCounter++;
341838d4:	4b14      	ldr	r3, [pc, #80]	@ (34183928 <BSP_I2C2_Init+0x6c>)
341838d6:	681b      	ldr	r3, [r3, #0]
341838d8:	3301      	adds	r3, #1
341838da:	4a13      	ldr	r2, [pc, #76]	@ (34183928 <BSP_I2C2_Init+0x6c>)
341838dc:	6013      	str	r3, [r2, #0]

    if (HAL_I2C_GetState(&hbus_i2c2) == HAL_I2C_STATE_RESET)
341838de:	4810      	ldr	r0, [pc, #64]	@ (34183920 <BSP_I2C2_Init+0x64>)
341838e0:	f004 f91a 	bl	34187b18 <HAL_I2C_GetState>
341838e4:	4603      	mov	r3, r0
341838e6:	2b00      	cmp	r3, #0
341838e8:	d114      	bne.n	34183914 <BSP_I2C2_Init+0x58>
        BspI2cSemaphore = osSemaphoreCreate(osSemaphore(BSP_I2C_SEM), 1);
      }
#endif /* BSP_USE_CMSIS_OS */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 0)
      /* Init the I2C2 Msp */
      I2C2_MspInit(&hbus_i2c2);
341838ea:	480d      	ldr	r0, [pc, #52]	@ (34183920 <BSP_I2C2_Init+0x64>)
341838ec:	f000 fb60 	bl	34183fb0 <I2C2_MspInit>
        }
      }
      if (ret == BSP_ERROR_NONE)
      {
#endif /* (USE_HAL_I2C_REGISTER_CALLBACKS == 0) */
        if (MX_I2C2_Init(&hbus_i2c2, I2C_GetTiming(HAL_RCC_GetPCLK1Freq(), BUS_I2C2_FREQUENCY)) != HAL_OK)
341838f0:	f007 f99d 	bl	3418ac2e <HAL_RCC_GetPCLK1Freq>
341838f4:	4603      	mov	r3, r0
341838f6:	490d      	ldr	r1, [pc, #52]	@ (3418392c <BSP_I2C2_Init+0x70>)
341838f8:	4618      	mov	r0, r3
341838fa:	f000 f8e3 	bl	34183ac4 <I2C_GetTiming>
341838fe:	4603      	mov	r3, r0
34183900:	4619      	mov	r1, r3
34183902:	4807      	ldr	r0, [pc, #28]	@ (34183920 <BSP_I2C2_Init+0x64>)
34183904:	f000 f838 	bl	34183978 <MX_I2C2_Init>
34183908:	4603      	mov	r3, r0
3418390a:	2b00      	cmp	r3, #0
3418390c:	d002      	beq.n	34183914 <BSP_I2C2_Init+0x58>
        {
          ret = BSP_ERROR_BUS_FAILURE;
3418390e:	f06f 0307 	mvn.w	r3, #7
34183912:	607b      	str	r3, [r7, #4]
      }
#endif /* (USE_HAL_I2C_REGISTER_CALLBACKS == 1) */
    }
  }

  return ret;
34183914:	687b      	ldr	r3, [r7, #4]
}
34183916:	4618      	mov	r0, r3
34183918:	3708      	adds	r7, #8
3418391a:	46bd      	mov	sp, r7
3418391c:	bd80      	pop	{r7, pc}
3418391e:	bf00      	nop
34183920:	341c2c84 	.word	0x341c2c84
34183924:	50005800 	.word	0x50005800
34183928:	341c227c 	.word	0x341c227c
3418392c:	000186a0 	.word	0x000186a0

34183930 <BSP_I2C2_DeInit>:
/**
  * @brief  DeInitializes I2C HAL.
  * @retval BSP status
  */
int32_t BSP_I2C2_DeInit(void)
{
34183930:	b580      	push	{r7, lr}
34183932:	b082      	sub	sp, #8
34183934:	af00      	add	r7, sp, #0
  int32_t ret = BSP_ERROR_NONE;
34183936:	2300      	movs	r3, #0
34183938:	607b      	str	r3, [r7, #4]

  I2c2InitCounter--;
3418393a:	4b0d      	ldr	r3, [pc, #52]	@ (34183970 <BSP_I2C2_DeInit+0x40>)
3418393c:	681b      	ldr	r3, [r3, #0]
3418393e:	3b01      	subs	r3, #1
34183940:	4a0b      	ldr	r2, [pc, #44]	@ (34183970 <BSP_I2C2_DeInit+0x40>)
34183942:	6013      	str	r3, [r2, #0]

  if (I2c2InitCounter == 0U)
34183944:	4b0a      	ldr	r3, [pc, #40]	@ (34183970 <BSP_I2C2_DeInit+0x40>)
34183946:	681b      	ldr	r3, [r3, #0]
34183948:	2b00      	cmp	r3, #0
3418394a:	d10b      	bne.n	34183964 <BSP_I2C2_DeInit+0x34>
  {
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 0)
    I2C2_MspDeInit(&hbus_i2c2);
3418394c:	4809      	ldr	r0, [pc, #36]	@ (34183974 <BSP_I2C2_DeInit+0x44>)
3418394e:	f000 fb6d 	bl	3418402c <I2C2_MspDeInit>
#endif /* (USE_HAL_I2C_REGISTER_CALLBACKS == 0) */

    /* Init the I2C */
    if (HAL_I2C_DeInit(&hbus_i2c2) != HAL_OK)
34183952:	4808      	ldr	r0, [pc, #32]	@ (34183974 <BSP_I2C2_DeInit+0x44>)
34183954:	f003 fe6f 	bl	34187636 <HAL_I2C_DeInit>
34183958:	4603      	mov	r3, r0
3418395a:	2b00      	cmp	r3, #0
3418395c:	d002      	beq.n	34183964 <BSP_I2C2_DeInit+0x34>
    {
      ret = BSP_ERROR_BUS_FAILURE;
3418395e:	f06f 0307 	mvn.w	r3, #7
34183962:	607b      	str	r3, [r7, #4]
    }
  }

  return ret;
34183964:	687b      	ldr	r3, [r7, #4]
}
34183966:	4618      	mov	r0, r3
34183968:	3708      	adds	r7, #8
3418396a:	46bd      	mov	sp, r7
3418396c:	bd80      	pop	{r7, pc}
3418396e:	bf00      	nop
34183970:	341c227c 	.word	0x341c227c
34183974:	341c2c84 	.word	0x341c2c84

34183978 <MX_I2C2_Init>:
  * @param  hI2c I2C handle
  * @param  timing I2C timing
  * @retval HAL status
  */
__weak HAL_StatusTypeDef MX_I2C2_Init(I2C_HandleTypeDef *hI2c, uint32_t timing)
{
34183978:	b580      	push	{r7, lr}
3418397a:	b084      	sub	sp, #16
3418397c:	af00      	add	r7, sp, #0
3418397e:	6078      	str	r0, [r7, #4]
34183980:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
34183982:	2300      	movs	r3, #0
34183984:	73fb      	strb	r3, [r7, #15]

  hI2c->Init.Timing           = timing;
34183986:	687b      	ldr	r3, [r7, #4]
34183988:	683a      	ldr	r2, [r7, #0]
3418398a:	605a      	str	r2, [r3, #4]
  hI2c->Init.OwnAddress1      = 0;
3418398c:	687b      	ldr	r3, [r7, #4]
3418398e:	2200      	movs	r2, #0
34183990:	609a      	str	r2, [r3, #8]
  hI2c->Init.AddressingMode   = I2C_ADDRESSINGMODE_7BIT;
34183992:	687b      	ldr	r3, [r7, #4]
34183994:	2201      	movs	r2, #1
34183996:	60da      	str	r2, [r3, #12]
  hI2c->Init.DualAddressMode  = I2C_DUALADDRESS_DISABLE;
34183998:	687b      	ldr	r3, [r7, #4]
3418399a:	2200      	movs	r2, #0
3418399c:	611a      	str	r2, [r3, #16]
  hI2c->Init.OwnAddress2      = 0;
3418399e:	687b      	ldr	r3, [r7, #4]
341839a0:	2200      	movs	r2, #0
341839a2:	615a      	str	r2, [r3, #20]
  hI2c->Init.OwnAddress2Masks = I2C_OA2_NOMASK;
341839a4:	687b      	ldr	r3, [r7, #4]
341839a6:	2200      	movs	r2, #0
341839a8:	619a      	str	r2, [r3, #24]
  hI2c->Init.GeneralCallMode  = I2C_GENERALCALL_DISABLE;
341839aa:	687b      	ldr	r3, [r7, #4]
341839ac:	2200      	movs	r2, #0
341839ae:	61da      	str	r2, [r3, #28]
  hI2c->Init.NoStretchMode    = I2C_NOSTRETCH_DISABLE;
341839b0:	687b      	ldr	r3, [r7, #4]
341839b2:	2200      	movs	r2, #0
341839b4:	621a      	str	r2, [r3, #32]

  if (HAL_I2C_Init(hI2c) != HAL_OK)
341839b6:	6878      	ldr	r0, [r7, #4]
341839b8:	f003 fda2 	bl	34187500 <HAL_I2C_Init>
341839bc:	4603      	mov	r3, r0
341839be:	2b00      	cmp	r3, #0
341839c0:	d002      	beq.n	341839c8 <MX_I2C2_Init+0x50>
  {
    status = HAL_ERROR;
341839c2:	2301      	movs	r3, #1
341839c4:	73fb      	strb	r3, [r7, #15]
341839c6:	e014      	b.n	341839f2 <MX_I2C2_Init+0x7a>
  }
  else
  {
    uint32_t analog_filter;

    analog_filter = I2C_ANALOGFILTER_ENABLE;
341839c8:	2300      	movs	r3, #0
341839ca:	60bb      	str	r3, [r7, #8]
    if (HAL_I2CEx_ConfigAnalogFilter(hI2c, analog_filter) != HAL_OK)
341839cc:	68b9      	ldr	r1, [r7, #8]
341839ce:	6878      	ldr	r0, [r7, #4]
341839d0:	f004 fb7e 	bl	341880d0 <HAL_I2CEx_ConfigAnalogFilter>
341839d4:	4603      	mov	r3, r0
341839d6:	2b00      	cmp	r3, #0
341839d8:	d002      	beq.n	341839e0 <MX_I2C2_Init+0x68>
    {
      status = HAL_ERROR;
341839da:	2301      	movs	r3, #1
341839dc:	73fb      	strb	r3, [r7, #15]
341839de:	e008      	b.n	341839f2 <MX_I2C2_Init+0x7a>
    }
    else
    {
      if (HAL_I2CEx_ConfigDigitalFilter(hI2c, I2C_DIGITAL_FILTER_COEF) != HAL_OK)
341839e0:	2100      	movs	r1, #0
341839e2:	6878      	ldr	r0, [r7, #4]
341839e4:	f004 fbbf 	bl	34188166 <HAL_I2CEx_ConfigDigitalFilter>
341839e8:	4603      	mov	r3, r0
341839ea:	2b00      	cmp	r3, #0
341839ec:	d001      	beq.n	341839f2 <MX_I2C2_Init+0x7a>
      {
        status = HAL_ERROR;
341839ee:	2301      	movs	r3, #1
341839f0:	73fb      	strb	r3, [r7, #15]
      }
    }
  }

  return status;
341839f2:	7bfb      	ldrb	r3, [r7, #15]
}
341839f4:	4618      	mov	r0, r3
341839f6:	3710      	adds	r7, #16
341839f8:	46bd      	mov	sp, r7
341839fa:	bd80      	pop	{r7, pc}

341839fc <BSP_I2C2_WriteReg>:
  * @param  pData  The target register value to be written
  * @param  Length buffer size to be written
  * @retval BSP status
  */
int32_t BSP_I2C2_WriteReg(uint16_t DevAddr, uint16_t Reg, uint8_t *pData, uint16_t Length)
{
341839fc:	b580      	push	{r7, lr}
341839fe:	b088      	sub	sp, #32
34183a00:	af02      	add	r7, sp, #8
34183a02:	60ba      	str	r2, [r7, #8]
34183a04:	461a      	mov	r2, r3
34183a06:	4603      	mov	r3, r0
34183a08:	81fb      	strh	r3, [r7, #14]
34183a0a:	460b      	mov	r3, r1
34183a0c:	81bb      	strh	r3, [r7, #12]
34183a0e:	4613      	mov	r3, r2
34183a10:	80fb      	strh	r3, [r7, #6]
  int32_t ret;
#if defined(BSP_USE_CMSIS_OS)
  /* Get semaphore to prevent multiple I2C access */
  osSemaphoreWait(BspI2cSemaphore, osWaitForever);
#endif /* BSP_USE_CMSIS_OS */
  if (I2C2_WriteReg(DevAddr, Reg, I2C_MEMADD_SIZE_8BIT, pData, Length) == 0)
34183a12:	89b9      	ldrh	r1, [r7, #12]
34183a14:	89f8      	ldrh	r0, [r7, #14]
34183a16:	88fb      	ldrh	r3, [r7, #6]
34183a18:	9300      	str	r3, [sp, #0]
34183a1a:	68bb      	ldr	r3, [r7, #8]
34183a1c:	2201      	movs	r2, #1
34183a1e:	f000 fb23 	bl	34184068 <I2C2_WriteReg>
34183a22:	4603      	mov	r3, r0
34183a24:	2b00      	cmp	r3, #0
34183a26:	d102      	bne.n	34183a2e <BSP_I2C2_WriteReg+0x32>
  {
    ret = BSP_ERROR_NONE;
34183a28:	2300      	movs	r3, #0
34183a2a:	617b      	str	r3, [r7, #20]
34183a2c:	e00c      	b.n	34183a48 <BSP_I2C2_WriteReg+0x4c>
  }
  else
  {
    if (HAL_I2C_GetError(&hbus_i2c2) == HAL_I2C_ERROR_AF)
34183a2e:	4809      	ldr	r0, [pc, #36]	@ (34183a54 <BSP_I2C2_WriteReg+0x58>)
34183a30:	f004 f880 	bl	34187b34 <HAL_I2C_GetError>
34183a34:	4603      	mov	r3, r0
34183a36:	2b04      	cmp	r3, #4
34183a38:	d103      	bne.n	34183a42 <BSP_I2C2_WriteReg+0x46>
    {
      ret = BSP_ERROR_BUS_ACKNOWLEDGE_FAILURE;
34183a3a:	f06f 0365 	mvn.w	r3, #101	@ 0x65
34183a3e:	617b      	str	r3, [r7, #20]
34183a40:	e002      	b.n	34183a48 <BSP_I2C2_WriteReg+0x4c>
    }
    else
    {
      ret = BSP_ERROR_PERIPH_FAILURE;
34183a42:	f06f 0303 	mvn.w	r3, #3
34183a46:	617b      	str	r3, [r7, #20]
  }
#if defined(BSP_USE_CMSIS_OS)
  /* Release semaphore to prevent multiple I2C access */
  osSemaphoreRelease(BspI2cSemaphore);
#endif /* BSP_USE_CMSIS_OS */
  return ret;
34183a48:	697b      	ldr	r3, [r7, #20]
}
34183a4a:	4618      	mov	r0, r3
34183a4c:	3718      	adds	r7, #24
34183a4e:	46bd      	mov	sp, r7
34183a50:	bd80      	pop	{r7, pc}
34183a52:	bf00      	nop
34183a54:	341c2c84 	.word	0x341c2c84

34183a58 <BSP_I2C2_ReadReg>:
  * @param  pData   Pointer to data buffer
  * @param  Length  Length of the data
  * @retval BSP status
  */
int32_t BSP_I2C2_ReadReg(uint16_t DevAddr, uint16_t Reg, uint8_t *pData, uint16_t Length)
{
34183a58:	b580      	push	{r7, lr}
34183a5a:	b088      	sub	sp, #32
34183a5c:	af02      	add	r7, sp, #8
34183a5e:	60ba      	str	r2, [r7, #8]
34183a60:	461a      	mov	r2, r3
34183a62:	4603      	mov	r3, r0
34183a64:	81fb      	strh	r3, [r7, #14]
34183a66:	460b      	mov	r3, r1
34183a68:	81bb      	strh	r3, [r7, #12]
34183a6a:	4613      	mov	r3, r2
34183a6c:	80fb      	strh	r3, [r7, #6]
  int32_t ret;
#if defined(BSP_USE_CMSIS_OS)
  /* Get semaphore to prevent multiple I2C access */
  osSemaphoreWait(BspI2cSemaphore, osWaitForever);
#endif /* BSP_USE_CMSIS_OS */
  if (I2C2_ReadReg(DevAddr, Reg, I2C_MEMADD_SIZE_8BIT, pData, Length) == 0)
34183a6e:	89b9      	ldrh	r1, [r7, #12]
34183a70:	89f8      	ldrh	r0, [r7, #14]
34183a72:	88fb      	ldrh	r3, [r7, #6]
34183a74:	9300      	str	r3, [sp, #0]
34183a76:	68bb      	ldr	r3, [r7, #8]
34183a78:	2201      	movs	r2, #1
34183a7a:	f000 fb1b 	bl	341840b4 <I2C2_ReadReg>
34183a7e:	4603      	mov	r3, r0
34183a80:	2b00      	cmp	r3, #0
34183a82:	d102      	bne.n	34183a8a <BSP_I2C2_ReadReg+0x32>
  {
    ret = BSP_ERROR_NONE;
34183a84:	2300      	movs	r3, #0
34183a86:	617b      	str	r3, [r7, #20]
34183a88:	e00c      	b.n	34183aa4 <BSP_I2C2_ReadReg+0x4c>
  }
  else
  {
    if (HAL_I2C_GetError(&hbus_i2c2) == HAL_I2C_ERROR_AF)
34183a8a:	4809      	ldr	r0, [pc, #36]	@ (34183ab0 <BSP_I2C2_ReadReg+0x58>)
34183a8c:	f004 f852 	bl	34187b34 <HAL_I2C_GetError>
34183a90:	4603      	mov	r3, r0
34183a92:	2b04      	cmp	r3, #4
34183a94:	d103      	bne.n	34183a9e <BSP_I2C2_ReadReg+0x46>
    {
      ret = BSP_ERROR_BUS_ACKNOWLEDGE_FAILURE;
34183a96:	f06f 0365 	mvn.w	r3, #101	@ 0x65
34183a9a:	617b      	str	r3, [r7, #20]
34183a9c:	e002      	b.n	34183aa4 <BSP_I2C2_ReadReg+0x4c>
    }
    else
    {
      ret = BSP_ERROR_PERIPH_FAILURE;
34183a9e:	f06f 0303 	mvn.w	r3, #3
34183aa2:	617b      	str	r3, [r7, #20]
  }
#if defined(BSP_USE_CMSIS_OS)
  /* Release semaphore to prevent multiple I2C access */
  osSemaphoreRelease(BspI2cSemaphore);
#endif /* BSP_USE_CMSIS_OS */
  return ret;
34183aa4:	697b      	ldr	r3, [r7, #20]
}
34183aa6:	4618      	mov	r0, r3
34183aa8:	3718      	adds	r7, #24
34183aaa:	46bd      	mov	sp, r7
34183aac:	bd80      	pop	{r7, pc}
34183aae:	bf00      	nop
34183ab0:	341c2c84 	.word	0x341c2c84

34183ab4 <BSP_GetTick>:
/**
  * @brief  Delay function
  * @retval Tick value
  */
int32_t BSP_GetTick(void)
{
34183ab4:	b580      	push	{r7, lr}
34183ab6:	af00      	add	r7, sp, #0
  return (int32_t)HAL_GetTick();
34183ab8:	f001 fd7e 	bl	341855b8 <HAL_GetTick>
34183abc:	4603      	mov	r3, r0
}
34183abe:	4618      	mov	r0, r3
34183ac0:	bd80      	pop	{r7, pc}
	...

34183ac4 <I2C_GetTiming>:
  * @param  clock_src_freq I2C clock source in Hz.
  * @param  i2c_freq Required I2C clock in Hz.
  * @retval I2C timing or 0 in case of error.
  */
static uint32_t I2C_GetTiming(uint32_t clock_src_freq, uint32_t i2c_freq)
{
34183ac4:	b580      	push	{r7, lr}
34183ac6:	b086      	sub	sp, #24
34183ac8:	af00      	add	r7, sp, #0
34183aca:	6078      	str	r0, [r7, #4]
34183acc:	6039      	str	r1, [r7, #0]
  uint32_t ret = 0;
34183ace:	2300      	movs	r3, #0
34183ad0:	617b      	str	r3, [r7, #20]
  uint32_t speed;
  uint32_t idx;

  if ((clock_src_freq != 0U) && (i2c_freq != 0U))
34183ad2:	687b      	ldr	r3, [r7, #4]
34183ad4:	2b00      	cmp	r3, #0
34183ad6:	d06b      	beq.n	34183bb0 <I2C_GetTiming+0xec>
34183ad8:	683b      	ldr	r3, [r7, #0]
34183ada:	2b00      	cmp	r3, #0
34183adc:	d068      	beq.n	34183bb0 <I2C_GetTiming+0xec>
  {
    for (speed = 0; speed <= (uint32_t)I2C_SPEED_FREQ_FAST_PLUS; speed++)
34183ade:	2300      	movs	r3, #0
34183ae0:	613b      	str	r3, [r7, #16]
34183ae2:	e060      	b.n	34183ba6 <I2C_GetTiming+0xe2>
    {
      if ((i2c_freq >= I2C_Charac[speed].freq_min) &&
34183ae4:	4a35      	ldr	r2, [pc, #212]	@ (34183bbc <I2C_GetTiming+0xf8>)
34183ae6:	693b      	ldr	r3, [r7, #16]
34183ae8:	212c      	movs	r1, #44	@ 0x2c
34183aea:	fb01 f303 	mul.w	r3, r1, r3
34183aee:	4413      	add	r3, r2
34183af0:	3304      	adds	r3, #4
34183af2:	681b      	ldr	r3, [r3, #0]
34183af4:	683a      	ldr	r2, [r7, #0]
34183af6:	429a      	cmp	r2, r3
34183af8:	d352      	bcc.n	34183ba0 <I2C_GetTiming+0xdc>
          (i2c_freq <= I2C_Charac[speed].freq_max))
34183afa:	4a30      	ldr	r2, [pc, #192]	@ (34183bbc <I2C_GetTiming+0xf8>)
34183afc:	693b      	ldr	r3, [r7, #16]
34183afe:	212c      	movs	r1, #44	@ 0x2c
34183b00:	fb01 f303 	mul.w	r3, r1, r3
34183b04:	4413      	add	r3, r2
34183b06:	3308      	adds	r3, #8
34183b08:	681b      	ldr	r3, [r3, #0]
      if ((i2c_freq >= I2C_Charac[speed].freq_min) &&
34183b0a:	683a      	ldr	r2, [r7, #0]
34183b0c:	429a      	cmp	r2, r3
34183b0e:	d847      	bhi.n	34183ba0 <I2C_GetTiming+0xdc>
      {
        I2C_Compute_PRESC_SCLDEL_SDADEL(clock_src_freq, speed);
34183b10:	6939      	ldr	r1, [r7, #16]
34183b12:	6878      	ldr	r0, [r7, #4]
34183b14:	f000 f856 	bl	34183bc4 <I2C_Compute_PRESC_SCLDEL_SDADEL>
        idx = I2C_Compute_SCLL_SCLH(clock_src_freq, speed);
34183b18:	6939      	ldr	r1, [r7, #16]
34183b1a:	6878      	ldr	r0, [r7, #4]
34183b1c:	f000 f940 	bl	34183da0 <I2C_Compute_SCLL_SCLH>
34183b20:	60f8      	str	r0, [r7, #12]

        if (idx < I2C_VALID_TIMING_NBR)
34183b22:	68fb      	ldr	r3, [r7, #12]
34183b24:	2b7f      	cmp	r3, #127	@ 0x7f
34183b26:	d842      	bhi.n	34183bae <I2C_GetTiming+0xea>
        {
          ret = ((I2c_valid_timing[idx].presc  & 0x0FU) << 28) |\
34183b28:	4925      	ldr	r1, [pc, #148]	@ (34183bc0 <I2C_GetTiming+0xfc>)
34183b2a:	68fa      	ldr	r2, [r7, #12]
34183b2c:	4613      	mov	r3, r2
34183b2e:	009b      	lsls	r3, r3, #2
34183b30:	4413      	add	r3, r2
34183b32:	009b      	lsls	r3, r3, #2
34183b34:	440b      	add	r3, r1
34183b36:	681b      	ldr	r3, [r3, #0]
34183b38:	0719      	lsls	r1, r3, #28
                ((I2c_valid_timing[idx].tscldel & 0x0FU) << 20) |\
34183b3a:	4821      	ldr	r0, [pc, #132]	@ (34183bc0 <I2C_GetTiming+0xfc>)
34183b3c:	68fa      	ldr	r2, [r7, #12]
34183b3e:	4613      	mov	r3, r2
34183b40:	009b      	lsls	r3, r3, #2
34183b42:	4413      	add	r3, r2
34183b44:	009b      	lsls	r3, r3, #2
34183b46:	4403      	add	r3, r0
34183b48:	3304      	adds	r3, #4
34183b4a:	681b      	ldr	r3, [r3, #0]
34183b4c:	051b      	lsls	r3, r3, #20
34183b4e:	f403 0370 	and.w	r3, r3, #15728640	@ 0xf00000
          ret = ((I2c_valid_timing[idx].presc  & 0x0FU) << 28) |\
34183b52:	4319      	orrs	r1, r3
                ((I2c_valid_timing[idx].tsdadel & 0x0FU) << 16) |\
34183b54:	481a      	ldr	r0, [pc, #104]	@ (34183bc0 <I2C_GetTiming+0xfc>)
34183b56:	68fa      	ldr	r2, [r7, #12]
34183b58:	4613      	mov	r3, r2
34183b5a:	009b      	lsls	r3, r3, #2
34183b5c:	4413      	add	r3, r2
34183b5e:	009b      	lsls	r3, r3, #2
34183b60:	4403      	add	r3, r0
34183b62:	3308      	adds	r3, #8
34183b64:	681b      	ldr	r3, [r3, #0]
34183b66:	041b      	lsls	r3, r3, #16
34183b68:	f403 2370 	and.w	r3, r3, #983040	@ 0xf0000
                ((I2c_valid_timing[idx].tscldel & 0x0FU) << 20) |\
34183b6c:	4319      	orrs	r1, r3
                ((I2c_valid_timing[idx].sclh & 0xFFU) << 8) |\
34183b6e:	4814      	ldr	r0, [pc, #80]	@ (34183bc0 <I2C_GetTiming+0xfc>)
34183b70:	68fa      	ldr	r2, [r7, #12]
34183b72:	4613      	mov	r3, r2
34183b74:	009b      	lsls	r3, r3, #2
34183b76:	4413      	add	r3, r2
34183b78:	009b      	lsls	r3, r3, #2
34183b7a:	4403      	add	r3, r0
34183b7c:	330c      	adds	r3, #12
34183b7e:	681b      	ldr	r3, [r3, #0]
34183b80:	021b      	lsls	r3, r3, #8
34183b82:	b29b      	uxth	r3, r3
                ((I2c_valid_timing[idx].tsdadel & 0x0FU) << 16) |\
34183b84:	4319      	orrs	r1, r3
                ((I2c_valid_timing[idx].scll & 0xFFU) << 0);
34183b86:	480e      	ldr	r0, [pc, #56]	@ (34183bc0 <I2C_GetTiming+0xfc>)
34183b88:	68fa      	ldr	r2, [r7, #12]
34183b8a:	4613      	mov	r3, r2
34183b8c:	009b      	lsls	r3, r3, #2
34183b8e:	4413      	add	r3, r2
34183b90:	009b      	lsls	r3, r3, #2
34183b92:	4403      	add	r3, r0
34183b94:	3310      	adds	r3, #16
34183b96:	681b      	ldr	r3, [r3, #0]
34183b98:	b2db      	uxtb	r3, r3
          ret = ((I2c_valid_timing[idx].presc  & 0x0FU) << 28) |\
34183b9a:	430b      	orrs	r3, r1
34183b9c:	617b      	str	r3, [r7, #20]
        }
        break;
34183b9e:	e006      	b.n	34183bae <I2C_GetTiming+0xea>
    for (speed = 0; speed <= (uint32_t)I2C_SPEED_FREQ_FAST_PLUS; speed++)
34183ba0:	693b      	ldr	r3, [r7, #16]
34183ba2:	3301      	adds	r3, #1
34183ba4:	613b      	str	r3, [r7, #16]
34183ba6:	693b      	ldr	r3, [r7, #16]
34183ba8:	2b02      	cmp	r3, #2
34183baa:	d99b      	bls.n	34183ae4 <I2C_GetTiming+0x20>
34183bac:	e000      	b.n	34183bb0 <I2C_GetTiming+0xec>
        break;
34183bae:	bf00      	nop
      }
    }
  }

  return ret;
34183bb0:	697b      	ldr	r3, [r7, #20]
}
34183bb2:	4618      	mov	r0, r3
34183bb4:	3718      	adds	r7, #24
34183bb6:	46bd      	mov	sp, r7
34183bb8:	bd80      	pop	{r7, pc}
34183bba:	bf00      	nop
34183bbc:	3419e354 	.word	0x3419e354
34183bc0:	341c2280 	.word	0x341c2280

34183bc4 <I2C_Compute_PRESC_SCLDEL_SDADEL>:
  * @param  clock_src_freq I2C source clock in HZ.
  * @param  I2C_speed I2C frequency (index).
  * @retval None.
  */
static void I2C_Compute_PRESC_SCLDEL_SDADEL(uint32_t clock_src_freq, uint32_t I2C_speed)
{
34183bc4:	b480      	push	{r7}
34183bc6:	b08f      	sub	sp, #60	@ 0x3c
34183bc8:	af00      	add	r7, sp, #0
34183bca:	6078      	str	r0, [r7, #4]
34183bcc:	6039      	str	r1, [r7, #0]
  uint32_t prev_presc = I2C_PRESC_MAX;
34183bce:	2310      	movs	r3, #16
34183bd0:	637b      	str	r3, [r7, #52]	@ 0x34
  uint32_t scldel;
  uint32_t sdadel;
  uint32_t tafdel_min;
  uint32_t tafdel_max;

  ti2cclk = (SEC2NSEC + (clock_src_freq / 2U))/ clock_src_freq;
34183bd2:	687b      	ldr	r3, [r7, #4]
34183bd4:	085a      	lsrs	r2, r3, #1
34183bd6:	4b6e      	ldr	r3, [pc, #440]	@ (34183d90 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1cc>)
34183bd8:	4413      	add	r3, r2
34183bda:	687a      	ldr	r2, [r7, #4]
34183bdc:	fbb3 f3f2 	udiv	r3, r3, r2
34183be0:	61fb      	str	r3, [r7, #28]

  tafdel_min = I2C_ANALOG_FILTER_DELAY_MIN;
34183be2:	2332      	movs	r3, #50	@ 0x32
34183be4:	61bb      	str	r3, [r7, #24]
  tafdel_max = I2C_ANALOG_FILTER_DELAY_MAX;
34183be6:	f44f 7382 	mov.w	r3, #260	@ 0x104
34183bea:	617b      	str	r3, [r7, #20]
  /* tDNF = DNF x tI2CCLK
     tPRESC = (PRESC+1) x tI2CCLK
     SDADEL >= {tf +tHD;DAT(min) - tAF(min) - tDNF - [3 x tI2CCLK]} / tPRESC
     SDADEL <= {tVD;DAT(max) - tr - tAF(max) - tDNF- [4 x tI2CCLK]} / tPRESC */

  tsdadel_min = (int32_t)I2C_Charac[I2C_speed].tfall + (int32_t)I2C_Charac[I2C_speed].hddat_min -
34183bec:	4a69      	ldr	r2, [pc, #420]	@ (34183d94 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d0>)
34183bee:	683b      	ldr	r3, [r7, #0]
34183bf0:	212c      	movs	r1, #44	@ 0x2c
34183bf2:	fb01 f303 	mul.w	r3, r1, r3
34183bf6:	4413      	add	r3, r2
34183bf8:	3324      	adds	r3, #36	@ 0x24
34183bfa:	681b      	ldr	r3, [r3, #0]
34183bfc:	4618      	mov	r0, r3
34183bfe:	4a65      	ldr	r2, [pc, #404]	@ (34183d94 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d0>)
34183c00:	683b      	ldr	r3, [r7, #0]
34183c02:	212c      	movs	r1, #44	@ 0x2c
34183c04:	fb01 f303 	mul.w	r3, r1, r3
34183c08:	4413      	add	r3, r2
34183c0a:	330c      	adds	r3, #12
34183c0c:	681b      	ldr	r3, [r3, #0]
34183c0e:	18c2      	adds	r2, r0, r3
    (int32_t)tafdel_min - (int32_t)(((int32_t)I2C_Charac[I2C_speed].dnf + 3) * (int32_t)ti2cclk);
34183c10:	69bb      	ldr	r3, [r7, #24]
  tsdadel_min = (int32_t)I2C_Charac[I2C_speed].tfall + (int32_t)I2C_Charac[I2C_speed].hddat_min -
34183c12:	1ad2      	subs	r2, r2, r3
    (int32_t)tafdel_min - (int32_t)(((int32_t)I2C_Charac[I2C_speed].dnf + 3) * (int32_t)ti2cclk);
34183c14:	495f      	ldr	r1, [pc, #380]	@ (34183d94 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d0>)
34183c16:	683b      	ldr	r3, [r7, #0]
34183c18:	202c      	movs	r0, #44	@ 0x2c
34183c1a:	fb00 f303 	mul.w	r3, r0, r3
34183c1e:	440b      	add	r3, r1
34183c20:	3328      	adds	r3, #40	@ 0x28
34183c22:	681b      	ldr	r3, [r3, #0]
34183c24:	3303      	adds	r3, #3
34183c26:	69f9      	ldr	r1, [r7, #28]
34183c28:	fb01 f303 	mul.w	r3, r1, r3
  tsdadel_min = (int32_t)I2C_Charac[I2C_speed].tfall + (int32_t)I2C_Charac[I2C_speed].hddat_min -
34183c2c:	1ad3      	subs	r3, r2, r3
34183c2e:	633b      	str	r3, [r7, #48]	@ 0x30

  tsdadel_max = (int32_t)I2C_Charac[I2C_speed].vddat_max - (int32_t)I2C_Charac[I2C_speed].trise -
34183c30:	4a58      	ldr	r2, [pc, #352]	@ (34183d94 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d0>)
34183c32:	683b      	ldr	r3, [r7, #0]
34183c34:	212c      	movs	r1, #44	@ 0x2c
34183c36:	fb01 f303 	mul.w	r3, r1, r3
34183c3a:	4413      	add	r3, r2
34183c3c:	3310      	adds	r3, #16
34183c3e:	681b      	ldr	r3, [r3, #0]
34183c40:	4618      	mov	r0, r3
34183c42:	4a54      	ldr	r2, [pc, #336]	@ (34183d94 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d0>)
34183c44:	683b      	ldr	r3, [r7, #0]
34183c46:	212c      	movs	r1, #44	@ 0x2c
34183c48:	fb01 f303 	mul.w	r3, r1, r3
34183c4c:	4413      	add	r3, r2
34183c4e:	3320      	adds	r3, #32
34183c50:	681b      	ldr	r3, [r3, #0]
34183c52:	1ac2      	subs	r2, r0, r3
    (int32_t)tafdel_max - (int32_t)(((int32_t)I2C_Charac[I2C_speed].dnf + 4) * (int32_t)ti2cclk);
34183c54:	697b      	ldr	r3, [r7, #20]
  tsdadel_max = (int32_t)I2C_Charac[I2C_speed].vddat_max - (int32_t)I2C_Charac[I2C_speed].trise -
34183c56:	1ad2      	subs	r2, r2, r3
    (int32_t)tafdel_max - (int32_t)(((int32_t)I2C_Charac[I2C_speed].dnf + 4) * (int32_t)ti2cclk);
34183c58:	494e      	ldr	r1, [pc, #312]	@ (34183d94 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d0>)
34183c5a:	683b      	ldr	r3, [r7, #0]
34183c5c:	202c      	movs	r0, #44	@ 0x2c
34183c5e:	fb00 f303 	mul.w	r3, r0, r3
34183c62:	440b      	add	r3, r1
34183c64:	3328      	adds	r3, #40	@ 0x28
34183c66:	681b      	ldr	r3, [r3, #0]
34183c68:	3304      	adds	r3, #4
34183c6a:	69f9      	ldr	r1, [r7, #28]
34183c6c:	fb01 f303 	mul.w	r3, r1, r3
  tsdadel_max = (int32_t)I2C_Charac[I2C_speed].vddat_max - (int32_t)I2C_Charac[I2C_speed].trise -
34183c70:	1ad3      	subs	r3, r2, r3
34183c72:	62fb      	str	r3, [r7, #44]	@ 0x2c


  /* {[tr+ tSU;DAT(min)] / [tPRESC]} - 1 <= SCLDEL */
  tscldel_min = (int32_t)I2C_Charac[I2C_speed].trise + (int32_t)I2C_Charac[I2C_speed].sudat_min;
34183c74:	4a47      	ldr	r2, [pc, #284]	@ (34183d94 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d0>)
34183c76:	683b      	ldr	r3, [r7, #0]
34183c78:	212c      	movs	r1, #44	@ 0x2c
34183c7a:	fb01 f303 	mul.w	r3, r1, r3
34183c7e:	4413      	add	r3, r2
34183c80:	3320      	adds	r3, #32
34183c82:	681b      	ldr	r3, [r3, #0]
34183c84:	4618      	mov	r0, r3
34183c86:	4a43      	ldr	r2, [pc, #268]	@ (34183d94 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d0>)
34183c88:	683b      	ldr	r3, [r7, #0]
34183c8a:	212c      	movs	r1, #44	@ 0x2c
34183c8c:	fb01 f303 	mul.w	r3, r1, r3
34183c90:	4413      	add	r3, r2
34183c92:	3314      	adds	r3, #20
34183c94:	681b      	ldr	r3, [r3, #0]
34183c96:	4403      	add	r3, r0
34183c98:	613b      	str	r3, [r7, #16]

  if (tsdadel_min <= 0)
34183c9a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34183c9c:	2b00      	cmp	r3, #0
34183c9e:	dc01      	bgt.n	34183ca4 <I2C_Compute_PRESC_SCLDEL_SDADEL+0xe0>
  {
    tsdadel_min = 0;
34183ca0:	2300      	movs	r3, #0
34183ca2:	633b      	str	r3, [r7, #48]	@ 0x30
  }

  if (tsdadel_max <= 0)
34183ca4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34183ca6:	2b00      	cmp	r3, #0
34183ca8:	dc01      	bgt.n	34183cae <I2C_Compute_PRESC_SCLDEL_SDADEL+0xea>
  {
    tsdadel_max = 0;
34183caa:	2300      	movs	r3, #0
34183cac:	62fb      	str	r3, [r7, #44]	@ 0x2c
  }

  for (presc = 0; presc < I2C_PRESC_MAX; presc++)
34183cae:	2300      	movs	r3, #0
34183cb0:	62bb      	str	r3, [r7, #40]	@ 0x28
34183cb2:	e062      	b.n	34183d7a <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1b6>
  {
    for (scldel = 0; scldel < I2C_SCLDEL_MAX; scldel++)
34183cb4:	2300      	movs	r3, #0
34183cb6:	627b      	str	r3, [r7, #36]	@ 0x24
34183cb8:	e059      	b.n	34183d6e <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1aa>
    {
      /* TSCLDEL = (SCLDEL+1) * (PRESC+1) * TI2CCLK */
      uint32_t tscldel = (scldel + 1U) * (presc + 1U) * ti2cclk;
34183cba:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34183cbc:	3301      	adds	r3, #1
34183cbe:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34183cc0:	3201      	adds	r2, #1
34183cc2:	fb03 f202 	mul.w	r2, r3, r2
34183cc6:	69fb      	ldr	r3, [r7, #28]
34183cc8:	fb02 f303 	mul.w	r3, r2, r3
34183ccc:	60fb      	str	r3, [r7, #12]

      if (tscldel >= (uint32_t)tscldel_min)
34183cce:	693b      	ldr	r3, [r7, #16]
34183cd0:	68fa      	ldr	r2, [r7, #12]
34183cd2:	429a      	cmp	r2, r3
34183cd4:	d348      	bcc.n	34183d68 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1a4>
      {
        for (sdadel = 0; sdadel < I2C_SDADEL_MAX; sdadel++)
34183cd6:	2300      	movs	r3, #0
34183cd8:	623b      	str	r3, [r7, #32]
34183cda:	e042      	b.n	34183d62 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x19e>
        {
          /* TSDADEL = SDADEL * (PRESC+1) * TI2CCLK */
          uint32_t tsdadel = (sdadel * (presc + 1U)) * ti2cclk;
34183cdc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183cde:	3301      	adds	r3, #1
34183ce0:	6a3a      	ldr	r2, [r7, #32]
34183ce2:	fb03 f202 	mul.w	r2, r3, r2
34183ce6:	69fb      	ldr	r3, [r7, #28]
34183ce8:	fb02 f303 	mul.w	r3, r2, r3
34183cec:	60bb      	str	r3, [r7, #8]

          if ((tsdadel >= (uint32_t)tsdadel_min) && (tsdadel <= (uint32_t)tsdadel_max))
34183cee:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34183cf0:	68ba      	ldr	r2, [r7, #8]
34183cf2:	429a      	cmp	r2, r3
34183cf4:	d332      	bcc.n	34183d5c <I2C_Compute_PRESC_SCLDEL_SDADEL+0x198>
34183cf6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34183cf8:	68ba      	ldr	r2, [r7, #8]
34183cfa:	429a      	cmp	r2, r3
34183cfc:	d82e      	bhi.n	34183d5c <I2C_Compute_PRESC_SCLDEL_SDADEL+0x198>
          {
            if (presc != prev_presc)
34183cfe:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34183d00:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34183d02:	429a      	cmp	r2, r3
34183d04:	d02a      	beq.n	34183d5c <I2C_Compute_PRESC_SCLDEL_SDADEL+0x198>
            {
              I2c_valid_timing[I2c_valid_timing_nbr].presc = presc;
34183d06:	4b24      	ldr	r3, [pc, #144]	@ (34183d98 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d4>)
34183d08:	681a      	ldr	r2, [r3, #0]
34183d0a:	4924      	ldr	r1, [pc, #144]	@ (34183d9c <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d8>)
34183d0c:	4613      	mov	r3, r2
34183d0e:	009b      	lsls	r3, r3, #2
34183d10:	4413      	add	r3, r2
34183d12:	009b      	lsls	r3, r3, #2
34183d14:	440b      	add	r3, r1
34183d16:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34183d18:	601a      	str	r2, [r3, #0]
              I2c_valid_timing[I2c_valid_timing_nbr].tscldel = scldel;
34183d1a:	4b1f      	ldr	r3, [pc, #124]	@ (34183d98 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d4>)
34183d1c:	681a      	ldr	r2, [r3, #0]
34183d1e:	491f      	ldr	r1, [pc, #124]	@ (34183d9c <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d8>)
34183d20:	4613      	mov	r3, r2
34183d22:	009b      	lsls	r3, r3, #2
34183d24:	4413      	add	r3, r2
34183d26:	009b      	lsls	r3, r3, #2
34183d28:	440b      	add	r3, r1
34183d2a:	3304      	adds	r3, #4
34183d2c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
34183d2e:	601a      	str	r2, [r3, #0]
              I2c_valid_timing[I2c_valid_timing_nbr].tsdadel = sdadel;
34183d30:	4b19      	ldr	r3, [pc, #100]	@ (34183d98 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d4>)
34183d32:	681a      	ldr	r2, [r3, #0]
34183d34:	4919      	ldr	r1, [pc, #100]	@ (34183d9c <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d8>)
34183d36:	4613      	mov	r3, r2
34183d38:	009b      	lsls	r3, r3, #2
34183d3a:	4413      	add	r3, r2
34183d3c:	009b      	lsls	r3, r3, #2
34183d3e:	440b      	add	r3, r1
34183d40:	3308      	adds	r3, #8
34183d42:	6a3a      	ldr	r2, [r7, #32]
34183d44:	601a      	str	r2, [r3, #0]
              prev_presc = presc;
34183d46:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183d48:	637b      	str	r3, [r7, #52]	@ 0x34
              I2c_valid_timing_nbr ++;
34183d4a:	4b13      	ldr	r3, [pc, #76]	@ (34183d98 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d4>)
34183d4c:	681b      	ldr	r3, [r3, #0]
34183d4e:	3301      	adds	r3, #1
34183d50:	4a11      	ldr	r2, [pc, #68]	@ (34183d98 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d4>)
34183d52:	6013      	str	r3, [r2, #0]

              if (I2c_valid_timing_nbr >= I2C_VALID_TIMING_NBR)
34183d54:	4b10      	ldr	r3, [pc, #64]	@ (34183d98 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d4>)
34183d56:	681b      	ldr	r3, [r3, #0]
34183d58:	2b7f      	cmp	r3, #127	@ 0x7f
34183d5a:	d812      	bhi.n	34183d82 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1be>
        for (sdadel = 0; sdadel < I2C_SDADEL_MAX; sdadel++)
34183d5c:	6a3b      	ldr	r3, [r7, #32]
34183d5e:	3301      	adds	r3, #1
34183d60:	623b      	str	r3, [r7, #32]
34183d62:	6a3b      	ldr	r3, [r7, #32]
34183d64:	2b0f      	cmp	r3, #15
34183d66:	d9b9      	bls.n	34183cdc <I2C_Compute_PRESC_SCLDEL_SDADEL+0x118>
    for (scldel = 0; scldel < I2C_SCLDEL_MAX; scldel++)
34183d68:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34183d6a:	3301      	adds	r3, #1
34183d6c:	627b      	str	r3, [r7, #36]	@ 0x24
34183d6e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34183d70:	2b0f      	cmp	r3, #15
34183d72:	d9a2      	bls.n	34183cba <I2C_Compute_PRESC_SCLDEL_SDADEL+0xf6>
  for (presc = 0; presc < I2C_PRESC_MAX; presc++)
34183d74:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183d76:	3301      	adds	r3, #1
34183d78:	62bb      	str	r3, [r7, #40]	@ 0x28
34183d7a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183d7c:	2b0f      	cmp	r3, #15
34183d7e:	d999      	bls.n	34183cb4 <I2C_Compute_PRESC_SCLDEL_SDADEL+0xf0>
34183d80:	e000      	b.n	34183d84 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1c0>
              {
                return;
34183d82:	bf00      	nop
          }
        }
      }
    }
  }
}
34183d84:	373c      	adds	r7, #60	@ 0x3c
34183d86:	46bd      	mov	sp, r7
34183d88:	f85d 7b04 	ldr.w	r7, [sp], #4
34183d8c:	4770      	bx	lr
34183d8e:	bf00      	nop
34183d90:	3b9aca00 	.word	0x3b9aca00
34183d94:	3419e354 	.word	0x3419e354
34183d98:	341c2c80 	.word	0x341c2c80
34183d9c:	341c2280 	.word	0x341c2280

34183da0 <I2C_Compute_SCLL_SCLH>:
  * @param  clock_src_freq I2C source clock in HZ.
  * @param  I2C_speed I2C frequency (index).
  * @retval config index (0 to I2C_VALID_TIMING_NBR], 0xFFFFFFFF for no valid config.
  */
static uint32_t I2C_Compute_SCLL_SCLH (uint32_t clock_src_freq, uint32_t I2C_speed)
{
34183da0:	b480      	push	{r7}
34183da2:	b093      	sub	sp, #76	@ 0x4c
34183da4:	af00      	add	r7, sp, #0
34183da6:	6078      	str	r0, [r7, #4]
34183da8:	6039      	str	r1, [r7, #0]
 uint32_t ret = 0xFFFFFFFFU;
34183daa:	f04f 33ff 	mov.w	r3, #4294967295
34183dae:	647b      	str	r3, [r7, #68]	@ 0x44
  uint32_t clk_max;
  uint32_t scll;
  uint32_t sclh;
  uint32_t tafdel_min;

  ti2cclk = (SEC2NSEC + (clock_src_freq / 2U))/ clock_src_freq;
34183db0:	687b      	ldr	r3, [r7, #4]
34183db2:	085a      	lsrs	r2, r3, #1
34183db4:	4b7a      	ldr	r3, [pc, #488]	@ (34183fa0 <I2C_Compute_SCLL_SCLH+0x200>)
34183db6:	4413      	add	r3, r2
34183db8:	687a      	ldr	r2, [r7, #4]
34183dba:	fbb3 f3f2 	udiv	r3, r3, r2
34183dbe:	62fb      	str	r3, [r7, #44]	@ 0x2c
  ti2cspeed = (SEC2NSEC + (I2C_Charac[I2C_speed].freq / 2U))/ I2C_Charac[I2C_speed].freq;
34183dc0:	4a78      	ldr	r2, [pc, #480]	@ (34183fa4 <I2C_Compute_SCLL_SCLH+0x204>)
34183dc2:	683b      	ldr	r3, [r7, #0]
34183dc4:	212c      	movs	r1, #44	@ 0x2c
34183dc6:	fb01 f303 	mul.w	r3, r1, r3
34183dca:	4413      	add	r3, r2
34183dcc:	681b      	ldr	r3, [r3, #0]
34183dce:	085a      	lsrs	r2, r3, #1
34183dd0:	4b73      	ldr	r3, [pc, #460]	@ (34183fa0 <I2C_Compute_SCLL_SCLH+0x200>)
34183dd2:	4413      	add	r3, r2
34183dd4:	4973      	ldr	r1, [pc, #460]	@ (34183fa4 <I2C_Compute_SCLL_SCLH+0x204>)
34183dd6:	683a      	ldr	r2, [r7, #0]
34183dd8:	202c      	movs	r0, #44	@ 0x2c
34183dda:	fb00 f202 	mul.w	r2, r0, r2
34183dde:	440a      	add	r2, r1
34183de0:	6812      	ldr	r2, [r2, #0]
34183de2:	fbb3 f3f2 	udiv	r3, r3, r2
34183de6:	62bb      	str	r3, [r7, #40]	@ 0x28

  tafdel_min = I2C_ANALOG_FILTER_DELAY_MIN;
34183de8:	2332      	movs	r3, #50	@ 0x32
34183dea:	627b      	str	r3, [r7, #36]	@ 0x24

  /* tDNF = DNF x tI2CCLK */
  dnf_delay = I2C_Charac[I2C_speed].dnf * ti2cclk;
34183dec:	4a6d      	ldr	r2, [pc, #436]	@ (34183fa4 <I2C_Compute_SCLL_SCLH+0x204>)
34183dee:	683b      	ldr	r3, [r7, #0]
34183df0:	212c      	movs	r1, #44	@ 0x2c
34183df2:	fb01 f303 	mul.w	r3, r1, r3
34183df6:	4413      	add	r3, r2
34183df8:	3328      	adds	r3, #40	@ 0x28
34183dfa:	681a      	ldr	r2, [r3, #0]
34183dfc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34183dfe:	fb02 f303 	mul.w	r3, r2, r3
34183e02:	623b      	str	r3, [r7, #32]

  clk_max = SEC2NSEC / I2C_Charac[I2C_speed].freq_min;
34183e04:	4a67      	ldr	r2, [pc, #412]	@ (34183fa4 <I2C_Compute_SCLL_SCLH+0x204>)
34183e06:	683b      	ldr	r3, [r7, #0]
34183e08:	212c      	movs	r1, #44	@ 0x2c
34183e0a:	fb01 f303 	mul.w	r3, r1, r3
34183e0e:	4413      	add	r3, r2
34183e10:	3304      	adds	r3, #4
34183e12:	681b      	ldr	r3, [r3, #0]
34183e14:	4a62      	ldr	r2, [pc, #392]	@ (34183fa0 <I2C_Compute_SCLL_SCLH+0x200>)
34183e16:	fbb2 f3f3 	udiv	r3, r2, r3
34183e1a:	61fb      	str	r3, [r7, #28]
  clk_min = SEC2NSEC / I2C_Charac[I2C_speed].freq_max;
34183e1c:	4a61      	ldr	r2, [pc, #388]	@ (34183fa4 <I2C_Compute_SCLL_SCLH+0x204>)
34183e1e:	683b      	ldr	r3, [r7, #0]
34183e20:	212c      	movs	r1, #44	@ 0x2c
34183e22:	fb01 f303 	mul.w	r3, r1, r3
34183e26:	4413      	add	r3, r2
34183e28:	3308      	adds	r3, #8
34183e2a:	681b      	ldr	r3, [r3, #0]
34183e2c:	4a5c      	ldr	r2, [pc, #368]	@ (34183fa0 <I2C_Compute_SCLL_SCLH+0x200>)
34183e2e:	fbb2 f3f3 	udiv	r3, r2, r3
34183e32:	61bb      	str	r3, [r7, #24]

  prev_error = ti2cspeed;
34183e34:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183e36:	643b      	str	r3, [r7, #64]	@ 0x40

  for (uint32_t count = 0; count < I2c_valid_timing_nbr; count++)
34183e38:	2300      	movs	r3, #0
34183e3a:	637b      	str	r3, [r7, #52]	@ 0x34
34183e3c:	e0a3      	b.n	34183f86 <I2C_Compute_SCLL_SCLH+0x1e6>
  {
    /* tPRESC = (PRESC+1) x tI2CCLK*/
    uint32_t tpresc = (I2c_valid_timing[count].presc + 1U) * ti2cclk;
34183e3e:	495a      	ldr	r1, [pc, #360]	@ (34183fa8 <I2C_Compute_SCLL_SCLH+0x208>)
34183e40:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
34183e42:	4613      	mov	r3, r2
34183e44:	009b      	lsls	r3, r3, #2
34183e46:	4413      	add	r3, r2
34183e48:	009b      	lsls	r3, r3, #2
34183e4a:	440b      	add	r3, r1
34183e4c:	681b      	ldr	r3, [r3, #0]
34183e4e:	1c5a      	adds	r2, r3, #1
34183e50:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34183e52:	fb02 f303 	mul.w	r3, r2, r3
34183e56:	617b      	str	r3, [r7, #20]

    for (scll = 0; scll < I2C_SCLL_MAX; scll++)
34183e58:	2300      	movs	r3, #0
34183e5a:	63fb      	str	r3, [r7, #60]	@ 0x3c
34183e5c:	e08c      	b.n	34183f78 <I2C_Compute_SCLL_SCLH+0x1d8>
    {
      /* tLOW(min) <= tAF(min) + tDNF + 2 x tI2CCLK + [(SCLL+1) x tPRESC ] */
      uint32_t tscl_l = tafdel_min + dnf_delay + (2U * ti2cclk) + ((scll + 1U) * tpresc);
34183e5e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
34183e60:	6a3b      	ldr	r3, [r7, #32]
34183e62:	441a      	add	r2, r3
34183e64:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34183e66:	3301      	adds	r3, #1
34183e68:	6979      	ldr	r1, [r7, #20]
34183e6a:	fb03 f101 	mul.w	r1, r3, r1
34183e6e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34183e70:	005b      	lsls	r3, r3, #1
34183e72:	440b      	add	r3, r1
34183e74:	4413      	add	r3, r2
34183e76:	613b      	str	r3, [r7, #16]


      /* The I2CCLK period tI2CCLK must respect the following conditions:
      tI2CCLK < (tLOW - tfilters) / 4 and tI2CCLK < tHIGH */
      if ((tscl_l > I2C_Charac[I2C_speed].lscl_min) && (ti2cclk < ((tscl_l - tafdel_min - dnf_delay) / 4U)))
34183e78:	4a4a      	ldr	r2, [pc, #296]	@ (34183fa4 <I2C_Compute_SCLL_SCLH+0x204>)
34183e7a:	683b      	ldr	r3, [r7, #0]
34183e7c:	212c      	movs	r1, #44	@ 0x2c
34183e7e:	fb01 f303 	mul.w	r3, r1, r3
34183e82:	4413      	add	r3, r2
34183e84:	3318      	adds	r3, #24
34183e86:	681b      	ldr	r3, [r3, #0]
34183e88:	693a      	ldr	r2, [r7, #16]
34183e8a:	429a      	cmp	r2, r3
34183e8c:	d971      	bls.n	34183f72 <I2C_Compute_SCLL_SCLH+0x1d2>
34183e8e:	693a      	ldr	r2, [r7, #16]
34183e90:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34183e92:	1ad2      	subs	r2, r2, r3
34183e94:	6a3b      	ldr	r3, [r7, #32]
34183e96:	1ad3      	subs	r3, r2, r3
34183e98:	089b      	lsrs	r3, r3, #2
34183e9a:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
34183e9c:	429a      	cmp	r2, r3
34183e9e:	d268      	bcs.n	34183f72 <I2C_Compute_SCLL_SCLH+0x1d2>
      {
        for (sclh = 0; sclh < I2C_SCLH_MAX; sclh++)
34183ea0:	2300      	movs	r3, #0
34183ea2:	63bb      	str	r3, [r7, #56]	@ 0x38
34183ea4:	e062      	b.n	34183f6c <I2C_Compute_SCLL_SCLH+0x1cc>
        {
          /* tHIGH(min) <= tAF(min) + tDNF + 2 x tI2CCLK + [(SCLH+1) x tPRESC] */
          uint32_t tscl_h = tafdel_min + dnf_delay + (2U * ti2cclk) + ((sclh + 1U) * tpresc);
34183ea6:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
34183ea8:	6a3b      	ldr	r3, [r7, #32]
34183eaa:	441a      	add	r2, r3
34183eac:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34183eae:	3301      	adds	r3, #1
34183eb0:	6979      	ldr	r1, [r7, #20]
34183eb2:	fb03 f101 	mul.w	r1, r3, r1
34183eb6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34183eb8:	005b      	lsls	r3, r3, #1
34183eba:	440b      	add	r3, r1
34183ebc:	4413      	add	r3, r2
34183ebe:	60fb      	str	r3, [r7, #12]

          /* tSCL = tf + tLOW + tr + tHIGH */
          uint32_t tscl = tscl_l + tscl_h + I2C_Charac[I2C_speed].trise + I2C_Charac[I2C_speed].tfall;
34183ec0:	693a      	ldr	r2, [r7, #16]
34183ec2:	68fb      	ldr	r3, [r7, #12]
34183ec4:	441a      	add	r2, r3
34183ec6:	4937      	ldr	r1, [pc, #220]	@ (34183fa4 <I2C_Compute_SCLL_SCLH+0x204>)
34183ec8:	683b      	ldr	r3, [r7, #0]
34183eca:	202c      	movs	r0, #44	@ 0x2c
34183ecc:	fb00 f303 	mul.w	r3, r0, r3
34183ed0:	440b      	add	r3, r1
34183ed2:	3320      	adds	r3, #32
34183ed4:	681b      	ldr	r3, [r3, #0]
34183ed6:	441a      	add	r2, r3
34183ed8:	4932      	ldr	r1, [pc, #200]	@ (34183fa4 <I2C_Compute_SCLL_SCLH+0x204>)
34183eda:	683b      	ldr	r3, [r7, #0]
34183edc:	202c      	movs	r0, #44	@ 0x2c
34183ede:	fb00 f303 	mul.w	r3, r0, r3
34183ee2:	440b      	add	r3, r1
34183ee4:	3324      	adds	r3, #36	@ 0x24
34183ee6:	681b      	ldr	r3, [r3, #0]
34183ee8:	4413      	add	r3, r2
34183eea:	60bb      	str	r3, [r7, #8]

          if ((tscl >= clk_min) && (tscl <= clk_max) && (tscl_h >= I2C_Charac[I2C_speed].hscl_min) && (ti2cclk < tscl_h))
34183eec:	68ba      	ldr	r2, [r7, #8]
34183eee:	69bb      	ldr	r3, [r7, #24]
34183ef0:	429a      	cmp	r2, r3
34183ef2:	d338      	bcc.n	34183f66 <I2C_Compute_SCLL_SCLH+0x1c6>
34183ef4:	68ba      	ldr	r2, [r7, #8]
34183ef6:	69fb      	ldr	r3, [r7, #28]
34183ef8:	429a      	cmp	r2, r3
34183efa:	d834      	bhi.n	34183f66 <I2C_Compute_SCLL_SCLH+0x1c6>
34183efc:	4a29      	ldr	r2, [pc, #164]	@ (34183fa4 <I2C_Compute_SCLL_SCLH+0x204>)
34183efe:	683b      	ldr	r3, [r7, #0]
34183f00:	212c      	movs	r1, #44	@ 0x2c
34183f02:	fb01 f303 	mul.w	r3, r1, r3
34183f06:	4413      	add	r3, r2
34183f08:	331c      	adds	r3, #28
34183f0a:	681b      	ldr	r3, [r3, #0]
34183f0c:	68fa      	ldr	r2, [r7, #12]
34183f0e:	429a      	cmp	r2, r3
34183f10:	d329      	bcc.n	34183f66 <I2C_Compute_SCLL_SCLH+0x1c6>
34183f12:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
34183f14:	68fb      	ldr	r3, [r7, #12]
34183f16:	429a      	cmp	r2, r3
34183f18:	d225      	bcs.n	34183f66 <I2C_Compute_SCLL_SCLH+0x1c6>
          {
            int32_t error = (int32_t)tscl - (int32_t)ti2cspeed;
34183f1a:	68ba      	ldr	r2, [r7, #8]
34183f1c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183f1e:	1ad3      	subs	r3, r2, r3
34183f20:	633b      	str	r3, [r7, #48]	@ 0x30

            if (error < 0)
34183f22:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34183f24:	2b00      	cmp	r3, #0
34183f26:	da02      	bge.n	34183f2e <I2C_Compute_SCLL_SCLH+0x18e>
            {
              error = -error;
34183f28:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34183f2a:	425b      	negs	r3, r3
34183f2c:	633b      	str	r3, [r7, #48]	@ 0x30
            }

            /* look for the timings with the lowest clock error */
            if ((uint32_t)error < prev_error)
34183f2e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34183f30:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
34183f32:	429a      	cmp	r2, r3
34183f34:	d917      	bls.n	34183f66 <I2C_Compute_SCLL_SCLH+0x1c6>
            {
              prev_error = (uint32_t)error;
34183f36:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34183f38:	643b      	str	r3, [r7, #64]	@ 0x40
              I2c_valid_timing[count].scll = scll;
34183f3a:	491b      	ldr	r1, [pc, #108]	@ (34183fa8 <I2C_Compute_SCLL_SCLH+0x208>)
34183f3c:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
34183f3e:	4613      	mov	r3, r2
34183f40:	009b      	lsls	r3, r3, #2
34183f42:	4413      	add	r3, r2
34183f44:	009b      	lsls	r3, r3, #2
34183f46:	440b      	add	r3, r1
34183f48:	3310      	adds	r3, #16
34183f4a:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
34183f4c:	601a      	str	r2, [r3, #0]
              I2c_valid_timing[count].sclh = sclh;
34183f4e:	4916      	ldr	r1, [pc, #88]	@ (34183fa8 <I2C_Compute_SCLL_SCLH+0x208>)
34183f50:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
34183f52:	4613      	mov	r3, r2
34183f54:	009b      	lsls	r3, r3, #2
34183f56:	4413      	add	r3, r2
34183f58:	009b      	lsls	r3, r3, #2
34183f5a:	440b      	add	r3, r1
34183f5c:	330c      	adds	r3, #12
34183f5e:	6bba      	ldr	r2, [r7, #56]	@ 0x38
34183f60:	601a      	str	r2, [r3, #0]
              ret = count;
34183f62:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34183f64:	647b      	str	r3, [r7, #68]	@ 0x44
        for (sclh = 0; sclh < I2C_SCLH_MAX; sclh++)
34183f66:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34183f68:	3301      	adds	r3, #1
34183f6a:	63bb      	str	r3, [r7, #56]	@ 0x38
34183f6c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34183f6e:	2bff      	cmp	r3, #255	@ 0xff
34183f70:	d999      	bls.n	34183ea6 <I2C_Compute_SCLL_SCLH+0x106>
    for (scll = 0; scll < I2C_SCLL_MAX; scll++)
34183f72:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34183f74:	3301      	adds	r3, #1
34183f76:	63fb      	str	r3, [r7, #60]	@ 0x3c
34183f78:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34183f7a:	2bff      	cmp	r3, #255	@ 0xff
34183f7c:	f67f af6f 	bls.w	34183e5e <I2C_Compute_SCLL_SCLH+0xbe>
  for (uint32_t count = 0; count < I2c_valid_timing_nbr; count++)
34183f80:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34183f82:	3301      	adds	r3, #1
34183f84:	637b      	str	r3, [r7, #52]	@ 0x34
34183f86:	4b09      	ldr	r3, [pc, #36]	@ (34183fac <I2C_Compute_SCLL_SCLH+0x20c>)
34183f88:	681b      	ldr	r3, [r3, #0]
34183f8a:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
34183f8c:	429a      	cmp	r2, r3
34183f8e:	f4ff af56 	bcc.w	34183e3e <I2C_Compute_SCLL_SCLH+0x9e>
        }
      }
    }
  }

  return ret;
34183f92:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
}
34183f94:	4618      	mov	r0, r3
34183f96:	374c      	adds	r7, #76	@ 0x4c
34183f98:	46bd      	mov	sp, r7
34183f9a:	f85d 7b04 	ldr.w	r7, [sp], #4
34183f9e:	4770      	bx	lr
34183fa0:	3b9aca00 	.word	0x3b9aca00
34183fa4:	3419e354 	.word	0x3419e354
34183fa8:	341c2280 	.word	0x341c2280
34183fac:	341c2c80 	.word	0x341c2c80

34183fb0 <I2C2_MspInit>:
  * @brief  Initializes I2C MSP.
  * @param  phi2c  I2C handler
  * @retval None
  */
static void I2C2_MspInit(I2C_HandleTypeDef *phi2c)
{
34183fb0:	b580      	push	{r7, lr}
34183fb2:	b088      	sub	sp, #32
34183fb4:	af00      	add	r7, sp, #0
34183fb6:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(phi2c);

  /*** Configure the GPIOs ***/
  /* Enable SCL GPIO clock */
  BUS_I2C2_SCL_GPIO_CLK_ENABLE();
34183fb8:	2008      	movs	r0, #8
34183fba:	f7ff fc1b 	bl	341837f4 <LL_AHB4_GRP1_EnableClock>
  /* Enable SDA GPIO clock */
  BUS_I2C2_SDA_GPIO_CLK_ENABLE();
34183fbe:	2008      	movs	r0, #8
34183fc0:	f7ff fc18 	bl	341837f4 <LL_AHB4_GRP1_EnableClock>

  /* Configure I2C Tx as alternate function */
  gpio_init_structure.Pin       = BUS_I2C2_SCL_PIN;
34183fc4:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
34183fc8:	60fb      	str	r3, [r7, #12]
  gpio_init_structure.Mode      = GPIO_MODE_AF_OD;
34183fca:	2312      	movs	r3, #18
34183fcc:	613b      	str	r3, [r7, #16]
  gpio_init_structure.Pull      = GPIO_NOPULL;
34183fce:	2300      	movs	r3, #0
34183fd0:	617b      	str	r3, [r7, #20]
  gpio_init_structure.Speed     = GPIO_SPEED_FREQ_HIGH;
34183fd2:	2302      	movs	r3, #2
34183fd4:	61bb      	str	r3, [r7, #24]
  gpio_init_structure.Alternate = BUS_I2C2_SCL_AF;
34183fd6:	2304      	movs	r3, #4
34183fd8:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(BUS_I2C2_SCL_GPIO_PORT, &gpio_init_structure);
34183fda:	f107 030c 	add.w	r3, r7, #12
34183fde:	4619      	mov	r1, r3
34183fe0:	4811      	ldr	r0, [pc, #68]	@ (34184028 <I2C2_MspInit+0x78>)
34183fe2:	f002 ff2f 	bl	34186e44 <HAL_GPIO_Init>

  /* Configure I2C Rx as alternate function */
  gpio_init_structure.Pin       = BUS_I2C2_SDA_PIN;
34183fe6:	2310      	movs	r3, #16
34183fe8:	60fb      	str	r3, [r7, #12]
  gpio_init_structure.Mode      = GPIO_MODE_AF_OD;
34183fea:	2312      	movs	r3, #18
34183fec:	613b      	str	r3, [r7, #16]
  gpio_init_structure.Pull      = GPIO_NOPULL;
34183fee:	2300      	movs	r3, #0
34183ff0:	617b      	str	r3, [r7, #20]
  gpio_init_structure.Speed     = GPIO_SPEED_FREQ_HIGH;
34183ff2:	2302      	movs	r3, #2
34183ff4:	61bb      	str	r3, [r7, #24]
  gpio_init_structure.Alternate = BUS_I2C2_SDA_AF;
34183ff6:	2304      	movs	r3, #4
34183ff8:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(BUS_I2C2_SDA_GPIO_PORT, &gpio_init_structure);
34183ffa:	f107 030c 	add.w	r3, r7, #12
34183ffe:	4619      	mov	r1, r3
34184000:	4809      	ldr	r0, [pc, #36]	@ (34184028 <I2C2_MspInit+0x78>)
34184002:	f002 ff1f 	bl	34186e44 <HAL_GPIO_Init>

  /*** Configure the I2C peripheral ***/
  /* Enable I2C clock */
  BUS_I2C2_CLK_ENABLE();
34184006:	f44f 0080 	mov.w	r0, #4194304	@ 0x400000
3418400a:	f7ff fc09 	bl	34183820 <LL_APB1_GRP1_EnableClock>

  /* Force the I2C peripheral clock reset */
  BUS_I2C2_FORCE_RESET();
3418400e:	f44f 0080 	mov.w	r0, #4194304	@ 0x400000
34184012:	f7ff fc2f 	bl	34183874 <LL_APB1_GRP1_ForceReset>

  /* Release the I2C peripheral clock reset */
  BUS_I2C2_RELEASE_RESET();
34184016:	f44f 0080 	mov.w	r0, #4194304	@ 0x400000
3418401a:	f7ff fc3b 	bl	34183894 <LL_APB1_GRP1_ReleaseReset>
}
3418401e:	bf00      	nop
34184020:	3720      	adds	r7, #32
34184022:	46bd      	mov	sp, r7
34184024:	bd80      	pop	{r7, pc}
34184026:	bf00      	nop
34184028:	56020c00 	.word	0x56020c00

3418402c <I2C2_MspDeInit>:
  * @brief  DeInitializes I2C MSP.
  * @param  phi2c  I2C handler
  * @retval None
  */
static void I2C2_MspDeInit(I2C_HandleTypeDef *phi2c)
{
3418402c:	b580      	push	{r7, lr}
3418402e:	b088      	sub	sp, #32
34184030:	af00      	add	r7, sp, #0
34184032:	6078      	str	r0, [r7, #4]

  /* Prevent unused argument(s) compilation warning */
  UNUSED(phi2c);

  /* Configure I2C Tx, Rx as alternate function */
  gpio_init_structure.Pin = BUS_I2C2_SCL_PIN;
34184034:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
34184038:	60fb      	str	r3, [r7, #12]
  HAL_GPIO_DeInit(BUS_I2C2_SCL_GPIO_PORT, gpio_init_structure.Pin );
3418403a:	68fb      	ldr	r3, [r7, #12]
3418403c:	4619      	mov	r1, r3
3418403e:	4809      	ldr	r0, [pc, #36]	@ (34184064 <I2C2_MspDeInit+0x38>)
34184040:	f003 f8b2 	bl	341871a8 <HAL_GPIO_DeInit>
  gpio_init_structure.Pin = BUS_I2C2_SDA_PIN;
34184044:	2310      	movs	r3, #16
34184046:	60fb      	str	r3, [r7, #12]
  HAL_GPIO_DeInit(BUS_I2C2_SDA_GPIO_PORT, gpio_init_structure.Pin);
34184048:	68fb      	ldr	r3, [r7, #12]
3418404a:	4619      	mov	r1, r3
3418404c:	4805      	ldr	r0, [pc, #20]	@ (34184064 <I2C2_MspDeInit+0x38>)
3418404e:	f003 f8ab 	bl	341871a8 <HAL_GPIO_DeInit>

  /* Disable I2C clock */
  BUS_I2C2_CLK_DISABLE();
34184052:	f44f 0080 	mov.w	r0, #4194304	@ 0x400000
34184056:	f7ff fbf9 	bl	3418384c <LL_APB1_GRP1_DisableClock>
}
3418405a:	bf00      	nop
3418405c:	3720      	adds	r7, #32
3418405e:	46bd      	mov	sp, r7
34184060:	bd80      	pop	{r7, pc}
34184062:	bf00      	nop
34184064:	56020c00 	.word	0x56020c00

34184068 <I2C2_WriteReg>:
  * @param  pData      The target register value to be written
  * @param  Length     data length in bytes
  * @retval BSP status
  */
static int32_t I2C2_WriteReg(uint16_t DevAddr, uint16_t Reg, uint16_t MemAddSize, uint8_t *pData, uint16_t Length)
{
34184068:	b580      	push	{r7, lr}
3418406a:	b088      	sub	sp, #32
3418406c:	af04      	add	r7, sp, #16
3418406e:	607b      	str	r3, [r7, #4]
34184070:	4603      	mov	r3, r0
34184072:	81fb      	strh	r3, [r7, #14]
34184074:	460b      	mov	r3, r1
34184076:	81bb      	strh	r3, [r7, #12]
34184078:	4613      	mov	r3, r2
3418407a:	817b      	strh	r3, [r7, #10]
  if (HAL_I2C_Mem_Write(&hbus_i2c2, DevAddr, Reg, MemAddSize, pData, Length, 1000) == HAL_OK)
3418407c:	8978      	ldrh	r0, [r7, #10]
3418407e:	89ba      	ldrh	r2, [r7, #12]
34184080:	89f9      	ldrh	r1, [r7, #14]
34184082:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
34184086:	9302      	str	r3, [sp, #8]
34184088:	8b3b      	ldrh	r3, [r7, #24]
3418408a:	9301      	str	r3, [sp, #4]
3418408c:	687b      	ldr	r3, [r7, #4]
3418408e:	9300      	str	r3, [sp, #0]
34184090:	4603      	mov	r3, r0
34184092:	4807      	ldr	r0, [pc, #28]	@ (341840b0 <I2C2_WriteReg+0x48>)
34184094:	f003 fb12 	bl	341876bc <HAL_I2C_Mem_Write>
34184098:	4603      	mov	r3, r0
3418409a:	2b00      	cmp	r3, #0
3418409c:	d101      	bne.n	341840a2 <I2C2_WriteReg+0x3a>
  {
    return BSP_ERROR_NONE;
3418409e:	2300      	movs	r3, #0
341840a0:	e001      	b.n	341840a6 <I2C2_WriteReg+0x3e>
  }

  return BSP_ERROR_BUS_FAILURE;
341840a2:	f06f 0307 	mvn.w	r3, #7
}
341840a6:	4618      	mov	r0, r3
341840a8:	3710      	adds	r7, #16
341840aa:	46bd      	mov	sp, r7
341840ac:	bd80      	pop	{r7, pc}
341840ae:	bf00      	nop
341840b0:	341c2c84 	.word	0x341c2c84

341840b4 <I2C2_ReadReg>:
  * @param  pData      The target register value to be read
  * @param  Length     data length in bytes
  * @retval BSP status
  */
static int32_t I2C2_ReadReg(uint16_t DevAddr, uint16_t Reg, uint16_t MemAddSize, uint8_t *pData, uint16_t Length)
{
341840b4:	b580      	push	{r7, lr}
341840b6:	b088      	sub	sp, #32
341840b8:	af04      	add	r7, sp, #16
341840ba:	607b      	str	r3, [r7, #4]
341840bc:	4603      	mov	r3, r0
341840be:	81fb      	strh	r3, [r7, #14]
341840c0:	460b      	mov	r3, r1
341840c2:	81bb      	strh	r3, [r7, #12]
341840c4:	4613      	mov	r3, r2
341840c6:	817b      	strh	r3, [r7, #10]
  if (HAL_I2C_Mem_Read(&hbus_i2c2, DevAddr, Reg, MemAddSize, pData, Length, 1000) == HAL_OK)
341840c8:	8978      	ldrh	r0, [r7, #10]
341840ca:	89ba      	ldrh	r2, [r7, #12]
341840cc:	89f9      	ldrh	r1, [r7, #14]
341840ce:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
341840d2:	9302      	str	r3, [sp, #8]
341840d4:	8b3b      	ldrh	r3, [r7, #24]
341840d6:	9301      	str	r3, [sp, #4]
341840d8:	687b      	ldr	r3, [r7, #4]
341840da:	9300      	str	r3, [sp, #0]
341840dc:	4603      	mov	r3, r0
341840de:	4807      	ldr	r0, [pc, #28]	@ (341840fc <I2C2_ReadReg+0x48>)
341840e0:	f003 fc00 	bl	341878e4 <HAL_I2C_Mem_Read>
341840e4:	4603      	mov	r3, r0
341840e6:	2b00      	cmp	r3, #0
341840e8:	d101      	bne.n	341840ee <I2C2_ReadReg+0x3a>
  {
    return BSP_ERROR_NONE;
341840ea:	2300      	movs	r3, #0
341840ec:	e001      	b.n	341840f2 <I2C2_ReadReg+0x3e>
  }

  return BSP_ERROR_BUS_FAILURE;
341840ee:	f06f 0307 	mvn.w	r3, #7
}
341840f2:	4618      	mov	r0, r3
341840f4:	3710      	adds	r7, #16
341840f6:	46bd      	mov	sp, r7
341840f8:	bd80      	pop	{r7, pc}
341840fa:	bf00      	nop
341840fc:	341c2c84 	.word	0x341c2c84

34184100 <__NVIC_EnableIRQ>:
{
34184100:	b480      	push	{r7}
34184102:	b083      	sub	sp, #12
34184104:	af00      	add	r7, sp, #0
34184106:	4603      	mov	r3, r0
34184108:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
3418410a:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
3418410e:	2b00      	cmp	r3, #0
34184110:	db0b      	blt.n	3418412a <__NVIC_EnableIRQ+0x2a>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
34184112:	88fb      	ldrh	r3, [r7, #6]
34184114:	f003 021f 	and.w	r2, r3, #31
34184118:	4907      	ldr	r1, [pc, #28]	@ (34184138 <__NVIC_EnableIRQ+0x38>)
3418411a:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
3418411e:	095b      	lsrs	r3, r3, #5
34184120:	2001      	movs	r0, #1
34184122:	fa00 f202 	lsl.w	r2, r0, r2
34184126:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
3418412a:	bf00      	nop
3418412c:	370c      	adds	r7, #12
3418412e:	46bd      	mov	sp, r7
34184130:	f85d 7b04 	ldr.w	r7, [sp], #4
34184134:	4770      	bx	lr
34184136:	bf00      	nop
34184138:	e000e100 	.word	0xe000e100

3418413c <__NVIC_SetPriority>:
{
3418413c:	b480      	push	{r7}
3418413e:	b083      	sub	sp, #12
34184140:	af00      	add	r7, sp, #0
34184142:	4603      	mov	r3, r0
34184144:	6039      	str	r1, [r7, #0]
34184146:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
34184148:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
3418414c:	2b00      	cmp	r3, #0
3418414e:	db0a      	blt.n	34184166 <__NVIC_SetPriority+0x2a>
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
34184150:	683b      	ldr	r3, [r7, #0]
34184152:	b2da      	uxtb	r2, r3
34184154:	490c      	ldr	r1, [pc, #48]	@ (34184188 <__NVIC_SetPriority+0x4c>)
34184156:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
3418415a:	0112      	lsls	r2, r2, #4
3418415c:	b2d2      	uxtb	r2, r2
3418415e:	440b      	add	r3, r1
34184160:	f883 2300 	strb.w	r2, [r3, #768]	@ 0x300
}
34184164:	e00a      	b.n	3418417c <__NVIC_SetPriority+0x40>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
34184166:	683b      	ldr	r3, [r7, #0]
34184168:	b2da      	uxtb	r2, r3
3418416a:	4908      	ldr	r1, [pc, #32]	@ (3418418c <__NVIC_SetPriority+0x50>)
3418416c:	88fb      	ldrh	r3, [r7, #6]
3418416e:	f003 030f 	and.w	r3, r3, #15
34184172:	3b04      	subs	r3, #4
34184174:	0112      	lsls	r2, r2, #4
34184176:	b2d2      	uxtb	r2, r2
34184178:	440b      	add	r3, r1
3418417a:	761a      	strb	r2, [r3, #24]
}
3418417c:	bf00      	nop
3418417e:	370c      	adds	r7, #12
34184180:	46bd      	mov	sp, r7
34184182:	f85d 7b04 	ldr.w	r7, [sp], #4
34184186:	4770      	bx	lr
34184188:	e000e100 	.word	0xe000e100
3418418c:	e000ed00 	.word	0xe000ed00

34184190 <LL_AHB1_GRP1_EnableClock>:
{
34184190:	b480      	push	{r7}
34184192:	b085      	sub	sp, #20
34184194:	af00      	add	r7, sp, #0
34184196:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB1ENSR, Periphs);
34184198:	4a07      	ldr	r2, [pc, #28]	@ (341841b8 <LL_AHB1_GRP1_EnableClock+0x28>)
3418419a:	687b      	ldr	r3, [r7, #4]
3418419c:	f8c2 3a50 	str.w	r3, [r2, #2640]	@ 0xa50
  tmpreg = READ_REG(RCC->AHB1ENR);
341841a0:	4b05      	ldr	r3, [pc, #20]	@ (341841b8 <LL_AHB1_GRP1_EnableClock+0x28>)
341841a2:	f8d3 3250 	ldr.w	r3, [r3, #592]	@ 0x250
341841a6:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
341841a8:	68fb      	ldr	r3, [r7, #12]
}
341841aa:	bf00      	nop
341841ac:	3714      	adds	r7, #20
341841ae:	46bd      	mov	sp, r7
341841b0:	f85d 7b04 	ldr.w	r7, [sp], #4
341841b4:	4770      	bx	lr
341841b6:	bf00      	nop
341841b8:	56028000 	.word	0x56028000

341841bc <LL_AHB4_GRP1_EnableClock>:
{
341841bc:	b480      	push	{r7}
341841be:	b085      	sub	sp, #20
341841c0:	af00      	add	r7, sp, #0
341841c2:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB4ENSR, Periphs);
341841c4:	4a07      	ldr	r2, [pc, #28]	@ (341841e4 <LL_AHB4_GRP1_EnableClock+0x28>)
341841c6:	687b      	ldr	r3, [r7, #4]
341841c8:	f8c2 3a5c 	str.w	r3, [r2, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
341841cc:	4b05      	ldr	r3, [pc, #20]	@ (341841e4 <LL_AHB4_GRP1_EnableClock+0x28>)
341841ce:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
341841d2:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
341841d4:	68fb      	ldr	r3, [r7, #12]
}
341841d6:	bf00      	nop
341841d8:	3714      	adds	r7, #20
341841da:	46bd      	mov	sp, r7
341841dc:	f85d 7b04 	ldr.w	r7, [sp], #4
341841e0:	4770      	bx	lr
341841e2:	bf00      	nop
341841e4:	56028000 	.word	0x56028000

341841e8 <LL_ADC_REG_ReadConversionData12>:
  * @rmtoll DR       RDATA          LL_ADC_REG_ReadConversionData12
  * @param  ADCx ADC instance
  * @retval Value between Min_Data=0x000 and Max_Data=0xFFF
  */
__STATIC_INLINE uint16_t LL_ADC_REG_ReadConversionData12(const ADC_TypeDef *ADCx)
{
341841e8:	b480      	push	{r7}
341841ea:	b083      	sub	sp, #12
341841ec:	af00      	add	r7, sp, #0
341841ee:	6078      	str	r0, [r7, #4]
  return (uint16_t)(READ_BIT(ADCx->DR, ADC_DR_RDATA));
341841f0:	687b      	ldr	r3, [r7, #4]
341841f2:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
341841f4:	b29b      	uxth	r3, r3
}
341841f6:	4618      	mov	r0, r3
341841f8:	370c      	adds	r7, #12
341841fa:	46bd      	mov	sp, r7
341841fc:	f85d 7b04 	ldr.w	r7, [sp], #4
34184200:	4770      	bx	lr

34184202 <LL_GPIO_SetPinMode>:
  *         @arg @ref LL_GPIO_MODE_ALTERNATE
  *         @arg @ref LL_GPIO_MODE_ANALOG
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_SetPinMode(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t Mode)
{
34184202:	b480      	push	{r7}
34184204:	b08b      	sub	sp, #44	@ 0x2c
34184206:	af00      	add	r7, sp, #0
34184208:	60f8      	str	r0, [r7, #12]
3418420a:	60b9      	str	r1, [r7, #8]
3418420c:	607a      	str	r2, [r7, #4]
  MODIFY_REG(GPIOx->MODER, (GPIO_MODER_MODE0 << (POSITION_VAL(Pin) * GPIO_MODER_MODE1_Pos)),
3418420e:	68fb      	ldr	r3, [r7, #12]
34184210:	681a      	ldr	r2, [r3, #0]
34184212:	68bb      	ldr	r3, [r7, #8]
34184214:	617b      	str	r3, [r7, #20]
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
34184216:	697b      	ldr	r3, [r7, #20]
34184218:	fa93 f3a3 	rbit	r3, r3
3418421c:	613b      	str	r3, [r7, #16]
  return result;
3418421e:	693b      	ldr	r3, [r7, #16]
34184220:	61bb      	str	r3, [r7, #24]
  if (value == 0U)
34184222:	69bb      	ldr	r3, [r7, #24]
34184224:	2b00      	cmp	r3, #0
34184226:	d101      	bne.n	3418422c <LL_GPIO_SetPinMode+0x2a>
    return 32U;
34184228:	2320      	movs	r3, #32
3418422a:	e003      	b.n	34184234 <LL_GPIO_SetPinMode+0x32>
  return __builtin_clz(value);
3418422c:	69bb      	ldr	r3, [r7, #24]
3418422e:	fab3 f383 	clz	r3, r3
34184232:	b2db      	uxtb	r3, r3
34184234:	005b      	lsls	r3, r3, #1
34184236:	2103      	movs	r1, #3
34184238:	fa01 f303 	lsl.w	r3, r1, r3
3418423c:	43db      	mvns	r3, r3
3418423e:	401a      	ands	r2, r3
34184240:	68bb      	ldr	r3, [r7, #8]
34184242:	623b      	str	r3, [r7, #32]
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
34184244:	6a3b      	ldr	r3, [r7, #32]
34184246:	fa93 f3a3 	rbit	r3, r3
3418424a:	61fb      	str	r3, [r7, #28]
  return result;
3418424c:	69fb      	ldr	r3, [r7, #28]
3418424e:	627b      	str	r3, [r7, #36]	@ 0x24
  if (value == 0U)
34184250:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34184252:	2b00      	cmp	r3, #0
34184254:	d101      	bne.n	3418425a <LL_GPIO_SetPinMode+0x58>
    return 32U;
34184256:	2320      	movs	r3, #32
34184258:	e003      	b.n	34184262 <LL_GPIO_SetPinMode+0x60>
  return __builtin_clz(value);
3418425a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3418425c:	fab3 f383 	clz	r3, r3
34184260:	b2db      	uxtb	r3, r3
34184262:	005b      	lsls	r3, r3, #1
34184264:	6879      	ldr	r1, [r7, #4]
34184266:	fa01 f303 	lsl.w	r3, r1, r3
3418426a:	431a      	orrs	r2, r3
3418426c:	68fb      	ldr	r3, [r7, #12]
3418426e:	601a      	str	r2, [r3, #0]
             (Mode << (POSITION_VAL(Pin) * GPIO_MODER_MODE1_Pos)));
}
34184270:	bf00      	nop
34184272:	372c      	adds	r7, #44	@ 0x2c
34184274:	46bd      	mov	sp, r7
34184276:	f85d 7b04 	ldr.w	r7, [sp], #4
3418427a:	4770      	bx	lr

3418427c <LL_GPIO_SetPinOutputType>:
  *         @arg @ref LL_GPIO_OUTPUT_PUSHPULL
  *         @arg @ref LL_GPIO_OUTPUT_OPENDRAIN
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_SetPinOutputType(GPIO_TypeDef *GPIOx, uint32_t PinMask, uint32_t OutputType)
{
3418427c:	b480      	push	{r7}
3418427e:	b085      	sub	sp, #20
34184280:	af00      	add	r7, sp, #0
34184282:	60f8      	str	r0, [r7, #12]
34184284:	60b9      	str	r1, [r7, #8]
34184286:	607a      	str	r2, [r7, #4]
  MODIFY_REG(GPIOx->OTYPER, PinMask, (PinMask * OutputType));
34184288:	68fb      	ldr	r3, [r7, #12]
3418428a:	685a      	ldr	r2, [r3, #4]
3418428c:	68bb      	ldr	r3, [r7, #8]
3418428e:	43db      	mvns	r3, r3
34184290:	401a      	ands	r2, r3
34184292:	68bb      	ldr	r3, [r7, #8]
34184294:	6879      	ldr	r1, [r7, #4]
34184296:	fb01 f303 	mul.w	r3, r1, r3
3418429a:	431a      	orrs	r2, r3
3418429c:	68fb      	ldr	r3, [r7, #12]
3418429e:	605a      	str	r2, [r3, #4]
}
341842a0:	bf00      	nop
341842a2:	3714      	adds	r7, #20
341842a4:	46bd      	mov	sp, r7
341842a6:	f85d 7b04 	ldr.w	r7, [sp], #4
341842aa:	4770      	bx	lr

341842ac <LL_GPIO_SetPinSpeed>:
  *         @arg @ref LL_GPIO_SPEED_FREQ_HIGH
  *         @arg @ref LL_GPIO_SPEED_FREQ_VERY_HIGH
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_SetPinSpeed(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t  Speed)
{
341842ac:	b480      	push	{r7}
341842ae:	b08b      	sub	sp, #44	@ 0x2c
341842b0:	af00      	add	r7, sp, #0
341842b2:	60f8      	str	r0, [r7, #12]
341842b4:	60b9      	str	r1, [r7, #8]
341842b6:	607a      	str	r2, [r7, #4]
  MODIFY_REG(GPIOx->OSPEEDR, (GPIO_OSPEEDR_OSPEED0 << (POSITION_VAL(Pin) * GPIO_OSPEEDR_OSPEED1_Pos)),
341842b8:	68fb      	ldr	r3, [r7, #12]
341842ba:	689a      	ldr	r2, [r3, #8]
341842bc:	68bb      	ldr	r3, [r7, #8]
341842be:	617b      	str	r3, [r7, #20]
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
341842c0:	697b      	ldr	r3, [r7, #20]
341842c2:	fa93 f3a3 	rbit	r3, r3
341842c6:	613b      	str	r3, [r7, #16]
  return result;
341842c8:	693b      	ldr	r3, [r7, #16]
341842ca:	61bb      	str	r3, [r7, #24]
  if (value == 0U)
341842cc:	69bb      	ldr	r3, [r7, #24]
341842ce:	2b00      	cmp	r3, #0
341842d0:	d101      	bne.n	341842d6 <LL_GPIO_SetPinSpeed+0x2a>
    return 32U;
341842d2:	2320      	movs	r3, #32
341842d4:	e003      	b.n	341842de <LL_GPIO_SetPinSpeed+0x32>
  return __builtin_clz(value);
341842d6:	69bb      	ldr	r3, [r7, #24]
341842d8:	fab3 f383 	clz	r3, r3
341842dc:	b2db      	uxtb	r3, r3
341842de:	005b      	lsls	r3, r3, #1
341842e0:	2103      	movs	r1, #3
341842e2:	fa01 f303 	lsl.w	r3, r1, r3
341842e6:	43db      	mvns	r3, r3
341842e8:	401a      	ands	r2, r3
341842ea:	68bb      	ldr	r3, [r7, #8]
341842ec:	623b      	str	r3, [r7, #32]
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
341842ee:	6a3b      	ldr	r3, [r7, #32]
341842f0:	fa93 f3a3 	rbit	r3, r3
341842f4:	61fb      	str	r3, [r7, #28]
  return result;
341842f6:	69fb      	ldr	r3, [r7, #28]
341842f8:	627b      	str	r3, [r7, #36]	@ 0x24
  if (value == 0U)
341842fa:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
341842fc:	2b00      	cmp	r3, #0
341842fe:	d101      	bne.n	34184304 <LL_GPIO_SetPinSpeed+0x58>
    return 32U;
34184300:	2320      	movs	r3, #32
34184302:	e003      	b.n	3418430c <LL_GPIO_SetPinSpeed+0x60>
  return __builtin_clz(value);
34184304:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34184306:	fab3 f383 	clz	r3, r3
3418430a:	b2db      	uxtb	r3, r3
3418430c:	005b      	lsls	r3, r3, #1
3418430e:	6879      	ldr	r1, [r7, #4]
34184310:	fa01 f303 	lsl.w	r3, r1, r3
34184314:	431a      	orrs	r2, r3
34184316:	68fb      	ldr	r3, [r7, #12]
34184318:	609a      	str	r2, [r3, #8]
             (Speed << (POSITION_VAL(Pin) * GPIO_OSPEEDR_OSPEED1_Pos)));
}
3418431a:	bf00      	nop
3418431c:	372c      	adds	r7, #44	@ 0x2c
3418431e:	46bd      	mov	sp, r7
34184320:	f85d 7b04 	ldr.w	r7, [sp], #4
34184324:	4770      	bx	lr

34184326 <LL_GPIO_SetPinPull>:
  *         @arg @ref LL_GPIO_PULL_UP
  *         @arg @ref LL_GPIO_PULL_DOWN
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_SetPinPull(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t Pull)
{
34184326:	b480      	push	{r7}
34184328:	b08b      	sub	sp, #44	@ 0x2c
3418432a:	af00      	add	r7, sp, #0
3418432c:	60f8      	str	r0, [r7, #12]
3418432e:	60b9      	str	r1, [r7, #8]
34184330:	607a      	str	r2, [r7, #4]
  MODIFY_REG(GPIOx->PUPDR, (GPIO_PUPDR_PUPD0 << (POSITION_VAL(Pin) * GPIO_PUPDR_PUPD1_Pos)),
34184332:	68fb      	ldr	r3, [r7, #12]
34184334:	68da      	ldr	r2, [r3, #12]
34184336:	68bb      	ldr	r3, [r7, #8]
34184338:	617b      	str	r3, [r7, #20]
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
3418433a:	697b      	ldr	r3, [r7, #20]
3418433c:	fa93 f3a3 	rbit	r3, r3
34184340:	613b      	str	r3, [r7, #16]
  return result;
34184342:	693b      	ldr	r3, [r7, #16]
34184344:	61bb      	str	r3, [r7, #24]
  if (value == 0U)
34184346:	69bb      	ldr	r3, [r7, #24]
34184348:	2b00      	cmp	r3, #0
3418434a:	d101      	bne.n	34184350 <LL_GPIO_SetPinPull+0x2a>
    return 32U;
3418434c:	2320      	movs	r3, #32
3418434e:	e003      	b.n	34184358 <LL_GPIO_SetPinPull+0x32>
  return __builtin_clz(value);
34184350:	69bb      	ldr	r3, [r7, #24]
34184352:	fab3 f383 	clz	r3, r3
34184356:	b2db      	uxtb	r3, r3
34184358:	005b      	lsls	r3, r3, #1
3418435a:	2103      	movs	r1, #3
3418435c:	fa01 f303 	lsl.w	r3, r1, r3
34184360:	43db      	mvns	r3, r3
34184362:	401a      	ands	r2, r3
34184364:	68bb      	ldr	r3, [r7, #8]
34184366:	623b      	str	r3, [r7, #32]
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
34184368:	6a3b      	ldr	r3, [r7, #32]
3418436a:	fa93 f3a3 	rbit	r3, r3
3418436e:	61fb      	str	r3, [r7, #28]
  return result;
34184370:	69fb      	ldr	r3, [r7, #28]
34184372:	627b      	str	r3, [r7, #36]	@ 0x24
  if (value == 0U)
34184374:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34184376:	2b00      	cmp	r3, #0
34184378:	d101      	bne.n	3418437e <LL_GPIO_SetPinPull+0x58>
    return 32U;
3418437a:	2320      	movs	r3, #32
3418437c:	e003      	b.n	34184386 <LL_GPIO_SetPinPull+0x60>
  return __builtin_clz(value);
3418437e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34184380:	fab3 f383 	clz	r3, r3
34184384:	b2db      	uxtb	r3, r3
34184386:	005b      	lsls	r3, r3, #1
34184388:	6879      	ldr	r1, [r7, #4]
3418438a:	fa01 f303 	lsl.w	r3, r1, r3
3418438e:	431a      	orrs	r2, r3
34184390:	68fb      	ldr	r3, [r7, #12]
34184392:	60da      	str	r2, [r3, #12]
             (Pull << (POSITION_VAL(Pin) * GPIO_PUPDR_PUPD1_Pos)));
}
34184394:	bf00      	nop
34184396:	372c      	adds	r7, #44	@ 0x2c
34184398:	46bd      	mov	sp, r7
3418439a:	f85d 7b04 	ldr.w	r7, [sp], #4
3418439e:	4770      	bx	lr

341843a0 <LL_GPIO_SetOutputPin>:
  *         @arg @ref LL_GPIO_PIN_15
  *         @arg @ref LL_GPIO_PIN_ALL
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_SetOutputPin(GPIO_TypeDef *GPIOx, uint32_t PinMask)
{
341843a0:	b480      	push	{r7}
341843a2:	b083      	sub	sp, #12
341843a4:	af00      	add	r7, sp, #0
341843a6:	6078      	str	r0, [r7, #4]
341843a8:	6039      	str	r1, [r7, #0]
  WRITE_REG(GPIOx->BSRR, PinMask);
341843aa:	687b      	ldr	r3, [r7, #4]
341843ac:	683a      	ldr	r2, [r7, #0]
341843ae:	619a      	str	r2, [r3, #24]
}
341843b0:	bf00      	nop
341843b2:	370c      	adds	r7, #12
341843b4:	46bd      	mov	sp, r7
341843b6:	f85d 7b04 	ldr.w	r7, [sp], #4
341843ba:	4770      	bx	lr

341843bc <LL_GPIO_ResetOutputPin>:
  *         @arg @ref LL_GPIO_PIN_15
  *         @arg @ref LL_GPIO_PIN_ALL
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_ResetOutputPin(GPIO_TypeDef *GPIOx, uint32_t PinMask)
{
341843bc:	b480      	push	{r7}
341843be:	b083      	sub	sp, #12
341843c0:	af00      	add	r7, sp, #0
341843c2:	6078      	str	r0, [r7, #4]
341843c4:	6039      	str	r1, [r7, #0]
  WRITE_REG(GPIOx->BRR, PinMask);
341843c6:	687b      	ldr	r3, [r7, #4]
341843c8:	683a      	ldr	r2, [r7, #0]
341843ca:	629a      	str	r2, [r3, #40]	@ 0x28
}
341843cc:	bf00      	nop
341843ce:	370c      	adds	r7, #12
341843d0:	46bd      	mov	sp, r7
341843d2:	f85d 7b04 	ldr.w	r7, [sp], #4
341843d6:	4770      	bx	lr

341843d8 <LL_EXTI_EnableIT_0_31>:
{
341843d8:	b480      	push	{r7}
341843da:	b083      	sub	sp, #12
341843dc:	af00      	add	r7, sp, #0
341843de:	6078      	str	r0, [r7, #4]
  SET_BIT(EXTI->IMR1, ExtiLine);
341843e0:	4b06      	ldr	r3, [pc, #24]	@ (341843fc <LL_EXTI_EnableIT_0_31+0x24>)
341843e2:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
341843e6:	4905      	ldr	r1, [pc, #20]	@ (341843fc <LL_EXTI_EnableIT_0_31+0x24>)
341843e8:	687b      	ldr	r3, [r7, #4]
341843ea:	4313      	orrs	r3, r2
341843ec:	f8c1 3080 	str.w	r3, [r1, #128]	@ 0x80
}
341843f0:	bf00      	nop
341843f2:	370c      	adds	r7, #12
341843f4:	46bd      	mov	sp, r7
341843f6:	f85d 7b04 	ldr.w	r7, [sp], #4
341843fa:	4770      	bx	lr
341843fc:	56025000 	.word	0x56025000

34184400 <LL_EXTI_DisableEvent_0_31>:
{
34184400:	b480      	push	{r7}
34184402:	b083      	sub	sp, #12
34184404:	af00      	add	r7, sp, #0
34184406:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(EXTI->EMR1, ExtiLine);
34184408:	4b07      	ldr	r3, [pc, #28]	@ (34184428 <LL_EXTI_DisableEvent_0_31+0x28>)
3418440a:	f8d3 2084 	ldr.w	r2, [r3, #132]	@ 0x84
3418440e:	687b      	ldr	r3, [r7, #4]
34184410:	43db      	mvns	r3, r3
34184412:	4905      	ldr	r1, [pc, #20]	@ (34184428 <LL_EXTI_DisableEvent_0_31+0x28>)
34184414:	4013      	ands	r3, r2
34184416:	f8c1 3084 	str.w	r3, [r1, #132]	@ 0x84
}
3418441a:	bf00      	nop
3418441c:	370c      	adds	r7, #12
3418441e:	46bd      	mov	sp, r7
34184420:	f85d 7b04 	ldr.w	r7, [sp], #4
34184424:	4770      	bx	lr
34184426:	bf00      	nop
34184428:	56025000 	.word	0x56025000

3418442c <LL_EXTI_DisableRisingTrig_0_31>:
{
3418442c:	b480      	push	{r7}
3418442e:	b083      	sub	sp, #12
34184430:	af00      	add	r7, sp, #0
34184432:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(EXTI->RTSR1, ExtiLine);
34184434:	4b06      	ldr	r3, [pc, #24]	@ (34184450 <LL_EXTI_DisableRisingTrig_0_31+0x24>)
34184436:	681a      	ldr	r2, [r3, #0]
34184438:	687b      	ldr	r3, [r7, #4]
3418443a:	43db      	mvns	r3, r3
3418443c:	4904      	ldr	r1, [pc, #16]	@ (34184450 <LL_EXTI_DisableRisingTrig_0_31+0x24>)
3418443e:	4013      	ands	r3, r2
34184440:	600b      	str	r3, [r1, #0]
}
34184442:	bf00      	nop
34184444:	370c      	adds	r7, #12
34184446:	46bd      	mov	sp, r7
34184448:	f85d 7b04 	ldr.w	r7, [sp], #4
3418444c:	4770      	bx	lr
3418444e:	bf00      	nop
34184450:	56025000 	.word	0x56025000

34184454 <LL_EXTI_EnableFallingTrig_0_31>:
{
34184454:	b480      	push	{r7}
34184456:	b083      	sub	sp, #12
34184458:	af00      	add	r7, sp, #0
3418445a:	6078      	str	r0, [r7, #4]
  SET_BIT(EXTI->FTSR1, ExtiLine);
3418445c:	4b05      	ldr	r3, [pc, #20]	@ (34184474 <LL_EXTI_EnableFallingTrig_0_31+0x20>)
3418445e:	685a      	ldr	r2, [r3, #4]
34184460:	4904      	ldr	r1, [pc, #16]	@ (34184474 <LL_EXTI_EnableFallingTrig_0_31+0x20>)
34184462:	687b      	ldr	r3, [r7, #4]
34184464:	4313      	orrs	r3, r2
34184466:	604b      	str	r3, [r1, #4]
}
34184468:	bf00      	nop
3418446a:	370c      	adds	r7, #12
3418446c:	46bd      	mov	sp, r7
3418446e:	f85d 7b04 	ldr.w	r7, [sp], #4
34184472:	4770      	bx	lr
34184474:	56025000 	.word	0x56025000

34184478 <LL_EXTI_SetEXTISource>:
  *         @arg @ref LL_EXTI_EXTI_LINE14
  *         @arg @ref LL_EXTI_EXTI_LINE15
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_SetEXTISource(uint32_t Port, uint32_t Line)
{
34184478:	b480      	push	{r7}
3418447a:	b083      	sub	sp, #12
3418447c:	af00      	add	r7, sp, #0
3418447e:	6078      	str	r0, [r7, #4]
34184480:	6039      	str	r1, [r7, #0]
  MODIFY_REG(EXTI->EXTICR[Line & 0x03U], EXTI_EXTICR1_EXTI0 << (Line >> LL_EXTI_REGISTER_PINPOS_SHFT),
34184482:	4a10      	ldr	r2, [pc, #64]	@ (341844c4 <LL_EXTI_SetEXTISource+0x4c>)
34184484:	683b      	ldr	r3, [r7, #0]
34184486:	f003 0303 	and.w	r3, r3, #3
3418448a:	3318      	adds	r3, #24
3418448c:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
34184490:	683b      	ldr	r3, [r7, #0]
34184492:	0c1b      	lsrs	r3, r3, #16
34184494:	21ff      	movs	r1, #255	@ 0xff
34184496:	fa01 f303 	lsl.w	r3, r1, r3
3418449a:	43db      	mvns	r3, r3
3418449c:	ea02 0103 	and.w	r1, r2, r3
341844a0:	683b      	ldr	r3, [r7, #0]
341844a2:	0c1b      	lsrs	r3, r3, #16
341844a4:	687a      	ldr	r2, [r7, #4]
341844a6:	409a      	lsls	r2, r3
341844a8:	4806      	ldr	r0, [pc, #24]	@ (341844c4 <LL_EXTI_SetEXTISource+0x4c>)
341844aa:	683b      	ldr	r3, [r7, #0]
341844ac:	f003 0303 	and.w	r3, r3, #3
341844b0:	430a      	orrs	r2, r1
341844b2:	3318      	adds	r3, #24
341844b4:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
             Port << (Line >> LL_EXTI_REGISTER_PINPOS_SHFT));
}
341844b8:	bf00      	nop
341844ba:	370c      	adds	r7, #12
341844bc:	46bd      	mov	sp, r7
341844be:	f85d 7b04 	ldr.w	r7, [sp], #4
341844c2:	4770      	bx	lr
341844c4:	56025000 	.word	0x56025000

341844c8 <BSP_USBPD_PWR_Init>:
  * @brief  Global initialization of PWR resource used by USB-PD
  * @param  PortNum Type-C port identifier
  * @retval BSP status
  */
int32_t BSP_USBPD_PWR_Init(uint32_t PortNum)
{
341844c8:	b580      	push	{r7, lr}
341844ca:	b084      	sub	sp, #16
341844cc:	af00      	add	r7, sp, #0
341844ce:	6078      	str	r0, [r7, #4]
  int32_t ret = BSP_ERROR_NONE;
341844d0:	2300      	movs	r3, #0
341844d2:	60fb      	str	r3, [r7, #12]

  /* Check if instance is valid */
  if (PortNum >= USBPD_PWR_INSTANCES_NBR)
341844d4:	687b      	ldr	r3, [r7, #4]
341844d6:	2b00      	cmp	r3, #0
341844d8:	d003      	beq.n	341844e2 <BSP_USBPD_PWR_Init+0x1a>
  {
    ret = BSP_ERROR_WRONG_PARAM;
341844da:	f06f 0301 	mvn.w	r3, #1
341844de:	60fb      	str	r3, [r7, #12]
341844e0:	e05d      	b.n	3418459e <BSP_USBPD_PWR_Init+0xd6>
  }
  else
  {
    BSP_USBPD_PWR_TRACE(PortNum, "-- BSP_USBPD_PWR_Init --");

    if (USBPD_PWR_Port_Status[PortNum].IsInitialized == 0U)
341844e2:	4931      	ldr	r1, [pc, #196]	@ (341845a8 <BSP_USBPD_PWR_Init+0xe0>)
341844e4:	687a      	ldr	r2, [r7, #4]
341844e6:	4613      	mov	r3, r2
341844e8:	005b      	lsls	r3, r3, #1
341844ea:	4413      	add	r3, r2
341844ec:	009b      	lsls	r3, r3, #2
341844ee:	440b      	add	r3, r1
341844f0:	781b      	ldrb	r3, [r3, #0]
341844f2:	2b00      	cmp	r3, #0
341844f4:	d153      	bne.n	3418459e <BSP_USBPD_PWR_Init+0xd6>
    {
      /* Initialisation according to HW configuration type of port */
      switch (USBPD_PWR_Port_Configs[PortNum].Type)
341844f6:	4a2d      	ldr	r2, [pc, #180]	@ (341845ac <BSP_USBPD_PWR_Init+0xe4>)
341844f8:	687b      	ldr	r3, [r7, #4]
341844fa:	f812 3013 	ldrb.w	r3, [r2, r3, lsl #1]
341844fe:	3b02      	subs	r3, #2
34184500:	2b01      	cmp	r3, #1
34184502:	d83c      	bhi.n	3418457e <BSP_USBPD_PWR_Init+0xb6>
      {
        case USBPD_PWR_HW_CONFIG_TYPE_TCPP02:
        case USBPD_PWR_HW_CONFIG_TYPE_TCPP03:
          /* Set default Role to SNK */
          USBPD_PWR_Port_Status[PortNum].PwrRole = POWER_ROLE_SINK;
34184504:	4928      	ldr	r1, [pc, #160]	@ (341845a8 <BSP_USBPD_PWR_Init+0xe0>)
34184506:	687a      	ldr	r2, [r7, #4]
34184508:	4613      	mov	r3, r2
3418450a:	005b      	lsls	r3, r3, #1
3418450c:	4413      	add	r3, r2
3418450e:	009b      	lsls	r3, r3, #2
34184510:	440b      	add	r3, r1
34184512:	3302      	adds	r3, #2
34184514:	2201      	movs	r2, #1
34184516:	701a      	strb	r2, [r3, #0]

          /* Set default Power Mode to Hibernate */
          USBPD_PWR_Port_Status[PortNum].PwrSavingMode = USBPD_PWR_MODE_HIBERNATE;
34184518:	4923      	ldr	r1, [pc, #140]	@ (341845a8 <BSP_USBPD_PWR_Init+0xe0>)
3418451a:	687a      	ldr	r2, [r7, #4]
3418451c:	4613      	mov	r3, r2
3418451e:	005b      	lsls	r3, r3, #1
34184520:	4413      	add	r3, r2
34184522:	009b      	lsls	r3, r3, #2
34184524:	440b      	add	r3, r1
34184526:	3303      	adds	r3, #3
34184528:	2201      	movs	r2, #1
3418452a:	701a      	strb	r2, [r3, #0]

          /* Reset port callback for VBUS detection event */
          USBPD_PWR_Port_Status[PortNum].VBUSDetectCallback = NULL;
3418452c:	491e      	ldr	r1, [pc, #120]	@ (341845a8 <BSP_USBPD_PWR_Init+0xe0>)
3418452e:	687a      	ldr	r2, [r7, #4]
34184530:	4613      	mov	r3, r2
34184532:	005b      	lsls	r3, r3, #1
34184534:	4413      	add	r3, r2
34184536:	009b      	lsls	r3, r3, #2
34184538:	440b      	add	r3, r1
3418453a:	3308      	adds	r3, #8
3418453c:	2200      	movs	r2, #0
3418453e:	601a      	str	r2, [r3, #0]

          /* Reset last detected fault Tick */
          USBPD_PWR_Port_Status[PortNum].LastFaultTick = 0U;
34184540:	4919      	ldr	r1, [pc, #100]	@ (341845a8 <BSP_USBPD_PWR_Init+0xe0>)
34184542:	687a      	ldr	r2, [r7, #4]
34184544:	4613      	mov	r3, r2
34184546:	005b      	lsls	r3, r3, #1
34184548:	4413      	add	r3, r2
3418454a:	009b      	lsls	r3, r3, #2
3418454c:	440b      	add	r3, r1
3418454e:	3304      	adds	r3, #4
34184550:	2200      	movs	r2, #0
34184552:	601a      	str	r2, [r3, #0]

          /* Initialize required GPIOs */
          PWR_TCPP0203_GPIOConfigInit(PortNum);
34184554:	6878      	ldr	r0, [r7, #4]
34184556:	f000 fa63 	bl	34184a20 <PWR_TCPP0203_GPIOConfigInit>

          /* Initialize EXTI for FLGn signal */
          PWR_TCPP0203_ITConfigInit(PortNum);
3418455a:	6878      	ldr	r0, [r7, #4]
3418455c:	f000 fb3c 	bl	34184bd8 <PWR_TCPP0203_ITConfigInit>

          /* Enable component : TCPP Enable pin activation is needed only from B01 revision of DK board */
          TCPP0203_PORT0_ENABLE_GPIO_SET();
34184560:	2110      	movs	r1, #16
34184562:	4813      	ldr	r0, [pc, #76]	@ (341845b0 <BSP_USBPD_PWR_Init+0xe8>)
34184564:	f7ff ff1c 	bl	341843a0 <LL_GPIO_SetOutputPin>

          /* Initialize required BUS for communication */
          ret = PWR_TCPP0203_BUSConfigInit(PortNum, USBPD_PWR_Port_Configs[PortNum].Address);
34184568:	4a10      	ldr	r2, [pc, #64]	@ (341845ac <BSP_USBPD_PWR_Init+0xe4>)
3418456a:	687b      	ldr	r3, [r7, #4]
3418456c:	005b      	lsls	r3, r3, #1
3418456e:	4413      	add	r3, r2
34184570:	785b      	ldrb	r3, [r3, #1]
34184572:	4619      	mov	r1, r3
34184574:	6878      	ldr	r0, [r7, #4]
34184576:	f000 fb7d 	bl	34184c74 <PWR_TCPP0203_BUSConfigInit>
3418457a:	60f8      	str	r0, [r7, #12]
          break;
3418457c:	e003      	b.n	34184586 <BSP_USBPD_PWR_Init+0xbe>

        case USBPD_PWR_HW_CONFIG_TYPE_DEFAULT:
        case USBPD_PWR_HW_CONFIG_TYPE_TCPP01:
        default:
          ret = BSP_ERROR_WRONG_PARAM;
3418457e:	f06f 0301 	mvn.w	r3, #1
34184582:	60fb      	str	r3, [r7, #12]
          break;
34184584:	bf00      	nop
      }

      if (ret == BSP_ERROR_NONE)
34184586:	68fb      	ldr	r3, [r7, #12]
34184588:	2b00      	cmp	r3, #0
3418458a:	d108      	bne.n	3418459e <BSP_USBPD_PWR_Init+0xd6>
      {
        /* Set Initialisation flag */
        USBPD_PWR_Port_Status[PortNum].IsInitialized = 1U;
3418458c:	4906      	ldr	r1, [pc, #24]	@ (341845a8 <BSP_USBPD_PWR_Init+0xe0>)
3418458e:	687a      	ldr	r2, [r7, #4]
34184590:	4613      	mov	r3, r2
34184592:	005b      	lsls	r3, r3, #1
34184594:	4413      	add	r3, r2
34184596:	009b      	lsls	r3, r3, #2
34184598:	440b      	add	r3, r1
3418459a:	2201      	movs	r2, #1
3418459c:	701a      	strb	r2, [r3, #0]
      }
    }
  }
  return ret;
3418459e:	68fb      	ldr	r3, [r7, #12]
}
341845a0:	4618      	mov	r0, r3
341845a2:	3710      	adds	r7, #16
341845a4:	46bd      	mov	sp, r7
341845a6:	bd80      	pop	{r7, pc}
341845a8:	341c0084 	.word	0x341c0084
341845ac:	341c0080 	.word	0x341c0080
341845b0:	56020000 	.word	0x56020000

341845b4 <BSP_USBPD_PWR_SetRole>:
  *         @arg @ref POWER_ROLE_SOURCE
  *         @arg @ref POWER_ROLE_SINK
  * @retval BSP status
  */
int32_t BSP_USBPD_PWR_SetRole(uint32_t PortNum, USBPD_PWR_PowerRoleTypeDef Role)
{
341845b4:	b590      	push	{r4, r7, lr}
341845b6:	b085      	sub	sp, #20
341845b8:	af00      	add	r7, sp, #0
341845ba:	6078      	str	r0, [r7, #4]
341845bc:	460b      	mov	r3, r1
341845be:	70fb      	strb	r3, [r7, #3]
  int32_t ret = BSP_ERROR_NONE;
341845c0:	2300      	movs	r3, #0
341845c2:	60fb      	str	r3, [r7, #12]

  /* Check if instance is valid */
  if (PortNum >= USBPD_PWR_INSTANCES_NBR)
341845c4:	687b      	ldr	r3, [r7, #4]
341845c6:	2b00      	cmp	r3, #0
341845c8:	d003      	beq.n	341845d2 <BSP_USBPD_PWR_SetRole+0x1e>
  {
    ret = BSP_ERROR_WRONG_PARAM;
341845ca:	f06f 0301 	mvn.w	r3, #1
341845ce:	60fb      	str	r3, [r7, #12]
341845d0:	e04b      	b.n	3418466a <BSP_USBPD_PWR_SetRole+0xb6>
  }
  else
  {
    switch (Role)
341845d2:	78fb      	ldrb	r3, [r7, #3]
341845d4:	2b00      	cmp	r3, #0
341845d6:	d002      	beq.n	341845de <BSP_USBPD_PWR_SetRole+0x2a>
341845d8:	2b01      	cmp	r3, #1
341845da:	d036      	beq.n	3418464a <BSP_USBPD_PWR_SetRole+0x96>
341845dc:	e040      	b.n	34184660 <BSP_USBPD_PWR_SetRole+0xac>
    {
      case POWER_ROLE_SOURCE:
        /* Port Role is now SRC */
        BSP_USBPD_PWR_TRACE(PortNum, "-- BSP_USBPD_PWR_SetRole : SRC --");
        /* Set port power Role */
        USBPD_PWR_Port_Status[PortNum].PwrRole = Role;
341845de:	4925      	ldr	r1, [pc, #148]	@ (34184674 <BSP_USBPD_PWR_SetRole+0xc0>)
341845e0:	687a      	ldr	r2, [r7, #4]
341845e2:	4613      	mov	r3, r2
341845e4:	005b      	lsls	r3, r3, #1
341845e6:	4413      	add	r3, r2
341845e8:	009b      	lsls	r3, r3, #2
341845ea:	440b      	add	r3, r1
341845ec:	3302      	adds	r3, #2
341845ee:	78fa      	ldrb	r2, [r7, #3]
341845f0:	701a      	strb	r2, [r3, #0]

        /* Ensure that TCPP0203 mode is not set to Hibernate */
        if (USBPD_PWR_Port_Status[PortNum].PwrSavingMode == USBPD_PWR_MODE_HIBERNATE)
341845f2:	4920      	ldr	r1, [pc, #128]	@ (34184674 <BSP_USBPD_PWR_SetRole+0xc0>)
341845f4:	687a      	ldr	r2, [r7, #4]
341845f6:	4613      	mov	r3, r2
341845f8:	005b      	lsls	r3, r3, #1
341845fa:	4413      	add	r3, r2
341845fc:	009b      	lsls	r3, r3, #2
341845fe:	440b      	add	r3, r1
34184600:	3303      	adds	r3, #3
34184602:	781b      	ldrb	r3, [r3, #0]
34184604:	2b01      	cmp	r3, #1
34184606:	d12f      	bne.n	34184668 <BSP_USBPD_PWR_SetRole+0xb4>
        {
          if (USBPD_PWR_PortCompDrv[PortNum]->SetPowerMode(&USBPD_PWR_PortCompObj[PortNum],
34184608:	4a1b      	ldr	r2, [pc, #108]	@ (34184678 <BSP_USBPD_PWR_SetRole+0xc4>)
3418460a:	687b      	ldr	r3, [r7, #4]
3418460c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
34184610:	699c      	ldr	r4, [r3, #24]
34184612:	687a      	ldr	r2, [r7, #4]
34184614:	4613      	mov	r3, r2
34184616:	009b      	lsls	r3, r3, #2
34184618:	4413      	add	r3, r2
3418461a:	00db      	lsls	r3, r3, #3
3418461c:	4a17      	ldr	r2, [pc, #92]	@ (3418467c <BSP_USBPD_PWR_SetRole+0xc8>)
3418461e:	4413      	add	r3, r2
34184620:	2120      	movs	r1, #32
34184622:	4618      	mov	r0, r3
34184624:	47a0      	blx	r4
34184626:	4603      	mov	r3, r0
34184628:	2b00      	cmp	r3, #0
3418462a:	d003      	beq.n	34184634 <BSP_USBPD_PWR_SetRole+0x80>
                                                           TCPP0203_POWER_MODE_LOWPOWER) != TCPP0203_OK)
          {
            ret = BSP_ERROR_COMPONENT_FAILURE;
3418462c:	f06f 0304 	mvn.w	r3, #4
34184630:	60fb      	str	r3, [r7, #12]
          else
          {
            USBPD_PWR_Port_Status[PortNum].PwrSavingMode = USBPD_PWR_MODE_LOWPOWER;
          }
        }
        break;
34184632:	e019      	b.n	34184668 <BSP_USBPD_PWR_SetRole+0xb4>
            USBPD_PWR_Port_Status[PortNum].PwrSavingMode = USBPD_PWR_MODE_LOWPOWER;
34184634:	490f      	ldr	r1, [pc, #60]	@ (34184674 <BSP_USBPD_PWR_SetRole+0xc0>)
34184636:	687a      	ldr	r2, [r7, #4]
34184638:	4613      	mov	r3, r2
3418463a:	005b      	lsls	r3, r3, #1
3418463c:	4413      	add	r3, r2
3418463e:	009b      	lsls	r3, r3, #2
34184640:	440b      	add	r3, r1
34184642:	3303      	adds	r3, #3
34184644:	2202      	movs	r2, #2
34184646:	701a      	strb	r2, [r3, #0]
        break;
34184648:	e00e      	b.n	34184668 <BSP_USBPD_PWR_SetRole+0xb4>

      case POWER_ROLE_SINK:
        /* Port Role is now SNK */
        BSP_USBPD_PWR_TRACE(PortNum, "-- BSP_USBPD_PWR_SetRole : SNK --");
        /* Set port power Role */
        USBPD_PWR_Port_Status[PortNum].PwrRole = Role;
3418464a:	490a      	ldr	r1, [pc, #40]	@ (34184674 <BSP_USBPD_PWR_SetRole+0xc0>)
3418464c:	687a      	ldr	r2, [r7, #4]
3418464e:	4613      	mov	r3, r2
34184650:	005b      	lsls	r3, r3, #1
34184652:	4413      	add	r3, r2
34184654:	009b      	lsls	r3, r3, #2
34184656:	440b      	add	r3, r1
34184658:	3302      	adds	r3, #2
3418465a:	78fa      	ldrb	r2, [r7, #3]
3418465c:	701a      	strb	r2, [r3, #0]
        break;
3418465e:	e004      	b.n	3418466a <BSP_USBPD_PWR_SetRole+0xb6>

      default:
        ret = BSP_ERROR_WRONG_PARAM;
34184660:	f06f 0301 	mvn.w	r3, #1
34184664:	60fb      	str	r3, [r7, #12]
        break;
34184666:	e000      	b.n	3418466a <BSP_USBPD_PWR_SetRole+0xb6>
        break;
34184668:	bf00      	nop
    }
  }

  return ret;
3418466a:	68fb      	ldr	r3, [r7, #12]
}
3418466c:	4618      	mov	r0, r3
3418466e:	3714      	adds	r7, #20
34184670:	46bd      	mov	sp, r7
34184672:	bd90      	pop	{r4, r7, pc}
34184674:	341c0084 	.word	0x341c0084
34184678:	341c2d00 	.word	0x341c2d00
3418467c:	341c2cd8 	.word	0x341c2cd8

34184680 <BSP_USBPD_PWR_SetPowerMode>:
  *         @arg @ref USBPD_PWR_MODE_LOWPOWER
  *         @arg @ref USBPD_PWR_MODE_NORMAL
  * @retval BSP status
  */
int32_t BSP_USBPD_PWR_SetPowerMode(uint32_t PortNum, USBPD_PWR_PowerModeTypeDef PwrMode)
{
34184680:	b590      	push	{r4, r7, lr}
34184682:	b085      	sub	sp, #20
34184684:	af00      	add	r7, sp, #0
34184686:	6078      	str	r0, [r7, #4]
34184688:	460b      	mov	r3, r1
3418468a:	70fb      	strb	r3, [r7, #3]
  uint8_t flg_reg;
  int32_t ret = BSP_ERROR_NONE;
3418468c:	2300      	movs	r3, #0
3418468e:	60fb      	str	r3, [r7, #12]

  /* Check if instance is valid */
  if (PortNum >= USBPD_PWR_INSTANCES_NBR)
34184690:	687b      	ldr	r3, [r7, #4]
34184692:	2b00      	cmp	r3, #0
34184694:	d003      	beq.n	3418469e <BSP_USBPD_PWR_SetPowerMode+0x1e>
  {
    ret = BSP_ERROR_WRONG_PARAM;
34184696:	f06f 0301 	mvn.w	r3, #1
3418469a:	60fb      	str	r3, [r7, #12]
3418469c:	e0c0      	b.n	34184820 <BSP_USBPD_PWR_SetPowerMode+0x1a0>
  else
  {
    BSP_USBPD_PWR_TRACE(PortNum, "-- BSP_USBPD_PWR_SetPowerMode --");

    /* Evaluate requested Power config for port */
    switch (PwrMode)
3418469e:	78fb      	ldrb	r3, [r7, #3]
341846a0:	2b03      	cmp	r3, #3
341846a2:	f200 80a8 	bhi.w	341847f6 <BSP_USBPD_PWR_SetPowerMode+0x176>
341846a6:	a201      	add	r2, pc, #4	@ (adr r2, 341846ac <BSP_USBPD_PWR_SetPowerMode+0x2c>)
341846a8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
341846ac:	341846bd 	.word	0x341846bd
341846b0:	341846e9 	.word	0x341846e9
341846b4:	3418479f 	.word	0x3418479f
341846b8:	341847cb 	.word	0x341847cb
    {
      case USBPD_PWR_MODE_OFF:
        /* Port should enter OFF mode : Reset TCPP0203 Reg0 */
        if (USBPD_PWR_PortCompDrv[PortNum]->Reset(&USBPD_PWR_PortCompObj[PortNum]) != TCPP0203_OK)
341846bc:	4a5b      	ldr	r2, [pc, #364]	@ (3418482c <BSP_USBPD_PWR_SetPowerMode+0x1ac>)
341846be:	687b      	ldr	r3, [r7, #4]
341846c0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
341846c4:	6899      	ldr	r1, [r3, #8]
341846c6:	687a      	ldr	r2, [r7, #4]
341846c8:	4613      	mov	r3, r2
341846ca:	009b      	lsls	r3, r3, #2
341846cc:	4413      	add	r3, r2
341846ce:	00db      	lsls	r3, r3, #3
341846d0:	4a57      	ldr	r2, [pc, #348]	@ (34184830 <BSP_USBPD_PWR_SetPowerMode+0x1b0>)
341846d2:	4413      	add	r3, r2
341846d4:	4618      	mov	r0, r3
341846d6:	4788      	blx	r1
341846d8:	4603      	mov	r3, r0
341846da:	2b00      	cmp	r3, #0
341846dc:	f000 808f 	beq.w	341847fe <BSP_USBPD_PWR_SetPowerMode+0x17e>
        {
          ret = BSP_ERROR_COMPONENT_FAILURE;
341846e0:	f06f 0304 	mvn.w	r3, #4
341846e4:	60fb      	str	r3, [r7, #12]
        }
        break;
341846e6:	e08a      	b.n	341847fe <BSP_USBPD_PWR_SetPowerMode+0x17e>
             - Dead Batteries Enabled,
             - Gate Driver Consumer controlled by I2C, Gate Driver Provider OFF
             - waiting for VBUS_OK in FLGn (interrupt)
        */
        BSP_USBPD_PWR_TRACE(PortNum, "-- Hibernate --");
        if (USBPD_PWR_PortCompDrv[PortNum]->SetPowerMode(&USBPD_PWR_PortCompObj[PortNum],
341846e8:	4a50      	ldr	r2, [pc, #320]	@ (3418482c <BSP_USBPD_PWR_SetPowerMode+0x1ac>)
341846ea:	687b      	ldr	r3, [r7, #4]
341846ec:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
341846f0:	699c      	ldr	r4, [r3, #24]
341846f2:	687a      	ldr	r2, [r7, #4]
341846f4:	4613      	mov	r3, r2
341846f6:	009b      	lsls	r3, r3, #2
341846f8:	4413      	add	r3, r2
341846fa:	00db      	lsls	r3, r3, #3
341846fc:	4a4c      	ldr	r2, [pc, #304]	@ (34184830 <BSP_USBPD_PWR_SetPowerMode+0x1b0>)
341846fe:	4413      	add	r3, r2
34184700:	2100      	movs	r1, #0
34184702:	4618      	mov	r0, r3
34184704:	47a0      	blx	r4
34184706:	4603      	mov	r3, r0
34184708:	2b00      	cmp	r3, #0
3418470a:	d002      	beq.n	34184712 <BSP_USBPD_PWR_SetPowerMode+0x92>
                                                         TCPP0203_POWER_MODE_HIBERNATE) != TCPP0203_OK)
        {
          ret = BSP_ERROR_COMPONENT_FAILURE;
3418470c:	f06f 0304 	mvn.w	r3, #4
34184710:	60fb      	str	r3, [r7, #12]
        }

        /* Check if VBUS is present (in case of SNK VBUS powered device) */
        /* Read Flags register (FLGn) */
        if (USBPD_PWR_PortCompDrv[PortNum]->ReadFlagRegister(&USBPD_PWR_PortCompObj[PortNum], &flg_reg) == TCPP0203_OK)
34184712:	4a46      	ldr	r2, [pc, #280]	@ (3418482c <BSP_USBPD_PWR_SetPowerMode+0x1ac>)
34184714:	687b      	ldr	r3, [r7, #4]
34184716:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
3418471a:	6e5c      	ldr	r4, [r3, #100]	@ 0x64
3418471c:	687a      	ldr	r2, [r7, #4]
3418471e:	4613      	mov	r3, r2
34184720:	009b      	lsls	r3, r3, #2
34184722:	4413      	add	r3, r2
34184724:	00db      	lsls	r3, r3, #3
34184726:	4a42      	ldr	r2, [pc, #264]	@ (34184830 <BSP_USBPD_PWR_SetPowerMode+0x1b0>)
34184728:	4413      	add	r3, r2
3418472a:	f107 020b 	add.w	r2, r7, #11
3418472e:	4611      	mov	r1, r2
34184730:	4618      	mov	r0, r3
34184732:	47a0      	blx	r4
34184734:	4603      	mov	r3, r0
34184736:	2b00      	cmp	r3, #0
34184738:	d163      	bne.n	34184802 <BSP_USBPD_PWR_SetPowerMode+0x182>
        {
          /* If FLGn has been set to 0 in LOW POWER or HIBERNATE mode,
             it is expected that a VBUS_OK condition is detected.
             In this case, if any, vBus Detection callback could be called */
          if ((flg_reg & TCPP0203_FLAG_VBUS_OK_SET) == TCPP0203_FLAG_VBUS_OK_SET)
3418473a:	7afb      	ldrb	r3, [r7, #11]
3418473c:	f003 0320 	and.w	r3, r3, #32
34184740:	2b00      	cmp	r3, #0
34184742:	d05e      	beq.n	34184802 <BSP_USBPD_PWR_SetPowerMode+0x182>
          {
            if (USBPD_PWR_Port_Status[PortNum].VBUSDetectCallback != NULL)
34184744:	493b      	ldr	r1, [pc, #236]	@ (34184834 <BSP_USBPD_PWR_SetPowerMode+0x1b4>)
34184746:	687a      	ldr	r2, [r7, #4]
34184748:	4613      	mov	r3, r2
3418474a:	005b      	lsls	r3, r3, #1
3418474c:	4413      	add	r3, r2
3418474e:	009b      	lsls	r3, r3, #2
34184750:	440b      	add	r3, r1
34184752:	3308      	adds	r3, #8
34184754:	681b      	ldr	r3, [r3, #0]
34184756:	2b00      	cmp	r3, #0
34184758:	d053      	beq.n	34184802 <BSP_USBPD_PWR_SetPowerMode+0x182>
            {
              /* In case of TCPP03 in Hibernate Mode (SNK config),
                 Mode is set to Low power to enable TCPP03 behavior on CC lines */
              /* Switch to Low Power mode */
              BSP_USBPD_PWR_TRACE(PortNum, "-- Low Power --");
              if (USBPD_PWR_PortCompDrv[PortNum]->SetPowerMode(&USBPD_PWR_PortCompObj[PortNum],
3418475a:	4a34      	ldr	r2, [pc, #208]	@ (3418482c <BSP_USBPD_PWR_SetPowerMode+0x1ac>)
3418475c:	687b      	ldr	r3, [r7, #4]
3418475e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
34184762:	699c      	ldr	r4, [r3, #24]
34184764:	687a      	ldr	r2, [r7, #4]
34184766:	4613      	mov	r3, r2
34184768:	009b      	lsls	r3, r3, #2
3418476a:	4413      	add	r3, r2
3418476c:	00db      	lsls	r3, r3, #3
3418476e:	4a30      	ldr	r2, [pc, #192]	@ (34184830 <BSP_USBPD_PWR_SetPowerMode+0x1b0>)
34184770:	4413      	add	r3, r2
34184772:	2120      	movs	r1, #32
34184774:	4618      	mov	r0, r3
34184776:	47a0      	blx	r4
34184778:	4603      	mov	r3, r0
3418477a:	2b00      	cmp	r3, #0
3418477c:	d002      	beq.n	34184784 <BSP_USBPD_PWR_SetPowerMode+0x104>
                                                               TCPP0203_POWER_MODE_LOWPOWER) != TCPP0203_OK)
              {
                ret = BSP_ERROR_COMPONENT_FAILURE;
3418477e:	f06f 0304 	mvn.w	r3, #4
34184782:	60fb      	str	r3, [r7, #12]
              }

              USBPD_PWR_Port_Status[PortNum].VBUSDetectCallback(PortNum, VBUS_CONNECTED);
34184784:	492b      	ldr	r1, [pc, #172]	@ (34184834 <BSP_USBPD_PWR_SetPowerMode+0x1b4>)
34184786:	687a      	ldr	r2, [r7, #4]
34184788:	4613      	mov	r3, r2
3418478a:	005b      	lsls	r3, r3, #1
3418478c:	4413      	add	r3, r2
3418478e:	009b      	lsls	r3, r3, #2
34184790:	440b      	add	r3, r1
34184792:	3308      	adds	r3, #8
34184794:	681b      	ldr	r3, [r3, #0]
34184796:	2100      	movs	r1, #0
34184798:	6878      	ldr	r0, [r7, #4]
3418479a:	4798      	blx	r3
          else
          {
            /* VBUS indication not present in FLGn flags : nothing more to be done */
          }
        }
        break;
3418479c:	e031      	b.n	34184802 <BSP_USBPD_PWR_SetPowerMode+0x182>
             - Dead Batteries Disabled,
             - Gate Driver Consumer or Provider controlled by I2C
             - waiting for VBUS_OK in FLGn (interrupt)
        */
        BSP_USBPD_PWR_TRACE(PortNum, "-- Low Power --");
        if (USBPD_PWR_PortCompDrv[PortNum]->SetPowerMode(&USBPD_PWR_PortCompObj[PortNum],
3418479e:	4a23      	ldr	r2, [pc, #140]	@ (3418482c <BSP_USBPD_PWR_SetPowerMode+0x1ac>)
341847a0:	687b      	ldr	r3, [r7, #4]
341847a2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
341847a6:	699c      	ldr	r4, [r3, #24]
341847a8:	687a      	ldr	r2, [r7, #4]
341847aa:	4613      	mov	r3, r2
341847ac:	009b      	lsls	r3, r3, #2
341847ae:	4413      	add	r3, r2
341847b0:	00db      	lsls	r3, r3, #3
341847b2:	4a1f      	ldr	r2, [pc, #124]	@ (34184830 <BSP_USBPD_PWR_SetPowerMode+0x1b0>)
341847b4:	4413      	add	r3, r2
341847b6:	2120      	movs	r1, #32
341847b8:	4618      	mov	r0, r3
341847ba:	47a0      	blx	r4
341847bc:	4603      	mov	r3, r0
341847be:	2b00      	cmp	r3, #0
341847c0:	d021      	beq.n	34184806 <BSP_USBPD_PWR_SetPowerMode+0x186>
                                                         TCPP0203_POWER_MODE_LOWPOWER) != TCPP0203_OK)
        {
          ret = BSP_ERROR_COMPONENT_FAILURE;
341847c2:	f06f 0304 	mvn.w	r3, #4
341847c6:	60fb      	str	r3, [r7, #12]
        }
        break;
341847c8:	e01d      	b.n	34184806 <BSP_USBPD_PWR_SetPowerMode+0x186>

      case USBPD_PWR_MODE_NORMAL:
        /* Port Mode is Normal : No power saving measure (Explicit contract in place) */
        BSP_USBPD_PWR_TRACE(PortNum, "-- Normal --");
        if (USBPD_PWR_PortCompDrv[PortNum]->SetPowerMode(&USBPD_PWR_PortCompObj[PortNum],
341847ca:	4a18      	ldr	r2, [pc, #96]	@ (3418482c <BSP_USBPD_PWR_SetPowerMode+0x1ac>)
341847cc:	687b      	ldr	r3, [r7, #4]
341847ce:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
341847d2:	699c      	ldr	r4, [r3, #24]
341847d4:	687a      	ldr	r2, [r7, #4]
341847d6:	4613      	mov	r3, r2
341847d8:	009b      	lsls	r3, r3, #2
341847da:	4413      	add	r3, r2
341847dc:	00db      	lsls	r3, r3, #3
341847de:	4a14      	ldr	r2, [pc, #80]	@ (34184830 <BSP_USBPD_PWR_SetPowerMode+0x1b0>)
341847e0:	4413      	add	r3, r2
341847e2:	2110      	movs	r1, #16
341847e4:	4618      	mov	r0, r3
341847e6:	47a0      	blx	r4
341847e8:	4603      	mov	r3, r0
341847ea:	2b00      	cmp	r3, #0
341847ec:	d00d      	beq.n	3418480a <BSP_USBPD_PWR_SetPowerMode+0x18a>
                                                         TCPP0203_POWER_MODE_NORMAL) != TCPP0203_OK)
        {
          ret = BSP_ERROR_COMPONENT_FAILURE;
341847ee:	f06f 0304 	mvn.w	r3, #4
341847f2:	60fb      	str	r3, [r7, #12]
        }
        break;
341847f4:	e009      	b.n	3418480a <BSP_USBPD_PWR_SetPowerMode+0x18a>

      default:
        ret = BSP_ERROR_WRONG_PARAM;
341847f6:	f06f 0301 	mvn.w	r3, #1
341847fa:	60fb      	str	r3, [r7, #12]
        break;
341847fc:	e006      	b.n	3418480c <BSP_USBPD_PWR_SetPowerMode+0x18c>
        break;
341847fe:	bf00      	nop
34184800:	e004      	b.n	3418480c <BSP_USBPD_PWR_SetPowerMode+0x18c>
        break;
34184802:	bf00      	nop
34184804:	e002      	b.n	3418480c <BSP_USBPD_PWR_SetPowerMode+0x18c>
        break;
34184806:	bf00      	nop
34184808:	e000      	b.n	3418480c <BSP_USBPD_PWR_SetPowerMode+0x18c>
        break;
3418480a:	bf00      	nop
    }

    /* Set port low power operating mode */
    USBPD_PWR_Port_Status[PortNum].PwrSavingMode = PwrMode;
3418480c:	4909      	ldr	r1, [pc, #36]	@ (34184834 <BSP_USBPD_PWR_SetPowerMode+0x1b4>)
3418480e:	687a      	ldr	r2, [r7, #4]
34184810:	4613      	mov	r3, r2
34184812:	005b      	lsls	r3, r3, #1
34184814:	4413      	add	r3, r2
34184816:	009b      	lsls	r3, r3, #2
34184818:	440b      	add	r3, r1
3418481a:	3303      	adds	r3, #3
3418481c:	78fa      	ldrb	r2, [r7, #3]
3418481e:	701a      	strb	r2, [r3, #0]
  }

  return ret;
34184820:	68fb      	ldr	r3, [r7, #12]
}
34184822:	4618      	mov	r0, r3
34184824:	3714      	adds	r7, #20
34184826:	46bd      	mov	sp, r7
34184828:	bd90      	pop	{r4, r7, pc}
3418482a:	bf00      	nop
3418482c:	341c2d00 	.word	0x341c2d00
34184830:	341c2cd8 	.word	0x341c2cd8
34184834:	341c0084 	.word	0x341c0084

34184838 <BSP_USBPD_PWR_VBUSInit>:
  *         This parameter can take one of the following values:
  *         @arg @ref USBPD_PWR_TYPE_C_PORT_1
  * @retval BSP status
  */
int32_t BSP_USBPD_PWR_VBUSInit(uint32_t PortNum)
{
34184838:	b580      	push	{r7, lr}
3418483a:	b084      	sub	sp, #16
3418483c:	af00      	add	r7, sp, #0
3418483e:	6078      	str	r0, [r7, #4]
  int32_t ret;

  /* Check if instance is valid */
  if (PortNum >= USBPD_PWR_INSTANCES_NBR)
34184840:	687b      	ldr	r3, [r7, #4]
34184842:	2b00      	cmp	r3, #0
34184844:	d003      	beq.n	3418484e <BSP_USBPD_PWR_VBUSInit+0x16>
  {
    ret = BSP_ERROR_WRONG_PARAM;
34184846:	f06f 0301 	mvn.w	r3, #1
3418484a:	60fb      	str	r3, [r7, #12]
3418484c:	e01a      	b.n	34184884 <BSP_USBPD_PWR_VBUSInit+0x4c>
  else
  {
    BSP_USBPD_PWR_TRACE(PortNum, "-- BSP_USBPD_PWR_VBUSInit --");

    /* Initialize required HW for VBUS management */
    switch (USBPD_PWR_Port_Configs[PortNum].Type)
3418484e:	4a10      	ldr	r2, [pc, #64]	@ (34184890 <BSP_USBPD_PWR_VBUSInit+0x58>)
34184850:	687b      	ldr	r3, [r7, #4]
34184852:	f812 3013 	ldrb.w	r3, [r2, r3, lsl #1]
34184856:	3b02      	subs	r3, #2
34184858:	2b01      	cmp	r3, #1
3418485a:	d80e      	bhi.n	3418487a <BSP_USBPD_PWR_VBUSInit+0x42>
    {
      case USBPD_PWR_HW_CONFIG_TYPE_TCPP02:
      case USBPD_PWR_HW_CONFIG_TYPE_TCPP03:
        /* Switch to Normal mode */
        ret = BSP_USBPD_PWR_SetPowerMode(PortNum, USBPD_PWR_MODE_NORMAL);
3418485c:	2103      	movs	r1, #3
3418485e:	6878      	ldr	r0, [r7, #4]
34184860:	f7ff ff0e 	bl	34184680 <BSP_USBPD_PWR_SetPowerMode>
34184864:	60f8      	str	r0, [r7, #12]

        /* Configure ADC */
        if (ADC_Configured == USBPD_FALSE)
34184866:	4b0b      	ldr	r3, [pc, #44]	@ (34184894 <BSP_USBPD_PWR_VBUSInit+0x5c>)
34184868:	781b      	ldrb	r3, [r3, #0]
3418486a:	2b00      	cmp	r3, #0
3418486c:	d109      	bne.n	34184882 <BSP_USBPD_PWR_VBUSInit+0x4a>
        {
          PWR_TCPP0203_Configure_ADC();
3418486e:	f000 f90d 	bl	34184a8c <PWR_TCPP0203_Configure_ADC>
          ADC_Configured = USBPD_TRUE;
34184872:	4b08      	ldr	r3, [pc, #32]	@ (34184894 <BSP_USBPD_PWR_VBUSInit+0x5c>)
34184874:	2201      	movs	r2, #1
34184876:	701a      	strb	r2, [r3, #0]
        }
        break;
34184878:	e003      	b.n	34184882 <BSP_USBPD_PWR_VBUSInit+0x4a>

      case USBPD_PWR_HW_CONFIG_TYPE_DEFAULT:
      case USBPD_PWR_HW_CONFIG_TYPE_TCPP01:
      default:
        ret = BSP_ERROR_FEATURE_NOT_SUPPORTED;
3418487a:	f06f 030a 	mvn.w	r3, #10
3418487e:	60fb      	str	r3, [r7, #12]
        break;
34184880:	e000      	b.n	34184884 <BSP_USBPD_PWR_VBUSInit+0x4c>
        break;
34184882:	bf00      	nop
    }
  }
  return ret;
34184884:	68fb      	ldr	r3, [r7, #12]
}
34184886:	4618      	mov	r0, r3
34184888:	3710      	adds	r7, #16
3418488a:	46bd      	mov	sp, r7
3418488c:	bd80      	pop	{r7, pc}
3418488e:	bf00      	nop
34184890:	341c0080 	.word	0x341c0080
34184894:	341c2d04 	.word	0x341c2d04

34184898 <BSP_USBPD_PWR_VBUSDeInit>:
  *         This parameter can take one of the following values:
  *         @arg @ref USBPD_PWR_TYPE_C_PORT_1
  * @retval BSP status
  */
int32_t BSP_USBPD_PWR_VBUSDeInit(uint32_t PortNum)
{
34184898:	b590      	push	{r4, r7, lr}
3418489a:	b085      	sub	sp, #20
3418489c:	af00      	add	r7, sp, #0
3418489e:	6078      	str	r0, [r7, #4]
  int32_t ret;

  /* Check if instance is valid */
  if (PortNum >= USBPD_PWR_INSTANCES_NBR)
341848a0:	687b      	ldr	r3, [r7, #4]
341848a2:	2b00      	cmp	r3, #0
341848a4:	d003      	beq.n	341848ae <BSP_USBPD_PWR_VBUSDeInit+0x16>
  {
    ret = BSP_ERROR_WRONG_PARAM;
341848a6:	f06f 0301 	mvn.w	r3, #1
341848aa:	60fb      	str	r3, [r7, #12]
341848ac:	e042      	b.n	34184934 <BSP_USBPD_PWR_VBUSDeInit+0x9c>
  else
  {
    BSP_USBPD_PWR_TRACE(PortNum, "-- BSP_USBPD_PWR_VBUSDeInit --");

    /* Only for TCPP03 */
    if (USBPD_PWR_HW_CONFIG_TYPE_TCPP03 == USBPD_PWR_Port_Configs[PortNum].Type)
341848ae:	4a24      	ldr	r2, [pc, #144]	@ (34184940 <BSP_USBPD_PWR_VBUSDeInit+0xa8>)
341848b0:	687b      	ldr	r3, [r7, #4]
341848b2:	f812 3013 	ldrb.w	r3, [r2, r3, lsl #1]
341848b6:	2b03      	cmp	r3, #3
341848b8:	d116      	bne.n	341848e8 <BSP_USBPD_PWR_VBUSDeInit+0x50>
    {
      /* Close Gate Driver Consumer, only for TCPP03 */
      if (USBPD_PWR_PortCompDrv[PortNum]->SetGateDriverConsumer(&USBPD_PWR_PortCompObj[PortNum],
341848ba:	4a22      	ldr	r2, [pc, #136]	@ (34184944 <BSP_USBPD_PWR_VBUSDeInit+0xac>)
341848bc:	687b      	ldr	r3, [r7, #4]
341848be:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
341848c2:	695c      	ldr	r4, [r3, #20]
341848c4:	687a      	ldr	r2, [r7, #4]
341848c6:	4613      	mov	r3, r2
341848c8:	009b      	lsls	r3, r3, #2
341848ca:	4413      	add	r3, r2
341848cc:	00db      	lsls	r3, r3, #3
341848ce:	4a1e      	ldr	r2, [pc, #120]	@ (34184948 <BSP_USBPD_PWR_VBUSDeInit+0xb0>)
341848d0:	4413      	add	r3, r2
341848d2:	2100      	movs	r1, #0
341848d4:	4618      	mov	r0, r3
341848d6:	47a0      	blx	r4
341848d8:	4603      	mov	r3, r0
341848da:	2b00      	cmp	r3, #0
341848dc:	d004      	beq.n	341848e8 <BSP_USBPD_PWR_VBUSDeInit+0x50>
                                                                TCPP0203_GD_CONSUMER_SWITCH_CLOSED) != TCPP0203_OK)
      {
        ret = BSP_ERROR_COMPONENT_FAILURE;
341848de:	f06f 0304 	mvn.w	r3, #4
341848e2:	60fb      	str	r3, [r7, #12]
        return ret;
341848e4:	68fb      	ldr	r3, [r7, #12]
341848e6:	e026      	b.n	34184936 <BSP_USBPD_PWR_VBUSDeInit+0x9e>
      }
    }

    /* Common for TCPP02 / TCPP03 */
    if ((USBPD_PWR_HW_CONFIG_TYPE_TCPP02 == USBPD_PWR_Port_Configs[PortNum].Type) ||
341848e8:	4a15      	ldr	r2, [pc, #84]	@ (34184940 <BSP_USBPD_PWR_VBUSDeInit+0xa8>)
341848ea:	687b      	ldr	r3, [r7, #4]
341848ec:	f812 3013 	ldrb.w	r3, [r2, r3, lsl #1]
341848f0:	2b02      	cmp	r3, #2
341848f2:	d005      	beq.n	34184900 <BSP_USBPD_PWR_VBUSDeInit+0x68>
        (USBPD_PWR_HW_CONFIG_TYPE_TCPP03 == USBPD_PWR_Port_Configs[PortNum].Type))
341848f4:	4a12      	ldr	r2, [pc, #72]	@ (34184940 <BSP_USBPD_PWR_VBUSDeInit+0xa8>)
341848f6:	687b      	ldr	r3, [r7, #4]
341848f8:	f812 3013 	ldrb.w	r3, [r2, r3, lsl #1]
    if ((USBPD_PWR_HW_CONFIG_TYPE_TCPP02 == USBPD_PWR_Port_Configs[PortNum].Type) ||
341848fc:	2b03      	cmp	r3, #3
341848fe:	d116      	bne.n	3418492e <BSP_USBPD_PWR_VBUSDeInit+0x96>
    {
      /* Restore default gates configuration for Low power mode */
      BSP_USBPD_PWR_TRACE(PortNum, "-- GDP/GDC setting : default --");

      if (USBPD_PWR_Port_Status[PortNum].PwrRole == POWER_ROLE_SOURCE)
34184900:	4912      	ldr	r1, [pc, #72]	@ (3418494c <BSP_USBPD_PWR_VBUSDeInit+0xb4>)
34184902:	687a      	ldr	r2, [r7, #4]
34184904:	4613      	mov	r3, r2
34184906:	005b      	lsls	r3, r3, #1
34184908:	4413      	add	r3, r2
3418490a:	009b      	lsls	r3, r3, #2
3418490c:	440b      	add	r3, r1
3418490e:	3302      	adds	r3, #2
34184910:	781b      	ldrb	r3, [r3, #0]
34184912:	2b00      	cmp	r3, #0
34184914:	d105      	bne.n	34184922 <BSP_USBPD_PWR_VBUSDeInit+0x8a>
      {
        /* Switch to Low Power mode */
        ret = BSP_USBPD_PWR_SetPowerMode(PortNum, USBPD_PWR_MODE_LOWPOWER);
34184916:	2102      	movs	r1, #2
34184918:	6878      	ldr	r0, [r7, #4]
3418491a:	f7ff feb1 	bl	34184680 <BSP_USBPD_PWR_SetPowerMode>
3418491e:	60f8      	str	r0, [r7, #12]
      if (USBPD_PWR_Port_Status[PortNum].PwrRole == POWER_ROLE_SOURCE)
34184920:	e008      	b.n	34184934 <BSP_USBPD_PWR_VBUSDeInit+0x9c>
      }
      else
      {
        /* Switch to Hibernate mode */
        ret = BSP_USBPD_PWR_SetPowerMode(PortNum, USBPD_PWR_MODE_HIBERNATE);
34184922:	2101      	movs	r1, #1
34184924:	6878      	ldr	r0, [r7, #4]
34184926:	f7ff feab 	bl	34184680 <BSP_USBPD_PWR_SetPowerMode>
3418492a:	60f8      	str	r0, [r7, #12]
      if (USBPD_PWR_Port_Status[PortNum].PwrRole == POWER_ROLE_SOURCE)
3418492c:	e002      	b.n	34184934 <BSP_USBPD_PWR_VBUSDeInit+0x9c>
      }
    }
    else
    {
      ret = BSP_ERROR_FEATURE_NOT_SUPPORTED;
3418492e:	f06f 030a 	mvn.w	r3, #10
34184932:	60fb      	str	r3, [r7, #12]
    }
  }
  return ret;
34184934:	68fb      	ldr	r3, [r7, #12]
}
34184936:	4618      	mov	r0, r3
34184938:	3714      	adds	r7, #20
3418493a:	46bd      	mov	sp, r7
3418493c:	bd90      	pop	{r4, r7, pc}
3418493e:	bf00      	nop
34184940:	341c0080 	.word	0x341c0080
34184944:	341c2d00 	.word	0x341c2d00
34184948:	341c2cd8 	.word	0x341c2cd8
3418494c:	341c0084 	.word	0x341c0084

34184950 <BSP_USBPD_PWR_RegisterVBUSDetectCallback>:
  * @param  pfnVBUSDetectCallback callback function pointer
  * @retval BSP status
  */
int32_t BSP_USBPD_PWR_RegisterVBUSDetectCallback(uint32_t PortNum,
                                                 USBPD_PWR_VBUSDetectCallbackFunc *pfnVBUSDetectCallback)
{
34184950:	b480      	push	{r7}
34184952:	b085      	sub	sp, #20
34184954:	af00      	add	r7, sp, #0
34184956:	6078      	str	r0, [r7, #4]
34184958:	6039      	str	r1, [r7, #0]
  int32_t ret = BSP_ERROR_NONE;
3418495a:	2300      	movs	r3, #0
3418495c:	60fb      	str	r3, [r7, #12]

  /* Check if instance is valid */
  if ((PortNum >= USBPD_PWR_INSTANCES_NBR) || (NULL == pfnVBUSDetectCallback))
3418495e:	687b      	ldr	r3, [r7, #4]
34184960:	2b00      	cmp	r3, #0
34184962:	d102      	bne.n	3418496a <BSP_USBPD_PWR_RegisterVBUSDetectCallback+0x1a>
34184964:	683b      	ldr	r3, [r7, #0]
34184966:	2b00      	cmp	r3, #0
34184968:	d103      	bne.n	34184972 <BSP_USBPD_PWR_RegisterVBUSDetectCallback+0x22>
  {
    ret = BSP_ERROR_WRONG_PARAM;
3418496a:	f06f 0301 	mvn.w	r3, #1
3418496e:	60fb      	str	r3, [r7, #12]
34184970:	e009      	b.n	34184986 <BSP_USBPD_PWR_RegisterVBUSDetectCallback+0x36>
  }
  else
  {
    /* Set port callback for VBUS detection event */
    USBPD_PWR_Port_Status[PortNum].VBUSDetectCallback = pfnVBUSDetectCallback;
34184972:	4908      	ldr	r1, [pc, #32]	@ (34184994 <BSP_USBPD_PWR_RegisterVBUSDetectCallback+0x44>)
34184974:	687a      	ldr	r2, [r7, #4]
34184976:	4613      	mov	r3, r2
34184978:	005b      	lsls	r3, r3, #1
3418497a:	4413      	add	r3, r2
3418497c:	009b      	lsls	r3, r3, #2
3418497e:	440b      	add	r3, r1
34184980:	3308      	adds	r3, #8
34184982:	683a      	ldr	r2, [r7, #0]
34184984:	601a      	str	r2, [r3, #0]
  }
  return ret;
34184986:	68fb      	ldr	r3, [r7, #12]
}
34184988:	4618      	mov	r0, r3
3418498a:	3714      	adds	r7, #20
3418498c:	46bd      	mov	sp, r7
3418498e:	f85d 7b04 	ldr.w	r7, [sp], #4
34184992:	4770      	bx	lr
34184994:	341c0084 	.word	0x341c0084

34184998 <BSP_USBPD_PWR_VBUSGetVoltage>:
  *         @arg @ref USBPD_PWR_TYPE_C_PORT_1
  * @param  pVoltage Pointer on measured voltage level (in mV)
  * @retval BSP status
  */
int32_t BSP_USBPD_PWR_VBUSGetVoltage(uint32_t PortNum, uint32_t *pVoltage)
{
34184998:	b580      	push	{r7, lr}
3418499a:	b084      	sub	sp, #16
3418499c:	af00      	add	r7, sp, #0
3418499e:	6078      	str	r0, [r7, #4]
341849a0:	6039      	str	r1, [r7, #0]
  int32_t ret = BSP_ERROR_NONE;
341849a2:	2300      	movs	r3, #0
341849a4:	60fb      	str	r3, [r7, #12]

  /* Check if instance is valid */
  if ((PortNum >= USBPD_PWR_INSTANCES_NBR) || (NULL == pVoltage))
341849a6:	687b      	ldr	r3, [r7, #4]
341849a8:	2b00      	cmp	r3, #0
341849aa:	d102      	bne.n	341849b2 <BSP_USBPD_PWR_VBUSGetVoltage+0x1a>
341849ac:	683b      	ldr	r3, [r7, #0]
341849ae:	2b00      	cmp	r3, #0
341849b0:	d103      	bne.n	341849ba <BSP_USBPD_PWR_VBUSGetVoltage+0x22>
  {
    ret = BSP_ERROR_WRONG_PARAM;
341849b2:	f06f 0301 	mvn.w	r3, #1
341849b6:	60fb      	str	r3, [r7, #12]
341849b8:	e012      	b.n	341849e0 <BSP_USBPD_PWR_VBUSGetVoltage+0x48>
  }
  else
  {
    uint32_t voltage;
    static __IO uint16_t adc_value;
    adc_value = LL_ADC_REG_ReadConversionData12(TCPP0203_PORT0_VBUSC_ADC_INSTANCE);
341849ba:	480c      	ldr	r0, [pc, #48]	@ (341849ec <BSP_USBPD_PWR_VBUSGetVoltage+0x54>)
341849bc:	f7ff fc14 	bl	341841e8 <LL_ADC_REG_ReadConversionData12>
341849c0:	4603      	mov	r3, r0
341849c2:	461a      	mov	r2, r3
341849c4:	4b0a      	ldr	r3, [pc, #40]	@ (341849f0 <BSP_USBPD_PWR_VBUSGetVoltage+0x58>)
341849c6:	801a      	strh	r2, [r3, #0]
    voltage = PWR_TCPP0203_ConvertADCDataToVoltage(adc_value, TCPP0203_PORT0_VBUSC_RA, TCPP0203_PORT0_VBUSC_RB);
341849c8:	4b09      	ldr	r3, [pc, #36]	@ (341849f0 <BSP_USBPD_PWR_VBUSGetVoltage+0x58>)
341849ca:	881b      	ldrh	r3, [r3, #0]
341849cc:	b29b      	uxth	r3, r3
341849ce:	220a      	movs	r2, #10
341849d0:	218c      	movs	r1, #140	@ 0x8c
341849d2:	4618      	mov	r0, r3
341849d4:	f000 faf8 	bl	34184fc8 <PWR_TCPP0203_ConvertADCDataToVoltage>
341849d8:	60b8      	str	r0, [r7, #8]

    *pVoltage = voltage;
341849da:	683b      	ldr	r3, [r7, #0]
341849dc:	68ba      	ldr	r2, [r7, #8]
341849de:	601a      	str	r2, [r3, #0]
  }
  return ret;
341849e0:	68fb      	ldr	r3, [r7, #12]
}
341849e2:	4618      	mov	r0, r3
341849e4:	3710      	adds	r7, #16
341849e6:	46bd      	mov	sp, r7
341849e8:	bd80      	pop	{r7, pc}
341849ea:	bf00      	nop
341849ec:	50022100 	.word	0x50022100
341849f0:	341c2d06 	.word	0x341c2d06

341849f4 <BSP_USBPD_PWR_EventCallback>:
  *         any PWR related event detection mechanism)
  * @param  PortNum Type-C port identifier
  * @retval None
  */
void BSP_USBPD_PWR_EventCallback(uint32_t PortNum)
{
341849f4:	b580      	push	{r7, lr}
341849f6:	b082      	sub	sp, #8
341849f8:	af00      	add	r7, sp, #0
341849fa:	6078      	str	r0, [r7, #4]
  BSP_USBPD_PWR_TRACE(PortNum, "-- BSP_USBPD_PWR_EventCallback --");

  /* Handle USBPD PWR event */
  switch (USBPD_PWR_Port_Configs[PortNum].Type)
341849fc:	4a07      	ldr	r2, [pc, #28]	@ (34184a1c <BSP_USBPD_PWR_EventCallback+0x28>)
341849fe:	687b      	ldr	r3, [r7, #4]
34184a00:	f812 3013 	ldrb.w	r3, [r2, r3, lsl #1]
34184a04:	3b02      	subs	r3, #2
34184a06:	2b01      	cmp	r3, #1
34184a08:	d803      	bhi.n	34184a12 <BSP_USBPD_PWR_EventCallback+0x1e>
  {
    case USBPD_PWR_HW_CONFIG_TYPE_TCPP02:
    case USBPD_PWR_HW_CONFIG_TYPE_TCPP03:
      /* In case of TCPP0203, this callback could be called when an event is detected
         on FLGn line */
      PWR_TCPP0203_EventCallback(PortNum);
34184a0a:	6878      	ldr	r0, [r7, #4]
34184a0c:	f000 f9dc 	bl	34184dc8 <PWR_TCPP0203_EventCallback>
      break;
34184a10:	e000      	b.n	34184a14 <BSP_USBPD_PWR_EventCallback+0x20>

    case USBPD_PWR_HW_CONFIG_TYPE_DEFAULT:
    case USBPD_PWR_HW_CONFIG_TYPE_TCPP01:
    default:
      break;
34184a12:	bf00      	nop
  }
}
34184a14:	bf00      	nop
34184a16:	3708      	adds	r7, #8
34184a18:	46bd      	mov	sp, r7
34184a1a:	bd80      	pop	{r7, pc}
34184a1c:	341c0080 	.word	0x341c0080

34184a20 <PWR_TCPP0203_GPIOConfigInit>:
  * @note   GPIO used for TCPP0203 operation includes VBUS measurement, ENABLE pin driving
  * @param  PortNum   Port number
  * @retval None
  */
static void PWR_TCPP0203_GPIOConfigInit(uint32_t PortNum)
{
34184a20:	b580      	push	{r7, lr}
34184a22:	b082      	sub	sp, #8
34184a24:	af00      	add	r7, sp, #0
34184a26:	6078      	str	r0, [r7, #4]
  UNUSED(PortNum);

  /* Configure ENABLE GPIO : Applies only from B01 revision of DK board */
  TCPP0203_PORT0_ENABLE_GPIO_CLK_ENABLE();
34184a28:	2001      	movs	r0, #1
34184a2a:	f7ff fbc7 	bl	341841bc <LL_AHB4_GRP1_EnableClock>
  /* Configure IO in output push-pull mode to drive ENABLE */
  LL_GPIO_SetPinMode(TCPP0203_PORT0_ENABLE_GPIO_PORT, TCPP0203_PORT0_ENABLE_GPIO_PIN, TCPP0203_PORT0_ENABLE_GPIO_MODE);
34184a2e:	2201      	movs	r2, #1
34184a30:	2110      	movs	r1, #16
34184a32:	4815      	ldr	r0, [pc, #84]	@ (34184a88 <PWR_TCPP0203_GPIOConfigInit+0x68>)
34184a34:	f7ff fbe5 	bl	34184202 <LL_GPIO_SetPinMode>
  LL_GPIO_SetPinOutputType(TCPP0203_PORT0_ENABLE_GPIO_PORT, TCPP0203_PORT0_ENABLE_GPIO_PIN,
34184a38:	2200      	movs	r2, #0
34184a3a:	2110      	movs	r1, #16
34184a3c:	4812      	ldr	r0, [pc, #72]	@ (34184a88 <PWR_TCPP0203_GPIOConfigInit+0x68>)
34184a3e:	f7ff fc1d 	bl	3418427c <LL_GPIO_SetPinOutputType>
                           TCPP0203_PORT0_ENABLE_GPIO_OUTPUT);
  LL_GPIO_SetPinSpeed(TCPP0203_PORT0_ENABLE_GPIO_PORT, TCPP0203_PORT0_ENABLE_GPIO_PIN, LL_GPIO_SPEED_FREQ_LOW);
34184a42:	2200      	movs	r2, #0
34184a44:	2110      	movs	r1, #16
34184a46:	4810      	ldr	r0, [pc, #64]	@ (34184a88 <PWR_TCPP0203_GPIOConfigInit+0x68>)
34184a48:	f7ff fc30 	bl	341842ac <LL_GPIO_SetPinSpeed>
  LL_GPIO_SetPinPull(TCPP0203_PORT0_ENABLE_GPIO_PORT, TCPP0203_PORT0_ENABLE_GPIO_PIN, TCPP0203_PORT0_ENABLE_GPIO_PUPD);
34184a4c:	2200      	movs	r2, #0
34184a4e:	2110      	movs	r1, #16
34184a50:	480d      	ldr	r0, [pc, #52]	@ (34184a88 <PWR_TCPP0203_GPIOConfigInit+0x68>)
34184a52:	f7ff fc68 	bl	34184326 <LL_GPIO_SetPinPull>

  /* Set ENABLE to default state */
  TCPP0203_PORT0_ENABLE_GPIO_DEFVALUE();
34184a56:	2110      	movs	r1, #16
34184a58:	480b      	ldr	r0, [pc, #44]	@ (34184a88 <PWR_TCPP0203_GPIOConfigInit+0x68>)
34184a5a:	f7ff fcaf 	bl	341843bc <LL_GPIO_ResetOutputPin>

  /* Configure IANA GPIO */
  TCPP0203_PORT0_IANA_GPIO_CLK_ENABLE();
34184a5e:	2001      	movs	r0, #1
34184a60:	f7ff fbac 	bl	341841bc <LL_AHB4_GRP1_EnableClock>
  /* Configure GPIO in Analog mode */
  LL_GPIO_SetPinMode(TCPP0203_PORT0_IANA_GPIO_PORT, TCPP0203_PORT0_IANA_GPIO_PIN, TCPP0203_PORT0_IANA_GPIO_MODE);
34184a64:	2203      	movs	r2, #3
34184a66:	2120      	movs	r1, #32
34184a68:	4807      	ldr	r0, [pc, #28]	@ (34184a88 <PWR_TCPP0203_GPIOConfigInit+0x68>)
34184a6a:	f7ff fbca 	bl	34184202 <LL_GPIO_SetPinMode>

  /* Configure VBUS Connector sensing GPIO */
  TCPP0203_PORT0_VBUSC_GPIO_CLK_ENABLE();
34184a6e:	2001      	movs	r0, #1
34184a70:	f7ff fba4 	bl	341841bc <LL_AHB4_GRP1_EnableClock>
  /* Configure GPIO in Analog mode */
  LL_GPIO_SetPinMode(TCPP0203_PORT0_VBUSC_GPIO_PORT, TCPP0203_PORT0_VBUSC_GPIO_PIN, TCPP0203_PORT0_VBUSC_GPIO_MODE);
34184a74:	2203      	movs	r2, #3
34184a76:	f44f 6100 	mov.w	r1, #2048	@ 0x800
34184a7a:	4803      	ldr	r0, [pc, #12]	@ (34184a88 <PWR_TCPP0203_GPIOConfigInit+0x68>)
34184a7c:	f7ff fbc1 	bl	34184202 <LL_GPIO_SetPinMode>
}
34184a80:	bf00      	nop
34184a82:	3708      	adds	r7, #8
34184a84:	46bd      	mov	sp, r7
34184a86:	bd80      	pop	{r7, pc}
34184a88:	56020000 	.word	0x56020000

34184a8c <PWR_TCPP0203_Configure_ADC>:
/**
  * @brief  Configure ADC (ADC instance for Vsense and Isense: TCPP0203_PORT0_VBUSC_ADC_INSTANCE) and GPIO used by ADC channels.
  * @retval None
  */
static void PWR_TCPP0203_Configure_ADC(void)
{
34184a8c:	b580      	push	{r7, lr}
34184a8e:	b0ec      	sub	sp, #432	@ 0x1b0
34184a90:	af00      	add	r7, sp, #0
  static ADC_HandleTypeDef hadc;

  /* USER CODE BEGIN ADC_Init 0 */
  TCPP0203_PORT0_VBUSC_ADC_CLK_ENABLE();
34184a92:	2020      	movs	r0, #32
34184a94:	f7ff fb7c 	bl	34184190 <LL_AHB1_GRP1_EnableClock>

  /* Configure the GPIO as analog */
  TCPP0203_PORT0_VBUSC_GPIO_CLK_ENABLE();
34184a98:	2001      	movs	r0, #1
34184a9a:	f7ff fb8f 	bl	341841bc <LL_AHB4_GRP1_EnableClock>
  LL_GPIO_SetPinMode(TCPP0203_PORT0_VBUSC_GPIO_PORT, TCPP0203_PORT0_VBUSC_GPIO_PIN, TCPP0203_PORT0_VBUSC_GPIO_MODE);
34184a9e:	2203      	movs	r2, #3
34184aa0:	f44f 6100 	mov.w	r1, #2048	@ 0x800
34184aa4:	4849      	ldr	r0, [pc, #292]	@ (34184bcc <PWR_TCPP0203_Configure_ADC+0x140>)
34184aa6:	f7ff fbac 	bl	34184202 <LL_GPIO_SetPinMode>

  /* USER CODE END ADC1_Init 0 */

  RCC_PeriphCLKInitTypeDef  RCC_PeriphClkInitStructure;
  RCC_PeriphClkInitStructure.PeriphClockSelection = RCC_PERIPHCLK_ADC;
34184aaa:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34184aae:	f5a3 71c8 	sub.w	r1, r3, #400	@ 0x190
34184ab2:	f04f 0201 	mov.w	r2, #1
34184ab6:	f04f 0300 	mov.w	r3, #0
34184aba:	e9c1 2300 	strd	r2, r3, [r1]
  RCC_PeriphClkInitStructure.AdcClockSelection    = RCC_ADCCLKSOURCE_CLKP;
34184abe:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34184ac2:	f5a3 73c8 	sub.w	r3, r3, #400	@ 0x190
34184ac6:	2210      	movs	r2, #16
34184ac8:	f8c3 20bc 	str.w	r2, [r3, #188]	@ 0xbc
  HAL_RCCEx_PeriphCLKConfig(&RCC_PeriphClkInitStructure);
34184acc:	f107 0320 	add.w	r3, r7, #32
34184ad0:	4618      	mov	r0, r3
34184ad2:	f006 fd1b 	bl	3418b50c <HAL_RCCEx_PeriphCLKConfig>

  ADC_ChannelConfTypeDef sConfig = {0};
34184ad6:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34184ada:	f5a3 73d8 	sub.w	r3, r3, #432	@ 0x1b0
34184ade:	4618      	mov	r0, r3
34184ae0:	2320      	movs	r3, #32
34184ae2:	461a      	mov	r2, r3
34184ae4:	2100      	movs	r1, #0
34184ae6:	f019 faeb 	bl	3419e0c0 <memset>

  /* USER CODE BEGIN ADC_Init 1 */

  /* USER CODE END ADC_Init 1 */
  /* Configure the global features of the ADC (Clock, Resolution, Data Alignment and number of conversion) */
  hadc.Instance = TCPP0203_PORT0_VBUSC_ADC_INSTANCE;
34184aea:	4b39      	ldr	r3, [pc, #228]	@ (34184bd0 <PWR_TCPP0203_Configure_ADC+0x144>)
34184aec:	4a39      	ldr	r2, [pc, #228]	@ (34184bd4 <PWR_TCPP0203_Configure_ADC+0x148>)
34184aee:	601a      	str	r2, [r3, #0]
  hadc.Init.Resolution = ADC_RESOLUTION_12B;
34184af0:	4b37      	ldr	r3, [pc, #220]	@ (34184bd0 <PWR_TCPP0203_Configure_ADC+0x144>)
34184af2:	2200      	movs	r2, #0
34184af4:	605a      	str	r2, [r3, #4]
  hadc.Init.ScanConvMode = ADC_SCAN_ENABLE;
34184af6:	4b36      	ldr	r3, [pc, #216]	@ (34184bd0 <PWR_TCPP0203_Configure_ADC+0x144>)
34184af8:	2201      	movs	r2, #1
34184afa:	60da      	str	r2, [r3, #12]
  hadc.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
34184afc:	4b34      	ldr	r3, [pc, #208]	@ (34184bd0 <PWR_TCPP0203_Configure_ADC+0x144>)
34184afe:	2204      	movs	r2, #4
34184b00:	611a      	str	r2, [r3, #16]
  hadc.Init.LowPowerAutoWait = DISABLE;
34184b02:	4b33      	ldr	r3, [pc, #204]	@ (34184bd0 <PWR_TCPP0203_Configure_ADC+0x144>)
34184b04:	2200      	movs	r2, #0
34184b06:	751a      	strb	r2, [r3, #20]
  hadc.Init.ContinuousConvMode = ENABLE;
34184b08:	4b31      	ldr	r3, [pc, #196]	@ (34184bd0 <PWR_TCPP0203_Configure_ADC+0x144>)
34184b0a:	2201      	movs	r2, #1
34184b0c:	755a      	strb	r2, [r3, #21]
  hadc.Init.NbrOfConversion = 1;
34184b0e:	4b30      	ldr	r3, [pc, #192]	@ (34184bd0 <PWR_TCPP0203_Configure_ADC+0x144>)
34184b10:	2201      	movs	r2, #1
34184b12:	619a      	str	r2, [r3, #24]
  hadc.Init.DiscontinuousConvMode = DISABLE;
34184b14:	4b2e      	ldr	r3, [pc, #184]	@ (34184bd0 <PWR_TCPP0203_Configure_ADC+0x144>)
34184b16:	2200      	movs	r2, #0
34184b18:	771a      	strb	r2, [r3, #28]
  hadc.Init.ExternalTrigConv = ADC_SOFTWARE_START;
34184b1a:	4b2d      	ldr	r3, [pc, #180]	@ (34184bd0 <PWR_TCPP0203_Configure_ADC+0x144>)
34184b1c:	2200      	movs	r2, #0
34184b1e:	625a      	str	r2, [r3, #36]	@ 0x24
  hadc.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
34184b20:	4b2b      	ldr	r3, [pc, #172]	@ (34184bd0 <PWR_TCPP0203_Configure_ADC+0x144>)
34184b22:	2200      	movs	r2, #0
34184b24:	629a      	str	r2, [r3, #40]	@ 0x28
  hadc.Init.ConversionDataManagement = ADC_CONVERSIONDATA_DR;
34184b26:	4b2a      	ldr	r3, [pc, #168]	@ (34184bd0 <PWR_TCPP0203_Configure_ADC+0x144>)
34184b28:	2200      	movs	r2, #0
34184b2a:	631a      	str	r2, [r3, #48]	@ 0x30
  hadc.Init.Overrun = ADC_OVR_DATA_OVERWRITTEN;
34184b2c:	4b28      	ldr	r3, [pc, #160]	@ (34184bd0 <PWR_TCPP0203_Configure_ADC+0x144>)
34184b2e:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
34184b32:	635a      	str	r2, [r3, #52]	@ 0x34
  hadc.Init.OversamplingMode = DISABLE;
34184b34:	4b26      	ldr	r3, [pc, #152]	@ (34184bd0 <PWR_TCPP0203_Configure_ADC+0x144>)
34184b36:	2200      	movs	r2, #0
34184b38:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c
  HAL_ADC_Init(&hadc);
34184b3c:	4824      	ldr	r0, [pc, #144]	@ (34184bd0 <PWR_TCPP0203_Configure_ADC+0x144>)
34184b3e:	f001 f8cb 	bl	34185cd8 <HAL_ADC_Init>

  /* Configure Regular Channel */
  sConfig.Channel = TCPP0203_PORT0_VBUSC_ADC_CHANNEL;
34184b42:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34184b46:	f5a3 73d8 	sub.w	r3, r3, #432	@ 0x1b0
34184b4a:	220c      	movs	r2, #12
34184b4c:	601a      	str	r2, [r3, #0]
  sConfig.Rank = TCPP0203_PORT0_VBUSC_ADC_RANK;
34184b4e:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34184b52:	f5a3 73d8 	sub.w	r3, r3, #432	@ 0x1b0
34184b56:	2206      	movs	r2, #6
34184b58:	605a      	str	r2, [r3, #4]
  sConfig.SamplingTime = ADC_SAMPLETIME_246CYCLES_5;
34184b5a:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34184b5e:	f5a3 73d8 	sub.w	r3, r3, #432	@ 0x1b0
34184b62:	2206      	movs	r2, #6
34184b64:	609a      	str	r2, [r3, #8]
  sConfig.SingleDiff   = ADC_SINGLE_ENDED;            /* Single-ended input channel */
34184b66:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34184b6a:	f5a3 73d8 	sub.w	r3, r3, #432	@ 0x1b0
34184b6e:	f240 32ff 	movw	r2, #1023	@ 0x3ff
34184b72:	60da      	str	r2, [r3, #12]
  sConfig.OffsetNumber = ADC_OFFSET_NONE;             /* No offset subtraction */
34184b74:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34184b78:	f5a3 73d8 	sub.w	r3, r3, #432	@ 0x1b0
34184b7c:	2204      	movs	r2, #4
34184b7e:	611a      	str	r2, [r3, #16]
  sConfig.Offset = 0U;                                /* Parameter discarded because offset correction is disabled */
34184b80:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34184b84:	f5a3 73d8 	sub.w	r3, r3, #432	@ 0x1b0
34184b88:	2200      	movs	r2, #0
34184b8a:	615a      	str	r2, [r3, #20]
  sConfig.OffsetSaturation = DISABLE;
34184b8c:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34184b90:	f5a3 73d8 	sub.w	r3, r3, #432	@ 0x1b0
34184b94:	2200      	movs	r2, #0
34184b96:	765a      	strb	r2, [r3, #25]
  sConfig.OffsetSign = ADC_OFFSET_SIGN_POSITIVE;
34184b98:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34184b9c:	f5a3 73d8 	sub.w	r3, r3, #432	@ 0x1b0
34184ba0:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
34184ba4:	61da      	str	r2, [r3, #28]

  HAL_ADC_ConfigChannel(&hadc, &sConfig);
34184ba6:	463b      	mov	r3, r7
34184ba8:	4619      	mov	r1, r3
34184baa:	4809      	ldr	r0, [pc, #36]	@ (34184bd0 <PWR_TCPP0203_Configure_ADC+0x144>)
34184bac:	f001 fa74 	bl	34186098 <HAL_ADC_ConfigChannel>

  /* USER CODE BEGIN ADC_Init 2 */
  HAL_ADCEx_Calibration_Start(&hadc, ADC_SINGLE_ENDED);
34184bb0:	f240 31ff 	movw	r1, #1023	@ 0x3ff
34184bb4:	4806      	ldr	r0, [pc, #24]	@ (34184bd0 <PWR_TCPP0203_Configure_ADC+0x144>)
34184bb6:	f001 fdd1 	bl	3418675c <HAL_ADCEx_Calibration_Start>

  HAL_ADC_Start(&hadc);
34184bba:	4805      	ldr	r0, [pc, #20]	@ (34184bd0 <PWR_TCPP0203_Configure_ADC+0x144>)
34184bbc:	f001 f9b2 	bl	34185f24 <HAL_ADC_Start>
  /* USER CODE END ADC_Init 2 */
}
34184bc0:	bf00      	nop
34184bc2:	f507 77d8 	add.w	r7, r7, #432	@ 0x1b0
34184bc6:	46bd      	mov	sp, r7
34184bc8:	bd80      	pop	{r7, pc}
34184bca:	bf00      	nop
34184bcc:	56020000 	.word	0x56020000
34184bd0:	341c2d08 	.word	0x341c2d08
34184bd4:	50022100 	.word	0x50022100

34184bd8 <PWR_TCPP0203_ITConfigInit>:
  * @note   Corresponds to EXTI mapped onto FLGn pin of TCPP0203
  * @param  PortNum   Port number
  * @retval None
  */
static void PWR_TCPP0203_ITConfigInit(uint32_t PortNum)
{
34184bd8:	b580      	push	{r7, lr}
34184bda:	b082      	sub	sp, #8
34184bdc:	af00      	add	r7, sp, #0
34184bde:	6078      	str	r0, [r7, #4]
  if (USBPD_PWR_Port_Status[PortNum].IsItEnabled == 0U)
34184be0:	4921      	ldr	r1, [pc, #132]	@ (34184c68 <PWR_TCPP0203_ITConfigInit+0x90>)
34184be2:	687a      	ldr	r2, [r7, #4]
34184be4:	4613      	mov	r3, r2
34184be6:	005b      	lsls	r3, r3, #1
34184be8:	4413      	add	r3, r2
34184bea:	009b      	lsls	r3, r3, #2
34184bec:	440b      	add	r3, r1
34184bee:	3301      	adds	r3, #1
34184bf0:	781b      	ldrb	r3, [r3, #0]
34184bf2:	2b00      	cmp	r3, #0
34184bf4:	d133      	bne.n	34184c5e <PWR_TCPP0203_ITConfigInit+0x86>
  {
    USBPD_PWR_Port_Status[PortNum].IsItEnabled = 1U;
34184bf6:	491c      	ldr	r1, [pc, #112]	@ (34184c68 <PWR_TCPP0203_ITConfigInit+0x90>)
34184bf8:	687a      	ldr	r2, [r7, #4]
34184bfa:	4613      	mov	r3, r2
34184bfc:	005b      	lsls	r3, r3, #1
34184bfe:	4413      	add	r3, r2
34184c00:	009b      	lsls	r3, r3, #2
34184c02:	440b      	add	r3, r1
34184c04:	3301      	adds	r3, #1
34184c06:	2201      	movs	r2, #1
34184c08:	701a      	strb	r2, [r3, #0]

    /* Enable the GPIO EXTI clock */
    TCPP0203_PORT0_FLG_GPIO_CLK_ENABLE();
34184c0a:	2008      	movs	r0, #8
34184c0c:	f7ff fad6 	bl	341841bc <LL_AHB4_GRP1_EnableClock>
    /* Configure IO */
    LL_GPIO_SetPinMode(TCPP0203_PORT0_FLG_GPIO_PORT, TCPP0203_PORT0_FLG_GPIO_PIN, TCPP0203_PORT0_FLG_GPIO_MODE);
34184c10:	2200      	movs	r2, #0
34184c12:	f44f 6180 	mov.w	r1, #1024	@ 0x400
34184c16:	4815      	ldr	r0, [pc, #84]	@ (34184c6c <PWR_TCPP0203_ITConfigInit+0x94>)
34184c18:	f7ff faf3 	bl	34184202 <LL_GPIO_SetPinMode>
    LL_GPIO_SetPinPull(TCPP0203_PORT0_FLG_GPIO_PORT, TCPP0203_PORT0_FLG_GPIO_PIN, TCPP0203_PORT0_FLG_GPIO_PUPD);
34184c1c:	2201      	movs	r2, #1
34184c1e:	f44f 6180 	mov.w	r1, #1024	@ 0x400
34184c22:	4812      	ldr	r0, [pc, #72]	@ (34184c6c <PWR_TCPP0203_ITConfigInit+0x94>)
34184c24:	f7ff fb7f 	bl	34184326 <LL_GPIO_SetPinPull>

    /* Connect External Line to the GPIO*/
    TCPP0203_PORT0_FLG_SET_EXTI();
34184c28:	4911      	ldr	r1, [pc, #68]	@ (34184c70 <PWR_TCPP0203_ITConfigInit+0x98>)
34184c2a:	2003      	movs	r0, #3
34184c2c:	f7ff fc24 	bl	34184478 <LL_EXTI_SetEXTISource>

    /* Enable a falling trigger EXTI line x Interrupt */
    TCPP0203_PORT0_FLG_EXTI_ENABLE();
34184c30:	f44f 6080 	mov.w	r0, #1024	@ 0x400
34184c34:	f7ff fbe4 	bl	34184400 <LL_EXTI_DisableEvent_0_31>
34184c38:	f44f 6080 	mov.w	r0, #1024	@ 0x400
34184c3c:	f7ff fbcc 	bl	341843d8 <LL_EXTI_EnableIT_0_31>
    TCPP0203_PORT0_FLG_TRIG_ENABLE();
34184c40:	f44f 6080 	mov.w	r0, #1024	@ 0x400
34184c44:	f7ff fbf2 	bl	3418442c <LL_EXTI_DisableRisingTrig_0_31>
34184c48:	f44f 6080 	mov.w	r0, #1024	@ 0x400
34184c4c:	f7ff fc02 	bl	34184454 <LL_EXTI_EnableFallingTrig_0_31>

    /* Configure NVIC for EXTIx_IRQn */
    NVIC_SetPriority(TCPP0203_PORT0_FLG_EXTI_IRQN, TCPP0203_PORT0_FLG_IT_PRIORITY);
34184c50:	210c      	movs	r1, #12
34184c52:	201e      	movs	r0, #30
34184c54:	f7ff fa72 	bl	3418413c <__NVIC_SetPriority>
    NVIC_EnableIRQ(TCPP0203_PORT0_FLG_EXTI_IRQN);
34184c58:	201e      	movs	r0, #30
34184c5a:	f7ff fa51 	bl	34184100 <__NVIC_EnableIRQ>
  }
}
34184c5e:	bf00      	nop
34184c60:	3708      	adds	r7, #8
34184c62:	46bd      	mov	sp, r7
34184c64:	bd80      	pop	{r7, pc}
34184c66:	bf00      	nop
34184c68:	341c0084 	.word	0x341c0084
34184c6c:	56020c00 	.word	0x56020c00
34184c70:	00100002 	.word	0x00100002

34184c74 <PWR_TCPP0203_BUSConfigInit>:
  * @param  PortNum   Port number
  * @param  Address   I2C Address
  * @retval BSP status
  */
static int32_t PWR_TCPP0203_BUSConfigInit(uint32_t PortNum, uint16_t Address)
{
34184c74:	b590      	push	{r4, r7, lr}
34184c76:	b08b      	sub	sp, #44	@ 0x2c
34184c78:	af00      	add	r7, sp, #0
34184c7a:	6078      	str	r0, [r7, #4]
34184c7c:	460b      	mov	r3, r1
34184c7e:	807b      	strh	r3, [r7, #2]
  int32_t                  ret = BSP_ERROR_NONE;
34184c80:	2300      	movs	r3, #0
34184c82:	627b      	str	r3, [r7, #36]	@ 0x24
  TCPP0203_IO_t            TCPP0203IOCtx;
  uint8_t                  tcpp_type;

  /* Configure the TCPP0203 I2C driver */
  TCPP0203IOCtx.Address     = Address;
34184c84:	887b      	ldrh	r3, [r7, #2]
34184c86:	82bb      	strh	r3, [r7, #20]
  TCPP0203IOCtx.Init        = BSP_I2C2_Init;
34184c88:	4b46      	ldr	r3, [pc, #280]	@ (34184da4 <PWR_TCPP0203_BUSConfigInit+0x130>)
34184c8a:	60fb      	str	r3, [r7, #12]
  TCPP0203IOCtx.DeInit      = BSP_I2C2_DeInit;
34184c8c:	4b46      	ldr	r3, [pc, #280]	@ (34184da8 <PWR_TCPP0203_BUSConfigInit+0x134>)
34184c8e:	613b      	str	r3, [r7, #16]
  TCPP0203IOCtx.ReadReg     = BSP_I2C2_ReadReg;
34184c90:	4b46      	ldr	r3, [pc, #280]	@ (34184dac <PWR_TCPP0203_BUSConfigInit+0x138>)
34184c92:	61fb      	str	r3, [r7, #28]
  TCPP0203IOCtx.WriteReg    = BSP_I2C2_WriteReg;
34184c94:	4b46      	ldr	r3, [pc, #280]	@ (34184db0 <PWR_TCPP0203_BUSConfigInit+0x13c>)
34184c96:	61bb      	str	r3, [r7, #24]
  TCPP0203IOCtx.GetTick     = BSP_GetTick;
34184c98:	4b46      	ldr	r3, [pc, #280]	@ (34184db4 <PWR_TCPP0203_BUSConfigInit+0x140>)
34184c9a:	623b      	str	r3, [r7, #32]

  /* Register the component on BUS IO */
  if (TCPP0203_RegisterBusIO(&USBPD_PWR_PortCompObj[PortNum], &TCPP0203IOCtx) != TCPP0203_OK)
34184c9c:	687a      	ldr	r2, [r7, #4]
34184c9e:	4613      	mov	r3, r2
34184ca0:	009b      	lsls	r3, r3, #2
34184ca2:	4413      	add	r3, r2
34184ca4:	00db      	lsls	r3, r3, #3
34184ca6:	4a44      	ldr	r2, [pc, #272]	@ (34184db8 <PWR_TCPP0203_BUSConfigInit+0x144>)
34184ca8:	4413      	add	r3, r2
34184caa:	f107 020c 	add.w	r2, r7, #12
34184cae:	4611      	mov	r1, r2
34184cb0:	4618      	mov	r0, r3
34184cb2:	f7fe f9b7 	bl	34183024 <TCPP0203_RegisterBusIO>
34184cb6:	4603      	mov	r3, r0
34184cb8:	2b00      	cmp	r3, #0
34184cba:	d003      	beq.n	34184cc4 <PWR_TCPP0203_BUSConfigInit+0x50>
  {
    ret = BSP_ERROR_BUS_FAILURE;
34184cbc:	f06f 0307 	mvn.w	r3, #7
34184cc0:	627b      	str	r3, [r7, #36]	@ 0x24
34184cc2:	e069      	b.n	34184d98 <PWR_TCPP0203_BUSConfigInit+0x124>
  }
  else
  {
    /* Initialisation step */
    USBPD_PWR_PortCompDrv[PortNum] = &TCPP0203_Driver;
34184cc4:	4a3d      	ldr	r2, [pc, #244]	@ (34184dbc <PWR_TCPP0203_BUSConfigInit+0x148>)
34184cc6:	687b      	ldr	r3, [r7, #4]
34184cc8:	493d      	ldr	r1, [pc, #244]	@ (34184dc0 <PWR_TCPP0203_BUSConfigInit+0x14c>)
34184cca:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
    if (USBPD_PWR_PortCompDrv[PortNum]->Init(&USBPD_PWR_PortCompObj[PortNum]) != TCPP0203_OK)
34184cce:	4a3b      	ldr	r2, [pc, #236]	@ (34184dbc <PWR_TCPP0203_BUSConfigInit+0x148>)
34184cd0:	687b      	ldr	r3, [r7, #4]
34184cd2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
34184cd6:	6819      	ldr	r1, [r3, #0]
34184cd8:	687a      	ldr	r2, [r7, #4]
34184cda:	4613      	mov	r3, r2
34184cdc:	009b      	lsls	r3, r3, #2
34184cde:	4413      	add	r3, r2
34184ce0:	00db      	lsls	r3, r3, #3
34184ce2:	4a35      	ldr	r2, [pc, #212]	@ (34184db8 <PWR_TCPP0203_BUSConfigInit+0x144>)
34184ce4:	4413      	add	r3, r2
34184ce6:	4618      	mov	r0, r3
34184ce8:	4788      	blx	r1
34184cea:	4603      	mov	r3, r0
34184cec:	2b00      	cmp	r3, #0
34184cee:	d002      	beq.n	34184cf6 <PWR_TCPP0203_BUSConfigInit+0x82>
    {
      ret = BSP_ERROR_COMPONENT_FAILURE;
34184cf0:	f06f 0304 	mvn.w	r3, #4
34184cf4:	627b      	str	r3, [r7, #36]	@ 0x24
    }

    /* Read the component type */
    if (USBPD_PWR_PortCompDrv[PortNum]->ReadTCPPType(&USBPD_PWR_PortCompObj[PortNum], &tcpp_type) != TCPP0203_OK)
34184cf6:	4a31      	ldr	r2, [pc, #196]	@ (34184dbc <PWR_TCPP0203_BUSConfigInit+0x148>)
34184cf8:	687b      	ldr	r3, [r7, #4]
34184cfa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
34184cfe:	6d5c      	ldr	r4, [r3, #84]	@ 0x54
34184d00:	687a      	ldr	r2, [r7, #4]
34184d02:	4613      	mov	r3, r2
34184d04:	009b      	lsls	r3, r3, #2
34184d06:	4413      	add	r3, r2
34184d08:	00db      	lsls	r3, r3, #3
34184d0a:	4a2b      	ldr	r2, [pc, #172]	@ (34184db8 <PWR_TCPP0203_BUSConfigInit+0x144>)
34184d0c:	4413      	add	r3, r2
34184d0e:	f107 020b 	add.w	r2, r7, #11
34184d12:	4611      	mov	r1, r2
34184d14:	4618      	mov	r0, r3
34184d16:	47a0      	blx	r4
34184d18:	4603      	mov	r3, r0
34184d1a:	2b00      	cmp	r3, #0
34184d1c:	d003      	beq.n	34184d26 <PWR_TCPP0203_BUSConfigInit+0xb2>
    {
      ret = BSP_ERROR_COMPONENT_FAILURE;
34184d1e:	f06f 0304 	mvn.w	r3, #4
34184d22:	627b      	str	r3, [r7, #36]	@ 0x24
34184d24:	e038      	b.n	34184d98 <PWR_TCPP0203_BUSConfigInit+0x124>
    }
    /* Check the component type */
    else if ((tcpp_type != TCPP0203_DEVICE_TYPE_02)
34184d26:	7afb      	ldrb	r3, [r7, #11]
34184d28:	2b80      	cmp	r3, #128	@ 0x80
34184d2a:	d006      	beq.n	34184d3a <PWR_TCPP0203_BUSConfigInit+0xc6>
             && (tcpp_type != TCPP0203_DEVICE_TYPE_03))
34184d2c:	7afb      	ldrb	r3, [r7, #11]
34184d2e:	2b00      	cmp	r3, #0
34184d30:	d003      	beq.n	34184d3a <PWR_TCPP0203_BUSConfigInit+0xc6>
    {
      ret = BSP_ERROR_UNKNOWN_COMPONENT;
34184d32:	f06f 0306 	mvn.w	r3, #6
34184d36:	627b      	str	r3, [r7, #36]	@ 0x24
34184d38:	e02e      	b.n	34184d98 <PWR_TCPP0203_BUSConfigInit+0x124>
    }
    /* Reset TCPP0203 Reg0 register */
    else if (USBPD_PWR_PortCompDrv[PortNum]->Reset(&USBPD_PWR_PortCompObj[PortNum]) != TCPP0203_OK)
34184d3a:	4a20      	ldr	r2, [pc, #128]	@ (34184dbc <PWR_TCPP0203_BUSConfigInit+0x148>)
34184d3c:	687b      	ldr	r3, [r7, #4]
34184d3e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
34184d42:	6899      	ldr	r1, [r3, #8]
34184d44:	687a      	ldr	r2, [r7, #4]
34184d46:	4613      	mov	r3, r2
34184d48:	009b      	lsls	r3, r3, #2
34184d4a:	4413      	add	r3, r2
34184d4c:	00db      	lsls	r3, r3, #3
34184d4e:	4a1a      	ldr	r2, [pc, #104]	@ (34184db8 <PWR_TCPP0203_BUSConfigInit+0x144>)
34184d50:	4413      	add	r3, r2
34184d52:	4618      	mov	r0, r3
34184d54:	4788      	blx	r1
34184d56:	4603      	mov	r3, r0
34184d58:	2b00      	cmp	r3, #0
34184d5a:	d003      	beq.n	34184d64 <PWR_TCPP0203_BUSConfigInit+0xf0>
    {
      ret = BSP_ERROR_COMPONENT_FAILURE;
34184d5c:	f06f 0304 	mvn.w	r3, #4
34184d60:	627b      	str	r3, [r7, #36]	@ 0x24
34184d62:	e019      	b.n	34184d98 <PWR_TCPP0203_BUSConfigInit+0x124>
    }
    else
    {
      /* Check the component type and update config accordingly */
      USBPD_PWR_Port_Configs[PortNum].Type = tcpp_type;
34184d64:	7af9      	ldrb	r1, [r7, #11]
34184d66:	4a17      	ldr	r2, [pc, #92]	@ (34184dc4 <PWR_TCPP0203_BUSConfigInit+0x150>)
34184d68:	687b      	ldr	r3, [r7, #4]
34184d6a:	f802 1013 	strb.w	r1, [r2, r3, lsl #1]

      /* Update Port Config */
      switch(tcpp_type)
34184d6e:	7afb      	ldrb	r3, [r7, #11]
34184d70:	2b00      	cmp	r3, #0
34184d72:	d007      	beq.n	34184d84 <PWR_TCPP0203_BUSConfigInit+0x110>
34184d74:	2b80      	cmp	r3, #128	@ 0x80
34184d76:	d10b      	bne.n	34184d90 <PWR_TCPP0203_BUSConfigInit+0x11c>
      {
        case TCPP0203_DEVICE_TYPE_02:
          USBPD_PWR_Port_Configs[PortNum].Type = USBPD_PWR_HW_CONFIG_TYPE_TCPP02;
34184d78:	4a12      	ldr	r2, [pc, #72]	@ (34184dc4 <PWR_TCPP0203_BUSConfigInit+0x150>)
34184d7a:	687b      	ldr	r3, [r7, #4]
34184d7c:	2102      	movs	r1, #2
34184d7e:	f802 1013 	strb.w	r1, [r2, r3, lsl #1]
          BSP_USBPD_PWR_TRACE(PortNum, "-- TCPP02 detected");
          break;
34184d82:	e009      	b.n	34184d98 <PWR_TCPP0203_BUSConfigInit+0x124>

        case TCPP0203_DEVICE_TYPE_03:
          USBPD_PWR_Port_Configs[PortNum].Type = USBPD_PWR_HW_CONFIG_TYPE_TCPP03;
34184d84:	4a0f      	ldr	r2, [pc, #60]	@ (34184dc4 <PWR_TCPP0203_BUSConfigInit+0x150>)
34184d86:	687b      	ldr	r3, [r7, #4]
34184d88:	2103      	movs	r1, #3
34184d8a:	f802 1013 	strb.w	r1, [r2, r3, lsl #1]
          BSP_USBPD_PWR_TRACE(PortNum, "-- TCPP03 detected");
          break;
34184d8e:	e003      	b.n	34184d98 <PWR_TCPP0203_BUSConfigInit+0x124>

        default:
          BSP_USBPD_PWR_TRACE(PortNum, "-- Unknown TCPP type");
          ret = BSP_ERROR_UNKNOWN_COMPONENT;
34184d90:	f06f 0306 	mvn.w	r3, #6
34184d94:	627b      	str	r3, [r7, #36]	@ 0x24
          break;
34184d96:	bf00      	nop
      }

      /* Registration completed */
    }
  }
  return ret;
34184d98:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
34184d9a:	4618      	mov	r0, r3
34184d9c:	372c      	adds	r7, #44	@ 0x2c
34184d9e:	46bd      	mov	sp, r7
34184da0:	bd90      	pop	{r4, r7, pc}
34184da2:	bf00      	nop
34184da4:	341838bd 	.word	0x341838bd
34184da8:	34183931 	.word	0x34183931
34184dac:	34183a59 	.word	0x34183a59
34184db0:	341839fd 	.word	0x341839fd
34184db4:	34183ab5 	.word	0x34183ab5
34184db8:	341c2cd8 	.word	0x341c2cd8
34184dbc:	341c2d00 	.word	0x341c2d00
34184dc0:	341c0018 	.word	0x341c0018
34184dc4:	341c0080 	.word	0x341c0080

34184dc8 <PWR_TCPP0203_EventCallback>:
  * @brief  Handle Event callback
  * @param  PortNum   Port number
  * @retval None
  */
static void PWR_TCPP0203_EventCallback(uint32_t PortNum)
{
34184dc8:	b590      	push	{r4, r7, lr}
34184dca:	b085      	sub	sp, #20
34184dcc:	af00      	add	r7, sp, #0
34184dce:	6078      	str	r0, [r7, #4]
  uint8_t flg_reg;

  /* In case of TCPP0203, this callback could be called when an event is detected
     on FLGn line */
  if (USBPD_PWR_Port_Status[PortNum].IsInitialized == 1U)
34184dd0:	497a      	ldr	r1, [pc, #488]	@ (34184fbc <PWR_TCPP0203_EventCallback+0x1f4>)
34184dd2:	687a      	ldr	r2, [r7, #4]
34184dd4:	4613      	mov	r3, r2
34184dd6:	005b      	lsls	r3, r3, #1
34184dd8:	4413      	add	r3, r2
34184dda:	009b      	lsls	r3, r3, #2
34184ddc:	440b      	add	r3, r1
34184dde:	781b      	ldrb	r3, [r3, #0]
34184de0:	2b01      	cmp	r3, #1
34184de2:	f040 80e6 	bne.w	34184fb2 <PWR_TCPP0203_EventCallback+0x1ea>
  {
    /* Read Flags register (FLGn) */
    if (USBPD_PWR_PortCompDrv[PortNum]->ReadFlagRegister(&USBPD_PWR_PortCompObj[PortNum], &flg_reg) == TCPP0203_OK)
34184de6:	4a76      	ldr	r2, [pc, #472]	@ (34184fc0 <PWR_TCPP0203_EventCallback+0x1f8>)
34184de8:	687b      	ldr	r3, [r7, #4]
34184dea:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
34184dee:	6e5c      	ldr	r4, [r3, #100]	@ 0x64
34184df0:	687a      	ldr	r2, [r7, #4]
34184df2:	4613      	mov	r3, r2
34184df4:	009b      	lsls	r3, r3, #2
34184df6:	4413      	add	r3, r2
34184df8:	00db      	lsls	r3, r3, #3
34184dfa:	4a72      	ldr	r2, [pc, #456]	@ (34184fc4 <PWR_TCPP0203_EventCallback+0x1fc>)
34184dfc:	4413      	add	r3, r2
34184dfe:	f107 020b 	add.w	r2, r7, #11
34184e02:	4611      	mov	r1, r2
34184e04:	4618      	mov	r0, r3
34184e06:	47a0      	blx	r4
34184e08:	4603      	mov	r3, r0
34184e0a:	2b00      	cmp	r3, #0
34184e0c:	f040 80d1 	bne.w	34184fb2 <PWR_TCPP0203_EventCallback+0x1ea>
#endif /* _TRACE */

      /* If FLGn has been set to 0 in LOW POWER or HIBERNATE mode,
         it is expected that a VBUS_OK condition is detected.
         In this case, if any, vBus Detection callback could be called */
      switch (USBPD_PWR_Port_Status[PortNum].PwrSavingMode)
34184e10:	496a      	ldr	r1, [pc, #424]	@ (34184fbc <PWR_TCPP0203_EventCallback+0x1f4>)
34184e12:	687a      	ldr	r2, [r7, #4]
34184e14:	4613      	mov	r3, r2
34184e16:	005b      	lsls	r3, r3, #1
34184e18:	4413      	add	r3, r2
34184e1a:	009b      	lsls	r3, r3, #2
34184e1c:	440b      	add	r3, r1
34184e1e:	3303      	adds	r3, #3
34184e20:	781b      	ldrb	r3, [r3, #0]
34184e22:	2b03      	cmp	r3, #3
34184e24:	d049      	beq.n	34184eba <PWR_TCPP0203_EventCallback+0xf2>
34184e26:	2b03      	cmp	r3, #3
34184e28:	f300 80bc 	bgt.w	34184fa4 <PWR_TCPP0203_EventCallback+0x1dc>
34184e2c:	2b01      	cmp	r3, #1
34184e2e:	d002      	beq.n	34184e36 <PWR_TCPP0203_EventCallback+0x6e>
34184e30:	2b02      	cmp	r3, #2
34184e32:	d023      	beq.n	34184e7c <PWR_TCPP0203_EventCallback+0xb4>

        default:
        {
          /* Unexpected port state */
          BSP_USBPD_PWR_TRACE(PortNum, "-- Unexpected State for FLGn event --");
          break;
34184e34:	e0b6      	b.n	34184fa4 <PWR_TCPP0203_EventCallback+0x1dc>
          if ((flg_reg & TCPP0203_FLAG_VBUS_OK_SET) == TCPP0203_FLAG_VBUS_OK_SET)
34184e36:	7afb      	ldrb	r3, [r7, #11]
34184e38:	f003 0320 	and.w	r3, r3, #32
34184e3c:	2b00      	cmp	r3, #0
34184e3e:	f000 80b3 	beq.w	34184fa8 <PWR_TCPP0203_EventCallback+0x1e0>
            if (USBPD_PWR_Port_Status[PortNum].VBUSDetectCallback != NULL)
34184e42:	495e      	ldr	r1, [pc, #376]	@ (34184fbc <PWR_TCPP0203_EventCallback+0x1f4>)
34184e44:	687a      	ldr	r2, [r7, #4]
34184e46:	4613      	mov	r3, r2
34184e48:	005b      	lsls	r3, r3, #1
34184e4a:	4413      	add	r3, r2
34184e4c:	009b      	lsls	r3, r3, #2
34184e4e:	440b      	add	r3, r1
34184e50:	3308      	adds	r3, #8
34184e52:	681b      	ldr	r3, [r3, #0]
34184e54:	2b00      	cmp	r3, #0
34184e56:	f000 80a7 	beq.w	34184fa8 <PWR_TCPP0203_EventCallback+0x1e0>
              (void)BSP_USBPD_PWR_SetPowerMode(PortNum, USBPD_PWR_MODE_LOWPOWER);
34184e5a:	2102      	movs	r1, #2
34184e5c:	6878      	ldr	r0, [r7, #4]
34184e5e:	f7ff fc0f 	bl	34184680 <BSP_USBPD_PWR_SetPowerMode>
              USBPD_PWR_Port_Status[PortNum].VBUSDetectCallback(PortNum, VBUS_CONNECTED);
34184e62:	4956      	ldr	r1, [pc, #344]	@ (34184fbc <PWR_TCPP0203_EventCallback+0x1f4>)
34184e64:	687a      	ldr	r2, [r7, #4]
34184e66:	4613      	mov	r3, r2
34184e68:	005b      	lsls	r3, r3, #1
34184e6a:	4413      	add	r3, r2
34184e6c:	009b      	lsls	r3, r3, #2
34184e6e:	440b      	add	r3, r1
34184e70:	3308      	adds	r3, #8
34184e72:	681b      	ldr	r3, [r3, #0]
34184e74:	2100      	movs	r1, #0
34184e76:	6878      	ldr	r0, [r7, #4]
34184e78:	4798      	blx	r3
          break;
34184e7a:	e095      	b.n	34184fa8 <PWR_TCPP0203_EventCallback+0x1e0>
          if ((flg_reg & TCPP0203_FLAG_VBUS_OK_SET) == TCPP0203_FLAG_VBUS_OK_SET)
34184e7c:	7afb      	ldrb	r3, [r7, #11]
34184e7e:	f003 0320 	and.w	r3, r3, #32
34184e82:	2b00      	cmp	r3, #0
34184e84:	f000 8092 	beq.w	34184fac <PWR_TCPP0203_EventCallback+0x1e4>
            if (USBPD_PWR_Port_Status[PortNum].VBUSDetectCallback != NULL)
34184e88:	494c      	ldr	r1, [pc, #304]	@ (34184fbc <PWR_TCPP0203_EventCallback+0x1f4>)
34184e8a:	687a      	ldr	r2, [r7, #4]
34184e8c:	4613      	mov	r3, r2
34184e8e:	005b      	lsls	r3, r3, #1
34184e90:	4413      	add	r3, r2
34184e92:	009b      	lsls	r3, r3, #2
34184e94:	440b      	add	r3, r1
34184e96:	3308      	adds	r3, #8
34184e98:	681b      	ldr	r3, [r3, #0]
34184e9a:	2b00      	cmp	r3, #0
34184e9c:	f000 8086 	beq.w	34184fac <PWR_TCPP0203_EventCallback+0x1e4>
              USBPD_PWR_Port_Status[PortNum].VBUSDetectCallback(PortNum, VBUS_CONNECTED);
34184ea0:	4946      	ldr	r1, [pc, #280]	@ (34184fbc <PWR_TCPP0203_EventCallback+0x1f4>)
34184ea2:	687a      	ldr	r2, [r7, #4]
34184ea4:	4613      	mov	r3, r2
34184ea6:	005b      	lsls	r3, r3, #1
34184ea8:	4413      	add	r3, r2
34184eaa:	009b      	lsls	r3, r3, #2
34184eac:	440b      	add	r3, r1
34184eae:	3308      	adds	r3, #8
34184eb0:	681b      	ldr	r3, [r3, #0]
34184eb2:	2100      	movs	r1, #0
34184eb4:	6878      	ldr	r0, [r7, #4]
34184eb6:	4798      	blx	r3
          break;
34184eb8:	e078      	b.n	34184fac <PWR_TCPP0203_EventCallback+0x1e4>
          uint32_t tickfault = HAL_GetTick();
34184eba:	f000 fb7d 	bl	341855b8 <HAL_GetTick>
34184ebe:	60f8      	str	r0, [r7, #12]
          if ((flg_reg & TCPP0203_FLAG_OCP_VBUS_SET) == TCPP0203_FLAG_OCP_VBUS_SET)
34184ec0:	7afb      	ldrb	r3, [r7, #11]
34184ec2:	f003 0302 	and.w	r3, r3, #2
34184ec6:	2b00      	cmp	r3, #0
34184ec8:	d072      	beq.n	34184fb0 <PWR_TCPP0203_EventCallback+0x1e8>
            if ((tickfault > USBPD_PWR_Port_Status[PortNum].LastFaultTick)
34184eca:	493c      	ldr	r1, [pc, #240]	@ (34184fbc <PWR_TCPP0203_EventCallback+0x1f4>)
34184ecc:	687a      	ldr	r2, [r7, #4]
34184ece:	4613      	mov	r3, r2
34184ed0:	005b      	lsls	r3, r3, #1
34184ed2:	4413      	add	r3, r2
34184ed4:	009b      	lsls	r3, r3, #2
34184ed6:	440b      	add	r3, r1
34184ed8:	3304      	adds	r3, #4
34184eda:	681b      	ldr	r3, [r3, #0]
34184edc:	68fa      	ldr	r2, [r7, #12]
34184ede:	429a      	cmp	r2, r3
34184ee0:	d955      	bls.n	34184f8e <PWR_TCPP0203_EventCallback+0x1c6>
                && ((tickfault - USBPD_PWR_Port_Status[PortNum].LastFaultTick) > USBPD_PWR_FAULT_MIN_TIME_RECOVERY))
34184ee2:	4936      	ldr	r1, [pc, #216]	@ (34184fbc <PWR_TCPP0203_EventCallback+0x1f4>)
34184ee4:	687a      	ldr	r2, [r7, #4]
34184ee6:	4613      	mov	r3, r2
34184ee8:	005b      	lsls	r3, r3, #1
34184eea:	4413      	add	r3, r2
34184eec:	009b      	lsls	r3, r3, #2
34184eee:	440b      	add	r3, r1
34184ef0:	3304      	adds	r3, #4
34184ef2:	681b      	ldr	r3, [r3, #0]
34184ef4:	68fa      	ldr	r2, [r7, #12]
34184ef6:	1ad3      	subs	r3, r2, r3
34184ef8:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
34184efc:	d947      	bls.n	34184f8e <PWR_TCPP0203_EventCallback+0x1c6>
              recoveryword = TCPP0203_GD_CONSUMER_SWITCH_OPEN | TCPP0203_POWER_MODE_NORMAL;
34184efe:	2318      	movs	r3, #24
34184f00:	72bb      	strb	r3, [r7, #10]
              (void)TCPP0203_WriteCtrlRegister(&USBPD_PWR_PortCompObj[PortNum], &recoveryword);
34184f02:	687a      	ldr	r2, [r7, #4]
34184f04:	4613      	mov	r3, r2
34184f06:	009b      	lsls	r3, r3, #2
34184f08:	4413      	add	r3, r2
34184f0a:	00db      	lsls	r3, r3, #3
34184f0c:	4a2d      	ldr	r2, [pc, #180]	@ (34184fc4 <PWR_TCPP0203_EventCallback+0x1fc>)
34184f0e:	4413      	add	r3, r2
34184f10:	f107 020a 	add.w	r2, r7, #10
34184f14:	4611      	mov	r1, r2
34184f16:	4618      	mov	r0, r3
34184f18:	f7fe fb98 	bl	3418364c <TCPP0203_WriteCtrlRegister>
              if (USBPD_PWR_Port_Status[PortNum].PwrRole == POWER_ROLE_SOURCE)
34184f1c:	4927      	ldr	r1, [pc, #156]	@ (34184fbc <PWR_TCPP0203_EventCallback+0x1f4>)
34184f1e:	687a      	ldr	r2, [r7, #4]
34184f20:	4613      	mov	r3, r2
34184f22:	005b      	lsls	r3, r3, #1
34184f24:	4413      	add	r3, r2
34184f26:	009b      	lsls	r3, r3, #2
34184f28:	440b      	add	r3, r1
34184f2a:	3302      	adds	r3, #2
34184f2c:	781b      	ldrb	r3, [r3, #0]
34184f2e:	2b00      	cmp	r3, #0
34184f30:	d116      	bne.n	34184f60 <PWR_TCPP0203_EventCallback+0x198>
                (void)TCPP0203_SetPowerMode(&USBPD_PWR_PortCompObj[PortNum], TCPP0203_POWER_MODE_NORMAL);
34184f32:	687a      	ldr	r2, [r7, #4]
34184f34:	4613      	mov	r3, r2
34184f36:	009b      	lsls	r3, r3, #2
34184f38:	4413      	add	r3, r2
34184f3a:	00db      	lsls	r3, r3, #3
34184f3c:	4a21      	ldr	r2, [pc, #132]	@ (34184fc4 <PWR_TCPP0203_EventCallback+0x1fc>)
34184f3e:	4413      	add	r3, r2
34184f40:	2110      	movs	r1, #16
34184f42:	4618      	mov	r0, r3
34184f44:	f7fe f9a6 	bl	34183294 <TCPP0203_SetPowerMode>
                (void)TCPP0203_SetGateDriverProvider(&USBPD_PWR_PortCompObj[PortNum],
34184f48:	687a      	ldr	r2, [r7, #4]
34184f4a:	4613      	mov	r3, r2
34184f4c:	009b      	lsls	r3, r3, #2
34184f4e:	4413      	add	r3, r2
34184f50:	00db      	lsls	r3, r3, #3
34184f52:	4a1c      	ldr	r2, [pc, #112]	@ (34184fc4 <PWR_TCPP0203_EventCallback+0x1fc>)
34184f54:	4413      	add	r3, r2
34184f56:	2104      	movs	r1, #4
34184f58:	4618      	mov	r0, r3
34184f5a:	f7fe f930 	bl	341831be <TCPP0203_SetGateDriverProvider>
34184f5e:	e016      	b.n	34184f8e <PWR_TCPP0203_EventCallback+0x1c6>
                if (USBPD_PWR_Port_Status[PortNum].VBUSDetectCallback != NULL)
34184f60:	4916      	ldr	r1, [pc, #88]	@ (34184fbc <PWR_TCPP0203_EventCallback+0x1f4>)
34184f62:	687a      	ldr	r2, [r7, #4]
34184f64:	4613      	mov	r3, r2
34184f66:	005b      	lsls	r3, r3, #1
34184f68:	4413      	add	r3, r2
34184f6a:	009b      	lsls	r3, r3, #2
34184f6c:	440b      	add	r3, r1
34184f6e:	3308      	adds	r3, #8
34184f70:	681b      	ldr	r3, [r3, #0]
34184f72:	2b00      	cmp	r3, #0
34184f74:	d00b      	beq.n	34184f8e <PWR_TCPP0203_EventCallback+0x1c6>
                  USBPD_PWR_Port_Status[PortNum].VBUSDetectCallback(PortNum, VBUS_NOT_CONNECTED);
34184f76:	4911      	ldr	r1, [pc, #68]	@ (34184fbc <PWR_TCPP0203_EventCallback+0x1f4>)
34184f78:	687a      	ldr	r2, [r7, #4]
34184f7a:	4613      	mov	r3, r2
34184f7c:	005b      	lsls	r3, r3, #1
34184f7e:	4413      	add	r3, r2
34184f80:	009b      	lsls	r3, r3, #2
34184f82:	440b      	add	r3, r1
34184f84:	3308      	adds	r3, #8
34184f86:	681b      	ldr	r3, [r3, #0]
34184f88:	2101      	movs	r1, #1
34184f8a:	6878      	ldr	r0, [r7, #4]
34184f8c:	4798      	blx	r3
            USBPD_PWR_Port_Status[PortNum].LastFaultTick = tickfault;
34184f8e:	490b      	ldr	r1, [pc, #44]	@ (34184fbc <PWR_TCPP0203_EventCallback+0x1f4>)
34184f90:	687a      	ldr	r2, [r7, #4]
34184f92:	4613      	mov	r3, r2
34184f94:	005b      	lsls	r3, r3, #1
34184f96:	4413      	add	r3, r2
34184f98:	009b      	lsls	r3, r3, #2
34184f9a:	440b      	add	r3, r1
34184f9c:	3304      	adds	r3, #4
34184f9e:	68fa      	ldr	r2, [r7, #12]
34184fa0:	601a      	str	r2, [r3, #0]
          break;
34184fa2:	e005      	b.n	34184fb0 <PWR_TCPP0203_EventCallback+0x1e8>
          break;
34184fa4:	bf00      	nop
34184fa6:	e004      	b.n	34184fb2 <PWR_TCPP0203_EventCallback+0x1ea>
          break;
34184fa8:	bf00      	nop
34184faa:	e002      	b.n	34184fb2 <PWR_TCPP0203_EventCallback+0x1ea>
          break;
34184fac:	bf00      	nop
34184fae:	e000      	b.n	34184fb2 <PWR_TCPP0203_EventCallback+0x1ea>
          break;
34184fb0:	bf00      	nop
        }
      }
    }
  }
}
34184fb2:	bf00      	nop
34184fb4:	3714      	adds	r7, #20
34184fb6:	46bd      	mov	sp, r7
34184fb8:	bd90      	pop	{r4, r7, pc}
34184fba:	bf00      	nop
34184fbc:	341c0084 	.word	0x341c0084
34184fc0:	341c2d00 	.word	0x341c2d00
34184fc4:	341c2cd8 	.word	0x341c2cd8

34184fc8 <PWR_TCPP0203_ConvertADCDataToVoltage>:
  * @param  Ra       value of Ra resistance
  * @param  Rb       value of Rb resistance
  * @retval analog voltage (unit: mV)
  */
static uint32_t PWR_TCPP0203_ConvertADCDataToVoltage(uint32_t ADCData, uint32_t Ra, uint32_t Rb)
{
34184fc8:	b480      	push	{r7}
34184fca:	b087      	sub	sp, #28
34184fcc:	af00      	add	r7, sp, #0
34184fce:	60f8      	str	r0, [r7, #12]
34184fd0:	60b9      	str	r1, [r7, #8]
34184fd2:	607a      	str	r2, [r7, #4]
  uint32_t voltage;
  uint32_t vadc;

  voltage = 0U;
34184fd4:	2300      	movs	r3, #0
34184fd6:	617b      	str	r3, [r7, #20]

  /* Avoid dividing by zero */
  if (IS_PWR_TCPP0203_NOT_ZERO(Rb))
34184fd8:	687b      	ldr	r3, [r7, #4]
34184fda:	2b00      	cmp	r3, #0
34184fdc:	d016      	beq.n	3418500c <PWR_TCPP0203_ConvertADCDataToVoltage+0x44>
  {
    vadc = (ADCData * VDD_VALUE) / ADC_FULL_SCALE;
34184fde:	68fb      	ldr	r3, [r7, #12]
34184fe0:	f640 42e4 	movw	r2, #3300	@ 0xce4
34184fe4:	fb03 f202 	mul.w	r2, r3, r2
34184fe8:	4b0c      	ldr	r3, [pc, #48]	@ (3418501c <PWR_TCPP0203_ConvertADCDataToVoltage+0x54>)
34184fea:	fba3 1302 	umull	r1, r3, r3, r2
34184fee:	1ad2      	subs	r2, r2, r3
34184ff0:	0852      	lsrs	r2, r2, #1
34184ff2:	4413      	add	r3, r2
34184ff4:	0adb      	lsrs	r3, r3, #11
34184ff6:	613b      	str	r3, [r7, #16]
    voltage = vadc * (Ra + Rb) / Rb;
34184ff8:	68ba      	ldr	r2, [r7, #8]
34184ffa:	687b      	ldr	r3, [r7, #4]
34184ffc:	4413      	add	r3, r2
34184ffe:	693a      	ldr	r2, [r7, #16]
34185000:	fb03 f202 	mul.w	r2, r3, r2
34185004:	687b      	ldr	r3, [r7, #4]
34185006:	fbb2 f3f3 	udiv	r3, r2, r3
3418500a:	617b      	str	r3, [r7, #20]
  }

  return voltage;
3418500c:	697b      	ldr	r3, [r7, #20]
}
3418500e:	4618      	mov	r0, r3
34185010:	371c      	adds	r7, #28
34185012:	46bd      	mov	sp, r7
34185014:	f85d 7b04 	ldr.w	r7, [sp], #4
34185018:	4770      	bx	lr
3418501a:	bf00      	nop
3418501c:	00100101 	.word	0x00100101

34185020 <SystemInit>:
  * @brief  Setup the microcontroller system.
  * @retval None
  */

void SystemInit(void)
{
34185020:	b480      	push	{r7}
34185022:	af00      	add	r7, sp, #0

  /* Configure the Vector Table location -------------------------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET;
#else
  SCB->VTOR = INTVECT_START;
34185024:	4b6a      	ldr	r3, [pc, #424]	@ (341851d0 <SystemInit+0x1b0>)
34185026:	4a6b      	ldr	r2, [pc, #428]	@ (341851d4 <SystemInit+0x1b4>)
34185028:	609a      	str	r2, [r3, #8]
#endif  /* USER_VECT_TAB_ADDRESS */

  /* RNG reset */
  RCC->AHB3RSTSR = RCC_AHB3RSTSR_RNGRSTS;
3418502a:	4b6b      	ldr	r3, [pc, #428]	@ (341851d8 <SystemInit+0x1b8>)
3418502c:	2201      	movs	r2, #1
3418502e:	f8c3 2a18 	str.w	r2, [r3, #2584]	@ 0xa18
  RCC->AHB3RSTCR = RCC_AHB3RSTCR_RNGRSTC;
34185032:	4b69      	ldr	r3, [pc, #420]	@ (341851d8 <SystemInit+0x1b8>)
34185034:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34185038:	461a      	mov	r2, r3
3418503a:	2301      	movs	r3, #1
3418503c:	f8c2 3218 	str.w	r3, [r2, #536]	@ 0x218
  /* Deactivate RNG clock */
  RCC->AHB3ENCR = RCC_AHB3ENCR_RNGENC;
34185040:	4b65      	ldr	r3, [pc, #404]	@ (341851d8 <SystemInit+0x1b8>)
34185042:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34185046:	461a      	mov	r2, r3
34185048:	2301      	movs	r3, #1
3418504a:	f8c2 3258 	str.w	r3, [r2, #600]	@ 0x258

  /* Clear SAU regions */
  SAU->RNR = 0;
3418504e:	4b63      	ldr	r3, [pc, #396]	@ (341851dc <SystemInit+0x1bc>)
34185050:	2200      	movs	r2, #0
34185052:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
34185054:	4b61      	ldr	r3, [pc, #388]	@ (341851dc <SystemInit+0x1bc>)
34185056:	2200      	movs	r2, #0
34185058:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
3418505a:	4b60      	ldr	r3, [pc, #384]	@ (341851dc <SystemInit+0x1bc>)
3418505c:	2200      	movs	r2, #0
3418505e:	611a      	str	r2, [r3, #16]
  SAU->RNR = 1;
34185060:	4b5e      	ldr	r3, [pc, #376]	@ (341851dc <SystemInit+0x1bc>)
34185062:	2201      	movs	r2, #1
34185064:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
34185066:	4b5d      	ldr	r3, [pc, #372]	@ (341851dc <SystemInit+0x1bc>)
34185068:	2200      	movs	r2, #0
3418506a:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
3418506c:	4b5b      	ldr	r3, [pc, #364]	@ (341851dc <SystemInit+0x1bc>)
3418506e:	2200      	movs	r2, #0
34185070:	611a      	str	r2, [r3, #16]
  SAU->RNR = 2;
34185072:	4b5a      	ldr	r3, [pc, #360]	@ (341851dc <SystemInit+0x1bc>)
34185074:	2202      	movs	r2, #2
34185076:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
34185078:	4b58      	ldr	r3, [pc, #352]	@ (341851dc <SystemInit+0x1bc>)
3418507a:	2200      	movs	r2, #0
3418507c:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
3418507e:	4b57      	ldr	r3, [pc, #348]	@ (341851dc <SystemInit+0x1bc>)
34185080:	2200      	movs	r2, #0
34185082:	611a      	str	r2, [r3, #16]
  SAU->RNR = 3;
34185084:	4b55      	ldr	r3, [pc, #340]	@ (341851dc <SystemInit+0x1bc>)
34185086:	2203      	movs	r2, #3
34185088:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
3418508a:	4b54      	ldr	r3, [pc, #336]	@ (341851dc <SystemInit+0x1bc>)
3418508c:	2200      	movs	r2, #0
3418508e:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
34185090:	4b52      	ldr	r3, [pc, #328]	@ (341851dc <SystemInit+0x1bc>)
34185092:	2200      	movs	r2, #0
34185094:	611a      	str	r2, [r3, #16]
  SAU->RNR = 4;
34185096:	4b51      	ldr	r3, [pc, #324]	@ (341851dc <SystemInit+0x1bc>)
34185098:	2204      	movs	r2, #4
3418509a:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
3418509c:	4b4f      	ldr	r3, [pc, #316]	@ (341851dc <SystemInit+0x1bc>)
3418509e:	2200      	movs	r2, #0
341850a0:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
341850a2:	4b4e      	ldr	r3, [pc, #312]	@ (341851dc <SystemInit+0x1bc>)
341850a4:	2200      	movs	r2, #0
341850a6:	611a      	str	r2, [r3, #16]
  SAU->RNR = 5;
341850a8:	4b4c      	ldr	r3, [pc, #304]	@ (341851dc <SystemInit+0x1bc>)
341850aa:	2205      	movs	r2, #5
341850ac:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
341850ae:	4b4b      	ldr	r3, [pc, #300]	@ (341851dc <SystemInit+0x1bc>)
341850b0:	2200      	movs	r2, #0
341850b2:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
341850b4:	4b49      	ldr	r3, [pc, #292]	@ (341851dc <SystemInit+0x1bc>)
341850b6:	2200      	movs	r2, #0
341850b8:	611a      	str	r2, [r3, #16]
  SAU->RNR = 6;
341850ba:	4b48      	ldr	r3, [pc, #288]	@ (341851dc <SystemInit+0x1bc>)
341850bc:	2206      	movs	r2, #6
341850be:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
341850c0:	4b46      	ldr	r3, [pc, #280]	@ (341851dc <SystemInit+0x1bc>)
341850c2:	2200      	movs	r2, #0
341850c4:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
341850c6:	4b45      	ldr	r3, [pc, #276]	@ (341851dc <SystemInit+0x1bc>)
341850c8:	2200      	movs	r2, #0
341850ca:	611a      	str	r2, [r3, #16]
  SAU->RNR = 7;
341850cc:	4b43      	ldr	r3, [pc, #268]	@ (341851dc <SystemInit+0x1bc>)
341850ce:	2207      	movs	r2, #7
341850d0:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
341850d2:	4b42      	ldr	r3, [pc, #264]	@ (341851dc <SystemInit+0x1bc>)
341850d4:	2200      	movs	r2, #0
341850d6:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
341850d8:	4b40      	ldr	r3, [pc, #256]	@ (341851dc <SystemInit+0x1bc>)
341850da:	2200      	movs	r2, #0
341850dc:	611a      	str	r2, [r3, #16]

  /* System configuration setup */
  RCC->APB4ENSR2 = RCC_APB4ENSR2_SYSCFGENS;
341850de:	4b3e      	ldr	r3, [pc, #248]	@ (341851d8 <SystemInit+0x1b8>)
341850e0:	2201      	movs	r2, #1
341850e2:	f8c3 2a78 	str.w	r2, [r3, #2680]	@ 0xa78
  /* Delay after an RCC peripheral clock enabling */
  (void)RCC->APB4ENR2;
341850e6:	4b3c      	ldr	r3, [pc, #240]	@ (341851d8 <SystemInit+0x1b8>)
341850e8:	f8d3 3278 	ldr.w	r3, [r3, #632]	@ 0x278

  /* Set default Vector Table location after system reset or return from Standby */
  SYSCFG->INITSVTORCR = SCB->VTOR;
341850ec:	4b38      	ldr	r3, [pc, #224]	@ (341851d0 <SystemInit+0x1b0>)
341850ee:	4a3c      	ldr	r2, [pc, #240]	@ (341851e0 <SystemInit+0x1c0>)
341850f0:	689b      	ldr	r3, [r3, #8]
341850f2:	6113      	str	r3, [r2, #16]

  /* Enable VDDADC CLAMP */
  PWR->SVMCR3 |= PWR_SVMCR3_ASV;
341850f4:	4b3b      	ldr	r3, [pc, #236]	@ (341851e4 <SystemInit+0x1c4>)
341850f6:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
341850f8:	4a3a      	ldr	r2, [pc, #232]	@ (341851e4 <SystemInit+0x1c4>)
341850fa:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
341850fe:	63d3      	str	r3, [r2, #60]	@ 0x3c
  PWR->SVMCR3 |= PWR_SVMCR3_AVMEN;
34185100:	4b38      	ldr	r3, [pc, #224]	@ (341851e4 <SystemInit+0x1c4>)
34185102:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34185104:	4a37      	ldr	r2, [pc, #220]	@ (341851e4 <SystemInit+0x1c4>)
34185106:	f043 0310 	orr.w	r3, r3, #16
3418510a:	63d3      	str	r3, [r2, #60]	@ 0x3c
  /* read back the register to make sure that the transaction has taken place */
  (void) PWR->SVMCR3;
3418510c:	4b35      	ldr	r3, [pc, #212]	@ (341851e4 <SystemInit+0x1c4>)
3418510e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
  /* enable VREF */
  RCC->APB4ENR1 |= RCC_APB4ENR1_VREFBUFEN;
34185110:	4b31      	ldr	r3, [pc, #196]	@ (341851d8 <SystemInit+0x1b8>)
34185112:	f8d3 3274 	ldr.w	r3, [r3, #628]	@ 0x274
34185116:	4a30      	ldr	r2, [pc, #192]	@ (341851d8 <SystemInit+0x1b8>)
34185118:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
3418511c:	f8c2 3274 	str.w	r3, [r2, #628]	@ 0x274

  /* RCC Fix to lower power consumption */
  RCC->APB4ENR2 |= 0x00000010UL;
34185120:	4b2d      	ldr	r3, [pc, #180]	@ (341851d8 <SystemInit+0x1b8>)
34185122:	f8d3 3278 	ldr.w	r3, [r3, #632]	@ 0x278
34185126:	4a2c      	ldr	r2, [pc, #176]	@ (341851d8 <SystemInit+0x1b8>)
34185128:	f043 0310 	orr.w	r3, r3, #16
3418512c:	f8c2 3278 	str.w	r3, [r2, #632]	@ 0x278
  (void) RCC->APB4ENR2;
34185130:	4b29      	ldr	r3, [pc, #164]	@ (341851d8 <SystemInit+0x1b8>)
34185132:	f8d3 3278 	ldr.w	r3, [r3, #632]	@ 0x278
  RCC->APB4ENR2 &= ~(0x00000010UL);
34185136:	4b28      	ldr	r3, [pc, #160]	@ (341851d8 <SystemInit+0x1b8>)
34185138:	f8d3 3278 	ldr.w	r3, [r3, #632]	@ 0x278
3418513c:	4a26      	ldr	r2, [pc, #152]	@ (341851d8 <SystemInit+0x1b8>)
3418513e:	f023 0310 	bic.w	r3, r3, #16
34185142:	f8c2 3278 	str.w	r3, [r2, #632]	@ 0x278

  /* XSPI2 & XSPIM reset                                  */
  RCC->AHB5RSTSR = RCC_AHB5RSTSR_XSPIMRSTS | RCC_AHB5RSTSR_XSPI2RSTS;
34185146:	4b24      	ldr	r3, [pc, #144]	@ (341851d8 <SystemInit+0x1b8>)
34185148:	f44f 5240 	mov.w	r2, #12288	@ 0x3000
3418514c:	f8c3 2a20 	str.w	r2, [r3, #2592]	@ 0xa20
  RCC->AHB5RSTCR = RCC_AHB5RSTCR_XSPIMRSTC | RCC_AHB5RSTCR_XSPI2RSTC;
34185150:	4b21      	ldr	r3, [pc, #132]	@ (341851d8 <SystemInit+0x1b8>)
34185152:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34185156:	461a      	mov	r2, r3
34185158:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
3418515c:	f8c2 3220 	str.w	r3, [r2, #544]	@ 0x220

  /* TIM2 reset */
  RCC->APB1RSTSR1 = RCC_APB1RSTSR1_TIM2RSTS;
34185160:	4b1d      	ldr	r3, [pc, #116]	@ (341851d8 <SystemInit+0x1b8>)
34185162:	2201      	movs	r2, #1
34185164:	f8c3 2a24 	str.w	r2, [r3, #2596]	@ 0xa24
  RCC->APB1RSTCR1 = RCC_APB1RSTCR1_TIM2RSTC;
34185168:	4b1b      	ldr	r3, [pc, #108]	@ (341851d8 <SystemInit+0x1b8>)
3418516a:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3418516e:	461a      	mov	r2, r3
34185170:	2301      	movs	r3, #1
34185172:	f8c2 3224 	str.w	r3, [r2, #548]	@ 0x224
  /* Deactivate TIM2 clock */
  RCC->APB1ENCR1 = RCC_APB1ENCR1_TIM2ENC;
34185176:	4b18      	ldr	r3, [pc, #96]	@ (341851d8 <SystemInit+0x1b8>)
34185178:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3418517c:	461a      	mov	r2, r3
3418517e:	2301      	movs	r3, #1
34185180:	f8c2 3264 	str.w	r3, [r2, #612]	@ 0x264

  /* Deactivate GPIOG clock */
  RCC->AHB4ENCR = RCC_AHB4ENCR_GPIOGENC;
34185184:	4b14      	ldr	r3, [pc, #80]	@ (341851d8 <SystemInit+0x1b8>)
34185186:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3418518a:	461a      	mov	r2, r3
3418518c:	2340      	movs	r3, #64	@ 0x40
3418518e:	f8c2 325c 	str.w	r3, [r2, #604]	@ 0x25c

  /* Read back the value to make sure it is written before deactivating SYSCFG */
  (void) SYSCFG->INITSVTORCR;
34185192:	4b13      	ldr	r3, [pc, #76]	@ (341851e0 <SystemInit+0x1c0>)
34185194:	691b      	ldr	r3, [r3, #16]
  /* Deactivate SYSCFG clock */
  RCC->APB4ENCR2 = RCC_APB4ENCR2_SYSCFGENC;
34185196:	4b10      	ldr	r3, [pc, #64]	@ (341851d8 <SystemInit+0x1b8>)
34185198:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3418519c:	461a      	mov	r2, r3
3418519e:	2301      	movs	r3, #1
341851a0:	f8c2 3278 	str.w	r3, [r2, #632]	@ 0x278
  TZ_SAU_Setup();
#endif /* USER_TZ_SAU_SETUP */

  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
341851a4:	4b0a      	ldr	r3, [pc, #40]	@ (341851d0 <SystemInit+0x1b0>)
341851a6:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
341851aa:	4a09      	ldr	r2, [pc, #36]	@ (341851d0 <SystemInit+0x1b0>)
341851ac:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
341851b0:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88

  SCB_NS->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
341851b4:	4b0c      	ldr	r3, [pc, #48]	@ (341851e8 <SystemInit+0x1c8>)
341851b6:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
341851ba:	4a0b      	ldr	r2, [pc, #44]	@ (341851e8 <SystemInit+0x1c8>)
341851bc:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
341851c0:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88
#endif /* __FPU_PRESENT && __FPU_USED */

}
341851c4:	bf00      	nop
341851c6:	46bd      	mov	sp, r7
341851c8:	f85d 7b04 	ldr.w	r7, [sp], #4
341851cc:	4770      	bx	lr
341851ce:	bf00      	nop
341851d0:	e000ed00 	.word	0xe000ed00
341851d4:	34180400 	.word	0x34180400
341851d8:	56028000 	.word	0x56028000
341851dc:	e000edd0 	.word	0xe000edd0
341851e0:	56008000 	.word	0x56008000
341851e4:	56024800 	.word	0x56024800
341851e8:	e002ed00 	.word	0xe002ed00

341851ec <SystemCoreClockUpdate>:
  *           value for HSE crystal.
  *
  * @retval None
  */
void SystemCoreClockUpdate(void)
{
341851ec:	b480      	push	{r7}
341851ee:	b08d      	sub	sp, #52	@ 0x34
341851f0:	af00      	add	r7, sp, #0
  uint32_t sysclk = 0;
341851f2:	2300      	movs	r3, #0
341851f4:	62fb      	str	r3, [r7, #44]	@ 0x2c
  uint32_t pllm = 0;
341851f6:	2300      	movs	r3, #0
341851f8:	62bb      	str	r3, [r7, #40]	@ 0x28
  uint32_t plln = 0;
341851fa:	2300      	movs	r3, #0
341851fc:	627b      	str	r3, [r7, #36]	@ 0x24
  uint32_t pllfracn = 0;
341851fe:	2300      	movs	r3, #0
34185200:	623b      	str	r3, [r7, #32]
  uint32_t pllp1 = 0;
34185202:	2300      	movs	r3, #0
34185204:	61fb      	str	r3, [r7, #28]
  uint32_t pllp2 = 0;
34185206:	2300      	movs	r3, #0
34185208:	61bb      	str	r3, [r7, #24]
  uint32_t pllcfgr, pllsource, pllbypass, ic_divider;
  float_t pllvco;

  /* Get CPUCLK source -------------------------------------------------------*/
  switch (RCC->CFGR1 & RCC_CFGR1_CPUSWS)
3418520a:	4b9b      	ldr	r3, [pc, #620]	@ (34185478 <SystemCoreClockUpdate+0x28c>)
3418520c:	6a1b      	ldr	r3, [r3, #32]
3418520e:	f403 1340 	and.w	r3, r3, #3145728	@ 0x300000
34185212:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
34185216:	d029      	beq.n	3418526c <SystemCoreClockUpdate+0x80>
34185218:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
3418521c:	f200 8180 	bhi.w	34185520 <SystemCoreClockUpdate+0x334>
34185220:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
34185224:	d01f      	beq.n	34185266 <SystemCoreClockUpdate+0x7a>
34185226:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
3418522a:	f200 8179 	bhi.w	34185520 <SystemCoreClockUpdate+0x334>
3418522e:	2b00      	cmp	r3, #0
34185230:	d003      	beq.n	3418523a <SystemCoreClockUpdate+0x4e>
34185232:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
34185236:	d00a      	beq.n	3418524e <SystemCoreClockUpdate+0x62>
    ic_divider = (READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1UL;
    sysclk = sysclk / ic_divider;
    break;
  default:
    /* Nothing to do, should not occur */
    break;
34185238:	e172      	b.n	34185520 <SystemCoreClockUpdate+0x334>
    sysclk = HSI_VALUE >> ((RCC->HSICFGR & RCC_HSICFGR_HSIDIV) >> RCC_HSICFGR_HSIDIV_Pos);
3418523a:	4b8f      	ldr	r3, [pc, #572]	@ (34185478 <SystemCoreClockUpdate+0x28c>)
3418523c:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3418523e:	09db      	lsrs	r3, r3, #7
34185240:	f003 0303 	and.w	r3, r3, #3
34185244:	4a8d      	ldr	r2, [pc, #564]	@ (3418547c <SystemCoreClockUpdate+0x290>)
34185246:	fa22 f303 	lsr.w	r3, r2, r3
3418524a:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
3418524c:	e169      	b.n	34185522 <SystemCoreClockUpdate+0x336>
    if (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL) == 0UL)
3418524e:	4b8a      	ldr	r3, [pc, #552]	@ (34185478 <SystemCoreClockUpdate+0x28c>)
34185250:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34185252:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34185256:	2b00      	cmp	r3, #0
34185258:	d102      	bne.n	34185260 <SystemCoreClockUpdate+0x74>
      sysclk = MSI_VALUE;
3418525a:	4b89      	ldr	r3, [pc, #548]	@ (34185480 <SystemCoreClockUpdate+0x294>)
3418525c:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
3418525e:	e160      	b.n	34185522 <SystemCoreClockUpdate+0x336>
      sysclk = 16000000UL;
34185260:	4b88      	ldr	r3, [pc, #544]	@ (34185484 <SystemCoreClockUpdate+0x298>)
34185262:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
34185264:	e15d      	b.n	34185522 <SystemCoreClockUpdate+0x336>
    sysclk = HSE_VALUE;
34185266:	4b88      	ldr	r3, [pc, #544]	@ (34185488 <SystemCoreClockUpdate+0x29c>)
34185268:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
3418526a:	e15a      	b.n	34185522 <SystemCoreClockUpdate+0x336>
    switch (READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL))
3418526c:	4b82      	ldr	r3, [pc, #520]	@ (34185478 <SystemCoreClockUpdate+0x28c>)
3418526e:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
34185272:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
34185276:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418527a:	d066      	beq.n	3418534a <SystemCoreClockUpdate+0x15e>
3418527c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34185280:	f200 8091 	bhi.w	341853a6 <SystemCoreClockUpdate+0x1ba>
34185284:	2b00      	cmp	r3, #0
34185286:	d003      	beq.n	34185290 <SystemCoreClockUpdate+0xa4>
34185288:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3418528c:	d02f      	beq.n	341852ee <SystemCoreClockUpdate+0x102>
3418528e:	e08a      	b.n	341853a6 <SystemCoreClockUpdate+0x1ba>
      pllcfgr = READ_REG(RCC->PLL1CFGR1);
34185290:	4b79      	ldr	r3, [pc, #484]	@ (34185478 <SystemCoreClockUpdate+0x28c>)
34185292:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34185296:	60fb      	str	r3, [r7, #12]
      pllsource = pllcfgr & RCC_PLL1CFGR1_PLL1SEL;
34185298:	68fb      	ldr	r3, [r7, #12]
3418529a:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
3418529e:	617b      	str	r3, [r7, #20]
      pllbypass = pllcfgr & RCC_PLL1CFGR1_PLL1BYP;
341852a0:	68fb      	ldr	r3, [r7, #12]
341852a2:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
341852a6:	613b      	str	r3, [r7, #16]
      if (pllbypass == 0U)
341852a8:	693b      	ldr	r3, [r7, #16]
341852aa:	2b00      	cmp	r3, #0
341852ac:	f040 80a9 	bne.w	34185402 <SystemCoreClockUpdate+0x216>
        pllm = (pllcfgr & RCC_PLL1CFGR1_PLL1DIVM) >>  RCC_PLL1CFGR1_PLL1DIVM_Pos;
341852b0:	68fb      	ldr	r3, [r7, #12]
341852b2:	0d1b      	lsrs	r3, r3, #20
341852b4:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
341852b8:	62bb      	str	r3, [r7, #40]	@ 0x28
        plln = (pllcfgr & RCC_PLL1CFGR1_PLL1DIVN) >>  RCC_PLL1CFGR1_PLL1DIVN_Pos;
341852ba:	68fb      	ldr	r3, [r7, #12]
341852bc:	0a1b      	lsrs	r3, r3, #8
341852be:	f3c3 030b 	ubfx	r3, r3, #0, #12
341852c2:	627b      	str	r3, [r7, #36]	@ 0x24
        pllfracn = READ_BIT(RCC->PLL1CFGR2, RCC_PLL1CFGR2_PLL1DIVNFRAC) >>  RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos;
341852c4:	4b6c      	ldr	r3, [pc, #432]	@ (34185478 <SystemCoreClockUpdate+0x28c>)
341852c6:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
341852ca:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
341852ce:	623b      	str	r3, [r7, #32]
        pllcfgr = READ_REG(RCC->PLL1CFGR3);
341852d0:	4b69      	ldr	r3, [pc, #420]	@ (34185478 <SystemCoreClockUpdate+0x28c>)
341852d2:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
341852d6:	60fb      	str	r3, [r7, #12]
        pllp1 = (pllcfgr & RCC_PLL1CFGR3_PLL1PDIV1) >>  RCC_PLL1CFGR3_PLL1PDIV1_Pos;
341852d8:	68fb      	ldr	r3, [r7, #12]
341852da:	0edb      	lsrs	r3, r3, #27
341852dc:	f003 0307 	and.w	r3, r3, #7
341852e0:	61fb      	str	r3, [r7, #28]
        pllp2 = (pllcfgr & RCC_PLL1CFGR3_PLL1PDIV2) >>  RCC_PLL1CFGR3_PLL1PDIV2_Pos;
341852e2:	68fb      	ldr	r3, [r7, #12]
341852e4:	0e1b      	lsrs	r3, r3, #24
341852e6:	f003 0307 	and.w	r3, r3, #7
341852ea:	61bb      	str	r3, [r7, #24]
      break;
341852ec:	e089      	b.n	34185402 <SystemCoreClockUpdate+0x216>
      pllcfgr = READ_REG(RCC->PLL2CFGR1);
341852ee:	4b62      	ldr	r3, [pc, #392]	@ (34185478 <SystemCoreClockUpdate+0x28c>)
341852f0:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
341852f4:	60fb      	str	r3, [r7, #12]
      pllsource = pllcfgr & RCC_PLL2CFGR1_PLL2SEL;
341852f6:	68fb      	ldr	r3, [r7, #12]
341852f8:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
341852fc:	617b      	str	r3, [r7, #20]
      pllbypass = pllcfgr & RCC_PLL2CFGR1_PLL2BYP;
341852fe:	68fb      	ldr	r3, [r7, #12]
34185300:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34185304:	613b      	str	r3, [r7, #16]
      if (pllbypass == 0U)
34185306:	693b      	ldr	r3, [r7, #16]
34185308:	2b00      	cmp	r3, #0
3418530a:	d17c      	bne.n	34185406 <SystemCoreClockUpdate+0x21a>
        pllm = (pllcfgr & RCC_PLL2CFGR1_PLL2DIVM) >>  RCC_PLL2CFGR1_PLL2DIVM_Pos;
3418530c:	68fb      	ldr	r3, [r7, #12]
3418530e:	0d1b      	lsrs	r3, r3, #20
34185310:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
34185314:	62bb      	str	r3, [r7, #40]	@ 0x28
        plln = (pllcfgr & RCC_PLL2CFGR1_PLL2DIVN) >>  RCC_PLL2CFGR1_PLL2DIVN_Pos;
34185316:	68fb      	ldr	r3, [r7, #12]
34185318:	0a1b      	lsrs	r3, r3, #8
3418531a:	f3c3 030b 	ubfx	r3, r3, #0, #12
3418531e:	627b      	str	r3, [r7, #36]	@ 0x24
        pllfracn = READ_BIT(RCC->PLL2CFGR2, RCC_PLL2CFGR2_PLL2DIVNFRAC) >>  RCC_PLL2CFGR2_PLL2DIVNFRAC_Pos;
34185320:	4b55      	ldr	r3, [pc, #340]	@ (34185478 <SystemCoreClockUpdate+0x28c>)
34185322:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
34185326:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
3418532a:	623b      	str	r3, [r7, #32]
        pllcfgr = READ_REG(RCC->PLL2CFGR3);
3418532c:	4b52      	ldr	r3, [pc, #328]	@ (34185478 <SystemCoreClockUpdate+0x28c>)
3418532e:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
34185332:	60fb      	str	r3, [r7, #12]
        pllp1 = (pllcfgr & RCC_PLL2CFGR3_PLL2PDIV1) >>  RCC_PLL2CFGR3_PLL2PDIV1_Pos;
34185334:	68fb      	ldr	r3, [r7, #12]
34185336:	0edb      	lsrs	r3, r3, #27
34185338:	f003 0307 	and.w	r3, r3, #7
3418533c:	61fb      	str	r3, [r7, #28]
        pllp2 = (pllcfgr & RCC_PLL2CFGR3_PLL2PDIV2) >>  RCC_PLL2CFGR3_PLL2PDIV2_Pos;
3418533e:	68fb      	ldr	r3, [r7, #12]
34185340:	0e1b      	lsrs	r3, r3, #24
34185342:	f003 0307 	and.w	r3, r3, #7
34185346:	61bb      	str	r3, [r7, #24]
      break;
34185348:	e05d      	b.n	34185406 <SystemCoreClockUpdate+0x21a>
      pllcfgr = READ_REG(RCC->PLL3CFGR1);
3418534a:	4b4b      	ldr	r3, [pc, #300]	@ (34185478 <SystemCoreClockUpdate+0x28c>)
3418534c:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
34185350:	60fb      	str	r3, [r7, #12]
      pllsource = pllcfgr & RCC_PLL3CFGR1_PLL3SEL;
34185352:	68fb      	ldr	r3, [r7, #12]
34185354:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
34185358:	617b      	str	r3, [r7, #20]
      pllbypass = pllcfgr & RCC_PLL3CFGR1_PLL3BYP;
3418535a:	68fb      	ldr	r3, [r7, #12]
3418535c:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34185360:	613b      	str	r3, [r7, #16]
      if (pllbypass == 0U)
34185362:	693b      	ldr	r3, [r7, #16]
34185364:	2b00      	cmp	r3, #0
34185366:	d150      	bne.n	3418540a <SystemCoreClockUpdate+0x21e>
        pllm = (pllcfgr & RCC_PLL3CFGR1_PLL3DIVM) >>  RCC_PLL3CFGR1_PLL3DIVM_Pos;
34185368:	68fb      	ldr	r3, [r7, #12]
3418536a:	0d1b      	lsrs	r3, r3, #20
3418536c:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
34185370:	62bb      	str	r3, [r7, #40]	@ 0x28
        plln = (pllcfgr & RCC_PLL3CFGR1_PLL3DIVN) >>  RCC_PLL3CFGR1_PLL3DIVN_Pos;
34185372:	68fb      	ldr	r3, [r7, #12]
34185374:	0a1b      	lsrs	r3, r3, #8
34185376:	f3c3 030b 	ubfx	r3, r3, #0, #12
3418537a:	627b      	str	r3, [r7, #36]	@ 0x24
        pllfracn = READ_BIT(RCC->PLL3CFGR2, RCC_PLL3CFGR2_PLL3DIVNFRAC) >>  RCC_PLL3CFGR2_PLL3DIVNFRAC_Pos;
3418537c:	4b3e      	ldr	r3, [pc, #248]	@ (34185478 <SystemCoreClockUpdate+0x28c>)
3418537e:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
34185382:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
34185386:	623b      	str	r3, [r7, #32]
        pllcfgr = READ_REG(RCC->PLL3CFGR3);
34185388:	4b3b      	ldr	r3, [pc, #236]	@ (34185478 <SystemCoreClockUpdate+0x28c>)
3418538a:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
3418538e:	60fb      	str	r3, [r7, #12]
        pllp1 = (pllcfgr & RCC_PLL3CFGR3_PLL3PDIV1) >>  RCC_PLL3CFGR3_PLL3PDIV1_Pos;
34185390:	68fb      	ldr	r3, [r7, #12]
34185392:	0edb      	lsrs	r3, r3, #27
34185394:	f003 0307 	and.w	r3, r3, #7
34185398:	61fb      	str	r3, [r7, #28]
        pllp2 = (pllcfgr & RCC_PLL3CFGR3_PLL3PDIV2) >>  RCC_PLL3CFGR3_PLL3PDIV2_Pos;
3418539a:	68fb      	ldr	r3, [r7, #12]
3418539c:	0e1b      	lsrs	r3, r3, #24
3418539e:	f003 0307 	and.w	r3, r3, #7
341853a2:	61bb      	str	r3, [r7, #24]
      break;
341853a4:	e031      	b.n	3418540a <SystemCoreClockUpdate+0x21e>
      pllcfgr = READ_REG(RCC->PLL4CFGR1);
341853a6:	4b34      	ldr	r3, [pc, #208]	@ (34185478 <SystemCoreClockUpdate+0x28c>)
341853a8:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
341853ac:	60fb      	str	r3, [r7, #12]
      pllsource = pllcfgr & RCC_PLL4CFGR1_PLL4SEL;
341853ae:	68fb      	ldr	r3, [r7, #12]
341853b0:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
341853b4:	617b      	str	r3, [r7, #20]
      pllbypass = pllcfgr & RCC_PLL4CFGR1_PLL4BYP;
341853b6:	68fb      	ldr	r3, [r7, #12]
341853b8:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
341853bc:	613b      	str	r3, [r7, #16]
      if (pllbypass == 0U)
341853be:	693b      	ldr	r3, [r7, #16]
341853c0:	2b00      	cmp	r3, #0
341853c2:	d124      	bne.n	3418540e <SystemCoreClockUpdate+0x222>
        pllm = (pllcfgr & RCC_PLL4CFGR1_PLL4DIVM) >>  RCC_PLL4CFGR1_PLL4DIVM_Pos;
341853c4:	68fb      	ldr	r3, [r7, #12]
341853c6:	0d1b      	lsrs	r3, r3, #20
341853c8:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
341853cc:	62bb      	str	r3, [r7, #40]	@ 0x28
        plln = (pllcfgr & RCC_PLL4CFGR1_PLL4DIVN) >>  RCC_PLL4CFGR1_PLL4DIVN_Pos;
341853ce:	68fb      	ldr	r3, [r7, #12]
341853d0:	0a1b      	lsrs	r3, r3, #8
341853d2:	f3c3 030b 	ubfx	r3, r3, #0, #12
341853d6:	627b      	str	r3, [r7, #36]	@ 0x24
        pllfracn = READ_BIT(RCC->PLL4CFGR2, RCC_PLL4CFGR2_PLL4DIVNFRAC) >>  RCC_PLL4CFGR2_PLL4DIVNFRAC_Pos;
341853d8:	4b27      	ldr	r3, [pc, #156]	@ (34185478 <SystemCoreClockUpdate+0x28c>)
341853da:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
341853de:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
341853e2:	623b      	str	r3, [r7, #32]
        pllcfgr = READ_REG(RCC->PLL4CFGR3);
341853e4:	4b24      	ldr	r3, [pc, #144]	@ (34185478 <SystemCoreClockUpdate+0x28c>)
341853e6:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
341853ea:	60fb      	str	r3, [r7, #12]
        pllp1 = (pllcfgr & RCC_PLL4CFGR3_PLL4PDIV1) >>  RCC_PLL4CFGR3_PLL4PDIV1_Pos;
341853ec:	68fb      	ldr	r3, [r7, #12]
341853ee:	0edb      	lsrs	r3, r3, #27
341853f0:	f003 0307 	and.w	r3, r3, #7
341853f4:	61fb      	str	r3, [r7, #28]
        pllp2 = (pllcfgr & RCC_PLL4CFGR3_PLL4PDIV2) >>  RCC_PLL4CFGR3_PLL4PDIV2_Pos;
341853f6:	68fb      	ldr	r3, [r7, #12]
341853f8:	0e1b      	lsrs	r3, r3, #24
341853fa:	f003 0307 	and.w	r3, r3, #7
341853fe:	61bb      	str	r3, [r7, #24]
      break;
34185400:	e005      	b.n	3418540e <SystemCoreClockUpdate+0x222>
      break;
34185402:	bf00      	nop
34185404:	e004      	b.n	34185410 <SystemCoreClockUpdate+0x224>
      break;
34185406:	bf00      	nop
34185408:	e002      	b.n	34185410 <SystemCoreClockUpdate+0x224>
      break;
3418540a:	bf00      	nop
3418540c:	e000      	b.n	34185410 <SystemCoreClockUpdate+0x224>
      break;
3418540e:	bf00      	nop
    switch (pllsource)
34185410:	697b      	ldr	r3, [r7, #20]
34185412:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34185416:	d02c      	beq.n	34185472 <SystemCoreClockUpdate+0x286>
34185418:	697b      	ldr	r3, [r7, #20]
3418541a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418541e:	d839      	bhi.n	34185494 <SystemCoreClockUpdate+0x2a8>
34185420:	697b      	ldr	r3, [r7, #20]
34185422:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34185426:	d021      	beq.n	3418546c <SystemCoreClockUpdate+0x280>
34185428:	697b      	ldr	r3, [r7, #20]
3418542a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418542e:	d831      	bhi.n	34185494 <SystemCoreClockUpdate+0x2a8>
34185430:	697b      	ldr	r3, [r7, #20]
34185432:	2b00      	cmp	r3, #0
34185434:	d004      	beq.n	34185440 <SystemCoreClockUpdate+0x254>
34185436:	697b      	ldr	r3, [r7, #20]
34185438:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3418543c:	d00a      	beq.n	34185454 <SystemCoreClockUpdate+0x268>
      break;
3418543e:	e029      	b.n	34185494 <SystemCoreClockUpdate+0x2a8>
      sysclk = HSI_VALUE >> ((RCC->HSICFGR & RCC_HSICFGR_HSIDIV) >> RCC_HSICFGR_HSIDIV_Pos);
34185440:	4b0d      	ldr	r3, [pc, #52]	@ (34185478 <SystemCoreClockUpdate+0x28c>)
34185442:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34185444:	09db      	lsrs	r3, r3, #7
34185446:	f003 0303 	and.w	r3, r3, #3
3418544a:	4a0c      	ldr	r2, [pc, #48]	@ (3418547c <SystemCoreClockUpdate+0x290>)
3418544c:	fa22 f303 	lsr.w	r3, r2, r3
34185450:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
34185452:	e020      	b.n	34185496 <SystemCoreClockUpdate+0x2aa>
      if (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL) == 0UL)
34185454:	4b08      	ldr	r3, [pc, #32]	@ (34185478 <SystemCoreClockUpdate+0x28c>)
34185456:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34185458:	f403 7300 	and.w	r3, r3, #512	@ 0x200
3418545c:	2b00      	cmp	r3, #0
3418545e:	d102      	bne.n	34185466 <SystemCoreClockUpdate+0x27a>
        sysclk = MSI_VALUE;
34185460:	4b07      	ldr	r3, [pc, #28]	@ (34185480 <SystemCoreClockUpdate+0x294>)
34185462:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
34185464:	e017      	b.n	34185496 <SystemCoreClockUpdate+0x2aa>
        sysclk = 16000000UL;
34185466:	4b07      	ldr	r3, [pc, #28]	@ (34185484 <SystemCoreClockUpdate+0x298>)
34185468:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
3418546a:	e014      	b.n	34185496 <SystemCoreClockUpdate+0x2aa>
      sysclk = HSE_VALUE;
3418546c:	4b06      	ldr	r3, [pc, #24]	@ (34185488 <SystemCoreClockUpdate+0x29c>)
3418546e:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
34185470:	e011      	b.n	34185496 <SystemCoreClockUpdate+0x2aa>
      sysclk = EXTERNAL_I2S_CLOCK_VALUE;
34185472:	4b06      	ldr	r3, [pc, #24]	@ (3418548c <SystemCoreClockUpdate+0x2a0>)
34185474:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
34185476:	e00e      	b.n	34185496 <SystemCoreClockUpdate+0x2aa>
34185478:	56028000 	.word	0x56028000
3418547c:	03d09000 	.word	0x03d09000
34185480:	003d0900 	.word	0x003d0900
34185484:	00f42400 	.word	0x00f42400
34185488:	02dc6c00 	.word	0x02dc6c00
3418548c:	00bb8000 	.word	0x00bb8000
34185490:	4b800000 	.word	0x4b800000
      break;
34185494:	bf00      	nop
    if (pllbypass == 0U)
34185496:	693b      	ldr	r3, [r7, #16]
34185498:	2b00      	cmp	r3, #0
3418549a:	d134      	bne.n	34185506 <SystemCoreClockUpdate+0x31a>
      pllvco = ((float_t)sysclk * ((float_t)plln + ((float_t)pllfracn/(float_t)0x1000000UL))) / (float_t)pllm;
3418549c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3418549e:	ee07 3a90 	vmov	s15, r3
341854a2:	eeb8 7a67 	vcvt.f32.u32	s14, s15
341854a6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
341854a8:	ee07 3a90 	vmov	s15, r3
341854ac:	eef8 6a67 	vcvt.f32.u32	s13, s15
341854b0:	6a3b      	ldr	r3, [r7, #32]
341854b2:	ee07 3a90 	vmov	s15, r3
341854b6:	eeb8 6a67 	vcvt.f32.u32	s12, s15
341854ba:	ed5f 5a0b 	vldr	s11, [pc, #-44]	@ 34185490 <SystemCoreClockUpdate+0x2a4>
341854be:	eec6 7a25 	vdiv.f32	s15, s12, s11
341854c2:	ee76 7aa7 	vadd.f32	s15, s13, s15
341854c6:	ee67 6a27 	vmul.f32	s13, s14, s15
341854ca:	6abb      	ldr	r3, [r7, #40]	@ 0x28
341854cc:	ee07 3a90 	vmov	s15, r3
341854d0:	eeb8 7a67 	vcvt.f32.u32	s14, s15
341854d4:	eec6 7a87 	vdiv.f32	s15, s13, s14
341854d8:	edc7 7a02 	vstr	s15, [r7, #8]
      sysclk = (uint32_t)((float_t)(pllvco/(((float_t)pllp1) * ((float_t)pllp2))));
341854dc:	69fb      	ldr	r3, [r7, #28]
341854de:	ee07 3a90 	vmov	s15, r3
341854e2:	eeb8 7a67 	vcvt.f32.u32	s14, s15
341854e6:	69bb      	ldr	r3, [r7, #24]
341854e8:	ee07 3a90 	vmov	s15, r3
341854ec:	eef8 7a67 	vcvt.f32.u32	s15, s15
341854f0:	ee27 7a27 	vmul.f32	s14, s14, s15
341854f4:	edd7 6a02 	vldr	s13, [r7, #8]
341854f8:	eec6 7a87 	vdiv.f32	s15, s13, s14
341854fc:	eefc 7ae7 	vcvt.u32.f32	s15, s15
34185500:	ee17 3a90 	vmov	r3, s15
34185504:	62fb      	str	r3, [r7, #44]	@ 0x2c
    ic_divider = (READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1UL;
34185506:	4b0b      	ldr	r3, [pc, #44]	@ (34185534 <SystemCoreClockUpdate+0x348>)
34185508:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
3418550c:	0c1b      	lsrs	r3, r3, #16
3418550e:	b2db      	uxtb	r3, r3
34185510:	3301      	adds	r3, #1
34185512:	607b      	str	r3, [r7, #4]
    sysclk = sysclk / ic_divider;
34185514:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
34185516:	687b      	ldr	r3, [r7, #4]
34185518:	fbb2 f3f3 	udiv	r3, r2, r3
3418551c:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
3418551e:	e000      	b.n	34185522 <SystemCoreClockUpdate+0x336>
    break;
34185520:	bf00      	nop
  }

  /* Return system clock frequency (CPU frequency) */
  SystemCoreClock = sysclk;
34185522:	4a05      	ldr	r2, [pc, #20]	@ (34185538 <SystemCoreClockUpdate+0x34c>)
34185524:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34185526:	6013      	str	r3, [r2, #0]
}
34185528:	bf00      	nop
3418552a:	3734      	adds	r7, #52	@ 0x34
3418552c:	46bd      	mov	sp, r7
3418552e:	f85d 7b04 	ldr.w	r7, [sp], #4
34185532:	4770      	bx	lr
34185534:	56028000 	.word	0x56028000
34185538:	341c0090 	.word	0x341c0090

3418553c <__acle_se_SECURE_SystemCoreClockUpdate>:
  *         be used by the user application to setup the SysTick timer or configure
  *         other parameters.
  * @retval SystemCoreClock value
  */
CMSE_NS_ENTRY uint32_t SECURE_SystemCoreClockUpdate(void)
{
3418553c:	ed6d cf81 	vstr	FPCXTNS, [sp, #-4]!
34185540:	b588      	push	{r3, r7, lr}
34185542:	af00      	add	r7, sp, #0
  SystemCoreClockUpdate();
34185544:	f7ff fe52 	bl	341851ec <SystemCoreClockUpdate>

  return SystemCoreClock;
34185548:	4b06      	ldr	r3, [pc, #24]	@ (34185564 <__acle_se_SECURE_SystemCoreClockUpdate+0x28>)
3418554a:	681b      	ldr	r3, [r3, #0]
}
3418554c:	4618      	mov	r0, r3
3418554e:	46bd      	mov	sp, r7
34185550:	e8bd 4088 	ldmia.w	sp!, {r3, r7, lr}
34185554:	ec9f 0a10 	vscclrm	{s0-s15, VPR}
34185558:	e89f 900e 	clrm	{r1, r2, r3, ip, APSR}
3418555c:	ecfd cf81 	vldr	FPCXTNS, [sp], #4
34185560:	4774      	bxns	lr
34185562:	bf00      	nop
34185564:	341c0090 	.word	0x341c0090

34185568 <HAL_Init>:
  *         each 1ms in the SysTick_Handler() interrupt handler.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
34185568:	b580      	push	{r7, lr}
3418556a:	af00      	add	r7, sp, #0
  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
3418556c:	2003      	movs	r0, #3
3418556e:	f001 fb68 	bl	34186c42 <HAL_NVIC_SetPriorityGrouping>

  /* Ensure time base clock coherency in SystemCoreClock global variable */
  SystemCoreClockUpdate();
34185572:	f7ff fe3b 	bl	341851ec <SystemCoreClockUpdate>

  /* Initialize 1ms tick time base (default SysTick based on HSI clock after Reset) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
34185576:	200f      	movs	r0, #15
34185578:	f7fc f9ae 	bl	341818d8 <HAL_InitTick>
3418557c:	4603      	mov	r3, r0
3418557e:	2b00      	cmp	r3, #0
34185580:	d001      	beq.n	34185586 <HAL_Init+0x1e>
  {
    return HAL_ERROR;
34185582:	2301      	movs	r3, #1
34185584:	e002      	b.n	3418558c <HAL_Init+0x24>
  }

  /* Init the low level hardware */
  HAL_MspInit();
34185586:	f7fc f895 	bl	341816b4 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
3418558a:	2300      	movs	r3, #0
}
3418558c:	4618      	mov	r0, r3
3418558e:	bd80      	pop	{r7, pc}

34185590 <HAL_IncTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
34185590:	b480      	push	{r7}
34185592:	af00      	add	r7, sp, #0
  uwTick += (uint32_t)uwTickFreq;
34185594:	4b06      	ldr	r3, [pc, #24]	@ (341855b0 <HAL_IncTick+0x20>)
34185596:	781b      	ldrb	r3, [r3, #0]
34185598:	461a      	mov	r2, r3
3418559a:	4b06      	ldr	r3, [pc, #24]	@ (341855b4 <HAL_IncTick+0x24>)
3418559c:	681b      	ldr	r3, [r3, #0]
3418559e:	4413      	add	r3, r2
341855a0:	4a04      	ldr	r2, [pc, #16]	@ (341855b4 <HAL_IncTick+0x24>)
341855a2:	6013      	str	r3, [r2, #0]
}
341855a4:	bf00      	nop
341855a6:	46bd      	mov	sp, r7
341855a8:	f85d 7b04 	ldr.w	r7, [sp], #4
341855ac:	4770      	bx	lr
341855ae:	bf00      	nop
341855b0:	341c0098 	.word	0x341c0098
341855b4:	341c2d68 	.word	0x341c2d68

341855b8 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
341855b8:	b480      	push	{r7}
341855ba:	af00      	add	r7, sp, #0
  return uwTick;
341855bc:	4b03      	ldr	r3, [pc, #12]	@ (341855cc <HAL_GetTick+0x14>)
341855be:	681b      	ldr	r3, [r3, #0]
}
341855c0:	4618      	mov	r0, r3
341855c2:	46bd      	mov	sp, r7
341855c4:	f85d 7b04 	ldr.w	r7, [sp], #4
341855c8:	4770      	bx	lr
341855ca:	bf00      	nop
341855cc:	341c2d68 	.word	0x341c2d68

341855d0 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay Specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
341855d0:	b580      	push	{r7, lr}
341855d2:	b084      	sub	sp, #16
341855d4:	af00      	add	r7, sp, #0
341855d6:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
341855d8:	f7ff ffee 	bl	341855b8 <HAL_GetTick>
341855dc:	60b8      	str	r0, [r7, #8]
  uint32_t wait = Delay;
341855de:	687b      	ldr	r3, [r7, #4]
341855e0:	60fb      	str	r3, [r7, #12]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
341855e2:	68fb      	ldr	r3, [r7, #12]
341855e4:	f1b3 3fff 	cmp.w	r3, #4294967295
341855e8:	d005      	beq.n	341855f6 <HAL_Delay+0x26>
  {
    wait += (uint32_t)(uwTickFreq);
341855ea:	4b0a      	ldr	r3, [pc, #40]	@ (34185614 <HAL_Delay+0x44>)
341855ec:	781b      	ldrb	r3, [r3, #0]
341855ee:	461a      	mov	r2, r3
341855f0:	68fb      	ldr	r3, [r7, #12]
341855f2:	4413      	add	r3, r2
341855f4:	60fb      	str	r3, [r7, #12]
  }

  while ((HAL_GetTick() - tickstart) < wait)
341855f6:	bf00      	nop
341855f8:	f7ff ffde 	bl	341855b8 <HAL_GetTick>
341855fc:	4602      	mov	r2, r0
341855fe:	68bb      	ldr	r3, [r7, #8]
34185600:	1ad3      	subs	r3, r2, r3
34185602:	68fa      	ldr	r2, [r7, #12]
34185604:	429a      	cmp	r2, r3
34185606:	d8f7      	bhi.n	341855f8 <HAL_Delay+0x28>
  {
  }
}
34185608:	bf00      	nop
3418560a:	bf00      	nop
3418560c:	3710      	adds	r7, #16
3418560e:	46bd      	mov	sp, r7
34185610:	bd80      	pop	{r7, pc}
34185612:	bf00      	nop
34185614:	341c0098 	.word	0x341c0098

34185618 <LL_ADC_SetCommonPathInternalCh>:
{
34185618:	b480      	push	{r7}
3418561a:	b083      	sub	sp, #12
3418561c:	af00      	add	r7, sp, #0
3418561e:	6078      	str	r0, [r7, #4]
34185620:	6039      	str	r1, [r7, #0]
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_VBATEN, PathInternal);
34185622:	687b      	ldr	r3, [r7, #4]
34185624:	689b      	ldr	r3, [r3, #8]
34185626:	f023 72a0 	bic.w	r2, r3, #20971520	@ 0x1400000
3418562a:	683b      	ldr	r3, [r7, #0]
3418562c:	431a      	orrs	r2, r3
3418562e:	687b      	ldr	r3, [r7, #4]
34185630:	609a      	str	r2, [r3, #8]
}
34185632:	bf00      	nop
34185634:	370c      	adds	r7, #12
34185636:	46bd      	mov	sp, r7
34185638:	f85d 7b04 	ldr.w	r7, [sp], #4
3418563c:	4770      	bx	lr

3418563e <LL_ADC_GetCommonPathInternalCh>:
{
3418563e:	b480      	push	{r7}
34185640:	b083      	sub	sp, #12
34185642:	af00      	add	r7, sp, #0
34185644:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_VBATEN));
34185646:	687b      	ldr	r3, [r7, #4]
34185648:	689b      	ldr	r3, [r3, #8]
3418564a:	f003 73a0 	and.w	r3, r3, #20971520	@ 0x1400000
}
3418564e:	4618      	mov	r0, r3
34185650:	370c      	adds	r7, #12
34185652:	46bd      	mov	sp, r7
34185654:	f85d 7b04 	ldr.w	r7, [sp], #4
34185658:	4770      	bx	lr

3418565a <LL_ADC_SetPathInternalCh>:
{
3418565a:	b480      	push	{r7}
3418565c:	b083      	sub	sp, #12
3418565e:	af00      	add	r7, sp, #0
34185660:	6078      	str	r0, [r7, #4]
34185662:	6039      	str	r1, [r7, #0]
  MODIFY_REG(ADCx->OR, ADC_OR_OP2, (PathInternal >> ADC_PATH_INTERNAL_POS));
34185664:	687b      	ldr	r3, [r7, #4]
34185666:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
3418566a:	f023 0204 	bic.w	r2, r3, #4
3418566e:	683b      	ldr	r3, [r7, #0]
34185670:	0c1b      	lsrs	r3, r3, #16
34185672:	431a      	orrs	r2, r3
34185674:	687b      	ldr	r3, [r7, #4]
34185676:	f8c3 20d0 	str.w	r2, [r3, #208]	@ 0xd0
}
3418567a:	bf00      	nop
3418567c:	370c      	adds	r7, #12
3418567e:	46bd      	mov	sp, r7
34185680:	f85d 7b04 	ldr.w	r7, [sp], #4
34185684:	4770      	bx	lr

34185686 <LL_ADC_GetPathInternalCh>:
{
34185686:	b480      	push	{r7}
34185688:	b083      	sub	sp, #12
3418568a:	af00      	add	r7, sp, #0
3418568c:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(ADCx->OR, ADC_OR_OP2)) << ADC_PATH_INTERNAL_POS;
3418568e:	687b      	ldr	r3, [r7, #4]
34185690:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
34185694:	041b      	lsls	r3, r3, #16
34185696:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
}
3418569a:	4618      	mov	r0, r3
3418569c:	370c      	adds	r7, #12
3418569e:	46bd      	mov	sp, r7
341856a0:	f85d 7b04 	ldr.w	r7, [sp], #4
341856a4:	4770      	bx	lr

341856a6 <LL_ADC_SetOffsetChannel>:
{
341856a6:	b480      	push	{r7}
341856a8:	b087      	sub	sp, #28
341856aa:	af00      	add	r7, sp, #0
341856ac:	60f8      	str	r0, [r7, #12]
341856ae:	60b9      	str	r1, [r7, #8]
341856b0:	607a      	str	r2, [r7, #4]
  __IO uint32_t *preg_offset_cfg = __ADC_PTR_REG_OFFSET(ADCx->OFCFGR1, Offsety);
341856b2:	68fb      	ldr	r3, [r7, #12]
341856b4:	3350      	adds	r3, #80	@ 0x50
341856b6:	461a      	mov	r2, r3
341856b8:	68bb      	ldr	r3, [r7, #8]
341856ba:	009b      	lsls	r3, r3, #2
341856bc:	4413      	add	r3, r2
341856be:	617b      	str	r3, [r7, #20]
  MODIFY_REG(*preg_offset_cfg,
341856c0:	697b      	ldr	r3, [r7, #20]
341856c2:	681b      	ldr	r3, [r3, #0]
341856c4:	f023 4278 	bic.w	r2, r3, #4160749568	@ 0xf8000000
341856c8:	687b      	ldr	r3, [r7, #4]
341856ca:	06db      	lsls	r3, r3, #27
341856cc:	431a      	orrs	r2, r3
341856ce:	697b      	ldr	r3, [r7, #20]
341856d0:	601a      	str	r2, [r3, #0]
}
341856d2:	bf00      	nop
341856d4:	371c      	adds	r7, #28
341856d6:	46bd      	mov	sp, r7
341856d8:	f85d 7b04 	ldr.w	r7, [sp], #4
341856dc:	4770      	bx	lr

341856de <LL_ADC_GetOffsetChannel>:
{
341856de:	b480      	push	{r7}
341856e0:	b085      	sub	sp, #20
341856e2:	af00      	add	r7, sp, #0
341856e4:	6078      	str	r0, [r7, #4]
341856e6:	6039      	str	r1, [r7, #0]
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFCFGR1, Offsety);
341856e8:	687b      	ldr	r3, [r7, #4]
341856ea:	3350      	adds	r3, #80	@ 0x50
341856ec:	461a      	mov	r2, r3
341856ee:	683b      	ldr	r3, [r7, #0]
341856f0:	009b      	lsls	r3, r3, #2
341856f2:	4413      	add	r3, r2
341856f4:	60fb      	str	r3, [r7, #12]
  return (uint32_t) __LL_ADC_DECIMAL_NB_TO_CHANNEL(READ_BIT(*preg, ADC_OFCFGR1_OFFSET_CH) >> ADC_OFCFGR1_OFFSET_CH_Pos);
341856f6:	68fb      	ldr	r3, [r7, #12]
341856f8:	681b      	ldr	r3, [r3, #0]
341856fa:	0edb      	lsrs	r3, r3, #27
341856fc:	f003 031f 	and.w	r3, r3, #31
}
34185700:	4618      	mov	r0, r3
34185702:	3714      	adds	r7, #20
34185704:	46bd      	mov	sp, r7
34185706:	f85d 7b04 	ldr.w	r7, [sp], #4
3418570a:	4770      	bx	lr

3418570c <LL_ADC_SetOffsetLevel>:
{
3418570c:	b480      	push	{r7}
3418570e:	b087      	sub	sp, #28
34185710:	af00      	add	r7, sp, #0
34185712:	60f8      	str	r0, [r7, #12]
34185714:	60b9      	str	r1, [r7, #8]
34185716:	607a      	str	r2, [r7, #4]
  __IO uint32_t *preg_offset_val = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
34185718:	68fb      	ldr	r3, [r7, #12]
3418571a:	3360      	adds	r3, #96	@ 0x60
3418571c:	461a      	mov	r2, r3
3418571e:	68bb      	ldr	r3, [r7, #8]
34185720:	009b      	lsls	r3, r3, #2
34185722:	4413      	add	r3, r2
34185724:	617b      	str	r3, [r7, #20]
  MODIFY_REG(*preg_offset_val,
34185726:	697b      	ldr	r3, [r7, #20]
34185728:	681b      	ldr	r3, [r3, #0]
3418572a:	0d9b      	lsrs	r3, r3, #22
3418572c:	059b      	lsls	r3, r3, #22
3418572e:	687a      	ldr	r2, [r7, #4]
34185730:	431a      	orrs	r2, r3
34185732:	697b      	ldr	r3, [r7, #20]
34185734:	601a      	str	r2, [r3, #0]
}
34185736:	bf00      	nop
34185738:	371c      	adds	r7, #28
3418573a:	46bd      	mov	sp, r7
3418573c:	f85d 7b04 	ldr.w	r7, [sp], #4
34185740:	4770      	bx	lr

34185742 <LL_ADC_SetOffsetSign>:
{
34185742:	b480      	push	{r7}
34185744:	b087      	sub	sp, #28
34185746:	af00      	add	r7, sp, #0
34185748:	60f8      	str	r0, [r7, #12]
3418574a:	60b9      	str	r1, [r7, #8]
3418574c:	607a      	str	r2, [r7, #4]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFCFGR1, Offsety);
3418574e:	68fb      	ldr	r3, [r7, #12]
34185750:	3350      	adds	r3, #80	@ 0x50
34185752:	461a      	mov	r2, r3
34185754:	68bb      	ldr	r3, [r7, #8]
34185756:	009b      	lsls	r3, r3, #2
34185758:	4413      	add	r3, r2
3418575a:	617b      	str	r3, [r7, #20]
  MODIFY_REG(*preg,
3418575c:	697b      	ldr	r3, [r7, #20]
3418575e:	681b      	ldr	r3, [r3, #0]
34185760:	f023 7280 	bic.w	r2, r3, #16777216	@ 0x1000000
34185764:	687b      	ldr	r3, [r7, #4]
34185766:	431a      	orrs	r2, r3
34185768:	697b      	ldr	r3, [r7, #20]
3418576a:	601a      	str	r2, [r3, #0]
}
3418576c:	bf00      	nop
3418576e:	371c      	adds	r7, #28
34185770:	46bd      	mov	sp, r7
34185772:	f85d 7b04 	ldr.w	r7, [sp], #4
34185776:	4770      	bx	lr

34185778 <LL_ADC_SetOffsetSignedSaturation>:
{
34185778:	b480      	push	{r7}
3418577a:	b087      	sub	sp, #28
3418577c:	af00      	add	r7, sp, #0
3418577e:	60f8      	str	r0, [r7, #12]
34185780:	60b9      	str	r1, [r7, #8]
34185782:	607a      	str	r2, [r7, #4]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFCFGR1, Offsety);
34185784:	68fb      	ldr	r3, [r7, #12]
34185786:	3350      	adds	r3, #80	@ 0x50
34185788:	461a      	mov	r2, r3
3418578a:	68bb      	ldr	r3, [r7, #8]
3418578c:	009b      	lsls	r3, r3, #2
3418578e:	4413      	add	r3, r2
34185790:	617b      	str	r3, [r7, #20]
  MODIFY_REG(*preg, ADC_OFCFGR1_SSAT, OffsetSignedSaturation);
34185792:	697b      	ldr	r3, [r7, #20]
34185794:	681b      	ldr	r3, [r3, #0]
34185796:	f023 6280 	bic.w	r2, r3, #67108864	@ 0x4000000
3418579a:	687b      	ldr	r3, [r7, #4]
3418579c:	431a      	orrs	r2, r3
3418579e:	697b      	ldr	r3, [r7, #20]
341857a0:	601a      	str	r2, [r3, #0]
}
341857a2:	bf00      	nop
341857a4:	371c      	adds	r7, #28
341857a6:	46bd      	mov	sp, r7
341857a8:	f85d 7b04 	ldr.w	r7, [sp], #4
341857ac:	4770      	bx	lr

341857ae <LL_ADC_SetOffsetUnsignedSaturation>:
{
341857ae:	b480      	push	{r7}
341857b0:	b087      	sub	sp, #28
341857b2:	af00      	add	r7, sp, #0
341857b4:	60f8      	str	r0, [r7, #12]
341857b6:	60b9      	str	r1, [r7, #8]
341857b8:	607a      	str	r2, [r7, #4]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFCFGR1, Offsety);
341857ba:	68fb      	ldr	r3, [r7, #12]
341857bc:	3350      	adds	r3, #80	@ 0x50
341857be:	461a      	mov	r2, r3
341857c0:	68bb      	ldr	r3, [r7, #8]
341857c2:	009b      	lsls	r3, r3, #2
341857c4:	4413      	add	r3, r2
341857c6:	617b      	str	r3, [r7, #20]
  MODIFY_REG(*preg, ADC_OFCFGR1_USAT, OffsetUnsignedSaturation);
341857c8:	697b      	ldr	r3, [r7, #20]
341857ca:	681b      	ldr	r3, [r3, #0]
341857cc:	f023 7200 	bic.w	r2, r3, #33554432	@ 0x2000000
341857d0:	687b      	ldr	r3, [r7, #4]
341857d2:	431a      	orrs	r2, r3
341857d4:	697b      	ldr	r3, [r7, #20]
341857d6:	601a      	str	r2, [r3, #0]
}
341857d8:	bf00      	nop
341857da:	371c      	adds	r7, #28
341857dc:	46bd      	mov	sp, r7
341857de:	f85d 7b04 	ldr.w	r7, [sp], #4
341857e2:	4770      	bx	lr

341857e4 <LL_ADC_SetGainCompensation>:
{
341857e4:	b480      	push	{r7}
341857e6:	b083      	sub	sp, #12
341857e8:	af00      	add	r7, sp, #0
341857ea:	6078      	str	r0, [r7, #4]
341857ec:	6039      	str	r1, [r7, #0]
  MODIFY_REG(ADCx->GCOMP, ADC_GCOMP_GCOMPCOEFF, GainCompensation);
341857ee:	687b      	ldr	r3, [r7, #4]
341857f0:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
341857f2:	f423 537f 	bic.w	r3, r3, #16320	@ 0x3fc0
341857f6:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
341857fa:	683a      	ldr	r2, [r7, #0]
341857fc:	431a      	orrs	r2, r3
341857fe:	687b      	ldr	r3, [r7, #4]
34185800:	671a      	str	r2, [r3, #112]	@ 0x70
  MODIFY_REG(ADCx->GCOMP, ADC_GCOMP_GCOMP, ((GainCompensation == 0UL) ? 0UL : 1UL) << ADC_GCOMP_GCOMP_Pos);
34185802:	687b      	ldr	r3, [r7, #4]
34185804:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34185806:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
3418580a:	683a      	ldr	r2, [r7, #0]
3418580c:	2a00      	cmp	r2, #0
3418580e:	d002      	beq.n	34185816 <LL_ADC_SetGainCompensation+0x32>
34185810:	f04f 4200 	mov.w	r2, #2147483648	@ 0x80000000
34185814:	e000      	b.n	34185818 <LL_ADC_SetGainCompensation+0x34>
34185816:	2200      	movs	r2, #0
34185818:	431a      	orrs	r2, r3
3418581a:	687b      	ldr	r3, [r7, #4]
3418581c:	671a      	str	r2, [r3, #112]	@ 0x70
}
3418581e:	bf00      	nop
34185820:	370c      	adds	r7, #12
34185822:	46bd      	mov	sp, r7
34185824:	f85d 7b04 	ldr.w	r7, [sp], #4
34185828:	4770      	bx	lr

3418582a <LL_ADC_REG_SetSequencerRanks>:
{
3418582a:	b480      	push	{r7}
3418582c:	b087      	sub	sp, #28
3418582e:	af00      	add	r7, sp, #0
34185830:	60f8      	str	r0, [r7, #12]
34185832:	60b9      	str	r1, [r7, #8]
34185834:	607a      	str	r2, [r7, #4]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SQR1,
34185836:	68fb      	ldr	r3, [r7, #12]
34185838:	3330      	adds	r3, #48	@ 0x30
3418583a:	461a      	mov	r2, r3
3418583c:	68bb      	ldr	r3, [r7, #8]
3418583e:	0a1b      	lsrs	r3, r3, #8
34185840:	009b      	lsls	r3, r3, #2
34185842:	f003 030c 	and.w	r3, r3, #12
34185846:	4413      	add	r3, r2
34185848:	617b      	str	r3, [r7, #20]
  MODIFY_REG(*preg,
3418584a:	697b      	ldr	r3, [r7, #20]
3418584c:	681a      	ldr	r2, [r3, #0]
3418584e:	68bb      	ldr	r3, [r7, #8]
34185850:	f003 031f 	and.w	r3, r3, #31
34185854:	211f      	movs	r1, #31
34185856:	fa01 f303 	lsl.w	r3, r1, r3
3418585a:	43db      	mvns	r3, r3
3418585c:	401a      	ands	r2, r3
3418585e:	687b      	ldr	r3, [r7, #4]
34185860:	f003 011f 	and.w	r1, r3, #31
34185864:	68bb      	ldr	r3, [r7, #8]
34185866:	f003 031f 	and.w	r3, r3, #31
3418586a:	fa01 f303 	lsl.w	r3, r1, r3
3418586e:	431a      	orrs	r2, r3
34185870:	697b      	ldr	r3, [r7, #20]
34185872:	601a      	str	r2, [r3, #0]
}
34185874:	bf00      	nop
34185876:	371c      	adds	r7, #28
34185878:	46bd      	mov	sp, r7
3418587a:	f85d 7b04 	ldr.w	r7, [sp], #4
3418587e:	4770      	bx	lr

34185880 <LL_ADC_SetChannelPreselection>:
{
34185880:	b480      	push	{r7}
34185882:	b085      	sub	sp, #20
34185884:	af00      	add	r7, sp, #0
34185886:	6078      	str	r0, [r7, #4]
34185888:	6039      	str	r1, [r7, #0]
  __IO uint32_t channel_preselectione = READ_REG(ADCx->PCSEL);
3418588a:	687b      	ldr	r3, [r7, #4]
3418588c:	69db      	ldr	r3, [r3, #28]
3418588e:	60fb      	str	r3, [r7, #12]
  WRITE_REG(ADCx->PCSEL,
34185890:	683b      	ldr	r3, [r7, #0]
34185892:	f003 031f 	and.w	r3, r3, #31
34185896:	2201      	movs	r2, #1
34185898:	409a      	lsls	r2, r3
3418589a:	68fb      	ldr	r3, [r7, #12]
3418589c:	431a      	orrs	r2, r3
3418589e:	687b      	ldr	r3, [r7, #4]
341858a0:	61da      	str	r2, [r3, #28]
}
341858a2:	bf00      	nop
341858a4:	3714      	adds	r7, #20
341858a6:	46bd      	mov	sp, r7
341858a8:	f85d 7b04 	ldr.w	r7, [sp], #4
341858ac:	4770      	bx	lr
	...

341858b0 <LL_ADC_SetChannelSamplingTime>:
{
341858b0:	b480      	push	{r7}
341858b2:	b087      	sub	sp, #28
341858b4:	af00      	add	r7, sp, #0
341858b6:	60f8      	str	r0, [r7, #12]
341858b8:	60b9      	str	r1, [r7, #8]
341858ba:	607a      	str	r2, [r7, #4]
  const uint32_t iChannel = __ADC_CHANNEL_INDEX(Channel);
341858bc:	68bb      	ldr	r3, [r7, #8]
341858be:	f003 031f 	and.w	r3, r3, #31
341858c2:	2b00      	cmp	r3, #0
341858c4:	f000 8087 	beq.w	341859d6 <LL_ADC_SetChannelSamplingTime+0x126>
341858c8:	68bb      	ldr	r3, [r7, #8]
341858ca:	f003 031f 	and.w	r3, r3, #31
341858ce:	2b01      	cmp	r3, #1
341858d0:	d07f      	beq.n	341859d2 <LL_ADC_SetChannelSamplingTime+0x122>
341858d2:	68bb      	ldr	r3, [r7, #8]
341858d4:	f003 031f 	and.w	r3, r3, #31
341858d8:	2b02      	cmp	r3, #2
341858da:	d078      	beq.n	341859ce <LL_ADC_SetChannelSamplingTime+0x11e>
341858dc:	68bb      	ldr	r3, [r7, #8]
341858de:	f003 031f 	and.w	r3, r3, #31
341858e2:	2b03      	cmp	r3, #3
341858e4:	d071      	beq.n	341859ca <LL_ADC_SetChannelSamplingTime+0x11a>
341858e6:	68bb      	ldr	r3, [r7, #8]
341858e8:	f003 031f 	and.w	r3, r3, #31
341858ec:	2b04      	cmp	r3, #4
341858ee:	d06a      	beq.n	341859c6 <LL_ADC_SetChannelSamplingTime+0x116>
341858f0:	68bb      	ldr	r3, [r7, #8]
341858f2:	f003 031f 	and.w	r3, r3, #31
341858f6:	2b05      	cmp	r3, #5
341858f8:	d063      	beq.n	341859c2 <LL_ADC_SetChannelSamplingTime+0x112>
341858fa:	68bb      	ldr	r3, [r7, #8]
341858fc:	f003 031f 	and.w	r3, r3, #31
34185900:	2b06      	cmp	r3, #6
34185902:	d05c      	beq.n	341859be <LL_ADC_SetChannelSamplingTime+0x10e>
34185904:	68bb      	ldr	r3, [r7, #8]
34185906:	f003 031f 	and.w	r3, r3, #31
3418590a:	2b07      	cmp	r3, #7
3418590c:	d055      	beq.n	341859ba <LL_ADC_SetChannelSamplingTime+0x10a>
3418590e:	68bb      	ldr	r3, [r7, #8]
34185910:	f003 031f 	and.w	r3, r3, #31
34185914:	2b08      	cmp	r3, #8
34185916:	d04e      	beq.n	341859b6 <LL_ADC_SetChannelSamplingTime+0x106>
34185918:	68bb      	ldr	r3, [r7, #8]
3418591a:	f003 031f 	and.w	r3, r3, #31
3418591e:	2b09      	cmp	r3, #9
34185920:	d047      	beq.n	341859b2 <LL_ADC_SetChannelSamplingTime+0x102>
34185922:	68bb      	ldr	r3, [r7, #8]
34185924:	f003 031f 	and.w	r3, r3, #31
34185928:	2b0a      	cmp	r3, #10
3418592a:	d040      	beq.n	341859ae <LL_ADC_SetChannelSamplingTime+0xfe>
3418592c:	68bb      	ldr	r3, [r7, #8]
3418592e:	f003 031f 	and.w	r3, r3, #31
34185932:	2b0b      	cmp	r3, #11
34185934:	d039      	beq.n	341859aa <LL_ADC_SetChannelSamplingTime+0xfa>
34185936:	68bb      	ldr	r3, [r7, #8]
34185938:	f003 031f 	and.w	r3, r3, #31
3418593c:	2b0c      	cmp	r3, #12
3418593e:	d032      	beq.n	341859a6 <LL_ADC_SetChannelSamplingTime+0xf6>
34185940:	68bb      	ldr	r3, [r7, #8]
34185942:	f003 031f 	and.w	r3, r3, #31
34185946:	2b0d      	cmp	r3, #13
34185948:	d02b      	beq.n	341859a2 <LL_ADC_SetChannelSamplingTime+0xf2>
3418594a:	68bb      	ldr	r3, [r7, #8]
3418594c:	f003 031f 	and.w	r3, r3, #31
34185950:	2b0e      	cmp	r3, #14
34185952:	d024      	beq.n	3418599e <LL_ADC_SetChannelSamplingTime+0xee>
34185954:	68bb      	ldr	r3, [r7, #8]
34185956:	f003 031f 	and.w	r3, r3, #31
3418595a:	2b0f      	cmp	r3, #15
3418595c:	d01d      	beq.n	3418599a <LL_ADC_SetChannelSamplingTime+0xea>
3418595e:	68bb      	ldr	r3, [r7, #8]
34185960:	f003 031f 	and.w	r3, r3, #31
34185964:	2b10      	cmp	r3, #16
34185966:	d016      	beq.n	34185996 <LL_ADC_SetChannelSamplingTime+0xe6>
34185968:	68bb      	ldr	r3, [r7, #8]
3418596a:	f003 031f 	and.w	r3, r3, #31
3418596e:	2b11      	cmp	r3, #17
34185970:	d00f      	beq.n	34185992 <LL_ADC_SetChannelSamplingTime+0xe2>
34185972:	68bb      	ldr	r3, [r7, #8]
34185974:	f003 031f 	and.w	r3, r3, #31
34185978:	2b12      	cmp	r3, #18
3418597a:	d008      	beq.n	3418598e <LL_ADC_SetChannelSamplingTime+0xde>
3418597c:	68bb      	ldr	r3, [r7, #8]
3418597e:	f003 031f 	and.w	r3, r3, #31
34185982:	2b13      	cmp	r3, #19
34185984:	d101      	bne.n	3418598a <LL_ADC_SetChannelSamplingTime+0xda>
34185986:	2313      	movs	r3, #19
34185988:	e026      	b.n	341859d8 <LL_ADC_SetChannelSamplingTime+0x128>
3418598a:	2300      	movs	r3, #0
3418598c:	e024      	b.n	341859d8 <LL_ADC_SetChannelSamplingTime+0x128>
3418598e:	2312      	movs	r3, #18
34185990:	e022      	b.n	341859d8 <LL_ADC_SetChannelSamplingTime+0x128>
34185992:	2311      	movs	r3, #17
34185994:	e020      	b.n	341859d8 <LL_ADC_SetChannelSamplingTime+0x128>
34185996:	2310      	movs	r3, #16
34185998:	e01e      	b.n	341859d8 <LL_ADC_SetChannelSamplingTime+0x128>
3418599a:	230f      	movs	r3, #15
3418599c:	e01c      	b.n	341859d8 <LL_ADC_SetChannelSamplingTime+0x128>
3418599e:	230e      	movs	r3, #14
341859a0:	e01a      	b.n	341859d8 <LL_ADC_SetChannelSamplingTime+0x128>
341859a2:	230d      	movs	r3, #13
341859a4:	e018      	b.n	341859d8 <LL_ADC_SetChannelSamplingTime+0x128>
341859a6:	230c      	movs	r3, #12
341859a8:	e016      	b.n	341859d8 <LL_ADC_SetChannelSamplingTime+0x128>
341859aa:	230b      	movs	r3, #11
341859ac:	e014      	b.n	341859d8 <LL_ADC_SetChannelSamplingTime+0x128>
341859ae:	230a      	movs	r3, #10
341859b0:	e012      	b.n	341859d8 <LL_ADC_SetChannelSamplingTime+0x128>
341859b2:	2309      	movs	r3, #9
341859b4:	e010      	b.n	341859d8 <LL_ADC_SetChannelSamplingTime+0x128>
341859b6:	2308      	movs	r3, #8
341859b8:	e00e      	b.n	341859d8 <LL_ADC_SetChannelSamplingTime+0x128>
341859ba:	2307      	movs	r3, #7
341859bc:	e00c      	b.n	341859d8 <LL_ADC_SetChannelSamplingTime+0x128>
341859be:	2306      	movs	r3, #6
341859c0:	e00a      	b.n	341859d8 <LL_ADC_SetChannelSamplingTime+0x128>
341859c2:	2305      	movs	r3, #5
341859c4:	e008      	b.n	341859d8 <LL_ADC_SetChannelSamplingTime+0x128>
341859c6:	2304      	movs	r3, #4
341859c8:	e006      	b.n	341859d8 <LL_ADC_SetChannelSamplingTime+0x128>
341859ca:	2303      	movs	r3, #3
341859cc:	e004      	b.n	341859d8 <LL_ADC_SetChannelSamplingTime+0x128>
341859ce:	2302      	movs	r3, #2
341859d0:	e002      	b.n	341859d8 <LL_ADC_SetChannelSamplingTime+0x128>
341859d2:	2301      	movs	r3, #1
341859d4:	e000      	b.n	341859d8 <LL_ADC_SetChannelSamplingTime+0x128>
341859d6:	2300      	movs	r3, #0
341859d8:	617b      	str	r3, [r7, #20]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1,
341859da:	68fb      	ldr	r3, [r7, #12]
341859dc:	3314      	adds	r3, #20
341859de:	4619      	mov	r1, r3
341859e0:	4a15      	ldr	r2, [pc, #84]	@ (34185a38 <LL_ADC_SetChannelSamplingTime+0x188>)
341859e2:	697b      	ldr	r3, [r7, #20]
341859e4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
341859e8:	0e5b      	lsrs	r3, r3, #25
341859ea:	009b      	lsls	r3, r3, #2
341859ec:	f003 0304 	and.w	r3, r3, #4
341859f0:	440b      	add	r3, r1
341859f2:	613b      	str	r3, [r7, #16]
  MODIFY_REG(*preg,
341859f4:	693b      	ldr	r3, [r7, #16]
341859f6:	681a      	ldr	r2, [r3, #0]
341859f8:	490f      	ldr	r1, [pc, #60]	@ (34185a38 <LL_ADC_SetChannelSamplingTime+0x188>)
341859fa:	697b      	ldr	r3, [r7, #20]
341859fc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
34185a00:	0d1b      	lsrs	r3, r3, #20
34185a02:	f003 031f 	and.w	r3, r3, #31
34185a06:	2107      	movs	r1, #7
34185a08:	fa01 f303 	lsl.w	r3, r1, r3
34185a0c:	43db      	mvns	r3, r3
34185a0e:	401a      	ands	r2, r3
34185a10:	4909      	ldr	r1, [pc, #36]	@ (34185a38 <LL_ADC_SetChannelSamplingTime+0x188>)
34185a12:	697b      	ldr	r3, [r7, #20]
34185a14:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
34185a18:	0d1b      	lsrs	r3, r3, #20
34185a1a:	f003 031f 	and.w	r3, r3, #31
34185a1e:	6879      	ldr	r1, [r7, #4]
34185a20:	fa01 f303 	lsl.w	r3, r1, r3
34185a24:	431a      	orrs	r2, r3
34185a26:	693b      	ldr	r3, [r7, #16]
34185a28:	601a      	str	r2, [r3, #0]
}
34185a2a:	bf00      	nop
34185a2c:	371c      	adds	r7, #28
34185a2e:	46bd      	mov	sp, r7
34185a30:	f85d 7b04 	ldr.w	r7, [sp], #4
34185a34:	4770      	bx	lr
34185a36:	bf00      	nop
34185a38:	3419e3d8 	.word	0x3419e3d8

34185a3c <LL_ADC_SetChannelSingleDiff>:
{
34185a3c:	b480      	push	{r7}
34185a3e:	b087      	sub	sp, #28
34185a40:	af00      	add	r7, sp, #0
34185a42:	60f8      	str	r0, [r7, #12]
34185a44:	60b9      	str	r1, [r7, #8]
34185a46:	607a      	str	r2, [r7, #4]
  const uint32_t iChannel = __ADC_CHANNEL_INDEX(Channel);
34185a48:	68bb      	ldr	r3, [r7, #8]
34185a4a:	f003 031f 	and.w	r3, r3, #31
34185a4e:	2b00      	cmp	r3, #0
34185a50:	f000 8087 	beq.w	34185b62 <LL_ADC_SetChannelSingleDiff+0x126>
34185a54:	68bb      	ldr	r3, [r7, #8]
34185a56:	f003 031f 	and.w	r3, r3, #31
34185a5a:	2b01      	cmp	r3, #1
34185a5c:	d07f      	beq.n	34185b5e <LL_ADC_SetChannelSingleDiff+0x122>
34185a5e:	68bb      	ldr	r3, [r7, #8]
34185a60:	f003 031f 	and.w	r3, r3, #31
34185a64:	2b02      	cmp	r3, #2
34185a66:	d078      	beq.n	34185b5a <LL_ADC_SetChannelSingleDiff+0x11e>
34185a68:	68bb      	ldr	r3, [r7, #8]
34185a6a:	f003 031f 	and.w	r3, r3, #31
34185a6e:	2b03      	cmp	r3, #3
34185a70:	d071      	beq.n	34185b56 <LL_ADC_SetChannelSingleDiff+0x11a>
34185a72:	68bb      	ldr	r3, [r7, #8]
34185a74:	f003 031f 	and.w	r3, r3, #31
34185a78:	2b04      	cmp	r3, #4
34185a7a:	d06a      	beq.n	34185b52 <LL_ADC_SetChannelSingleDiff+0x116>
34185a7c:	68bb      	ldr	r3, [r7, #8]
34185a7e:	f003 031f 	and.w	r3, r3, #31
34185a82:	2b05      	cmp	r3, #5
34185a84:	d063      	beq.n	34185b4e <LL_ADC_SetChannelSingleDiff+0x112>
34185a86:	68bb      	ldr	r3, [r7, #8]
34185a88:	f003 031f 	and.w	r3, r3, #31
34185a8c:	2b06      	cmp	r3, #6
34185a8e:	d05c      	beq.n	34185b4a <LL_ADC_SetChannelSingleDiff+0x10e>
34185a90:	68bb      	ldr	r3, [r7, #8]
34185a92:	f003 031f 	and.w	r3, r3, #31
34185a96:	2b07      	cmp	r3, #7
34185a98:	d055      	beq.n	34185b46 <LL_ADC_SetChannelSingleDiff+0x10a>
34185a9a:	68bb      	ldr	r3, [r7, #8]
34185a9c:	f003 031f 	and.w	r3, r3, #31
34185aa0:	2b08      	cmp	r3, #8
34185aa2:	d04e      	beq.n	34185b42 <LL_ADC_SetChannelSingleDiff+0x106>
34185aa4:	68bb      	ldr	r3, [r7, #8]
34185aa6:	f003 031f 	and.w	r3, r3, #31
34185aaa:	2b09      	cmp	r3, #9
34185aac:	d047      	beq.n	34185b3e <LL_ADC_SetChannelSingleDiff+0x102>
34185aae:	68bb      	ldr	r3, [r7, #8]
34185ab0:	f003 031f 	and.w	r3, r3, #31
34185ab4:	2b0a      	cmp	r3, #10
34185ab6:	d040      	beq.n	34185b3a <LL_ADC_SetChannelSingleDiff+0xfe>
34185ab8:	68bb      	ldr	r3, [r7, #8]
34185aba:	f003 031f 	and.w	r3, r3, #31
34185abe:	2b0b      	cmp	r3, #11
34185ac0:	d039      	beq.n	34185b36 <LL_ADC_SetChannelSingleDiff+0xfa>
34185ac2:	68bb      	ldr	r3, [r7, #8]
34185ac4:	f003 031f 	and.w	r3, r3, #31
34185ac8:	2b0c      	cmp	r3, #12
34185aca:	d032      	beq.n	34185b32 <LL_ADC_SetChannelSingleDiff+0xf6>
34185acc:	68bb      	ldr	r3, [r7, #8]
34185ace:	f003 031f 	and.w	r3, r3, #31
34185ad2:	2b0d      	cmp	r3, #13
34185ad4:	d02b      	beq.n	34185b2e <LL_ADC_SetChannelSingleDiff+0xf2>
34185ad6:	68bb      	ldr	r3, [r7, #8]
34185ad8:	f003 031f 	and.w	r3, r3, #31
34185adc:	2b0e      	cmp	r3, #14
34185ade:	d024      	beq.n	34185b2a <LL_ADC_SetChannelSingleDiff+0xee>
34185ae0:	68bb      	ldr	r3, [r7, #8]
34185ae2:	f003 031f 	and.w	r3, r3, #31
34185ae6:	2b0f      	cmp	r3, #15
34185ae8:	d01d      	beq.n	34185b26 <LL_ADC_SetChannelSingleDiff+0xea>
34185aea:	68bb      	ldr	r3, [r7, #8]
34185aec:	f003 031f 	and.w	r3, r3, #31
34185af0:	2b10      	cmp	r3, #16
34185af2:	d016      	beq.n	34185b22 <LL_ADC_SetChannelSingleDiff+0xe6>
34185af4:	68bb      	ldr	r3, [r7, #8]
34185af6:	f003 031f 	and.w	r3, r3, #31
34185afa:	2b11      	cmp	r3, #17
34185afc:	d00f      	beq.n	34185b1e <LL_ADC_SetChannelSingleDiff+0xe2>
34185afe:	68bb      	ldr	r3, [r7, #8]
34185b00:	f003 031f 	and.w	r3, r3, #31
34185b04:	2b12      	cmp	r3, #18
34185b06:	d008      	beq.n	34185b1a <LL_ADC_SetChannelSingleDiff+0xde>
34185b08:	68bb      	ldr	r3, [r7, #8]
34185b0a:	f003 031f 	and.w	r3, r3, #31
34185b0e:	2b13      	cmp	r3, #19
34185b10:	d101      	bne.n	34185b16 <LL_ADC_SetChannelSingleDiff+0xda>
34185b12:	2313      	movs	r3, #19
34185b14:	e026      	b.n	34185b64 <LL_ADC_SetChannelSingleDiff+0x128>
34185b16:	2300      	movs	r3, #0
34185b18:	e024      	b.n	34185b64 <LL_ADC_SetChannelSingleDiff+0x128>
34185b1a:	2312      	movs	r3, #18
34185b1c:	e022      	b.n	34185b64 <LL_ADC_SetChannelSingleDiff+0x128>
34185b1e:	2311      	movs	r3, #17
34185b20:	e020      	b.n	34185b64 <LL_ADC_SetChannelSingleDiff+0x128>
34185b22:	2310      	movs	r3, #16
34185b24:	e01e      	b.n	34185b64 <LL_ADC_SetChannelSingleDiff+0x128>
34185b26:	230f      	movs	r3, #15
34185b28:	e01c      	b.n	34185b64 <LL_ADC_SetChannelSingleDiff+0x128>
34185b2a:	230e      	movs	r3, #14
34185b2c:	e01a      	b.n	34185b64 <LL_ADC_SetChannelSingleDiff+0x128>
34185b2e:	230d      	movs	r3, #13
34185b30:	e018      	b.n	34185b64 <LL_ADC_SetChannelSingleDiff+0x128>
34185b32:	230c      	movs	r3, #12
34185b34:	e016      	b.n	34185b64 <LL_ADC_SetChannelSingleDiff+0x128>
34185b36:	230b      	movs	r3, #11
34185b38:	e014      	b.n	34185b64 <LL_ADC_SetChannelSingleDiff+0x128>
34185b3a:	230a      	movs	r3, #10
34185b3c:	e012      	b.n	34185b64 <LL_ADC_SetChannelSingleDiff+0x128>
34185b3e:	2309      	movs	r3, #9
34185b40:	e010      	b.n	34185b64 <LL_ADC_SetChannelSingleDiff+0x128>
34185b42:	2308      	movs	r3, #8
34185b44:	e00e      	b.n	34185b64 <LL_ADC_SetChannelSingleDiff+0x128>
34185b46:	2307      	movs	r3, #7
34185b48:	e00c      	b.n	34185b64 <LL_ADC_SetChannelSingleDiff+0x128>
34185b4a:	2306      	movs	r3, #6
34185b4c:	e00a      	b.n	34185b64 <LL_ADC_SetChannelSingleDiff+0x128>
34185b4e:	2305      	movs	r3, #5
34185b50:	e008      	b.n	34185b64 <LL_ADC_SetChannelSingleDiff+0x128>
34185b52:	2304      	movs	r3, #4
34185b54:	e006      	b.n	34185b64 <LL_ADC_SetChannelSingleDiff+0x128>
34185b56:	2303      	movs	r3, #3
34185b58:	e004      	b.n	34185b64 <LL_ADC_SetChannelSingleDiff+0x128>
34185b5a:	2302      	movs	r3, #2
34185b5c:	e002      	b.n	34185b64 <LL_ADC_SetChannelSingleDiff+0x128>
34185b5e:	2301      	movs	r3, #1
34185b60:	e000      	b.n	34185b64 <LL_ADC_SetChannelSingleDiff+0x128>
34185b62:	2300      	movs	r3, #0
34185b64:	617b      	str	r3, [r7, #20]
  MODIFY_REG(ADCx->DIFSEL,
34185b66:	68fb      	ldr	r3, [r7, #12]
34185b68:	f8d3 20c0 	ldr.w	r2, [r3, #192]	@ 0xc0
34185b6c:	490f      	ldr	r1, [pc, #60]	@ (34185bac <LL_ADC_SetChannelSingleDiff+0x170>)
34185b6e:	697b      	ldr	r3, [r7, #20]
34185b70:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
34185b74:	f3c3 0313 	ubfx	r3, r3, #0, #20
34185b78:	43db      	mvns	r3, r3
34185b7a:	401a      	ands	r2, r3
34185b7c:	490b      	ldr	r1, [pc, #44]	@ (34185bac <LL_ADC_SetChannelSingleDiff+0x170>)
34185b7e:	697b      	ldr	r3, [r7, #20]
34185b80:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
34185b84:	687b      	ldr	r3, [r7, #4]
34185b86:	f003 0318 	and.w	r3, r3, #24
34185b8a:	4809      	ldr	r0, [pc, #36]	@ (34185bb0 <LL_ADC_SetChannelSingleDiff+0x174>)
34185b8c:	fa20 f303 	lsr.w	r3, r0, r3
34185b90:	400b      	ands	r3, r1
34185b92:	f3c3 0313 	ubfx	r3, r3, #0, #20
34185b96:	431a      	orrs	r2, r3
34185b98:	68fb      	ldr	r3, [r7, #12]
34185b9a:	f8c3 20c0 	str.w	r2, [r3, #192]	@ 0xc0
}
34185b9e:	bf00      	nop
34185ba0:	371c      	adds	r7, #28
34185ba2:	46bd      	mov	sp, r7
34185ba4:	f85d 7b04 	ldr.w	r7, [sp], #4
34185ba8:	4770      	bx	lr
34185baa:	bf00      	nop
34185bac:	3419e3d8 	.word	0x3419e3d8
34185bb0:	000fffff 	.word	0x000fffff

34185bb4 <LL_ADC_GetMultimode>:
{
34185bb4:	b480      	push	{r7}
34185bb6:	b083      	sub	sp, #12
34185bb8:	af00      	add	r7, sp, #0
34185bba:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_DUAL));
34185bbc:	687b      	ldr	r3, [r7, #4]
34185bbe:	689b      	ldr	r3, [r3, #8]
34185bc0:	f003 031f 	and.w	r3, r3, #31
}
34185bc4:	4618      	mov	r0, r3
34185bc6:	370c      	adds	r7, #12
34185bc8:	46bd      	mov	sp, r7
34185bca:	f85d 7b04 	ldr.w	r7, [sp], #4
34185bce:	4770      	bx	lr

34185bd0 <LL_ADC_DisableDeepPowerDown>:
{
34185bd0:	b480      	push	{r7}
34185bd2:	b083      	sub	sp, #12
34185bd4:	af00      	add	r7, sp, #0
34185bd6:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(ADCx->CR, (ADC_CR_DEEPPWD | ADC_CR_BITS_PROPERTY_RS));
34185bd8:	687b      	ldr	r3, [r7, #4]
34185bda:	689b      	ldr	r3, [r3, #8]
34185bdc:	f023 5300 	bic.w	r3, r3, #536870912	@ 0x20000000
34185be0:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
34185be4:	687a      	ldr	r2, [r7, #4]
34185be6:	6093      	str	r3, [r2, #8]
}
34185be8:	bf00      	nop
34185bea:	370c      	adds	r7, #12
34185bec:	46bd      	mov	sp, r7
34185bee:	f85d 7b04 	ldr.w	r7, [sp], #4
34185bf2:	4770      	bx	lr

34185bf4 <LL_ADC_IsDeepPowerDownEnabled>:
{
34185bf4:	b480      	push	{r7}
34185bf6:	b083      	sub	sp, #12
34185bf8:	af00      	add	r7, sp, #0
34185bfa:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_DEEPPWD) == (ADC_CR_DEEPPWD)) ? 1UL : 0UL);
34185bfc:	687b      	ldr	r3, [r7, #4]
34185bfe:	689b      	ldr	r3, [r3, #8]
34185c00:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
34185c04:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34185c08:	d101      	bne.n	34185c0e <LL_ADC_IsDeepPowerDownEnabled+0x1a>
34185c0a:	2301      	movs	r3, #1
34185c0c:	e000      	b.n	34185c10 <LL_ADC_IsDeepPowerDownEnabled+0x1c>
34185c0e:	2300      	movs	r3, #0
}
34185c10:	4618      	mov	r0, r3
34185c12:	370c      	adds	r7, #12
34185c14:	46bd      	mov	sp, r7
34185c16:	f85d 7b04 	ldr.w	r7, [sp], #4
34185c1a:	4770      	bx	lr

34185c1c <LL_ADC_Enable>:
{
34185c1c:	b480      	push	{r7}
34185c1e:	b083      	sub	sp, #12
34185c20:	af00      	add	r7, sp, #0
34185c22:	6078      	str	r0, [r7, #4]
  MODIFY_REG(ADCx->CR,
34185c24:	687b      	ldr	r3, [r7, #4]
34185c26:	689b      	ldr	r3, [r3, #8]
34185c28:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
34185c2c:	f043 0201 	orr.w	r2, r3, #1
34185c30:	687b      	ldr	r3, [r7, #4]
34185c32:	609a      	str	r2, [r3, #8]
}
34185c34:	bf00      	nop
34185c36:	370c      	adds	r7, #12
34185c38:	46bd      	mov	sp, r7
34185c3a:	f85d 7b04 	ldr.w	r7, [sp], #4
34185c3e:	4770      	bx	lr

34185c40 <LL_ADC_IsEnabled>:
{
34185c40:	b480      	push	{r7}
34185c42:	b083      	sub	sp, #12
34185c44:	af00      	add	r7, sp, #0
34185c46:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
34185c48:	687b      	ldr	r3, [r7, #4]
34185c4a:	689b      	ldr	r3, [r3, #8]
34185c4c:	f003 0301 	and.w	r3, r3, #1
34185c50:	2b01      	cmp	r3, #1
34185c52:	d101      	bne.n	34185c58 <LL_ADC_IsEnabled+0x18>
34185c54:	2301      	movs	r3, #1
34185c56:	e000      	b.n	34185c5a <LL_ADC_IsEnabled+0x1a>
34185c58:	2300      	movs	r3, #0
}
34185c5a:	4618      	mov	r0, r3
34185c5c:	370c      	adds	r7, #12
34185c5e:	46bd      	mov	sp, r7
34185c60:	f85d 7b04 	ldr.w	r7, [sp], #4
34185c64:	4770      	bx	lr

34185c66 <LL_ADC_REG_StartConversion>:
{
34185c66:	b480      	push	{r7}
34185c68:	b083      	sub	sp, #12
34185c6a:	af00      	add	r7, sp, #0
34185c6c:	6078      	str	r0, [r7, #4]
  MODIFY_REG(ADCx->CR,
34185c6e:	687b      	ldr	r3, [r7, #4]
34185c70:	689b      	ldr	r3, [r3, #8]
34185c72:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
34185c76:	f043 0204 	orr.w	r2, r3, #4
34185c7a:	687b      	ldr	r3, [r7, #4]
34185c7c:	609a      	str	r2, [r3, #8]
}
34185c7e:	bf00      	nop
34185c80:	370c      	adds	r7, #12
34185c82:	46bd      	mov	sp, r7
34185c84:	f85d 7b04 	ldr.w	r7, [sp], #4
34185c88:	4770      	bx	lr

34185c8a <LL_ADC_REG_IsConversionOngoing>:
{
34185c8a:	b480      	push	{r7}
34185c8c:	b083      	sub	sp, #12
34185c8e:	af00      	add	r7, sp, #0
34185c90:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
34185c92:	687b      	ldr	r3, [r7, #4]
34185c94:	689b      	ldr	r3, [r3, #8]
34185c96:	f003 0304 	and.w	r3, r3, #4
34185c9a:	2b04      	cmp	r3, #4
34185c9c:	d101      	bne.n	34185ca2 <LL_ADC_REG_IsConversionOngoing+0x18>
34185c9e:	2301      	movs	r3, #1
34185ca0:	e000      	b.n	34185ca4 <LL_ADC_REG_IsConversionOngoing+0x1a>
34185ca2:	2300      	movs	r3, #0
}
34185ca4:	4618      	mov	r0, r3
34185ca6:	370c      	adds	r7, #12
34185ca8:	46bd      	mov	sp, r7
34185caa:	f85d 7b04 	ldr.w	r7, [sp], #4
34185cae:	4770      	bx	lr

34185cb0 <LL_ADC_INJ_IsConversionOngoing>:
  * @rmtoll CR       JADSTART       LL_ADC_INJ_IsConversionOngoing
  * @param  ADCx ADC instance
  * @retval 0: no conversion is on going on ADC group injected.
  */
__STATIC_INLINE uint32_t LL_ADC_INJ_IsConversionOngoing(const ADC_TypeDef *ADCx)
{
34185cb0:	b480      	push	{r7}
34185cb2:	b083      	sub	sp, #12
34185cb4:	af00      	add	r7, sp, #0
34185cb6:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
34185cb8:	687b      	ldr	r3, [r7, #4]
34185cba:	689b      	ldr	r3, [r3, #8]
34185cbc:	f003 0308 	and.w	r3, r3, #8
34185cc0:	2b08      	cmp	r3, #8
34185cc2:	d101      	bne.n	34185cc8 <LL_ADC_INJ_IsConversionOngoing+0x18>
34185cc4:	2301      	movs	r3, #1
34185cc6:	e000      	b.n	34185cca <LL_ADC_INJ_IsConversionOngoing+0x1a>
34185cc8:	2300      	movs	r3, #0
}
34185cca:	4618      	mov	r0, r3
34185ccc:	370c      	adds	r7, #12
34185cce:	46bd      	mov	sp, r7
34185cd0:	f85d 7b04 	ldr.w	r7, [sp], #4
34185cd4:	4770      	bx	lr
	...

34185cd8 <HAL_ADC_Init>:
  *         without disabling the other ADCs sharing the same ADC common instance.
  * @param hadc ADC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef *hadc)
{
34185cd8:	b580      	push	{r7, lr}
34185cda:	b088      	sub	sp, #32
34185cdc:	af00      	add	r7, sp, #0
34185cde:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
34185ce0:	2300      	movs	r3, #0
34185ce2:	77fb      	strb	r3, [r7, #31]
  uint32_t tmp_adc_reg_is_conversion_on_going;
  uint32_t tmp_adc_is_conversion_on_going_regular;
  uint32_t tmp_adc_is_conversion_on_going_injected;

  /* Check ADC handle */
  if (hadc == NULL)
34185ce4:	687b      	ldr	r3, [r7, #4]
34185ce6:	2b00      	cmp	r3, #0
34185ce8:	d101      	bne.n	34185cee <HAL_ADC_Init+0x16>
  {
    return HAL_ERROR;
34185cea:	2301      	movs	r3, #1
34185cec:	e108      	b.n	34185f00 <HAL_ADC_Init+0x228>
  assert_param(IS_ADC_EOC_SELECTION(hadc->Init.EOCSelection));
  assert_param(IS_ADC_OVERRUN(hadc->Init.Overrun));
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.LowPowerAutoWait));
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.OversamplingMode));

  if (hadc->Init.ScanConvMode != ADC_SCAN_DISABLE)
34185cee:	687b      	ldr	r3, [r7, #4]
34185cf0:	68db      	ldr	r3, [r3, #12]
34185cf2:	2b00      	cmp	r3, #0
  /* DISCEN and CONT bits cannot be set at the same time */
  assert_param(!((hadc->Init.DiscontinuousConvMode == ENABLE) && (hadc->Init.ContinuousConvMode == ENABLE)));

  /* Actions performed only if ADC is coming from state reset:                */
  /* - Initialization of ADC MSP                                              */
  if (hadc->State == HAL_ADC_STATE_RESET)
34185cf4:	687b      	ldr	r3, [r7, #4]
34185cf6:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34185cf8:	2b00      	cmp	r3, #0
34185cfa:	d109      	bne.n	34185d10 <HAL_ADC_Init+0x38>

    /* Init the low level hardware */
    hadc->MspInitCallback(hadc);
#else
    /* Init the low level hardware */
    HAL_ADC_MspInit(hadc);
34185cfc:	6878      	ldr	r0, [r7, #4]
34185cfe:	f000 f907 	bl	34185f10 <HAL_ADC_MspInit>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */

    /* Set ADC error code to none */
    ADC_CLEAR_ERRORCODE(hadc);
34185d02:	687b      	ldr	r3, [r7, #4]
34185d04:	2200      	movs	r2, #0
34185d06:	65da      	str	r2, [r3, #92]	@ 0x5c

    /* Initialize Lock */
    hadc->Lock = HAL_UNLOCKED;
34185d08:	687b      	ldr	r3, [r7, #4]
34185d0a:	2200      	movs	r2, #0
34185d0c:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54
  }

  /* ADC must be disabled to set configuration bits                            */
  if (LL_ADC_IsEnabled(hadc->Instance) != 0UL)
34185d10:	687b      	ldr	r3, [r7, #4]
34185d12:	681b      	ldr	r3, [r3, #0]
34185d14:	4618      	mov	r0, r3
34185d16:	f7ff ff93 	bl	34185c40 <LL_ADC_IsEnabled>
34185d1a:	4603      	mov	r3, r0
34185d1c:	2b00      	cmp	r3, #0
34185d1e:	d001      	beq.n	34185d24 <HAL_ADC_Init+0x4c>
  {
    return HAL_ERROR;
34185d20:	2301      	movs	r3, #1
34185d22:	e0ed      	b.n	34185f00 <HAL_ADC_Init+0x228>
  }

  /* - Exit from deep-power-down mode and ADC voltage regulator enable        */
  if (LL_ADC_IsDeepPowerDownEnabled(hadc->Instance) != 0UL)
34185d24:	687b      	ldr	r3, [r7, #4]
34185d26:	681b      	ldr	r3, [r3, #0]
34185d28:	4618      	mov	r0, r3
34185d2a:	f7ff ff63 	bl	34185bf4 <LL_ADC_IsDeepPowerDownEnabled>
34185d2e:	4603      	mov	r3, r0
34185d30:	2b00      	cmp	r3, #0
34185d32:	d004      	beq.n	34185d3e <HAL_ADC_Init+0x66>
  {
    /* Disable ADC deep power down mode */
    LL_ADC_DisableDeepPowerDown(hadc->Instance);
34185d34:	687b      	ldr	r3, [r7, #4]
34185d36:	681b      	ldr	r3, [r3, #0]
34185d38:	4618      	mov	r0, r3
34185d3a:	f7ff ff49 	bl	34185bd0 <LL_ADC_DisableDeepPowerDown>
  }
  /* Configuration of ADC parameters if previous preliminary actions are      */
  /* correctly completed and if there is no conversion on going on regular    */
  /* group (ADC may already be enabled at this point if HAL_ADC_Init() is     */
  /* called to update a parameter on the fly).                                */
  tmp_adc_reg_is_conversion_on_going = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
34185d3e:	687b      	ldr	r3, [r7, #4]
34185d40:	681b      	ldr	r3, [r3, #0]
34185d42:	4618      	mov	r0, r3
34185d44:	f7ff ffa1 	bl	34185c8a <LL_ADC_REG_IsConversionOngoing>
34185d48:	6178      	str	r0, [r7, #20]

  if (((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
34185d4a:	687b      	ldr	r3, [r7, #4]
34185d4c:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34185d4e:	f003 0310 	and.w	r3, r3, #16
34185d52:	2b00      	cmp	r3, #0
34185d54:	f040 80cb 	bne.w	34185eee <HAL_ADC_Init+0x216>
      && (tmp_adc_reg_is_conversion_on_going == 0UL)
34185d58:	697b      	ldr	r3, [r7, #20]
34185d5a:	2b00      	cmp	r3, #0
34185d5c:	f040 80c7 	bne.w	34185eee <HAL_ADC_Init+0x216>
     )
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
34185d60:	687b      	ldr	r3, [r7, #4]
34185d62:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34185d64:	f423 7381 	bic.w	r3, r3, #258	@ 0x102
34185d68:	f043 0202 	orr.w	r2, r3, #2
34185d6c:	687b      	ldr	r3, [r7, #4]
34185d6e:	659a      	str	r2, [r3, #88]	@ 0x58
    /*  - continuous conversion mode               Init.ContinuousConvMode    */
    /*  - overrun                                  Init.Overrun               */
    /*  - discontinuous mode                       Init.DiscontinuousConvMode */
    /*  - discontinuous mode channel count         Init.NbrOfDiscConversion   */

    tmpCFGR1 = (ADC_CFGR1_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)         |
34185d70:	687b      	ldr	r3, [r7, #4]
34185d72:	7d5b      	ldrb	r3, [r3, #21]
34185d74:	035a      	lsls	r2, r3, #13
                hadc->Init.Overrun                                                    |
34185d76:	687b      	ldr	r3, [r7, #4]
34185d78:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
    tmpCFGR1 = (ADC_CFGR1_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)         |
34185d7a:	431a      	orrs	r2, r3
                hadc->Init.Resolution                                                 |
34185d7c:	687b      	ldr	r3, [r7, #4]
34185d7e:	685b      	ldr	r3, [r3, #4]
                hadc->Init.Overrun                                                    |
34185d80:	431a      	orrs	r2, r3
                ADC_CFGR1_REG_DISCONTINUOUS((uint32_t)hadc->Init.DiscontinuousConvMode));
34185d82:	687b      	ldr	r3, [r7, #4]
34185d84:	7f1b      	ldrb	r3, [r3, #28]
34185d86:	041b      	lsls	r3, r3, #16
    tmpCFGR1 = (ADC_CFGR1_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)         |
34185d88:	4313      	orrs	r3, r2
34185d8a:	61bb      	str	r3, [r7, #24]

    if (hadc->Init.DiscontinuousConvMode == ENABLE)
34185d8c:	687b      	ldr	r3, [r7, #4]
34185d8e:	7f1b      	ldrb	r3, [r3, #28]
34185d90:	2b01      	cmp	r3, #1
34185d92:	d106      	bne.n	34185da2 <HAL_ADC_Init+0xca>
    {
      tmpCFGR1 |= ADC_CFGR1_DISCONTINUOUS_NUM(hadc->Init.NbrOfDiscConversion);
34185d94:	687b      	ldr	r3, [r7, #4]
34185d96:	6a1b      	ldr	r3, [r3, #32]
34185d98:	3b01      	subs	r3, #1
34185d9a:	045b      	lsls	r3, r3, #17
34185d9c:	69ba      	ldr	r2, [r7, #24]
34185d9e:	4313      	orrs	r3, r2
34185da0:	61bb      	str	r3, [r7, #24]
    /* Enable external trigger if trigger selection is different of software  */
    /* start.                                                                 */
    /* Note: This configuration keeps the hardware feature of parameter       */
    /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
    /*       software start.                                                  */
    if (hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
34185da2:	687b      	ldr	r3, [r7, #4]
34185da4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34185da6:	2b00      	cmp	r3, #0
34185da8:	d009      	beq.n	34185dbe <HAL_ADC_Init+0xe6>
    {
      tmpCFGR1 |= ((hadc->Init.ExternalTrigConv & ADC_CFGR1_EXTSEL)
34185daa:	687b      	ldr	r3, [r7, #4]
34185dac:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34185dae:	f403 7278 	and.w	r2, r3, #992	@ 0x3e0
                   | hadc->Init.ExternalTrigConvEdge
34185db2:	687b      	ldr	r3, [r7, #4]
34185db4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34185db6:	4313      	orrs	r3, r2
      tmpCFGR1 |= ((hadc->Init.ExternalTrigConv & ADC_CFGR1_EXTSEL)
34185db8:	69ba      	ldr	r2, [r7, #24]
34185dba:	4313      	orrs	r3, r2
34185dbc:	61bb      	str	r3, [r7, #24]
                  );
    }

    /* Update Configuration Register CFGR */
    MODIFY_REG(hadc->Instance->CFGR1, ADC_CFGR1_FIELDS_1, tmpCFGR1);
34185dbe:	687b      	ldr	r3, [r7, #4]
34185dc0:	681b      	ldr	r3, [r3, #0]
34185dc2:	68da      	ldr	r2, [r3, #12]
34185dc4:	4b50      	ldr	r3, [pc, #320]	@ (34185f08 <HAL_ADC_Init+0x230>)
34185dc6:	4013      	ands	r3, r2
34185dc8:	687a      	ldr	r2, [r7, #4]
34185dca:	6812      	ldr	r2, [r2, #0]
34185dcc:	69b9      	ldr	r1, [r7, #24]
34185dce:	430b      	orrs	r3, r1
34185dd0:	60d3      	str	r3, [r2, #12]

    /* Configuration of sampling mode */
    MODIFY_REG(hadc->Instance->CFGR2, ADC_CFGR2_BULB | ADC_CFGR2_SMPTRIG, hadc->Init.SamplingMode);
34185dd2:	687b      	ldr	r3, [r7, #4]
34185dd4:	681b      	ldr	r3, [r3, #0]
34185dd6:	691b      	ldr	r3, [r3, #16]
34185dd8:	f423 4120 	bic.w	r1, r3, #40960	@ 0xa000
34185ddc:	687b      	ldr	r3, [r7, #4]
34185dde:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
34185de0:	687b      	ldr	r3, [r7, #4]
34185de2:	681b      	ldr	r3, [r3, #0]
34185de4:	430a      	orrs	r2, r1
34185de6:	611a      	str	r2, [r3, #16]
    /* Parameters that can be updated when ADC is disabled or enabled without */
    /* conversion on going on regular and injected groups:                    */
    /*  - Conversion data management      Init.ConversionDataManagement       */
    /*  - LowPowerAutoWait feature        Init.LowPowerAutoWait               */
    /*  - Oversampling parameters         Init.Oversampling                   */
    tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
34185de8:	687b      	ldr	r3, [r7, #4]
34185dea:	681b      	ldr	r3, [r3, #0]
34185dec:	4618      	mov	r0, r3
34185dee:	f7ff ff4c 	bl	34185c8a <LL_ADC_REG_IsConversionOngoing>
34185df2:	6138      	str	r0, [r7, #16]
    tmp_adc_is_conversion_on_going_injected = LL_ADC_INJ_IsConversionOngoing(hadc->Instance);
34185df4:	687b      	ldr	r3, [r7, #4]
34185df6:	681b      	ldr	r3, [r3, #0]
34185df8:	4618      	mov	r0, r3
34185dfa:	f7ff ff59 	bl	34185cb0 <LL_ADC_INJ_IsConversionOngoing>
34185dfe:	60f8      	str	r0, [r7, #12]
    if ((tmp_adc_is_conversion_on_going_regular == 0UL)
34185e00:	693b      	ldr	r3, [r7, #16]
34185e02:	2b00      	cmp	r3, #0
34185e04:	d151      	bne.n	34185eaa <HAL_ADC_Init+0x1d2>
        && (tmp_adc_is_conversion_on_going_injected == 0UL)
34185e06:	68fb      	ldr	r3, [r7, #12]
34185e08:	2b00      	cmp	r3, #0
34185e0a:	d14e      	bne.n	34185eaa <HAL_ADC_Init+0x1d2>
       )
    {
      tmpCFGR1 = (
                   ADC_CFGR1_AUTODELAY((uint32_t)hadc->Init.LowPowerAutoWait)        |
34185e0c:	687b      	ldr	r3, [r7, #4]
34185e0e:	7d1b      	ldrb	r3, [r3, #20]
34185e10:	039a      	lsls	r2, r3, #14
                   ADC_CFGR1_DMACONTREQ((uint32_t)hadc->Init.ConversionDataManagement));
34185e12:	687b      	ldr	r3, [r7, #4]
34185e14:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
      tmpCFGR1 = (
34185e16:	4313      	orrs	r3, r2
34185e18:	61bb      	str	r3, [r7, #24]

      MODIFY_REG(hadc->Instance->CFGR1, ADC_CFGR1_FIELDS_2, tmpCFGR1);
34185e1a:	687b      	ldr	r3, [r7, #4]
34185e1c:	681b      	ldr	r3, [r3, #0]
34185e1e:	68db      	ldr	r3, [r3, #12]
34185e20:	f423 4380 	bic.w	r3, r3, #16384	@ 0x4000
34185e24:	f023 0303 	bic.w	r3, r3, #3
34185e28:	687a      	ldr	r2, [r7, #4]
34185e2a:	6812      	ldr	r2, [r2, #0]
34185e2c:	69b9      	ldr	r1, [r7, #24]
34185e2e:	430b      	orrs	r3, r1
34185e30:	60d3      	str	r3, [r2, #12]

      LL_ADC_SetGainCompensation(hadc->Instance, hadc->Init.GainCompensation);
34185e32:	687b      	ldr	r3, [r7, #4]
34185e34:	681a      	ldr	r2, [r3, #0]
34185e36:	687b      	ldr	r3, [r7, #4]
34185e38:	689b      	ldr	r3, [r3, #8]
34185e3a:	4619      	mov	r1, r3
34185e3c:	4610      	mov	r0, r2
34185e3e:	f7ff fcd1 	bl	341857e4 <LL_ADC_SetGainCompensation>

      if (hadc->Init.OversamplingMode == ENABLE)
34185e42:	687b      	ldr	r3, [r7, #4]
34185e44:	f893 303c 	ldrb.w	r3, [r3, #60]	@ 0x3c
34185e48:	2b01      	cmp	r3, #1
34185e4a:	d11b      	bne.n	34185e84 <HAL_ADC_Init+0x1ac>
        assert_param(IS_ADC_OVERSAMPLING_RATIO(hadc->Init.Oversampling.Ratio));
        assert_param(IS_ADC_RIGHT_BIT_SHIFT(hadc->Init.Oversampling.RightBitShift));
        assert_param(IS_ADC_TRIGGERED_OVERSAMPLING_MODE(hadc->Init.Oversampling.TriggeredMode));
        assert_param(IS_ADC_REGOVERSAMPLING_MODE(hadc->Init.Oversampling.OversamplingStopReset));

        if ((hadc->Init.ExternalTrigConv == ADC_SOFTWARE_START)
34185e4c:	687b      	ldr	r3, [r7, #4]
34185e4e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34185e50:	2b00      	cmp	r3, #0
        /*  - Oversampling Ratio                                               */
        /*  - Right bit shift                                                  */
        /*  - Left bit shift                                                   */
        /*  - Triggered mode                                                   */
        /*  - Oversampling mode (continued/resumed)                            */
        MODIFY_REG(hadc->Instance->CFGR2, ADC_CFGR2_FIELDS,
34185e52:	687b      	ldr	r3, [r7, #4]
34185e54:	681b      	ldr	r3, [r3, #0]
34185e56:	691a      	ldr	r2, [r3, #16]
34185e58:	4b2c      	ldr	r3, [pc, #176]	@ (34185f0c <HAL_ADC_Init+0x234>)
34185e5a:	4013      	ands	r3, r2
34185e5c:	687a      	ldr	r2, [r7, #4]
34185e5e:	6c12      	ldr	r2, [r2, #64]	@ 0x40
34185e60:	3a01      	subs	r2, #1
34185e62:	0411      	lsls	r1, r2, #16
34185e64:	687a      	ldr	r2, [r7, #4]
34185e66:	6c52      	ldr	r2, [r2, #68]	@ 0x44
34185e68:	4311      	orrs	r1, r2
34185e6a:	687a      	ldr	r2, [r7, #4]
34185e6c:	6c92      	ldr	r2, [r2, #72]	@ 0x48
34185e6e:	4311      	orrs	r1, r2
34185e70:	687a      	ldr	r2, [r7, #4]
34185e72:	6cd2      	ldr	r2, [r2, #76]	@ 0x4c
34185e74:	430a      	orrs	r2, r1
34185e76:	431a      	orrs	r2, r3
34185e78:	687b      	ldr	r3, [r7, #4]
34185e7a:	681b      	ldr	r3, [r3, #0]
34185e7c:	f042 0201 	orr.w	r2, r2, #1
34185e80:	611a      	str	r2, [r3, #16]
34185e82:	e007      	b.n	34185e94 <HAL_ADC_Init+0x1bc>

      }
      else
      {
        /* Disable ADC oversampling scope on ADC group regular */
        CLEAR_BIT(hadc->Instance->CFGR2, ADC_CFGR2_ROVSE);
34185e84:	687b      	ldr	r3, [r7, #4]
34185e86:	681b      	ldr	r3, [r3, #0]
34185e88:	691a      	ldr	r2, [r3, #16]
34185e8a:	687b      	ldr	r3, [r7, #4]
34185e8c:	681b      	ldr	r3, [r3, #0]
34185e8e:	f022 0201 	bic.w	r2, r2, #1
34185e92:	611a      	str	r2, [r3, #16]
      }

      /* Set the LeftShift parameter: it is applied to the final result with or without oversampling */
      MODIFY_REG(hadc->Instance->CFGR2, ADC_CFGR2_LSHIFT, hadc->Init.LeftBitShift);
34185e94:	687b      	ldr	r3, [r7, #4]
34185e96:	681b      	ldr	r3, [r3, #0]
34185e98:	691b      	ldr	r3, [r3, #16]
34185e9a:	f023 4170 	bic.w	r1, r3, #4026531840	@ 0xf0000000
34185e9e:	687b      	ldr	r3, [r7, #4]
34185ea0:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
34185ea2:	687b      	ldr	r3, [r7, #4]
34185ea4:	681b      	ldr	r3, [r3, #0]
34185ea6:	430a      	orrs	r2, r1
34185ea8:	611a      	str	r2, [r3, #16]
    /*   Note: Scan mode is not present by hardware on this device, but       */
    /*   emulated by software for alignment over all STM32 devices.           */
    /* - if scan mode is enabled, regular channels sequence length is set to  */
    /*   parameter "NbrOfConversion".                                         */

    if (hadc->Init.ScanConvMode == ADC_SCAN_ENABLE)
34185eaa:	687b      	ldr	r3, [r7, #4]
34185eac:	68db      	ldr	r3, [r3, #12]
34185eae:	2b01      	cmp	r3, #1
34185eb0:	d10c      	bne.n	34185ecc <HAL_ADC_Init+0x1f4>
    {
      /* Set number of ranks in regular group sequencer */
      MODIFY_REG(hadc->Instance->SQR1, ADC_SQR1_L, (hadc->Init.NbrOfConversion - (uint8_t)1));
34185eb2:	687b      	ldr	r3, [r7, #4]
34185eb4:	681b      	ldr	r3, [r3, #0]
34185eb6:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34185eb8:	f023 010f 	bic.w	r1, r3, #15
34185ebc:	687b      	ldr	r3, [r7, #4]
34185ebe:	699b      	ldr	r3, [r3, #24]
34185ec0:	1e5a      	subs	r2, r3, #1
34185ec2:	687b      	ldr	r3, [r7, #4]
34185ec4:	681b      	ldr	r3, [r3, #0]
34185ec6:	430a      	orrs	r2, r1
34185ec8:	631a      	str	r2, [r3, #48]	@ 0x30
34185eca:	e007      	b.n	34185edc <HAL_ADC_Init+0x204>
    }
    else
    {
      CLEAR_BIT(hadc->Instance->SQR1, ADC_SQR1_L);
34185ecc:	687b      	ldr	r3, [r7, #4]
34185ece:	681b      	ldr	r3, [r3, #0]
34185ed0:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
34185ed2:	687b      	ldr	r3, [r7, #4]
34185ed4:	681b      	ldr	r3, [r3, #0]
34185ed6:	f022 020f 	bic.w	r2, r2, #15
34185eda:	631a      	str	r2, [r3, #48]	@ 0x30
    }

    /* Initialize the ADC state */
    /* Clear HAL_ADC_STATE_BUSY_INTERNAL bit, set HAL_ADC_STATE_READY bit */
    ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL, HAL_ADC_STATE_READY);
34185edc:	687b      	ldr	r3, [r7, #4]
34185ede:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34185ee0:	f023 0303 	bic.w	r3, r3, #3
34185ee4:	f043 0201 	orr.w	r2, r3, #1
34185ee8:	687b      	ldr	r3, [r7, #4]
34185eea:	659a      	str	r2, [r3, #88]	@ 0x58
34185eec:	e007      	b.n	34185efe <HAL_ADC_Init+0x226>
  }
  else
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
34185eee:	687b      	ldr	r3, [r7, #4]
34185ef0:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34185ef2:	f043 0210 	orr.w	r2, r3, #16
34185ef6:	687b      	ldr	r3, [r7, #4]
34185ef8:	659a      	str	r2, [r3, #88]	@ 0x58

    tmp_hal_status = HAL_ERROR;
34185efa:	2301      	movs	r3, #1
34185efc:	77fb      	strb	r3, [r7, #31]
  }

  return tmp_hal_status;
34185efe:	7ffb      	ldrb	r3, [r7, #31]
}
34185f00:	4618      	mov	r0, r3
34185f02:	3720      	adds	r7, #32
34185f04:	46bd      	mov	sp, r7
34185f06:	bd80      	pop	{r7, pc}
34185f08:	fff0c013 	.word	0xfff0c013
34185f0c:	fc00f81e 	.word	0xfc00f81e

34185f10 <HAL_ADC_MspInit>:
  * @brief  Initialize the ADC MSP.
  * @param hadc ADC handle
  * @retval None
  */
__weak void HAL_ADC_MspInit(ADC_HandleTypeDef *hadc)
{
34185f10:	b480      	push	{r7}
34185f12:	b083      	sub	sp, #12
34185f14:	af00      	add	r7, sp, #0
34185f16:	6078      	str	r0, [r7, #4]
  UNUSED(hadc);

  /* NOTE : This function should not be modified. When the callback is needed,
            function HAL_ADC_MspInit must be implemented in the user file.
   */
}
34185f18:	bf00      	nop
34185f1a:	370c      	adds	r7, #12
34185f1c:	46bd      	mov	sp, r7
34185f1e:	f85d 7b04 	ldr.w	r7, [sp], #4
34185f22:	4770      	bx	lr

34185f24 <HAL_ADC_Start>:
  *           if ADC is master, ADC is enabled and multimode conversion is started.
  * @param hadc ADC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Start(ADC_HandleTypeDef *hadc)
{
34185f24:	b580      	push	{r7, lr}
34185f26:	b086      	sub	sp, #24
34185f28:	af00      	add	r7, sp, #0
34185f2a:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef tmp_hal_status;
#if defined(ADC_MULTIMODE_SUPPORT)
  const ADC_TypeDef *tmpADC_Master;
  uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
34185f2c:	4857      	ldr	r0, [pc, #348]	@ (3418608c <HAL_ADC_Start+0x168>)
34185f2e:	f7ff fe41 	bl	34185bb4 <LL_ADC_GetMultimode>
34185f32:	6138      	str	r0, [r7, #16]

  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));

  /* Perform ADC enable and conversion start if no conversion is on going */
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
34185f34:	687b      	ldr	r3, [r7, #4]
34185f36:	681b      	ldr	r3, [r3, #0]
34185f38:	4618      	mov	r0, r3
34185f3a:	f7ff fea6 	bl	34185c8a <LL_ADC_REG_IsConversionOngoing>
34185f3e:	4603      	mov	r3, r0
34185f40:	2b00      	cmp	r3, #0
34185f42:	f040 809c 	bne.w	3418607e <HAL_ADC_Start+0x15a>
  {
    /* Process locked */
    __HAL_LOCK(hadc);
34185f46:	687b      	ldr	r3, [r7, #4]
34185f48:	f893 3054 	ldrb.w	r3, [r3, #84]	@ 0x54
34185f4c:	2b01      	cmp	r3, #1
34185f4e:	d101      	bne.n	34185f54 <HAL_ADC_Start+0x30>
34185f50:	2302      	movs	r3, #2
34185f52:	e097      	b.n	34186084 <HAL_ADC_Start+0x160>
34185f54:	687b      	ldr	r3, [r7, #4]
34185f56:	2201      	movs	r2, #1
34185f58:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

    /* Enable the ADC peripheral */
    tmp_hal_status = ADC_Enable(hadc);
34185f5c:	6878      	ldr	r0, [r7, #4]
34185f5e:	f000 fa9d 	bl	3418649c <ADC_Enable>
34185f62:	4603      	mov	r3, r0
34185f64:	75fb      	strb	r3, [r7, #23]

    /* Start conversion if ADC is effectively enabled */
    if (tmp_hal_status == HAL_OK)
34185f66:	7dfb      	ldrb	r3, [r7, #23]
34185f68:	2b00      	cmp	r3, #0
34185f6a:	f040 8083 	bne.w	34186074 <HAL_ADC_Start+0x150>
    {
      /* Set ADC state                                                        */
      /* - Clear state bitfield related to regular group conversion results   */
      /* - Set state bitfield related to regular operation                    */
      ADC_STATE_CLR_SET(hadc->State,
34185f6e:	687b      	ldr	r3, [r7, #4]
34185f70:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34185f72:	f423 6370 	bic.w	r3, r3, #3840	@ 0xf00
34185f76:	f023 0301 	bic.w	r3, r3, #1
34185f7a:	f443 7280 	orr.w	r2, r3, #256	@ 0x100
34185f7e:	687b      	ldr	r3, [r7, #4]
34185f80:	659a      	str	r2, [r3, #88]	@ 0x58

#if defined(ADC_MULTIMODE_SUPPORT)
      /* Reset HAL_ADC_STATE_MULTIMODE_SLAVE bit
        - if ADC instance is master or if multimode feature is not available
        - if multimode setting is disabled (ADC instance slave in independent mode) */
      if ((__LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance) == hadc->Instance)
34185f82:	687b      	ldr	r3, [r7, #4]
34185f84:	681b      	ldr	r3, [r3, #0]
34185f86:	4a42      	ldr	r2, [pc, #264]	@ (34186090 <HAL_ADC_Start+0x16c>)
34185f88:	4293      	cmp	r3, r2
34185f8a:	d002      	beq.n	34185f92 <HAL_ADC_Start+0x6e>
34185f8c:	687b      	ldr	r3, [r7, #4]
34185f8e:	681b      	ldr	r3, [r3, #0]
34185f90:	e000      	b.n	34185f94 <HAL_ADC_Start+0x70>
34185f92:	4b40      	ldr	r3, [pc, #256]	@ (34186094 <HAL_ADC_Start+0x170>)
34185f94:	687a      	ldr	r2, [r7, #4]
34185f96:	6812      	ldr	r2, [r2, #0]
34185f98:	4293      	cmp	r3, r2
34185f9a:	d002      	beq.n	34185fa2 <HAL_ADC_Start+0x7e>
          || (tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
34185f9c:	693b      	ldr	r3, [r7, #16]
34185f9e:	2b00      	cmp	r3, #0
34185fa0:	d105      	bne.n	34185fae <HAL_ADC_Start+0x8a>
         )
      {
        CLEAR_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
34185fa2:	687b      	ldr	r3, [r7, #4]
34185fa4:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34185fa6:	f423 1280 	bic.w	r2, r3, #1048576	@ 0x100000
34185faa:	687b      	ldr	r3, [r7, #4]
34185fac:	659a      	str	r2, [r3, #88]	@ 0x58
      }
#endif /* ADC_MULTIMODE_SUPPORT */

      /* Set ADC error code */
      /* Check if a conversion is on going on ADC group injected */
      if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_INJ_BUSY))
34185fae:	687b      	ldr	r3, [r7, #4]
34185fb0:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34185fb2:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
34185fb6:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34185fba:	d106      	bne.n	34185fca <HAL_ADC_Start+0xa6>
      {
        /* Reset ADC error code fields related to regular conversions only */
        CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));
34185fbc:	687b      	ldr	r3, [r7, #4]
34185fbe:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
34185fc0:	f023 0206 	bic.w	r2, r3, #6
34185fc4:	687b      	ldr	r3, [r7, #4]
34185fc6:	65da      	str	r2, [r3, #92]	@ 0x5c
34185fc8:	e002      	b.n	34185fd0 <HAL_ADC_Start+0xac>
      }
      else
      {
        /* Reset all ADC error code fields */
        ADC_CLEAR_ERRORCODE(hadc);
34185fca:	687b      	ldr	r3, [r7, #4]
34185fcc:	2200      	movs	r2, #0
34185fce:	65da      	str	r2, [r3, #92]	@ 0x5c
      }

      /* Clear ADC group regular conversion flag and overrun flag               */
      /* (To ensure of no unknown state from potential previous ADC operations) */
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
34185fd0:	687b      	ldr	r3, [r7, #4]
34185fd2:	681b      	ldr	r3, [r3, #0]
34185fd4:	221c      	movs	r2, #28
34185fd6:	601a      	str	r2, [r3, #0]

      /* Unlock before starting ADC conversions: in case of potential         */
      /* interruption, to let the process to ADC IRQ Handler.                 */
      __HAL_UNLOCK(hadc);
34185fd8:	687b      	ldr	r3, [r7, #4]
34185fda:	2200      	movs	r2, #0
34185fdc:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54
      /* Case of multimode enabled (when multimode feature is available):     */
      /*  - if ADC is slave and dual regular conversions are enabled, ADC is  */
      /*    enabled only (conversion is not started),                         */
      /*  - if ADC is master, ADC is enabled and conversion is started.       */
#if defined(ADC_MULTIMODE_SUPPORT)
      if ((__LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance) == hadc->Instance)
34185fe0:	687b      	ldr	r3, [r7, #4]
34185fe2:	681b      	ldr	r3, [r3, #0]
34185fe4:	4a2a      	ldr	r2, [pc, #168]	@ (34186090 <HAL_ADC_Start+0x16c>)
34185fe6:	4293      	cmp	r3, r2
34185fe8:	d002      	beq.n	34185ff0 <HAL_ADC_Start+0xcc>
34185fea:	687b      	ldr	r3, [r7, #4]
34185fec:	681b      	ldr	r3, [r3, #0]
34185fee:	e000      	b.n	34185ff2 <HAL_ADC_Start+0xce>
34185ff0:	4b28      	ldr	r3, [pc, #160]	@ (34186094 <HAL_ADC_Start+0x170>)
34185ff2:	687a      	ldr	r2, [r7, #4]
34185ff4:	6812      	ldr	r2, [r2, #0]
34185ff6:	4293      	cmp	r3, r2
34185ff8:	d008      	beq.n	3418600c <HAL_ADC_Start+0xe8>
          || (tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
34185ffa:	693b      	ldr	r3, [r7, #16]
34185ffc:	2b00      	cmp	r3, #0
34185ffe:	d005      	beq.n	3418600c <HAL_ADC_Start+0xe8>
          || (tmp_multimode_config == LL_ADC_MULTI_DUAL_INJ_SIMULT)
34186000:	693b      	ldr	r3, [r7, #16]
34186002:	2b05      	cmp	r3, #5
34186004:	d002      	beq.n	3418600c <HAL_ADC_Start+0xe8>
          || (tmp_multimode_config == LL_ADC_MULTI_DUAL_INJ_ALTERN)
34186006:	693b      	ldr	r3, [r7, #16]
34186008:	2b09      	cmp	r3, #9
3418600a:	d114      	bne.n	34186036 <HAL_ADC_Start+0x112>
         )
      {
        /* ADC instance is not a multimode slave instance with multimode regular conversions enabled */
        if (READ_BIT(hadc->Instance->CFGR1, ADC_CFGR1_JAUTO) != 0UL)
3418600c:	687b      	ldr	r3, [r7, #4]
3418600e:	681b      	ldr	r3, [r3, #0]
34186010:	68db      	ldr	r3, [r3, #12]
34186012:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
34186016:	2b00      	cmp	r3, #0
34186018:	d007      	beq.n	3418602a <HAL_ADC_Start+0x106>
        {
          ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);
3418601a:	687b      	ldr	r3, [r7, #4]
3418601c:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
3418601e:	f423 5340 	bic.w	r3, r3, #12288	@ 0x3000
34186022:	f443 5280 	orr.w	r2, r3, #4096	@ 0x1000
34186026:	687b      	ldr	r3, [r7, #4]
34186028:	659a      	str	r2, [r3, #88]	@ 0x58
        }

        /* Start ADC group regular conversion */
        LL_ADC_REG_StartConversion(hadc->Instance);
3418602a:	687b      	ldr	r3, [r7, #4]
3418602c:	681b      	ldr	r3, [r3, #0]
3418602e:	4618      	mov	r0, r3
34186030:	f7ff fe19 	bl	34185c66 <LL_ADC_REG_StartConversion>
34186034:	e025      	b.n	34186082 <HAL_ADC_Start+0x15e>
      }
      else
      {
        /* ADC instance is a multimode slave instance with multimode regular conversions enabled */
        SET_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
34186036:	687b      	ldr	r3, [r7, #4]
34186038:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
3418603a:	f443 1280 	orr.w	r2, r3, #1048576	@ 0x100000
3418603e:	687b      	ldr	r3, [r7, #4]
34186040:	659a      	str	r2, [r3, #88]	@ 0x58
        /* if Master ADC JAUTO bit is set, update Slave State in setting
           HAL_ADC_STATE_INJ_BUSY bit and in resetting HAL_ADC_STATE_INJ_EOC bit */
        tmpADC_Master = __LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance);
34186042:	687b      	ldr	r3, [r7, #4]
34186044:	681b      	ldr	r3, [r3, #0]
34186046:	4a12      	ldr	r2, [pc, #72]	@ (34186090 <HAL_ADC_Start+0x16c>)
34186048:	4293      	cmp	r3, r2
3418604a:	d002      	beq.n	34186052 <HAL_ADC_Start+0x12e>
3418604c:	687b      	ldr	r3, [r7, #4]
3418604e:	681b      	ldr	r3, [r3, #0]
34186050:	e000      	b.n	34186054 <HAL_ADC_Start+0x130>
34186052:	4b10      	ldr	r3, [pc, #64]	@ (34186094 <HAL_ADC_Start+0x170>)
34186054:	60fb      	str	r3, [r7, #12]
        if (READ_BIT(tmpADC_Master->CFGR1, ADC_CFGR1_JAUTO) != 0UL)
34186056:	68fb      	ldr	r3, [r7, #12]
34186058:	68db      	ldr	r3, [r3, #12]
3418605a:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
3418605e:	2b00      	cmp	r3, #0
34186060:	d00f      	beq.n	34186082 <HAL_ADC_Start+0x15e>
        {
          ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);
34186062:	687b      	ldr	r3, [r7, #4]
34186064:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34186066:	f423 5340 	bic.w	r3, r3, #12288	@ 0x3000
3418606a:	f443 5280 	orr.w	r2, r3, #4096	@ 0x1000
3418606e:	687b      	ldr	r3, [r7, #4]
34186070:	659a      	str	r2, [r3, #88]	@ 0x58
34186072:	e006      	b.n	34186082 <HAL_ADC_Start+0x15e>
      LL_ADC_REG_StartConversion(hadc->Instance);
#endif /* ADC_MULTIMODE_SUPPORT */
    }
    else
    {
      __HAL_UNLOCK(hadc);
34186074:	687b      	ldr	r3, [r7, #4]
34186076:	2200      	movs	r2, #0
34186078:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54
3418607c:	e001      	b.n	34186082 <HAL_ADC_Start+0x15e>
    }
  }
  else
  {
    tmp_hal_status = HAL_BUSY;
3418607e:	2302      	movs	r3, #2
34186080:	75fb      	strb	r3, [r7, #23]
  }

  return tmp_hal_status;
34186082:	7dfb      	ldrb	r3, [r7, #23]
}
34186084:	4618      	mov	r0, r3
34186086:	3718      	adds	r7, #24
34186088:	46bd      	mov	sp, r7
3418608a:	bd80      	pop	{r7, pc}
3418608c:	50022300 	.word	0x50022300
34186090:	50022100 	.word	0x50022100
34186094:	50022000 	.word	0x50022000

34186098 <HAL_ADC_ConfigChannel>:
  * @param hadc ADC handle
  * @param pConfig Structure of ADC channel assigned to ADC group regular.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef *hadc, const ADC_ChannelConfTypeDef *pConfig)
{
34186098:	b590      	push	{r4, r7, lr}
3418609a:	b089      	sub	sp, #36	@ 0x24
3418609c:	af00      	add	r7, sp, #0
3418609e:	6078      	str	r0, [r7, #4]
341860a0:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
341860a2:	2300      	movs	r3, #0
341860a4:	77fb      	strb	r3, [r7, #31]
  {
    assert_param(IS_ADC_DIFF_CHANNEL(hadc, pConfig->Channel));
  }

  /* ADC must be disabled to set configuration bits                           */
  if (LL_ADC_IsEnabled(hadc->Instance) != 0UL)
341860a6:	687b      	ldr	r3, [r7, #4]
341860a8:	681b      	ldr	r3, [r3, #0]
341860aa:	4618      	mov	r0, r3
341860ac:	f7ff fdc8 	bl	34185c40 <LL_ADC_IsEnabled>
341860b0:	4603      	mov	r3, r0
341860b2:	2b00      	cmp	r3, #0
341860b4:	d001      	beq.n	341860ba <HAL_ADC_ConfigChannel+0x22>
  {
    return HAL_ERROR;
341860b6:	2301      	movs	r3, #1
341860b8:	e1db      	b.n	34186472 <HAL_ADC_ConfigChannel+0x3da>
  }

  /* Process locked */
  __HAL_LOCK(hadc);
341860ba:	687b      	ldr	r3, [r7, #4]
341860bc:	f893 3054 	ldrb.w	r3, [r3, #84]	@ 0x54
341860c0:	2b01      	cmp	r3, #1
341860c2:	d101      	bne.n	341860c8 <HAL_ADC_ConfigChannel+0x30>
341860c4:	2302      	movs	r3, #2
341860c6:	e1d4      	b.n	34186472 <HAL_ADC_ConfigChannel+0x3da>
341860c8:	687b      	ldr	r3, [r7, #4]
341860ca:	2201      	movs	r2, #1
341860cc:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54
  /* Parameters update conditioned to ADC state:                              */
  /* Parameters that can be updated when ADC is disabled or enabled without   */
  /* conversion on going on regular group:                                    */
  /*  - Channel number                                                        */
  /*  - Channel rank                                                          */
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
341860d0:	687b      	ldr	r3, [r7, #4]
341860d2:	681b      	ldr	r3, [r3, #0]
341860d4:	4618      	mov	r0, r3
341860d6:	f7ff fdd8 	bl	34185c8a <LL_ADC_REG_IsConversionOngoing>
341860da:	4603      	mov	r3, r0
341860dc:	2b00      	cmp	r3, #0
341860de:	f040 81bb 	bne.w	34186458 <HAL_ADC_ConfigChannel+0x3c0>
  {
    /* ADC channels preselection */
    LL_ADC_SetChannelPreselection(hadc->Instance, pConfig->Channel);
341860e2:	687b      	ldr	r3, [r7, #4]
341860e4:	681a      	ldr	r2, [r3, #0]
341860e6:	683b      	ldr	r3, [r7, #0]
341860e8:	681b      	ldr	r3, [r3, #0]
341860ea:	4619      	mov	r1, r3
341860ec:	4610      	mov	r0, r2
341860ee:	f7ff fbc7 	bl	34185880 <LL_ADC_SetChannelPreselection>

    /* Set ADC group regular sequence: channel on the selected scan sequence rank */
    LL_ADC_REG_SetSequencerRanks(hadc->Instance, pConfig->Rank, pConfig->Channel);
341860f2:	687b      	ldr	r3, [r7, #4]
341860f4:	6818      	ldr	r0, [r3, #0]
341860f6:	683b      	ldr	r3, [r7, #0]
341860f8:	6859      	ldr	r1, [r3, #4]
341860fa:	683b      	ldr	r3, [r7, #0]
341860fc:	681b      	ldr	r3, [r3, #0]
341860fe:	461a      	mov	r2, r3
34186100:	f7ff fb93 	bl	3418582a <LL_ADC_REG_SetSequencerRanks>
    /* Parameters update conditioned to ADC state:                              */
    /* Parameters that can be updated when ADC is disabled or enabled without   */
    /* conversion on going on regular group:                                    */
    /*  - Channel sampling time                                                 */
    /*  - Channel offset                                                        */
    tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
34186104:	687b      	ldr	r3, [r7, #4]
34186106:	681b      	ldr	r3, [r3, #0]
34186108:	4618      	mov	r0, r3
3418610a:	f7ff fdbe 	bl	34185c8a <LL_ADC_REG_IsConversionOngoing>
3418610e:	61b8      	str	r0, [r7, #24]
    tmp_adc_is_conversion_on_going_injected = LL_ADC_INJ_IsConversionOngoing(hadc->Instance);
34186110:	687b      	ldr	r3, [r7, #4]
34186112:	681b      	ldr	r3, [r3, #0]
34186114:	4618      	mov	r0, r3
34186116:	f7ff fdcb 	bl	34185cb0 <LL_ADC_INJ_IsConversionOngoing>
3418611a:	6178      	str	r0, [r7, #20]
    if ((tmp_adc_is_conversion_on_going_regular == 0UL)
3418611c:	69bb      	ldr	r3, [r7, #24]
3418611e:	2b00      	cmp	r3, #0
34186120:	f040 80aa 	bne.w	34186278 <HAL_ADC_ConfigChannel+0x1e0>
        && (tmp_adc_is_conversion_on_going_injected == 0UL)
34186124:	697b      	ldr	r3, [r7, #20]
34186126:	2b00      	cmp	r3, #0
34186128:	f040 80a6 	bne.w	34186278 <HAL_ADC_ConfigChannel+0x1e0>
       )
    {
      /* Set sampling time of the selected ADC channel */
      LL_ADC_SetChannelSamplingTime(hadc->Instance, pConfig->Channel, pConfig->SamplingTime);
3418612c:	687b      	ldr	r3, [r7, #4]
3418612e:	6818      	ldr	r0, [r3, #0]
34186130:	683b      	ldr	r3, [r7, #0]
34186132:	6819      	ldr	r1, [r3, #0]
34186134:	683b      	ldr	r3, [r7, #0]
34186136:	689b      	ldr	r3, [r3, #8]
34186138:	461a      	mov	r2, r3
3418613a:	f7ff fbb9 	bl	341858b0 <LL_ADC_SetChannelSamplingTime>

      /* Configure the offset: offset enable/disable, channel, offset value */

      /* Shift the offset with respect to the selected ADC resolution. */
      /* Offset has to be left-aligned on bit 11, the LSB (right bits) are set to 0 */
      tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, (uint32_t)pConfig->Offset);
3418613e:	683b      	ldr	r3, [r7, #0]
34186140:	695a      	ldr	r2, [r3, #20]
34186142:	687b      	ldr	r3, [r7, #4]
34186144:	681b      	ldr	r3, [r3, #0]
34186146:	68db      	ldr	r3, [r3, #12]
34186148:	089b      	lsrs	r3, r3, #2
3418614a:	f003 0303 	and.w	r3, r3, #3
3418614e:	005b      	lsls	r3, r3, #1
34186150:	fa02 f303 	lsl.w	r3, r2, r3
34186154:	613b      	str	r3, [r7, #16]

      if (pConfig->OffsetNumber != ADC_OFFSET_NONE)
34186156:	683b      	ldr	r3, [r7, #0]
34186158:	691b      	ldr	r3, [r3, #16]
3418615a:	2b04      	cmp	r3, #4
3418615c:	d038      	beq.n	341861d0 <HAL_ADC_ConfigChannel+0x138>
      {
        /* Set ADC selected offset number */
        LL_ADC_SetOffsetChannel(hadc->Instance, pConfig->OffsetNumber, pConfig->Channel);
3418615e:	687b      	ldr	r3, [r7, #4]
34186160:	6818      	ldr	r0, [r3, #0]
34186162:	683b      	ldr	r3, [r7, #0]
34186164:	6919      	ldr	r1, [r3, #16]
34186166:	683b      	ldr	r3, [r7, #0]
34186168:	681b      	ldr	r3, [r3, #0]
3418616a:	461a      	mov	r2, r3
3418616c:	f7ff fa9b 	bl	341856a6 <LL_ADC_SetOffsetChannel>
        LL_ADC_SetOffsetLevel(hadc->Instance, pConfig->OffsetNumber, tmpOffsetShifted);
34186170:	687b      	ldr	r3, [r7, #4]
34186172:	6818      	ldr	r0, [r3, #0]
34186174:	683b      	ldr	r3, [r7, #0]
34186176:	691b      	ldr	r3, [r3, #16]
34186178:	693a      	ldr	r2, [r7, #16]
3418617a:	4619      	mov	r1, r3
3418617c:	f7ff fac6 	bl	3418570c <LL_ADC_SetOffsetLevel>
        /* Signed and unsigned saturation cannot be set at the same time */
        assert_param(!((pConfig->OffsetSignedSaturation == ENABLE) && (pConfig->OffsetSaturation == ENABLE)));


        /* Set ADC offset sign */
        LL_ADC_SetOffsetSign(hadc->Instance, pConfig->OffsetNumber, pConfig->OffsetSign);
34186180:	687b      	ldr	r3, [r7, #4]
34186182:	6818      	ldr	r0, [r3, #0]
34186184:	683b      	ldr	r3, [r7, #0]
34186186:	6919      	ldr	r1, [r3, #16]
34186188:	683b      	ldr	r3, [r7, #0]
3418618a:	69db      	ldr	r3, [r3, #28]
3418618c:	461a      	mov	r2, r3
3418618e:	f7ff fad8 	bl	34185742 <LL_ADC_SetOffsetSign>
        /* Set ADC offset signed saturation */
        LL_ADC_SetOffsetSignedSaturation(hadc->Instance, pConfig->OffsetNumber,      \
34186192:	687b      	ldr	r3, [r7, #4]
34186194:	6818      	ldr	r0, [r3, #0]
34186196:	683b      	ldr	r3, [r7, #0]
34186198:	6919      	ldr	r1, [r3, #16]
                                         (pConfig->OffsetSignedSaturation == ENABLE) \
3418619a:	683b      	ldr	r3, [r7, #0]
3418619c:	7e1b      	ldrb	r3, [r3, #24]
        LL_ADC_SetOffsetSignedSaturation(hadc->Instance, pConfig->OffsetNumber,      \
3418619e:	2b01      	cmp	r3, #1
341861a0:	d102      	bne.n	341861a8 <HAL_ADC_ConfigChannel+0x110>
341861a2:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
341861a6:	e000      	b.n	341861aa <HAL_ADC_ConfigChannel+0x112>
341861a8:	2300      	movs	r3, #0
341861aa:	461a      	mov	r2, r3
341861ac:	f7ff fae4 	bl	34185778 <LL_ADC_SetOffsetSignedSaturation>
                                         ? LL_ADC_OFFSET_SIGNED_SAT_ENABLE           \
                                         : LL_ADC_OFFSET_SIGNED_SAT_DISABLE);
        /* Set ADC offset unsigned saturation */
        LL_ADC_SetOffsetUnsignedSaturation(hadc->Instance, pConfig->OffsetNumber,    \
341861b0:	687b      	ldr	r3, [r7, #4]
341861b2:	6818      	ldr	r0, [r3, #0]
341861b4:	683b      	ldr	r3, [r7, #0]
341861b6:	6919      	ldr	r1, [r3, #16]
                                           (pConfig->OffsetSaturation == ENABLE)     \
341861b8:	683b      	ldr	r3, [r7, #0]
341861ba:	7e5b      	ldrb	r3, [r3, #25]
        LL_ADC_SetOffsetUnsignedSaturation(hadc->Instance, pConfig->OffsetNumber,    \
341861bc:	2b01      	cmp	r3, #1
341861be:	d102      	bne.n	341861c6 <HAL_ADC_ConfigChannel+0x12e>
341861c0:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
341861c4:	e000      	b.n	341861c8 <HAL_ADC_ConfigChannel+0x130>
341861c6:	2300      	movs	r3, #0
341861c8:	461a      	mov	r2, r3
341861ca:	f7ff faf0 	bl	341857ae <LL_ADC_SetOffsetUnsignedSaturation>
341861ce:	e053      	b.n	34186278 <HAL_ADC_ConfigChannel+0x1e0>
      }
      else
      {
        /* Scan each offset register to check if the selected channel is targeted.
           If this is the case, the corresponding offset number is disabled.       */
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1))
341861d0:	687b      	ldr	r3, [r7, #4]
341861d2:	681b      	ldr	r3, [r3, #0]
341861d4:	2100      	movs	r1, #0
341861d6:	4618      	mov	r0, r3
341861d8:	f7ff fa81 	bl	341856de <LL_ADC_GetOffsetChannel>
341861dc:	4602      	mov	r2, r0
            == __HAL_ADC_CHANNEL_TO_DECIMAL_NB(pConfig->Channel))
341861de:	683b      	ldr	r3, [r7, #0]
341861e0:	681b      	ldr	r3, [r3, #0]
341861e2:	4053      	eors	r3, r2
341861e4:	f003 031f 	and.w	r3, r3, #31
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1))
341861e8:	2b00      	cmp	r3, #0
341861ea:	d106      	bne.n	341861fa <HAL_ADC_ConfigChannel+0x162>
        {
          LL_ADC_SetOffsetLevel(hadc->Instance, LL_ADC_OFFSET_1, 0UL);
341861ec:	687b      	ldr	r3, [r7, #4]
341861ee:	681b      	ldr	r3, [r3, #0]
341861f0:	2200      	movs	r2, #0
341861f2:	2100      	movs	r1, #0
341861f4:	4618      	mov	r0, r3
341861f6:	f7ff fa89 	bl	3418570c <LL_ADC_SetOffsetLevel>
        }
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2))
341861fa:	687b      	ldr	r3, [r7, #4]
341861fc:	681b      	ldr	r3, [r3, #0]
341861fe:	2101      	movs	r1, #1
34186200:	4618      	mov	r0, r3
34186202:	f7ff fa6c 	bl	341856de <LL_ADC_GetOffsetChannel>
34186206:	4602      	mov	r2, r0
            == __HAL_ADC_CHANNEL_TO_DECIMAL_NB(pConfig->Channel))
34186208:	683b      	ldr	r3, [r7, #0]
3418620a:	681b      	ldr	r3, [r3, #0]
3418620c:	4053      	eors	r3, r2
3418620e:	f003 031f 	and.w	r3, r3, #31
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2))
34186212:	2b00      	cmp	r3, #0
34186214:	d106      	bne.n	34186224 <HAL_ADC_ConfigChannel+0x18c>
        {
          LL_ADC_SetOffsetLevel(hadc->Instance, LL_ADC_OFFSET_2, 0UL);
34186216:	687b      	ldr	r3, [r7, #4]
34186218:	681b      	ldr	r3, [r3, #0]
3418621a:	2200      	movs	r2, #0
3418621c:	2101      	movs	r1, #1
3418621e:	4618      	mov	r0, r3
34186220:	f7ff fa74 	bl	3418570c <LL_ADC_SetOffsetLevel>
        }
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3))
34186224:	687b      	ldr	r3, [r7, #4]
34186226:	681b      	ldr	r3, [r3, #0]
34186228:	2102      	movs	r1, #2
3418622a:	4618      	mov	r0, r3
3418622c:	f7ff fa57 	bl	341856de <LL_ADC_GetOffsetChannel>
34186230:	4602      	mov	r2, r0
            == __HAL_ADC_CHANNEL_TO_DECIMAL_NB(pConfig->Channel))
34186232:	683b      	ldr	r3, [r7, #0]
34186234:	681b      	ldr	r3, [r3, #0]
34186236:	4053      	eors	r3, r2
34186238:	f003 031f 	and.w	r3, r3, #31
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3))
3418623c:	2b00      	cmp	r3, #0
3418623e:	d106      	bne.n	3418624e <HAL_ADC_ConfigChannel+0x1b6>
        {
          LL_ADC_SetOffsetLevel(hadc->Instance, LL_ADC_OFFSET_3, 0UL);
34186240:	687b      	ldr	r3, [r7, #4]
34186242:	681b      	ldr	r3, [r3, #0]
34186244:	2200      	movs	r2, #0
34186246:	2102      	movs	r1, #2
34186248:	4618      	mov	r0, r3
3418624a:	f7ff fa5f 	bl	3418570c <LL_ADC_SetOffsetLevel>
        }
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4))
3418624e:	687b      	ldr	r3, [r7, #4]
34186250:	681b      	ldr	r3, [r3, #0]
34186252:	2103      	movs	r1, #3
34186254:	4618      	mov	r0, r3
34186256:	f7ff fa42 	bl	341856de <LL_ADC_GetOffsetChannel>
3418625a:	4602      	mov	r2, r0
            == __HAL_ADC_CHANNEL_TO_DECIMAL_NB(pConfig->Channel))
3418625c:	683b      	ldr	r3, [r7, #0]
3418625e:	681b      	ldr	r3, [r3, #0]
34186260:	4053      	eors	r3, r2
34186262:	f003 031f 	and.w	r3, r3, #31
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4))
34186266:	2b00      	cmp	r3, #0
34186268:	d106      	bne.n	34186278 <HAL_ADC_ConfigChannel+0x1e0>
        {
          LL_ADC_SetOffsetLevel(hadc->Instance, LL_ADC_OFFSET_4, 0UL);
3418626a:	687b      	ldr	r3, [r7, #4]
3418626c:	681b      	ldr	r3, [r3, #0]
3418626e:	2200      	movs	r2, #0
34186270:	2103      	movs	r1, #3
34186272:	4618      	mov	r0, r3
34186274:	f7ff fa4a 	bl	3418570c <LL_ADC_SetOffsetLevel>

    /* Parameters update conditioned to ADC state:                              */
    /* Parameters that can be updated only when ADC is disabled:                */
    /*  - Single or differential mode                                           */
    /*  - Internal measurement channels: Vbat/VrefInt/TempSensor                */
    if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
34186278:	687b      	ldr	r3, [r7, #4]
3418627a:	681b      	ldr	r3, [r3, #0]
3418627c:	4618      	mov	r0, r3
3418627e:	f7ff fcdf 	bl	34185c40 <LL_ADC_IsEnabled>
34186282:	4603      	mov	r3, r0
34186284:	2b00      	cmp	r3, #0
34186286:	f040 8090 	bne.w	341863aa <HAL_ADC_ConfigChannel+0x312>
    {
      /* Set mode single-ended or differential input of the selected ADC channel */
      LL_ADC_SetChannelSingleDiff(hadc->Instance, pConfig->Channel, pConfig->SingleDiff);
3418628a:	687b      	ldr	r3, [r7, #4]
3418628c:	6818      	ldr	r0, [r3, #0]
3418628e:	683b      	ldr	r3, [r7, #0]
34186290:	6819      	ldr	r1, [r3, #0]
34186292:	683b      	ldr	r3, [r7, #0]
34186294:	68db      	ldr	r3, [r3, #12]
34186296:	461a      	mov	r2, r3
34186298:	f7ff fbd0 	bl	34185a3c <LL_ADC_SetChannelSingleDiff>

      /* Configuration of differential mode */
      if (pConfig->SingleDiff == ADC_DIFFERENTIAL_ENDED)
3418629c:	683b      	ldr	r3, [r7, #0]
3418629e:	68db      	ldr	r3, [r3, #12]
341862a0:	4a76      	ldr	r2, [pc, #472]	@ (3418647c <HAL_ADC_ConfigChannel+0x3e4>)
341862a2:	4293      	cmp	r3, r2
341862a4:	f040 8081 	bne.w	341863aa <HAL_ADC_ConfigChannel+0x312>
      {
        /* Set ADC channel preselection of corresponding negative channel */
        LL_ADC_SetChannelPreselection(hadc->Instance,
341862a8:	687b      	ldr	r3, [r7, #4]
341862aa:	681a      	ldr	r2, [r3, #0]
                                      __HAL_ADC_CHANNEL_DIFF_NEG_INPUT(hadc, pConfig->Channel));
341862ac:	683b      	ldr	r3, [r7, #0]
341862ae:	681b      	ldr	r3, [r3, #0]
341862b0:	2b00      	cmp	r3, #0
341862b2:	d05a      	beq.n	3418636a <HAL_ADC_ConfigChannel+0x2d2>
341862b4:	683b      	ldr	r3, [r7, #0]
341862b6:	681b      	ldr	r3, [r3, #0]
341862b8:	2b01      	cmp	r3, #1
341862ba:	d056      	beq.n	3418636a <HAL_ADC_ConfigChannel+0x2d2>
341862bc:	683b      	ldr	r3, [r7, #0]
341862be:	681b      	ldr	r3, [r3, #0]
341862c0:	2b02      	cmp	r3, #2
341862c2:	d052      	beq.n	3418636a <HAL_ADC_ConfigChannel+0x2d2>
341862c4:	683b      	ldr	r3, [r7, #0]
341862c6:	681b      	ldr	r3, [r3, #0]
341862c8:	2b03      	cmp	r3, #3
341862ca:	d04e      	beq.n	3418636a <HAL_ADC_ConfigChannel+0x2d2>
341862cc:	683b      	ldr	r3, [r7, #0]
341862ce:	681b      	ldr	r3, [r3, #0]
341862d0:	2b04      	cmp	r3, #4
341862d2:	d04a      	beq.n	3418636a <HAL_ADC_ConfigChannel+0x2d2>
341862d4:	683b      	ldr	r3, [r7, #0]
341862d6:	681b      	ldr	r3, [r3, #0]
341862d8:	2b05      	cmp	r3, #5
341862da:	d046      	beq.n	3418636a <HAL_ADC_ConfigChannel+0x2d2>
341862dc:	683b      	ldr	r3, [r7, #0]
341862de:	681b      	ldr	r3, [r3, #0]
341862e0:	2b06      	cmp	r3, #6
341862e2:	d042      	beq.n	3418636a <HAL_ADC_ConfigChannel+0x2d2>
341862e4:	683b      	ldr	r3, [r7, #0]
341862e6:	681b      	ldr	r3, [r3, #0]
341862e8:	2b07      	cmp	r3, #7
341862ea:	d03e      	beq.n	3418636a <HAL_ADC_ConfigChannel+0x2d2>
341862ec:	683b      	ldr	r3, [r7, #0]
341862ee:	681b      	ldr	r3, [r3, #0]
341862f0:	2b08      	cmp	r3, #8
341862f2:	d03a      	beq.n	3418636a <HAL_ADC_ConfigChannel+0x2d2>
341862f4:	683b      	ldr	r3, [r7, #0]
341862f6:	681b      	ldr	r3, [r3, #0]
341862f8:	2b09      	cmp	r3, #9
341862fa:	d036      	beq.n	3418636a <HAL_ADC_ConfigChannel+0x2d2>
341862fc:	683b      	ldr	r3, [r7, #0]
341862fe:	681b      	ldr	r3, [r3, #0]
34186300:	2b0a      	cmp	r3, #10
34186302:	d032      	beq.n	3418636a <HAL_ADC_ConfigChannel+0x2d2>
34186304:	683b      	ldr	r3, [r7, #0]
34186306:	681b      	ldr	r3, [r3, #0]
34186308:	2b0b      	cmp	r3, #11
3418630a:	d02e      	beq.n	3418636a <HAL_ADC_ConfigChannel+0x2d2>
3418630c:	683b      	ldr	r3, [r7, #0]
3418630e:	681b      	ldr	r3, [r3, #0]
34186310:	2b0c      	cmp	r3, #12
34186312:	d02a      	beq.n	3418636a <HAL_ADC_ConfigChannel+0x2d2>
34186314:	683b      	ldr	r3, [r7, #0]
34186316:	681b      	ldr	r3, [r3, #0]
34186318:	2b0d      	cmp	r3, #13
3418631a:	d026      	beq.n	3418636a <HAL_ADC_ConfigChannel+0x2d2>
3418631c:	683b      	ldr	r3, [r7, #0]
3418631e:	681b      	ldr	r3, [r3, #0]
34186320:	2b0e      	cmp	r3, #14
34186322:	d022      	beq.n	3418636a <HAL_ADC_ConfigChannel+0x2d2>
34186324:	683b      	ldr	r3, [r7, #0]
34186326:	681b      	ldr	r3, [r3, #0]
34186328:	2b0f      	cmp	r3, #15
3418632a:	d01e      	beq.n	3418636a <HAL_ADC_ConfigChannel+0x2d2>
3418632c:	683b      	ldr	r3, [r7, #0]
3418632e:	681b      	ldr	r3, [r3, #0]
34186330:	2b10      	cmp	r3, #16
34186332:	d01a      	beq.n	3418636a <HAL_ADC_ConfigChannel+0x2d2>
34186334:	683b      	ldr	r3, [r7, #0]
34186336:	681b      	ldr	r3, [r3, #0]
34186338:	2b11      	cmp	r3, #17
3418633a:	d016      	beq.n	3418636a <HAL_ADC_ConfigChannel+0x2d2>
3418633c:	683b      	ldr	r3, [r7, #0]
3418633e:	681b      	ldr	r3, [r3, #0]
34186340:	2b12      	cmp	r3, #18
34186342:	d012      	beq.n	3418636a <HAL_ADC_ConfigChannel+0x2d2>
34186344:	683b      	ldr	r3, [r7, #0]
34186346:	681b      	ldr	r3, [r3, #0]
34186348:	2b13      	cmp	r3, #19
3418634a:	d00e      	beq.n	3418636a <HAL_ADC_ConfigChannel+0x2d2>
3418634c:	683b      	ldr	r3, [r7, #0]
3418634e:	681b      	ldr	r3, [r3, #0]
34186350:	494b      	ldr	r1, [pc, #300]	@ (34186480 <HAL_ADC_ConfigChannel+0x3e8>)
34186352:	428b      	cmp	r3, r1
34186354:	d009      	beq.n	3418636a <HAL_ADC_ConfigChannel+0x2d2>
34186356:	683b      	ldr	r3, [r7, #0]
34186358:	681b      	ldr	r3, [r3, #0]
3418635a:	494a      	ldr	r1, [pc, #296]	@ (34186484 <HAL_ADC_ConfigChannel+0x3ec>)
3418635c:	428b      	cmp	r3, r1
3418635e:	d004      	beq.n	3418636a <HAL_ADC_ConfigChannel+0x2d2>
34186360:	683b      	ldr	r3, [r7, #0]
34186362:	681b      	ldr	r3, [r3, #0]
34186364:	4948      	ldr	r1, [pc, #288]	@ (34186488 <HAL_ADC_ConfigChannel+0x3f0>)
34186366:	428b      	cmp	r3, r1
34186368:	d101      	bne.n	3418636e <HAL_ADC_ConfigChannel+0x2d6>
3418636a:	2301      	movs	r3, #1
3418636c:	e000      	b.n	34186370 <HAL_ADC_ConfigChannel+0x2d8>
3418636e:	2300      	movs	r3, #0
        LL_ADC_SetChannelPreselection(hadc->Instance,
34186370:	2b00      	cmp	r3, #0
34186372:	d015      	beq.n	341863a0 <HAL_ADC_ConfigChannel+0x308>
                                      __HAL_ADC_CHANNEL_DIFF_NEG_INPUT(hadc, pConfig->Channel));
34186374:	687b      	ldr	r3, [r7, #4]
34186376:	681b      	ldr	r3, [r3, #0]
34186378:	4944      	ldr	r1, [pc, #272]	@ (3418648c <HAL_ADC_ConfigChannel+0x3f4>)
3418637a:	428b      	cmp	r3, r1
3418637c:	bf14      	ite	ne
3418637e:	2301      	movne	r3, #1
34186380:	2300      	moveq	r3, #0
34186382:	b2db      	uxtb	r3, r3
34186384:	4618      	mov	r0, r3
34186386:	683b      	ldr	r3, [r7, #0]
34186388:	681b      	ldr	r3, [r3, #0]
3418638a:	b2db      	uxtb	r3, r3
3418638c:	461c      	mov	r4, r3
3418638e:	4940      	ldr	r1, [pc, #256]	@ (34186490 <HAL_ADC_ConfigChannel+0x3f8>)
34186390:	4603      	mov	r3, r0
34186392:	009b      	lsls	r3, r3, #2
34186394:	4403      	add	r3, r0
34186396:	009b      	lsls	r3, r3, #2
34186398:	440b      	add	r3, r1
3418639a:	4423      	add	r3, r4
3418639c:	781b      	ldrb	r3, [r3, #0]
3418639e:	e000      	b.n	341863a2 <HAL_ADC_ConfigChannel+0x30a>
        LL_ADC_SetChannelPreselection(hadc->Instance,
341863a0:	23ff      	movs	r3, #255	@ 0xff
341863a2:	4619      	mov	r1, r3
341863a4:	4610      	mov	r0, r2
341863a6:	f7ff fa6b 	bl	34185880 <LL_ADC_SetChannelPreselection>
    /* If internal channel selected, enable dedicated internal buffers and    */
    /* paths.                                                                 */
    /* Note: these internal measurement paths can be disabled using           */
    /* HAL_ADC_DeInit().                                                      */

    if (__LL_ADC_IS_CHANNEL_INTERNAL(pConfig->Channel))
341863aa:	683b      	ldr	r3, [r7, #0]
341863ac:	681b      	ldr	r3, [r3, #0]
341863ae:	f403 437f 	and.w	r3, r3, #65280	@ 0xff00
341863b2:	2b00      	cmp	r3, #0
341863b4:	d058      	beq.n	34186468 <HAL_ADC_ConfigChannel+0x3d0>
    {
      tmp_config_common_path_internal_channel =
        LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
341863b6:	4837      	ldr	r0, [pc, #220]	@ (34186494 <HAL_ADC_ConfigChannel+0x3fc>)
341863b8:	f7ff f941 	bl	3418563e <LL_ADC_GetCommonPathInternalCh>
341863bc:	60f8      	str	r0, [r7, #12]
      tmp_config_path_internal_channel = LL_ADC_GetPathInternalCh(hadc->Instance);
341863be:	687b      	ldr	r3, [r7, #4]
341863c0:	681b      	ldr	r3, [r3, #0]
341863c2:	4618      	mov	r0, r3
341863c4:	f7ff f95f 	bl	34185686 <LL_ADC_GetPathInternalCh>
341863c8:	60b8      	str	r0, [r7, #8]
      /* If the requested internal measurement path has already been enabled, */
      /* bypass the configuration processing.                                 */
      if ((pConfig->Channel == ADC_CHANNEL_VREFINT)
341863ca:	683b      	ldr	r3, [r7, #0]
341863cc:	681b      	ldr	r3, [r3, #0]
341863ce:	4a2e      	ldr	r2, [pc, #184]	@ (34186488 <HAL_ADC_ConfigChannel+0x3f0>)
341863d0:	4293      	cmp	r3, r2
341863d2:	d111      	bne.n	341863f8 <HAL_ADC_ConfigChannel+0x360>
          && ((tmp_config_common_path_internal_channel & LL_ADC_PATH_INTERNAL_VREFINT) == 0UL))
341863d4:	68fb      	ldr	r3, [r7, #12]
341863d6:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
341863da:	2b00      	cmp	r3, #0
341863dc:	d10c      	bne.n	341863f8 <HAL_ADC_ConfigChannel+0x360>
      {
        if (ADC_VREFINT_INSTANCE(hadc))
341863de:	687b      	ldr	r3, [r7, #4]
341863e0:	681b      	ldr	r3, [r3, #0]
341863e2:	4a2a      	ldr	r2, [pc, #168]	@ (3418648c <HAL_ADC_ConfigChannel+0x3f4>)
341863e4:	4293      	cmp	r3, r2
341863e6:	d13f      	bne.n	34186468 <HAL_ADC_ConfigChannel+0x3d0>
        {
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
341863e8:	68fb      	ldr	r3, [r7, #12]
341863ea:	f443 0380 	orr.w	r3, r3, #4194304	@ 0x400000
341863ee:	4619      	mov	r1, r3
341863f0:	4828      	ldr	r0, [pc, #160]	@ (34186494 <HAL_ADC_ConfigChannel+0x3fc>)
341863f2:	f7ff f911 	bl	34185618 <LL_ADC_SetCommonPathInternalCh>
        if (ADC_VREFINT_INSTANCE(hadc))
341863f6:	e037      	b.n	34186468 <HAL_ADC_ConfigChannel+0x3d0>
                                         LL_ADC_PATH_INTERNAL_VREFINT | tmp_config_common_path_internal_channel);
        }
      }
      else if ((pConfig->Channel == ADC_CHANNEL_VBAT)
341863f8:	683b      	ldr	r3, [r7, #0]
341863fa:	681b      	ldr	r3, [r3, #0]
341863fc:	4a20      	ldr	r2, [pc, #128]	@ (34186480 <HAL_ADC_ConfigChannel+0x3e8>)
341863fe:	4293      	cmp	r3, r2
34186400:	d111      	bne.n	34186426 <HAL_ADC_ConfigChannel+0x38e>
               && ((tmp_config_common_path_internal_channel & LL_ADC_PATH_INTERNAL_VBAT) == 0UL))
34186402:	68fb      	ldr	r3, [r7, #12]
34186404:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
34186408:	2b00      	cmp	r3, #0
3418640a:	d10c      	bne.n	34186426 <HAL_ADC_ConfigChannel+0x38e>
      {
        if (ADC_BATTERY_VOLTAGE_INSTANCE(hadc))
3418640c:	687b      	ldr	r3, [r7, #4]
3418640e:	681b      	ldr	r3, [r3, #0]
34186410:	4a21      	ldr	r2, [pc, #132]	@ (34186498 <HAL_ADC_ConfigChannel+0x400>)
34186412:	4293      	cmp	r3, r2
34186414:	d128      	bne.n	34186468 <HAL_ADC_ConfigChannel+0x3d0>
        {
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
34186416:	68fb      	ldr	r3, [r7, #12]
34186418:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
3418641c:	4619      	mov	r1, r3
3418641e:	481d      	ldr	r0, [pc, #116]	@ (34186494 <HAL_ADC_ConfigChannel+0x3fc>)
34186420:	f7ff f8fa 	bl	34185618 <LL_ADC_SetCommonPathInternalCh>
        if (ADC_BATTERY_VOLTAGE_INSTANCE(hadc))
34186424:	e020      	b.n	34186468 <HAL_ADC_ConfigChannel+0x3d0>
                                         LL_ADC_PATH_INTERNAL_VBAT | tmp_config_common_path_internal_channel);
        }
      }
      else if (((pConfig->Channel == ADC_CHANNEL_VDDCORE)
34186426:	683b      	ldr	r3, [r7, #0]
34186428:	681b      	ldr	r3, [r3, #0]
3418642a:	4a16      	ldr	r2, [pc, #88]	@ (34186484 <HAL_ADC_ConfigChannel+0x3ec>)
3418642c:	4293      	cmp	r3, r2
3418642e:	d11b      	bne.n	34186468 <HAL_ADC_ConfigChannel+0x3d0>
                && ((tmp_config_path_internal_channel & LL_ADC_PATH_INTERNAL_VDDCORE) == 0UL)))
34186430:	68bb      	ldr	r3, [r7, #8]
34186432:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
34186436:	2b00      	cmp	r3, #0
34186438:	d116      	bne.n	34186468 <HAL_ADC_ConfigChannel+0x3d0>
      {
        if (ADC_VDDCORE_INSTANCE(hadc))
3418643a:	687b      	ldr	r3, [r7, #4]
3418643c:	681b      	ldr	r3, [r3, #0]
3418643e:	4a16      	ldr	r2, [pc, #88]	@ (34186498 <HAL_ADC_ConfigChannel+0x400>)
34186440:	4293      	cmp	r3, r2
34186442:	d111      	bne.n	34186468 <HAL_ADC_ConfigChannel+0x3d0>
        {
          LL_ADC_SetPathInternalCh(hadc->Instance, LL_ADC_PATH_INTERNAL_VDDCORE | tmp_config_path_internal_channel);
34186444:	687b      	ldr	r3, [r7, #4]
34186446:	681a      	ldr	r2, [r3, #0]
34186448:	68bb      	ldr	r3, [r7, #8]
3418644a:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
3418644e:	4619      	mov	r1, r3
34186450:	4610      	mov	r0, r2
34186452:	f7ff f902 	bl	3418565a <LL_ADC_SetPathInternalCh>
34186456:	e007      	b.n	34186468 <HAL_ADC_ConfigChannel+0x3d0>
  /* channel could be done on neither of the channel configuration structure  */
  /* parameters.                                                              */
  else
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
34186458:	687b      	ldr	r3, [r7, #4]
3418645a:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
3418645c:	f043 0220 	orr.w	r2, r3, #32
34186460:	687b      	ldr	r3, [r7, #4]
34186462:	659a      	str	r2, [r3, #88]	@ 0x58

    tmp_hal_status = HAL_ERROR;
34186464:	2301      	movs	r3, #1
34186466:	77fb      	strb	r3, [r7, #31]
  }

  __HAL_UNLOCK(hadc);
34186468:	687b      	ldr	r3, [r7, #4]
3418646a:	2200      	movs	r2, #0
3418646c:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

  return tmp_hal_status;
34186470:	7ffb      	ldrb	r3, [r7, #31]
}
34186472:	4618      	mov	r0, r3
34186474:	3724      	adds	r7, #36	@ 0x24
34186476:	46bd      	mov	sp, r7
34186478:	bd90      	pop	{r4, r7, pc}
3418647a:	bf00      	nop
3418647c:	43ff0000 	.word	0x43ff0000
34186480:	01000810 	.word	0x01000810
34186484:	00040811 	.word	0x00040811
34186488:	00400411 	.word	0x00400411
3418648c:	50022000 	.word	0x50022000
34186490:	3419e428 	.word	0x3419e428
34186494:	50022300 	.word	0x50022300
34186498:	50022100 	.word	0x50022100

3418649c <ADC_Enable>:
  *         and voltage regulator must be enabled (done into HAL_ADC_Init()).
  * @param hadc ADC handle
  * @retval HAL status.
  */
HAL_StatusTypeDef ADC_Enable(ADC_HandleTypeDef *hadc)
{
3418649c:	b580      	push	{r7, lr}
3418649e:	b084      	sub	sp, #16
341864a0:	af00      	add	r7, sp, #0
341864a2:	6078      	str	r0, [r7, #4]

  /* ADC enable and wait for ADC ready (in case of ADC is disabled or         */
  /* enabling phase not yet completed: flag ADC ready not yet set).           */
  /* Timeout implemented to not be stuck if ADC cannot be enabled (possible   */
  /* causes: ADC clock not running, ...).                                     */
  if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
341864a4:	687b      	ldr	r3, [r7, #4]
341864a6:	681b      	ldr	r3, [r3, #0]
341864a8:	4618      	mov	r0, r3
341864aa:	f7ff fbc9 	bl	34185c40 <LL_ADC_IsEnabled>
341864ae:	4603      	mov	r3, r0
341864b0:	2b00      	cmp	r3, #0
341864b2:	d14d      	bne.n	34186550 <ADC_Enable+0xb4>
  {
    /* Check if conditions to enable the ADC are fulfilled */
    if ((hadc->Instance->CR & (ADC_CR_ADCAL | ADC_CR_JADSTP | ADC_CR_ADSTP | ADC_CR_JADSTART | ADC_CR_ADSTART
341864b4:	687b      	ldr	r3, [r7, #4]
341864b6:	681b      	ldr	r3, [r3, #0]
341864b8:	689a      	ldr	r2, [r3, #8]
341864ba:	4b28      	ldr	r3, [pc, #160]	@ (3418655c <ADC_Enable+0xc0>)
341864bc:	4013      	ands	r3, r2
341864be:	2b00      	cmp	r3, #0
341864c0:	d00d      	beq.n	341864de <ADC_Enable+0x42>
                               | ADC_CR_ADDIS | ADC_CR_ADEN)) != 0UL)
    {
      /* Update ADC state machine to error */
      SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
341864c2:	687b      	ldr	r3, [r7, #4]
341864c4:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
341864c6:	f043 0210 	orr.w	r2, r3, #16
341864ca:	687b      	ldr	r3, [r7, #4]
341864cc:	659a      	str	r2, [r3, #88]	@ 0x58

      /* Set ADC error code to ADC peripheral internal error */
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
341864ce:	687b      	ldr	r3, [r7, #4]
341864d0:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
341864d2:	f043 0201 	orr.w	r2, r3, #1
341864d6:	687b      	ldr	r3, [r7, #4]
341864d8:	65da      	str	r2, [r3, #92]	@ 0x5c

      return HAL_ERROR;
341864da:	2301      	movs	r3, #1
341864dc:	e039      	b.n	34186552 <ADC_Enable+0xb6>
    }

    /* Enable the ADC peripheral */
    LL_ADC_Enable(hadc->Instance);
341864de:	687b      	ldr	r3, [r7, #4]
341864e0:	681b      	ldr	r3, [r3, #0]
341864e2:	4618      	mov	r0, r3
341864e4:	f7ff fb9a 	bl	34185c1c <LL_ADC_Enable>

    /* Wait for ADC effectively enabled */
    tickstart = HAL_GetTick();
341864e8:	f7ff f866 	bl	341855b8 <HAL_GetTick>
341864ec:	60f8      	str	r0, [r7, #12]

    while (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == 0UL)
341864ee:	e028      	b.n	34186542 <ADC_Enable+0xa6>
          The workaround is to continue setting ADEN until ADRDY is becomes 1.
          Additionally, ADC_ENABLE_TIMEOUT is defined to encompass this
          4 ADC clock cycle duration */
      /* Note: Test of ADC enabled required due to hardware constraint to     */
      /*       not enable ADC if already enabled.                             */
      if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
341864f0:	687b      	ldr	r3, [r7, #4]
341864f2:	681b      	ldr	r3, [r3, #0]
341864f4:	4618      	mov	r0, r3
341864f6:	f7ff fba3 	bl	34185c40 <LL_ADC_IsEnabled>
341864fa:	4603      	mov	r3, r0
341864fc:	2b00      	cmp	r3, #0
341864fe:	d104      	bne.n	3418650a <ADC_Enable+0x6e>
      {
        LL_ADC_Enable(hadc->Instance);
34186500:	687b      	ldr	r3, [r7, #4]
34186502:	681b      	ldr	r3, [r3, #0]
34186504:	4618      	mov	r0, r3
34186506:	f7ff fb89 	bl	34185c1c <LL_ADC_Enable>
      }

      if ((HAL_GetTick() - tickstart) > ADC_ENABLE_TIMEOUT)
3418650a:	f7ff f855 	bl	341855b8 <HAL_GetTick>
3418650e:	4602      	mov	r2, r0
34186510:	68fb      	ldr	r3, [r7, #12]
34186512:	1ad3      	subs	r3, r2, r3
34186514:	2b02      	cmp	r3, #2
34186516:	d914      	bls.n	34186542 <ADC_Enable+0xa6>
      {
        /* New check to avoid false timeout detection in case of preemption */
        if (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == 0UL)
34186518:	687b      	ldr	r3, [r7, #4]
3418651a:	681b      	ldr	r3, [r3, #0]
3418651c:	681b      	ldr	r3, [r3, #0]
3418651e:	f003 0301 	and.w	r3, r3, #1
34186522:	2b01      	cmp	r3, #1
34186524:	d00d      	beq.n	34186542 <ADC_Enable+0xa6>
        {
          /* Update ADC state machine to error */
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
34186526:	687b      	ldr	r3, [r7, #4]
34186528:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
3418652a:	f043 0210 	orr.w	r2, r3, #16
3418652e:	687b      	ldr	r3, [r7, #4]
34186530:	659a      	str	r2, [r3, #88]	@ 0x58

          /* Set ADC error code to ADC peripheral internal error */
          SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
34186532:	687b      	ldr	r3, [r7, #4]
34186534:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
34186536:	f043 0201 	orr.w	r2, r3, #1
3418653a:	687b      	ldr	r3, [r7, #4]
3418653c:	65da      	str	r2, [r3, #92]	@ 0x5c

          return HAL_ERROR;
3418653e:	2301      	movs	r3, #1
34186540:	e007      	b.n	34186552 <ADC_Enable+0xb6>
    while (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == 0UL)
34186542:	687b      	ldr	r3, [r7, #4]
34186544:	681b      	ldr	r3, [r3, #0]
34186546:	681b      	ldr	r3, [r3, #0]
34186548:	f003 0301 	and.w	r3, r3, #1
3418654c:	2b01      	cmp	r3, #1
3418654e:	d1cf      	bne.n	341864f0 <ADC_Enable+0x54>
      }
    }
  }

  /* Return HAL status */
  return HAL_OK;
34186550:	2300      	movs	r3, #0
}
34186552:	4618      	mov	r0, r3
34186554:	3710      	adds	r7, #16
34186556:	46bd      	mov	sp, r7
34186558:	bd80      	pop	{r7, pc}
3418655a:	bf00      	nop
3418655c:	8000003f 	.word	0x8000003f

34186560 <LL_ADC_SetCalibrationFactor>:
{
34186560:	b480      	push	{r7}
34186562:	b085      	sub	sp, #20
34186564:	af00      	add	r7, sp, #0
34186566:	60f8      	str	r0, [r7, #12]
34186568:	60b9      	str	r1, [r7, #8]
3418656a:	607a      	str	r2, [r7, #4]
  MODIFY_REG(ADCx->CALFACT,
3418656c:	68fb      	ldr	r3, [r7, #12]
3418656e:	f8d3 20c4 	ldr.w	r2, [r3, #196]	@ 0xc4
34186572:	68bb      	ldr	r3, [r7, #8]
34186574:	f023 23fc 	bic.w	r3, r3, #4227922944	@ 0xfc00fc00
34186578:	43db      	mvns	r3, r3
3418657a:	401a      	ands	r2, r3
3418657c:	68bb      	ldr	r3, [r7, #8]
3418657e:	f3c3 0309 	ubfx	r3, r3, #0, #10
34186582:	43db      	mvns	r3, r3
34186584:	f003 0310 	and.w	r3, r3, #16
34186588:	6879      	ldr	r1, [r7, #4]
3418658a:	4099      	lsls	r1, r3
3418658c:	68bb      	ldr	r3, [r7, #8]
3418658e:	400b      	ands	r3, r1
34186590:	f023 23fc 	bic.w	r3, r3, #4227922944	@ 0xfc00fc00
34186594:	431a      	orrs	r2, r3
34186596:	68fb      	ldr	r3, [r7, #12]
34186598:	f8c3 20c4 	str.w	r2, [r3, #196]	@ 0xc4
}
3418659c:	bf00      	nop
3418659e:	3714      	adds	r7, #20
341865a0:	46bd      	mov	sp, r7
341865a2:	f85d 7b04 	ldr.w	r7, [sp], #4
341865a6:	4770      	bx	lr

341865a8 <LL_ADC_SetOffsetLevel>:
{
341865a8:	b480      	push	{r7}
341865aa:	b087      	sub	sp, #28
341865ac:	af00      	add	r7, sp, #0
341865ae:	60f8      	str	r0, [r7, #12]
341865b0:	60b9      	str	r1, [r7, #8]
341865b2:	607a      	str	r2, [r7, #4]
  __IO uint32_t *preg_offset_val = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
341865b4:	68fb      	ldr	r3, [r7, #12]
341865b6:	3360      	adds	r3, #96	@ 0x60
341865b8:	461a      	mov	r2, r3
341865ba:	68bb      	ldr	r3, [r7, #8]
341865bc:	009b      	lsls	r3, r3, #2
341865be:	4413      	add	r3, r2
341865c0:	617b      	str	r3, [r7, #20]
  MODIFY_REG(*preg_offset_val,
341865c2:	697b      	ldr	r3, [r7, #20]
341865c4:	681b      	ldr	r3, [r3, #0]
341865c6:	0d9b      	lsrs	r3, r3, #22
341865c8:	059b      	lsls	r3, r3, #22
341865ca:	687a      	ldr	r2, [r7, #4]
341865cc:	431a      	orrs	r2, r3
341865ce:	697b      	ldr	r3, [r7, #20]
341865d0:	601a      	str	r2, [r3, #0]
}
341865d2:	bf00      	nop
341865d4:	371c      	adds	r7, #28
341865d6:	46bd      	mov	sp, r7
341865d8:	f85d 7b04 	ldr.w	r7, [sp], #4
341865dc:	4770      	bx	lr

341865de <LL_ADC_GetOffsetLevel>:
{
341865de:	b480      	push	{r7}
341865e0:	b085      	sub	sp, #20
341865e2:	af00      	add	r7, sp, #0
341865e4:	6078      	str	r0, [r7, #4]
341865e6:	6039      	str	r1, [r7, #0]
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
341865e8:	687b      	ldr	r3, [r7, #4]
341865ea:	3360      	adds	r3, #96	@ 0x60
341865ec:	461a      	mov	r2, r3
341865ee:	683b      	ldr	r3, [r7, #0]
341865f0:	009b      	lsls	r3, r3, #2
341865f2:	4413      	add	r3, r2
341865f4:	60fb      	str	r3, [r7, #12]
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET);
341865f6:	68fb      	ldr	r3, [r7, #12]
341865f8:	681b      	ldr	r3, [r3, #0]
341865fa:	f3c3 0315 	ubfx	r3, r3, #0, #22
}
341865fe:	4618      	mov	r0, r3
34186600:	3714      	adds	r7, #20
34186602:	46bd      	mov	sp, r7
34186604:	f85d 7b04 	ldr.w	r7, [sp], #4
34186608:	4770      	bx	lr

3418660a <LL_ADC_IsEnabled>:
{
3418660a:	b480      	push	{r7}
3418660c:	b083      	sub	sp, #12
3418660e:	af00      	add	r7, sp, #0
34186610:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
34186612:	687b      	ldr	r3, [r7, #4]
34186614:	689b      	ldr	r3, [r3, #8]
34186616:	f003 0301 	and.w	r3, r3, #1
3418661a:	2b01      	cmp	r3, #1
3418661c:	d101      	bne.n	34186622 <LL_ADC_IsEnabled+0x18>
3418661e:	2301      	movs	r3, #1
34186620:	e000      	b.n	34186624 <LL_ADC_IsEnabled+0x1a>
34186622:	2300      	movs	r3, #0
}
34186624:	4618      	mov	r0, r3
34186626:	370c      	adds	r7, #12
34186628:	46bd      	mov	sp, r7
3418662a:	f85d 7b04 	ldr.w	r7, [sp], #4
3418662e:	4770      	bx	lr

34186630 <LL_ADC_StartCalibration>:
{
34186630:	b480      	push	{r7}
34186632:	b083      	sub	sp, #12
34186634:	af00      	add	r7, sp, #0
34186636:	6078      	str	r0, [r7, #4]
34186638:	6039      	str	r1, [r7, #0]
  MODIFY_REG(ADCx->CR,
3418663a:	687b      	ldr	r3, [r7, #4]
3418663c:	689b      	ldr	r3, [r3, #8]
3418663e:	f023 4380 	bic.w	r3, r3, #1073741824	@ 0x40000000
34186642:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
34186646:	683a      	ldr	r2, [r7, #0]
34186648:	f002 4280 	and.w	r2, r2, #1073741824	@ 0x40000000
3418664c:	4313      	orrs	r3, r2
3418664e:	f043 4200 	orr.w	r2, r3, #2147483648	@ 0x80000000
34186652:	687b      	ldr	r3, [r7, #4]
34186654:	609a      	str	r2, [r3, #8]
}
34186656:	bf00      	nop
34186658:	370c      	adds	r7, #12
3418665a:	46bd      	mov	sp, r7
3418665c:	f85d 7b04 	ldr.w	r7, [sp], #4
34186660:	4770      	bx	lr

34186662 <LL_ADC_StopCalibration>:
{
34186662:	b480      	push	{r7}
34186664:	b083      	sub	sp, #12
34186666:	af00      	add	r7, sp, #0
34186668:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(ADCx->CR, ADC_CR_ADCALDIF | ADC_CR_ADCAL | ADC_CR_BITS_PROPERTY_RS);
3418666a:	687b      	ldr	r3, [r7, #4]
3418666c:	689b      	ldr	r3, [r3, #8]
3418666e:	f023 4340 	bic.w	r3, r3, #3221225472	@ 0xc0000000
34186672:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
34186676:	687a      	ldr	r2, [r7, #4]
34186678:	6093      	str	r3, [r2, #8]
}
3418667a:	bf00      	nop
3418667c:	370c      	adds	r7, #12
3418667e:	46bd      	mov	sp, r7
34186680:	f85d 7b04 	ldr.w	r7, [sp], #4
34186684:	4770      	bx	lr

34186686 <LL_ADC_EnableCalibrationOffset>:
{
34186686:	b480      	push	{r7}
34186688:	b083      	sub	sp, #12
3418668a:	af00      	add	r7, sp, #0
3418668c:	6078      	str	r0, [r7, #4]
  SET_BIT(ADCx->CALFACT, ADC_CALFACT_CALADDOS);
3418668e:	687b      	ldr	r3, [r7, #4]
34186690:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
34186694:	f043 4200 	orr.w	r2, r3, #2147483648	@ 0x80000000
34186698:	687b      	ldr	r3, [r7, #4]
3418669a:	f8c3 20c4 	str.w	r2, [r3, #196]	@ 0xc4
}
3418669e:	bf00      	nop
341866a0:	370c      	adds	r7, #12
341866a2:	46bd      	mov	sp, r7
341866a4:	f85d 7b04 	ldr.w	r7, [sp], #4
341866a8:	4770      	bx	lr

341866aa <LL_ADC_DisableCalibrationOffset>:
{
341866aa:	b480      	push	{r7}
341866ac:	b083      	sub	sp, #12
341866ae:	af00      	add	r7, sp, #0
341866b0:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(ADCx->CALFACT, ADC_CALFACT_CALADDOS);
341866b2:	687b      	ldr	r3, [r7, #4]
341866b4:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
341866b8:	f023 4200 	bic.w	r2, r3, #2147483648	@ 0x80000000
341866bc:	687b      	ldr	r3, [r7, #4]
341866be:	f8c3 20c4 	str.w	r2, [r3, #196]	@ 0xc4
}
341866c2:	bf00      	nop
341866c4:	370c      	adds	r7, #12
341866c6:	46bd      	mov	sp, r7
341866c8:	f85d 7b04 	ldr.w	r7, [sp], #4
341866cc:	4770      	bx	lr

341866ce <LL_ADC_IsCalibrationOffsetEnabled>:
{
341866ce:	b480      	push	{r7}
341866d0:	b083      	sub	sp, #12
341866d2:	af00      	add	r7, sp, #0
341866d4:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CALFACT, ADC_CALFACT_CALADDOS) == (ADC_CALFACT_CALADDOS)) ? 1UL : 0UL);
341866d6:	687b      	ldr	r3, [r7, #4]
341866d8:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
341866dc:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
341866e0:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
341866e4:	d101      	bne.n	341866ea <LL_ADC_IsCalibrationOffsetEnabled+0x1c>
341866e6:	2301      	movs	r3, #1
341866e8:	e000      	b.n	341866ec <LL_ADC_IsCalibrationOffsetEnabled+0x1e>
341866ea:	2300      	movs	r3, #0
}
341866ec:	4618      	mov	r0, r3
341866ee:	370c      	adds	r7, #12
341866f0:	46bd      	mov	sp, r7
341866f2:	f85d 7b04 	ldr.w	r7, [sp], #4
341866f6:	4770      	bx	lr

341866f8 <LL_ADC_REG_StartConversion>:
{
341866f8:	b480      	push	{r7}
341866fa:	b083      	sub	sp, #12
341866fc:	af00      	add	r7, sp, #0
341866fe:	6078      	str	r0, [r7, #4]
  MODIFY_REG(ADCx->CR,
34186700:	687b      	ldr	r3, [r7, #4]
34186702:	689b      	ldr	r3, [r3, #8]
34186704:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
34186708:	f043 0204 	orr.w	r2, r3, #4
3418670c:	687b      	ldr	r3, [r7, #4]
3418670e:	609a      	str	r2, [r3, #8]
}
34186710:	bf00      	nop
34186712:	370c      	adds	r7, #12
34186714:	46bd      	mov	sp, r7
34186716:	f85d 7b04 	ldr.w	r7, [sp], #4
3418671a:	4770      	bx	lr

3418671c <LL_ADC_REG_IsConversionOngoing>:
{
3418671c:	b480      	push	{r7}
3418671e:	b083      	sub	sp, #12
34186720:	af00      	add	r7, sp, #0
34186722:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
34186724:	687b      	ldr	r3, [r7, #4]
34186726:	689b      	ldr	r3, [r3, #8]
34186728:	f003 0304 	and.w	r3, r3, #4
3418672c:	2b04      	cmp	r3, #4
3418672e:	d101      	bne.n	34186734 <LL_ADC_REG_IsConversionOngoing+0x18>
34186730:	2301      	movs	r3, #1
34186732:	e000      	b.n	34186736 <LL_ADC_REG_IsConversionOngoing+0x1a>
34186734:	2300      	movs	r3, #0
}
34186736:	4618      	mov	r0, r3
34186738:	370c      	adds	r7, #12
3418673a:	46bd      	mov	sp, r7
3418673c:	f85d 7b04 	ldr.w	r7, [sp], #4
34186740:	4770      	bx	lr

34186742 <LL_ADC_REG_ReadConversionData32>:
{
34186742:	b480      	push	{r7}
34186744:	b083      	sub	sp, #12
34186746:	af00      	add	r7, sp, #0
34186748:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(ADCx->DR, ADC_DR_RDATA));
3418674a:	687b      	ldr	r3, [r7, #4]
3418674c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
}
3418674e:	4618      	mov	r0, r3
34186750:	370c      	adds	r7, #12
34186752:	46bd      	mov	sp, r7
34186754:	f85d 7b04 	ldr.w	r7, [sp], #4
34186758:	4770      	bx	lr
	...

3418675c <HAL_ADCEx_Calibration_Start>:
  *           @arg @ref ADC_DIFFERENTIAL_ENDED Channel in mode input
  *           single ended and differential ended
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_Calibration_Start(ADC_HandleTypeDef *hadc, uint32_t SingleDiff)
{
3418675c:	b580      	push	{r7, lr}
3418675e:	b08a      	sub	sp, #40	@ 0x28
34186760:	af00      	add	r7, sp, #0
34186762:	6078      	str	r0, [r7, #4]
34186764:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef tmp_hal_status;
  uint32_t calibration_factor;
  uint32_t offset_required_single_end = 0UL;
34186766:	2300      	movs	r3, #0
34186768:	623b      	str	r3, [r7, #32]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
  assert_param(IS_ADC_SINGLE_DIFFERENTIAL(SingleDiff));

  /* Process locked */
  __HAL_LOCK(hadc);
3418676a:	687b      	ldr	r3, [r7, #4]
3418676c:	f893 3054 	ldrb.w	r3, [r3, #84]	@ 0x54
34186770:	2b01      	cmp	r3, #1
34186772:	d101      	bne.n	34186778 <HAL_ADCEx_Calibration_Start+0x1c>
34186774:	2302      	movs	r3, #2
34186776:	e117      	b.n	341869a8 <HAL_ADCEx_Calibration_Start+0x24c>
34186778:	687b      	ldr	r3, [r7, #4]
3418677a:	2201      	movs	r2, #1
3418677c:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

  /* Enable ADC if not already enabled */
  tmp_hal_status = ADC_Enable(hadc);
34186780:	6878      	ldr	r0, [r7, #4]
34186782:	f7ff fe8b 	bl	3418649c <ADC_Enable>
34186786:	4603      	mov	r3, r0
34186788:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27

  /* Ensure no conversion is ongoing and ADC enabled correctly */
  if ((LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
3418678c:	687b      	ldr	r3, [r7, #4]
3418678e:	681b      	ldr	r3, [r3, #0]
34186790:	4618      	mov	r0, r3
34186792:	f7ff ffc3 	bl	3418671c <LL_ADC_REG_IsConversionOngoing>
34186796:	4603      	mov	r3, r0
34186798:	2b00      	cmp	r3, #0
3418679a:	f040 80f9 	bne.w	34186990 <HAL_ADCEx_Calibration_Start+0x234>
      && (tmp_hal_status == HAL_OK))
3418679e:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
341867a2:	2b00      	cmp	r3, #0
341867a4:	f040 80f4 	bne.w	34186990 <HAL_ADCEx_Calibration_Start+0x234>
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
341867a8:	687b      	ldr	r3, [r7, #4]
341867aa:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
341867ac:	f423 5388 	bic.w	r3, r3, #4352	@ 0x1100
341867b0:	f023 0302 	bic.w	r3, r3, #2
341867b4:	f043 0202 	orr.w	r2, r3, #2
341867b8:	687b      	ldr	r3, [r7, #4]
341867ba:	659a      	str	r2, [r3, #88]	@ 0x58
                      HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
                      HAL_ADC_STATE_BUSY_INTERNAL);

    /* Save ADC to current configuration */
    backup_trigger_settings = READ_REG(hadc->Instance->CFGR1);
341867bc:	687b      	ldr	r3, [r7, #4]
341867be:	681b      	ldr	r3, [r3, #0]
341867c0:	68db      	ldr	r3, [r3, #12]
341867c2:	61fb      	str	r3, [r7, #28]
    backup_offset_config[0] = LL_ADC_GetOffsetLevel(hadc->Instance, LL_ADC_OFFSET_1);
341867c4:	687b      	ldr	r3, [r7, #4]
341867c6:	681b      	ldr	r3, [r3, #0]
341867c8:	2100      	movs	r1, #0
341867ca:	4618      	mov	r0, r3
341867cc:	f7ff ff07 	bl	341865de <LL_ADC_GetOffsetLevel>
341867d0:	4603      	mov	r3, r0
341867d2:	60bb      	str	r3, [r7, #8]
    backup_offset_config[1] = LL_ADC_GetOffsetLevel(hadc->Instance, LL_ADC_OFFSET_2);
341867d4:	687b      	ldr	r3, [r7, #4]
341867d6:	681b      	ldr	r3, [r3, #0]
341867d8:	2101      	movs	r1, #1
341867da:	4618      	mov	r0, r3
341867dc:	f7ff feff 	bl	341865de <LL_ADC_GetOffsetLevel>
341867e0:	4603      	mov	r3, r0
341867e2:	60fb      	str	r3, [r7, #12]
    backup_offset_config[2] = LL_ADC_GetOffsetLevel(hadc->Instance, LL_ADC_OFFSET_3);
341867e4:	687b      	ldr	r3, [r7, #4]
341867e6:	681b      	ldr	r3, [r3, #0]
341867e8:	2102      	movs	r1, #2
341867ea:	4618      	mov	r0, r3
341867ec:	f7ff fef7 	bl	341865de <LL_ADC_GetOffsetLevel>
341867f0:	4603      	mov	r3, r0
341867f2:	613b      	str	r3, [r7, #16]
    backup_offset_config[3] = LL_ADC_GetOffsetLevel(hadc->Instance, LL_ADC_OFFSET_4);
341867f4:	687b      	ldr	r3, [r7, #4]
341867f6:	681b      	ldr	r3, [r3, #0]
341867f8:	2103      	movs	r1, #3
341867fa:	4618      	mov	r0, r3
341867fc:	f7ff feef 	bl	341865de <LL_ADC_GetOffsetLevel>
34186800:	4603      	mov	r3, r0
34186802:	617b      	str	r3, [r7, #20]

    /* Force ADC configuration for calibration */
    CLEAR_BIT(hadc->Instance->CFGR1, ADC_CFGR1_DMNGT | ADC_CFGR1_EXTEN | ADC_CFGR1_CONT | ADC_CFGR1_RES);
34186804:	687b      	ldr	r3, [r7, #4]
34186806:	681b      	ldr	r3, [r3, #0]
34186808:	68db      	ldr	r3, [r3, #12]
3418680a:	687a      	ldr	r2, [r7, #4]
3418680c:	6812      	ldr	r2, [r2, #0]
3418680e:	f423 5330 	bic.w	r3, r3, #11264	@ 0x2c00
34186812:	f023 030f 	bic.w	r3, r3, #15
34186816:	60d3      	str	r3, [r2, #12]
    LL_ADC_SetOffsetLevel(hadc->Instance, LL_ADC_OFFSET_1, 0);
34186818:	687b      	ldr	r3, [r7, #4]
3418681a:	681b      	ldr	r3, [r3, #0]
3418681c:	2200      	movs	r2, #0
3418681e:	2100      	movs	r1, #0
34186820:	4618      	mov	r0, r3
34186822:	f7ff fec1 	bl	341865a8 <LL_ADC_SetOffsetLevel>
    LL_ADC_SetOffsetLevel(hadc->Instance, LL_ADC_OFFSET_2, 0);
34186826:	687b      	ldr	r3, [r7, #4]
34186828:	681b      	ldr	r3, [r3, #0]
3418682a:	2200      	movs	r2, #0
3418682c:	2101      	movs	r1, #1
3418682e:	4618      	mov	r0, r3
34186830:	f7ff feba 	bl	341865a8 <LL_ADC_SetOffsetLevel>
    LL_ADC_SetOffsetLevel(hadc->Instance, LL_ADC_OFFSET_3, 0);
34186834:	687b      	ldr	r3, [r7, #4]
34186836:	681b      	ldr	r3, [r3, #0]
34186838:	2200      	movs	r2, #0
3418683a:	2102      	movs	r1, #2
3418683c:	4618      	mov	r0, r3
3418683e:	f7ff feb3 	bl	341865a8 <LL_ADC_SetOffsetLevel>
    LL_ADC_SetOffsetLevel(hadc->Instance, LL_ADC_OFFSET_4, 0);
34186842:	687b      	ldr	r3, [r7, #4]
34186844:	681b      	ldr	r3, [r3, #0]
34186846:	2200      	movs	r2, #0
34186848:	2103      	movs	r1, #3
3418684a:	4618      	mov	r0, r3
3418684c:	f7ff feac 	bl	341865a8 <LL_ADC_SetOffsetLevel>

    /* Disable additional offset before calibration start */
    LL_ADC_DisableCalibrationOffset(hadc->Instance);
34186850:	687b      	ldr	r3, [r7, #4]
34186852:	681b      	ldr	r3, [r3, #0]
34186854:	4618      	mov	r0, r3
34186856:	f7ff ff28 	bl	341866aa <LL_ADC_DisableCalibrationOffset>

    /* Start ADC offset measurement in single ended mode */
    tmp_hal_status = ADC_Calibration_MeasureOffset(hadc, ADC_SINGLE_ENDED, &calibration_factor);
3418685a:	f107 0318 	add.w	r3, r7, #24
3418685e:	461a      	mov	r2, r3
34186860:	f240 31ff 	movw	r1, #1023	@ 0x3ff
34186864:	6878      	ldr	r0, [r7, #4]
34186866:	f000 f8a5 	bl	341869b4 <ADC_Calibration_MeasureOffset>
3418686a:	4603      	mov	r3, r0
3418686c:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27

    if (tmp_hal_status == HAL_OK)
34186870:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
34186874:	2b00      	cmp	r3, #0
34186876:	d157      	bne.n	34186928 <HAL_ADCEx_Calibration_Start+0x1cc>
    {
      /* Store the singled-ended calibration factor in CALFACT_S[8:0]. */
      LL_ADC_SetCalibrationFactor(hadc->Instance, LL_ADC_SINGLE_ENDED, calibration_factor);
34186878:	687b      	ldr	r3, [r7, #4]
3418687a:	681b      	ldr	r3, [r3, #0]
3418687c:	69ba      	ldr	r2, [r7, #24]
3418687e:	f240 31ff 	movw	r1, #1023	@ 0x3ff
34186882:	4618      	mov	r0, r3
34186884:	f7ff fe6c 	bl	34186560 <LL_ADC_SetCalibrationFactor>

      if ((SingleDiff & ADC_DIFFERENTIAL_ENDED) == ADC_DIFFERENTIAL_ENDED)
34186888:	683a      	ldr	r2, [r7, #0]
3418688a:	4b49      	ldr	r3, [pc, #292]	@ (341869b0 <HAL_ADCEx_Calibration_Start+0x254>)
3418688c:	4013      	ands	r3, r2
3418688e:	4a48      	ldr	r2, [pc, #288]	@ (341869b0 <HAL_ADCEx_Calibration_Start+0x254>)
34186890:	4293      	cmp	r3, r2
34186892:	d14f      	bne.n	34186934 <HAL_ADCEx_Calibration_Start+0x1d8>
      {
        /* Store calibration offset state after single-ended calibration.     */
        /* keep the same setting for differential-ended calibration.          */
        offset_required_single_end = LL_ADC_IsCalibrationOffsetEnabled(hadc->Instance);
34186894:	687b      	ldr	r3, [r7, #4]
34186896:	681b      	ldr	r3, [r3, #0]
34186898:	4618      	mov	r0, r3
3418689a:	f7ff ff18 	bl	341866ce <LL_ADC_IsCalibrationOffsetEnabled>
3418689e:	6238      	str	r0, [r7, #32]

        /* Start ADC offset measurement in differential ended mode */
        tmp_hal_status = ADC_Calibration_MeasureOffset(hadc, ADC_DIFFERENTIAL_ENDED, &calibration_factor);
341868a0:	f107 0318 	add.w	r3, r7, #24
341868a4:	461a      	mov	r2, r3
341868a6:	4942      	ldr	r1, [pc, #264]	@ (341869b0 <HAL_ADCEx_Calibration_Start+0x254>)
341868a8:	6878      	ldr	r0, [r7, #4]
341868aa:	f000 f883 	bl	341869b4 <ADC_Calibration_MeasureOffset>
341868ae:	4603      	mov	r3, r0
341868b0:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27

        if (tmp_hal_status == HAL_OK)
341868b4:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
341868b8:	2b00      	cmp	r3, #0
341868ba:	d12e      	bne.n	3418691a <HAL_ADCEx_Calibration_Start+0x1be>
        {
          /* Store the differential-ended calibration factor in CALFACT_D[8:0]. */
          LL_ADC_SetCalibrationFactor(hadc->Instance, LL_ADC_DIFFERENTIAL_ENDED, calibration_factor);
341868bc:	687b      	ldr	r3, [r7, #4]
341868be:	681b      	ldr	r3, [r3, #0]
341868c0:	69ba      	ldr	r2, [r7, #24]
341868c2:	493b      	ldr	r1, [pc, #236]	@ (341869b0 <HAL_ADCEx_Calibration_Start+0x254>)
341868c4:	4618      	mov	r0, r3
341868c6:	f7ff fe4b 	bl	34186560 <LL_ADC_SetCalibrationFactor>
          /* Additional calibration offset is applied to both single-ended    */
          /* and differential-ended conversion mode.                          */
          /* If calibration offset was enabled by differential-ended          */
          /* calibration, single-ended mode should be recalibrated using with */
          /* calibration offset enabled.                                      */
          if (offset_required_single_end != LL_ADC_IsCalibrationOffsetEnabled(hadc->Instance))
341868ca:	687b      	ldr	r3, [r7, #4]
341868cc:	681b      	ldr	r3, [r3, #0]
341868ce:	4618      	mov	r0, r3
341868d0:	f7ff fefd 	bl	341866ce <LL_ADC_IsCalibrationOffsetEnabled>
341868d4:	4602      	mov	r2, r0
341868d6:	6a3b      	ldr	r3, [r7, #32]
341868d8:	4293      	cmp	r3, r2
341868da:	d02b      	beq.n	34186934 <HAL_ADCEx_Calibration_Start+0x1d8>
          {
            /* Start ADC offset measurement in single-ended mode */
            tmp_hal_status = ADC_Calibration_MeasureOffset(hadc, ADC_SINGLE_ENDED, &calibration_factor);
341868dc:	f107 0318 	add.w	r3, r7, #24
341868e0:	461a      	mov	r2, r3
341868e2:	f240 31ff 	movw	r1, #1023	@ 0x3ff
341868e6:	6878      	ldr	r0, [r7, #4]
341868e8:	f000 f864 	bl	341869b4 <ADC_Calibration_MeasureOffset>
341868ec:	4603      	mov	r3, r0
341868ee:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27

            if (tmp_hal_status == HAL_OK)
341868f2:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
341868f6:	2b00      	cmp	r3, #0
341868f8:	d108      	bne.n	3418690c <HAL_ADCEx_Calibration_Start+0x1b0>
            {
              /* Store the singled-ended calibration factor in CALFACT_S[8:0]. */
              LL_ADC_SetCalibrationFactor(hadc->Instance, LL_ADC_SINGLE_ENDED, calibration_factor);
341868fa:	687b      	ldr	r3, [r7, #4]
341868fc:	681b      	ldr	r3, [r3, #0]
341868fe:	69ba      	ldr	r2, [r7, #24]
34186900:	f240 31ff 	movw	r1, #1023	@ 0x3ff
34186904:	4618      	mov	r0, r3
34186906:	f7ff fe2b 	bl	34186560 <LL_ADC_SetCalibrationFactor>
3418690a:	e013      	b.n	34186934 <HAL_ADCEx_Calibration_Start+0x1d8>
            }
            else
            {
              SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
3418690c:	687b      	ldr	r3, [r7, #4]
3418690e:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34186910:	f043 0210 	orr.w	r2, r3, #16
34186914:	687b      	ldr	r3, [r7, #4]
34186916:	659a      	str	r2, [r3, #88]	@ 0x58
34186918:	e00c      	b.n	34186934 <HAL_ADCEx_Calibration_Start+0x1d8>
            /* nothing to do */
          }
        }
        else
        {
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
3418691a:	687b      	ldr	r3, [r7, #4]
3418691c:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
3418691e:	f043 0210 	orr.w	r2, r3, #16
34186922:	687b      	ldr	r3, [r7, #4]
34186924:	659a      	str	r2, [r3, #88]	@ 0x58
34186926:	e005      	b.n	34186934 <HAL_ADCEx_Calibration_Start+0x1d8>
        UNUSED(offset_required_single_end);
      }
    }
    else
    {
      SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
34186928:	687b      	ldr	r3, [r7, #4]
3418692a:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
3418692c:	f043 0210 	orr.w	r2, r3, #16
34186930:	687b      	ldr	r3, [r7, #4]
34186932:	659a      	str	r2, [r3, #88]	@ 0x58
      /* Note: No need to update variable "tmp_hal_status" here: already set  */
      /*       to state "HAL_ERROR" by function disabling the ADC.            */
    }

    /* End of calibration procedure */
    LL_ADC_StopCalibration(hadc->Instance);
34186934:	687b      	ldr	r3, [r7, #4]
34186936:	681b      	ldr	r3, [r3, #0]
34186938:	4618      	mov	r0, r3
3418693a:	f7ff fe92 	bl	34186662 <LL_ADC_StopCalibration>

    /* Restore ADC configuration to previous state */
    WRITE_REG(hadc->Instance->CFGR1, backup_trigger_settings);
3418693e:	687b      	ldr	r3, [r7, #4]
34186940:	681b      	ldr	r3, [r3, #0]
34186942:	69fa      	ldr	r2, [r7, #28]
34186944:	60da      	str	r2, [r3, #12]
    LL_ADC_SetOffsetLevel(hadc->Instance, LL_ADC_OFFSET_1, backup_offset_config[0]);
34186946:	687b      	ldr	r3, [r7, #4]
34186948:	681b      	ldr	r3, [r3, #0]
3418694a:	68ba      	ldr	r2, [r7, #8]
3418694c:	2100      	movs	r1, #0
3418694e:	4618      	mov	r0, r3
34186950:	f7ff fe2a 	bl	341865a8 <LL_ADC_SetOffsetLevel>
    LL_ADC_SetOffsetLevel(hadc->Instance, LL_ADC_OFFSET_2, backup_offset_config[1]);
34186954:	687b      	ldr	r3, [r7, #4]
34186956:	681b      	ldr	r3, [r3, #0]
34186958:	68fa      	ldr	r2, [r7, #12]
3418695a:	2101      	movs	r1, #1
3418695c:	4618      	mov	r0, r3
3418695e:	f7ff fe23 	bl	341865a8 <LL_ADC_SetOffsetLevel>
    LL_ADC_SetOffsetLevel(hadc->Instance, LL_ADC_OFFSET_3, backup_offset_config[2]);
34186962:	687b      	ldr	r3, [r7, #4]
34186964:	681b      	ldr	r3, [r3, #0]
34186966:	693a      	ldr	r2, [r7, #16]
34186968:	2102      	movs	r1, #2
3418696a:	4618      	mov	r0, r3
3418696c:	f7ff fe1c 	bl	341865a8 <LL_ADC_SetOffsetLevel>
    LL_ADC_SetOffsetLevel(hadc->Instance, LL_ADC_OFFSET_4, backup_offset_config[3]);
34186970:	687b      	ldr	r3, [r7, #4]
34186972:	681b      	ldr	r3, [r3, #0]
34186974:	697a      	ldr	r2, [r7, #20]
34186976:	2103      	movs	r1, #3
34186978:	4618      	mov	r0, r3
3418697a:	f7ff fe15 	bl	341865a8 <LL_ADC_SetOffsetLevel>

    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
3418697e:	687b      	ldr	r3, [r7, #4]
34186980:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34186982:	f023 0303 	bic.w	r3, r3, #3
34186986:	f043 0201 	orr.w	r2, r3, #1
3418698a:	687b      	ldr	r3, [r7, #4]
3418698c:	659a      	str	r2, [r3, #88]	@ 0x58
3418698e:	e005      	b.n	3418699c <HAL_ADCEx_Calibration_Start+0x240>
                      HAL_ADC_STATE_BUSY_INTERNAL,
                      HAL_ADC_STATE_READY);
  }
  else
  {
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
34186990:	687b      	ldr	r3, [r7, #4]
34186992:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34186994:	f043 0210 	orr.w	r2, r3, #16
34186998:	687b      	ldr	r3, [r7, #4]
3418699a:	659a      	str	r2, [r3, #88]	@ 0x58

    /* Note: No need to update variable "tmp_hal_status" here: already set    */
    /*       to state "HAL_ERROR" by function disabling the ADC.              */
  }

  __HAL_UNLOCK(hadc);
3418699c:	687b      	ldr	r3, [r7, #4]
3418699e:	2200      	movs	r2, #0
341869a0:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

  return tmp_hal_status;
341869a4:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
}
341869a8:	4618      	mov	r0, r3
341869aa:	3728      	adds	r7, #40	@ 0x28
341869ac:	46bd      	mov	sp, r7
341869ae:	bd80      	pop	{r7, pc}
341869b0:	43ff0000 	.word	0x43ff0000

341869b4 <ADC_Calibration_MeasureOffset>:
  * @retval HAL status
  */
HAL_StatusTypeDef ADC_Calibration_MeasureOffset(ADC_HandleTypeDef *hadc,
                                                uint32_t SingleDiff,
                                                uint32_t *pCalibrationFactor)
{
341869b4:	b580      	push	{r7, lr}
341869b6:	b088      	sub	sp, #32
341869b8:	af00      	add	r7, sp, #0
341869ba:	60f8      	str	r0, [r7, #12]
341869bc:	60b9      	str	r1, [r7, #8]
341869be:	607a      	str	r2, [r7, #4]
  int32_t  calib_factor_avg = 0;
341869c0:	2300      	movs	r3, #0
341869c2:	61fb      	str	r3, [r7, #28]
  uint32_t calibration_step;
  uint32_t tickstart;

  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
341869c4:	2300      	movs	r3, #0
341869c6:	75fb      	strb	r3, [r7, #23]

  if (LL_ADC_IsEnabled(hadc->Instance) != 0UL)
341869c8:	68fb      	ldr	r3, [r7, #12]
341869ca:	681b      	ldr	r3, [r3, #0]
341869cc:	4618      	mov	r0, r3
341869ce:	f7ff fe1c 	bl	3418660a <LL_ADC_IsEnabled>
341869d2:	4603      	mov	r3, r0
341869d4:	2b00      	cmp	r3, #0
341869d6:	d077      	beq.n	34186ac8 <ADC_Calibration_MeasureOffset+0x114>
  {
    /* Start ADC calibration */
    LL_ADC_StartCalibration(hadc->Instance, SingleDiff);
341869d8:	68fb      	ldr	r3, [r7, #12]
341869da:	681b      	ldr	r3, [r3, #0]
341869dc:	68b9      	ldr	r1, [r7, #8]
341869de:	4618      	mov	r0, r3
341869e0:	f7ff fe26 	bl	34186630 <LL_ADC_StartCalibration>
      /* Measure current ADC offset */

      /* With calibration mode enabled, start multiple conversion and           */
      /* accumulate data to compute ADC conversion offset.                      */
      /* The calibration factor will be the averaged converted value            */
      for (calibration_step = 0; calibration_step < ADC_CALIBRATION_STEPS; calibration_step++)
341869e4:	2300      	movs	r3, #0
341869e6:	61bb      	str	r3, [r7, #24]
341869e8:	e03a      	b.n	34186a60 <ADC_Calibration_MeasureOffset+0xac>
      {
        LL_ADC_REG_StartConversion(hadc->Instance);
341869ea:	68fb      	ldr	r3, [r7, #12]
341869ec:	681b      	ldr	r3, [r3, #0]
341869ee:	4618      	mov	r0, r3
341869f0:	f7ff fe82 	bl	341866f8 <LL_ADC_REG_StartConversion>

        /* Wait for ADC conversion to end */
        /* Get tick count */
        tickstart = HAL_GetTick();
341869f4:	f7fe fde0 	bl	341855b8 <HAL_GetTick>
341869f8:	6138      	str	r0, [r7, #16]
        while (LL_ADC_REG_IsConversionOngoing(hadc->Instance) != 0UL)
341869fa:	e01c      	b.n	34186a36 <ADC_Calibration_MeasureOffset+0x82>
        {
          if ((HAL_GetTick() - tickstart) > ADC_CALIBRATION_TIMEOUT)
341869fc:	f7fe fddc 	bl	341855b8 <HAL_GetTick>
34186a00:	4602      	mov	r2, r0
34186a02:	693b      	ldr	r3, [r7, #16]
34186a04:	1ad3      	subs	r3, r2, r3
34186a06:	2b05      	cmp	r3, #5
34186a08:	d915      	bls.n	34186a36 <ADC_Calibration_MeasureOffset+0x82>
          {
            /* New check to avoid false timeout detection in case of preemption */
            if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) != 0UL)
34186a0a:	68fb      	ldr	r3, [r7, #12]
34186a0c:	681b      	ldr	r3, [r3, #0]
34186a0e:	4618      	mov	r0, r3
34186a10:	f7ff fe84 	bl	3418671c <LL_ADC_REG_IsConversionOngoing>
34186a14:	4603      	mov	r3, r0
34186a16:	2b00      	cmp	r3, #0
34186a18:	d00d      	beq.n	34186a36 <ADC_Calibration_MeasureOffset+0x82>
            {
              /* Update ADC state machine to error */
              SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
34186a1a:	68fb      	ldr	r3, [r7, #12]
34186a1c:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34186a1e:	f043 0210 	orr.w	r2, r3, #16
34186a22:	68fb      	ldr	r3, [r7, #12]
34186a24:	659a      	str	r2, [r3, #88]	@ 0x58

              /* Set ADC error code to ADC peripheral internal error */
              SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
34186a26:	68fb      	ldr	r3, [r7, #12]
34186a28:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
34186a2a:	f043 0201 	orr.w	r2, r3, #1
34186a2e:	68fb      	ldr	r3, [r7, #12]
34186a30:	65da      	str	r2, [r3, #92]	@ 0x5c

              return HAL_ERROR;
34186a32:	2301      	movs	r3, #1
34186a34:	e051      	b.n	34186ada <ADC_Calibration_MeasureOffset+0x126>
        while (LL_ADC_REG_IsConversionOngoing(hadc->Instance) != 0UL)
34186a36:	68fb      	ldr	r3, [r7, #12]
34186a38:	681b      	ldr	r3, [r3, #0]
34186a3a:	4618      	mov	r0, r3
34186a3c:	f7ff fe6e 	bl	3418671c <LL_ADC_REG_IsConversionOngoing>
34186a40:	4603      	mov	r3, r0
34186a42:	2b00      	cmp	r3, #0
34186a44:	d1da      	bne.n	341869fc <ADC_Calibration_MeasureOffset+0x48>
            }
          }
        }

        calib_factor_avg += (int32_t)(LL_ADC_REG_ReadConversionData32(hadc->Instance));
34186a46:	68fb      	ldr	r3, [r7, #12]
34186a48:	681b      	ldr	r3, [r3, #0]
34186a4a:	4618      	mov	r0, r3
34186a4c:	f7ff fe79 	bl	34186742 <LL_ADC_REG_ReadConversionData32>
34186a50:	4603      	mov	r3, r0
34186a52:	461a      	mov	r2, r3
34186a54:	69fb      	ldr	r3, [r7, #28]
34186a56:	4413      	add	r3, r2
34186a58:	61fb      	str	r3, [r7, #28]
      for (calibration_step = 0; calibration_step < ADC_CALIBRATION_STEPS; calibration_step++)
34186a5a:	69bb      	ldr	r3, [r7, #24]
34186a5c:	3301      	adds	r3, #1
34186a5e:	61bb      	str	r3, [r7, #24]
34186a60:	69bb      	ldr	r3, [r7, #24]
34186a62:	2b07      	cmp	r3, #7
34186a64:	d9c1      	bls.n	341869ea <ADC_Calibration_MeasureOffset+0x36>
      } /* end of calibration steps */

      /* Compute the average data */
      calib_factor_avg = calib_factor_avg / (int32_t)(calibration_step);
34186a66:	69bb      	ldr	r3, [r7, #24]
34186a68:	69fa      	ldr	r2, [r7, #28]
34186a6a:	fb92 f3f3 	sdiv	r3, r2, r3
34186a6e:	61fb      	str	r3, [r7, #28]

      if (SingleDiff == ADC_DIFFERENTIAL_ENDED)
34186a70:	68bb      	ldr	r3, [r7, #8]
34186a72:	4a1c      	ldr	r2, [pc, #112]	@ (34186ae4 <ADC_Calibration_MeasureOffset+0x130>)
34186a74:	4293      	cmp	r3, r2
34186a76:	d103      	bne.n	34186a80 <ADC_Calibration_MeasureOffset+0xcc>
      {
        /* In differential mode, subtract averaged data by 0x7FF (middle      */
        /* value for differential ended corresponding to a null offset)      */
        calib_factor_avg = calib_factor_avg - 0x7FF;
34186a78:	69fb      	ldr	r3, [r7, #28]
34186a7a:	f2a3 73ff 	subw	r3, r3, #2047	@ 0x7ff
34186a7e:	61fb      	str	r3, [r7, #28]
      }
      else
      {
        /* nothing to do */
      }
      if (calib_factor_avg <= 0)
34186a80:	69fb      	ldr	r3, [r7, #28]
34186a82:	2b00      	cmp	r3, #0
34186a84:	dc16      	bgt.n	34186ab4 <ADC_Calibration_MeasureOffset+0x100>
      {
        if (LL_ADC_IsCalibrationOffsetEnabled(hadc->Instance) == 0UL)
34186a86:	68fb      	ldr	r3, [r7, #12]
34186a88:	681b      	ldr	r3, [r3, #0]
34186a8a:	4618      	mov	r0, r3
34186a8c:	f7ff fe1f 	bl	341866ce <LL_ADC_IsCalibrationOffsetEnabled>
34186a90:	4603      	mov	r3, r0
34186a92:	2b00      	cmp	r3, #0
34186a94:	d105      	bne.n	34186aa2 <ADC_Calibration_MeasureOffset+0xee>
        {
          LL_ADC_EnableCalibrationOffset(hadc->Instance);
34186a96:	68fb      	ldr	r3, [r7, #12]
34186a98:	681b      	ldr	r3, [r3, #0]
34186a9a:	4618      	mov	r0, r3
34186a9c:	f7ff fdf3 	bl	34186686 <LL_ADC_EnableCalibrationOffset>
34186aa0:	e00b      	b.n	34186aba <ADC_Calibration_MeasureOffset+0x106>
        }
        else
        {
          /* If calibration additional offset is enabled, measured calibration */
          /* factor should be different than 0.                                */
          tmp_hal_status = HAL_ERROR;
34186aa2:	2301      	movs	r3, #1
34186aa4:	75fb      	strb	r3, [r7, #23]

          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
34186aa6:	68fb      	ldr	r3, [r7, #12]
34186aa8:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34186aaa:	f043 0210 	orr.w	r2, r3, #16
34186aae:	68fb      	ldr	r3, [r7, #12]
34186ab0:	659a      	str	r2, [r3, #88]	@ 0x58
34186ab2:	e002      	b.n	34186aba <ADC_Calibration_MeasureOffset+0x106>
        }
      }
      else
      {
        *pCalibrationFactor = (uint32_t)(calib_factor_avg);
34186ab4:	69fa      	ldr	r2, [r7, #28]
34186ab6:	687b      	ldr	r3, [r7, #4]
34186ab8:	601a      	str	r2, [r3, #0]
      }
    } while ((calib_factor_avg <= 0) && (tmp_hal_status == HAL_OK));
34186aba:	69fb      	ldr	r3, [r7, #28]
34186abc:	2b00      	cmp	r3, #0
34186abe:	dc0b      	bgt.n	34186ad8 <ADC_Calibration_MeasureOffset+0x124>
34186ac0:	7dfb      	ldrb	r3, [r7, #23]
34186ac2:	2b00      	cmp	r3, #0
34186ac4:	d08e      	beq.n	341869e4 <ADC_Calibration_MeasureOffset+0x30>
34186ac6:	e007      	b.n	34186ad8 <ADC_Calibration_MeasureOffset+0x124>
  }
  else
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
34186ac8:	68fb      	ldr	r3, [r7, #12]
34186aca:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34186acc:	f043 0210 	orr.w	r2, r3, #16
34186ad0:	68fb      	ldr	r3, [r7, #12]
34186ad2:	659a      	str	r2, [r3, #88]	@ 0x58

    tmp_hal_status = HAL_ERROR;
34186ad4:	2301      	movs	r3, #1
34186ad6:	75fb      	strb	r3, [r7, #23]
  }

  return tmp_hal_status;
34186ad8:	7dfb      	ldrb	r3, [r7, #23]
}
34186ada:	4618      	mov	r0, r3
34186adc:	3720      	adds	r7, #32
34186ade:	46bd      	mov	sp, r7
34186ae0:	bd80      	pop	{r7, pc}
34186ae2:	bf00      	nop
34186ae4:	43ff0000 	.word	0x43ff0000

34186ae8 <__NVIC_SetPriorityGrouping>:
{
34186ae8:	b480      	push	{r7}
34186aea:	b085      	sub	sp, #20
34186aec:	af00      	add	r7, sp, #0
34186aee:	6078      	str	r0, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
34186af0:	687b      	ldr	r3, [r7, #4]
34186af2:	f003 0307 	and.w	r3, r3, #7
34186af6:	60fb      	str	r3, [r7, #12]
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
34186af8:	4b0c      	ldr	r3, [pc, #48]	@ (34186b2c <__NVIC_SetPriorityGrouping+0x44>)
34186afa:	68db      	ldr	r3, [r3, #12]
34186afc:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
34186afe:	68ba      	ldr	r2, [r7, #8]
34186b00:	f64f 03ff 	movw	r3, #63743	@ 0xf8ff
34186b04:	4013      	ands	r3, r2
34186b06:	60bb      	str	r3, [r7, #8]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
34186b08:	68fb      	ldr	r3, [r7, #12]
34186b0a:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
34186b0c:	68bb      	ldr	r3, [r7, #8]
34186b0e:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
34186b10:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
34186b14:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
34186b18:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
34186b1a:	4a04      	ldr	r2, [pc, #16]	@ (34186b2c <__NVIC_SetPriorityGrouping+0x44>)
34186b1c:	68bb      	ldr	r3, [r7, #8]
34186b1e:	60d3      	str	r3, [r2, #12]
}
34186b20:	bf00      	nop
34186b22:	3714      	adds	r7, #20
34186b24:	46bd      	mov	sp, r7
34186b26:	f85d 7b04 	ldr.w	r7, [sp], #4
34186b2a:	4770      	bx	lr
34186b2c:	e000ed00 	.word	0xe000ed00

34186b30 <__NVIC_GetPriorityGrouping>:
{
34186b30:	b480      	push	{r7}
34186b32:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
34186b34:	4b04      	ldr	r3, [pc, #16]	@ (34186b48 <__NVIC_GetPriorityGrouping+0x18>)
34186b36:	68db      	ldr	r3, [r3, #12]
34186b38:	0a1b      	lsrs	r3, r3, #8
34186b3a:	f003 0307 	and.w	r3, r3, #7
}
34186b3e:	4618      	mov	r0, r3
34186b40:	46bd      	mov	sp, r7
34186b42:	f85d 7b04 	ldr.w	r7, [sp], #4
34186b46:	4770      	bx	lr
34186b48:	e000ed00 	.word	0xe000ed00

34186b4c <__NVIC_EnableIRQ>:
{
34186b4c:	b480      	push	{r7}
34186b4e:	b083      	sub	sp, #12
34186b50:	af00      	add	r7, sp, #0
34186b52:	4603      	mov	r3, r0
34186b54:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
34186b56:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
34186b5a:	2b00      	cmp	r3, #0
34186b5c:	db0b      	blt.n	34186b76 <__NVIC_EnableIRQ+0x2a>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
34186b5e:	88fb      	ldrh	r3, [r7, #6]
34186b60:	f003 021f 	and.w	r2, r3, #31
34186b64:	4907      	ldr	r1, [pc, #28]	@ (34186b84 <__NVIC_EnableIRQ+0x38>)
34186b66:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
34186b6a:	095b      	lsrs	r3, r3, #5
34186b6c:	2001      	movs	r0, #1
34186b6e:	fa00 f202 	lsl.w	r2, r0, r2
34186b72:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
34186b76:	bf00      	nop
34186b78:	370c      	adds	r7, #12
34186b7a:	46bd      	mov	sp, r7
34186b7c:	f85d 7b04 	ldr.w	r7, [sp], #4
34186b80:	4770      	bx	lr
34186b82:	bf00      	nop
34186b84:	e000e100 	.word	0xe000e100

34186b88 <__NVIC_SetPriority>:
{
34186b88:	b480      	push	{r7}
34186b8a:	b083      	sub	sp, #12
34186b8c:	af00      	add	r7, sp, #0
34186b8e:	4603      	mov	r3, r0
34186b90:	6039      	str	r1, [r7, #0]
34186b92:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
34186b94:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
34186b98:	2b00      	cmp	r3, #0
34186b9a:	db0a      	blt.n	34186bb2 <__NVIC_SetPriority+0x2a>
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
34186b9c:	683b      	ldr	r3, [r7, #0]
34186b9e:	b2da      	uxtb	r2, r3
34186ba0:	490c      	ldr	r1, [pc, #48]	@ (34186bd4 <__NVIC_SetPriority+0x4c>)
34186ba2:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
34186ba6:	0112      	lsls	r2, r2, #4
34186ba8:	b2d2      	uxtb	r2, r2
34186baa:	440b      	add	r3, r1
34186bac:	f883 2300 	strb.w	r2, [r3, #768]	@ 0x300
}
34186bb0:	e00a      	b.n	34186bc8 <__NVIC_SetPriority+0x40>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
34186bb2:	683b      	ldr	r3, [r7, #0]
34186bb4:	b2da      	uxtb	r2, r3
34186bb6:	4908      	ldr	r1, [pc, #32]	@ (34186bd8 <__NVIC_SetPriority+0x50>)
34186bb8:	88fb      	ldrh	r3, [r7, #6]
34186bba:	f003 030f 	and.w	r3, r3, #15
34186bbe:	3b04      	subs	r3, #4
34186bc0:	0112      	lsls	r2, r2, #4
34186bc2:	b2d2      	uxtb	r2, r2
34186bc4:	440b      	add	r3, r1
34186bc6:	761a      	strb	r2, [r3, #24]
}
34186bc8:	bf00      	nop
34186bca:	370c      	adds	r7, #12
34186bcc:	46bd      	mov	sp, r7
34186bce:	f85d 7b04 	ldr.w	r7, [sp], #4
34186bd2:	4770      	bx	lr
34186bd4:	e000e100 	.word	0xe000e100
34186bd8:	e000ed00 	.word	0xe000ed00

34186bdc <NVIC_EncodePriority>:
{
34186bdc:	b480      	push	{r7}
34186bde:	b089      	sub	sp, #36	@ 0x24
34186be0:	af00      	add	r7, sp, #0
34186be2:	60f8      	str	r0, [r7, #12]
34186be4:	60b9      	str	r1, [r7, #8]
34186be6:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
34186be8:	68fb      	ldr	r3, [r7, #12]
34186bea:	f003 0307 	and.w	r3, r3, #7
34186bee:	61fb      	str	r3, [r7, #28]
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
34186bf0:	69fb      	ldr	r3, [r7, #28]
34186bf2:	f1c3 0307 	rsb	r3, r3, #7
34186bf6:	2b04      	cmp	r3, #4
34186bf8:	bf28      	it	cs
34186bfa:	2304      	movcs	r3, #4
34186bfc:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
34186bfe:	69fb      	ldr	r3, [r7, #28]
34186c00:	3304      	adds	r3, #4
34186c02:	2b06      	cmp	r3, #6
34186c04:	d902      	bls.n	34186c0c <NVIC_EncodePriority+0x30>
34186c06:	69fb      	ldr	r3, [r7, #28]
34186c08:	3b03      	subs	r3, #3
34186c0a:	e000      	b.n	34186c0e <NVIC_EncodePriority+0x32>
34186c0c:	2300      	movs	r3, #0
34186c0e:	617b      	str	r3, [r7, #20]
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
34186c10:	f04f 32ff 	mov.w	r2, #4294967295
34186c14:	69bb      	ldr	r3, [r7, #24]
34186c16:	fa02 f303 	lsl.w	r3, r2, r3
34186c1a:	43da      	mvns	r2, r3
34186c1c:	68bb      	ldr	r3, [r7, #8]
34186c1e:	401a      	ands	r2, r3
34186c20:	697b      	ldr	r3, [r7, #20]
34186c22:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
34186c24:	f04f 31ff 	mov.w	r1, #4294967295
34186c28:	697b      	ldr	r3, [r7, #20]
34186c2a:	fa01 f303 	lsl.w	r3, r1, r3
34186c2e:	43d9      	mvns	r1, r3
34186c30:	687b      	ldr	r3, [r7, #4]
34186c32:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
34186c34:	4313      	orrs	r3, r2
}
34186c36:	4618      	mov	r0, r3
34186c38:	3724      	adds	r7, #36	@ 0x24
34186c3a:	46bd      	mov	sp, r7
34186c3c:	f85d 7b04 	ldr.w	r7, [sp], #4
34186c40:	4770      	bx	lr

34186c42 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ pre-emption is no more possible.
  *         The pending IRQ priority will be managed only by the subpriority.
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
34186c42:	b580      	push	{r7, lr}
34186c44:	b082      	sub	sp, #8
34186c46:	af00      	add	r7, sp, #0
34186c48:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
34186c4a:	6878      	ldr	r0, [r7, #4]
34186c4c:	f7ff ff4c 	bl	34186ae8 <__NVIC_SetPriorityGrouping>
}
34186c50:	bf00      	nop
34186c52:	3708      	adds	r7, #8
34186c54:	46bd      	mov	sp, r7
34186c56:	bd80      	pop	{r7, pc}

34186c58 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
34186c58:	b580      	push	{r7, lr}
34186c5a:	b086      	sub	sp, #24
34186c5c:	af00      	add	r7, sp, #0
34186c5e:	4603      	mov	r3, r0
34186c60:	60b9      	str	r1, [r7, #8]
34186c62:	607a      	str	r2, [r7, #4]
34186c64:	81fb      	strh	r3, [r7, #14]
  uint32_t prioritygroup;

  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_INTERRUPT(IRQn));

  prioritygroup = (NVIC_GetPriorityGrouping() & 0x7U);
34186c66:	f7ff ff63 	bl	34186b30 <__NVIC_GetPriorityGrouping>
34186c6a:	4603      	mov	r3, r0
34186c6c:	f003 0307 	and.w	r3, r3, #7
34186c70:	617b      	str	r3, [r7, #20]
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority, prioritygroup));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority, prioritygroup));

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
34186c72:	687a      	ldr	r2, [r7, #4]
34186c74:	68b9      	ldr	r1, [r7, #8]
34186c76:	6978      	ldr	r0, [r7, #20]
34186c78:	f7ff ffb0 	bl	34186bdc <NVIC_EncodePriority>
34186c7c:	4602      	mov	r2, r0
34186c7e:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
34186c82:	4611      	mov	r1, r2
34186c84:	4618      	mov	r0, r3
34186c86:	f7ff ff7f 	bl	34186b88 <__NVIC_SetPriority>
}
34186c8a:	bf00      	nop
34186c8c:	3718      	adds	r7, #24
34186c8e:	46bd      	mov	sp, r7
34186c90:	bd80      	pop	{r7, pc}

34186c92 <HAL_NVIC_EnableIRQ>:
  *         (For the complete STM32 Devices IRQ Channels list, please refer
  *         to the appropriate CMSIS device file (stm32n6xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
34186c92:	b580      	push	{r7, lr}
34186c94:	b082      	sub	sp, #8
34186c96:	af00      	add	r7, sp, #0
34186c98:	4603      	mov	r3, r0
34186c9a:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
34186c9c:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
34186ca0:	4618      	mov	r0, r3
34186ca2:	f7ff ff53 	bl	34186b4c <__NVIC_EnableIRQ>
}
34186ca6:	bf00      	nop
34186ca8:	3708      	adds	r7, #8
34186caa:	46bd      	mov	sp, r7
34186cac:	bd80      	pop	{r7, pc}
	...

34186cb0 <HAL_MPU_Enable>:
  *            @arg MPU_PRIVILEGED_DEFAULT
  *            @arg MPU_HFNMI_PRIVDEF
  * @retval None
  */
void HAL_MPU_Enable(uint32_t MPU_Control)
{
34186cb0:	b480      	push	{r7}
34186cb2:	b083      	sub	sp, #12
34186cb4:	af00      	add	r7, sp, #0
34186cb6:	6078      	str	r0, [r7, #4]
  __ASM volatile ("dmb 0xF":::"memory");
34186cb8:	f3bf 8f5f 	dmb	sy
}
34186cbc:	bf00      	nop
  __DMB(); /* Force any outstanding transfers to complete before enabling MPU */

  /* Enable the MPU */
  MPU->CTRL = (MPU_Control | MPU_CTRL_ENABLE_Msk);
34186cbe:	4a0b      	ldr	r2, [pc, #44]	@ (34186cec <HAL_MPU_Enable+0x3c>)
34186cc0:	687b      	ldr	r3, [r7, #4]
34186cc2:	f043 0301 	orr.w	r3, r3, #1
34186cc6:	6053      	str	r3, [r2, #4]

  /* Enable fault exceptions */
  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
34186cc8:	4b09      	ldr	r3, [pc, #36]	@ (34186cf0 <HAL_MPU_Enable+0x40>)
34186cca:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34186ccc:	4a08      	ldr	r2, [pc, #32]	@ (34186cf0 <HAL_MPU_Enable+0x40>)
34186cce:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
34186cd2:	6253      	str	r3, [r2, #36]	@ 0x24
  __ASM volatile ("dsb 0xF":::"memory");
34186cd4:	f3bf 8f4f 	dsb	sy
}
34186cd8:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
34186cda:	f3bf 8f6f 	isb	sy
}
34186cde:	bf00      	nop

  /* Ensure MPU setting take effects */
  __DSB();
  __ISB();
}
34186ce0:	bf00      	nop
34186ce2:	370c      	adds	r7, #12
34186ce4:	46bd      	mov	sp, r7
34186ce6:	f85d 7b04 	ldr.w	r7, [sp], #4
34186cea:	4770      	bx	lr
34186cec:	e000ed90 	.word	0xe000ed90
34186cf0:	e000ed00 	.word	0xe000ed00

34186cf4 <HAL_MPU_Disable>:
/**
  * @brief  Disable the MPU.
  * @retval None
  */
void HAL_MPU_Disable(void)
{
34186cf4:	b480      	push	{r7}
34186cf6:	af00      	add	r7, sp, #0
  __ASM volatile ("dmb 0xF":::"memory");
34186cf8:	f3bf 8f5f 	dmb	sy
}
34186cfc:	bf00      	nop
  __DMB(); /* Force any outstanding transfers to complete before disabling MPU */

  /* Disable fault exceptions */
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
34186cfe:	4b0b      	ldr	r3, [pc, #44]	@ (34186d2c <HAL_MPU_Disable+0x38>)
34186d00:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34186d02:	4a0a      	ldr	r2, [pc, #40]	@ (34186d2c <HAL_MPU_Disable+0x38>)
34186d04:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
34186d08:	6253      	str	r3, [r2, #36]	@ 0x24

  /* Disable the MPU */
  MPU->CTRL &= ~MPU_CTRL_ENABLE_Msk;
34186d0a:	4b09      	ldr	r3, [pc, #36]	@ (34186d30 <HAL_MPU_Disable+0x3c>)
34186d0c:	685b      	ldr	r3, [r3, #4]
34186d0e:	4a08      	ldr	r2, [pc, #32]	@ (34186d30 <HAL_MPU_Disable+0x3c>)
34186d10:	f023 0301 	bic.w	r3, r3, #1
34186d14:	6053      	str	r3, [r2, #4]
  __ASM volatile ("dsb 0xF":::"memory");
34186d16:	f3bf 8f4f 	dsb	sy
}
34186d1a:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
34186d1c:	f3bf 8f6f 	isb	sy
}
34186d20:	bf00      	nop

  /* Ensure MPU setting take effects */
  __DSB();
  __ISB();
}
34186d22:	bf00      	nop
34186d24:	46bd      	mov	sp, r7
34186d26:	f85d 7b04 	ldr.w	r7, [sp], #4
34186d2a:	4770      	bx	lr
34186d2c:	e000ed00 	.word	0xe000ed00
34186d30:	e000ed90 	.word	0xe000ed90

34186d34 <HAL_MPU_ConfigRegion>:
  * @param  pMPU_RegionInit Pointer to a MPU_Region_InitTypeDef structure that contains
  *                         the initialization and configuration information.
  * @retval None
  */
void HAL_MPU_ConfigRegion(const MPU_Region_InitTypeDef *pMPU_RegionInit)
{
34186d34:	b580      	push	{r7, lr}
34186d36:	b082      	sub	sp, #8
34186d38:	af00      	add	r7, sp, #0
34186d3a:	6078      	str	r0, [r7, #4]
  MPU_ConfigRegion(MPU, pMPU_RegionInit);
34186d3c:	6879      	ldr	r1, [r7, #4]
34186d3e:	4803      	ldr	r0, [pc, #12]	@ (34186d4c <HAL_MPU_ConfigRegion+0x18>)
34186d40:	f000 f814 	bl	34186d6c <MPU_ConfigRegion>
}
34186d44:	bf00      	nop
34186d46:	3708      	adds	r7, #8
34186d48:	46bd      	mov	sp, r7
34186d4a:	bd80      	pop	{r7, pc}
34186d4c:	e000ed90 	.word	0xe000ed90

34186d50 <HAL_MPU_ConfigMemoryAttributes>:
  * @param  pMPU_AttributesInit Pointer to a MPU_Attributes_InitTypeDef structure that contains
  *                             the initialization and configuration information.
  * @retval None
  */
void HAL_MPU_ConfigMemoryAttributes(const MPU_Attributes_InitTypeDef *pMPU_AttributesInit)
{
34186d50:	b580      	push	{r7, lr}
34186d52:	b082      	sub	sp, #8
34186d54:	af00      	add	r7, sp, #0
34186d56:	6078      	str	r0, [r7, #4]
  MPU_ConfigMemoryAttributes(MPU, pMPU_AttributesInit);
34186d58:	6879      	ldr	r1, [r7, #4]
34186d5a:	4803      	ldr	r0, [pc, #12]	@ (34186d68 <HAL_MPU_ConfigMemoryAttributes+0x18>)
34186d5c:	f000 f83e 	bl	34186ddc <MPU_ConfigMemoryAttributes>
}
34186d60:	bf00      	nop
34186d62:	3708      	adds	r7, #8
34186d64:	46bd      	mov	sp, r7
34186d66:	bd80      	pop	{r7, pc}
34186d68:	e000ed90 	.word	0xe000ed90

34186d6c <MPU_ConfigRegion>:

/** @addtogroup CORTEX_Private_Functions
  * @{
  */
static void MPU_ConfigRegion(MPU_Type *MPUx, const MPU_Region_InitTypeDef *pMPU_RegionInit)
{
34186d6c:	b480      	push	{r7}
34186d6e:	b083      	sub	sp, #12
34186d70:	af00      	add	r7, sp, #0
34186d72:	6078      	str	r0, [r7, #4]
34186d74:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_MPU_REGION_NUMBER(pMPU_RegionInit->Number));
  assert_param(IS_MPU_REGION_ENABLE(pMPU_RegionInit->Enable));

  /* Set the Region number */
  MPUx->RNR = pMPU_RegionInit->Number;
34186d76:	683b      	ldr	r3, [r7, #0]
34186d78:	785b      	ldrb	r3, [r3, #1]
34186d7a:	461a      	mov	r2, r3
34186d7c:	687b      	ldr	r3, [r7, #4]
34186d7e:	609a      	str	r2, [r3, #8]

  /* Disable the Region */
  CLEAR_BIT(MPUx->RLAR, MPU_RLAR_EN_Msk);
34186d80:	687b      	ldr	r3, [r7, #4]
34186d82:	691b      	ldr	r3, [r3, #16]
34186d84:	f023 0201 	bic.w	r2, r3, #1
34186d88:	687b      	ldr	r3, [r7, #4]
34186d8a:	611a      	str	r2, [r3, #16]
  assert_param(IS_MPU_PRIV_INSTRUCTION_ACCESS(pMPU_RegionInit->DisablePrivExec));
  assert_param(IS_MPU_REGION_PERMISSION_ATTRIBUTE(pMPU_RegionInit->AccessPermission));
  assert_param(IS_MPU_ACCESS_SHAREABLE(pMPU_RegionInit->IsShareable));
  assert_param(IS_MPU_ATTRIBUTES_NUMBER(pMPU_RegionInit->AttributesIndex));

  MPUx->RBAR = (((uint32_t)pMPU_RegionInit->BaseAddress & 0xFFFFFFE0UL)  |
34186d8c:	683b      	ldr	r3, [r7, #0]
34186d8e:	685b      	ldr	r3, [r3, #4]
34186d90:	f023 021f 	bic.w	r2, r3, #31
                ((uint32_t)pMPU_RegionInit->IsShareable      << MPU_RBAR_SH_Pos)  |
34186d94:	683b      	ldr	r3, [r7, #0]
34186d96:	7bdb      	ldrb	r3, [r3, #15]
34186d98:	00db      	lsls	r3, r3, #3
  MPUx->RBAR = (((uint32_t)pMPU_RegionInit->BaseAddress & 0xFFFFFFE0UL)  |
34186d9a:	431a      	orrs	r2, r3
                ((uint32_t)pMPU_RegionInit->AccessPermission << MPU_RBAR_AP_Pos)  |
34186d9c:	683b      	ldr	r3, [r7, #0]
34186d9e:	7b1b      	ldrb	r3, [r3, #12]
34186da0:	005b      	lsls	r3, r3, #1
                ((uint32_t)pMPU_RegionInit->IsShareable      << MPU_RBAR_SH_Pos)  |
34186da2:	4313      	orrs	r3, r2
                ((uint32_t)pMPU_RegionInit->DisableExec      << MPU_RBAR_XN_Pos));
34186da4:	683a      	ldr	r2, [r7, #0]
34186da6:	7b52      	ldrb	r2, [r2, #13]
                ((uint32_t)pMPU_RegionInit->AccessPermission << MPU_RBAR_AP_Pos)  |
34186da8:	431a      	orrs	r2, r3
  MPUx->RBAR = (((uint32_t)pMPU_RegionInit->BaseAddress & 0xFFFFFFE0UL)  |
34186daa:	687b      	ldr	r3, [r7, #4]
34186dac:	60da      	str	r2, [r3, #12]

  MPUx->RLAR = (((uint32_t)pMPU_RegionInit->LimitAddress & 0xFFFFFFE0UL) |
34186dae:	683b      	ldr	r3, [r7, #0]
34186db0:	689b      	ldr	r3, [r3, #8]
34186db2:	f023 021f 	bic.w	r2, r3, #31
                ((uint32_t)pMPU_RegionInit->DisablePrivExec << MPU_RLAR_PXN_Pos) |
34186db6:	683b      	ldr	r3, [r7, #0]
34186db8:	7b9b      	ldrb	r3, [r3, #14]
34186dba:	011b      	lsls	r3, r3, #4
  MPUx->RLAR = (((uint32_t)pMPU_RegionInit->LimitAddress & 0xFFFFFFE0UL) |
34186dbc:	431a      	orrs	r2, r3
                ((uint32_t)pMPU_RegionInit->AttributesIndex  << MPU_RLAR_AttrIndx_Pos) |
34186dbe:	683b      	ldr	r3, [r7, #0]
34186dc0:	789b      	ldrb	r3, [r3, #2]
34186dc2:	005b      	lsls	r3, r3, #1
                ((uint32_t)pMPU_RegionInit->DisablePrivExec << MPU_RLAR_PXN_Pos) |
34186dc4:	4313      	orrs	r3, r2
                ((uint32_t)pMPU_RegionInit->Enable           << MPU_RLAR_EN_Pos));
34186dc6:	683a      	ldr	r2, [r7, #0]
34186dc8:	7812      	ldrb	r2, [r2, #0]
                ((uint32_t)pMPU_RegionInit->AttributesIndex  << MPU_RLAR_AttrIndx_Pos) |
34186dca:	431a      	orrs	r2, r3
  MPUx->RLAR = (((uint32_t)pMPU_RegionInit->LimitAddress & 0xFFFFFFE0UL) |
34186dcc:	687b      	ldr	r3, [r7, #4]
34186dce:	611a      	str	r2, [r3, #16]
}
34186dd0:	bf00      	nop
34186dd2:	370c      	adds	r7, #12
34186dd4:	46bd      	mov	sp, r7
34186dd6:	f85d 7b04 	ldr.w	r7, [sp], #4
34186dda:	4770      	bx	lr

34186ddc <MPU_ConfigMemoryAttributes>:

static void MPU_ConfigMemoryAttributes(MPU_Type *MPUx, const MPU_Attributes_InitTypeDef *pMPU_AttributesInit)
{
34186ddc:	b480      	push	{r7}
34186dde:	b087      	sub	sp, #28
34186de0:	af00      	add	r7, sp, #0
34186de2:	6078      	str	r0, [r7, #4]
34186de4:	6039      	str	r1, [r7, #0]

  /* Check the parameters */
  assert_param(IS_MPU_ATTRIBUTES_NUMBER(pMPU_AttributesInit->Number));
  /* No need to check Attributes value as all 0x0..0xFF possible */

  if (pMPU_AttributesInit->Number < MPU_ATTRIBUTES_NUMBER4)
34186de6:	683b      	ldr	r3, [r7, #0]
34186de8:	781b      	ldrb	r3, [r3, #0]
34186dea:	2b03      	cmp	r3, #3
34186dec:	d806      	bhi.n	34186dfc <MPU_ConfigMemoryAttributes+0x20>
  {
    /* Program MPU_MAIR0 */
    p_mair = &(MPUx->MAIR0);
34186dee:	687b      	ldr	r3, [r7, #4]
34186df0:	3330      	adds	r3, #48	@ 0x30
34186df2:	617b      	str	r3, [r7, #20]
    attr_number = pMPU_AttributesInit->Number;
34186df4:	683b      	ldr	r3, [r7, #0]
34186df6:	781b      	ldrb	r3, [r3, #0]
34186df8:	613b      	str	r3, [r7, #16]
34186dfa:	e006      	b.n	34186e0a <MPU_ConfigMemoryAttributes+0x2e>
  }
  else
  {
    /* Program MPU_MAIR1 */
    p_mair = &(MPUx->MAIR1);
34186dfc:	687b      	ldr	r3, [r7, #4]
34186dfe:	3334      	adds	r3, #52	@ 0x34
34186e00:	617b      	str	r3, [r7, #20]
    attr_number = (uint32_t)pMPU_AttributesInit->Number - 4U;
34186e02:	683b      	ldr	r3, [r7, #0]
34186e04:	781b      	ldrb	r3, [r3, #0]
34186e06:	3b04      	subs	r3, #4
34186e08:	613b      	str	r3, [r7, #16]
  }

  attr_values = *(p_mair);
34186e0a:	697b      	ldr	r3, [r7, #20]
34186e0c:	681b      	ldr	r3, [r3, #0]
34186e0e:	60fb      	str	r3, [r7, #12]
  attr_values &=  ~(0xFFU << (attr_number * 8U));
34186e10:	693b      	ldr	r3, [r7, #16]
34186e12:	00db      	lsls	r3, r3, #3
34186e14:	22ff      	movs	r2, #255	@ 0xff
34186e16:	fa02 f303 	lsl.w	r3, r2, r3
34186e1a:	43db      	mvns	r3, r3
34186e1c:	68fa      	ldr	r2, [r7, #12]
34186e1e:	4013      	ands	r3, r2
34186e20:	60fb      	str	r3, [r7, #12]
  *(p_mair) = attr_values | ((uint32_t)pMPU_AttributesInit->Attributes << (attr_number * 8U));
34186e22:	683b      	ldr	r3, [r7, #0]
34186e24:	785b      	ldrb	r3, [r3, #1]
34186e26:	461a      	mov	r2, r3
34186e28:	693b      	ldr	r3, [r7, #16]
34186e2a:	00db      	lsls	r3, r3, #3
34186e2c:	409a      	lsls	r2, r3
34186e2e:	68fb      	ldr	r3, [r7, #12]
34186e30:	431a      	orrs	r2, r3
34186e32:	697b      	ldr	r3, [r7, #20]
34186e34:	601a      	str	r2, [r3, #0]
}
34186e36:	bf00      	nop
34186e38:	371c      	adds	r7, #28
34186e3a:	46bd      	mov	sp, r7
34186e3c:	f85d 7b04 	ldr.w	r7, [sp], #4
34186e40:	4770      	bx	lr
	...

34186e44 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, const GPIO_InitTypeDef *GPIO_Init)
{
34186e44:	b480      	push	{r7}
34186e46:	b087      	sub	sp, #28
34186e48:	af00      	add	r7, sp, #0
34186e4a:	6078      	str	r0, [r7, #4]
34186e4c:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00u;
34186e4e:	2300      	movs	r3, #0
34186e50:	617b      	str	r3, [r7, #20]
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
34186e52:	e180      	b.n	34187156 <HAL_GPIO_Init+0x312>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
34186e54:	683b      	ldr	r3, [r7, #0]
34186e56:	681a      	ldr	r2, [r3, #0]
34186e58:	2101      	movs	r1, #1
34186e5a:	697b      	ldr	r3, [r7, #20]
34186e5c:	fa01 f303 	lsl.w	r3, r1, r3
34186e60:	4013      	ands	r3, r2
34186e62:	60fb      	str	r3, [r7, #12]

    if (iocurrent != 0x00u)
34186e64:	68fb      	ldr	r3, [r7, #12]
34186e66:	2b00      	cmp	r3, #0
34186e68:	f000 8172 	beq.w	34187150 <HAL_GPIO_Init+0x30c>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
34186e6c:	683b      	ldr	r3, [r7, #0]
34186e6e:	685b      	ldr	r3, [r3, #4]
34186e70:	f003 0303 	and.w	r3, r3, #3
34186e74:	2b01      	cmp	r3, #1
34186e76:	d005      	beq.n	34186e84 <HAL_GPIO_Init+0x40>
34186e78:	683b      	ldr	r3, [r7, #0]
34186e7a:	685b      	ldr	r3, [r3, #4]
34186e7c:	f003 0303 	and.w	r3, r3, #3
34186e80:	2b02      	cmp	r3, #2
34186e82:	d130      	bne.n	34186ee6 <HAL_GPIO_Init+0xa2>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));

        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
34186e84:	687b      	ldr	r3, [r7, #4]
34186e86:	689b      	ldr	r3, [r3, #8]
34186e88:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * GPIO_OSPEEDR_OSPEED1_Pos));
34186e8a:	697b      	ldr	r3, [r7, #20]
34186e8c:	005b      	lsls	r3, r3, #1
34186e8e:	2203      	movs	r2, #3
34186e90:	fa02 f303 	lsl.w	r3, r2, r3
34186e94:	43db      	mvns	r3, r3
34186e96:	693a      	ldr	r2, [r7, #16]
34186e98:	4013      	ands	r3, r2
34186e9a:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_Init->Speed << (position * GPIO_OSPEEDR_OSPEED1_Pos));
34186e9c:	683b      	ldr	r3, [r7, #0]
34186e9e:	68da      	ldr	r2, [r3, #12]
34186ea0:	697b      	ldr	r3, [r7, #20]
34186ea2:	005b      	lsls	r3, r3, #1
34186ea4:	fa02 f303 	lsl.w	r3, r2, r3
34186ea8:	693a      	ldr	r2, [r7, #16]
34186eaa:	4313      	orrs	r3, r2
34186eac:	613b      	str	r3, [r7, #16]
        GPIOx->OSPEEDR = temp;
34186eae:	687b      	ldr	r3, [r7, #4]
34186eb0:	693a      	ldr	r2, [r7, #16]
34186eb2:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
34186eb4:	687b      	ldr	r3, [r7, #4]
34186eb6:	685b      	ldr	r3, [r3, #4]
34186eb8:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
34186eba:	2201      	movs	r2, #1
34186ebc:	697b      	ldr	r3, [r7, #20]
34186ebe:	fa02 f303 	lsl.w	r3, r2, r3
34186ec2:	43db      	mvns	r3, r3
34186ec4:	693a      	ldr	r2, [r7, #16]
34186ec6:	4013      	ands	r3, r2
34186ec8:	613b      	str	r3, [r7, #16]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
34186eca:	683b      	ldr	r3, [r7, #0]
34186ecc:	685b      	ldr	r3, [r3, #4]
34186ece:	091b      	lsrs	r3, r3, #4
34186ed0:	f003 0201 	and.w	r2, r3, #1
34186ed4:	697b      	ldr	r3, [r7, #20]
34186ed6:	fa02 f303 	lsl.w	r3, r2, r3
34186eda:	693a      	ldr	r2, [r7, #16]
34186edc:	4313      	orrs	r3, r2
34186ede:	613b      	str	r3, [r7, #16]
        GPIOx->OTYPER = temp;
34186ee0:	687b      	ldr	r3, [r7, #4]
34186ee2:	693a      	ldr	r2, [r7, #16]
34186ee4:	605a      	str	r2, [r3, #4]
      }

      if (((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG) ||
34186ee6:	683b      	ldr	r3, [r7, #0]
34186ee8:	685b      	ldr	r3, [r3, #4]
34186eea:	f003 0303 	and.w	r3, r3, #3
34186eee:	2b03      	cmp	r3, #3
34186ef0:	d109      	bne.n	34186f06 <HAL_GPIO_Init+0xc2>
          (((GPIO_Init->Mode & GPIO_MODE) == MODE_ANALOG) && (GPIO_Init->Pull != GPIO_PULLUP)))
34186ef2:	683b      	ldr	r3, [r7, #0]
34186ef4:	685b      	ldr	r3, [r3, #4]
34186ef6:	f003 0303 	and.w	r3, r3, #3
      if (((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG) ||
34186efa:	2b03      	cmp	r3, #3
34186efc:	d11b      	bne.n	34186f36 <HAL_GPIO_Init+0xf2>
          (((GPIO_Init->Mode & GPIO_MODE) == MODE_ANALOG) && (GPIO_Init->Pull != GPIO_PULLUP)))
34186efe:	683b      	ldr	r3, [r7, #0]
34186f00:	689b      	ldr	r3, [r3, #8]
34186f02:	2b01      	cmp	r3, #1
34186f04:	d017      	beq.n	34186f36 <HAL_GPIO_Init+0xf2>
      {
        /* Check the Pull parameter */
        assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

        /* Activate the Pull-up or Pull down resistor for the current IO */
        temp = GPIOx->PUPDR;
34186f06:	687b      	ldr	r3, [r7, #4]
34186f08:	68db      	ldr	r3, [r3, #12]
34186f0a:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * GPIO_PUPDR_PUPD1_Pos));
34186f0c:	697b      	ldr	r3, [r7, #20]
34186f0e:	005b      	lsls	r3, r3, #1
34186f10:	2203      	movs	r2, #3
34186f12:	fa02 f303 	lsl.w	r3, r2, r3
34186f16:	43db      	mvns	r3, r3
34186f18:	693a      	ldr	r2, [r7, #16]
34186f1a:	4013      	ands	r3, r2
34186f1c:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Pull) << (position * GPIO_PUPDR_PUPD1_Pos));
34186f1e:	683b      	ldr	r3, [r7, #0]
34186f20:	689a      	ldr	r2, [r3, #8]
34186f22:	697b      	ldr	r3, [r7, #20]
34186f24:	005b      	lsls	r3, r3, #1
34186f26:	fa02 f303 	lsl.w	r3, r2, r3
34186f2a:	693a      	ldr	r2, [r7, #16]
34186f2c:	4313      	orrs	r3, r2
34186f2e:	613b      	str	r3, [r7, #16]
        GPIOx->PUPDR = temp;
34186f30:	687b      	ldr	r3, [r7, #4]
34186f32:	693a      	ldr	r2, [r7, #16]
34186f34:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
34186f36:	683b      	ldr	r3, [r7, #0]
34186f38:	685b      	ldr	r3, [r3, #4]
34186f3a:	f003 0303 	and.w	r3, r3, #3
34186f3e:	2b02      	cmp	r3, #2
34186f40:	d123      	bne.n	34186f8a <HAL_GPIO_Init+0x146>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3u];
34186f42:	697b      	ldr	r3, [r7, #20]
34186f44:	08da      	lsrs	r2, r3, #3
34186f46:	687b      	ldr	r3, [r7, #4]
34186f48:	3208      	adds	r2, #8
34186f4a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
34186f4e:	613b      	str	r3, [r7, #16]
        temp &= ~(0xFu << ((position & 0x07u) * GPIO_AFRL_AFSEL1_Pos));
34186f50:	697b      	ldr	r3, [r7, #20]
34186f52:	f003 0307 	and.w	r3, r3, #7
34186f56:	009b      	lsls	r3, r3, #2
34186f58:	220f      	movs	r2, #15
34186f5a:	fa02 f303 	lsl.w	r3, r2, r3
34186f5e:	43db      	mvns	r3, r3
34186f60:	693a      	ldr	r2, [r7, #16]
34186f62:	4013      	ands	r3, r2
34186f64:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07u) * GPIO_AFRL_AFSEL1_Pos));
34186f66:	683b      	ldr	r3, [r7, #0]
34186f68:	691a      	ldr	r2, [r3, #16]
34186f6a:	697b      	ldr	r3, [r7, #20]
34186f6c:	f003 0307 	and.w	r3, r3, #7
34186f70:	009b      	lsls	r3, r3, #2
34186f72:	fa02 f303 	lsl.w	r3, r2, r3
34186f76:	693a      	ldr	r2, [r7, #16]
34186f78:	4313      	orrs	r3, r2
34186f7a:	613b      	str	r3, [r7, #16]
        GPIOx->AFR[position >> 3u] = temp;
34186f7c:	697b      	ldr	r3, [r7, #20]
34186f7e:	08da      	lsrs	r2, r3, #3
34186f80:	687b      	ldr	r3, [r7, #4]
34186f82:	3208      	adds	r2, #8
34186f84:	6939      	ldr	r1, [r7, #16]
34186f86:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
34186f8a:	687b      	ldr	r3, [r7, #4]
34186f8c:	681b      	ldr	r3, [r3, #0]
34186f8e:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_MODER_MODE0 << (position * GPIO_MODER_MODE1_Pos));
34186f90:	697b      	ldr	r3, [r7, #20]
34186f92:	005b      	lsls	r3, r3, #1
34186f94:	2203      	movs	r2, #3
34186f96:	fa02 f303 	lsl.w	r3, r2, r3
34186f9a:	43db      	mvns	r3, r3
34186f9c:	693a      	ldr	r2, [r7, #16]
34186f9e:	4013      	ands	r3, r2
34186fa0:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * GPIO_MODER_MODE1_Pos));
34186fa2:	683b      	ldr	r3, [r7, #0]
34186fa4:	685b      	ldr	r3, [r3, #4]
34186fa6:	f003 0203 	and.w	r2, r3, #3
34186faa:	697b      	ldr	r3, [r7, #20]
34186fac:	005b      	lsls	r3, r3, #1
34186fae:	fa02 f303 	lsl.w	r3, r2, r3
34186fb2:	693a      	ldr	r2, [r7, #16]
34186fb4:	4313      	orrs	r3, r2
34186fb6:	613b      	str	r3, [r7, #16]
      GPIOx->MODER = temp;
34186fb8:	687b      	ldr	r3, [r7, #4]
34186fba:	693a      	ldr	r2, [r7, #16]
34186fbc:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
34186fbe:	683b      	ldr	r3, [r7, #0]
34186fc0:	685b      	ldr	r3, [r3, #4]
34186fc2:	f403 3340 	and.w	r3, r3, #196608	@ 0x30000
34186fc6:	2b00      	cmp	r3, #0
34186fc8:	f000 80c2 	beq.w	34187150 <HAL_GPIO_Init+0x30c>
      {
        temp = EXTI->EXTICR[position >> 2u];
34186fcc:	4a69      	ldr	r2, [pc, #420]	@ (34187174 <HAL_GPIO_Init+0x330>)
34186fce:	697b      	ldr	r3, [r7, #20]
34186fd0:	089b      	lsrs	r3, r3, #2
34186fd2:	3318      	adds	r3, #24
34186fd4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
34186fd8:	613b      	str	r3, [r7, #16]
        temp &= ~(0x0FuL << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
34186fda:	697b      	ldr	r3, [r7, #20]
34186fdc:	f003 0303 	and.w	r3, r3, #3
34186fe0:	00db      	lsls	r3, r3, #3
34186fe2:	220f      	movs	r2, #15
34186fe4:	fa02 f303 	lsl.w	r3, r2, r3
34186fe8:	43db      	mvns	r3, r3
34186fea:	693a      	ldr	r2, [r7, #16]
34186fec:	4013      	ands	r3, r2
34186fee:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_GET_INDEX(GPIOx) << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
34186ff0:	687b      	ldr	r3, [r7, #4]
34186ff2:	4a61      	ldr	r2, [pc, #388]	@ (34187178 <HAL_GPIO_Init+0x334>)
34186ff4:	4293      	cmp	r3, r2
34186ff6:	d043      	beq.n	34187080 <HAL_GPIO_Init+0x23c>
34186ff8:	687b      	ldr	r3, [r7, #4]
34186ffa:	4a60      	ldr	r2, [pc, #384]	@ (3418717c <HAL_GPIO_Init+0x338>)
34186ffc:	4293      	cmp	r3, r2
34186ffe:	d03d      	beq.n	3418707c <HAL_GPIO_Init+0x238>
34187000:	687b      	ldr	r3, [r7, #4]
34187002:	4a5f      	ldr	r2, [pc, #380]	@ (34187180 <HAL_GPIO_Init+0x33c>)
34187004:	4293      	cmp	r3, r2
34187006:	d037      	beq.n	34187078 <HAL_GPIO_Init+0x234>
34187008:	687b      	ldr	r3, [r7, #4]
3418700a:	4a5e      	ldr	r2, [pc, #376]	@ (34187184 <HAL_GPIO_Init+0x340>)
3418700c:	4293      	cmp	r3, r2
3418700e:	d031      	beq.n	34187074 <HAL_GPIO_Init+0x230>
34187010:	687b      	ldr	r3, [r7, #4]
34187012:	4a5d      	ldr	r2, [pc, #372]	@ (34187188 <HAL_GPIO_Init+0x344>)
34187014:	4293      	cmp	r3, r2
34187016:	d02b      	beq.n	34187070 <HAL_GPIO_Init+0x22c>
34187018:	687b      	ldr	r3, [r7, #4]
3418701a:	4a5c      	ldr	r2, [pc, #368]	@ (3418718c <HAL_GPIO_Init+0x348>)
3418701c:	4293      	cmp	r3, r2
3418701e:	d025      	beq.n	3418706c <HAL_GPIO_Init+0x228>
34187020:	687b      	ldr	r3, [r7, #4]
34187022:	4a5b      	ldr	r2, [pc, #364]	@ (34187190 <HAL_GPIO_Init+0x34c>)
34187024:	4293      	cmp	r3, r2
34187026:	d01f      	beq.n	34187068 <HAL_GPIO_Init+0x224>
34187028:	687b      	ldr	r3, [r7, #4]
3418702a:	4a5a      	ldr	r2, [pc, #360]	@ (34187194 <HAL_GPIO_Init+0x350>)
3418702c:	4293      	cmp	r3, r2
3418702e:	d019      	beq.n	34187064 <HAL_GPIO_Init+0x220>
34187030:	687b      	ldr	r3, [r7, #4]
34187032:	4a59      	ldr	r2, [pc, #356]	@ (34187198 <HAL_GPIO_Init+0x354>)
34187034:	4293      	cmp	r3, r2
34187036:	d013      	beq.n	34187060 <HAL_GPIO_Init+0x21c>
34187038:	687b      	ldr	r3, [r7, #4]
3418703a:	4a58      	ldr	r2, [pc, #352]	@ (3418719c <HAL_GPIO_Init+0x358>)
3418703c:	4293      	cmp	r3, r2
3418703e:	d00d      	beq.n	3418705c <HAL_GPIO_Init+0x218>
34187040:	687b      	ldr	r3, [r7, #4]
34187042:	4a57      	ldr	r2, [pc, #348]	@ (341871a0 <HAL_GPIO_Init+0x35c>)
34187044:	4293      	cmp	r3, r2
34187046:	d007      	beq.n	34187058 <HAL_GPIO_Init+0x214>
34187048:	687b      	ldr	r3, [r7, #4]
3418704a:	4a56      	ldr	r2, [pc, #344]	@ (341871a4 <HAL_GPIO_Init+0x360>)
3418704c:	4293      	cmp	r3, r2
3418704e:	d101      	bne.n	34187054 <HAL_GPIO_Init+0x210>
34187050:	230b      	movs	r3, #11
34187052:	e016      	b.n	34187082 <HAL_GPIO_Init+0x23e>
34187054:	2310      	movs	r3, #16
34187056:	e014      	b.n	34187082 <HAL_GPIO_Init+0x23e>
34187058:	230a      	movs	r3, #10
3418705a:	e012      	b.n	34187082 <HAL_GPIO_Init+0x23e>
3418705c:	2309      	movs	r3, #9
3418705e:	e010      	b.n	34187082 <HAL_GPIO_Init+0x23e>
34187060:	2308      	movs	r3, #8
34187062:	e00e      	b.n	34187082 <HAL_GPIO_Init+0x23e>
34187064:	2307      	movs	r3, #7
34187066:	e00c      	b.n	34187082 <HAL_GPIO_Init+0x23e>
34187068:	2306      	movs	r3, #6
3418706a:	e00a      	b.n	34187082 <HAL_GPIO_Init+0x23e>
3418706c:	2305      	movs	r3, #5
3418706e:	e008      	b.n	34187082 <HAL_GPIO_Init+0x23e>
34187070:	2304      	movs	r3, #4
34187072:	e006      	b.n	34187082 <HAL_GPIO_Init+0x23e>
34187074:	2303      	movs	r3, #3
34187076:	e004      	b.n	34187082 <HAL_GPIO_Init+0x23e>
34187078:	2302      	movs	r3, #2
3418707a:	e002      	b.n	34187082 <HAL_GPIO_Init+0x23e>
3418707c:	2301      	movs	r3, #1
3418707e:	e000      	b.n	34187082 <HAL_GPIO_Init+0x23e>
34187080:	2300      	movs	r3, #0
34187082:	697a      	ldr	r2, [r7, #20]
34187084:	f002 0203 	and.w	r2, r2, #3
34187088:	00d2      	lsls	r2, r2, #3
3418708a:	4093      	lsls	r3, r2
3418708c:	693a      	ldr	r2, [r7, #16]
3418708e:	4313      	orrs	r3, r2
34187090:	613b      	str	r3, [r7, #16]
        EXTI->EXTICR[position >> 2u] = temp;
34187092:	4938      	ldr	r1, [pc, #224]	@ (34187174 <HAL_GPIO_Init+0x330>)
34187094:	697b      	ldr	r3, [r7, #20]
34187096:	089b      	lsrs	r3, r3, #2
34187098:	3318      	adds	r3, #24
3418709a:	693a      	ldr	r2, [r7, #16]
3418709c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
341870a0:	4b34      	ldr	r3, [pc, #208]	@ (34187174 <HAL_GPIO_Init+0x330>)
341870a2:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
341870a6:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
341870a8:	68fb      	ldr	r3, [r7, #12]
341870aa:	43db      	mvns	r3, r3
341870ac:	693a      	ldr	r2, [r7, #16]
341870ae:	4013      	ands	r3, r2
341870b0:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00u)
341870b2:	683b      	ldr	r3, [r7, #0]
341870b4:	685b      	ldr	r3, [r3, #4]
341870b6:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
341870ba:	2b00      	cmp	r3, #0
341870bc:	d003      	beq.n	341870c6 <HAL_GPIO_Init+0x282>
        {
          temp |= iocurrent;
341870be:	693a      	ldr	r2, [r7, #16]
341870c0:	68fb      	ldr	r3, [r7, #12]
341870c2:	4313      	orrs	r3, r2
341870c4:	613b      	str	r3, [r7, #16]
        }
        EXTI->IMR1 = temp;
341870c6:	4a2b      	ldr	r2, [pc, #172]	@ (34187174 <HAL_GPIO_Init+0x330>)
341870c8:	693b      	ldr	r3, [r7, #16]
341870ca:	f8c2 3080 	str.w	r3, [r2, #128]	@ 0x80

        temp = EXTI->EMR1;
341870ce:	4b29      	ldr	r3, [pc, #164]	@ (34187174 <HAL_GPIO_Init+0x330>)
341870d0:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
341870d4:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
341870d6:	68fb      	ldr	r3, [r7, #12]
341870d8:	43db      	mvns	r3, r3
341870da:	693a      	ldr	r2, [r7, #16]
341870dc:	4013      	ands	r3, r2
341870de:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00u)
341870e0:	683b      	ldr	r3, [r7, #0]
341870e2:	685b      	ldr	r3, [r3, #4]
341870e4:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
341870e8:	2b00      	cmp	r3, #0
341870ea:	d003      	beq.n	341870f4 <HAL_GPIO_Init+0x2b0>
        {
          temp |= iocurrent;
341870ec:	693a      	ldr	r2, [r7, #16]
341870ee:	68fb      	ldr	r3, [r7, #12]
341870f0:	4313      	orrs	r3, r2
341870f2:	613b      	str	r3, [r7, #16]
        }
        EXTI->EMR1 = temp;
341870f4:	4a1f      	ldr	r2, [pc, #124]	@ (34187174 <HAL_GPIO_Init+0x330>)
341870f6:	693b      	ldr	r3, [r7, #16]
341870f8:	f8c2 3084 	str.w	r3, [r2, #132]	@ 0x84

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
341870fc:	4b1d      	ldr	r3, [pc, #116]	@ (34187174 <HAL_GPIO_Init+0x330>)
341870fe:	681b      	ldr	r3, [r3, #0]
34187100:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
34187102:	68fb      	ldr	r3, [r7, #12]
34187104:	43db      	mvns	r3, r3
34187106:	693a      	ldr	r2, [r7, #16]
34187108:	4013      	ands	r3, r2
3418710a:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00u)
3418710c:	683b      	ldr	r3, [r7, #0]
3418710e:	685b      	ldr	r3, [r3, #4]
34187110:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
34187114:	2b00      	cmp	r3, #0
34187116:	d003      	beq.n	34187120 <HAL_GPIO_Init+0x2dc>
        {
          temp |= iocurrent;
34187118:	693a      	ldr	r2, [r7, #16]
3418711a:	68fb      	ldr	r3, [r7, #12]
3418711c:	4313      	orrs	r3, r2
3418711e:	613b      	str	r3, [r7, #16]
        }
        EXTI->RTSR1 = temp;
34187120:	4a14      	ldr	r2, [pc, #80]	@ (34187174 <HAL_GPIO_Init+0x330>)
34187122:	693b      	ldr	r3, [r7, #16]
34187124:	6013      	str	r3, [r2, #0]

        temp = EXTI->FTSR1;
34187126:	4b13      	ldr	r3, [pc, #76]	@ (34187174 <HAL_GPIO_Init+0x330>)
34187128:	685b      	ldr	r3, [r3, #4]
3418712a:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
3418712c:	68fb      	ldr	r3, [r7, #12]
3418712e:	43db      	mvns	r3, r3
34187130:	693a      	ldr	r2, [r7, #16]
34187132:	4013      	ands	r3, r2
34187134:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00u)
34187136:	683b      	ldr	r3, [r7, #0]
34187138:	685b      	ldr	r3, [r3, #4]
3418713a:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
3418713e:	2b00      	cmp	r3, #0
34187140:	d003      	beq.n	3418714a <HAL_GPIO_Init+0x306>
        {
          temp |= iocurrent;
34187142:	693a      	ldr	r2, [r7, #16]
34187144:	68fb      	ldr	r3, [r7, #12]
34187146:	4313      	orrs	r3, r2
34187148:	613b      	str	r3, [r7, #16]
        }
        EXTI->FTSR1 = temp;
3418714a:	4a0a      	ldr	r2, [pc, #40]	@ (34187174 <HAL_GPIO_Init+0x330>)
3418714c:	693b      	ldr	r3, [r7, #16]
3418714e:	6053      	str	r3, [r2, #4]
      }
    }

    position++;
34187150:	697b      	ldr	r3, [r7, #20]
34187152:	3301      	adds	r3, #1
34187154:	617b      	str	r3, [r7, #20]
  while (((GPIO_Init->Pin) >> position) != 0x00u)
34187156:	683b      	ldr	r3, [r7, #0]
34187158:	681a      	ldr	r2, [r3, #0]
3418715a:	697b      	ldr	r3, [r7, #20]
3418715c:	fa22 f303 	lsr.w	r3, r2, r3
34187160:	2b00      	cmp	r3, #0
34187162:	f47f ae77 	bne.w	34186e54 <HAL_GPIO_Init+0x10>
  }
}
34187166:	bf00      	nop
34187168:	bf00      	nop
3418716a:	371c      	adds	r7, #28
3418716c:	46bd      	mov	sp, r7
3418716e:	f85d 7b04 	ldr.w	r7, [sp], #4
34187172:	4770      	bx	lr
34187174:	56025000 	.word	0x56025000
34187178:	56020000 	.word	0x56020000
3418717c:	56020400 	.word	0x56020400
34187180:	56020800 	.word	0x56020800
34187184:	56020c00 	.word	0x56020c00
34187188:	56021000 	.word	0x56021000
3418718c:	56021400 	.word	0x56021400
34187190:	56021800 	.word	0x56021800
34187194:	56021c00 	.word	0x56021c00
34187198:	56023400 	.word	0x56023400
3418719c:	56023800 	.word	0x56023800
341871a0:	56023c00 	.word	0x56023c00
341871a4:	56024000 	.word	0x56024000

341871a8 <HAL_GPIO_DeInit>:
  * @param  GPIO_Pin specifies the port bit to be written.
  *         This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{
341871a8:	b480      	push	{r7}
341871aa:	b087      	sub	sp, #28
341871ac:	af00      	add	r7, sp, #0
341871ae:	6078      	str	r0, [r7, #4]
341871b0:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00u;
341871b2:	2300      	movs	r3, #0
341871b4:	617b      	str	r3, [r7, #20]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Configure the port pins */
  while ((GPIO_Pin >> position) != 0x00u)
341871b6:	e10f      	b.n	341873d8 <HAL_GPIO_DeInit+0x230>
  {
    /* Get current io position */
    iocurrent = (GPIO_Pin) & (1uL << position);
341871b8:	2201      	movs	r2, #1
341871ba:	697b      	ldr	r3, [r7, #20]
341871bc:	fa02 f303 	lsl.w	r3, r2, r3
341871c0:	683a      	ldr	r2, [r7, #0]
341871c2:	4013      	ands	r3, r2
341871c4:	613b      	str	r3, [r7, #16]

    if (iocurrent != 0x00u)
341871c6:	693b      	ldr	r3, [r7, #16]
341871c8:	2b00      	cmp	r3, #0
341871ca:	f000 8102 	beq.w	341873d2 <HAL_GPIO_DeInit+0x22a>
    {
      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */

      tmp = EXTI->EXTICR[position >> 2u];
341871ce:	4a89      	ldr	r2, [pc, #548]	@ (341873f4 <HAL_GPIO_DeInit+0x24c>)
341871d0:	697b      	ldr	r3, [r7, #20]
341871d2:	089b      	lsrs	r3, r3, #2
341871d4:	3318      	adds	r3, #24
341871d6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
341871da:	60fb      	str	r3, [r7, #12]
      tmp &= (0x0FuL << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
341871dc:	697b      	ldr	r3, [r7, #20]
341871de:	f003 0303 	and.w	r3, r3, #3
341871e2:	00db      	lsls	r3, r3, #3
341871e4:	220f      	movs	r2, #15
341871e6:	fa02 f303 	lsl.w	r3, r2, r3
341871ea:	68fa      	ldr	r2, [r7, #12]
341871ec:	4013      	ands	r3, r2
341871ee:	60fb      	str	r3, [r7, #12]
      if (tmp == (GPIO_GET_INDEX(GPIOx) << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos)))
341871f0:	687b      	ldr	r3, [r7, #4]
341871f2:	4a81      	ldr	r2, [pc, #516]	@ (341873f8 <HAL_GPIO_DeInit+0x250>)
341871f4:	4293      	cmp	r3, r2
341871f6:	d043      	beq.n	34187280 <HAL_GPIO_DeInit+0xd8>
341871f8:	687b      	ldr	r3, [r7, #4]
341871fa:	4a80      	ldr	r2, [pc, #512]	@ (341873fc <HAL_GPIO_DeInit+0x254>)
341871fc:	4293      	cmp	r3, r2
341871fe:	d03d      	beq.n	3418727c <HAL_GPIO_DeInit+0xd4>
34187200:	687b      	ldr	r3, [r7, #4]
34187202:	4a7f      	ldr	r2, [pc, #508]	@ (34187400 <HAL_GPIO_DeInit+0x258>)
34187204:	4293      	cmp	r3, r2
34187206:	d037      	beq.n	34187278 <HAL_GPIO_DeInit+0xd0>
34187208:	687b      	ldr	r3, [r7, #4]
3418720a:	4a7e      	ldr	r2, [pc, #504]	@ (34187404 <HAL_GPIO_DeInit+0x25c>)
3418720c:	4293      	cmp	r3, r2
3418720e:	d031      	beq.n	34187274 <HAL_GPIO_DeInit+0xcc>
34187210:	687b      	ldr	r3, [r7, #4]
34187212:	4a7d      	ldr	r2, [pc, #500]	@ (34187408 <HAL_GPIO_DeInit+0x260>)
34187214:	4293      	cmp	r3, r2
34187216:	d02b      	beq.n	34187270 <HAL_GPIO_DeInit+0xc8>
34187218:	687b      	ldr	r3, [r7, #4]
3418721a:	4a7c      	ldr	r2, [pc, #496]	@ (3418740c <HAL_GPIO_DeInit+0x264>)
3418721c:	4293      	cmp	r3, r2
3418721e:	d025      	beq.n	3418726c <HAL_GPIO_DeInit+0xc4>
34187220:	687b      	ldr	r3, [r7, #4]
34187222:	4a7b      	ldr	r2, [pc, #492]	@ (34187410 <HAL_GPIO_DeInit+0x268>)
34187224:	4293      	cmp	r3, r2
34187226:	d01f      	beq.n	34187268 <HAL_GPIO_DeInit+0xc0>
34187228:	687b      	ldr	r3, [r7, #4]
3418722a:	4a7a      	ldr	r2, [pc, #488]	@ (34187414 <HAL_GPIO_DeInit+0x26c>)
3418722c:	4293      	cmp	r3, r2
3418722e:	d019      	beq.n	34187264 <HAL_GPIO_DeInit+0xbc>
34187230:	687b      	ldr	r3, [r7, #4]
34187232:	4a79      	ldr	r2, [pc, #484]	@ (34187418 <HAL_GPIO_DeInit+0x270>)
34187234:	4293      	cmp	r3, r2
34187236:	d013      	beq.n	34187260 <HAL_GPIO_DeInit+0xb8>
34187238:	687b      	ldr	r3, [r7, #4]
3418723a:	4a78      	ldr	r2, [pc, #480]	@ (3418741c <HAL_GPIO_DeInit+0x274>)
3418723c:	4293      	cmp	r3, r2
3418723e:	d00d      	beq.n	3418725c <HAL_GPIO_DeInit+0xb4>
34187240:	687b      	ldr	r3, [r7, #4]
34187242:	4a77      	ldr	r2, [pc, #476]	@ (34187420 <HAL_GPIO_DeInit+0x278>)
34187244:	4293      	cmp	r3, r2
34187246:	d007      	beq.n	34187258 <HAL_GPIO_DeInit+0xb0>
34187248:	687b      	ldr	r3, [r7, #4]
3418724a:	4a76      	ldr	r2, [pc, #472]	@ (34187424 <HAL_GPIO_DeInit+0x27c>)
3418724c:	4293      	cmp	r3, r2
3418724e:	d101      	bne.n	34187254 <HAL_GPIO_DeInit+0xac>
34187250:	230b      	movs	r3, #11
34187252:	e016      	b.n	34187282 <HAL_GPIO_DeInit+0xda>
34187254:	2310      	movs	r3, #16
34187256:	e014      	b.n	34187282 <HAL_GPIO_DeInit+0xda>
34187258:	230a      	movs	r3, #10
3418725a:	e012      	b.n	34187282 <HAL_GPIO_DeInit+0xda>
3418725c:	2309      	movs	r3, #9
3418725e:	e010      	b.n	34187282 <HAL_GPIO_DeInit+0xda>
34187260:	2308      	movs	r3, #8
34187262:	e00e      	b.n	34187282 <HAL_GPIO_DeInit+0xda>
34187264:	2307      	movs	r3, #7
34187266:	e00c      	b.n	34187282 <HAL_GPIO_DeInit+0xda>
34187268:	2306      	movs	r3, #6
3418726a:	e00a      	b.n	34187282 <HAL_GPIO_DeInit+0xda>
3418726c:	2305      	movs	r3, #5
3418726e:	e008      	b.n	34187282 <HAL_GPIO_DeInit+0xda>
34187270:	2304      	movs	r3, #4
34187272:	e006      	b.n	34187282 <HAL_GPIO_DeInit+0xda>
34187274:	2303      	movs	r3, #3
34187276:	e004      	b.n	34187282 <HAL_GPIO_DeInit+0xda>
34187278:	2302      	movs	r3, #2
3418727a:	e002      	b.n	34187282 <HAL_GPIO_DeInit+0xda>
3418727c:	2301      	movs	r3, #1
3418727e:	e000      	b.n	34187282 <HAL_GPIO_DeInit+0xda>
34187280:	2300      	movs	r3, #0
34187282:	697a      	ldr	r2, [r7, #20]
34187284:	f002 0203 	and.w	r2, r2, #3
34187288:	00d2      	lsls	r2, r2, #3
3418728a:	4093      	lsls	r3, r2
3418728c:	68fa      	ldr	r2, [r7, #12]
3418728e:	429a      	cmp	r2, r3
34187290:	d136      	bne.n	34187300 <HAL_GPIO_DeInit+0x158>
      {
        /* Clear EXTI line configuration */
        EXTI->IMR1 &= ~(iocurrent);
34187292:	4b58      	ldr	r3, [pc, #352]	@ (341873f4 <HAL_GPIO_DeInit+0x24c>)
34187294:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
34187298:	693b      	ldr	r3, [r7, #16]
3418729a:	43db      	mvns	r3, r3
3418729c:	4955      	ldr	r1, [pc, #340]	@ (341873f4 <HAL_GPIO_DeInit+0x24c>)
3418729e:	4013      	ands	r3, r2
341872a0:	f8c1 3080 	str.w	r3, [r1, #128]	@ 0x80
        EXTI->EMR1 &= ~(iocurrent);
341872a4:	4b53      	ldr	r3, [pc, #332]	@ (341873f4 <HAL_GPIO_DeInit+0x24c>)
341872a6:	f8d3 2084 	ldr.w	r2, [r3, #132]	@ 0x84
341872aa:	693b      	ldr	r3, [r7, #16]
341872ac:	43db      	mvns	r3, r3
341872ae:	4951      	ldr	r1, [pc, #324]	@ (341873f4 <HAL_GPIO_DeInit+0x24c>)
341872b0:	4013      	ands	r3, r2
341872b2:	f8c1 3084 	str.w	r3, [r1, #132]	@ 0x84

        /* Clear Rising Falling edge configuration */
        EXTI->RTSR1 &= ~(iocurrent);
341872b6:	4b4f      	ldr	r3, [pc, #316]	@ (341873f4 <HAL_GPIO_DeInit+0x24c>)
341872b8:	681a      	ldr	r2, [r3, #0]
341872ba:	693b      	ldr	r3, [r7, #16]
341872bc:	43db      	mvns	r3, r3
341872be:	494d      	ldr	r1, [pc, #308]	@ (341873f4 <HAL_GPIO_DeInit+0x24c>)
341872c0:	4013      	ands	r3, r2
341872c2:	600b      	str	r3, [r1, #0]
        EXTI->FTSR1 &= ~(iocurrent);
341872c4:	4b4b      	ldr	r3, [pc, #300]	@ (341873f4 <HAL_GPIO_DeInit+0x24c>)
341872c6:	685a      	ldr	r2, [r3, #4]
341872c8:	693b      	ldr	r3, [r7, #16]
341872ca:	43db      	mvns	r3, r3
341872cc:	4949      	ldr	r1, [pc, #292]	@ (341873f4 <HAL_GPIO_DeInit+0x24c>)
341872ce:	4013      	ands	r3, r2
341872d0:	604b      	str	r3, [r1, #4]

        tmp = 0x0FuL << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos);
341872d2:	697b      	ldr	r3, [r7, #20]
341872d4:	f003 0303 	and.w	r3, r3, #3
341872d8:	00db      	lsls	r3, r3, #3
341872da:	220f      	movs	r2, #15
341872dc:	fa02 f303 	lsl.w	r3, r2, r3
341872e0:	60fb      	str	r3, [r7, #12]
        EXTI->EXTICR[position >> 2u] &= ~tmp;
341872e2:	4a44      	ldr	r2, [pc, #272]	@ (341873f4 <HAL_GPIO_DeInit+0x24c>)
341872e4:	697b      	ldr	r3, [r7, #20]
341872e6:	089b      	lsrs	r3, r3, #2
341872e8:	3318      	adds	r3, #24
341872ea:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
341872ee:	68fb      	ldr	r3, [r7, #12]
341872f0:	43da      	mvns	r2, r3
341872f2:	4840      	ldr	r0, [pc, #256]	@ (341873f4 <HAL_GPIO_DeInit+0x24c>)
341872f4:	697b      	ldr	r3, [r7, #20]
341872f6:	089b      	lsrs	r3, r3, #2
341872f8:	400a      	ands	r2, r1
341872fa:	3318      	adds	r3, #24
341872fc:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
      }

      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO in Analog Mode */
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * GPIO_MODER_MODE1_Pos));
34187300:	687b      	ldr	r3, [r7, #4]
34187302:	681a      	ldr	r2, [r3, #0]
34187304:	697b      	ldr	r3, [r7, #20]
34187306:	005b      	lsls	r3, r3, #1
34187308:	2103      	movs	r1, #3
3418730a:	fa01 f303 	lsl.w	r3, r1, r3
3418730e:	431a      	orrs	r2, r3
34187310:	687b      	ldr	r3, [r7, #4]
34187312:	601a      	str	r2, [r3, #0]

      /* Configure the default Alternate Function in current IO */
      GPIOx->AFR[position >> 3u] &= ~(0xFu << ((position & 0x07u) * GPIO_AFRL_AFSEL1_Pos)) ;
34187314:	697b      	ldr	r3, [r7, #20]
34187316:	08da      	lsrs	r2, r3, #3
34187318:	687b      	ldr	r3, [r7, #4]
3418731a:	3208      	adds	r2, #8
3418731c:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
34187320:	697b      	ldr	r3, [r7, #20]
34187322:	f003 0307 	and.w	r3, r3, #7
34187326:	009b      	lsls	r3, r3, #2
34187328:	220f      	movs	r2, #15
3418732a:	fa02 f303 	lsl.w	r3, r2, r3
3418732e:	43db      	mvns	r3, r3
34187330:	697a      	ldr	r2, [r7, #20]
34187332:	08d2      	lsrs	r2, r2, #3
34187334:	4019      	ands	r1, r3
34187336:	687b      	ldr	r3, [r7, #4]
34187338:	3208      	adds	r2, #8
3418733a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

      /* Configure the default value for IO Speed */
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * GPIO_OSPEEDR_OSPEED1_Pos));
3418733e:	687b      	ldr	r3, [r7, #4]
34187340:	689a      	ldr	r2, [r3, #8]
34187342:	697b      	ldr	r3, [r7, #20]
34187344:	005b      	lsls	r3, r3, #1
34187346:	2103      	movs	r1, #3
34187348:	fa01 f303 	lsl.w	r3, r1, r3
3418734c:	43db      	mvns	r3, r3
3418734e:	401a      	ands	r2, r3
34187350:	687b      	ldr	r3, [r7, #4]
34187352:	609a      	str	r2, [r3, #8]

      /* Configure the default value IO Output Type */
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT0 << position) ;
34187354:	687b      	ldr	r3, [r7, #4]
34187356:	685a      	ldr	r2, [r3, #4]
34187358:	2101      	movs	r1, #1
3418735a:	697b      	ldr	r3, [r7, #20]
3418735c:	fa01 f303 	lsl.w	r3, r1, r3
34187360:	43db      	mvns	r3, r3
34187362:	401a      	ands	r2, r3
34187364:	687b      	ldr	r3, [r7, #4]
34187366:	605a      	str	r2, [r3, #4]

      /* Deactivate the Pull-up and Pull-down resistor for the current IO */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * GPIO_PUPDR_PUPD1_Pos));
34187368:	687b      	ldr	r3, [r7, #4]
3418736a:	68da      	ldr	r2, [r3, #12]
3418736c:	697b      	ldr	r3, [r7, #20]
3418736e:	005b      	lsls	r3, r3, #1
34187370:	2103      	movs	r1, #3
34187372:	fa01 f303 	lsl.w	r3, r1, r3
34187376:	43db      	mvns	r3, r3
34187378:	401a      	ands	r2, r3
3418737a:	687b      	ldr	r3, [r7, #4]
3418737c:	60da      	str	r2, [r3, #12]

      /* Reset delay settings for the current IO */
      GPIOx->DELAYR[position >> 3u] &= ~(0xFu << ((position & 0x07u) * GPIO_DELAYRL_DLY1_Pos)) ;
3418737e:	697b      	ldr	r3, [r7, #20]
34187380:	08da      	lsrs	r2, r3, #3
34187382:	687b      	ldr	r3, [r7, #4]
34187384:	3210      	adds	r2, #16
34187386:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
3418738a:	697b      	ldr	r3, [r7, #20]
3418738c:	f003 0307 	and.w	r3, r3, #7
34187390:	009b      	lsls	r3, r3, #2
34187392:	220f      	movs	r2, #15
34187394:	fa02 f303 	lsl.w	r3, r2, r3
34187398:	43db      	mvns	r3, r3
3418739a:	697a      	ldr	r2, [r7, #20]
3418739c:	08d2      	lsrs	r2, r2, #3
3418739e:	4019      	ands	r1, r3
341873a0:	687b      	ldr	r3, [r7, #4]
341873a2:	3210      	adds	r2, #16
341873a4:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

      /* Reset control settings for the current IO */
      GPIOx->ADVCFGR[position >> 3u] &= ~(0xFu << ((position & 0x07u) * GPIO_ADVCFGRL_1_Pos)) ;
341873a8:	697b      	ldr	r3, [r7, #20]
341873aa:	08da      	lsrs	r2, r3, #3
341873ac:	687b      	ldr	r3, [r7, #4]
341873ae:	3212      	adds	r2, #18
341873b0:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
341873b4:	697b      	ldr	r3, [r7, #20]
341873b6:	f003 0307 	and.w	r3, r3, #7
341873ba:	009b      	lsls	r3, r3, #2
341873bc:	220f      	movs	r2, #15
341873be:	fa02 f303 	lsl.w	r3, r2, r3
341873c2:	43db      	mvns	r3, r3
341873c4:	697a      	ldr	r2, [r7, #20]
341873c6:	08d2      	lsrs	r2, r2, #3
341873c8:	4019      	ands	r1, r3
341873ca:	687b      	ldr	r3, [r7, #4]
341873cc:	3212      	adds	r2, #18
341873ce:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    }

    position++;
341873d2:	697b      	ldr	r3, [r7, #20]
341873d4:	3301      	adds	r3, #1
341873d6:	617b      	str	r3, [r7, #20]
  while ((GPIO_Pin >> position) != 0x00u)
341873d8:	683a      	ldr	r2, [r7, #0]
341873da:	697b      	ldr	r3, [r7, #20]
341873dc:	fa22 f303 	lsr.w	r3, r2, r3
341873e0:	2b00      	cmp	r3, #0
341873e2:	f47f aee9 	bne.w	341871b8 <HAL_GPIO_DeInit+0x10>
  }
}
341873e6:	bf00      	nop
341873e8:	bf00      	nop
341873ea:	371c      	adds	r7, #28
341873ec:	46bd      	mov	sp, r7
341873ee:	f85d 7b04 	ldr.w	r7, [sp], #4
341873f2:	4770      	bx	lr
341873f4:	56025000 	.word	0x56025000
341873f8:	56020000 	.word	0x56020000
341873fc:	56020400 	.word	0x56020400
34187400:	56020800 	.word	0x56020800
34187404:	56020c00 	.word	0x56020c00
34187408:	56021000 	.word	0x56021000
3418740c:	56021400 	.word	0x56021400
34187410:	56021800 	.word	0x56021800
34187414:	56021c00 	.word	0x56021c00
34187418:	56023400 	.word	0x56023400
3418741c:	56023800 	.word	0x56023800
34187420:	56023c00 	.word	0x56023c00
34187424:	56024000 	.word	0x56024000

34187428 <HAL_GPIO_ReadPin>:
  * @param  GPIO_Pin specifies the port bit to read.
  *         This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval The input port pin value.
  */
GPIO_PinState HAL_GPIO_ReadPin(const GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
34187428:	b480      	push	{r7}
3418742a:	b085      	sub	sp, #20
3418742c:	af00      	add	r7, sp, #0
3418742e:	6078      	str	r0, [r7, #4]
34187430:	460b      	mov	r3, r1
34187432:	807b      	strh	r3, [r7, #2]
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != 0x00u)
34187434:	687b      	ldr	r3, [r7, #4]
34187436:	691a      	ldr	r2, [r3, #16]
34187438:	887b      	ldrh	r3, [r7, #2]
3418743a:	4013      	ands	r3, r2
3418743c:	2b00      	cmp	r3, #0
3418743e:	d002      	beq.n	34187446 <HAL_GPIO_ReadPin+0x1e>
  {
    bitstatus = GPIO_PIN_SET;
34187440:	2301      	movs	r3, #1
34187442:	73fb      	strb	r3, [r7, #15]
34187444:	e001      	b.n	3418744a <HAL_GPIO_ReadPin+0x22>
  }
  else
  {
    bitstatus = GPIO_PIN_RESET;
34187446:	2300      	movs	r3, #0
34187448:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
3418744a:	7bfb      	ldrb	r3, [r7, #15]
}
3418744c:	4618      	mov	r0, r3
3418744e:	3714      	adds	r7, #20
34187450:	46bd      	mov	sp, r7
34187452:	f85d 7b04 	ldr.w	r7, [sp], #4
34187456:	4770      	bx	lr

34187458 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
34187458:	b480      	push	{r7}
3418745a:	b083      	sub	sp, #12
3418745c:	af00      	add	r7, sp, #0
3418745e:	6078      	str	r0, [r7, #4]
34187460:	460b      	mov	r3, r1
34187462:	807b      	strh	r3, [r7, #2]
34187464:	4613      	mov	r3, r2
34187466:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
34187468:	787b      	ldrb	r3, [r7, #1]
3418746a:	2b00      	cmp	r3, #0
3418746c:	d003      	beq.n	34187476 <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
3418746e:	887a      	ldrh	r2, [r7, #2]
34187470:	687b      	ldr	r3, [r7, #4]
34187472:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
  }
}
34187474:	e002      	b.n	3418747c <HAL_GPIO_WritePin+0x24>
    GPIOx->BRR = (uint32_t)GPIO_Pin;
34187476:	887a      	ldrh	r2, [r7, #2]
34187478:	687b      	ldr	r3, [r7, #4]
3418747a:	629a      	str	r2, [r3, #40]	@ 0x28
}
3418747c:	bf00      	nop
3418747e:	370c      	adds	r7, #12
34187480:	46bd      	mov	sp, r7
34187482:	f85d 7b04 	ldr.w	r7, [sp], #4
34187486:	4770      	bx	lr

34187488 <HAL_GPIO_EXTI_IRQHandler>:
  * @brief  Handle EXTI interrupt request.
  * @param  GPIO_Pin Specifies the port pin connected to corresponding EXTI line.
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
34187488:	b580      	push	{r7, lr}
3418748a:	b082      	sub	sp, #8
3418748c:	af00      	add	r7, sp, #0
3418748e:	4603      	mov	r3, r0
34187490:	80fb      	strh	r3, [r7, #6]
  /* EXTI line interrupt detected */
  if (__HAL_GPIO_EXTI_GET_RISING_IT(GPIO_Pin) != 0x00u)
34187492:	4b0f      	ldr	r3, [pc, #60]	@ (341874d0 <HAL_GPIO_EXTI_IRQHandler+0x48>)
34187494:	68da      	ldr	r2, [r3, #12]
34187496:	88fb      	ldrh	r3, [r7, #6]
34187498:	4013      	ands	r3, r2
3418749a:	2b00      	cmp	r3, #0
3418749c:	d006      	beq.n	341874ac <HAL_GPIO_EXTI_IRQHandler+0x24>
  {
    __HAL_GPIO_EXTI_CLEAR_RISING_IT(GPIO_Pin);
3418749e:	4a0c      	ldr	r2, [pc, #48]	@ (341874d0 <HAL_GPIO_EXTI_IRQHandler+0x48>)
341874a0:	88fb      	ldrh	r3, [r7, #6]
341874a2:	60d3      	str	r3, [r2, #12]
    HAL_GPIO_EXTI_Rising_Callback(GPIO_Pin);
341874a4:	88fb      	ldrh	r3, [r7, #6]
341874a6:	4618      	mov	r0, r3
341874a8:	f000 f814 	bl	341874d4 <HAL_GPIO_EXTI_Rising_Callback>
  }

  if (__HAL_GPIO_EXTI_GET_FALLING_IT(GPIO_Pin) != 0x00u)
341874ac:	4b08      	ldr	r3, [pc, #32]	@ (341874d0 <HAL_GPIO_EXTI_IRQHandler+0x48>)
341874ae:	691a      	ldr	r2, [r3, #16]
341874b0:	88fb      	ldrh	r3, [r7, #6]
341874b2:	4013      	ands	r3, r2
341874b4:	2b00      	cmp	r3, #0
341874b6:	d006      	beq.n	341874c6 <HAL_GPIO_EXTI_IRQHandler+0x3e>
  {
    __HAL_GPIO_EXTI_CLEAR_FALLING_IT(GPIO_Pin);
341874b8:	4a05      	ldr	r2, [pc, #20]	@ (341874d0 <HAL_GPIO_EXTI_IRQHandler+0x48>)
341874ba:	88fb      	ldrh	r3, [r7, #6]
341874bc:	6113      	str	r3, [r2, #16]
    HAL_GPIO_EXTI_Falling_Callback(GPIO_Pin);
341874be:	88fb      	ldrh	r3, [r7, #6]
341874c0:	4618      	mov	r0, r3
341874c2:	f000 f812 	bl	341874ea <HAL_GPIO_EXTI_Falling_Callback>
  }
}
341874c6:	bf00      	nop
341874c8:	3708      	adds	r7, #8
341874ca:	46bd      	mov	sp, r7
341874cc:	bd80      	pop	{r7, pc}
341874ce:	bf00      	nop
341874d0:	56025000 	.word	0x56025000

341874d4 <HAL_GPIO_EXTI_Rising_Callback>:
  * @brief  EXTI line rising detection callback.
  * @param  GPIO_Pin Specifies the port pin connected to corresponding EXTI line.
  * @retval None
  */
__weak void HAL_GPIO_EXTI_Rising_Callback(uint16_t GPIO_Pin)
{
341874d4:	b480      	push	{r7}
341874d6:	b083      	sub	sp, #12
341874d8:	af00      	add	r7, sp, #0
341874da:	4603      	mov	r3, r0
341874dc:	80fb      	strh	r3, [r7, #6]
  UNUSED(GPIO_Pin);

  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_GPIO_EXTI_Rising_Callback could be implemented in the user file
   */
}
341874de:	bf00      	nop
341874e0:	370c      	adds	r7, #12
341874e2:	46bd      	mov	sp, r7
341874e4:	f85d 7b04 	ldr.w	r7, [sp], #4
341874e8:	4770      	bx	lr

341874ea <HAL_GPIO_EXTI_Falling_Callback>:
  * @brief  EXTI line falling detection callback.
  * @param  GPIO_Pin Specifies the port pin connected to corresponding EXTI line.
  * @retval None
  */
__weak void HAL_GPIO_EXTI_Falling_Callback(uint16_t GPIO_Pin)
{
341874ea:	b480      	push	{r7}
341874ec:	b083      	sub	sp, #12
341874ee:	af00      	add	r7, sp, #0
341874f0:	4603      	mov	r3, r0
341874f2:	80fb      	strh	r3, [r7, #6]
  UNUSED(GPIO_Pin);

  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_GPIO_EXTI_Falling_Callback could be implemented in the user file
   */
}
341874f4:	bf00      	nop
341874f6:	370c      	adds	r7, #12
341874f8:	46bd      	mov	sp, r7
341874fa:	f85d 7b04 	ldr.w	r7, [sp], #4
341874fe:	4770      	bx	lr

34187500 <HAL_I2C_Init>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
{
34187500:	b580      	push	{r7, lr}
34187502:	b082      	sub	sp, #8
34187504:	af00      	add	r7, sp, #0
34187506:	6078      	str	r0, [r7, #4]
  /* Check the I2C handle allocation */
  if (hi2c == NULL)
34187508:	687b      	ldr	r3, [r7, #4]
3418750a:	2b00      	cmp	r3, #0
3418750c:	d101      	bne.n	34187512 <HAL_I2C_Init+0x12>
  {
    return HAL_ERROR;
3418750e:	2301      	movs	r3, #1
34187510:	e08d      	b.n	3418762e <HAL_I2C_Init+0x12e>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));

  if (hi2c->State == HAL_I2C_STATE_RESET)
34187512:	687b      	ldr	r3, [r7, #4]
34187514:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
34187518:	b2db      	uxtb	r3, r3
3418751a:	2b00      	cmp	r3, #0
3418751c:	d106      	bne.n	3418752c <HAL_I2C_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hi2c->Lock = HAL_UNLOCKED;
3418751e:	687b      	ldr	r3, [r7, #4]
34187520:	2200      	movs	r2, #0
34187522:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    hi2c->MspInitCallback(hi2c);
#else
    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    HAL_I2C_MspInit(hi2c);
34187526:	6878      	ldr	r0, [r7, #4]
34187528:	f000 f8b4 	bl	34187694 <HAL_I2C_MspInit>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }

  hi2c->State = HAL_I2C_STATE_BUSY;
3418752c:	687b      	ldr	r3, [r7, #4]
3418752e:	2224      	movs	r2, #36	@ 0x24
34187530:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);
34187534:	687b      	ldr	r3, [r7, #4]
34187536:	681b      	ldr	r3, [r3, #0]
34187538:	681a      	ldr	r2, [r3, #0]
3418753a:	687b      	ldr	r3, [r7, #4]
3418753c:	681b      	ldr	r3, [r3, #0]
3418753e:	f022 0201 	bic.w	r2, r2, #1
34187542:	601a      	str	r2, [r3, #0]

  /*---------------------------- I2Cx TIMINGR Configuration ------------------*/
  /* Configure I2Cx: Frequency range */
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
34187544:	687b      	ldr	r3, [r7, #4]
34187546:	685a      	ldr	r2, [r3, #4]
34187548:	687b      	ldr	r3, [r7, #4]
3418754a:	681b      	ldr	r3, [r3, #0]
3418754c:	f022 6270 	bic.w	r2, r2, #251658240	@ 0xf000000
34187550:	611a      	str	r2, [r3, #16]

  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
  /* Disable Own Address1 before set the Own Address1 configuration */
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
34187552:	687b      	ldr	r3, [r7, #4]
34187554:	681b      	ldr	r3, [r3, #0]
34187556:	689a      	ldr	r2, [r3, #8]
34187558:	687b      	ldr	r3, [r7, #4]
3418755a:	681b      	ldr	r3, [r3, #0]
3418755c:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
34187560:	609a      	str	r2, [r3, #8]

  /* Configure I2Cx: Own Address1 and ack own address1 mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
34187562:	687b      	ldr	r3, [r7, #4]
34187564:	68db      	ldr	r3, [r3, #12]
34187566:	2b01      	cmp	r3, #1
34187568:	d107      	bne.n	3418757a <HAL_I2C_Init+0x7a>
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
3418756a:	687b      	ldr	r3, [r7, #4]
3418756c:	689a      	ldr	r2, [r3, #8]
3418756e:	687b      	ldr	r3, [r7, #4]
34187570:	681b      	ldr	r3, [r3, #0]
34187572:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
34187576:	609a      	str	r2, [r3, #8]
34187578:	e006      	b.n	34187588 <HAL_I2C_Init+0x88>
  }
  else /* I2C_ADDRESSINGMODE_10BIT */
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
3418757a:	687b      	ldr	r3, [r7, #4]
3418757c:	689a      	ldr	r2, [r3, #8]
3418757e:	687b      	ldr	r3, [r7, #4]
34187580:	681b      	ldr	r3, [r3, #0]
34187582:	f442 4204 	orr.w	r2, r2, #33792	@ 0x8400
34187586:	609a      	str	r2, [r3, #8]
  }

  /*---------------------------- I2Cx CR2 Configuration ----------------------*/
  /* Configure I2Cx: Addressing Master mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
34187588:	687b      	ldr	r3, [r7, #4]
3418758a:	68db      	ldr	r3, [r3, #12]
3418758c:	2b02      	cmp	r3, #2
3418758e:	d108      	bne.n	341875a2 <HAL_I2C_Init+0xa2>
  {
    SET_BIT(hi2c->Instance->CR2, I2C_CR2_ADD10);
34187590:	687b      	ldr	r3, [r7, #4]
34187592:	681b      	ldr	r3, [r3, #0]
34187594:	685a      	ldr	r2, [r3, #4]
34187596:	687b      	ldr	r3, [r7, #4]
34187598:	681b      	ldr	r3, [r3, #0]
3418759a:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
3418759e:	605a      	str	r2, [r3, #4]
341875a0:	e007      	b.n	341875b2 <HAL_I2C_Init+0xb2>
  }
  else
  {
    /* Clear the I2C ADD10 bit */
    CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_ADD10);
341875a2:	687b      	ldr	r3, [r7, #4]
341875a4:	681b      	ldr	r3, [r3, #0]
341875a6:	685a      	ldr	r2, [r3, #4]
341875a8:	687b      	ldr	r3, [r7, #4]
341875aa:	681b      	ldr	r3, [r3, #0]
341875ac:	f422 6200 	bic.w	r2, r2, #2048	@ 0x800
341875b0:	605a      	str	r2, [r3, #4]
  }
  /* Enable the AUTOEND by default, and enable NACK (should be disable only during Slave process */
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
341875b2:	687b      	ldr	r3, [r7, #4]
341875b4:	681b      	ldr	r3, [r3, #0]
341875b6:	685b      	ldr	r3, [r3, #4]
341875b8:	687a      	ldr	r2, [r7, #4]
341875ba:	6812      	ldr	r2, [r2, #0]
341875bc:	f043 7300 	orr.w	r3, r3, #33554432	@ 0x2000000
341875c0:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
341875c4:	6053      	str	r3, [r2, #4]

  /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
  /* Disable Own Address2 before set the Own Address2 configuration */
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
341875c6:	687b      	ldr	r3, [r7, #4]
341875c8:	681b      	ldr	r3, [r3, #0]
341875ca:	68da      	ldr	r2, [r3, #12]
341875cc:	687b      	ldr	r3, [r7, #4]
341875ce:	681b      	ldr	r3, [r3, #0]
341875d0:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
341875d4:	60da      	str	r2, [r3, #12]

  /* Configure I2Cx: Dual mode and Own Address2 */
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
341875d6:	687b      	ldr	r3, [r7, #4]
341875d8:	691a      	ldr	r2, [r3, #16]
341875da:	687b      	ldr	r3, [r7, #4]
341875dc:	695b      	ldr	r3, [r3, #20]
341875de:	ea42 0103 	orr.w	r1, r2, r3
                          (hi2c->Init.OwnAddress2Masks << 8));
341875e2:	687b      	ldr	r3, [r7, #4]
341875e4:	699b      	ldr	r3, [r3, #24]
341875e6:	021a      	lsls	r2, r3, #8
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
341875e8:	687b      	ldr	r3, [r7, #4]
341875ea:	681b      	ldr	r3, [r3, #0]
341875ec:	430a      	orrs	r2, r1
341875ee:	60da      	str	r2, [r3, #12]

  /*---------------------------- I2Cx CR1 Configuration ----------------------*/
  /* Configure I2Cx: Generalcall and NoStretch mode */
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
341875f0:	687b      	ldr	r3, [r7, #4]
341875f2:	69d9      	ldr	r1, [r3, #28]
341875f4:	687b      	ldr	r3, [r7, #4]
341875f6:	6a1a      	ldr	r2, [r3, #32]
341875f8:	687b      	ldr	r3, [r7, #4]
341875fa:	681b      	ldr	r3, [r3, #0]
341875fc:	430a      	orrs	r2, r1
341875fe:	601a      	str	r2, [r3, #0]

  /* Enable the selected I2C peripheral */
  __HAL_I2C_ENABLE(hi2c);
34187600:	687b      	ldr	r3, [r7, #4]
34187602:	681b      	ldr	r3, [r3, #0]
34187604:	681a      	ldr	r2, [r3, #0]
34187606:	687b      	ldr	r3, [r7, #4]
34187608:	681b      	ldr	r3, [r3, #0]
3418760a:	f042 0201 	orr.w	r2, r2, #1
3418760e:	601a      	str	r2, [r3, #0]

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
34187610:	687b      	ldr	r3, [r7, #4]
34187612:	2200      	movs	r2, #0
34187614:	645a      	str	r2, [r3, #68]	@ 0x44
  hi2c->State = HAL_I2C_STATE_READY;
34187616:	687b      	ldr	r3, [r7, #4]
34187618:	2220      	movs	r2, #32
3418761a:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
3418761e:	687b      	ldr	r3, [r7, #4]
34187620:	2200      	movs	r2, #0
34187622:	631a      	str	r2, [r3, #48]	@ 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
34187624:	687b      	ldr	r3, [r7, #4]
34187626:	2200      	movs	r2, #0
34187628:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

  return HAL_OK;
3418762c:	2300      	movs	r3, #0
}
3418762e:	4618      	mov	r0, r3
34187630:	3708      	adds	r7, #8
34187632:	46bd      	mov	sp, r7
34187634:	bd80      	pop	{r7, pc}

34187636 <HAL_I2C_DeInit>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_DeInit(I2C_HandleTypeDef *hi2c)
{
34187636:	b580      	push	{r7, lr}
34187638:	b082      	sub	sp, #8
3418763a:	af00      	add	r7, sp, #0
3418763c:	6078      	str	r0, [r7, #4]
  /* Check the I2C handle allocation */
  if (hi2c == NULL)
3418763e:	687b      	ldr	r3, [r7, #4]
34187640:	2b00      	cmp	r3, #0
34187642:	d101      	bne.n	34187648 <HAL_I2C_DeInit+0x12>
  {
    return HAL_ERROR;
34187644:	2301      	movs	r3, #1
34187646:	e021      	b.n	3418768c <HAL_I2C_DeInit+0x56>
  }

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));

  hi2c->State = HAL_I2C_STATE_BUSY;
34187648:	687b      	ldr	r3, [r7, #4]
3418764a:	2224      	movs	r2, #36	@ 0x24
3418764c:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

  /* Disable the I2C Peripheral Clock */
  __HAL_I2C_DISABLE(hi2c);
34187650:	687b      	ldr	r3, [r7, #4]
34187652:	681b      	ldr	r3, [r3, #0]
34187654:	681a      	ldr	r2, [r3, #0]
34187656:	687b      	ldr	r3, [r7, #4]
34187658:	681b      	ldr	r3, [r3, #0]
3418765a:	f022 0201 	bic.w	r2, r2, #1
3418765e:	601a      	str	r2, [r3, #0]

  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
  hi2c->MspDeInitCallback(hi2c);
#else
  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
  HAL_I2C_MspDeInit(hi2c);
34187660:	6878      	ldr	r0, [r7, #4]
34187662:	f000 f821 	bl	341876a8 <HAL_I2C_MspDeInit>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
34187666:	687b      	ldr	r3, [r7, #4]
34187668:	2200      	movs	r2, #0
3418766a:	645a      	str	r2, [r3, #68]	@ 0x44
  hi2c->State = HAL_I2C_STATE_RESET;
3418766c:	687b      	ldr	r3, [r7, #4]
3418766e:	2200      	movs	r2, #0
34187670:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
34187674:	687b      	ldr	r3, [r7, #4]
34187676:	2200      	movs	r2, #0
34187678:	631a      	str	r2, [r3, #48]	@ 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
3418767a:	687b      	ldr	r3, [r7, #4]
3418767c:	2200      	movs	r2, #0
3418767e:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

  /* Release Lock */
  __HAL_UNLOCK(hi2c);
34187682:	687b      	ldr	r3, [r7, #4]
34187684:	2200      	movs	r2, #0
34187686:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

  return HAL_OK;
3418768a:	2300      	movs	r3, #0
}
3418768c:	4618      	mov	r0, r3
3418768e:	3708      	adds	r7, #8
34187690:	46bd      	mov	sp, r7
34187692:	bd80      	pop	{r7, pc}

34187694 <HAL_I2C_MspInit>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MspInit(I2C_HandleTypeDef *hi2c)
{
34187694:	b480      	push	{r7}
34187696:	b083      	sub	sp, #12
34187698:	af00      	add	r7, sp, #0
3418769a:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MspInit could be implemented in the user file
   */
}
3418769c:	bf00      	nop
3418769e:	370c      	adds	r7, #12
341876a0:	46bd      	mov	sp, r7
341876a2:	f85d 7b04 	ldr.w	r7, [sp], #4
341876a6:	4770      	bx	lr

341876a8 <HAL_I2C_MspDeInit>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c)
{
341876a8:	b480      	push	{r7}
341876aa:	b083      	sub	sp, #12
341876ac:	af00      	add	r7, sp, #0
341876ae:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MspDeInit could be implemented in the user file
   */
}
341876b0:	bf00      	nop
341876b2:	370c      	adds	r7, #12
341876b4:	46bd      	mov	sp, r7
341876b6:	f85d 7b04 	ldr.w	r7, [sp], #4
341876ba:	4770      	bx	lr

341876bc <HAL_I2C_Mem_Write>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,
                                    uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
341876bc:	b580      	push	{r7, lr}
341876be:	b088      	sub	sp, #32
341876c0:	af02      	add	r7, sp, #8
341876c2:	60f8      	str	r0, [r7, #12]
341876c4:	4608      	mov	r0, r1
341876c6:	4611      	mov	r1, r2
341876c8:	461a      	mov	r2, r3
341876ca:	4603      	mov	r3, r0
341876cc:	817b      	strh	r3, [r7, #10]
341876ce:	460b      	mov	r3, r1
341876d0:	813b      	strh	r3, [r7, #8]
341876d2:	4613      	mov	r3, r2
341876d4:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
341876d6:	68fb      	ldr	r3, [r7, #12]
341876d8:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
341876dc:	b2db      	uxtb	r3, r3
341876de:	2b20      	cmp	r3, #32
341876e0:	f040 80f9 	bne.w	341878d6 <HAL_I2C_Mem_Write+0x21a>
  {
    if ((pData == NULL) || (Size == 0U))
341876e4:	6a3b      	ldr	r3, [r7, #32]
341876e6:	2b00      	cmp	r3, #0
341876e8:	d002      	beq.n	341876f0 <HAL_I2C_Mem_Write+0x34>
341876ea:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
341876ec:	2b00      	cmp	r3, #0
341876ee:	d105      	bne.n	341876fc <HAL_I2C_Mem_Write+0x40>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
341876f0:	68fb      	ldr	r3, [r7, #12]
341876f2:	f44f 7200 	mov.w	r2, #512	@ 0x200
341876f6:	645a      	str	r2, [r3, #68]	@ 0x44
      return  HAL_ERROR;
341876f8:	2301      	movs	r3, #1
341876fa:	e0ed      	b.n	341878d8 <HAL_I2C_Mem_Write+0x21c>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
341876fc:	68fb      	ldr	r3, [r7, #12]
341876fe:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
34187702:	2b01      	cmp	r3, #1
34187704:	d101      	bne.n	3418770a <HAL_I2C_Mem_Write+0x4e>
34187706:	2302      	movs	r3, #2
34187708:	e0e6      	b.n	341878d8 <HAL_I2C_Mem_Write+0x21c>
3418770a:	68fb      	ldr	r3, [r7, #12]
3418770c:	2201      	movs	r2, #1
3418770e:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
34187712:	f7fd ff51 	bl	341855b8 <HAL_GetTick>
34187716:	6178      	str	r0, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
34187718:	697b      	ldr	r3, [r7, #20]
3418771a:	9300      	str	r3, [sp, #0]
3418771c:	2319      	movs	r3, #25
3418771e:	2201      	movs	r2, #1
34187720:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
34187724:	68f8      	ldr	r0, [r7, #12]
34187726:	f000 fadd 	bl	34187ce4 <I2C_WaitOnFlagUntilTimeout>
3418772a:	4603      	mov	r3, r0
3418772c:	2b00      	cmp	r3, #0
3418772e:	d001      	beq.n	34187734 <HAL_I2C_Mem_Write+0x78>
    {
      return HAL_ERROR;
34187730:	2301      	movs	r3, #1
34187732:	e0d1      	b.n	341878d8 <HAL_I2C_Mem_Write+0x21c>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
34187734:	68fb      	ldr	r3, [r7, #12]
34187736:	2221      	movs	r2, #33	@ 0x21
34187738:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
3418773c:	68fb      	ldr	r3, [r7, #12]
3418773e:	2240      	movs	r2, #64	@ 0x40
34187740:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
34187744:	68fb      	ldr	r3, [r7, #12]
34187746:	2200      	movs	r2, #0
34187748:	645a      	str	r2, [r3, #68]	@ 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
3418774a:	68fb      	ldr	r3, [r7, #12]
3418774c:	6a3a      	ldr	r2, [r7, #32]
3418774e:	625a      	str	r2, [r3, #36]	@ 0x24
    hi2c->XferCount = Size;
34187750:	68fb      	ldr	r3, [r7, #12]
34187752:	8cba      	ldrh	r2, [r7, #36]	@ 0x24
34187754:	855a      	strh	r2, [r3, #42]	@ 0x2a
    hi2c->XferISR   = NULL;
34187756:	68fb      	ldr	r3, [r7, #12]
34187758:	2200      	movs	r2, #0
3418775a:	635a      	str	r2, [r3, #52]	@ 0x34

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
3418775c:	88f8      	ldrh	r0, [r7, #6]
3418775e:	893a      	ldrh	r2, [r7, #8]
34187760:	8979      	ldrh	r1, [r7, #10]
34187762:	697b      	ldr	r3, [r7, #20]
34187764:	9301      	str	r3, [sp, #4]
34187766:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34187768:	9300      	str	r3, [sp, #0]
3418776a:	4603      	mov	r3, r0
3418776c:	68f8      	ldr	r0, [r7, #12]
3418776e:	f000 f9ed 	bl	34187b4c <I2C_RequestMemoryWrite>
34187772:	4603      	mov	r3, r0
34187774:	2b00      	cmp	r3, #0
34187776:	d005      	beq.n	34187784 <HAL_I2C_Mem_Write+0xc8>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
34187778:	68fb      	ldr	r3, [r7, #12]
3418777a:	2200      	movs	r2, #0
3418777c:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
      return HAL_ERROR;
34187780:	2301      	movs	r3, #1
34187782:	e0a9      	b.n	341878d8 <HAL_I2C_Mem_Write+0x21c>
    }

    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
34187784:	68fb      	ldr	r3, [r7, #12]
34187786:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34187788:	b29b      	uxth	r3, r3
3418778a:	2bff      	cmp	r3, #255	@ 0xff
3418778c:	d90e      	bls.n	341877ac <HAL_I2C_Mem_Write+0xf0>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
3418778e:	68fb      	ldr	r3, [r7, #12]
34187790:	22ff      	movs	r2, #255	@ 0xff
34187792:	851a      	strh	r2, [r3, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
34187794:	68fb      	ldr	r3, [r7, #12]
34187796:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
34187798:	b2da      	uxtb	r2, r3
3418779a:	8979      	ldrh	r1, [r7, #10]
3418779c:	2300      	movs	r3, #0
3418779e:	9300      	str	r3, [sp, #0]
341877a0:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
341877a4:	68f8      	ldr	r0, [r7, #12]
341877a6:	f000 fc61 	bl	3418806c <I2C_TransferConfig>
341877aa:	e00f      	b.n	341877cc <HAL_I2C_Mem_Write+0x110>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
341877ac:	68fb      	ldr	r3, [r7, #12]
341877ae:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
341877b0:	b29a      	uxth	r2, r3
341877b2:	68fb      	ldr	r3, [r7, #12]
341877b4:	851a      	strh	r2, [r3, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
341877b6:	68fb      	ldr	r3, [r7, #12]
341877b8:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
341877ba:	b2da      	uxtb	r2, r3
341877bc:	8979      	ldrh	r1, [r7, #10]
341877be:	2300      	movs	r3, #0
341877c0:	9300      	str	r3, [sp, #0]
341877c2:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
341877c6:	68f8      	ldr	r0, [r7, #12]
341877c8:	f000 fc50 	bl	3418806c <I2C_TransferConfig>
    }

    do
    {
      /* Wait until TXIS flag is set */
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
341877cc:	697a      	ldr	r2, [r7, #20]
341877ce:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
341877d0:	68f8      	ldr	r0, [r7, #12]
341877d2:	f000 fae0 	bl	34187d96 <I2C_WaitOnTXISFlagUntilTimeout>
341877d6:	4603      	mov	r3, r0
341877d8:	2b00      	cmp	r3, #0
341877da:	d001      	beq.n	341877e0 <HAL_I2C_Mem_Write+0x124>
      {
        return HAL_ERROR;
341877dc:	2301      	movs	r3, #1
341877de:	e07b      	b.n	341878d8 <HAL_I2C_Mem_Write+0x21c>
      }

      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
341877e0:	68fb      	ldr	r3, [r7, #12]
341877e2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
341877e4:	781a      	ldrb	r2, [r3, #0]
341877e6:	68fb      	ldr	r3, [r7, #12]
341877e8:	681b      	ldr	r3, [r3, #0]
341877ea:	629a      	str	r2, [r3, #40]	@ 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
341877ec:	68fb      	ldr	r3, [r7, #12]
341877ee:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
341877f0:	1c5a      	adds	r2, r3, #1
341877f2:	68fb      	ldr	r3, [r7, #12]
341877f4:	625a      	str	r2, [r3, #36]	@ 0x24

      hi2c->XferCount--;
341877f6:	68fb      	ldr	r3, [r7, #12]
341877f8:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
341877fa:	b29b      	uxth	r3, r3
341877fc:	3b01      	subs	r3, #1
341877fe:	b29a      	uxth	r2, r3
34187800:	68fb      	ldr	r3, [r7, #12]
34187802:	855a      	strh	r2, [r3, #42]	@ 0x2a
      hi2c->XferSize--;
34187804:	68fb      	ldr	r3, [r7, #12]
34187806:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
34187808:	3b01      	subs	r3, #1
3418780a:	b29a      	uxth	r2, r3
3418780c:	68fb      	ldr	r3, [r7, #12]
3418780e:	851a      	strh	r2, [r3, #40]	@ 0x28

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
34187810:	68fb      	ldr	r3, [r7, #12]
34187812:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34187814:	b29b      	uxth	r3, r3
34187816:	2b00      	cmp	r3, #0
34187818:	d034      	beq.n	34187884 <HAL_I2C_Mem_Write+0x1c8>
3418781a:	68fb      	ldr	r3, [r7, #12]
3418781c:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
3418781e:	2b00      	cmp	r3, #0
34187820:	d130      	bne.n	34187884 <HAL_I2C_Mem_Write+0x1c8>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
34187822:	697b      	ldr	r3, [r7, #20]
34187824:	9300      	str	r3, [sp, #0]
34187826:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34187828:	2200      	movs	r2, #0
3418782a:	2180      	movs	r1, #128	@ 0x80
3418782c:	68f8      	ldr	r0, [r7, #12]
3418782e:	f000 fa59 	bl	34187ce4 <I2C_WaitOnFlagUntilTimeout>
34187832:	4603      	mov	r3, r0
34187834:	2b00      	cmp	r3, #0
34187836:	d001      	beq.n	3418783c <HAL_I2C_Mem_Write+0x180>
        {
          return HAL_ERROR;
34187838:	2301      	movs	r3, #1
3418783a:	e04d      	b.n	341878d8 <HAL_I2C_Mem_Write+0x21c>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
3418783c:	68fb      	ldr	r3, [r7, #12]
3418783e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34187840:	b29b      	uxth	r3, r3
34187842:	2bff      	cmp	r3, #255	@ 0xff
34187844:	d90e      	bls.n	34187864 <HAL_I2C_Mem_Write+0x1a8>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
34187846:	68fb      	ldr	r3, [r7, #12]
34187848:	22ff      	movs	r2, #255	@ 0xff
3418784a:	851a      	strh	r2, [r3, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
3418784c:	68fb      	ldr	r3, [r7, #12]
3418784e:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
34187850:	b2da      	uxtb	r2, r3
34187852:	8979      	ldrh	r1, [r7, #10]
34187854:	2300      	movs	r3, #0
34187856:	9300      	str	r3, [sp, #0]
34187858:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
3418785c:	68f8      	ldr	r0, [r7, #12]
3418785e:	f000 fc05 	bl	3418806c <I2C_TransferConfig>
34187862:	e00f      	b.n	34187884 <HAL_I2C_Mem_Write+0x1c8>
                             I2C_NO_STARTSTOP);
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
34187864:	68fb      	ldr	r3, [r7, #12]
34187866:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34187868:	b29a      	uxth	r2, r3
3418786a:	68fb      	ldr	r3, [r7, #12]
3418786c:	851a      	strh	r2, [r3, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
3418786e:	68fb      	ldr	r3, [r7, #12]
34187870:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
34187872:	b2da      	uxtb	r2, r3
34187874:	8979      	ldrh	r1, [r7, #10]
34187876:	2300      	movs	r3, #0
34187878:	9300      	str	r3, [sp, #0]
3418787a:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
3418787e:	68f8      	ldr	r0, [r7, #12]
34187880:	f000 fbf4 	bl	3418806c <I2C_TransferConfig>
                             I2C_NO_STARTSTOP);
        }
      }

    } while (hi2c->XferCount > 0U);
34187884:	68fb      	ldr	r3, [r7, #12]
34187886:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34187888:	b29b      	uxth	r3, r3
3418788a:	2b00      	cmp	r3, #0
3418788c:	d19e      	bne.n	341877cc <HAL_I2C_Mem_Write+0x110>

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
3418788e:	697a      	ldr	r2, [r7, #20]
34187890:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
34187892:	68f8      	ldr	r0, [r7, #12]
34187894:	f000 fac6 	bl	34187e24 <I2C_WaitOnSTOPFlagUntilTimeout>
34187898:	4603      	mov	r3, r0
3418789a:	2b00      	cmp	r3, #0
3418789c:	d001      	beq.n	341878a2 <HAL_I2C_Mem_Write+0x1e6>
    {
      return HAL_ERROR;
3418789e:	2301      	movs	r3, #1
341878a0:	e01a      	b.n	341878d8 <HAL_I2C_Mem_Write+0x21c>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
341878a2:	68fb      	ldr	r3, [r7, #12]
341878a4:	681b      	ldr	r3, [r3, #0]
341878a6:	2220      	movs	r2, #32
341878a8:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
341878aa:	68fb      	ldr	r3, [r7, #12]
341878ac:	681b      	ldr	r3, [r3, #0]
341878ae:	6859      	ldr	r1, [r3, #4]
341878b0:	68fb      	ldr	r3, [r7, #12]
341878b2:	681a      	ldr	r2, [r3, #0]
341878b4:	4b0a      	ldr	r3, [pc, #40]	@ (341878e0 <HAL_I2C_Mem_Write+0x224>)
341878b6:	400b      	ands	r3, r1
341878b8:	6053      	str	r3, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY;
341878ba:	68fb      	ldr	r3, [r7, #12]
341878bc:	2220      	movs	r2, #32
341878be:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
341878c2:	68fb      	ldr	r3, [r7, #12]
341878c4:	2200      	movs	r2, #0
341878c6:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
341878ca:	68fb      	ldr	r3, [r7, #12]
341878cc:	2200      	movs	r2, #0
341878ce:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    return HAL_OK;
341878d2:	2300      	movs	r3, #0
341878d4:	e000      	b.n	341878d8 <HAL_I2C_Mem_Write+0x21c>
  }
  else
  {
    return HAL_BUSY;
341878d6:	2302      	movs	r3, #2
  }
}
341878d8:	4618      	mov	r0, r3
341878da:	3718      	adds	r7, #24
341878dc:	46bd      	mov	sp, r7
341878de:	bd80      	pop	{r7, pc}
341878e0:	fe00e800 	.word	0xfe00e800

341878e4 <HAL_I2C_Mem_Read>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,
                                   uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
341878e4:	b580      	push	{r7, lr}
341878e6:	b088      	sub	sp, #32
341878e8:	af02      	add	r7, sp, #8
341878ea:	60f8      	str	r0, [r7, #12]
341878ec:	4608      	mov	r0, r1
341878ee:	4611      	mov	r1, r2
341878f0:	461a      	mov	r2, r3
341878f2:	4603      	mov	r3, r0
341878f4:	817b      	strh	r3, [r7, #10]
341878f6:	460b      	mov	r3, r1
341878f8:	813b      	strh	r3, [r7, #8]
341878fa:	4613      	mov	r3, r2
341878fc:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
341878fe:	68fb      	ldr	r3, [r7, #12]
34187900:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
34187904:	b2db      	uxtb	r3, r3
34187906:	2b20      	cmp	r3, #32
34187908:	f040 80fd 	bne.w	34187b06 <HAL_I2C_Mem_Read+0x222>
  {
    if ((pData == NULL) || (Size == 0U))
3418790c:	6a3b      	ldr	r3, [r7, #32]
3418790e:	2b00      	cmp	r3, #0
34187910:	d002      	beq.n	34187918 <HAL_I2C_Mem_Read+0x34>
34187912:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
34187914:	2b00      	cmp	r3, #0
34187916:	d105      	bne.n	34187924 <HAL_I2C_Mem_Read+0x40>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
34187918:	68fb      	ldr	r3, [r7, #12]
3418791a:	f44f 7200 	mov.w	r2, #512	@ 0x200
3418791e:	645a      	str	r2, [r3, #68]	@ 0x44
      return  HAL_ERROR;
34187920:	2301      	movs	r3, #1
34187922:	e0f1      	b.n	34187b08 <HAL_I2C_Mem_Read+0x224>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
34187924:	68fb      	ldr	r3, [r7, #12]
34187926:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
3418792a:	2b01      	cmp	r3, #1
3418792c:	d101      	bne.n	34187932 <HAL_I2C_Mem_Read+0x4e>
3418792e:	2302      	movs	r3, #2
34187930:	e0ea      	b.n	34187b08 <HAL_I2C_Mem_Read+0x224>
34187932:	68fb      	ldr	r3, [r7, #12]
34187934:	2201      	movs	r2, #1
34187936:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
3418793a:	f7fd fe3d 	bl	341855b8 <HAL_GetTick>
3418793e:	6178      	str	r0, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
34187940:	697b      	ldr	r3, [r7, #20]
34187942:	9300      	str	r3, [sp, #0]
34187944:	2319      	movs	r3, #25
34187946:	2201      	movs	r2, #1
34187948:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
3418794c:	68f8      	ldr	r0, [r7, #12]
3418794e:	f000 f9c9 	bl	34187ce4 <I2C_WaitOnFlagUntilTimeout>
34187952:	4603      	mov	r3, r0
34187954:	2b00      	cmp	r3, #0
34187956:	d001      	beq.n	3418795c <HAL_I2C_Mem_Read+0x78>
    {
      return HAL_ERROR;
34187958:	2301      	movs	r3, #1
3418795a:	e0d5      	b.n	34187b08 <HAL_I2C_Mem_Read+0x224>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
3418795c:	68fb      	ldr	r3, [r7, #12]
3418795e:	2222      	movs	r2, #34	@ 0x22
34187960:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
34187964:	68fb      	ldr	r3, [r7, #12]
34187966:	2240      	movs	r2, #64	@ 0x40
34187968:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
3418796c:	68fb      	ldr	r3, [r7, #12]
3418796e:	2200      	movs	r2, #0
34187970:	645a      	str	r2, [r3, #68]	@ 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
34187972:	68fb      	ldr	r3, [r7, #12]
34187974:	6a3a      	ldr	r2, [r7, #32]
34187976:	625a      	str	r2, [r3, #36]	@ 0x24
    hi2c->XferCount = Size;
34187978:	68fb      	ldr	r3, [r7, #12]
3418797a:	8cba      	ldrh	r2, [r7, #36]	@ 0x24
3418797c:	855a      	strh	r2, [r3, #42]	@ 0x2a
    hi2c->XferISR   = NULL;
3418797e:	68fb      	ldr	r3, [r7, #12]
34187980:	2200      	movs	r2, #0
34187982:	635a      	str	r2, [r3, #52]	@ 0x34

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
34187984:	88f8      	ldrh	r0, [r7, #6]
34187986:	893a      	ldrh	r2, [r7, #8]
34187988:	8979      	ldrh	r1, [r7, #10]
3418798a:	697b      	ldr	r3, [r7, #20]
3418798c:	9301      	str	r3, [sp, #4]
3418798e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34187990:	9300      	str	r3, [sp, #0]
34187992:	4603      	mov	r3, r0
34187994:	68f8      	ldr	r0, [r7, #12]
34187996:	f000 f92d 	bl	34187bf4 <I2C_RequestMemoryRead>
3418799a:	4603      	mov	r3, r0
3418799c:	2b00      	cmp	r3, #0
3418799e:	d005      	beq.n	341879ac <HAL_I2C_Mem_Read+0xc8>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
341879a0:	68fb      	ldr	r3, [r7, #12]
341879a2:	2200      	movs	r2, #0
341879a4:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
      return HAL_ERROR;
341879a8:	2301      	movs	r3, #1
341879aa:	e0ad      	b.n	34187b08 <HAL_I2C_Mem_Read+0x224>
    }

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
341879ac:	68fb      	ldr	r3, [r7, #12]
341879ae:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
341879b0:	b29b      	uxth	r3, r3
341879b2:	2bff      	cmp	r3, #255	@ 0xff
341879b4:	d90e      	bls.n	341879d4 <HAL_I2C_Mem_Read+0xf0>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
341879b6:	68fb      	ldr	r3, [r7, #12]
341879b8:	22ff      	movs	r2, #255	@ 0xff
341879ba:	851a      	strh	r2, [r3, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
341879bc:	68fb      	ldr	r3, [r7, #12]
341879be:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
341879c0:	b2da      	uxtb	r2, r3
341879c2:	8979      	ldrh	r1, [r7, #10]
341879c4:	4b52      	ldr	r3, [pc, #328]	@ (34187b10 <HAL_I2C_Mem_Read+0x22c>)
341879c6:	9300      	str	r3, [sp, #0]
341879c8:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
341879cc:	68f8      	ldr	r0, [r7, #12]
341879ce:	f000 fb4d 	bl	3418806c <I2C_TransferConfig>
341879d2:	e00f      	b.n	341879f4 <HAL_I2C_Mem_Read+0x110>
                         I2C_GENERATE_START_READ);
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
341879d4:	68fb      	ldr	r3, [r7, #12]
341879d6:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
341879d8:	b29a      	uxth	r2, r3
341879da:	68fb      	ldr	r3, [r7, #12]
341879dc:	851a      	strh	r2, [r3, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
341879de:	68fb      	ldr	r3, [r7, #12]
341879e0:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
341879e2:	b2da      	uxtb	r2, r3
341879e4:	8979      	ldrh	r1, [r7, #10]
341879e6:	4b4a      	ldr	r3, [pc, #296]	@ (34187b10 <HAL_I2C_Mem_Read+0x22c>)
341879e8:	9300      	str	r3, [sp, #0]
341879ea:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
341879ee:	68f8      	ldr	r0, [r7, #12]
341879f0:	f000 fb3c 	bl	3418806c <I2C_TransferConfig>
    }

    do
    {
      /* Wait until RXNE flag is set */
      if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout, tickstart) != HAL_OK)
341879f4:	697b      	ldr	r3, [r7, #20]
341879f6:	9300      	str	r3, [sp, #0]
341879f8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
341879fa:	2200      	movs	r2, #0
341879fc:	2104      	movs	r1, #4
341879fe:	68f8      	ldr	r0, [r7, #12]
34187a00:	f000 f970 	bl	34187ce4 <I2C_WaitOnFlagUntilTimeout>
34187a04:	4603      	mov	r3, r0
34187a06:	2b00      	cmp	r3, #0
34187a08:	d001      	beq.n	34187a0e <HAL_I2C_Mem_Read+0x12a>
      {
        return HAL_ERROR;
34187a0a:	2301      	movs	r3, #1
34187a0c:	e07c      	b.n	34187b08 <HAL_I2C_Mem_Read+0x224>
      }

      /* Read data from RXDR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
34187a0e:	68fb      	ldr	r3, [r7, #12]
34187a10:	681b      	ldr	r3, [r3, #0]
34187a12:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
34187a14:	68fb      	ldr	r3, [r7, #12]
34187a16:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34187a18:	b2d2      	uxtb	r2, r2
34187a1a:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
34187a1c:	68fb      	ldr	r3, [r7, #12]
34187a1e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34187a20:	1c5a      	adds	r2, r3, #1
34187a22:	68fb      	ldr	r3, [r7, #12]
34187a24:	625a      	str	r2, [r3, #36]	@ 0x24

      hi2c->XferSize--;
34187a26:	68fb      	ldr	r3, [r7, #12]
34187a28:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
34187a2a:	3b01      	subs	r3, #1
34187a2c:	b29a      	uxth	r2, r3
34187a2e:	68fb      	ldr	r3, [r7, #12]
34187a30:	851a      	strh	r2, [r3, #40]	@ 0x28
      hi2c->XferCount--;
34187a32:	68fb      	ldr	r3, [r7, #12]
34187a34:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34187a36:	b29b      	uxth	r3, r3
34187a38:	3b01      	subs	r3, #1
34187a3a:	b29a      	uxth	r2, r3
34187a3c:	68fb      	ldr	r3, [r7, #12]
34187a3e:	855a      	strh	r2, [r3, #42]	@ 0x2a

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
34187a40:	68fb      	ldr	r3, [r7, #12]
34187a42:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34187a44:	b29b      	uxth	r3, r3
34187a46:	2b00      	cmp	r3, #0
34187a48:	d034      	beq.n	34187ab4 <HAL_I2C_Mem_Read+0x1d0>
34187a4a:	68fb      	ldr	r3, [r7, #12]
34187a4c:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
34187a4e:	2b00      	cmp	r3, #0
34187a50:	d130      	bne.n	34187ab4 <HAL_I2C_Mem_Read+0x1d0>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
34187a52:	697b      	ldr	r3, [r7, #20]
34187a54:	9300      	str	r3, [sp, #0]
34187a56:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34187a58:	2200      	movs	r2, #0
34187a5a:	2180      	movs	r1, #128	@ 0x80
34187a5c:	68f8      	ldr	r0, [r7, #12]
34187a5e:	f000 f941 	bl	34187ce4 <I2C_WaitOnFlagUntilTimeout>
34187a62:	4603      	mov	r3, r0
34187a64:	2b00      	cmp	r3, #0
34187a66:	d001      	beq.n	34187a6c <HAL_I2C_Mem_Read+0x188>
        {
          return HAL_ERROR;
34187a68:	2301      	movs	r3, #1
34187a6a:	e04d      	b.n	34187b08 <HAL_I2C_Mem_Read+0x224>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
34187a6c:	68fb      	ldr	r3, [r7, #12]
34187a6e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34187a70:	b29b      	uxth	r3, r3
34187a72:	2bff      	cmp	r3, #255	@ 0xff
34187a74:	d90e      	bls.n	34187a94 <HAL_I2C_Mem_Read+0x1b0>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
34187a76:	68fb      	ldr	r3, [r7, #12]
34187a78:	22ff      	movs	r2, #255	@ 0xff
34187a7a:	851a      	strh	r2, [r3, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t) hi2c->XferSize, I2C_RELOAD_MODE,
34187a7c:	68fb      	ldr	r3, [r7, #12]
34187a7e:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
34187a80:	b2da      	uxtb	r2, r3
34187a82:	8979      	ldrh	r1, [r7, #10]
34187a84:	2300      	movs	r3, #0
34187a86:	9300      	str	r3, [sp, #0]
34187a88:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
34187a8c:	68f8      	ldr	r0, [r7, #12]
34187a8e:	f000 faed 	bl	3418806c <I2C_TransferConfig>
34187a92:	e00f      	b.n	34187ab4 <HAL_I2C_Mem_Read+0x1d0>
                             I2C_NO_STARTSTOP);
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
34187a94:	68fb      	ldr	r3, [r7, #12]
34187a96:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34187a98:	b29a      	uxth	r2, r3
34187a9a:	68fb      	ldr	r3, [r7, #12]
34187a9c:	851a      	strh	r2, [r3, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
34187a9e:	68fb      	ldr	r3, [r7, #12]
34187aa0:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
34187aa2:	b2da      	uxtb	r2, r3
34187aa4:	8979      	ldrh	r1, [r7, #10]
34187aa6:	2300      	movs	r3, #0
34187aa8:	9300      	str	r3, [sp, #0]
34187aaa:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
34187aae:	68f8      	ldr	r0, [r7, #12]
34187ab0:	f000 fadc 	bl	3418806c <I2C_TransferConfig>
                             I2C_NO_STARTSTOP);
        }
      }
    } while (hi2c->XferCount > 0U);
34187ab4:	68fb      	ldr	r3, [r7, #12]
34187ab6:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34187ab8:	b29b      	uxth	r3, r3
34187aba:	2b00      	cmp	r3, #0
34187abc:	d19a      	bne.n	341879f4 <HAL_I2C_Mem_Read+0x110>

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
34187abe:	697a      	ldr	r2, [r7, #20]
34187ac0:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
34187ac2:	68f8      	ldr	r0, [r7, #12]
34187ac4:	f000 f9ae 	bl	34187e24 <I2C_WaitOnSTOPFlagUntilTimeout>
34187ac8:	4603      	mov	r3, r0
34187aca:	2b00      	cmp	r3, #0
34187acc:	d001      	beq.n	34187ad2 <HAL_I2C_Mem_Read+0x1ee>
    {
      return HAL_ERROR;
34187ace:	2301      	movs	r3, #1
34187ad0:	e01a      	b.n	34187b08 <HAL_I2C_Mem_Read+0x224>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
34187ad2:	68fb      	ldr	r3, [r7, #12]
34187ad4:	681b      	ldr	r3, [r3, #0]
34187ad6:	2220      	movs	r2, #32
34187ad8:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
34187ada:	68fb      	ldr	r3, [r7, #12]
34187adc:	681b      	ldr	r3, [r3, #0]
34187ade:	6859      	ldr	r1, [r3, #4]
34187ae0:	68fb      	ldr	r3, [r7, #12]
34187ae2:	681a      	ldr	r2, [r3, #0]
34187ae4:	4b0b      	ldr	r3, [pc, #44]	@ (34187b14 <HAL_I2C_Mem_Read+0x230>)
34187ae6:	400b      	ands	r3, r1
34187ae8:	6053      	str	r3, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY;
34187aea:	68fb      	ldr	r3, [r7, #12]
34187aec:	2220      	movs	r2, #32
34187aee:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
34187af2:	68fb      	ldr	r3, [r7, #12]
34187af4:	2200      	movs	r2, #0
34187af6:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
34187afa:	68fb      	ldr	r3, [r7, #12]
34187afc:	2200      	movs	r2, #0
34187afe:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    return HAL_OK;
34187b02:	2300      	movs	r3, #0
34187b04:	e000      	b.n	34187b08 <HAL_I2C_Mem_Read+0x224>
  }
  else
  {
    return HAL_BUSY;
34187b06:	2302      	movs	r3, #2
  }
}
34187b08:	4618      	mov	r0, r3
34187b0a:	3718      	adds	r7, #24
34187b0c:	46bd      	mov	sp, r7
34187b0e:	bd80      	pop	{r7, pc}
34187b10:	80002400 	.word	0x80002400
34187b14:	fe00e800 	.word	0xfe00e800

34187b18 <HAL_I2C_GetState>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL state
  */
HAL_I2C_StateTypeDef HAL_I2C_GetState(const I2C_HandleTypeDef *hi2c)
{
34187b18:	b480      	push	{r7}
34187b1a:	b083      	sub	sp, #12
34187b1c:	af00      	add	r7, sp, #0
34187b1e:	6078      	str	r0, [r7, #4]
  /* Return I2C handle state */
  return hi2c->State;
34187b20:	687b      	ldr	r3, [r7, #4]
34187b22:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
34187b26:	b2db      	uxtb	r3, r3
}
34187b28:	4618      	mov	r0, r3
34187b2a:	370c      	adds	r7, #12
34187b2c:	46bd      	mov	sp, r7
34187b2e:	f85d 7b04 	ldr.w	r7, [sp], #4
34187b32:	4770      	bx	lr

34187b34 <HAL_I2C_GetError>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *              the configuration information for the specified I2C.
  * @retval I2C Error Code
  */
uint32_t HAL_I2C_GetError(const I2C_HandleTypeDef *hi2c)
{
34187b34:	b480      	push	{r7}
34187b36:	b083      	sub	sp, #12
34187b38:	af00      	add	r7, sp, #0
34187b3a:	6078      	str	r0, [r7, #4]
  return hi2c->ErrorCode;
34187b3c:	687b      	ldr	r3, [r7, #4]
34187b3e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
}
34187b40:	4618      	mov	r0, r3
34187b42:	370c      	adds	r7, #12
34187b44:	46bd      	mov	sp, r7
34187b46:	f85d 7b04 	ldr.w	r7, [sp], #4
34187b4a:	4770      	bx	lr

34187b4c <I2C_RequestMemoryWrite>:
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress,
                                                uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout,
                                                uint32_t Tickstart)
{
34187b4c:	b580      	push	{r7, lr}
34187b4e:	b086      	sub	sp, #24
34187b50:	af02      	add	r7, sp, #8
34187b52:	60f8      	str	r0, [r7, #12]
34187b54:	4608      	mov	r0, r1
34187b56:	4611      	mov	r1, r2
34187b58:	461a      	mov	r2, r3
34187b5a:	4603      	mov	r3, r0
34187b5c:	817b      	strh	r3, [r7, #10]
34187b5e:	460b      	mov	r3, r1
34187b60:	813b      	strh	r3, [r7, #8]
34187b62:	4613      	mov	r3, r2
34187b64:	80fb      	strh	r3, [r7, #6]
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
34187b66:	88fb      	ldrh	r3, [r7, #6]
34187b68:	b2da      	uxtb	r2, r3
34187b6a:	8979      	ldrh	r1, [r7, #10]
34187b6c:	4b20      	ldr	r3, [pc, #128]	@ (34187bf0 <I2C_RequestMemoryWrite+0xa4>)
34187b6e:	9300      	str	r3, [sp, #0]
34187b70:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
34187b74:	68f8      	ldr	r0, [r7, #12]
34187b76:	f000 fa79 	bl	3418806c <I2C_TransferConfig>

  /* Wait until TXIS flag is set */
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
34187b7a:	69fa      	ldr	r2, [r7, #28]
34187b7c:	69b9      	ldr	r1, [r7, #24]
34187b7e:	68f8      	ldr	r0, [r7, #12]
34187b80:	f000 f909 	bl	34187d96 <I2C_WaitOnTXISFlagUntilTimeout>
34187b84:	4603      	mov	r3, r0
34187b86:	2b00      	cmp	r3, #0
34187b88:	d001      	beq.n	34187b8e <I2C_RequestMemoryWrite+0x42>
  {
    return HAL_ERROR;
34187b8a:	2301      	movs	r3, #1
34187b8c:	e02c      	b.n	34187be8 <I2C_RequestMemoryWrite+0x9c>
  }

  /* If Memory address size is 8Bit */
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
34187b8e:	88fb      	ldrh	r3, [r7, #6]
34187b90:	2b01      	cmp	r3, #1
34187b92:	d105      	bne.n	34187ba0 <I2C_RequestMemoryWrite+0x54>
  {
    /* Send Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
34187b94:	893b      	ldrh	r3, [r7, #8]
34187b96:	b2da      	uxtb	r2, r3
34187b98:	68fb      	ldr	r3, [r7, #12]
34187b9a:	681b      	ldr	r3, [r3, #0]
34187b9c:	629a      	str	r2, [r3, #40]	@ 0x28
34187b9e:	e015      	b.n	34187bcc <I2C_RequestMemoryWrite+0x80>
  }
  /* If Memory address size is 16Bit */
  else
  {
    /* Send MSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
34187ba0:	893b      	ldrh	r3, [r7, #8]
34187ba2:	0a1b      	lsrs	r3, r3, #8
34187ba4:	b29b      	uxth	r3, r3
34187ba6:	b2da      	uxtb	r2, r3
34187ba8:	68fb      	ldr	r3, [r7, #12]
34187baa:	681b      	ldr	r3, [r3, #0]
34187bac:	629a      	str	r2, [r3, #40]	@ 0x28

    /* Wait until TXIS flag is set */
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
34187bae:	69fa      	ldr	r2, [r7, #28]
34187bb0:	69b9      	ldr	r1, [r7, #24]
34187bb2:	68f8      	ldr	r0, [r7, #12]
34187bb4:	f000 f8ef 	bl	34187d96 <I2C_WaitOnTXISFlagUntilTimeout>
34187bb8:	4603      	mov	r3, r0
34187bba:	2b00      	cmp	r3, #0
34187bbc:	d001      	beq.n	34187bc2 <I2C_RequestMemoryWrite+0x76>
    {
      return HAL_ERROR;
34187bbe:	2301      	movs	r3, #1
34187bc0:	e012      	b.n	34187be8 <I2C_RequestMemoryWrite+0x9c>
    }

    /* Send LSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
34187bc2:	893b      	ldrh	r3, [r7, #8]
34187bc4:	b2da      	uxtb	r2, r3
34187bc6:	68fb      	ldr	r3, [r7, #12]
34187bc8:	681b      	ldr	r3, [r3, #0]
34187bca:	629a      	str	r2, [r3, #40]	@ 0x28
  }

  /* Wait until TCR flag is set */
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, Tickstart) != HAL_OK)
34187bcc:	69fb      	ldr	r3, [r7, #28]
34187bce:	9300      	str	r3, [sp, #0]
34187bd0:	69bb      	ldr	r3, [r7, #24]
34187bd2:	2200      	movs	r2, #0
34187bd4:	2180      	movs	r1, #128	@ 0x80
34187bd6:	68f8      	ldr	r0, [r7, #12]
34187bd8:	f000 f884 	bl	34187ce4 <I2C_WaitOnFlagUntilTimeout>
34187bdc:	4603      	mov	r3, r0
34187bde:	2b00      	cmp	r3, #0
34187be0:	d001      	beq.n	34187be6 <I2C_RequestMemoryWrite+0x9a>
  {
    return HAL_ERROR;
34187be2:	2301      	movs	r3, #1
34187be4:	e000      	b.n	34187be8 <I2C_RequestMemoryWrite+0x9c>
  }

  return HAL_OK;
34187be6:	2300      	movs	r3, #0
}
34187be8:	4618      	mov	r0, r3
34187bea:	3710      	adds	r7, #16
34187bec:	46bd      	mov	sp, r7
34187bee:	bd80      	pop	{r7, pc}
34187bf0:	80002000 	.word	0x80002000

34187bf4 <I2C_RequestMemoryRead>:
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress,
                                               uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout,
                                               uint32_t Tickstart)
{
34187bf4:	b580      	push	{r7, lr}
34187bf6:	b086      	sub	sp, #24
34187bf8:	af02      	add	r7, sp, #8
34187bfa:	60f8      	str	r0, [r7, #12]
34187bfc:	4608      	mov	r0, r1
34187bfe:	4611      	mov	r1, r2
34187c00:	461a      	mov	r2, r3
34187c02:	4603      	mov	r3, r0
34187c04:	817b      	strh	r3, [r7, #10]
34187c06:	460b      	mov	r3, r1
34187c08:	813b      	strh	r3, [r7, #8]
34187c0a:	4613      	mov	r3, r2
34187c0c:	80fb      	strh	r3, [r7, #6]
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
34187c0e:	88fb      	ldrh	r3, [r7, #6]
34187c10:	b2da      	uxtb	r2, r3
34187c12:	8979      	ldrh	r1, [r7, #10]
34187c14:	4b20      	ldr	r3, [pc, #128]	@ (34187c98 <I2C_RequestMemoryRead+0xa4>)
34187c16:	9300      	str	r3, [sp, #0]
34187c18:	2300      	movs	r3, #0
34187c1a:	68f8      	ldr	r0, [r7, #12]
34187c1c:	f000 fa26 	bl	3418806c <I2C_TransferConfig>

  /* Wait until TXIS flag is set */
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
34187c20:	69fa      	ldr	r2, [r7, #28]
34187c22:	69b9      	ldr	r1, [r7, #24]
34187c24:	68f8      	ldr	r0, [r7, #12]
34187c26:	f000 f8b6 	bl	34187d96 <I2C_WaitOnTXISFlagUntilTimeout>
34187c2a:	4603      	mov	r3, r0
34187c2c:	2b00      	cmp	r3, #0
34187c2e:	d001      	beq.n	34187c34 <I2C_RequestMemoryRead+0x40>
  {
    return HAL_ERROR;
34187c30:	2301      	movs	r3, #1
34187c32:	e02c      	b.n	34187c8e <I2C_RequestMemoryRead+0x9a>
  }

  /* If Memory address size is 8Bit */
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
34187c34:	88fb      	ldrh	r3, [r7, #6]
34187c36:	2b01      	cmp	r3, #1
34187c38:	d105      	bne.n	34187c46 <I2C_RequestMemoryRead+0x52>
  {
    /* Send Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
34187c3a:	893b      	ldrh	r3, [r7, #8]
34187c3c:	b2da      	uxtb	r2, r3
34187c3e:	68fb      	ldr	r3, [r7, #12]
34187c40:	681b      	ldr	r3, [r3, #0]
34187c42:	629a      	str	r2, [r3, #40]	@ 0x28
34187c44:	e015      	b.n	34187c72 <I2C_RequestMemoryRead+0x7e>
  }
  /* If Memory address size is 16Bit */
  else
  {
    /* Send MSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
34187c46:	893b      	ldrh	r3, [r7, #8]
34187c48:	0a1b      	lsrs	r3, r3, #8
34187c4a:	b29b      	uxth	r3, r3
34187c4c:	b2da      	uxtb	r2, r3
34187c4e:	68fb      	ldr	r3, [r7, #12]
34187c50:	681b      	ldr	r3, [r3, #0]
34187c52:	629a      	str	r2, [r3, #40]	@ 0x28

    /* Wait until TXIS flag is set */
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
34187c54:	69fa      	ldr	r2, [r7, #28]
34187c56:	69b9      	ldr	r1, [r7, #24]
34187c58:	68f8      	ldr	r0, [r7, #12]
34187c5a:	f000 f89c 	bl	34187d96 <I2C_WaitOnTXISFlagUntilTimeout>
34187c5e:	4603      	mov	r3, r0
34187c60:	2b00      	cmp	r3, #0
34187c62:	d001      	beq.n	34187c68 <I2C_RequestMemoryRead+0x74>
    {
      return HAL_ERROR;
34187c64:	2301      	movs	r3, #1
34187c66:	e012      	b.n	34187c8e <I2C_RequestMemoryRead+0x9a>
    }

    /* Send LSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
34187c68:	893b      	ldrh	r3, [r7, #8]
34187c6a:	b2da      	uxtb	r2, r3
34187c6c:	68fb      	ldr	r3, [r7, #12]
34187c6e:	681b      	ldr	r3, [r3, #0]
34187c70:	629a      	str	r2, [r3, #40]	@ 0x28
  }

  /* Wait until TC flag is set */
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TC, RESET, Timeout, Tickstart) != HAL_OK)
34187c72:	69fb      	ldr	r3, [r7, #28]
34187c74:	9300      	str	r3, [sp, #0]
34187c76:	69bb      	ldr	r3, [r7, #24]
34187c78:	2200      	movs	r2, #0
34187c7a:	2140      	movs	r1, #64	@ 0x40
34187c7c:	68f8      	ldr	r0, [r7, #12]
34187c7e:	f000 f831 	bl	34187ce4 <I2C_WaitOnFlagUntilTimeout>
34187c82:	4603      	mov	r3, r0
34187c84:	2b00      	cmp	r3, #0
34187c86:	d001      	beq.n	34187c8c <I2C_RequestMemoryRead+0x98>
  {
    return HAL_ERROR;
34187c88:	2301      	movs	r3, #1
34187c8a:	e000      	b.n	34187c8e <I2C_RequestMemoryRead+0x9a>
  }

  return HAL_OK;
34187c8c:	2300      	movs	r3, #0
}
34187c8e:	4618      	mov	r0, r3
34187c90:	3710      	adds	r7, #16
34187c92:	46bd      	mov	sp, r7
34187c94:	bd80      	pop	{r7, pc}
34187c96:	bf00      	nop
34187c98:	80002000 	.word	0x80002000

34187c9c <I2C_Flush_TXDR>:
  * @brief  I2C Tx data register flush process.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)
{
34187c9c:	b480      	push	{r7}
34187c9e:	b083      	sub	sp, #12
34187ca0:	af00      	add	r7, sp, #0
34187ca2:	6078      	str	r0, [r7, #4]
  /* If a pending TXIS flag is set */
  /* Write a dummy data in TXDR to clear it */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
34187ca4:	687b      	ldr	r3, [r7, #4]
34187ca6:	681b      	ldr	r3, [r3, #0]
34187ca8:	699b      	ldr	r3, [r3, #24]
34187caa:	f003 0302 	and.w	r3, r3, #2
34187cae:	2b02      	cmp	r3, #2
34187cb0:	d103      	bne.n	34187cba <I2C_Flush_TXDR+0x1e>
  {
    hi2c->Instance->TXDR = 0x00U;
34187cb2:	687b      	ldr	r3, [r7, #4]
34187cb4:	681b      	ldr	r3, [r3, #0]
34187cb6:	2200      	movs	r2, #0
34187cb8:	629a      	str	r2, [r3, #40]	@ 0x28
  }

  /* Flush TX register if not empty */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
34187cba:	687b      	ldr	r3, [r7, #4]
34187cbc:	681b      	ldr	r3, [r3, #0]
34187cbe:	699b      	ldr	r3, [r3, #24]
34187cc0:	f003 0301 	and.w	r3, r3, #1
34187cc4:	2b01      	cmp	r3, #1
34187cc6:	d007      	beq.n	34187cd8 <I2C_Flush_TXDR+0x3c>
  {
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
34187cc8:	687b      	ldr	r3, [r7, #4]
34187cca:	681b      	ldr	r3, [r3, #0]
34187ccc:	699a      	ldr	r2, [r3, #24]
34187cce:	687b      	ldr	r3, [r7, #4]
34187cd0:	681b      	ldr	r3, [r3, #0]
34187cd2:	f042 0201 	orr.w	r2, r2, #1
34187cd6:	619a      	str	r2, [r3, #24]
  }
}
34187cd8:	bf00      	nop
34187cda:	370c      	adds	r7, #12
34187cdc:	46bd      	mov	sp, r7
34187cde:	f85d 7b04 	ldr.w	r7, [sp], #4
34187ce2:	4770      	bx	lr

34187ce4 <I2C_WaitOnFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status,
                                                    uint32_t Timeout, uint32_t Tickstart)
{
34187ce4:	b580      	push	{r7, lr}
34187ce6:	b084      	sub	sp, #16
34187ce8:	af00      	add	r7, sp, #0
34187cea:	60f8      	str	r0, [r7, #12]
34187cec:	60b9      	str	r1, [r7, #8]
34187cee:	603b      	str	r3, [r7, #0]
34187cf0:	4613      	mov	r3, r2
34187cf2:	71fb      	strb	r3, [r7, #7]
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
34187cf4:	e03b      	b.n	34187d6e <I2C_WaitOnFlagUntilTimeout+0x8a>
  {
    /* Check if an error is detected */
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
34187cf6:	69ba      	ldr	r2, [r7, #24]
34187cf8:	6839      	ldr	r1, [r7, #0]
34187cfa:	68f8      	ldr	r0, [r7, #12]
34187cfc:	f000 f8d6 	bl	34187eac <I2C_IsErrorOccurred>
34187d00:	4603      	mov	r3, r0
34187d02:	2b00      	cmp	r3, #0
34187d04:	d001      	beq.n	34187d0a <I2C_WaitOnFlagUntilTimeout+0x26>
    {
      return HAL_ERROR;
34187d06:	2301      	movs	r3, #1
34187d08:	e041      	b.n	34187d8e <I2C_WaitOnFlagUntilTimeout+0xaa>
    }

    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
34187d0a:	683b      	ldr	r3, [r7, #0]
34187d0c:	f1b3 3fff 	cmp.w	r3, #4294967295
34187d10:	d02d      	beq.n	34187d6e <I2C_WaitOnFlagUntilTimeout+0x8a>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
34187d12:	f7fd fc51 	bl	341855b8 <HAL_GetTick>
34187d16:	4602      	mov	r2, r0
34187d18:	69bb      	ldr	r3, [r7, #24]
34187d1a:	1ad3      	subs	r3, r2, r3
34187d1c:	683a      	ldr	r2, [r7, #0]
34187d1e:	429a      	cmp	r2, r3
34187d20:	d302      	bcc.n	34187d28 <I2C_WaitOnFlagUntilTimeout+0x44>
34187d22:	683b      	ldr	r3, [r7, #0]
34187d24:	2b00      	cmp	r3, #0
34187d26:	d122      	bne.n	34187d6e <I2C_WaitOnFlagUntilTimeout+0x8a>
      {
        if (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
34187d28:	68fb      	ldr	r3, [r7, #12]
34187d2a:	681b      	ldr	r3, [r3, #0]
34187d2c:	699a      	ldr	r2, [r3, #24]
34187d2e:	68bb      	ldr	r3, [r7, #8]
34187d30:	4013      	ands	r3, r2
34187d32:	68ba      	ldr	r2, [r7, #8]
34187d34:	429a      	cmp	r2, r3
34187d36:	bf0c      	ite	eq
34187d38:	2301      	moveq	r3, #1
34187d3a:	2300      	movne	r3, #0
34187d3c:	b2db      	uxtb	r3, r3
34187d3e:	461a      	mov	r2, r3
34187d40:	79fb      	ldrb	r3, [r7, #7]
34187d42:	429a      	cmp	r2, r3
34187d44:	d113      	bne.n	34187d6e <I2C_WaitOnFlagUntilTimeout+0x8a>
        {
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
34187d46:	68fb      	ldr	r3, [r7, #12]
34187d48:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34187d4a:	f043 0220 	orr.w	r2, r3, #32
34187d4e:	68fb      	ldr	r3, [r7, #12]
34187d50:	645a      	str	r2, [r3, #68]	@ 0x44
          hi2c->State = HAL_I2C_STATE_READY;
34187d52:	68fb      	ldr	r3, [r7, #12]
34187d54:	2220      	movs	r2, #32
34187d56:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
          hi2c->Mode = HAL_I2C_MODE_NONE;
34187d5a:	68fb      	ldr	r3, [r7, #12]
34187d5c:	2200      	movs	r2, #0
34187d5e:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
34187d62:	68fb      	ldr	r3, [r7, #12]
34187d64:	2200      	movs	r2, #0
34187d66:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
          return HAL_ERROR;
34187d6a:	2301      	movs	r3, #1
34187d6c:	e00f      	b.n	34187d8e <I2C_WaitOnFlagUntilTimeout+0xaa>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
34187d6e:	68fb      	ldr	r3, [r7, #12]
34187d70:	681b      	ldr	r3, [r3, #0]
34187d72:	699a      	ldr	r2, [r3, #24]
34187d74:	68bb      	ldr	r3, [r7, #8]
34187d76:	4013      	ands	r3, r2
34187d78:	68ba      	ldr	r2, [r7, #8]
34187d7a:	429a      	cmp	r2, r3
34187d7c:	bf0c      	ite	eq
34187d7e:	2301      	moveq	r3, #1
34187d80:	2300      	movne	r3, #0
34187d82:	b2db      	uxtb	r3, r3
34187d84:	461a      	mov	r2, r3
34187d86:	79fb      	ldrb	r3, [r7, #7]
34187d88:	429a      	cmp	r2, r3
34187d8a:	d0b4      	beq.n	34187cf6 <I2C_WaitOnFlagUntilTimeout+0x12>
        }
      }
    }
  }
  return HAL_OK;
34187d8c:	2300      	movs	r3, #0
}
34187d8e:	4618      	mov	r0, r3
34187d90:	3710      	adds	r7, #16
34187d92:	46bd      	mov	sp, r7
34187d94:	bd80      	pop	{r7, pc}

34187d96 <I2C_WaitOnTXISFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout,
                                                        uint32_t Tickstart)
{
34187d96:	b580      	push	{r7, lr}
34187d98:	b084      	sub	sp, #16
34187d9a:	af00      	add	r7, sp, #0
34187d9c:	60f8      	str	r0, [r7, #12]
34187d9e:	60b9      	str	r1, [r7, #8]
34187da0:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
34187da2:	e033      	b.n	34187e0c <I2C_WaitOnTXISFlagUntilTimeout+0x76>
  {
    /* Check if an error is detected */
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
34187da4:	687a      	ldr	r2, [r7, #4]
34187da6:	68b9      	ldr	r1, [r7, #8]
34187da8:	68f8      	ldr	r0, [r7, #12]
34187daa:	f000 f87f 	bl	34187eac <I2C_IsErrorOccurred>
34187dae:	4603      	mov	r3, r0
34187db0:	2b00      	cmp	r3, #0
34187db2:	d001      	beq.n	34187db8 <I2C_WaitOnTXISFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
34187db4:	2301      	movs	r3, #1
34187db6:	e031      	b.n	34187e1c <I2C_WaitOnTXISFlagUntilTimeout+0x86>
    }

    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
34187db8:	68bb      	ldr	r3, [r7, #8]
34187dba:	f1b3 3fff 	cmp.w	r3, #4294967295
34187dbe:	d025      	beq.n	34187e0c <I2C_WaitOnTXISFlagUntilTimeout+0x76>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
34187dc0:	f7fd fbfa 	bl	341855b8 <HAL_GetTick>
34187dc4:	4602      	mov	r2, r0
34187dc6:	687b      	ldr	r3, [r7, #4]
34187dc8:	1ad3      	subs	r3, r2, r3
34187dca:	68ba      	ldr	r2, [r7, #8]
34187dcc:	429a      	cmp	r2, r3
34187dce:	d302      	bcc.n	34187dd6 <I2C_WaitOnTXISFlagUntilTimeout+0x40>
34187dd0:	68bb      	ldr	r3, [r7, #8]
34187dd2:	2b00      	cmp	r3, #0
34187dd4:	d11a      	bne.n	34187e0c <I2C_WaitOnTXISFlagUntilTimeout+0x76>
      {
        if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
34187dd6:	68fb      	ldr	r3, [r7, #12]
34187dd8:	681b      	ldr	r3, [r3, #0]
34187dda:	699b      	ldr	r3, [r3, #24]
34187ddc:	f003 0302 	and.w	r3, r3, #2
34187de0:	2b02      	cmp	r3, #2
34187de2:	d013      	beq.n	34187e0c <I2C_WaitOnTXISFlagUntilTimeout+0x76>
        {
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
34187de4:	68fb      	ldr	r3, [r7, #12]
34187de6:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34187de8:	f043 0220 	orr.w	r2, r3, #32
34187dec:	68fb      	ldr	r3, [r7, #12]
34187dee:	645a      	str	r2, [r3, #68]	@ 0x44
          hi2c->State = HAL_I2C_STATE_READY;
34187df0:	68fb      	ldr	r3, [r7, #12]
34187df2:	2220      	movs	r2, #32
34187df4:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
          hi2c->Mode = HAL_I2C_MODE_NONE;
34187df8:	68fb      	ldr	r3, [r7, #12]
34187dfa:	2200      	movs	r2, #0
34187dfc:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
34187e00:	68fb      	ldr	r3, [r7, #12]
34187e02:	2200      	movs	r2, #0
34187e04:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

          return HAL_ERROR;
34187e08:	2301      	movs	r3, #1
34187e0a:	e007      	b.n	34187e1c <I2C_WaitOnTXISFlagUntilTimeout+0x86>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
34187e0c:	68fb      	ldr	r3, [r7, #12]
34187e0e:	681b      	ldr	r3, [r3, #0]
34187e10:	699b      	ldr	r3, [r3, #24]
34187e12:	f003 0302 	and.w	r3, r3, #2
34187e16:	2b02      	cmp	r3, #2
34187e18:	d1c4      	bne.n	34187da4 <I2C_WaitOnTXISFlagUntilTimeout+0xe>
        }
      }
    }
  }
  return HAL_OK;
34187e1a:	2300      	movs	r3, #0
}
34187e1c:	4618      	mov	r0, r3
34187e1e:	3710      	adds	r7, #16
34187e20:	46bd      	mov	sp, r7
34187e22:	bd80      	pop	{r7, pc}

34187e24 <I2C_WaitOnSTOPFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout,
                                                        uint32_t Tickstart)
{
34187e24:	b580      	push	{r7, lr}
34187e26:	b084      	sub	sp, #16
34187e28:	af00      	add	r7, sp, #0
34187e2a:	60f8      	str	r0, [r7, #12]
34187e2c:	60b9      	str	r1, [r7, #8]
34187e2e:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
34187e30:	e02f      	b.n	34187e92 <I2C_WaitOnSTOPFlagUntilTimeout+0x6e>
  {
    /* Check if an error is detected */
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
34187e32:	687a      	ldr	r2, [r7, #4]
34187e34:	68b9      	ldr	r1, [r7, #8]
34187e36:	68f8      	ldr	r0, [r7, #12]
34187e38:	f000 f838 	bl	34187eac <I2C_IsErrorOccurred>
34187e3c:	4603      	mov	r3, r0
34187e3e:	2b00      	cmp	r3, #0
34187e40:	d001      	beq.n	34187e46 <I2C_WaitOnSTOPFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
34187e42:	2301      	movs	r3, #1
34187e44:	e02d      	b.n	34187ea2 <I2C_WaitOnSTOPFlagUntilTimeout+0x7e>
    }

    /* Check for the Timeout */
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
34187e46:	f7fd fbb7 	bl	341855b8 <HAL_GetTick>
34187e4a:	4602      	mov	r2, r0
34187e4c:	687b      	ldr	r3, [r7, #4]
34187e4e:	1ad3      	subs	r3, r2, r3
34187e50:	68ba      	ldr	r2, [r7, #8]
34187e52:	429a      	cmp	r2, r3
34187e54:	d302      	bcc.n	34187e5c <I2C_WaitOnSTOPFlagUntilTimeout+0x38>
34187e56:	68bb      	ldr	r3, [r7, #8]
34187e58:	2b00      	cmp	r3, #0
34187e5a:	d11a      	bne.n	34187e92 <I2C_WaitOnSTOPFlagUntilTimeout+0x6e>
    {
      if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
34187e5c:	68fb      	ldr	r3, [r7, #12]
34187e5e:	681b      	ldr	r3, [r3, #0]
34187e60:	699b      	ldr	r3, [r3, #24]
34187e62:	f003 0320 	and.w	r3, r3, #32
34187e66:	2b20      	cmp	r3, #32
34187e68:	d013      	beq.n	34187e92 <I2C_WaitOnSTOPFlagUntilTimeout+0x6e>
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
34187e6a:	68fb      	ldr	r3, [r7, #12]
34187e6c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34187e6e:	f043 0220 	orr.w	r2, r3, #32
34187e72:	68fb      	ldr	r3, [r7, #12]
34187e74:	645a      	str	r2, [r3, #68]	@ 0x44
        hi2c->State = HAL_I2C_STATE_READY;
34187e76:	68fb      	ldr	r3, [r7, #12]
34187e78:	2220      	movs	r2, #32
34187e7a:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
34187e7e:	68fb      	ldr	r3, [r7, #12]
34187e80:	2200      	movs	r2, #0
34187e82:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
34187e86:	68fb      	ldr	r3, [r7, #12]
34187e88:	2200      	movs	r2, #0
34187e8a:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

        return HAL_ERROR;
34187e8e:	2301      	movs	r3, #1
34187e90:	e007      	b.n	34187ea2 <I2C_WaitOnSTOPFlagUntilTimeout+0x7e>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
34187e92:	68fb      	ldr	r3, [r7, #12]
34187e94:	681b      	ldr	r3, [r3, #0]
34187e96:	699b      	ldr	r3, [r3, #24]
34187e98:	f003 0320 	and.w	r3, r3, #32
34187e9c:	2b20      	cmp	r3, #32
34187e9e:	d1c8      	bne.n	34187e32 <I2C_WaitOnSTOPFlagUntilTimeout+0xe>
      }
    }
  }
  return HAL_OK;
34187ea0:	2300      	movs	r3, #0
}
34187ea2:	4618      	mov	r0, r3
34187ea4:	3710      	adds	r7, #16
34187ea6:	46bd      	mov	sp, r7
34187ea8:	bd80      	pop	{r7, pc}
	...

34187eac <I2C_IsErrorOccurred>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_IsErrorOccurred(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
34187eac:	b580      	push	{r7, lr}
34187eae:	b08a      	sub	sp, #40	@ 0x28
34187eb0:	af00      	add	r7, sp, #0
34187eb2:	60f8      	str	r0, [r7, #12]
34187eb4:	60b9      	str	r1, [r7, #8]
34187eb6:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
34187eb8:	2300      	movs	r3, #0
34187eba:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  uint32_t itflag   = hi2c->Instance->ISR;
34187ebe:	68fb      	ldr	r3, [r7, #12]
34187ec0:	681b      	ldr	r3, [r3, #0]
34187ec2:	699b      	ldr	r3, [r3, #24]
34187ec4:	61bb      	str	r3, [r7, #24]
  uint32_t error_code = 0;
34187ec6:	2300      	movs	r3, #0
34187ec8:	623b      	str	r3, [r7, #32]
  uint32_t tickstart = Tickstart;
34187eca:	687b      	ldr	r3, [r7, #4]
34187ecc:	61fb      	str	r3, [r7, #28]
  uint32_t tmp1;
  HAL_I2C_ModeTypeDef tmp2;

  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_AF))
34187ece:	69bb      	ldr	r3, [r7, #24]
34187ed0:	f003 0310 	and.w	r3, r3, #16
34187ed4:	2b00      	cmp	r3, #0
34187ed6:	d068      	beq.n	34187faa <I2C_IsErrorOccurred+0xfe>
  {
    /* Clear NACKF Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
34187ed8:	68fb      	ldr	r3, [r7, #12]
34187eda:	681b      	ldr	r3, [r3, #0]
34187edc:	2210      	movs	r2, #16
34187ede:	61da      	str	r2, [r3, #28]

    /* Wait until STOP Flag is set or timeout occurred */
    /* AutoEnd should be initiate after AF */
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
34187ee0:	e049      	b.n	34187f76 <I2C_IsErrorOccurred+0xca>
    {
      /* Check for the Timeout */
      if (Timeout != HAL_MAX_DELAY)
34187ee2:	68bb      	ldr	r3, [r7, #8]
34187ee4:	f1b3 3fff 	cmp.w	r3, #4294967295
34187ee8:	d045      	beq.n	34187f76 <I2C_IsErrorOccurred+0xca>
      {
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
34187eea:	f7fd fb65 	bl	341855b8 <HAL_GetTick>
34187eee:	4602      	mov	r2, r0
34187ef0:	69fb      	ldr	r3, [r7, #28]
34187ef2:	1ad3      	subs	r3, r2, r3
34187ef4:	68ba      	ldr	r2, [r7, #8]
34187ef6:	429a      	cmp	r2, r3
34187ef8:	d302      	bcc.n	34187f00 <I2C_IsErrorOccurred+0x54>
34187efa:	68bb      	ldr	r3, [r7, #8]
34187efc:	2b00      	cmp	r3, #0
34187efe:	d13a      	bne.n	34187f76 <I2C_IsErrorOccurred+0xca>
        {
          tmp1 = (uint32_t)(hi2c->Instance->CR2 & I2C_CR2_STOP);
34187f00:	68fb      	ldr	r3, [r7, #12]
34187f02:	681b      	ldr	r3, [r3, #0]
34187f04:	685b      	ldr	r3, [r3, #4]
34187f06:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
34187f0a:	617b      	str	r3, [r7, #20]
          tmp2 = hi2c->Mode;
34187f0c:	68fb      	ldr	r3, [r7, #12]
34187f0e:	f893 3042 	ldrb.w	r3, [r3, #66]	@ 0x42
34187f12:	74fb      	strb	r3, [r7, #19]

          /* In case of I2C still busy, try to regenerate a STOP manually */
          if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET) && \
34187f14:	68fb      	ldr	r3, [r7, #12]
34187f16:	681b      	ldr	r3, [r3, #0]
34187f18:	699b      	ldr	r3, [r3, #24]
34187f1a:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
34187f1e:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
34187f22:	d121      	bne.n	34187f68 <I2C_IsErrorOccurred+0xbc>
34187f24:	697b      	ldr	r3, [r7, #20]
34187f26:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
34187f2a:	d01d      	beq.n	34187f68 <I2C_IsErrorOccurred+0xbc>
              (tmp1 != I2C_CR2_STOP) && \
34187f2c:	7cfb      	ldrb	r3, [r7, #19]
34187f2e:	2b20      	cmp	r3, #32
34187f30:	d01a      	beq.n	34187f68 <I2C_IsErrorOccurred+0xbc>
              (tmp2 != HAL_I2C_MODE_SLAVE))
          {
            /* Generate Stop */
            hi2c->Instance->CR2 |= I2C_CR2_STOP;
34187f32:	68fb      	ldr	r3, [r7, #12]
34187f34:	681b      	ldr	r3, [r3, #0]
34187f36:	685a      	ldr	r2, [r3, #4]
34187f38:	68fb      	ldr	r3, [r7, #12]
34187f3a:	681b      	ldr	r3, [r3, #0]
34187f3c:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
34187f40:	605a      	str	r2, [r3, #4]

            /* Update Tick with new reference */
            tickstart = HAL_GetTick();
34187f42:	f7fd fb39 	bl	341855b8 <HAL_GetTick>
34187f46:	61f8      	str	r0, [r7, #28]
          }

          while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
34187f48:	e00e      	b.n	34187f68 <I2C_IsErrorOccurred+0xbc>
          {
            /* Check for the Timeout */
            if ((HAL_GetTick() - tickstart) > I2C_TIMEOUT_STOPF)
34187f4a:	f7fd fb35 	bl	341855b8 <HAL_GetTick>
34187f4e:	4602      	mov	r2, r0
34187f50:	69fb      	ldr	r3, [r7, #28]
34187f52:	1ad3      	subs	r3, r2, r3
34187f54:	2b19      	cmp	r3, #25
34187f56:	d907      	bls.n	34187f68 <I2C_IsErrorOccurred+0xbc>
            {
              error_code |= HAL_I2C_ERROR_TIMEOUT;
34187f58:	6a3b      	ldr	r3, [r7, #32]
34187f5a:	f043 0320 	orr.w	r3, r3, #32
34187f5e:	623b      	str	r3, [r7, #32]

              status = HAL_ERROR;
34187f60:	2301      	movs	r3, #1
34187f62:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27

              break;
34187f66:	e006      	b.n	34187f76 <I2C_IsErrorOccurred+0xca>
          while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
34187f68:	68fb      	ldr	r3, [r7, #12]
34187f6a:	681b      	ldr	r3, [r3, #0]
34187f6c:	699b      	ldr	r3, [r3, #24]
34187f6e:	f003 0320 	and.w	r3, r3, #32
34187f72:	2b20      	cmp	r3, #32
34187f74:	d1e9      	bne.n	34187f4a <I2C_IsErrorOccurred+0x9e>
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
34187f76:	68fb      	ldr	r3, [r7, #12]
34187f78:	681b      	ldr	r3, [r3, #0]
34187f7a:	699b      	ldr	r3, [r3, #24]
34187f7c:	f003 0320 	and.w	r3, r3, #32
34187f80:	2b20      	cmp	r3, #32
34187f82:	d003      	beq.n	34187f8c <I2C_IsErrorOccurred+0xe0>
34187f84:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
34187f88:	2b00      	cmp	r3, #0
34187f8a:	d0aa      	beq.n	34187ee2 <I2C_IsErrorOccurred+0x36>
        }
      }
    }

    /* In case STOP Flag is detected, clear it */
    if (status == HAL_OK)
34187f8c:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
34187f90:	2b00      	cmp	r3, #0
34187f92:	d103      	bne.n	34187f9c <I2C_IsErrorOccurred+0xf0>
    {
      /* Clear STOP Flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
34187f94:	68fb      	ldr	r3, [r7, #12]
34187f96:	681b      	ldr	r3, [r3, #0]
34187f98:	2220      	movs	r2, #32
34187f9a:	61da      	str	r2, [r3, #28]
    }

    error_code |= HAL_I2C_ERROR_AF;
34187f9c:	6a3b      	ldr	r3, [r7, #32]
34187f9e:	f043 0304 	orr.w	r3, r3, #4
34187fa2:	623b      	str	r3, [r7, #32]

    status = HAL_ERROR;
34187fa4:	2301      	movs	r3, #1
34187fa6:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  }

  /* Refresh Content of Status register */
  itflag = hi2c->Instance->ISR;
34187faa:	68fb      	ldr	r3, [r7, #12]
34187fac:	681b      	ldr	r3, [r3, #0]
34187fae:	699b      	ldr	r3, [r3, #24]
34187fb0:	61bb      	str	r3, [r7, #24]

  /* Then verify if an additional errors occurs */
  /* Check if a Bus error occurred */
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_BERR))
34187fb2:	69bb      	ldr	r3, [r7, #24]
34187fb4:	f403 7380 	and.w	r3, r3, #256	@ 0x100
34187fb8:	2b00      	cmp	r3, #0
34187fba:	d00b      	beq.n	34187fd4 <I2C_IsErrorOccurred+0x128>
  {
    error_code |= HAL_I2C_ERROR_BERR;
34187fbc:	6a3b      	ldr	r3, [r7, #32]
34187fbe:	f043 0301 	orr.w	r3, r3, #1
34187fc2:	623b      	str	r3, [r7, #32]

    /* Clear BERR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
34187fc4:	68fb      	ldr	r3, [r7, #12]
34187fc6:	681b      	ldr	r3, [r3, #0]
34187fc8:	f44f 7280 	mov.w	r2, #256	@ 0x100
34187fcc:	61da      	str	r2, [r3, #28]

    status = HAL_ERROR;
34187fce:	2301      	movs	r3, #1
34187fd0:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  }

  /* Check if an Over-Run/Under-Run error occurred */
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_OVR))
34187fd4:	69bb      	ldr	r3, [r7, #24]
34187fd6:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34187fda:	2b00      	cmp	r3, #0
34187fdc:	d00b      	beq.n	34187ff6 <I2C_IsErrorOccurred+0x14a>
  {
    error_code |= HAL_I2C_ERROR_OVR;
34187fde:	6a3b      	ldr	r3, [r7, #32]
34187fe0:	f043 0308 	orr.w	r3, r3, #8
34187fe4:	623b      	str	r3, [r7, #32]

    /* Clear OVR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
34187fe6:	68fb      	ldr	r3, [r7, #12]
34187fe8:	681b      	ldr	r3, [r3, #0]
34187fea:	f44f 6280 	mov.w	r2, #1024	@ 0x400
34187fee:	61da      	str	r2, [r3, #28]

    status = HAL_ERROR;
34187ff0:	2301      	movs	r3, #1
34187ff2:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  }

  /* Check if an Arbitration Loss error occurred */
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_ARLO))
34187ff6:	69bb      	ldr	r3, [r7, #24]
34187ff8:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34187ffc:	2b00      	cmp	r3, #0
34187ffe:	d00b      	beq.n	34188018 <I2C_IsErrorOccurred+0x16c>
  {
    error_code |= HAL_I2C_ERROR_ARLO;
34188000:	6a3b      	ldr	r3, [r7, #32]
34188002:	f043 0302 	orr.w	r3, r3, #2
34188006:	623b      	str	r3, [r7, #32]

    /* Clear ARLO flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
34188008:	68fb      	ldr	r3, [r7, #12]
3418800a:	681b      	ldr	r3, [r3, #0]
3418800c:	f44f 7200 	mov.w	r2, #512	@ 0x200
34188010:	61da      	str	r2, [r3, #28]

    status = HAL_ERROR;
34188012:	2301      	movs	r3, #1
34188014:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  }

  if (status != HAL_OK)
34188018:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3418801c:	2b00      	cmp	r3, #0
3418801e:	d01c      	beq.n	3418805a <I2C_IsErrorOccurred+0x1ae>
  {
    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);
34188020:	68f8      	ldr	r0, [r7, #12]
34188022:	f7ff fe3b 	bl	34187c9c <I2C_Flush_TXDR>

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
34188026:	68fb      	ldr	r3, [r7, #12]
34188028:	681b      	ldr	r3, [r3, #0]
3418802a:	6859      	ldr	r1, [r3, #4]
3418802c:	68fb      	ldr	r3, [r7, #12]
3418802e:	681a      	ldr	r2, [r3, #0]
34188030:	4b0d      	ldr	r3, [pc, #52]	@ (34188068 <I2C_IsErrorOccurred+0x1bc>)
34188032:	400b      	ands	r3, r1
34188034:	6053      	str	r3, [r2, #4]

    hi2c->ErrorCode |= error_code;
34188036:	68fb      	ldr	r3, [r7, #12]
34188038:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
3418803a:	6a3b      	ldr	r3, [r7, #32]
3418803c:	431a      	orrs	r2, r3
3418803e:	68fb      	ldr	r3, [r7, #12]
34188040:	645a      	str	r2, [r3, #68]	@ 0x44
    hi2c->State = HAL_I2C_STATE_READY;
34188042:	68fb      	ldr	r3, [r7, #12]
34188044:	2220      	movs	r2, #32
34188046:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
3418804a:	68fb      	ldr	r3, [r7, #12]
3418804c:	2200      	movs	r2, #0
3418804e:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
34188052:	68fb      	ldr	r3, [r7, #12]
34188054:	2200      	movs	r2, #0
34188056:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
  }

  return status;
3418805a:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
}
3418805e:	4618      	mov	r0, r3
34188060:	3728      	adds	r7, #40	@ 0x28
34188062:	46bd      	mov	sp, r7
34188064:	bd80      	pop	{r7, pc}
34188066:	bf00      	nop
34188068:	fe00e800 	.word	0xfe00e800

3418806c <I2C_TransferConfig>:
  *     @arg @ref I2C_GENERATE_START_WRITE Generate Restart for write request.
  * @retval None
  */
static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode,
                               uint32_t Request)
{
3418806c:	b480      	push	{r7}
3418806e:	b087      	sub	sp, #28
34188070:	af00      	add	r7, sp, #0
34188072:	60f8      	str	r0, [r7, #12]
34188074:	607b      	str	r3, [r7, #4]
34188076:	460b      	mov	r3, r1
34188078:	817b      	strh	r3, [r7, #10]
3418807a:	4613      	mov	r3, r2
3418807c:	727b      	strb	r3, [r7, #9]
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));

  /* Declaration of tmp to prevent undefined behavior of volatile usage */
  tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
3418807e:	897b      	ldrh	r3, [r7, #10]
34188080:	f3c3 0209 	ubfx	r2, r3, #0, #10
                    (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
34188084:	7a7b      	ldrb	r3, [r7, #9]
34188086:	041b      	lsls	r3, r3, #16
34188088:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
  tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
3418808c:	431a      	orrs	r2, r3
                    (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
3418808e:	687b      	ldr	r3, [r7, #4]
34188090:	431a      	orrs	r2, r3
  tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
34188092:	6a3b      	ldr	r3, [r7, #32]
34188094:	4313      	orrs	r3, r2
34188096:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
3418809a:	617b      	str	r3, [r7, #20]
                    (uint32_t)Mode | (uint32_t)Request) & (~0x80000000U));

  /* update CR2 register */
  MODIFY_REG(hi2c->Instance->CR2, \
3418809c:	68fb      	ldr	r3, [r7, #12]
3418809e:	681b      	ldr	r3, [r3, #0]
341880a0:	685a      	ldr	r2, [r3, #4]
341880a2:	6a3b      	ldr	r3, [r7, #32]
341880a4:	0d5b      	lsrs	r3, r3, #21
341880a6:	f403 6180 	and.w	r1, r3, #1024	@ 0x400
341880aa:	4b08      	ldr	r3, [pc, #32]	@ (341880cc <I2C_TransferConfig+0x60>)
341880ac:	430b      	orrs	r3, r1
341880ae:	43db      	mvns	r3, r3
341880b0:	ea02 0103 	and.w	r1, r2, r3
341880b4:	68fb      	ldr	r3, [r7, #12]
341880b6:	681b      	ldr	r3, [r3, #0]
341880b8:	697a      	ldr	r2, [r7, #20]
341880ba:	430a      	orrs	r2, r1
341880bc:	605a      	str	r2, [r3, #4]
             ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | \
               (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | \
               I2C_CR2_START | I2C_CR2_STOP)), tmp);
}
341880be:	bf00      	nop
341880c0:	371c      	adds	r7, #28
341880c2:	46bd      	mov	sp, r7
341880c4:	f85d 7b04 	ldr.w	r7, [sp], #4
341880c8:	4770      	bx	lr
341880ca:	bf00      	nop
341880cc:	03ff63ff 	.word	0x03ff63ff

341880d0 <HAL_I2CEx_ConfigAnalogFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  AnalogFilter New state of the Analog filter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigAnalogFilter(I2C_HandleTypeDef *hi2c, uint32_t AnalogFilter)
{
341880d0:	b480      	push	{r7}
341880d2:	b083      	sub	sp, #12
341880d4:	af00      	add	r7, sp, #0
341880d6:	6078      	str	r0, [r7, #4]
341880d8:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
341880da:	687b      	ldr	r3, [r7, #4]
341880dc:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
341880e0:	b2db      	uxtb	r3, r3
341880e2:	2b20      	cmp	r3, #32
341880e4:	d138      	bne.n	34188158 <HAL_I2CEx_ConfigAnalogFilter+0x88>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
341880e6:	687b      	ldr	r3, [r7, #4]
341880e8:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
341880ec:	2b01      	cmp	r3, #1
341880ee:	d101      	bne.n	341880f4 <HAL_I2CEx_ConfigAnalogFilter+0x24>
341880f0:	2302      	movs	r3, #2
341880f2:	e032      	b.n	3418815a <HAL_I2CEx_ConfigAnalogFilter+0x8a>
341880f4:	687b      	ldr	r3, [r7, #4]
341880f6:	2201      	movs	r2, #1
341880f8:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
341880fc:	687b      	ldr	r3, [r7, #4]
341880fe:	2224      	movs	r2, #36	@ 0x24
34188100:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
34188104:	687b      	ldr	r3, [r7, #4]
34188106:	681b      	ldr	r3, [r3, #0]
34188108:	681a      	ldr	r2, [r3, #0]
3418810a:	687b      	ldr	r3, [r7, #4]
3418810c:	681b      	ldr	r3, [r3, #0]
3418810e:	f022 0201 	bic.w	r2, r2, #1
34188112:	601a      	str	r2, [r3, #0]

    /* Reset I2Cx ANOFF bit */
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
34188114:	687b      	ldr	r3, [r7, #4]
34188116:	681b      	ldr	r3, [r3, #0]
34188118:	681a      	ldr	r2, [r3, #0]
3418811a:	687b      	ldr	r3, [r7, #4]
3418811c:	681b      	ldr	r3, [r3, #0]
3418811e:	f422 5280 	bic.w	r2, r2, #4096	@ 0x1000
34188122:	601a      	str	r2, [r3, #0]

    /* Set analog filter bit*/
    hi2c->Instance->CR1 |= AnalogFilter;
34188124:	687b      	ldr	r3, [r7, #4]
34188126:	681b      	ldr	r3, [r3, #0]
34188128:	6819      	ldr	r1, [r3, #0]
3418812a:	687b      	ldr	r3, [r7, #4]
3418812c:	681b      	ldr	r3, [r3, #0]
3418812e:	683a      	ldr	r2, [r7, #0]
34188130:	430a      	orrs	r2, r1
34188132:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
34188134:	687b      	ldr	r3, [r7, #4]
34188136:	681b      	ldr	r3, [r3, #0]
34188138:	681a      	ldr	r2, [r3, #0]
3418813a:	687b      	ldr	r3, [r7, #4]
3418813c:	681b      	ldr	r3, [r3, #0]
3418813e:	f042 0201 	orr.w	r2, r2, #1
34188142:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
34188144:	687b      	ldr	r3, [r7, #4]
34188146:	2220      	movs	r2, #32
34188148:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
3418814c:	687b      	ldr	r3, [r7, #4]
3418814e:	2200      	movs	r2, #0
34188150:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    return HAL_OK;
34188154:	2300      	movs	r3, #0
34188156:	e000      	b.n	3418815a <HAL_I2CEx_ConfigAnalogFilter+0x8a>
  }
  else
  {
    return HAL_BUSY;
34188158:	2302      	movs	r3, #2
  }
}
3418815a:	4618      	mov	r0, r3
3418815c:	370c      	adds	r7, #12
3418815e:	46bd      	mov	sp, r7
34188160:	f85d 7b04 	ldr.w	r7, [sp], #4
34188164:	4770      	bx	lr

34188166 <HAL_I2CEx_ConfigDigitalFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  DigitalFilter Coefficient of digital noise filter between Min_Data=0x00 and Max_Data=0x0F.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter)
{
34188166:	b480      	push	{r7}
34188168:	b085      	sub	sp, #20
3418816a:	af00      	add	r7, sp, #0
3418816c:	6078      	str	r0, [r7, #4]
3418816e:	6039      	str	r1, [r7, #0]

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
34188170:	687b      	ldr	r3, [r7, #4]
34188172:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
34188176:	b2db      	uxtb	r3, r3
34188178:	2b20      	cmp	r3, #32
3418817a:	d139      	bne.n	341881f0 <HAL_I2CEx_ConfigDigitalFilter+0x8a>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
3418817c:	687b      	ldr	r3, [r7, #4]
3418817e:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
34188182:	2b01      	cmp	r3, #1
34188184:	d101      	bne.n	3418818a <HAL_I2CEx_ConfigDigitalFilter+0x24>
34188186:	2302      	movs	r3, #2
34188188:	e033      	b.n	341881f2 <HAL_I2CEx_ConfigDigitalFilter+0x8c>
3418818a:	687b      	ldr	r3, [r7, #4]
3418818c:	2201      	movs	r2, #1
3418818e:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
34188192:	687b      	ldr	r3, [r7, #4]
34188194:	2224      	movs	r2, #36	@ 0x24
34188196:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
3418819a:	687b      	ldr	r3, [r7, #4]
3418819c:	681b      	ldr	r3, [r3, #0]
3418819e:	681a      	ldr	r2, [r3, #0]
341881a0:	687b      	ldr	r3, [r7, #4]
341881a2:	681b      	ldr	r3, [r3, #0]
341881a4:	f022 0201 	bic.w	r2, r2, #1
341881a8:	601a      	str	r2, [r3, #0]

    /* Get the old register value */
    tmpreg = hi2c->Instance->CR1;
341881aa:	687b      	ldr	r3, [r7, #4]
341881ac:	681b      	ldr	r3, [r3, #0]
341881ae:	681b      	ldr	r3, [r3, #0]
341881b0:	60fb      	str	r3, [r7, #12]

    /* Reset I2Cx DNF bits [11:8] */
    tmpreg &= ~(I2C_CR1_DNF);
341881b2:	68fb      	ldr	r3, [r7, #12]
341881b4:	f423 6370 	bic.w	r3, r3, #3840	@ 0xf00
341881b8:	60fb      	str	r3, [r7, #12]

    /* Set I2Cx DNF coefficient */
    tmpreg |= DigitalFilter << 8U;
341881ba:	683b      	ldr	r3, [r7, #0]
341881bc:	021b      	lsls	r3, r3, #8
341881be:	68fa      	ldr	r2, [r7, #12]
341881c0:	4313      	orrs	r3, r2
341881c2:	60fb      	str	r3, [r7, #12]

    /* Store the new register value */
    hi2c->Instance->CR1 = tmpreg;
341881c4:	687b      	ldr	r3, [r7, #4]
341881c6:	681b      	ldr	r3, [r3, #0]
341881c8:	68fa      	ldr	r2, [r7, #12]
341881ca:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
341881cc:	687b      	ldr	r3, [r7, #4]
341881ce:	681b      	ldr	r3, [r3, #0]
341881d0:	681a      	ldr	r2, [r3, #0]
341881d2:	687b      	ldr	r3, [r7, #4]
341881d4:	681b      	ldr	r3, [r3, #0]
341881d6:	f042 0201 	orr.w	r2, r2, #1
341881da:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
341881dc:	687b      	ldr	r3, [r7, #4]
341881de:	2220      	movs	r2, #32
341881e0:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
341881e4:	687b      	ldr	r3, [r7, #4]
341881e6:	2200      	movs	r2, #0
341881e8:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    return HAL_OK;
341881ec:	2300      	movs	r3, #0
341881ee:	e000      	b.n	341881f2 <HAL_I2CEx_ConfigDigitalFilter+0x8c>
  }
  else
  {
    return HAL_BUSY;
341881f0:	2302      	movs	r3, #2
  }
}
341881f2:	4618      	mov	r0, r3
341881f4:	3714      	adds	r7, #20
341881f6:	46bd      	mov	sp, r7
341881f8:	f85d 7b04 	ldr.w	r7, [sp], #4
341881fc:	4770      	bx	lr

341881fe <HAL_PCD_Init>:
  *         parameters in the PCD_InitTypeDef and initialize the associated handle.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
{
341881fe:	b580      	push	{r7, lr}
34188200:	b086      	sub	sp, #24
34188202:	af02      	add	r7, sp, #8
34188204:	6078      	str	r0, [r7, #4]
  uint8_t i;

  /* Check the PCD handle allocation */
  if (hpcd == NULL)
34188206:	687b      	ldr	r3, [r7, #4]
34188208:	2b00      	cmp	r3, #0
3418820a:	d101      	bne.n	34188210 <HAL_PCD_Init+0x12>
  {
    return HAL_ERROR;
3418820c:	2301      	movs	r3, #1
3418820e:	e0fe      	b.n	3418840e <HAL_PCD_Init+0x210>
  }

  /* Check the parameters */
  assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));

  if (hpcd->State == HAL_PCD_STATE_RESET)
34188210:	687b      	ldr	r3, [r7, #4]
34188212:	f893 3495 	ldrb.w	r3, [r3, #1173]	@ 0x495
34188216:	b2db      	uxtb	r3, r3
34188218:	2b00      	cmp	r3, #0
3418821a:	d106      	bne.n	3418822a <HAL_PCD_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hpcd->Lock = HAL_UNLOCKED;
3418821c:	687b      	ldr	r3, [r7, #4]
3418821e:	2200      	movs	r2, #0
34188220:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

    /* Init the low level hardware */
    hpcd->MspInitCallback(hpcd);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_PCD_MspInit(hpcd);
34188224:	6878      	ldr	r0, [r7, #4]
34188226:	f7f9 fa4d 	bl	341816c4 <HAL_PCD_MspInit>
#endif /* (USE_HAL_PCD_REGISTER_CALLBACKS) */
  }

  hpcd->State = HAL_PCD_STATE_BUSY;
3418822a:	687b      	ldr	r3, [r7, #4]
3418822c:	2203      	movs	r2, #3
3418822e:	f883 2495 	strb.w	r2, [r3, #1173]	@ 0x495

  /* Disable the Interrupts */
  __HAL_PCD_DISABLE(hpcd);
34188232:	687b      	ldr	r3, [r7, #4]
34188234:	681b      	ldr	r3, [r3, #0]
34188236:	4618      	mov	r0, r3
34188238:	f00a f873 	bl	34192322 <USB_DisableGlobalInt>

  /*Init the Core (common init.) */
  if (USB_CoreInit(hpcd->Instance, hpcd->Init) != HAL_OK)
3418823c:	687b      	ldr	r3, [r7, #4]
3418823e:	6818      	ldr	r0, [r3, #0]
34188240:	687b      	ldr	r3, [r7, #4]
34188242:	7c1a      	ldrb	r2, [r3, #16]
34188244:	f88d 2000 	strb.w	r2, [sp]
34188248:	3304      	adds	r3, #4
3418824a:	cb0e      	ldmia	r3, {r1, r2, r3}
3418824c:	f009 ff83 	bl	34192156 <USB_CoreInit>
34188250:	4603      	mov	r3, r0
34188252:	2b00      	cmp	r3, #0
34188254:	d005      	beq.n	34188262 <HAL_PCD_Init+0x64>
  {
    hpcd->State = HAL_PCD_STATE_ERROR;
34188256:	687b      	ldr	r3, [r7, #4]
34188258:	2202      	movs	r2, #2
3418825a:	f883 2495 	strb.w	r2, [r3, #1173]	@ 0x495
    return HAL_ERROR;
3418825e:	2301      	movs	r3, #1
34188260:	e0d5      	b.n	3418840e <HAL_PCD_Init+0x210>
  }

  /* Force Device Mode */
  if (USB_SetCurrentMode(hpcd->Instance, USB_DEVICE_MODE) != HAL_OK)
34188262:	687b      	ldr	r3, [r7, #4]
34188264:	681b      	ldr	r3, [r3, #0]
34188266:	2100      	movs	r1, #0
34188268:	4618      	mov	r0, r3
3418826a:	f00a f86b 	bl	34192344 <USB_SetCurrentMode>
3418826e:	4603      	mov	r3, r0
34188270:	2b00      	cmp	r3, #0
34188272:	d005      	beq.n	34188280 <HAL_PCD_Init+0x82>
  {
    hpcd->State = HAL_PCD_STATE_ERROR;
34188274:	687b      	ldr	r3, [r7, #4]
34188276:	2202      	movs	r2, #2
34188278:	f883 2495 	strb.w	r2, [r3, #1173]	@ 0x495
    return HAL_ERROR;
3418827c:	2301      	movs	r3, #1
3418827e:	e0c6      	b.n	3418840e <HAL_PCD_Init+0x210>
  }

  /* Init endpoints structures */
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
34188280:	2300      	movs	r3, #0
34188282:	73fb      	strb	r3, [r7, #15]
34188284:	e04a      	b.n	3418831c <HAL_PCD_Init+0x11e>
  {
    /* Init ep structure */
    hpcd->IN_ep[i].is_in = 1U;
34188286:	7bfa      	ldrb	r2, [r7, #15]
34188288:	6879      	ldr	r1, [r7, #4]
3418828a:	4613      	mov	r3, r2
3418828c:	00db      	lsls	r3, r3, #3
3418828e:	4413      	add	r3, r2
34188290:	009b      	lsls	r3, r3, #2
34188292:	440b      	add	r3, r1
34188294:	3315      	adds	r3, #21
34188296:	2201      	movs	r2, #1
34188298:	701a      	strb	r2, [r3, #0]
    hpcd->IN_ep[i].num = i;
3418829a:	7bfa      	ldrb	r2, [r7, #15]
3418829c:	6879      	ldr	r1, [r7, #4]
3418829e:	4613      	mov	r3, r2
341882a0:	00db      	lsls	r3, r3, #3
341882a2:	4413      	add	r3, r2
341882a4:	009b      	lsls	r3, r3, #2
341882a6:	440b      	add	r3, r1
341882a8:	3314      	adds	r3, #20
341882aa:	7bfa      	ldrb	r2, [r7, #15]
341882ac:	701a      	strb	r2, [r3, #0]
    hpcd->IN_ep[i].tx_fifo_num = i;
341882ae:	7bfa      	ldrb	r2, [r7, #15]
341882b0:	7bfb      	ldrb	r3, [r7, #15]
341882b2:	b298      	uxth	r0, r3
341882b4:	6879      	ldr	r1, [r7, #4]
341882b6:	4613      	mov	r3, r2
341882b8:	00db      	lsls	r3, r3, #3
341882ba:	4413      	add	r3, r2
341882bc:	009b      	lsls	r3, r3, #2
341882be:	440b      	add	r3, r1
341882c0:	332e      	adds	r3, #46	@ 0x2e
341882c2:	4602      	mov	r2, r0
341882c4:	801a      	strh	r2, [r3, #0]
    /* Control until ep is activated */
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
341882c6:	7bfa      	ldrb	r2, [r7, #15]
341882c8:	6879      	ldr	r1, [r7, #4]
341882ca:	4613      	mov	r3, r2
341882cc:	00db      	lsls	r3, r3, #3
341882ce:	4413      	add	r3, r2
341882d0:	009b      	lsls	r3, r3, #2
341882d2:	440b      	add	r3, r1
341882d4:	3318      	adds	r3, #24
341882d6:	2200      	movs	r2, #0
341882d8:	701a      	strb	r2, [r3, #0]
    hpcd->IN_ep[i].maxpacket = 0U;
341882da:	7bfa      	ldrb	r2, [r7, #15]
341882dc:	6879      	ldr	r1, [r7, #4]
341882de:	4613      	mov	r3, r2
341882e0:	00db      	lsls	r3, r3, #3
341882e2:	4413      	add	r3, r2
341882e4:	009b      	lsls	r3, r3, #2
341882e6:	440b      	add	r3, r1
341882e8:	331c      	adds	r3, #28
341882ea:	2200      	movs	r2, #0
341882ec:	601a      	str	r2, [r3, #0]
    hpcd->IN_ep[i].xfer_buff = 0U;
341882ee:	7bfa      	ldrb	r2, [r7, #15]
341882f0:	6879      	ldr	r1, [r7, #4]
341882f2:	4613      	mov	r3, r2
341882f4:	00db      	lsls	r3, r3, #3
341882f6:	4413      	add	r3, r2
341882f8:	009b      	lsls	r3, r3, #2
341882fa:	440b      	add	r3, r1
341882fc:	3320      	adds	r3, #32
341882fe:	2200      	movs	r2, #0
34188300:	601a      	str	r2, [r3, #0]
    hpcd->IN_ep[i].xfer_len = 0U;
34188302:	7bfa      	ldrb	r2, [r7, #15]
34188304:	6879      	ldr	r1, [r7, #4]
34188306:	4613      	mov	r3, r2
34188308:	00db      	lsls	r3, r3, #3
3418830a:	4413      	add	r3, r2
3418830c:	009b      	lsls	r3, r3, #2
3418830e:	440b      	add	r3, r1
34188310:	3324      	adds	r3, #36	@ 0x24
34188312:	2200      	movs	r2, #0
34188314:	601a      	str	r2, [r3, #0]
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
34188316:	7bfb      	ldrb	r3, [r7, #15]
34188318:	3301      	adds	r3, #1
3418831a:	73fb      	strb	r3, [r7, #15]
3418831c:	687b      	ldr	r3, [r7, #4]
3418831e:	791b      	ldrb	r3, [r3, #4]
34188320:	7bfa      	ldrb	r2, [r7, #15]
34188322:	429a      	cmp	r2, r3
34188324:	d3af      	bcc.n	34188286 <HAL_PCD_Init+0x88>
  }

  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
34188326:	2300      	movs	r3, #0
34188328:	73fb      	strb	r3, [r7, #15]
3418832a:	e044      	b.n	341883b6 <HAL_PCD_Init+0x1b8>
  {
    hpcd->OUT_ep[i].is_in = 0U;
3418832c:	7bfa      	ldrb	r2, [r7, #15]
3418832e:	6879      	ldr	r1, [r7, #4]
34188330:	4613      	mov	r3, r2
34188332:	00db      	lsls	r3, r3, #3
34188334:	4413      	add	r3, r2
34188336:	009b      	lsls	r3, r3, #2
34188338:	440b      	add	r3, r1
3418833a:	f203 2355 	addw	r3, r3, #597	@ 0x255
3418833e:	2200      	movs	r2, #0
34188340:	701a      	strb	r2, [r3, #0]
    hpcd->OUT_ep[i].num = i;
34188342:	7bfa      	ldrb	r2, [r7, #15]
34188344:	6879      	ldr	r1, [r7, #4]
34188346:	4613      	mov	r3, r2
34188348:	00db      	lsls	r3, r3, #3
3418834a:	4413      	add	r3, r2
3418834c:	009b      	lsls	r3, r3, #2
3418834e:	440b      	add	r3, r1
34188350:	f503 7315 	add.w	r3, r3, #596	@ 0x254
34188354:	7bfa      	ldrb	r2, [r7, #15]
34188356:	701a      	strb	r2, [r3, #0]
    /* Control until ep is activated */
    hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
34188358:	7bfa      	ldrb	r2, [r7, #15]
3418835a:	6879      	ldr	r1, [r7, #4]
3418835c:	4613      	mov	r3, r2
3418835e:	00db      	lsls	r3, r3, #3
34188360:	4413      	add	r3, r2
34188362:	009b      	lsls	r3, r3, #2
34188364:	440b      	add	r3, r1
34188366:	f503 7316 	add.w	r3, r3, #600	@ 0x258
3418836a:	2200      	movs	r2, #0
3418836c:	701a      	strb	r2, [r3, #0]
    hpcd->OUT_ep[i].maxpacket = 0U;
3418836e:	7bfa      	ldrb	r2, [r7, #15]
34188370:	6879      	ldr	r1, [r7, #4]
34188372:	4613      	mov	r3, r2
34188374:	00db      	lsls	r3, r3, #3
34188376:	4413      	add	r3, r2
34188378:	009b      	lsls	r3, r3, #2
3418837a:	440b      	add	r3, r1
3418837c:	f503 7317 	add.w	r3, r3, #604	@ 0x25c
34188380:	2200      	movs	r2, #0
34188382:	601a      	str	r2, [r3, #0]
    hpcd->OUT_ep[i].xfer_buff = 0U;
34188384:	7bfa      	ldrb	r2, [r7, #15]
34188386:	6879      	ldr	r1, [r7, #4]
34188388:	4613      	mov	r3, r2
3418838a:	00db      	lsls	r3, r3, #3
3418838c:	4413      	add	r3, r2
3418838e:	009b      	lsls	r3, r3, #2
34188390:	440b      	add	r3, r1
34188392:	f503 7318 	add.w	r3, r3, #608	@ 0x260
34188396:	2200      	movs	r2, #0
34188398:	601a      	str	r2, [r3, #0]
    hpcd->OUT_ep[i].xfer_len = 0U;
3418839a:	7bfa      	ldrb	r2, [r7, #15]
3418839c:	6879      	ldr	r1, [r7, #4]
3418839e:	4613      	mov	r3, r2
341883a0:	00db      	lsls	r3, r3, #3
341883a2:	4413      	add	r3, r2
341883a4:	009b      	lsls	r3, r3, #2
341883a6:	440b      	add	r3, r1
341883a8:	f503 7319 	add.w	r3, r3, #612	@ 0x264
341883ac:	2200      	movs	r2, #0
341883ae:	601a      	str	r2, [r3, #0]
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
341883b0:	7bfb      	ldrb	r3, [r7, #15]
341883b2:	3301      	adds	r3, #1
341883b4:	73fb      	strb	r3, [r7, #15]
341883b6:	687b      	ldr	r3, [r7, #4]
341883b8:	791b      	ldrb	r3, [r3, #4]
341883ba:	7bfa      	ldrb	r2, [r7, #15]
341883bc:	429a      	cmp	r2, r3
341883be:	d3b5      	bcc.n	3418832c <HAL_PCD_Init+0x12e>
  }

  /* Init Device */
  if (USB_DevInit(hpcd->Instance, hpcd->Init) != HAL_OK)
341883c0:	687b      	ldr	r3, [r7, #4]
341883c2:	6818      	ldr	r0, [r3, #0]
341883c4:	687b      	ldr	r3, [r7, #4]
341883c6:	7c1a      	ldrb	r2, [r3, #16]
341883c8:	f88d 2000 	strb.w	r2, [sp]
341883cc:	3304      	adds	r3, #4
341883ce:	cb0e      	ldmia	r3, {r1, r2, r3}
341883d0:	f00a f804 	bl	341923dc <USB_DevInit>
341883d4:	4603      	mov	r3, r0
341883d6:	2b00      	cmp	r3, #0
341883d8:	d005      	beq.n	341883e6 <HAL_PCD_Init+0x1e8>
  {
    hpcd->State = HAL_PCD_STATE_ERROR;
341883da:	687b      	ldr	r3, [r7, #4]
341883dc:	2202      	movs	r2, #2
341883de:	f883 2495 	strb.w	r2, [r3, #1173]	@ 0x495
    return HAL_ERROR;
341883e2:	2301      	movs	r3, #1
341883e4:	e013      	b.n	3418840e <HAL_PCD_Init+0x210>
  }

  hpcd->USB_Address = 0U;
341883e6:	687b      	ldr	r3, [r7, #4]
341883e8:	2200      	movs	r2, #0
341883ea:	745a      	strb	r2, [r3, #17]
  hpcd->State = HAL_PCD_STATE_READY;
341883ec:	687b      	ldr	r3, [r7, #4]
341883ee:	2201      	movs	r2, #1
341883f0:	f883 2495 	strb.w	r2, [r3, #1173]	@ 0x495

  /* Activate LPM */
  if (hpcd->Init.lpm_enable == 1U)
341883f4:	687b      	ldr	r3, [r7, #4]
341883f6:	7b1b      	ldrb	r3, [r3, #12]
341883f8:	2b01      	cmp	r3, #1
341883fa:	d102      	bne.n	34188402 <HAL_PCD_Init+0x204>
  {
    (void)HAL_PCDEx_ActivateLPM(hpcd);
341883fc:	6878      	ldr	r0, [r7, #4]
341883fe:	f001 f9c9 	bl	34189794 <HAL_PCDEx_ActivateLPM>
  }

  (void)USB_DevDisconnect(hpcd->Instance);
34188402:	687b      	ldr	r3, [r7, #4]
34188404:	681b      	ldr	r3, [r3, #0]
34188406:	4618      	mov	r0, r3
34188408:	f00b f847 	bl	3419349a <USB_DevDisconnect>

  return HAL_OK;
3418840c:	2300      	movs	r3, #0
}
3418840e:	4618      	mov	r0, r3
34188410:	3710      	adds	r7, #16
34188412:	46bd      	mov	sp, r7
34188414:	bd80      	pop	{r7, pc}

34188416 <HAL_PCD_Start>:
  * @brief  Start the USB device
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
{
34188416:	b580      	push	{r7, lr}
34188418:	b082      	sub	sp, #8
3418841a:	af00      	add	r7, sp, #0
3418841c:	6078      	str	r0, [r7, #4]
  __HAL_LOCK(hpcd);
3418841e:	687b      	ldr	r3, [r7, #4]
34188420:	f893 3494 	ldrb.w	r3, [r3, #1172]	@ 0x494
34188424:	2b01      	cmp	r3, #1
34188426:	d101      	bne.n	3418842c <HAL_PCD_Start+0x16>
34188428:	2302      	movs	r3, #2
3418842a:	e012      	b.n	34188452 <HAL_PCD_Start+0x3c>
3418842c:	687b      	ldr	r3, [r7, #4]
3418842e:	2201      	movs	r2, #1
34188430:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494
  __HAL_PCD_ENABLE(hpcd);
34188434:	687b      	ldr	r3, [r7, #4]
34188436:	681b      	ldr	r3, [r3, #0]
34188438:	4618      	mov	r0, r3
3418843a:	f009 ff61 	bl	34192300 <USB_EnableGlobalInt>
  (void)USB_DevConnect(hpcd->Instance);
3418843e:	687b      	ldr	r3, [r7, #4]
34188440:	681b      	ldr	r3, [r3, #0]
34188442:	4618      	mov	r0, r3
34188444:	f00b f808 	bl	34193458 <USB_DevConnect>
  __HAL_UNLOCK(hpcd);
34188448:	687b      	ldr	r3, [r7, #4]
3418844a:	2200      	movs	r2, #0
3418844c:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  return HAL_OK;
34188450:	2300      	movs	r3, #0
}
34188452:	4618      	mov	r0, r3
34188454:	3708      	adds	r7, #8
34188456:	46bd      	mov	sp, r7
34188458:	bd80      	pop	{r7, pc}

3418845a <HAL_PCD_Stop>:
  * @brief  Stop the USB device.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Stop(PCD_HandleTypeDef *hpcd)
{
3418845a:	b580      	push	{r7, lr}
3418845c:	b082      	sub	sp, #8
3418845e:	af00      	add	r7, sp, #0
34188460:	6078      	str	r0, [r7, #4]
  __HAL_LOCK(hpcd);
34188462:	687b      	ldr	r3, [r7, #4]
34188464:	f893 3494 	ldrb.w	r3, [r3, #1172]	@ 0x494
34188468:	2b01      	cmp	r3, #1
3418846a:	d101      	bne.n	34188470 <HAL_PCD_Stop+0x16>
3418846c:	2302      	movs	r3, #2
3418846e:	e018      	b.n	341884a2 <HAL_PCD_Stop+0x48>
34188470:	687b      	ldr	r3, [r7, #4]
34188472:	2201      	movs	r2, #1
34188474:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494
  __HAL_PCD_DISABLE(hpcd);
34188478:	687b      	ldr	r3, [r7, #4]
3418847a:	681b      	ldr	r3, [r3, #0]
3418847c:	4618      	mov	r0, r3
3418847e:	f009 ff50 	bl	34192322 <USB_DisableGlobalInt>
  (void)USB_DevDisconnect(hpcd->Instance);
34188482:	687b      	ldr	r3, [r7, #4]
34188484:	681b      	ldr	r3, [r3, #0]
34188486:	4618      	mov	r0, r3
34188488:	f00b f807 	bl	3419349a <USB_DevDisconnect>

  (void)USB_FlushTxFifo(hpcd->Instance, 0x10U);
3418848c:	687b      	ldr	r3, [r7, #4]
3418848e:	681b      	ldr	r3, [r3, #0]
34188490:	2110      	movs	r1, #16
34188492:	4618      	mov	r0, r3
34188494:	f00a f906 	bl	341926a4 <USB_FlushTxFifo>
  __HAL_UNLOCK(hpcd);
34188498:	687b      	ldr	r3, [r7, #4]
3418849a:	2200      	movs	r2, #0
3418849c:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  return HAL_OK;
341884a0:	2300      	movs	r3, #0
}
341884a2:	4618      	mov	r0, r3
341884a4:	3708      	adds	r7, #8
341884a6:	46bd      	mov	sp, r7
341884a8:	bd80      	pop	{r7, pc}

341884aa <HAL_PCD_IRQHandler>:
  * @brief  Handles PCD interrupt request.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
341884aa:	b590      	push	{r4, r7, lr}
341884ac:	b08d      	sub	sp, #52	@ 0x34
341884ae:	af00      	add	r7, sp, #0
341884b0:	6078      	str	r0, [r7, #4]
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
341884b2:	687b      	ldr	r3, [r7, #4]
341884b4:	681b      	ldr	r3, [r3, #0]
341884b6:	623b      	str	r3, [r7, #32]
  uint32_t USBx_BASE = (uint32_t)USBx;
341884b8:	6a3b      	ldr	r3, [r7, #32]
341884ba:	61fb      	str	r3, [r7, #28]
  uint32_t epnum;
  uint32_t fifoemptymsk;
  uint32_t RegVal;

  /* ensure that we are in device mode */
  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
341884bc:	687b      	ldr	r3, [r7, #4]
341884be:	681b      	ldr	r3, [r3, #0]
341884c0:	4618      	mov	r0, r3
341884c2:	f00b f89e 	bl	34193602 <USB_GetMode>
341884c6:	4603      	mov	r3, r0
341884c8:	2b00      	cmp	r3, #0
341884ca:	f040 84b9 	bne.w	34188e40 <HAL_PCD_IRQHandler+0x996>
  {
    /* avoid spurious interrupt */
    if (__HAL_PCD_IS_INVALID_INTERRUPT(hpcd))
341884ce:	687b      	ldr	r3, [r7, #4]
341884d0:	681b      	ldr	r3, [r3, #0]
341884d2:	4618      	mov	r0, r3
341884d4:	f00b f802 	bl	341934dc <USB_ReadInterrupts>
341884d8:	4603      	mov	r3, r0
341884da:	2b00      	cmp	r3, #0
341884dc:	f000 84af 	beq.w	34188e3e <HAL_PCD_IRQHandler+0x994>
    {
      return;
    }

    /* store current frame number */
    hpcd->FrameNumber = (USBx_DEVICE->DSTS & USB_OTG_DSTS_FNSOF_Msk) >> USB_OTG_DSTS_FNSOF_Pos;
341884e0:	69fb      	ldr	r3, [r7, #28]
341884e2:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
341884e6:	689b      	ldr	r3, [r3, #8]
341884e8:	0a1b      	lsrs	r3, r3, #8
341884ea:	f3c3 020d 	ubfx	r2, r3, #0, #14
341884ee:	687b      	ldr	r3, [r7, #4]
341884f0:	f8c3 24d4 	str.w	r2, [r3, #1236]	@ 0x4d4

    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
341884f4:	687b      	ldr	r3, [r7, #4]
341884f6:	681b      	ldr	r3, [r3, #0]
341884f8:	4618      	mov	r0, r3
341884fa:	f00a ffef 	bl	341934dc <USB_ReadInterrupts>
341884fe:	4603      	mov	r3, r0
34188500:	f003 0302 	and.w	r3, r3, #2
34188504:	2b02      	cmp	r3, #2
34188506:	d107      	bne.n	34188518 <HAL_PCD_IRQHandler+0x6e>
    {
      /* incorrect mode, acknowledge the interrupt */
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
34188508:	687b      	ldr	r3, [r7, #4]
3418850a:	681b      	ldr	r3, [r3, #0]
3418850c:	695a      	ldr	r2, [r3, #20]
3418850e:	687b      	ldr	r3, [r7, #4]
34188510:	681b      	ldr	r3, [r3, #0]
34188512:	f002 0202 	and.w	r2, r2, #2
34188516:	615a      	str	r2, [r3, #20]
    }

    /* Handle RxQLevel Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_RXFLVL))
34188518:	687b      	ldr	r3, [r7, #4]
3418851a:	681b      	ldr	r3, [r3, #0]
3418851c:	4618      	mov	r0, r3
3418851e:	f00a ffdd 	bl	341934dc <USB_ReadInterrupts>
34188522:	4603      	mov	r3, r0
34188524:	f003 0310 	and.w	r3, r3, #16
34188528:	2b10      	cmp	r3, #16
3418852a:	d161      	bne.n	341885f0 <HAL_PCD_IRQHandler+0x146>
    {
      USB_MASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
3418852c:	687b      	ldr	r3, [r7, #4]
3418852e:	681b      	ldr	r3, [r3, #0]
34188530:	699a      	ldr	r2, [r3, #24]
34188532:	687b      	ldr	r3, [r7, #4]
34188534:	681b      	ldr	r3, [r3, #0]
34188536:	f022 0210 	bic.w	r2, r2, #16
3418853a:	619a      	str	r2, [r3, #24]

      RegVal = USBx->GRXSTSP;
3418853c:	6a3b      	ldr	r3, [r7, #32]
3418853e:	6a1b      	ldr	r3, [r3, #32]
34188540:	61bb      	str	r3, [r7, #24]

      ep = &hpcd->OUT_ep[RegVal & USB_OTG_GRXSTSP_EPNUM];
34188542:	69bb      	ldr	r3, [r7, #24]
34188544:	f003 020f 	and.w	r2, r3, #15
34188548:	4613      	mov	r3, r2
3418854a:	00db      	lsls	r3, r3, #3
3418854c:	4413      	add	r3, r2
3418854e:	009b      	lsls	r3, r3, #2
34188550:	f503 7314 	add.w	r3, r3, #592	@ 0x250
34188554:	687a      	ldr	r2, [r7, #4]
34188556:	4413      	add	r3, r2
34188558:	3304      	adds	r3, #4
3418855a:	617b      	str	r3, [r7, #20]

      if (((RegVal & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_DATA_UPDT)
3418855c:	69bb      	ldr	r3, [r7, #24]
3418855e:	f403 13f0 	and.w	r3, r3, #1966080	@ 0x1e0000
34188562:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
34188566:	d124      	bne.n	341885b2 <HAL_PCD_IRQHandler+0x108>
      {
        if ((RegVal & USB_OTG_GRXSTSP_BCNT) != 0U)
34188568:	69ba      	ldr	r2, [r7, #24]
3418856a:	f647 73f0 	movw	r3, #32752	@ 0x7ff0
3418856e:	4013      	ands	r3, r2
34188570:	2b00      	cmp	r3, #0
34188572:	d035      	beq.n	341885e0 <HAL_PCD_IRQHandler+0x136>
        {
          (void)USB_ReadPacket(USBx, ep->xfer_buff,
34188574:	697b      	ldr	r3, [r7, #20]
34188576:	68d9      	ldr	r1, [r3, #12]
                               (uint16_t)((RegVal & USB_OTG_GRXSTSP_BCNT) >> 4));
34188578:	69bb      	ldr	r3, [r7, #24]
3418857a:	091b      	lsrs	r3, r3, #4
3418857c:	b29b      	uxth	r3, r3
          (void)USB_ReadPacket(USBx, ep->xfer_buff,
3418857e:	f3c3 030a 	ubfx	r3, r3, #0, #11
34188582:	b29b      	uxth	r3, r3
34188584:	461a      	mov	r2, r3
34188586:	6a38      	ldr	r0, [r7, #32]
34188588:	f00a fe14 	bl	341931b4 <USB_ReadPacket>

          ep->xfer_buff += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
3418858c:	697b      	ldr	r3, [r7, #20]
3418858e:	68da      	ldr	r2, [r3, #12]
34188590:	69bb      	ldr	r3, [r7, #24]
34188592:	091b      	lsrs	r3, r3, #4
34188594:	f3c3 030a 	ubfx	r3, r3, #0, #11
34188598:	441a      	add	r2, r3
3418859a:	697b      	ldr	r3, [r7, #20]
3418859c:	60da      	str	r2, [r3, #12]
          ep->xfer_count += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
3418859e:	697b      	ldr	r3, [r7, #20]
341885a0:	695a      	ldr	r2, [r3, #20]
341885a2:	69bb      	ldr	r3, [r7, #24]
341885a4:	091b      	lsrs	r3, r3, #4
341885a6:	f3c3 030a 	ubfx	r3, r3, #0, #11
341885aa:	441a      	add	r2, r3
341885ac:	697b      	ldr	r3, [r7, #20]
341885ae:	615a      	str	r2, [r3, #20]
341885b0:	e016      	b.n	341885e0 <HAL_PCD_IRQHandler+0x136>
        }
      }
      else if (((RegVal & USB_OTG_GRXSTSP_PKTSTS) >> 17) == STS_SETUP_UPDT)
341885b2:	69bb      	ldr	r3, [r7, #24]
341885b4:	f403 13f0 	and.w	r3, r3, #1966080	@ 0x1e0000
341885b8:	f5b3 2f40 	cmp.w	r3, #786432	@ 0xc0000
341885bc:	d110      	bne.n	341885e0 <HAL_PCD_IRQHandler+0x136>
      {
        (void)USB_ReadPacket(USBx, (uint8_t *)hpcd->Setup, 8U);
341885be:	687b      	ldr	r3, [r7, #4]
341885c0:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
341885c4:	2208      	movs	r2, #8
341885c6:	4619      	mov	r1, r3
341885c8:	6a38      	ldr	r0, [r7, #32]
341885ca:	f00a fdf3 	bl	341931b4 <USB_ReadPacket>
        ep->xfer_count += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
341885ce:	697b      	ldr	r3, [r7, #20]
341885d0:	695a      	ldr	r2, [r3, #20]
341885d2:	69bb      	ldr	r3, [r7, #24]
341885d4:	091b      	lsrs	r3, r3, #4
341885d6:	f3c3 030a 	ubfx	r3, r3, #0, #11
341885da:	441a      	add	r2, r3
341885dc:	697b      	ldr	r3, [r7, #20]
341885de:	615a      	str	r2, [r3, #20]
      else
      {
        /* ... */
      }

      USB_UNMASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
341885e0:	687b      	ldr	r3, [r7, #4]
341885e2:	681b      	ldr	r3, [r3, #0]
341885e4:	699a      	ldr	r2, [r3, #24]
341885e6:	687b      	ldr	r3, [r7, #4]
341885e8:	681b      	ldr	r3, [r3, #0]
341885ea:	f042 0210 	orr.w	r2, r2, #16
341885ee:	619a      	str	r2, [r3, #24]
    }

    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
341885f0:	687b      	ldr	r3, [r7, #4]
341885f2:	681b      	ldr	r3, [r3, #0]
341885f4:	4618      	mov	r0, r3
341885f6:	f00a ff71 	bl	341934dc <USB_ReadInterrupts>
341885fa:	4603      	mov	r3, r0
341885fc:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
34188600:	f5b3 2f00 	cmp.w	r3, #524288	@ 0x80000
34188604:	f040 80a7 	bne.w	34188756 <HAL_PCD_IRQHandler+0x2ac>
    {
      epnum = 0U;
34188608:	2300      	movs	r3, #0
3418860a:	627b      	str	r3, [r7, #36]	@ 0x24

      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
3418860c:	687b      	ldr	r3, [r7, #4]
3418860e:	681b      	ldr	r3, [r3, #0]
34188610:	4618      	mov	r0, r3
34188612:	f00a ff76 	bl	34193502 <USB_ReadDevAllOutEpInterrupt>
34188616:	62b8      	str	r0, [r7, #40]	@ 0x28

      while (ep_intr != 0U)
34188618:	e099      	b.n	3418874e <HAL_PCD_IRQHandler+0x2a4>
      {
        if ((ep_intr & 0x1U) != 0U)
3418861a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418861c:	f003 0301 	and.w	r3, r3, #1
34188620:	2b00      	cmp	r3, #0
34188622:	f000 808e 	beq.w	34188742 <HAL_PCD_IRQHandler+0x298>
        {
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, (uint8_t)epnum);
34188626:	687b      	ldr	r3, [r7, #4]
34188628:	681b      	ldr	r3, [r3, #0]
3418862a:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
3418862c:	b2d2      	uxtb	r2, r2
3418862e:	4611      	mov	r1, r2
34188630:	4618      	mov	r0, r3
34188632:	f00a ff9a 	bl	3419356a <USB_ReadDevOutEPInterrupt>
34188636:	6138      	str	r0, [r7, #16]

          if ((epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
34188638:	693b      	ldr	r3, [r7, #16]
3418863a:	f003 0301 	and.w	r3, r3, #1
3418863e:	2b00      	cmp	r3, #0
34188640:	d00c      	beq.n	3418865c <HAL_PCD_IRQHandler+0x1b2>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
34188642:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34188644:	015a      	lsls	r2, r3, #5
34188646:	69fb      	ldr	r3, [r7, #28]
34188648:	4413      	add	r3, r2
3418864a:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
3418864e:	461a      	mov	r2, r3
34188650:	2301      	movs	r3, #1
34188652:	6093      	str	r3, [r2, #8]
            (void)PCD_EP_OutXfrComplete_int(hpcd, epnum);
34188654:	6a79      	ldr	r1, [r7, #36]	@ 0x24
34188656:	6878      	ldr	r0, [r7, #4]
34188658:	f000 ff16 	bl	34189488 <PCD_EP_OutXfrComplete_int>
          }

          if ((epint & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP)
3418865c:	693b      	ldr	r3, [r7, #16]
3418865e:	f003 0308 	and.w	r3, r3, #8
34188662:	2b00      	cmp	r3, #0
34188664:	d00c      	beq.n	34188680 <HAL_PCD_IRQHandler+0x1d6>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STUP);
34188666:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34188668:	015a      	lsls	r2, r3, #5
3418866a:	69fb      	ldr	r3, [r7, #28]
3418866c:	4413      	add	r3, r2
3418866e:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
34188672:	461a      	mov	r2, r3
34188674:	2308      	movs	r3, #8
34188676:	6093      	str	r3, [r2, #8]
            /* Class B setup phase done for previous decoded setup */
            (void)PCD_EP_OutSetupPacket_int(hpcd, epnum);
34188678:	6a79      	ldr	r1, [r7, #36]	@ 0x24
3418867a:	6878      	ldr	r0, [r7, #4]
3418867c:	f000 ffec 	bl	34189658 <PCD_EP_OutSetupPacket_int>
          }

          if ((epint & USB_OTG_DOEPINT_OTEPDIS) == USB_OTG_DOEPINT_OTEPDIS)
34188680:	693b      	ldr	r3, [r7, #16]
34188682:	f003 0310 	and.w	r3, r3, #16
34188686:	2b00      	cmp	r3, #0
34188688:	d008      	beq.n	3418869c <HAL_PCD_IRQHandler+0x1f2>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPDIS);
3418868a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3418868c:	015a      	lsls	r2, r3, #5
3418868e:	69fb      	ldr	r3, [r7, #28]
34188690:	4413      	add	r3, r2
34188692:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
34188696:	461a      	mov	r2, r3
34188698:	2310      	movs	r3, #16
3418869a:	6093      	str	r3, [r2, #8]
          }

          /* Clear OUT Endpoint disable interrupt */
          if ((epint & USB_OTG_DOEPINT_EPDISD) == USB_OTG_DOEPINT_EPDISD)
3418869c:	693b      	ldr	r3, [r7, #16]
3418869e:	f003 0302 	and.w	r3, r3, #2
341886a2:	2b00      	cmp	r3, #0
341886a4:	d030      	beq.n	34188708 <HAL_PCD_IRQHandler+0x25e>
          {
            if ((USBx->GINTSTS & USB_OTG_GINTSTS_BOUTNAKEFF) == USB_OTG_GINTSTS_BOUTNAKEFF)
341886a6:	6a3b      	ldr	r3, [r7, #32]
341886a8:	695b      	ldr	r3, [r3, #20]
341886aa:	f003 0380 	and.w	r3, r3, #128	@ 0x80
341886ae:	2b80      	cmp	r3, #128	@ 0x80
341886b0:	d109      	bne.n	341886c6 <HAL_PCD_IRQHandler+0x21c>
            {
              USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGONAK;
341886b2:	69fb      	ldr	r3, [r7, #28]
341886b4:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
341886b8:	685b      	ldr	r3, [r3, #4]
341886ba:	69fa      	ldr	r2, [r7, #28]
341886bc:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
341886c0:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
341886c4:	6053      	str	r3, [r2, #4]
            }

            ep = &hpcd->OUT_ep[epnum];
341886c6:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
341886c8:	4613      	mov	r3, r2
341886ca:	00db      	lsls	r3, r3, #3
341886cc:	4413      	add	r3, r2
341886ce:	009b      	lsls	r3, r3, #2
341886d0:	f503 7314 	add.w	r3, r3, #592	@ 0x250
341886d4:	687a      	ldr	r2, [r7, #4]
341886d6:	4413      	add	r3, r2
341886d8:	3304      	adds	r3, #4
341886da:	617b      	str	r3, [r7, #20]

            if (ep->is_iso_incomplete == 1U)
341886dc:	697b      	ldr	r3, [r7, #20]
341886de:	78db      	ldrb	r3, [r3, #3]
341886e0:	2b01      	cmp	r3, #1
341886e2:	d108      	bne.n	341886f6 <HAL_PCD_IRQHandler+0x24c>
            {
              ep->is_iso_incomplete = 0U;
341886e4:	697b      	ldr	r3, [r7, #20]
341886e6:	2200      	movs	r2, #0
341886e8:	70da      	strb	r2, [r3, #3]

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
              hpcd->ISOOUTIncompleteCallback(hpcd, (uint8_t)epnum);
#else
              HAL_PCD_ISOOUTIncompleteCallback(hpcd, (uint8_t)epnum);
341886ea:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
341886ec:	b2db      	uxtb	r3, r3
341886ee:	4619      	mov	r1, r3
341886f0:	6878      	ldr	r0, [r7, #4]
341886f2:	f000 fba8 	bl	34188e46 <HAL_PCD_ISOOUTIncompleteCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
            }

            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_EPDISD);
341886f6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
341886f8:	015a      	lsls	r2, r3, #5
341886fa:	69fb      	ldr	r3, [r7, #28]
341886fc:	4413      	add	r3, r2
341886fe:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
34188702:	461a      	mov	r2, r3
34188704:	2302      	movs	r3, #2
34188706:	6093      	str	r3, [r2, #8]
          }

          /* Clear Status Phase Received interrupt */
          if ((epint & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR)
34188708:	693b      	ldr	r3, [r7, #16]
3418870a:	f003 0320 	and.w	r3, r3, #32
3418870e:	2b00      	cmp	r3, #0
34188710:	d008      	beq.n	34188724 <HAL_PCD_IRQHandler+0x27a>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
34188712:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34188714:	015a      	lsls	r2, r3, #5
34188716:	69fb      	ldr	r3, [r7, #28]
34188718:	4413      	add	r3, r2
3418871a:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
3418871e:	461a      	mov	r2, r3
34188720:	2320      	movs	r3, #32
34188722:	6093      	str	r3, [r2, #8]
          }

          /* Clear OUT NAK interrupt */
          if ((epint & USB_OTG_DOEPINT_NAK) == USB_OTG_DOEPINT_NAK)
34188724:	693b      	ldr	r3, [r7, #16]
34188726:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
3418872a:	2b00      	cmp	r3, #0
3418872c:	d009      	beq.n	34188742 <HAL_PCD_IRQHandler+0x298>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_NAK);
3418872e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34188730:	015a      	lsls	r2, r3, #5
34188732:	69fb      	ldr	r3, [r7, #28]
34188734:	4413      	add	r3, r2
34188736:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
3418873a:	461a      	mov	r2, r3
3418873c:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
34188740:	6093      	str	r3, [r2, #8]
          }
        }
        epnum++;
34188742:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34188744:	3301      	adds	r3, #1
34188746:	627b      	str	r3, [r7, #36]	@ 0x24
        ep_intr >>= 1U;
34188748:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418874a:	085b      	lsrs	r3, r3, #1
3418874c:	62bb      	str	r3, [r7, #40]	@ 0x28
      while (ep_intr != 0U)
3418874e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34188750:	2b00      	cmp	r3, #0
34188752:	f47f af62 	bne.w	3418861a <HAL_PCD_IRQHandler+0x170>
      }
    }

    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IEPINT))
34188756:	687b      	ldr	r3, [r7, #4]
34188758:	681b      	ldr	r3, [r3, #0]
3418875a:	4618      	mov	r0, r3
3418875c:	f00a febe 	bl	341934dc <USB_ReadInterrupts>
34188760:	4603      	mov	r3, r0
34188762:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
34188766:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
3418876a:	f040 80db 	bne.w	34188924 <HAL_PCD_IRQHandler+0x47a>
    {
      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllInEpInterrupt(hpcd->Instance);
3418876e:	687b      	ldr	r3, [r7, #4]
34188770:	681b      	ldr	r3, [r3, #0]
34188772:	4618      	mov	r0, r3
34188774:	f00a fedf 	bl	34193536 <USB_ReadDevAllInEpInterrupt>
34188778:	62b8      	str	r0, [r7, #40]	@ 0x28

      epnum = 0U;
3418877a:	2300      	movs	r3, #0
3418877c:	627b      	str	r3, [r7, #36]	@ 0x24

      while (ep_intr != 0U)
3418877e:	e0cd      	b.n	3418891c <HAL_PCD_IRQHandler+0x472>
      {
        if ((ep_intr & 0x1U) != 0U) /* In ITR */
34188780:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34188782:	f003 0301 	and.w	r3, r3, #1
34188786:	2b00      	cmp	r3, #0
34188788:	f000 80c2 	beq.w	34188910 <HAL_PCD_IRQHandler+0x466>
        {
          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, (uint8_t)epnum);
3418878c:	687b      	ldr	r3, [r7, #4]
3418878e:	681b      	ldr	r3, [r3, #0]
34188790:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
34188792:	b2d2      	uxtb	r2, r2
34188794:	4611      	mov	r1, r2
34188796:	4618      	mov	r0, r3
34188798:	f00a ff05 	bl	341935a6 <USB_ReadDevInEPInterrupt>
3418879c:	6138      	str	r0, [r7, #16]

          if ((epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
3418879e:	693b      	ldr	r3, [r7, #16]
341887a0:	f003 0301 	and.w	r3, r3, #1
341887a4:	2b00      	cmp	r3, #0
341887a6:	d057      	beq.n	34188858 <HAL_PCD_IRQHandler+0x3ae>
          {
            fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
341887a8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
341887aa:	f003 030f 	and.w	r3, r3, #15
341887ae:	2201      	movs	r2, #1
341887b0:	fa02 f303 	lsl.w	r3, r2, r3
341887b4:	60fb      	str	r3, [r7, #12]
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
341887b6:	69fb      	ldr	r3, [r7, #28]
341887b8:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
341887bc:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
341887be:	68fb      	ldr	r3, [r7, #12]
341887c0:	43db      	mvns	r3, r3
341887c2:	69f9      	ldr	r1, [r7, #28]
341887c4:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
341887c8:	4013      	ands	r3, r2
341887ca:	634b      	str	r3, [r1, #52]	@ 0x34

            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_XFRC);
341887cc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
341887ce:	015a      	lsls	r2, r3, #5
341887d0:	69fb      	ldr	r3, [r7, #28]
341887d2:	4413      	add	r3, r2
341887d4:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
341887d8:	461a      	mov	r2, r3
341887da:	2301      	movs	r3, #1
341887dc:	6093      	str	r3, [r2, #8]

            if (hpcd->Init.dma_enable == 1U)
341887de:	687b      	ldr	r3, [r7, #4]
341887e0:	799b      	ldrb	r3, [r3, #6]
341887e2:	2b01      	cmp	r3, #1
341887e4:	d132      	bne.n	3418884c <HAL_PCD_IRQHandler+0x3a2>
            {
              hpcd->IN_ep[epnum].xfer_buff += hpcd->IN_ep[epnum].maxpacket;
341887e6:	6879      	ldr	r1, [r7, #4]
341887e8:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
341887ea:	4613      	mov	r3, r2
341887ec:	00db      	lsls	r3, r3, #3
341887ee:	4413      	add	r3, r2
341887f0:	009b      	lsls	r3, r3, #2
341887f2:	440b      	add	r3, r1
341887f4:	3320      	adds	r3, #32
341887f6:	6819      	ldr	r1, [r3, #0]
341887f8:	6878      	ldr	r0, [r7, #4]
341887fa:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
341887fc:	4613      	mov	r3, r2
341887fe:	00db      	lsls	r3, r3, #3
34188800:	4413      	add	r3, r2
34188802:	009b      	lsls	r3, r3, #2
34188804:	4403      	add	r3, r0
34188806:	331c      	adds	r3, #28
34188808:	681b      	ldr	r3, [r3, #0]
3418880a:	4419      	add	r1, r3
3418880c:	6878      	ldr	r0, [r7, #4]
3418880e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
34188810:	4613      	mov	r3, r2
34188812:	00db      	lsls	r3, r3, #3
34188814:	4413      	add	r3, r2
34188816:	009b      	lsls	r3, r3, #2
34188818:	4403      	add	r3, r0
3418881a:	3320      	adds	r3, #32
3418881c:	6019      	str	r1, [r3, #0]

              /* this is ZLP, so prepare EP0 for next setup */
              if ((epnum == 0U) && (hpcd->IN_ep[epnum].xfer_len == 0U))
3418881e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34188820:	2b00      	cmp	r3, #0
34188822:	d113      	bne.n	3418884c <HAL_PCD_IRQHandler+0x3a2>
34188824:	6879      	ldr	r1, [r7, #4]
34188826:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
34188828:	4613      	mov	r3, r2
3418882a:	00db      	lsls	r3, r3, #3
3418882c:	4413      	add	r3, r2
3418882e:	009b      	lsls	r3, r3, #2
34188830:	440b      	add	r3, r1
34188832:	3324      	adds	r3, #36	@ 0x24
34188834:	681b      	ldr	r3, [r3, #0]
34188836:	2b00      	cmp	r3, #0
34188838:	d108      	bne.n	3418884c <HAL_PCD_IRQHandler+0x3a2>
              {
                /* prepare to rx more setup packets */
                (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
3418883a:	687b      	ldr	r3, [r7, #4]
3418883c:	6818      	ldr	r0, [r3, #0]
3418883e:	687b      	ldr	r3, [r7, #4]
34188840:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
34188844:	461a      	mov	r2, r3
34188846:	2101      	movs	r1, #1
34188848:	f00a ff0c 	bl	34193664 <USB_EP0_OutStart>
            }

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
            hpcd->DataInStageCallback(hpcd, (uint8_t)epnum);
#else
            HAL_PCD_DataInStageCallback(hpcd, (uint8_t)epnum);
3418884c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3418884e:	b2db      	uxtb	r3, r3
34188850:	4619      	mov	r1, r3
34188852:	6878      	ldr	r0, [r7, #4]
34188854:	f014 fe3c 	bl	3419d4d0 <HAL_PCD_DataInStageCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
          }
          if ((epint & USB_OTG_DIEPINT_TOC) == USB_OTG_DIEPINT_TOC)
34188858:	693b      	ldr	r3, [r7, #16]
3418885a:	f003 0308 	and.w	r3, r3, #8
3418885e:	2b00      	cmp	r3, #0
34188860:	d008      	beq.n	34188874 <HAL_PCD_IRQHandler+0x3ca>
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_TOC);
34188862:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34188864:	015a      	lsls	r2, r3, #5
34188866:	69fb      	ldr	r3, [r7, #28]
34188868:	4413      	add	r3, r2
3418886a:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
3418886e:	461a      	mov	r2, r3
34188870:	2308      	movs	r3, #8
34188872:	6093      	str	r3, [r2, #8]
          }
          if ((epint & USB_OTG_DIEPINT_ITTXFE) == USB_OTG_DIEPINT_ITTXFE)
34188874:	693b      	ldr	r3, [r7, #16]
34188876:	f003 0310 	and.w	r3, r3, #16
3418887a:	2b00      	cmp	r3, #0
3418887c:	d008      	beq.n	34188890 <HAL_PCD_IRQHandler+0x3e6>
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_ITTXFE);
3418887e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34188880:	015a      	lsls	r2, r3, #5
34188882:	69fb      	ldr	r3, [r7, #28]
34188884:	4413      	add	r3, r2
34188886:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
3418888a:	461a      	mov	r2, r3
3418888c:	2310      	movs	r3, #16
3418888e:	6093      	str	r3, [r2, #8]
          }
          if ((epint & USB_OTG_DIEPINT_INEPNE) == USB_OTG_DIEPINT_INEPNE)
34188890:	693b      	ldr	r3, [r7, #16]
34188892:	f003 0340 	and.w	r3, r3, #64	@ 0x40
34188896:	2b00      	cmp	r3, #0
34188898:	d008      	beq.n	341888ac <HAL_PCD_IRQHandler+0x402>
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_INEPNE);
3418889a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3418889c:	015a      	lsls	r2, r3, #5
3418889e:	69fb      	ldr	r3, [r7, #28]
341888a0:	4413      	add	r3, r2
341888a2:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
341888a6:	461a      	mov	r2, r3
341888a8:	2340      	movs	r3, #64	@ 0x40
341888aa:	6093      	str	r3, [r2, #8]
          }
          if ((epint & USB_OTG_DIEPINT_EPDISD) == USB_OTG_DIEPINT_EPDISD)
341888ac:	693b      	ldr	r3, [r7, #16]
341888ae:	f003 0302 	and.w	r3, r3, #2
341888b2:	2b00      	cmp	r3, #0
341888b4:	d023      	beq.n	341888fe <HAL_PCD_IRQHandler+0x454>
          {
            (void)USB_FlushTxFifo(USBx, epnum);
341888b6:	6a79      	ldr	r1, [r7, #36]	@ 0x24
341888b8:	6a38      	ldr	r0, [r7, #32]
341888ba:	f009 fef3 	bl	341926a4 <USB_FlushTxFifo>

            ep = &hpcd->IN_ep[epnum];
341888be:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
341888c0:	4613      	mov	r3, r2
341888c2:	00db      	lsls	r3, r3, #3
341888c4:	4413      	add	r3, r2
341888c6:	009b      	lsls	r3, r3, #2
341888c8:	3310      	adds	r3, #16
341888ca:	687a      	ldr	r2, [r7, #4]
341888cc:	4413      	add	r3, r2
341888ce:	3304      	adds	r3, #4
341888d0:	617b      	str	r3, [r7, #20]

            if (ep->is_iso_incomplete == 1U)
341888d2:	697b      	ldr	r3, [r7, #20]
341888d4:	78db      	ldrb	r3, [r3, #3]
341888d6:	2b01      	cmp	r3, #1
341888d8:	d108      	bne.n	341888ec <HAL_PCD_IRQHandler+0x442>
            {
              ep->is_iso_incomplete = 0U;
341888da:	697b      	ldr	r3, [r7, #20]
341888dc:	2200      	movs	r2, #0
341888de:	70da      	strb	r2, [r3, #3]

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
              hpcd->ISOINIncompleteCallback(hpcd, (uint8_t)epnum);
#else
              HAL_PCD_ISOINIncompleteCallback(hpcd, (uint8_t)epnum);
341888e0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
341888e2:	b2db      	uxtb	r3, r3
341888e4:	4619      	mov	r1, r3
341888e6:	6878      	ldr	r0, [r7, #4]
341888e8:	f000 fab9 	bl	34188e5e <HAL_PCD_ISOINIncompleteCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
            }

            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_EPDISD);
341888ec:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
341888ee:	015a      	lsls	r2, r3, #5
341888f0:	69fb      	ldr	r3, [r7, #28]
341888f2:	4413      	add	r3, r2
341888f4:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
341888f8:	461a      	mov	r2, r3
341888fa:	2302      	movs	r3, #2
341888fc:	6093      	str	r3, [r2, #8]
          }
          if ((epint & USB_OTG_DIEPINT_TXFE) == USB_OTG_DIEPINT_TXFE)
341888fe:	693b      	ldr	r3, [r7, #16]
34188900:	f003 0380 	and.w	r3, r3, #128	@ 0x80
34188904:	2b00      	cmp	r3, #0
34188906:	d003      	beq.n	34188910 <HAL_PCD_IRQHandler+0x466>
          {
            (void)PCD_WriteEmptyTxFifo(hpcd, epnum);
34188908:	6a79      	ldr	r1, [r7, #36]	@ 0x24
3418890a:	6878      	ldr	r0, [r7, #4]
3418890c:	f000 fd2f 	bl	3418936e <PCD_WriteEmptyTxFifo>
          }
        }
        epnum++;
34188910:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34188912:	3301      	adds	r3, #1
34188914:	627b      	str	r3, [r7, #36]	@ 0x24
        ep_intr >>= 1U;
34188916:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34188918:	085b      	lsrs	r3, r3, #1
3418891a:	62bb      	str	r3, [r7, #40]	@ 0x28
      while (ep_intr != 0U)
3418891c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418891e:	2b00      	cmp	r3, #0
34188920:	f47f af2e 	bne.w	34188780 <HAL_PCD_IRQHandler+0x2d6>
      }
    }

    /* Handle Resume Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
34188924:	687b      	ldr	r3, [r7, #4]
34188926:	681b      	ldr	r3, [r3, #0]
34188928:	4618      	mov	r0, r3
3418892a:	f00a fdd7 	bl	341934dc <USB_ReadInterrupts>
3418892e:	4603      	mov	r3, r0
34188930:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
34188934:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
34188938:	d122      	bne.n	34188980 <HAL_PCD_IRQHandler+0x4d6>
    {
      /* Clear the Remote Wake-up Signaling */
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
3418893a:	69fb      	ldr	r3, [r7, #28]
3418893c:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
34188940:	685b      	ldr	r3, [r3, #4]
34188942:	69fa      	ldr	r2, [r7, #28]
34188944:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
34188948:	f023 0301 	bic.w	r3, r3, #1
3418894c:	6053      	str	r3, [r2, #4]

      if (hpcd->LPM_State == LPM_L1)
3418894e:	687b      	ldr	r3, [r7, #4]
34188950:	f893 34cc 	ldrb.w	r3, [r3, #1228]	@ 0x4cc
34188954:	2b01      	cmp	r3, #1
34188956:	d108      	bne.n	3418896a <HAL_PCD_IRQHandler+0x4c0>
      {
        hpcd->LPM_State = LPM_L0;
34188958:	687b      	ldr	r3, [r7, #4]
3418895a:	2200      	movs	r2, #0
3418895c:	f883 24cc 	strb.w	r2, [r3, #1228]	@ 0x4cc

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->LPMCallback(hpcd, PCD_LPM_L0_ACTIVE);
#else
        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L0_ACTIVE);
34188960:	2100      	movs	r1, #0
34188962:	6878      	ldr	r0, [r7, #4]
34188964:	f000 ff3a 	bl	341897dc <HAL_PCDEx_LPM_Callback>
34188968:	e002      	b.n	34188970 <HAL_PCD_IRQHandler+0x4c6>
      else
      {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->ResumeCallback(hpcd);
#else
        HAL_PCD_ResumeCallback(hpcd);
3418896a:	6878      	ldr	r0, [r7, #4]
3418896c:	f014 ff60 	bl	3419d830 <HAL_PCD_ResumeCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT);
34188970:	687b      	ldr	r3, [r7, #4]
34188972:	681b      	ldr	r3, [r3, #0]
34188974:	695a      	ldr	r2, [r3, #20]
34188976:	687b      	ldr	r3, [r7, #4]
34188978:	681b      	ldr	r3, [r3, #0]
3418897a:	f002 4200 	and.w	r2, r2, #2147483648	@ 0x80000000
3418897e:	615a      	str	r2, [r3, #20]
    }

    /* Handle Suspend Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP))
34188980:	687b      	ldr	r3, [r7, #4]
34188982:	681b      	ldr	r3, [r3, #0]
34188984:	4618      	mov	r0, r3
34188986:	f00a fda9 	bl	341934dc <USB_ReadInterrupts>
3418898a:	4603      	mov	r3, r0
3418898c:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
34188990:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
34188994:	d112      	bne.n	341889bc <HAL_PCD_IRQHandler+0x512>
    {
      if ((USBx_DEVICE->DSTS & USB_OTG_DSTS_SUSPSTS) == USB_OTG_DSTS_SUSPSTS)
34188996:	69fb      	ldr	r3, [r7, #28]
34188998:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
3418899c:	689b      	ldr	r3, [r3, #8]
3418899e:	f003 0301 	and.w	r3, r3, #1
341889a2:	2b01      	cmp	r3, #1
341889a4:	d102      	bne.n	341889ac <HAL_PCD_IRQHandler+0x502>
      {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->SuspendCallback(hpcd);
#else
        HAL_PCD_SuspendCallback(hpcd);
341889a6:	6878      	ldr	r0, [r7, #4]
341889a8:	f014 ff2c 	bl	3419d804 <HAL_PCD_SuspendCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP);
341889ac:	687b      	ldr	r3, [r7, #4]
341889ae:	681b      	ldr	r3, [r3, #0]
341889b0:	695a      	ldr	r2, [r3, #20]
341889b2:	687b      	ldr	r3, [r7, #4]
341889b4:	681b      	ldr	r3, [r3, #0]
341889b6:	f402 6200 	and.w	r2, r2, #2048	@ 0x800
341889ba:	615a      	str	r2, [r3, #20]
    }

    /* Handle LPM Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_LPMINT))
341889bc:	687b      	ldr	r3, [r7, #4]
341889be:	681b      	ldr	r3, [r3, #0]
341889c0:	4618      	mov	r0, r3
341889c2:	f00a fd8b 	bl	341934dc <USB_ReadInterrupts>
341889c6:	4603      	mov	r3, r0
341889c8:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
341889cc:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
341889d0:	d121      	bne.n	34188a16 <HAL_PCD_IRQHandler+0x56c>
    {
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_LPMINT);
341889d2:	687b      	ldr	r3, [r7, #4]
341889d4:	681b      	ldr	r3, [r3, #0]
341889d6:	695a      	ldr	r2, [r3, #20]
341889d8:	687b      	ldr	r3, [r7, #4]
341889da:	681b      	ldr	r3, [r3, #0]
341889dc:	f002 6200 	and.w	r2, r2, #134217728	@ 0x8000000
341889e0:	615a      	str	r2, [r3, #20]

      if (hpcd->LPM_State == LPM_L0)
341889e2:	687b      	ldr	r3, [r7, #4]
341889e4:	f893 34cc 	ldrb.w	r3, [r3, #1228]	@ 0x4cc
341889e8:	2b00      	cmp	r3, #0
341889ea:	d111      	bne.n	34188a10 <HAL_PCD_IRQHandler+0x566>
      {
        hpcd->LPM_State = LPM_L1;
341889ec:	687b      	ldr	r3, [r7, #4]
341889ee:	2201      	movs	r2, #1
341889f0:	f883 24cc 	strb.w	r2, [r3, #1228]	@ 0x4cc
        hpcd->BESL = (hpcd->Instance->GLPMCFG & USB_OTG_GLPMCFG_BESL) >> 2U;
341889f4:	687b      	ldr	r3, [r7, #4]
341889f6:	681b      	ldr	r3, [r3, #0]
341889f8:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
341889fa:	089b      	lsrs	r3, r3, #2
341889fc:	f003 020f 	and.w	r2, r3, #15
34188a00:	687b      	ldr	r3, [r7, #4]
34188a02:	f8c3 24d0 	str.w	r2, [r3, #1232]	@ 0x4d0

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->LPMCallback(hpcd, PCD_LPM_L1_ACTIVE);
#else
        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L1_ACTIVE);
34188a06:	2101      	movs	r1, #1
34188a08:	6878      	ldr	r0, [r7, #4]
34188a0a:	f000 fee7 	bl	341897dc <HAL_PCDEx_LPM_Callback>
34188a0e:	e002      	b.n	34188a16 <HAL_PCD_IRQHandler+0x56c>
      else
      {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->SuspendCallback(hpcd);
#else
        HAL_PCD_SuspendCallback(hpcd);
34188a10:	6878      	ldr	r0, [r7, #4]
34188a12:	f014 fef7 	bl	3419d804 <HAL_PCD_SuspendCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }
    }

    /* Handle Reset Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
34188a16:	687b      	ldr	r3, [r7, #4]
34188a18:	681b      	ldr	r3, [r3, #0]
34188a1a:	4618      	mov	r0, r3
34188a1c:	f00a fd5e 	bl	341934dc <USB_ReadInterrupts>
34188a20:	4603      	mov	r3, r0
34188a22:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
34188a26:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34188a2a:	f040 80b7 	bne.w	34188b9c <HAL_PCD_IRQHandler+0x6f2>
    {
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
34188a2e:	69fb      	ldr	r3, [r7, #28]
34188a30:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
34188a34:	685b      	ldr	r3, [r3, #4]
34188a36:	69fa      	ldr	r2, [r7, #28]
34188a38:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
34188a3c:	f023 0301 	bic.w	r3, r3, #1
34188a40:	6053      	str	r3, [r2, #4]
      (void)USB_FlushTxFifo(hpcd->Instance, 0x10U);
34188a42:	687b      	ldr	r3, [r7, #4]
34188a44:	681b      	ldr	r3, [r3, #0]
34188a46:	2110      	movs	r1, #16
34188a48:	4618      	mov	r0, r3
34188a4a:	f009 fe2b 	bl	341926a4 <USB_FlushTxFifo>

      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
34188a4e:	2300      	movs	r3, #0
34188a50:	62fb      	str	r3, [r7, #44]	@ 0x2c
34188a52:	e046      	b.n	34188ae2 <HAL_PCD_IRQHandler+0x638>
      {
        USBx_INEP(i)->DIEPINT = 0xFB7FU;
34188a54:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34188a56:	015a      	lsls	r2, r3, #5
34188a58:	69fb      	ldr	r3, [r7, #28]
34188a5a:	4413      	add	r3, r2
34188a5c:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
34188a60:	461a      	mov	r2, r3
34188a62:	f64f 337f 	movw	r3, #64383	@ 0xfb7f
34188a66:	6093      	str	r3, [r2, #8]
        USBx_INEP(i)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
34188a68:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34188a6a:	015a      	lsls	r2, r3, #5
34188a6c:	69fb      	ldr	r3, [r7, #28]
34188a6e:	4413      	add	r3, r2
34188a70:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
34188a74:	681b      	ldr	r3, [r3, #0]
34188a76:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
34188a78:	0151      	lsls	r1, r2, #5
34188a7a:	69fa      	ldr	r2, [r7, #28]
34188a7c:	440a      	add	r2, r1
34188a7e:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
34188a82:	f423 1300 	bic.w	r3, r3, #2097152	@ 0x200000
34188a86:	6013      	str	r3, [r2, #0]
        USBx_OUTEP(i)->DOEPINT = 0xFB7FU;
34188a88:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34188a8a:	015a      	lsls	r2, r3, #5
34188a8c:	69fb      	ldr	r3, [r7, #28]
34188a8e:	4413      	add	r3, r2
34188a90:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
34188a94:	461a      	mov	r2, r3
34188a96:	f64f 337f 	movw	r3, #64383	@ 0xfb7f
34188a9a:	6093      	str	r3, [r2, #8]
        USBx_OUTEP(i)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
34188a9c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34188a9e:	015a      	lsls	r2, r3, #5
34188aa0:	69fb      	ldr	r3, [r7, #28]
34188aa2:	4413      	add	r3, r2
34188aa4:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
34188aa8:	681b      	ldr	r3, [r3, #0]
34188aaa:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
34188aac:	0151      	lsls	r1, r2, #5
34188aae:	69fa      	ldr	r2, [r7, #28]
34188ab0:	440a      	add	r2, r1
34188ab2:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
34188ab6:	f423 1300 	bic.w	r3, r3, #2097152	@ 0x200000
34188aba:	6013      	str	r3, [r2, #0]
        USBx_OUTEP(i)->DOEPCTL |= USB_OTG_DOEPCTL_SNAK;
34188abc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34188abe:	015a      	lsls	r2, r3, #5
34188ac0:	69fb      	ldr	r3, [r7, #28]
34188ac2:	4413      	add	r3, r2
34188ac4:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
34188ac8:	681b      	ldr	r3, [r3, #0]
34188aca:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
34188acc:	0151      	lsls	r1, r2, #5
34188ace:	69fa      	ldr	r2, [r7, #28]
34188ad0:	440a      	add	r2, r1
34188ad2:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
34188ad6:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
34188ada:	6013      	str	r3, [r2, #0]
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
34188adc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34188ade:	3301      	adds	r3, #1
34188ae0:	62fb      	str	r3, [r7, #44]	@ 0x2c
34188ae2:	687b      	ldr	r3, [r7, #4]
34188ae4:	791b      	ldrb	r3, [r3, #4]
34188ae6:	461a      	mov	r2, r3
34188ae8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34188aea:	4293      	cmp	r3, r2
34188aec:	d3b2      	bcc.n	34188a54 <HAL_PCD_IRQHandler+0x5aa>
      }
      USBx_DEVICE->DAINTMSK |= 0x10001U;
34188aee:	69fb      	ldr	r3, [r7, #28]
34188af0:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
34188af4:	69db      	ldr	r3, [r3, #28]
34188af6:	69fa      	ldr	r2, [r7, #28]
34188af8:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
34188afc:	f043 1301 	orr.w	r3, r3, #65537	@ 0x10001
34188b00:	61d3      	str	r3, [r2, #28]

      if (hpcd->Init.use_dedicated_ep1 != 0U)
34188b02:	687b      	ldr	r3, [r7, #4]
34188b04:	7bdb      	ldrb	r3, [r3, #15]
34188b06:	2b00      	cmp	r3, #0
34188b08:	d016      	beq.n	34188b38 <HAL_PCD_IRQHandler+0x68e>
      {
        USBx_DEVICE->DOUTEP1MSK |= USB_OTG_DOEPMSK_STUPM |
34188b0a:	69fb      	ldr	r3, [r7, #28]
34188b0c:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
34188b10:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
34188b14:	69fa      	ldr	r2, [r7, #28]
34188b16:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
34188b1a:	f043 030b 	orr.w	r3, r3, #11
34188b1e:	f8c2 3084 	str.w	r3, [r2, #132]	@ 0x84
                                   USB_OTG_DOEPMSK_XFRCM |
                                   USB_OTG_DOEPMSK_EPDM;

        USBx_DEVICE->DINEP1MSK |= USB_OTG_DIEPMSK_TOM |
34188b22:	69fb      	ldr	r3, [r7, #28]
34188b24:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
34188b28:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34188b2a:	69fa      	ldr	r2, [r7, #28]
34188b2c:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
34188b30:	f043 030b 	orr.w	r3, r3, #11
34188b34:	6453      	str	r3, [r2, #68]	@ 0x44
34188b36:	e015      	b.n	34188b64 <HAL_PCD_IRQHandler+0x6ba>
                                  USB_OTG_DIEPMSK_XFRCM |
                                  USB_OTG_DIEPMSK_EPDM;
      }
      else
      {
        USBx_DEVICE->DOEPMSK |= USB_OTG_DOEPMSK_STUPM |
34188b38:	69fb      	ldr	r3, [r7, #28]
34188b3a:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
34188b3e:	695b      	ldr	r3, [r3, #20]
34188b40:	69fa      	ldr	r2, [r7, #28]
34188b42:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
34188b46:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
34188b4a:	f043 032b 	orr.w	r3, r3, #43	@ 0x2b
34188b4e:	6153      	str	r3, [r2, #20]
                                USB_OTG_DOEPMSK_XFRCM |
                                USB_OTG_DOEPMSK_EPDM |
                                USB_OTG_DOEPMSK_OTEPSPRM |
                                USB_OTG_DOEPMSK_NAKM;

        USBx_DEVICE->DIEPMSK |= USB_OTG_DIEPMSK_TOM |
34188b50:	69fb      	ldr	r3, [r7, #28]
34188b52:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
34188b56:	691b      	ldr	r3, [r3, #16]
34188b58:	69fa      	ldr	r2, [r7, #28]
34188b5a:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
34188b5e:	f043 030b 	orr.w	r3, r3, #11
34188b62:	6113      	str	r3, [r2, #16]
                                USB_OTG_DIEPMSK_XFRCM |
                                USB_OTG_DIEPMSK_EPDM;
      }

      /* Set Default Address to 0 */
      USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
34188b64:	69fb      	ldr	r3, [r7, #28]
34188b66:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
34188b6a:	681b      	ldr	r3, [r3, #0]
34188b6c:	69fa      	ldr	r2, [r7, #28]
34188b6e:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
34188b72:	f423 63fe 	bic.w	r3, r3, #2032	@ 0x7f0
34188b76:	6013      	str	r3, [r2, #0]

      /* setup EP0 to receive SETUP packets */
      (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable,
34188b78:	687b      	ldr	r3, [r7, #4]
34188b7a:	6818      	ldr	r0, [r3, #0]
34188b7c:	687b      	ldr	r3, [r7, #4]
34188b7e:	7999      	ldrb	r1, [r3, #6]
                             (uint8_t *)hpcd->Setup);
34188b80:	687b      	ldr	r3, [r7, #4]
34188b82:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
      (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable,
34188b86:	461a      	mov	r2, r3
34188b88:	f00a fd6c 	bl	34193664 <USB_EP0_OutStart>

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBRST);
34188b8c:	687b      	ldr	r3, [r7, #4]
34188b8e:	681b      	ldr	r3, [r3, #0]
34188b90:	695a      	ldr	r2, [r3, #20]
34188b92:	687b      	ldr	r3, [r7, #4]
34188b94:	681b      	ldr	r3, [r3, #0]
34188b96:	f402 5280 	and.w	r2, r2, #4096	@ 0x1000
34188b9a:	615a      	str	r2, [r3, #20]
    }

    /* Handle Enumeration done Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE))
34188b9c:	687b      	ldr	r3, [r7, #4]
34188b9e:	681b      	ldr	r3, [r3, #0]
34188ba0:	4618      	mov	r0, r3
34188ba2:	f00a fc9b 	bl	341934dc <USB_ReadInterrupts>
34188ba6:	4603      	mov	r3, r0
34188ba8:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
34188bac:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
34188bb0:	d123      	bne.n	34188bfa <HAL_PCD_IRQHandler+0x750>
    {
      (void)USB_ActivateSetup(hpcd->Instance);
34188bb2:	687b      	ldr	r3, [r7, #4]
34188bb4:	681b      	ldr	r3, [r3, #0]
34188bb6:	4618      	mov	r0, r3
34188bb8:	f00a fd31 	bl	3419361e <USB_ActivateSetup>
      hpcd->Init.speed = USB_GetDevSpeed(hpcd->Instance);
34188bbc:	687b      	ldr	r3, [r7, #4]
34188bbe:	681b      	ldr	r3, [r3, #0]
34188bc0:	4618      	mov	r0, r3
34188bc2:	f009 fde8 	bl	34192796 <USB_GetDevSpeed>
34188bc6:	4603      	mov	r3, r0
34188bc8:	461a      	mov	r2, r3
34188bca:	687b      	ldr	r3, [r7, #4]
34188bcc:	71da      	strb	r2, [r3, #7]

      /* Set USB Turnaround time */
      (void)USB_SetTurnaroundTime(hpcd->Instance,
34188bce:	687b      	ldr	r3, [r7, #4]
34188bd0:	681c      	ldr	r4, [r3, #0]
34188bd2:	f002 f81d 	bl	3418ac10 <HAL_RCC_GetHCLKFreq>
34188bd6:	4601      	mov	r1, r0
                                  HAL_RCC_GetHCLKFreq(),
                                  (uint8_t)hpcd->Init.speed);
34188bd8:	687b      	ldr	r3, [r7, #4]
34188bda:	79db      	ldrb	r3, [r3, #7]
      (void)USB_SetTurnaroundTime(hpcd->Instance,
34188bdc:	461a      	mov	r2, r3
34188bde:	4620      	mov	r0, r4
34188be0:	f009 faec 	bl	341921bc <USB_SetTurnaroundTime>

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->ResetCallback(hpcd);
#else
      HAL_PCD_ResetCallback(hpcd);
34188be4:	6878      	ldr	r0, [r7, #4]
34188be6:	f014 fda9 	bl	3419d73c <HAL_PCD_ResetCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE);
34188bea:	687b      	ldr	r3, [r7, #4]
34188bec:	681b      	ldr	r3, [r3, #0]
34188bee:	695a      	ldr	r2, [r3, #20]
34188bf0:	687b      	ldr	r3, [r7, #4]
34188bf2:	681b      	ldr	r3, [r3, #0]
34188bf4:	f402 5200 	and.w	r2, r2, #8192	@ 0x2000
34188bf8:	615a      	str	r2, [r3, #20]
    }

    /* Handle SOF Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SOF))
34188bfa:	687b      	ldr	r3, [r7, #4]
34188bfc:	681b      	ldr	r3, [r3, #0]
34188bfe:	4618      	mov	r0, r3
34188c00:	f00a fc6c 	bl	341934dc <USB_ReadInterrupts>
34188c04:	4603      	mov	r3, r0
34188c06:	f003 0308 	and.w	r3, r3, #8
34188c0a:	2b08      	cmp	r3, #8
34188c0c:	d10a      	bne.n	34188c24 <HAL_PCD_IRQHandler+0x77a>
    {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->SOFCallback(hpcd);
#else
      HAL_PCD_SOFCallback(hpcd);
34188c0e:	6878      	ldr	r0, [r7, #4]
34188c10:	f014 fe24 	bl	3419d85c <HAL_PCD_SOFCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SOF);
34188c14:	687b      	ldr	r3, [r7, #4]
34188c16:	681b      	ldr	r3, [r3, #0]
34188c18:	695a      	ldr	r2, [r3, #20]
34188c1a:	687b      	ldr	r3, [r7, #4]
34188c1c:	681b      	ldr	r3, [r3, #0]
34188c1e:	f002 0208 	and.w	r2, r2, #8
34188c22:	615a      	str	r2, [r3, #20]
    }

    /* Handle Global OUT NAK effective Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_BOUTNAKEFF))
34188c24:	687b      	ldr	r3, [r7, #4]
34188c26:	681b      	ldr	r3, [r3, #0]
34188c28:	4618      	mov	r0, r3
34188c2a:	f00a fc57 	bl	341934dc <USB_ReadInterrupts>
34188c2e:	4603      	mov	r3, r0
34188c30:	f003 0380 	and.w	r3, r3, #128	@ 0x80
34188c34:	2b80      	cmp	r3, #128	@ 0x80
34188c36:	d123      	bne.n	34188c80 <HAL_PCD_IRQHandler+0x7d6>
    {
      USBx->GINTMSK &= ~USB_OTG_GINTMSK_GONAKEFFM;
34188c38:	6a3b      	ldr	r3, [r7, #32]
34188c3a:	699b      	ldr	r3, [r3, #24]
34188c3c:	f023 0280 	bic.w	r2, r3, #128	@ 0x80
34188c40:	6a3b      	ldr	r3, [r7, #32]
34188c42:	619a      	str	r2, [r3, #24]

      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
34188c44:	2301      	movs	r3, #1
34188c46:	627b      	str	r3, [r7, #36]	@ 0x24
34188c48:	e014      	b.n	34188c74 <HAL_PCD_IRQHandler+0x7ca>
      {
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
34188c4a:	6879      	ldr	r1, [r7, #4]
34188c4c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
34188c4e:	4613      	mov	r3, r2
34188c50:	00db      	lsls	r3, r3, #3
34188c52:	4413      	add	r3, r2
34188c54:	009b      	lsls	r3, r3, #2
34188c56:	440b      	add	r3, r1
34188c58:	f203 2357 	addw	r3, r3, #599	@ 0x257
34188c5c:	781b      	ldrb	r3, [r3, #0]
34188c5e:	2b01      	cmp	r3, #1
34188c60:	d105      	bne.n	34188c6e <HAL_PCD_IRQHandler+0x7c4>
        {
          /* Abort current transaction and disable the EP */
          (void)HAL_PCD_EP_Abort(hpcd, (uint8_t)epnum);
34188c62:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34188c64:	b2db      	uxtb	r3, r3
34188c66:	4619      	mov	r1, r3
34188c68:	6878      	ldr	r0, [r7, #4]
34188c6a:	f000 fb22 	bl	341892b2 <HAL_PCD_EP_Abort>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
34188c6e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34188c70:	3301      	adds	r3, #1
34188c72:	627b      	str	r3, [r7, #36]	@ 0x24
34188c74:	687b      	ldr	r3, [r7, #4]
34188c76:	791b      	ldrb	r3, [r3, #4]
34188c78:	461a      	mov	r2, r3
34188c7a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34188c7c:	4293      	cmp	r3, r2
34188c7e:	d3e4      	bcc.n	34188c4a <HAL_PCD_IRQHandler+0x7a0>
        }
      }
    }

    /* Handle Incomplete ISO IN Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR))
34188c80:	687b      	ldr	r3, [r7, #4]
34188c82:	681b      	ldr	r3, [r3, #0]
34188c84:	4618      	mov	r0, r3
34188c86:	f00a fc29 	bl	341934dc <USB_ReadInterrupts>
34188c8a:	4603      	mov	r3, r0
34188c8c:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
34188c90:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
34188c94:	d13c      	bne.n	34188d10 <HAL_PCD_IRQHandler+0x866>
    {
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
34188c96:	2301      	movs	r3, #1
34188c98:	627b      	str	r3, [r7, #36]	@ 0x24
34188c9a:	e02b      	b.n	34188cf4 <HAL_PCD_IRQHandler+0x84a>
      {
        RegVal = USBx_INEP(epnum)->DIEPCTL;
34188c9c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34188c9e:	015a      	lsls	r2, r3, #5
34188ca0:	69fb      	ldr	r3, [r7, #28]
34188ca2:	4413      	add	r3, r2
34188ca4:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
34188ca8:	681b      	ldr	r3, [r3, #0]
34188caa:	61bb      	str	r3, [r7, #24]

        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
34188cac:	6879      	ldr	r1, [r7, #4]
34188cae:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
34188cb0:	4613      	mov	r3, r2
34188cb2:	00db      	lsls	r3, r3, #3
34188cb4:	4413      	add	r3, r2
34188cb6:	009b      	lsls	r3, r3, #2
34188cb8:	440b      	add	r3, r1
34188cba:	3318      	adds	r3, #24
34188cbc:	781b      	ldrb	r3, [r3, #0]
34188cbe:	2b01      	cmp	r3, #1
34188cc0:	d115      	bne.n	34188cee <HAL_PCD_IRQHandler+0x844>
            ((RegVal & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA))
34188cc2:	69bb      	ldr	r3, [r7, #24]
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
34188cc4:	2b00      	cmp	r3, #0
34188cc6:	da12      	bge.n	34188cee <HAL_PCD_IRQHandler+0x844>
        {
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
34188cc8:	6879      	ldr	r1, [r7, #4]
34188cca:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
34188ccc:	4613      	mov	r3, r2
34188cce:	00db      	lsls	r3, r3, #3
34188cd0:	4413      	add	r3, r2
34188cd2:	009b      	lsls	r3, r3, #2
34188cd4:	440b      	add	r3, r1
34188cd6:	3317      	adds	r3, #23
34188cd8:	2201      	movs	r2, #1
34188cda:	701a      	strb	r2, [r3, #0]

          /* Abort current transaction and disable the EP */
          (void)HAL_PCD_EP_Abort(hpcd, (uint8_t)(epnum | 0x80U));
34188cdc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34188cde:	b2db      	uxtb	r3, r3
34188ce0:	f063 037f 	orn	r3, r3, #127	@ 0x7f
34188ce4:	b2db      	uxtb	r3, r3
34188ce6:	4619      	mov	r1, r3
34188ce8:	6878      	ldr	r0, [r7, #4]
34188cea:	f000 fae2 	bl	341892b2 <HAL_PCD_EP_Abort>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
34188cee:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34188cf0:	3301      	adds	r3, #1
34188cf2:	627b      	str	r3, [r7, #36]	@ 0x24
34188cf4:	687b      	ldr	r3, [r7, #4]
34188cf6:	791b      	ldrb	r3, [r3, #4]
34188cf8:	461a      	mov	r2, r3
34188cfa:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34188cfc:	4293      	cmp	r3, r2
34188cfe:	d3cd      	bcc.n	34188c9c <HAL_PCD_IRQHandler+0x7f2>
        }
      }

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR);
34188d00:	687b      	ldr	r3, [r7, #4]
34188d02:	681b      	ldr	r3, [r3, #0]
34188d04:	695a      	ldr	r2, [r3, #20]
34188d06:	687b      	ldr	r3, [r7, #4]
34188d08:	681b      	ldr	r3, [r3, #0]
34188d0a:	f402 1280 	and.w	r2, r2, #1048576	@ 0x100000
34188d0e:	615a      	str	r2, [r3, #20]
    }

    /* Handle Incomplete ISO OUT Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
34188d10:	687b      	ldr	r3, [r7, #4]
34188d12:	681b      	ldr	r3, [r3, #0]
34188d14:	4618      	mov	r0, r3
34188d16:	f00a fbe1 	bl	341934dc <USB_ReadInterrupts>
34188d1a:	4603      	mov	r3, r0
34188d1c:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
34188d20:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
34188d24:	d156      	bne.n	34188dd4 <HAL_PCD_IRQHandler+0x92a>
    {
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
34188d26:	2301      	movs	r3, #1
34188d28:	627b      	str	r3, [r7, #36]	@ 0x24
34188d2a:	e045      	b.n	34188db8 <HAL_PCD_IRQHandler+0x90e>
      {
        RegVal = USBx_OUTEP(epnum)->DOEPCTL;
34188d2c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34188d2e:	015a      	lsls	r2, r3, #5
34188d30:	69fb      	ldr	r3, [r7, #28]
34188d32:	4413      	add	r3, r2
34188d34:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
34188d38:	681b      	ldr	r3, [r3, #0]
34188d3a:	61bb      	str	r3, [r7, #24]

        if ((hpcd->OUT_ep[epnum].type == EP_TYPE_ISOC) &&
34188d3c:	6879      	ldr	r1, [r7, #4]
34188d3e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
34188d40:	4613      	mov	r3, r2
34188d42:	00db      	lsls	r3, r3, #3
34188d44:	4413      	add	r3, r2
34188d46:	009b      	lsls	r3, r3, #2
34188d48:	440b      	add	r3, r1
34188d4a:	f503 7316 	add.w	r3, r3, #600	@ 0x258
34188d4e:	781b      	ldrb	r3, [r3, #0]
34188d50:	2b01      	cmp	r3, #1
34188d52:	d12e      	bne.n	34188db2 <HAL_PCD_IRQHandler+0x908>
            ((RegVal & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA) &&
34188d54:	69bb      	ldr	r3, [r7, #24]
        if ((hpcd->OUT_ep[epnum].type == EP_TYPE_ISOC) &&
34188d56:	2b00      	cmp	r3, #0
34188d58:	da2b      	bge.n	34188db2 <HAL_PCD_IRQHandler+0x908>
            (((RegVal & (0x1U << 16)) >> 16U) == (hpcd->FrameNumber & 0x1U)))
34188d5a:	69bb      	ldr	r3, [r7, #24]
34188d5c:	0c1a      	lsrs	r2, r3, #16
34188d5e:	687b      	ldr	r3, [r7, #4]
34188d60:	f8d3 34d4 	ldr.w	r3, [r3, #1236]	@ 0x4d4
34188d64:	4053      	eors	r3, r2
34188d66:	f003 0301 	and.w	r3, r3, #1
            ((RegVal & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA) &&
34188d6a:	2b00      	cmp	r3, #0
34188d6c:	d121      	bne.n	34188db2 <HAL_PCD_IRQHandler+0x908>
        {
          hpcd->OUT_ep[epnum].is_iso_incomplete = 1U;
34188d6e:	6879      	ldr	r1, [r7, #4]
34188d70:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
34188d72:	4613      	mov	r3, r2
34188d74:	00db      	lsls	r3, r3, #3
34188d76:	4413      	add	r3, r2
34188d78:	009b      	lsls	r3, r3, #2
34188d7a:	440b      	add	r3, r1
34188d7c:	f203 2357 	addw	r3, r3, #599	@ 0x257
34188d80:	2201      	movs	r2, #1
34188d82:	701a      	strb	r2, [r3, #0]

          USBx->GINTMSK |= USB_OTG_GINTMSK_GONAKEFFM;
34188d84:	6a3b      	ldr	r3, [r7, #32]
34188d86:	699b      	ldr	r3, [r3, #24]
34188d88:	f043 0280 	orr.w	r2, r3, #128	@ 0x80
34188d8c:	6a3b      	ldr	r3, [r7, #32]
34188d8e:	619a      	str	r2, [r3, #24]

          if ((USBx->GINTSTS & USB_OTG_GINTSTS_BOUTNAKEFF) == 0U)
34188d90:	6a3b      	ldr	r3, [r7, #32]
34188d92:	695b      	ldr	r3, [r3, #20]
34188d94:	f003 0380 	and.w	r3, r3, #128	@ 0x80
34188d98:	2b00      	cmp	r3, #0
34188d9a:	d10a      	bne.n	34188db2 <HAL_PCD_IRQHandler+0x908>
          {
            USBx_DEVICE->DCTL |= USB_OTG_DCTL_SGONAK;
34188d9c:	69fb      	ldr	r3, [r7, #28]
34188d9e:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
34188da2:	685b      	ldr	r3, [r3, #4]
34188da4:	69fa      	ldr	r2, [r7, #28]
34188da6:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
34188daa:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
34188dae:	6053      	str	r3, [r2, #4]
            break;
34188db0:	e008      	b.n	34188dc4 <HAL_PCD_IRQHandler+0x91a>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
34188db2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34188db4:	3301      	adds	r3, #1
34188db6:	627b      	str	r3, [r7, #36]	@ 0x24
34188db8:	687b      	ldr	r3, [r7, #4]
34188dba:	791b      	ldrb	r3, [r3, #4]
34188dbc:	461a      	mov	r2, r3
34188dbe:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34188dc0:	4293      	cmp	r3, r2
34188dc2:	d3b3      	bcc.n	34188d2c <HAL_PCD_IRQHandler+0x882>
          }
        }
      }

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
34188dc4:	687b      	ldr	r3, [r7, #4]
34188dc6:	681b      	ldr	r3, [r3, #0]
34188dc8:	695a      	ldr	r2, [r3, #20]
34188dca:	687b      	ldr	r3, [r7, #4]
34188dcc:	681b      	ldr	r3, [r3, #0]
34188dce:	f402 1200 	and.w	r2, r2, #2097152	@ 0x200000
34188dd2:	615a      	str	r2, [r3, #20]
    }

    /* Handle Connection event Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT))
34188dd4:	687b      	ldr	r3, [r7, #4]
34188dd6:	681b      	ldr	r3, [r3, #0]
34188dd8:	4618      	mov	r0, r3
34188dda:	f00a fb7f 	bl	341934dc <USB_ReadInterrupts>
34188dde:	4603      	mov	r3, r0
34188de0:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
34188de4:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
34188de8:	d10a      	bne.n	34188e00 <HAL_PCD_IRQHandler+0x956>
    {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->ConnectCallback(hpcd);
#else
      HAL_PCD_ConnectCallback(hpcd);
34188dea:	6878      	ldr	r0, [r7, #4]
34188dec:	f014 fcd6 	bl	3419d79c <HAL_PCD_ConnectCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT);
34188df0:	687b      	ldr	r3, [r7, #4]
34188df2:	681b      	ldr	r3, [r3, #0]
34188df4:	695a      	ldr	r2, [r3, #20]
34188df6:	687b      	ldr	r3, [r7, #4]
34188df8:	681b      	ldr	r3, [r3, #0]
34188dfa:	f002 4280 	and.w	r2, r2, #1073741824	@ 0x40000000
34188dfe:	615a      	str	r2, [r3, #20]
    }

    /* Handle Disconnection event Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OTGINT))
34188e00:	687b      	ldr	r3, [r7, #4]
34188e02:	681b      	ldr	r3, [r3, #0]
34188e04:	4618      	mov	r0, r3
34188e06:	f00a fb69 	bl	341934dc <USB_ReadInterrupts>
34188e0a:	4603      	mov	r3, r0
34188e0c:	f003 0304 	and.w	r3, r3, #4
34188e10:	2b04      	cmp	r3, #4
34188e12:	d115      	bne.n	34188e40 <HAL_PCD_IRQHandler+0x996>
    {
      RegVal = hpcd->Instance->GOTGINT;
34188e14:	687b      	ldr	r3, [r7, #4]
34188e16:	681b      	ldr	r3, [r3, #0]
34188e18:	685b      	ldr	r3, [r3, #4]
34188e1a:	61bb      	str	r3, [r7, #24]

      if ((RegVal & USB_OTG_GOTGINT_SEDET) == USB_OTG_GOTGINT_SEDET)
34188e1c:	69bb      	ldr	r3, [r7, #24]
34188e1e:	f003 0304 	and.w	r3, r3, #4
34188e22:	2b00      	cmp	r3, #0
34188e24:	d002      	beq.n	34188e2c <HAL_PCD_IRQHandler+0x982>
      {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->DisconnectCallback(hpcd);
#else
        HAL_PCD_DisconnectCallback(hpcd);
34188e26:	6878      	ldr	r0, [r7, #4]
34188e28:	f014 fcce 	bl	3419d7c8 <HAL_PCD_DisconnectCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }
      hpcd->Instance->GOTGINT |= RegVal;
34188e2c:	687b      	ldr	r3, [r7, #4]
34188e2e:	681b      	ldr	r3, [r3, #0]
34188e30:	6859      	ldr	r1, [r3, #4]
34188e32:	687b      	ldr	r3, [r7, #4]
34188e34:	681b      	ldr	r3, [r3, #0]
34188e36:	69ba      	ldr	r2, [r7, #24]
34188e38:	430a      	orrs	r2, r1
34188e3a:	605a      	str	r2, [r3, #4]
34188e3c:	e000      	b.n	34188e40 <HAL_PCD_IRQHandler+0x996>
      return;
34188e3e:	bf00      	nop
    }
  }
}
34188e40:	3734      	adds	r7, #52	@ 0x34
34188e42:	46bd      	mov	sp, r7
34188e44:	bd90      	pop	{r4, r7, pc}

34188e46 <HAL_PCD_ISOOUTIncompleteCallback>:
  * @param  hpcd PCD handle
  * @param  epnum endpoint number
  * @retval None
  */
__weak void HAL_PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
34188e46:	b480      	push	{r7}
34188e48:	b083      	sub	sp, #12
34188e4a:	af00      	add	r7, sp, #0
34188e4c:	6078      	str	r0, [r7, #4]
34188e4e:	460b      	mov	r3, r1
34188e50:	70fb      	strb	r3, [r7, #3]
  UNUSED(epnum);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PCD_ISOOUTIncompleteCallback could be implemented in the user file
   */
}
34188e52:	bf00      	nop
34188e54:	370c      	adds	r7, #12
34188e56:	46bd      	mov	sp, r7
34188e58:	f85d 7b04 	ldr.w	r7, [sp], #4
34188e5c:	4770      	bx	lr

34188e5e <HAL_PCD_ISOINIncompleteCallback>:
  * @param  hpcd PCD handle
  * @param  epnum endpoint number
  * @retval None
  */
__weak void HAL_PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
34188e5e:	b480      	push	{r7}
34188e60:	b083      	sub	sp, #12
34188e62:	af00      	add	r7, sp, #0
34188e64:	6078      	str	r0, [r7, #4]
34188e66:	460b      	mov	r3, r1
34188e68:	70fb      	strb	r3, [r7, #3]
  UNUSED(epnum);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PCD_ISOINIncompleteCallback could be implemented in the user file
   */
}
34188e6a:	bf00      	nop
34188e6c:	370c      	adds	r7, #12
34188e6e:	46bd      	mov	sp, r7
34188e70:	f85d 7b04 	ldr.w	r7, [sp], #4
34188e74:	4770      	bx	lr

34188e76 <HAL_PCD_SetAddress>:
  * @param  hpcd PCD handle
  * @param  address new device address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_SetAddress(PCD_HandleTypeDef *hpcd, uint8_t address)
{
34188e76:	b580      	push	{r7, lr}
34188e78:	b082      	sub	sp, #8
34188e7a:	af00      	add	r7, sp, #0
34188e7c:	6078      	str	r0, [r7, #4]
34188e7e:	460b      	mov	r3, r1
34188e80:	70fb      	strb	r3, [r7, #3]
  __HAL_LOCK(hpcd);
34188e82:	687b      	ldr	r3, [r7, #4]
34188e84:	f893 3494 	ldrb.w	r3, [r3, #1172]	@ 0x494
34188e88:	2b01      	cmp	r3, #1
34188e8a:	d101      	bne.n	34188e90 <HAL_PCD_SetAddress+0x1a>
34188e8c:	2302      	movs	r3, #2
34188e8e:	e012      	b.n	34188eb6 <HAL_PCD_SetAddress+0x40>
34188e90:	687b      	ldr	r3, [r7, #4]
34188e92:	2201      	movs	r2, #1
34188e94:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494
  hpcd->USB_Address = address;
34188e98:	687b      	ldr	r3, [r7, #4]
34188e9a:	78fa      	ldrb	r2, [r7, #3]
34188e9c:	745a      	strb	r2, [r3, #17]
  (void)USB_SetDevAddress(hpcd->Instance, address);
34188e9e:	687b      	ldr	r3, [r7, #4]
34188ea0:	681b      	ldr	r3, [r3, #0]
34188ea2:	78fa      	ldrb	r2, [r7, #3]
34188ea4:	4611      	mov	r1, r2
34188ea6:	4618      	mov	r0, r3
34188ea8:	f00a fab0 	bl	3419340c <USB_SetDevAddress>
  __HAL_UNLOCK(hpcd);
34188eac:	687b      	ldr	r3, [r7, #4]
34188eae:	2200      	movs	r2, #0
34188eb0:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  return HAL_OK;
34188eb4:	2300      	movs	r3, #0
}
34188eb6:	4618      	mov	r0, r3
34188eb8:	3708      	adds	r7, #8
34188eba:	46bd      	mov	sp, r7
34188ebc:	bd80      	pop	{r7, pc}

34188ebe <HAL_PCD_EP_Open>:
  * @param  ep_type endpoint type
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Open(PCD_HandleTypeDef *hpcd, uint8_t ep_addr,
                                  uint16_t ep_mps, uint8_t ep_type)
{
34188ebe:	b580      	push	{r7, lr}
34188ec0:	b084      	sub	sp, #16
34188ec2:	af00      	add	r7, sp, #0
34188ec4:	6078      	str	r0, [r7, #4]
34188ec6:	4608      	mov	r0, r1
34188ec8:	4611      	mov	r1, r2
34188eca:	461a      	mov	r2, r3
34188ecc:	4603      	mov	r3, r0
34188ece:	70fb      	strb	r3, [r7, #3]
34188ed0:	460b      	mov	r3, r1
34188ed2:	803b      	strh	r3, [r7, #0]
34188ed4:	4613      	mov	r3, r2
34188ed6:	70bb      	strb	r3, [r7, #2]
  HAL_StatusTypeDef ret = HAL_OK;
34188ed8:	2300      	movs	r3, #0
34188eda:	72fb      	strb	r3, [r7, #11]
  PCD_EPTypeDef *ep;

  if ((ep_addr & 0x80U) == 0x80U)
34188edc:	f997 3003 	ldrsb.w	r3, [r7, #3]
34188ee0:	2b00      	cmp	r3, #0
34188ee2:	da0f      	bge.n	34188f04 <HAL_PCD_EP_Open+0x46>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
34188ee4:	78fb      	ldrb	r3, [r7, #3]
34188ee6:	f003 020f 	and.w	r2, r3, #15
34188eea:	4613      	mov	r3, r2
34188eec:	00db      	lsls	r3, r3, #3
34188eee:	4413      	add	r3, r2
34188ef0:	009b      	lsls	r3, r3, #2
34188ef2:	3310      	adds	r3, #16
34188ef4:	687a      	ldr	r2, [r7, #4]
34188ef6:	4413      	add	r3, r2
34188ef8:	3304      	adds	r3, #4
34188efa:	60fb      	str	r3, [r7, #12]
    ep->is_in = 1U;
34188efc:	68fb      	ldr	r3, [r7, #12]
34188efe:	2201      	movs	r2, #1
34188f00:	705a      	strb	r2, [r3, #1]
34188f02:	e00f      	b.n	34188f24 <HAL_PCD_EP_Open+0x66>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
34188f04:	78fb      	ldrb	r3, [r7, #3]
34188f06:	f003 020f 	and.w	r2, r3, #15
34188f0a:	4613      	mov	r3, r2
34188f0c:	00db      	lsls	r3, r3, #3
34188f0e:	4413      	add	r3, r2
34188f10:	009b      	lsls	r3, r3, #2
34188f12:	f503 7314 	add.w	r3, r3, #592	@ 0x250
34188f16:	687a      	ldr	r2, [r7, #4]
34188f18:	4413      	add	r3, r2
34188f1a:	3304      	adds	r3, #4
34188f1c:	60fb      	str	r3, [r7, #12]
    ep->is_in = 0U;
34188f1e:	68fb      	ldr	r3, [r7, #12]
34188f20:	2200      	movs	r2, #0
34188f22:	705a      	strb	r2, [r3, #1]
  }

  ep->num = ep_addr & EP_ADDR_MSK;
34188f24:	78fb      	ldrb	r3, [r7, #3]
34188f26:	f003 030f 	and.w	r3, r3, #15
34188f2a:	b2da      	uxtb	r2, r3
34188f2c:	68fb      	ldr	r3, [r7, #12]
34188f2e:	701a      	strb	r2, [r3, #0]
  ep->maxpacket = (uint32_t)ep_mps & 0x7FFU;
34188f30:	883b      	ldrh	r3, [r7, #0]
34188f32:	f3c3 020a 	ubfx	r2, r3, #0, #11
34188f36:	68fb      	ldr	r3, [r7, #12]
34188f38:	609a      	str	r2, [r3, #8]
  ep->type = ep_type;
34188f3a:	68fb      	ldr	r3, [r7, #12]
34188f3c:	78ba      	ldrb	r2, [r7, #2]
34188f3e:	711a      	strb	r2, [r3, #4]

  if (ep->is_in != 0U)
34188f40:	68fb      	ldr	r3, [r7, #12]
34188f42:	785b      	ldrb	r3, [r3, #1]
34188f44:	2b00      	cmp	r3, #0
34188f46:	d004      	beq.n	34188f52 <HAL_PCD_EP_Open+0x94>
  {
    /* Assign a Tx FIFO */
    ep->tx_fifo_num = ep->num;
34188f48:	68fb      	ldr	r3, [r7, #12]
34188f4a:	781b      	ldrb	r3, [r3, #0]
34188f4c:	461a      	mov	r2, r3
34188f4e:	68fb      	ldr	r3, [r7, #12]
34188f50:	835a      	strh	r2, [r3, #26]
  }

  /* Set initial data PID. */
  if (ep_type == EP_TYPE_BULK)
34188f52:	78bb      	ldrb	r3, [r7, #2]
34188f54:	2b02      	cmp	r3, #2
34188f56:	d102      	bne.n	34188f5e <HAL_PCD_EP_Open+0xa0>
  {
    ep->data_pid_start = 0U;
34188f58:	68fb      	ldr	r3, [r7, #12]
34188f5a:	2200      	movs	r2, #0
34188f5c:	715a      	strb	r2, [r3, #5]
  }

  __HAL_LOCK(hpcd);
34188f5e:	687b      	ldr	r3, [r7, #4]
34188f60:	f893 3494 	ldrb.w	r3, [r3, #1172]	@ 0x494
34188f64:	2b01      	cmp	r3, #1
34188f66:	d101      	bne.n	34188f6c <HAL_PCD_EP_Open+0xae>
34188f68:	2302      	movs	r3, #2
34188f6a:	e00e      	b.n	34188f8a <HAL_PCD_EP_Open+0xcc>
34188f6c:	687b      	ldr	r3, [r7, #4]
34188f6e:	2201      	movs	r2, #1
34188f70:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494
  (void)USB_ActivateEndpoint(hpcd->Instance, ep);
34188f74:	687b      	ldr	r3, [r7, #4]
34188f76:	681b      	ldr	r3, [r3, #0]
34188f78:	68f9      	ldr	r1, [r7, #12]
34188f7a:	4618      	mov	r0, r3
34188f7c:	f009 fc30 	bl	341927e0 <USB_ActivateEndpoint>
  __HAL_UNLOCK(hpcd);
34188f80:	687b      	ldr	r3, [r7, #4]
34188f82:	2200      	movs	r2, #0
34188f84:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  return ret;
34188f88:	7afb      	ldrb	r3, [r7, #11]
}
34188f8a:	4618      	mov	r0, r3
34188f8c:	3710      	adds	r7, #16
34188f8e:	46bd      	mov	sp, r7
34188f90:	bd80      	pop	{r7, pc}

34188f92 <HAL_PCD_EP_Close>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Close(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
34188f92:	b580      	push	{r7, lr}
34188f94:	b084      	sub	sp, #16
34188f96:	af00      	add	r7, sp, #0
34188f98:	6078      	str	r0, [r7, #4]
34188f9a:	460b      	mov	r3, r1
34188f9c:	70fb      	strb	r3, [r7, #3]
  PCD_EPTypeDef *ep;

  if ((ep_addr & 0x80U) == 0x80U)
34188f9e:	f997 3003 	ldrsb.w	r3, [r7, #3]
34188fa2:	2b00      	cmp	r3, #0
34188fa4:	da0f      	bge.n	34188fc6 <HAL_PCD_EP_Close+0x34>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
34188fa6:	78fb      	ldrb	r3, [r7, #3]
34188fa8:	f003 020f 	and.w	r2, r3, #15
34188fac:	4613      	mov	r3, r2
34188fae:	00db      	lsls	r3, r3, #3
34188fb0:	4413      	add	r3, r2
34188fb2:	009b      	lsls	r3, r3, #2
34188fb4:	3310      	adds	r3, #16
34188fb6:	687a      	ldr	r2, [r7, #4]
34188fb8:	4413      	add	r3, r2
34188fba:	3304      	adds	r3, #4
34188fbc:	60fb      	str	r3, [r7, #12]
    ep->is_in = 1U;
34188fbe:	68fb      	ldr	r3, [r7, #12]
34188fc0:	2201      	movs	r2, #1
34188fc2:	705a      	strb	r2, [r3, #1]
34188fc4:	e00f      	b.n	34188fe6 <HAL_PCD_EP_Close+0x54>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
34188fc6:	78fb      	ldrb	r3, [r7, #3]
34188fc8:	f003 020f 	and.w	r2, r3, #15
34188fcc:	4613      	mov	r3, r2
34188fce:	00db      	lsls	r3, r3, #3
34188fd0:	4413      	add	r3, r2
34188fd2:	009b      	lsls	r3, r3, #2
34188fd4:	f503 7314 	add.w	r3, r3, #592	@ 0x250
34188fd8:	687a      	ldr	r2, [r7, #4]
34188fda:	4413      	add	r3, r2
34188fdc:	3304      	adds	r3, #4
34188fde:	60fb      	str	r3, [r7, #12]
    ep->is_in = 0U;
34188fe0:	68fb      	ldr	r3, [r7, #12]
34188fe2:	2200      	movs	r2, #0
34188fe4:	705a      	strb	r2, [r3, #1]
  }
  ep->num = ep_addr & EP_ADDR_MSK;
34188fe6:	78fb      	ldrb	r3, [r7, #3]
34188fe8:	f003 030f 	and.w	r3, r3, #15
34188fec:	b2da      	uxtb	r2, r3
34188fee:	68fb      	ldr	r3, [r7, #12]
34188ff0:	701a      	strb	r2, [r3, #0]

  __HAL_LOCK(hpcd);
34188ff2:	687b      	ldr	r3, [r7, #4]
34188ff4:	f893 3494 	ldrb.w	r3, [r3, #1172]	@ 0x494
34188ff8:	2b01      	cmp	r3, #1
34188ffa:	d101      	bne.n	34189000 <HAL_PCD_EP_Close+0x6e>
34188ffc:	2302      	movs	r3, #2
34188ffe:	e00e      	b.n	3418901e <HAL_PCD_EP_Close+0x8c>
34189000:	687b      	ldr	r3, [r7, #4]
34189002:	2201      	movs	r2, #1
34189004:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494
  (void)USB_DeactivateEndpoint(hpcd->Instance, ep);
34189008:	687b      	ldr	r3, [r7, #4]
3418900a:	681b      	ldr	r3, [r3, #0]
3418900c:	68f9      	ldr	r1, [r7, #12]
3418900e:	4618      	mov	r0, r3
34189010:	f009 fc6e 	bl	341928f0 <USB_DeactivateEndpoint>
  __HAL_UNLOCK(hpcd);
34189014:	687b      	ldr	r3, [r7, #4]
34189016:	2200      	movs	r2, #0
34189018:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494
  return HAL_OK;
3418901c:	2300      	movs	r3, #0
}
3418901e:	4618      	mov	r0, r3
34189020:	3710      	adds	r7, #16
34189022:	46bd      	mov	sp, r7
34189024:	bd80      	pop	{r7, pc}

34189026 <HAL_PCD_EP_Receive>:
  * @param  pBuf pointer to the reception buffer
  * @param  len amount of data to be received
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Receive(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
34189026:	b580      	push	{r7, lr}
34189028:	b086      	sub	sp, #24
3418902a:	af00      	add	r7, sp, #0
3418902c:	60f8      	str	r0, [r7, #12]
3418902e:	607a      	str	r2, [r7, #4]
34189030:	603b      	str	r3, [r7, #0]
34189032:	460b      	mov	r3, r1
34189034:	72fb      	strb	r3, [r7, #11]
  PCD_EPTypeDef *ep;

  ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
34189036:	7afb      	ldrb	r3, [r7, #11]
34189038:	f003 020f 	and.w	r2, r3, #15
3418903c:	4613      	mov	r3, r2
3418903e:	00db      	lsls	r3, r3, #3
34189040:	4413      	add	r3, r2
34189042:	009b      	lsls	r3, r3, #2
34189044:	f503 7314 	add.w	r3, r3, #592	@ 0x250
34189048:	68fa      	ldr	r2, [r7, #12]
3418904a:	4413      	add	r3, r2
3418904c:	3304      	adds	r3, #4
3418904e:	617b      	str	r3, [r7, #20]

  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;
34189050:	697b      	ldr	r3, [r7, #20]
34189052:	687a      	ldr	r2, [r7, #4]
34189054:	60da      	str	r2, [r3, #12]
  ep->xfer_len = len;
34189056:	697b      	ldr	r3, [r7, #20]
34189058:	683a      	ldr	r2, [r7, #0]
3418905a:	611a      	str	r2, [r3, #16]
  ep->xfer_count = 0U;
3418905c:	697b      	ldr	r3, [r7, #20]
3418905e:	2200      	movs	r2, #0
34189060:	615a      	str	r2, [r3, #20]
  ep->is_in = 0U;
34189062:	697b      	ldr	r3, [r7, #20]
34189064:	2200      	movs	r2, #0
34189066:	705a      	strb	r2, [r3, #1]
  ep->num = ep_addr & EP_ADDR_MSK;
34189068:	7afb      	ldrb	r3, [r7, #11]
3418906a:	f003 030f 	and.w	r3, r3, #15
3418906e:	b2da      	uxtb	r2, r3
34189070:	697b      	ldr	r3, [r7, #20]
34189072:	701a      	strb	r2, [r3, #0]

  if (hpcd->Init.dma_enable == 1U)
34189074:	68fb      	ldr	r3, [r7, #12]
34189076:	799b      	ldrb	r3, [r3, #6]
34189078:	2b01      	cmp	r3, #1
3418907a:	d102      	bne.n	34189082 <HAL_PCD_EP_Receive+0x5c>
  {
    ep->dma_addr = (uint32_t)pBuf;
3418907c:	687a      	ldr	r2, [r7, #4]
3418907e:	697b      	ldr	r3, [r7, #20]
34189080:	61da      	str	r2, [r3, #28]
  }

  (void)USB_EPStartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
34189082:	68fb      	ldr	r3, [r7, #12]
34189084:	6818      	ldr	r0, [r3, #0]
34189086:	68fb      	ldr	r3, [r7, #12]
34189088:	799b      	ldrb	r3, [r3, #6]
3418908a:	461a      	mov	r2, r3
3418908c:	6979      	ldr	r1, [r7, #20]
3418908e:	f009 fd0b 	bl	34192aa8 <USB_EPStartXfer>

  return HAL_OK;
34189092:	2300      	movs	r3, #0
}
34189094:	4618      	mov	r0, r3
34189096:	3718      	adds	r7, #24
34189098:	46bd      	mov	sp, r7
3418909a:	bd80      	pop	{r7, pc}

3418909c <HAL_PCD_EP_GetRxCount>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval Data Size
  */
uint32_t HAL_PCD_EP_GetRxCount(PCD_HandleTypeDef const *hpcd, uint8_t ep_addr)
{
3418909c:	b480      	push	{r7}
3418909e:	b083      	sub	sp, #12
341890a0:	af00      	add	r7, sp, #0
341890a2:	6078      	str	r0, [r7, #4]
341890a4:	460b      	mov	r3, r1
341890a6:	70fb      	strb	r3, [r7, #3]
  return hpcd->OUT_ep[ep_addr & EP_ADDR_MSK].xfer_count;
341890a8:	78fb      	ldrb	r3, [r7, #3]
341890aa:	f003 020f 	and.w	r2, r3, #15
341890ae:	6879      	ldr	r1, [r7, #4]
341890b0:	4613      	mov	r3, r2
341890b2:	00db      	lsls	r3, r3, #3
341890b4:	4413      	add	r3, r2
341890b6:	009b      	lsls	r3, r3, #2
341890b8:	440b      	add	r3, r1
341890ba:	f503 731a 	add.w	r3, r3, #616	@ 0x268
341890be:	681b      	ldr	r3, [r3, #0]
}
341890c0:	4618      	mov	r0, r3
341890c2:	370c      	adds	r7, #12
341890c4:	46bd      	mov	sp, r7
341890c6:	f85d 7b04 	ldr.w	r7, [sp], #4
341890ca:	4770      	bx	lr

341890cc <HAL_PCD_EP_Transmit>:
  * @param  pBuf pointer to the transmission buffer
  * @param  len amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Transmit(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
341890cc:	b580      	push	{r7, lr}
341890ce:	b086      	sub	sp, #24
341890d0:	af00      	add	r7, sp, #0
341890d2:	60f8      	str	r0, [r7, #12]
341890d4:	607a      	str	r2, [r7, #4]
341890d6:	603b      	str	r3, [r7, #0]
341890d8:	460b      	mov	r3, r1
341890da:	72fb      	strb	r3, [r7, #11]
  PCD_EPTypeDef *ep;

  ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
341890dc:	7afb      	ldrb	r3, [r7, #11]
341890de:	f003 020f 	and.w	r2, r3, #15
341890e2:	4613      	mov	r3, r2
341890e4:	00db      	lsls	r3, r3, #3
341890e6:	4413      	add	r3, r2
341890e8:	009b      	lsls	r3, r3, #2
341890ea:	3310      	adds	r3, #16
341890ec:	68fa      	ldr	r2, [r7, #12]
341890ee:	4413      	add	r3, r2
341890f0:	3304      	adds	r3, #4
341890f2:	617b      	str	r3, [r7, #20]

  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;
341890f4:	697b      	ldr	r3, [r7, #20]
341890f6:	687a      	ldr	r2, [r7, #4]
341890f8:	60da      	str	r2, [r3, #12]
  ep->xfer_len = len;
341890fa:	697b      	ldr	r3, [r7, #20]
341890fc:	683a      	ldr	r2, [r7, #0]
341890fe:	611a      	str	r2, [r3, #16]
  ep->xfer_count = 0U;
34189100:	697b      	ldr	r3, [r7, #20]
34189102:	2200      	movs	r2, #0
34189104:	615a      	str	r2, [r3, #20]
  ep->is_in = 1U;
34189106:	697b      	ldr	r3, [r7, #20]
34189108:	2201      	movs	r2, #1
3418910a:	705a      	strb	r2, [r3, #1]
  ep->num = ep_addr & EP_ADDR_MSK;
3418910c:	7afb      	ldrb	r3, [r7, #11]
3418910e:	f003 030f 	and.w	r3, r3, #15
34189112:	b2da      	uxtb	r2, r3
34189114:	697b      	ldr	r3, [r7, #20]
34189116:	701a      	strb	r2, [r3, #0]

  if (hpcd->Init.dma_enable == 1U)
34189118:	68fb      	ldr	r3, [r7, #12]
3418911a:	799b      	ldrb	r3, [r3, #6]
3418911c:	2b01      	cmp	r3, #1
3418911e:	d102      	bne.n	34189126 <HAL_PCD_EP_Transmit+0x5a>
  {
    ep->dma_addr = (uint32_t)pBuf;
34189120:	687a      	ldr	r2, [r7, #4]
34189122:	697b      	ldr	r3, [r7, #20]
34189124:	61da      	str	r2, [r3, #28]
  }

  (void)USB_EPStartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
34189126:	68fb      	ldr	r3, [r7, #12]
34189128:	6818      	ldr	r0, [r3, #0]
3418912a:	68fb      	ldr	r3, [r7, #12]
3418912c:	799b      	ldrb	r3, [r3, #6]
3418912e:	461a      	mov	r2, r3
34189130:	6979      	ldr	r1, [r7, #20]
34189132:	f009 fcb9 	bl	34192aa8 <USB_EPStartXfer>

  return HAL_OK;
34189136:	2300      	movs	r3, #0
}
34189138:	4618      	mov	r0, r3
3418913a:	3718      	adds	r7, #24
3418913c:	46bd      	mov	sp, r7
3418913e:	bd80      	pop	{r7, pc}

34189140 <HAL_PCD_EP_SetStall>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_SetStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
34189140:	b580      	push	{r7, lr}
34189142:	b084      	sub	sp, #16
34189144:	af00      	add	r7, sp, #0
34189146:	6078      	str	r0, [r7, #4]
34189148:	460b      	mov	r3, r1
3418914a:	70fb      	strb	r3, [r7, #3]
  PCD_EPTypeDef *ep;

  if (((uint32_t)ep_addr & EP_ADDR_MSK) > hpcd->Init.dev_endpoints)
3418914c:	78fb      	ldrb	r3, [r7, #3]
3418914e:	f003 030f 	and.w	r3, r3, #15
34189152:	687a      	ldr	r2, [r7, #4]
34189154:	7912      	ldrb	r2, [r2, #4]
34189156:	4293      	cmp	r3, r2
34189158:	d901      	bls.n	3418915e <HAL_PCD_EP_SetStall+0x1e>
  {
    return HAL_ERROR;
3418915a:	2301      	movs	r3, #1
3418915c:	e04f      	b.n	341891fe <HAL_PCD_EP_SetStall+0xbe>
  }

  if ((0x80U & ep_addr) == 0x80U)
3418915e:	f997 3003 	ldrsb.w	r3, [r7, #3]
34189162:	2b00      	cmp	r3, #0
34189164:	da0f      	bge.n	34189186 <HAL_PCD_EP_SetStall+0x46>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
34189166:	78fb      	ldrb	r3, [r7, #3]
34189168:	f003 020f 	and.w	r2, r3, #15
3418916c:	4613      	mov	r3, r2
3418916e:	00db      	lsls	r3, r3, #3
34189170:	4413      	add	r3, r2
34189172:	009b      	lsls	r3, r3, #2
34189174:	3310      	adds	r3, #16
34189176:	687a      	ldr	r2, [r7, #4]
34189178:	4413      	add	r3, r2
3418917a:	3304      	adds	r3, #4
3418917c:	60fb      	str	r3, [r7, #12]
    ep->is_in = 1U;
3418917e:	68fb      	ldr	r3, [r7, #12]
34189180:	2201      	movs	r2, #1
34189182:	705a      	strb	r2, [r3, #1]
34189184:	e00d      	b.n	341891a2 <HAL_PCD_EP_SetStall+0x62>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
34189186:	78fa      	ldrb	r2, [r7, #3]
34189188:	4613      	mov	r3, r2
3418918a:	00db      	lsls	r3, r3, #3
3418918c:	4413      	add	r3, r2
3418918e:	009b      	lsls	r3, r3, #2
34189190:	f503 7314 	add.w	r3, r3, #592	@ 0x250
34189194:	687a      	ldr	r2, [r7, #4]
34189196:	4413      	add	r3, r2
34189198:	3304      	adds	r3, #4
3418919a:	60fb      	str	r3, [r7, #12]
    ep->is_in = 0U;
3418919c:	68fb      	ldr	r3, [r7, #12]
3418919e:	2200      	movs	r2, #0
341891a0:	705a      	strb	r2, [r3, #1]
  }

  ep->is_stall = 1U;
341891a2:	68fb      	ldr	r3, [r7, #12]
341891a4:	2201      	movs	r2, #1
341891a6:	709a      	strb	r2, [r3, #2]
  ep->num = ep_addr & EP_ADDR_MSK;
341891a8:	78fb      	ldrb	r3, [r7, #3]
341891aa:	f003 030f 	and.w	r3, r3, #15
341891ae:	b2da      	uxtb	r2, r3
341891b0:	68fb      	ldr	r3, [r7, #12]
341891b2:	701a      	strb	r2, [r3, #0]

  __HAL_LOCK(hpcd);
341891b4:	687b      	ldr	r3, [r7, #4]
341891b6:	f893 3494 	ldrb.w	r3, [r3, #1172]	@ 0x494
341891ba:	2b01      	cmp	r3, #1
341891bc:	d101      	bne.n	341891c2 <HAL_PCD_EP_SetStall+0x82>
341891be:	2302      	movs	r3, #2
341891c0:	e01d      	b.n	341891fe <HAL_PCD_EP_SetStall+0xbe>
341891c2:	687b      	ldr	r3, [r7, #4]
341891c4:	2201      	movs	r2, #1
341891c6:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  (void)USB_EPSetStall(hpcd->Instance, ep);
341891ca:	687b      	ldr	r3, [r7, #4]
341891cc:	681b      	ldr	r3, [r3, #0]
341891ce:	68f9      	ldr	r1, [r7, #12]
341891d0:	4618      	mov	r0, r3
341891d2:	f00a f847 	bl	34193264 <USB_EPSetStall>

  if ((ep_addr & EP_ADDR_MSK) == 0U)
341891d6:	78fb      	ldrb	r3, [r7, #3]
341891d8:	f003 030f 	and.w	r3, r3, #15
341891dc:	2b00      	cmp	r3, #0
341891de:	d109      	bne.n	341891f4 <HAL_PCD_EP_SetStall+0xb4>
  {
    (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
341891e0:	687b      	ldr	r3, [r7, #4]
341891e2:	6818      	ldr	r0, [r3, #0]
341891e4:	687b      	ldr	r3, [r7, #4]
341891e6:	7999      	ldrb	r1, [r3, #6]
341891e8:	687b      	ldr	r3, [r7, #4]
341891ea:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
341891ee:	461a      	mov	r2, r3
341891f0:	f00a fa38 	bl	34193664 <USB_EP0_OutStart>
  }

  __HAL_UNLOCK(hpcd);
341891f4:	687b      	ldr	r3, [r7, #4]
341891f6:	2200      	movs	r2, #0
341891f8:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  return HAL_OK;
341891fc:	2300      	movs	r3, #0
}
341891fe:	4618      	mov	r0, r3
34189200:	3710      	adds	r7, #16
34189202:	46bd      	mov	sp, r7
34189204:	bd80      	pop	{r7, pc}

34189206 <HAL_PCD_EP_ClrStall>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_ClrStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
34189206:	b580      	push	{r7, lr}
34189208:	b084      	sub	sp, #16
3418920a:	af00      	add	r7, sp, #0
3418920c:	6078      	str	r0, [r7, #4]
3418920e:	460b      	mov	r3, r1
34189210:	70fb      	strb	r3, [r7, #3]
  PCD_EPTypeDef *ep;

  if (((uint32_t)ep_addr & 0x0FU) > hpcd->Init.dev_endpoints)
34189212:	78fb      	ldrb	r3, [r7, #3]
34189214:	f003 030f 	and.w	r3, r3, #15
34189218:	687a      	ldr	r2, [r7, #4]
3418921a:	7912      	ldrb	r2, [r2, #4]
3418921c:	4293      	cmp	r3, r2
3418921e:	d901      	bls.n	34189224 <HAL_PCD_EP_ClrStall+0x1e>
  {
    return HAL_ERROR;
34189220:	2301      	movs	r3, #1
34189222:	e042      	b.n	341892aa <HAL_PCD_EP_ClrStall+0xa4>
  }

  if ((0x80U & ep_addr) == 0x80U)
34189224:	f997 3003 	ldrsb.w	r3, [r7, #3]
34189228:	2b00      	cmp	r3, #0
3418922a:	da0f      	bge.n	3418924c <HAL_PCD_EP_ClrStall+0x46>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
3418922c:	78fb      	ldrb	r3, [r7, #3]
3418922e:	f003 020f 	and.w	r2, r3, #15
34189232:	4613      	mov	r3, r2
34189234:	00db      	lsls	r3, r3, #3
34189236:	4413      	add	r3, r2
34189238:	009b      	lsls	r3, r3, #2
3418923a:	3310      	adds	r3, #16
3418923c:	687a      	ldr	r2, [r7, #4]
3418923e:	4413      	add	r3, r2
34189240:	3304      	adds	r3, #4
34189242:	60fb      	str	r3, [r7, #12]
    ep->is_in = 1U;
34189244:	68fb      	ldr	r3, [r7, #12]
34189246:	2201      	movs	r2, #1
34189248:	705a      	strb	r2, [r3, #1]
3418924a:	e00f      	b.n	3418926c <HAL_PCD_EP_ClrStall+0x66>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
3418924c:	78fb      	ldrb	r3, [r7, #3]
3418924e:	f003 020f 	and.w	r2, r3, #15
34189252:	4613      	mov	r3, r2
34189254:	00db      	lsls	r3, r3, #3
34189256:	4413      	add	r3, r2
34189258:	009b      	lsls	r3, r3, #2
3418925a:	f503 7314 	add.w	r3, r3, #592	@ 0x250
3418925e:	687a      	ldr	r2, [r7, #4]
34189260:	4413      	add	r3, r2
34189262:	3304      	adds	r3, #4
34189264:	60fb      	str	r3, [r7, #12]
    ep->is_in = 0U;
34189266:	68fb      	ldr	r3, [r7, #12]
34189268:	2200      	movs	r2, #0
3418926a:	705a      	strb	r2, [r3, #1]
  }

  ep->is_stall = 0U;
3418926c:	68fb      	ldr	r3, [r7, #12]
3418926e:	2200      	movs	r2, #0
34189270:	709a      	strb	r2, [r3, #2]
  ep->num = ep_addr & EP_ADDR_MSK;
34189272:	78fb      	ldrb	r3, [r7, #3]
34189274:	f003 030f 	and.w	r3, r3, #15
34189278:	b2da      	uxtb	r2, r3
3418927a:	68fb      	ldr	r3, [r7, #12]
3418927c:	701a      	strb	r2, [r3, #0]

  __HAL_LOCK(hpcd);
3418927e:	687b      	ldr	r3, [r7, #4]
34189280:	f893 3494 	ldrb.w	r3, [r3, #1172]	@ 0x494
34189284:	2b01      	cmp	r3, #1
34189286:	d101      	bne.n	3418928c <HAL_PCD_EP_ClrStall+0x86>
34189288:	2302      	movs	r3, #2
3418928a:	e00e      	b.n	341892aa <HAL_PCD_EP_ClrStall+0xa4>
3418928c:	687b      	ldr	r3, [r7, #4]
3418928e:	2201      	movs	r2, #1
34189290:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494
  (void)USB_EPClearStall(hpcd->Instance, ep);
34189294:	687b      	ldr	r3, [r7, #4]
34189296:	681b      	ldr	r3, [r3, #0]
34189298:	68f9      	ldr	r1, [r7, #12]
3418929a:	4618      	mov	r0, r3
3418929c:	f00a f850 	bl	34193340 <USB_EPClearStall>
  __HAL_UNLOCK(hpcd);
341892a0:	687b      	ldr	r3, [r7, #4]
341892a2:	2200      	movs	r2, #0
341892a4:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  return HAL_OK;
341892a8:	2300      	movs	r3, #0
}
341892aa:	4618      	mov	r0, r3
341892ac:	3710      	adds	r7, #16
341892ae:	46bd      	mov	sp, r7
341892b0:	bd80      	pop	{r7, pc}

341892b2 <HAL_PCD_EP_Abort>:
   * @param  hpcd PCD handle
   * @param  ep_addr endpoint address
   * @retval HAL status
   */
HAL_StatusTypeDef HAL_PCD_EP_Abort(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
341892b2:	b580      	push	{r7, lr}
341892b4:	b084      	sub	sp, #16
341892b6:	af00      	add	r7, sp, #0
341892b8:	6078      	str	r0, [r7, #4]
341892ba:	460b      	mov	r3, r1
341892bc:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef ret;
  PCD_EPTypeDef *ep;

  if ((0x80U & ep_addr) == 0x80U)
341892be:	f997 3003 	ldrsb.w	r3, [r7, #3]
341892c2:	2b00      	cmp	r3, #0
341892c4:	da0c      	bge.n	341892e0 <HAL_PCD_EP_Abort+0x2e>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
341892c6:	78fb      	ldrb	r3, [r7, #3]
341892c8:	f003 020f 	and.w	r2, r3, #15
341892cc:	4613      	mov	r3, r2
341892ce:	00db      	lsls	r3, r3, #3
341892d0:	4413      	add	r3, r2
341892d2:	009b      	lsls	r3, r3, #2
341892d4:	3310      	adds	r3, #16
341892d6:	687a      	ldr	r2, [r7, #4]
341892d8:	4413      	add	r3, r2
341892da:	3304      	adds	r3, #4
341892dc:	60fb      	str	r3, [r7, #12]
341892de:	e00c      	b.n	341892fa <HAL_PCD_EP_Abort+0x48>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
341892e0:	78fb      	ldrb	r3, [r7, #3]
341892e2:	f003 020f 	and.w	r2, r3, #15
341892e6:	4613      	mov	r3, r2
341892e8:	00db      	lsls	r3, r3, #3
341892ea:	4413      	add	r3, r2
341892ec:	009b      	lsls	r3, r3, #2
341892ee:	f503 7314 	add.w	r3, r3, #592	@ 0x250
341892f2:	687a      	ldr	r2, [r7, #4]
341892f4:	4413      	add	r3, r2
341892f6:	3304      	adds	r3, #4
341892f8:	60fb      	str	r3, [r7, #12]
  }

  /* Stop Xfer */
  ret = USB_EPStopXfer(hpcd->Instance, ep);
341892fa:	687b      	ldr	r3, [r7, #4]
341892fc:	681b      	ldr	r3, [r3, #0]
341892fe:	68f9      	ldr	r1, [r7, #12]
34189300:	4618      	mov	r0, r3
34189302:	f009 fe6f 	bl	34192fe4 <USB_EPStopXfer>
34189306:	4603      	mov	r3, r0
34189308:	72fb      	strb	r3, [r7, #11]

  return ret;
3418930a:	7afb      	ldrb	r3, [r7, #11]
}
3418930c:	4618      	mov	r0, r3
3418930e:	3710      	adds	r7, #16
34189310:	46bd      	mov	sp, r7
34189312:	bd80      	pop	{r7, pc}

34189314 <HAL_PCD_EP_Flush>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Flush(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
34189314:	b580      	push	{r7, lr}
34189316:	b082      	sub	sp, #8
34189318:	af00      	add	r7, sp, #0
3418931a:	6078      	str	r0, [r7, #4]
3418931c:	460b      	mov	r3, r1
3418931e:	70fb      	strb	r3, [r7, #3]
  __HAL_LOCK(hpcd);
34189320:	687b      	ldr	r3, [r7, #4]
34189322:	f893 3494 	ldrb.w	r3, [r3, #1172]	@ 0x494
34189326:	2b01      	cmp	r3, #1
34189328:	d101      	bne.n	3418932e <HAL_PCD_EP_Flush+0x1a>
3418932a:	2302      	movs	r3, #2
3418932c:	e01b      	b.n	34189366 <HAL_PCD_EP_Flush+0x52>
3418932e:	687b      	ldr	r3, [r7, #4]
34189330:	2201      	movs	r2, #1
34189332:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  if ((ep_addr & 0x80U) == 0x80U)
34189336:	f997 3003 	ldrsb.w	r3, [r7, #3]
3418933a:	2b00      	cmp	r3, #0
3418933c:	da09      	bge.n	34189352 <HAL_PCD_EP_Flush+0x3e>
  {
    (void)USB_FlushTxFifo(hpcd->Instance, (uint32_t)ep_addr & EP_ADDR_MSK);
3418933e:	687b      	ldr	r3, [r7, #4]
34189340:	681a      	ldr	r2, [r3, #0]
34189342:	78fb      	ldrb	r3, [r7, #3]
34189344:	f003 030f 	and.w	r3, r3, #15
34189348:	4619      	mov	r1, r3
3418934a:	4610      	mov	r0, r2
3418934c:	f009 f9aa 	bl	341926a4 <USB_FlushTxFifo>
34189350:	e004      	b.n	3418935c <HAL_PCD_EP_Flush+0x48>
  }
  else
  {
    (void)USB_FlushRxFifo(hpcd->Instance);
34189352:	687b      	ldr	r3, [r7, #4]
34189354:	681b      	ldr	r3, [r3, #0]
34189356:	4618      	mov	r0, r3
34189358:	f009 f9d6 	bl	34192708 <USB_FlushRxFifo>
  }

  __HAL_UNLOCK(hpcd);
3418935c:	687b      	ldr	r3, [r7, #4]
3418935e:	2200      	movs	r2, #0
34189360:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  return HAL_OK;
34189364:	2300      	movs	r3, #0
}
34189366:	4618      	mov	r0, r3
34189368:	3708      	adds	r7, #8
3418936a:	46bd      	mov	sp, r7
3418936c:	bd80      	pop	{r7, pc}

3418936e <PCD_WriteEmptyTxFifo>:
  * @param  hpcd PCD handle
  * @param  epnum endpoint number
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_WriteEmptyTxFifo(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
3418936e:	b580      	push	{r7, lr}
34189370:	b08a      	sub	sp, #40	@ 0x28
34189372:	af02      	add	r7, sp, #8
34189374:	6078      	str	r0, [r7, #4]
34189376:	6039      	str	r1, [r7, #0]
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
34189378:	687b      	ldr	r3, [r7, #4]
3418937a:	681b      	ldr	r3, [r3, #0]
3418937c:	617b      	str	r3, [r7, #20]
  uint32_t USBx_BASE = (uint32_t)USBx;
3418937e:	697b      	ldr	r3, [r7, #20]
34189380:	613b      	str	r3, [r7, #16]
  USB_OTG_EPTypeDef *ep;
  uint32_t len;
  uint32_t len32b;
  uint32_t fifoemptymsk;

  ep = &hpcd->IN_ep[epnum];
34189382:	683a      	ldr	r2, [r7, #0]
34189384:	4613      	mov	r3, r2
34189386:	00db      	lsls	r3, r3, #3
34189388:	4413      	add	r3, r2
3418938a:	009b      	lsls	r3, r3, #2
3418938c:	3310      	adds	r3, #16
3418938e:	687a      	ldr	r2, [r7, #4]
34189390:	4413      	add	r3, r2
34189392:	3304      	adds	r3, #4
34189394:	60fb      	str	r3, [r7, #12]

  if (ep->xfer_count > ep->xfer_len)
34189396:	68fb      	ldr	r3, [r7, #12]
34189398:	695a      	ldr	r2, [r3, #20]
3418939a:	68fb      	ldr	r3, [r7, #12]
3418939c:	691b      	ldr	r3, [r3, #16]
3418939e:	429a      	cmp	r2, r3
341893a0:	d901      	bls.n	341893a6 <PCD_WriteEmptyTxFifo+0x38>
  {
    return HAL_ERROR;
341893a2:	2301      	movs	r3, #1
341893a4:	e06b      	b.n	3418947e <PCD_WriteEmptyTxFifo+0x110>
  }

  len = ep->xfer_len - ep->xfer_count;
341893a6:	68fb      	ldr	r3, [r7, #12]
341893a8:	691a      	ldr	r2, [r3, #16]
341893aa:	68fb      	ldr	r3, [r7, #12]
341893ac:	695b      	ldr	r3, [r3, #20]
341893ae:	1ad3      	subs	r3, r2, r3
341893b0:	61fb      	str	r3, [r7, #28]

  if (len > ep->maxpacket)
341893b2:	68fb      	ldr	r3, [r7, #12]
341893b4:	689b      	ldr	r3, [r3, #8]
341893b6:	69fa      	ldr	r2, [r7, #28]
341893b8:	429a      	cmp	r2, r3
341893ba:	d902      	bls.n	341893c2 <PCD_WriteEmptyTxFifo+0x54>
  {
    len = ep->maxpacket;
341893bc:	68fb      	ldr	r3, [r7, #12]
341893be:	689b      	ldr	r3, [r3, #8]
341893c0:	61fb      	str	r3, [r7, #28]
  }

  len32b = (len + 3U) / 4U;
341893c2:	69fb      	ldr	r3, [r7, #28]
341893c4:	3303      	adds	r3, #3
341893c6:	089b      	lsrs	r3, r3, #2
341893c8:	61bb      	str	r3, [r7, #24]

  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
341893ca:	e02a      	b.n	34189422 <PCD_WriteEmptyTxFifo+0xb4>
         (ep->xfer_count < ep->xfer_len) && (ep->xfer_len != 0U))
  {
    /* Write the FIFO */
    len = ep->xfer_len - ep->xfer_count;
341893cc:	68fb      	ldr	r3, [r7, #12]
341893ce:	691a      	ldr	r2, [r3, #16]
341893d0:	68fb      	ldr	r3, [r7, #12]
341893d2:	695b      	ldr	r3, [r3, #20]
341893d4:	1ad3      	subs	r3, r2, r3
341893d6:	61fb      	str	r3, [r7, #28]

    if (len > ep->maxpacket)
341893d8:	68fb      	ldr	r3, [r7, #12]
341893da:	689b      	ldr	r3, [r3, #8]
341893dc:	69fa      	ldr	r2, [r7, #28]
341893de:	429a      	cmp	r2, r3
341893e0:	d902      	bls.n	341893e8 <PCD_WriteEmptyTxFifo+0x7a>
    {
      len = ep->maxpacket;
341893e2:	68fb      	ldr	r3, [r7, #12]
341893e4:	689b      	ldr	r3, [r3, #8]
341893e6:	61fb      	str	r3, [r7, #28]
    }
    len32b = (len + 3U) / 4U;
341893e8:	69fb      	ldr	r3, [r7, #28]
341893ea:	3303      	adds	r3, #3
341893ec:	089b      	lsrs	r3, r3, #2
341893ee:	61bb      	str	r3, [r7, #24]

    (void)USB_WritePacket(USBx, ep->xfer_buff, (uint8_t)epnum, (uint16_t)len,
341893f0:	68fb      	ldr	r3, [r7, #12]
341893f2:	68d9      	ldr	r1, [r3, #12]
341893f4:	683b      	ldr	r3, [r7, #0]
341893f6:	b2da      	uxtb	r2, r3
341893f8:	69fb      	ldr	r3, [r7, #28]
341893fa:	b298      	uxth	r0, r3
                          (uint8_t)hpcd->Init.dma_enable);
341893fc:	687b      	ldr	r3, [r7, #4]
341893fe:	799b      	ldrb	r3, [r3, #6]
    (void)USB_WritePacket(USBx, ep->xfer_buff, (uint8_t)epnum, (uint16_t)len,
34189400:	9300      	str	r3, [sp, #0]
34189402:	4603      	mov	r3, r0
34189404:	6978      	ldr	r0, [r7, #20]
34189406:	f009 fe97 	bl	34193138 <USB_WritePacket>

    ep->xfer_buff  += len;
3418940a:	68fb      	ldr	r3, [r7, #12]
3418940c:	68da      	ldr	r2, [r3, #12]
3418940e:	69fb      	ldr	r3, [r7, #28]
34189410:	441a      	add	r2, r3
34189412:	68fb      	ldr	r3, [r7, #12]
34189414:	60da      	str	r2, [r3, #12]
    ep->xfer_count += len;
34189416:	68fb      	ldr	r3, [r7, #12]
34189418:	695a      	ldr	r2, [r3, #20]
3418941a:	69fb      	ldr	r3, [r7, #28]
3418941c:	441a      	add	r2, r3
3418941e:	68fb      	ldr	r3, [r7, #12]
34189420:	615a      	str	r2, [r3, #20]
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
34189422:	683b      	ldr	r3, [r7, #0]
34189424:	015a      	lsls	r2, r3, #5
34189426:	693b      	ldr	r3, [r7, #16]
34189428:	4413      	add	r3, r2
3418942a:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
3418942e:	699b      	ldr	r3, [r3, #24]
34189430:	b29b      	uxth	r3, r3
         (ep->xfer_count < ep->xfer_len) && (ep->xfer_len != 0U))
34189432:	69ba      	ldr	r2, [r7, #24]
34189434:	429a      	cmp	r2, r3
34189436:	d809      	bhi.n	3418944c <PCD_WriteEmptyTxFifo+0xde>
34189438:	68fb      	ldr	r3, [r7, #12]
3418943a:	695a      	ldr	r2, [r3, #20]
3418943c:	68fb      	ldr	r3, [r7, #12]
3418943e:	691b      	ldr	r3, [r3, #16]
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
34189440:	429a      	cmp	r2, r3
34189442:	d203      	bcs.n	3418944c <PCD_WriteEmptyTxFifo+0xde>
         (ep->xfer_count < ep->xfer_len) && (ep->xfer_len != 0U))
34189444:	68fb      	ldr	r3, [r7, #12]
34189446:	691b      	ldr	r3, [r3, #16]
34189448:	2b00      	cmp	r3, #0
3418944a:	d1bf      	bne.n	341893cc <PCD_WriteEmptyTxFifo+0x5e>
  }

  if (ep->xfer_len <= ep->xfer_count)
3418944c:	68fb      	ldr	r3, [r7, #12]
3418944e:	691a      	ldr	r2, [r3, #16]
34189450:	68fb      	ldr	r3, [r7, #12]
34189452:	695b      	ldr	r3, [r3, #20]
34189454:	429a      	cmp	r2, r3
34189456:	d811      	bhi.n	3418947c <PCD_WriteEmptyTxFifo+0x10e>
  {
    fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
34189458:	683b      	ldr	r3, [r7, #0]
3418945a:	f003 030f 	and.w	r3, r3, #15
3418945e:	2201      	movs	r2, #1
34189460:	fa02 f303 	lsl.w	r3, r2, r3
34189464:	60bb      	str	r3, [r7, #8]
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
34189466:	693b      	ldr	r3, [r7, #16]
34189468:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
3418946c:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
3418946e:	68bb      	ldr	r3, [r7, #8]
34189470:	43db      	mvns	r3, r3
34189472:	6939      	ldr	r1, [r7, #16]
34189474:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
34189478:	4013      	ands	r3, r2
3418947a:	634b      	str	r3, [r1, #52]	@ 0x34
  }

  return HAL_OK;
3418947c:	2300      	movs	r3, #0
}
3418947e:	4618      	mov	r0, r3
34189480:	3720      	adds	r7, #32
34189482:	46bd      	mov	sp, r7
34189484:	bd80      	pop	{r7, pc}
	...

34189488 <PCD_EP_OutXfrComplete_int>:
  * @param  hpcd PCD handle
  * @param  epnum endpoint number
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_EP_OutXfrComplete_int(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
34189488:	b580      	push	{r7, lr}
3418948a:	b088      	sub	sp, #32
3418948c:	af00      	add	r7, sp, #0
3418948e:	6078      	str	r0, [r7, #4]
34189490:	6039      	str	r1, [r7, #0]
  USB_OTG_EPTypeDef *ep;
  const USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
34189492:	687b      	ldr	r3, [r7, #4]
34189494:	681b      	ldr	r3, [r3, #0]
34189496:	61fb      	str	r3, [r7, #28]
  uint32_t USBx_BASE = (uint32_t)USBx;
34189498:	69fb      	ldr	r3, [r7, #28]
3418949a:	61bb      	str	r3, [r7, #24]
  uint32_t gSNPSiD = *(__IO const uint32_t *)(&USBx->CID + 0x1U);
3418949c:	69fb      	ldr	r3, [r7, #28]
3418949e:	333c      	adds	r3, #60	@ 0x3c
341894a0:	3304      	adds	r3, #4
341894a2:	681b      	ldr	r3, [r3, #0]
341894a4:	617b      	str	r3, [r7, #20]
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
341894a6:	683b      	ldr	r3, [r7, #0]
341894a8:	015a      	lsls	r2, r3, #5
341894aa:	69bb      	ldr	r3, [r7, #24]
341894ac:	4413      	add	r3, r2
341894ae:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
341894b2:	689b      	ldr	r3, [r3, #8]
341894b4:	613b      	str	r3, [r7, #16]

  if (hpcd->Init.dma_enable == 1U)
341894b6:	687b      	ldr	r3, [r7, #4]
341894b8:	799b      	ldrb	r3, [r3, #6]
341894ba:	2b01      	cmp	r3, #1
341894bc:	d17b      	bne.n	341895b6 <PCD_EP_OutXfrComplete_int+0x12e>
  {
    if ((DoepintReg & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP) /* Class C */
341894be:	693b      	ldr	r3, [r7, #16]
341894c0:	f003 0308 	and.w	r3, r3, #8
341894c4:	2b00      	cmp	r3, #0
341894c6:	d015      	beq.n	341894f4 <PCD_EP_OutXfrComplete_int+0x6c>
    {
      /* StupPktRcvd = 1 this is a setup packet */
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
341894c8:	697b      	ldr	r3, [r7, #20]
341894ca:	4a61      	ldr	r2, [pc, #388]	@ (34189650 <PCD_EP_OutXfrComplete_int+0x1c8>)
341894cc:	4293      	cmp	r3, r2
341894ce:	f240 80b9 	bls.w	34189644 <PCD_EP_OutXfrComplete_int+0x1bc>
          ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX))
341894d2:	693b      	ldr	r3, [r7, #16]
341894d4:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
341894d8:	2b00      	cmp	r3, #0
341894da:	f000 80b3 	beq.w	34189644 <PCD_EP_OutXfrComplete_int+0x1bc>
      {
        CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
341894de:	683b      	ldr	r3, [r7, #0]
341894e0:	015a      	lsls	r2, r3, #5
341894e2:	69bb      	ldr	r3, [r7, #24]
341894e4:	4413      	add	r3, r2
341894e6:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
341894ea:	461a      	mov	r2, r3
341894ec:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
341894f0:	6093      	str	r3, [r2, #8]
341894f2:	e0a7      	b.n	34189644 <PCD_EP_OutXfrComplete_int+0x1bc>
      }
    }
    else if ((DoepintReg & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR) /* Class E */
341894f4:	693b      	ldr	r3, [r7, #16]
341894f6:	f003 0320 	and.w	r3, r3, #32
341894fa:	2b00      	cmp	r3, #0
341894fc:	d009      	beq.n	34189512 <PCD_EP_OutXfrComplete_int+0x8a>
    {
      CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
341894fe:	683b      	ldr	r3, [r7, #0]
34189500:	015a      	lsls	r2, r3, #5
34189502:	69bb      	ldr	r3, [r7, #24]
34189504:	4413      	add	r3, r2
34189506:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
3418950a:	461a      	mov	r2, r3
3418950c:	2320      	movs	r3, #32
3418950e:	6093      	str	r3, [r2, #8]
34189510:	e098      	b.n	34189644 <PCD_EP_OutXfrComplete_int+0x1bc>
    }
    else if ((DoepintReg & (USB_OTG_DOEPINT_STUP | USB_OTG_DOEPINT_OTEPSPR)) == 0U)
34189512:	693b      	ldr	r3, [r7, #16]
34189514:	f003 0328 	and.w	r3, r3, #40	@ 0x28
34189518:	2b00      	cmp	r3, #0
3418951a:	f040 8093 	bne.w	34189644 <PCD_EP_OutXfrComplete_int+0x1bc>
    {
      /* StupPktRcvd = 1 this is a setup packet */
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
3418951e:	697b      	ldr	r3, [r7, #20]
34189520:	4a4b      	ldr	r2, [pc, #300]	@ (34189650 <PCD_EP_OutXfrComplete_int+0x1c8>)
34189522:	4293      	cmp	r3, r2
34189524:	d90f      	bls.n	34189546 <PCD_EP_OutXfrComplete_int+0xbe>
          ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX))
34189526:	693b      	ldr	r3, [r7, #16]
34189528:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
3418952c:	2b00      	cmp	r3, #0
3418952e:	d00a      	beq.n	34189546 <PCD_EP_OutXfrComplete_int+0xbe>
      {
        CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
34189530:	683b      	ldr	r3, [r7, #0]
34189532:	015a      	lsls	r2, r3, #5
34189534:	69bb      	ldr	r3, [r7, #24]
34189536:	4413      	add	r3, r2
34189538:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
3418953c:	461a      	mov	r2, r3
3418953e:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
34189542:	6093      	str	r3, [r2, #8]
34189544:	e07e      	b.n	34189644 <PCD_EP_OutXfrComplete_int+0x1bc>
      }
      else
      {
        ep = &hpcd->OUT_ep[epnum];
34189546:	683a      	ldr	r2, [r7, #0]
34189548:	4613      	mov	r3, r2
3418954a:	00db      	lsls	r3, r3, #3
3418954c:	4413      	add	r3, r2
3418954e:	009b      	lsls	r3, r3, #2
34189550:	f503 7314 	add.w	r3, r3, #592	@ 0x250
34189554:	687a      	ldr	r2, [r7, #4]
34189556:	4413      	add	r3, r2
34189558:	3304      	adds	r3, #4
3418955a:	60fb      	str	r3, [r7, #12]

        /* out data packet received over EP */
        ep->xfer_count = ep->xfer_size - (USBx_OUTEP(epnum)->DOEPTSIZ & USB_OTG_DOEPTSIZ_XFRSIZ);
3418955c:	68fb      	ldr	r3, [r7, #12]
3418955e:	6a1a      	ldr	r2, [r3, #32]
34189560:	683b      	ldr	r3, [r7, #0]
34189562:	0159      	lsls	r1, r3, #5
34189564:	69bb      	ldr	r3, [r7, #24]
34189566:	440b      	add	r3, r1
34189568:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
3418956c:	691b      	ldr	r3, [r3, #16]
3418956e:	f3c3 0312 	ubfx	r3, r3, #0, #19
34189572:	1ad2      	subs	r2, r2, r3
34189574:	68fb      	ldr	r3, [r7, #12]
34189576:	615a      	str	r2, [r3, #20]

        if (epnum == 0U)
34189578:	683b      	ldr	r3, [r7, #0]
3418957a:	2b00      	cmp	r3, #0
3418957c:	d114      	bne.n	341895a8 <PCD_EP_OutXfrComplete_int+0x120>
        {
          if (ep->xfer_len == 0U)
3418957e:	68fb      	ldr	r3, [r7, #12]
34189580:	691b      	ldr	r3, [r3, #16]
34189582:	2b00      	cmp	r3, #0
34189584:	d109      	bne.n	3418959a <PCD_EP_OutXfrComplete_int+0x112>
          {
            /* this is ZLP, so prepare EP0 for next setup */
            (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
34189586:	687b      	ldr	r3, [r7, #4]
34189588:	6818      	ldr	r0, [r3, #0]
3418958a:	687b      	ldr	r3, [r7, #4]
3418958c:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
34189590:	461a      	mov	r2, r3
34189592:	2101      	movs	r1, #1
34189594:	f00a f866 	bl	34193664 <USB_EP0_OutStart>
34189598:	e006      	b.n	341895a8 <PCD_EP_OutXfrComplete_int+0x120>
          }
          else
          {
            ep->xfer_buff += ep->xfer_count;
3418959a:	68fb      	ldr	r3, [r7, #12]
3418959c:	68da      	ldr	r2, [r3, #12]
3418959e:	68fb      	ldr	r3, [r7, #12]
341895a0:	695b      	ldr	r3, [r3, #20]
341895a2:	441a      	add	r2, r3
341895a4:	68fb      	ldr	r3, [r7, #12]
341895a6:	60da      	str	r2, [r3, #12]
        }

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->DataOutStageCallback(hpcd, (uint8_t)epnum);
#else
        HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
341895a8:	683b      	ldr	r3, [r7, #0]
341895aa:	b2db      	uxtb	r3, r3
341895ac:	4619      	mov	r1, r3
341895ae:	6878      	ldr	r0, [r7, #4]
341895b0:	f014 f844 	bl	3419d63c <HAL_PCD_DataOutStageCallback>
341895b4:	e046      	b.n	34189644 <PCD_EP_OutXfrComplete_int+0x1bc>
      /* ... */
    }
  }
  else
  {
    if (gSNPSiD == USB_OTG_CORE_ID_310A)
341895b6:	697b      	ldr	r3, [r7, #20]
341895b8:	4a26      	ldr	r2, [pc, #152]	@ (34189654 <PCD_EP_OutXfrComplete_int+0x1cc>)
341895ba:	4293      	cmp	r3, r2
341895bc:	d124      	bne.n	34189608 <PCD_EP_OutXfrComplete_int+0x180>
    {
      /* StupPktRcvd = 1 this is a setup packet */
      if ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX)
341895be:	693b      	ldr	r3, [r7, #16]
341895c0:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
341895c4:	2b00      	cmp	r3, #0
341895c6:	d00a      	beq.n	341895de <PCD_EP_OutXfrComplete_int+0x156>
      {
        CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
341895c8:	683b      	ldr	r3, [r7, #0]
341895ca:	015a      	lsls	r2, r3, #5
341895cc:	69bb      	ldr	r3, [r7, #24]
341895ce:	4413      	add	r3, r2
341895d0:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
341895d4:	461a      	mov	r2, r3
341895d6:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
341895da:	6093      	str	r3, [r2, #8]
341895dc:	e032      	b.n	34189644 <PCD_EP_OutXfrComplete_int+0x1bc>
      }
      else
      {
        if ((DoepintReg & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR)
341895de:	693b      	ldr	r3, [r7, #16]
341895e0:	f003 0320 	and.w	r3, r3, #32
341895e4:	2b00      	cmp	r3, #0
341895e6:	d008      	beq.n	341895fa <PCD_EP_OutXfrComplete_int+0x172>
        {
          CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
341895e8:	683b      	ldr	r3, [r7, #0]
341895ea:	015a      	lsls	r2, r3, #5
341895ec:	69bb      	ldr	r3, [r7, #24]
341895ee:	4413      	add	r3, r2
341895f0:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
341895f4:	461a      	mov	r2, r3
341895f6:	2320      	movs	r3, #32
341895f8:	6093      	str	r3, [r2, #8]
        }

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->DataOutStageCallback(hpcd, (uint8_t)epnum);
#else
        HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
341895fa:	683b      	ldr	r3, [r7, #0]
341895fc:	b2db      	uxtb	r3, r3
341895fe:	4619      	mov	r1, r3
34189600:	6878      	ldr	r0, [r7, #4]
34189602:	f014 f81b 	bl	3419d63c <HAL_PCD_DataOutStageCallback>
34189606:	e01d      	b.n	34189644 <PCD_EP_OutXfrComplete_int+0x1bc>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }
    }
    else
    {
      if ((epnum == 0U) && (hpcd->OUT_ep[epnum].xfer_len == 0U))
34189608:	683b      	ldr	r3, [r7, #0]
3418960a:	2b00      	cmp	r3, #0
3418960c:	d114      	bne.n	34189638 <PCD_EP_OutXfrComplete_int+0x1b0>
3418960e:	6879      	ldr	r1, [r7, #4]
34189610:	683a      	ldr	r2, [r7, #0]
34189612:	4613      	mov	r3, r2
34189614:	00db      	lsls	r3, r3, #3
34189616:	4413      	add	r3, r2
34189618:	009b      	lsls	r3, r3, #2
3418961a:	440b      	add	r3, r1
3418961c:	f503 7319 	add.w	r3, r3, #612	@ 0x264
34189620:	681b      	ldr	r3, [r3, #0]
34189622:	2b00      	cmp	r3, #0
34189624:	d108      	bne.n	34189638 <PCD_EP_OutXfrComplete_int+0x1b0>
      {
        /* this is ZLP, so prepare EP0 for next setup */
        (void)USB_EP0_OutStart(hpcd->Instance, 0U, (uint8_t *)hpcd->Setup);
34189626:	687b      	ldr	r3, [r7, #4]
34189628:	6818      	ldr	r0, [r3, #0]
3418962a:	687b      	ldr	r3, [r7, #4]
3418962c:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
34189630:	461a      	mov	r2, r3
34189632:	2100      	movs	r1, #0
34189634:	f00a f816 	bl	34193664 <USB_EP0_OutStart>
      }

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->DataOutStageCallback(hpcd, (uint8_t)epnum);
#else
      HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
34189638:	683b      	ldr	r3, [r7, #0]
3418963a:	b2db      	uxtb	r3, r3
3418963c:	4619      	mov	r1, r3
3418963e:	6878      	ldr	r0, [r7, #4]
34189640:	f013 fffc 	bl	3419d63c <HAL_PCD_DataOutStageCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
    }
  }

  return HAL_OK;
34189644:	2300      	movs	r3, #0
}
34189646:	4618      	mov	r0, r3
34189648:	3720      	adds	r7, #32
3418964a:	46bd      	mov	sp, r7
3418964c:	bd80      	pop	{r7, pc}
3418964e:	bf00      	nop
34189650:	4f54300a 	.word	0x4f54300a
34189654:	4f54310a 	.word	0x4f54310a

34189658 <PCD_EP_OutSetupPacket_int>:
  * @param  hpcd PCD handle
  * @param  epnum endpoint number
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_EP_OutSetupPacket_int(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
34189658:	b580      	push	{r7, lr}
3418965a:	b086      	sub	sp, #24
3418965c:	af00      	add	r7, sp, #0
3418965e:	6078      	str	r0, [r7, #4]
34189660:	6039      	str	r1, [r7, #0]
  const USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
34189662:	687b      	ldr	r3, [r7, #4]
34189664:	681b      	ldr	r3, [r3, #0]
34189666:	617b      	str	r3, [r7, #20]
  uint32_t USBx_BASE = (uint32_t)USBx;
34189668:	697b      	ldr	r3, [r7, #20]
3418966a:	613b      	str	r3, [r7, #16]
  uint32_t gSNPSiD = *(__IO const uint32_t *)(&USBx->CID + 0x1U);
3418966c:	697b      	ldr	r3, [r7, #20]
3418966e:	333c      	adds	r3, #60	@ 0x3c
34189670:	3304      	adds	r3, #4
34189672:	681b      	ldr	r3, [r3, #0]
34189674:	60fb      	str	r3, [r7, #12]
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
34189676:	683b      	ldr	r3, [r7, #0]
34189678:	015a      	lsls	r2, r3, #5
3418967a:	693b      	ldr	r3, [r7, #16]
3418967c:	4413      	add	r3, r2
3418967e:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
34189682:	689b      	ldr	r3, [r3, #8]
34189684:	60bb      	str	r3, [r7, #8]

  if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
34189686:	68fb      	ldr	r3, [r7, #12]
34189688:	4a15      	ldr	r2, [pc, #84]	@ (341896e0 <PCD_EP_OutSetupPacket_int+0x88>)
3418968a:	4293      	cmp	r3, r2
3418968c:	d90e      	bls.n	341896ac <PCD_EP_OutSetupPacket_int+0x54>
      ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX))
3418968e:	68bb      	ldr	r3, [r7, #8]
34189690:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
  if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
34189694:	2b00      	cmp	r3, #0
34189696:	d009      	beq.n	341896ac <PCD_EP_OutSetupPacket_int+0x54>
  {
    CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
34189698:	683b      	ldr	r3, [r7, #0]
3418969a:	015a      	lsls	r2, r3, #5
3418969c:	693b      	ldr	r3, [r7, #16]
3418969e:	4413      	add	r3, r2
341896a0:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
341896a4:	461a      	mov	r2, r3
341896a6:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
341896aa:	6093      	str	r3, [r2, #8]

  /* Inform the upper layer that a setup packet is available */
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
  hpcd->SetupStageCallback(hpcd);
#else
  HAL_PCD_SetupStageCallback(hpcd);
341896ac:	6878      	ldr	r0, [r7, #4]
341896ae:	f013 fe95 	bl	3419d3dc <HAL_PCD_SetupStageCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

  if ((gSNPSiD > USB_OTG_CORE_ID_300A) && (hpcd->Init.dma_enable == 1U))
341896b2:	68fb      	ldr	r3, [r7, #12]
341896b4:	4a0a      	ldr	r2, [pc, #40]	@ (341896e0 <PCD_EP_OutSetupPacket_int+0x88>)
341896b6:	4293      	cmp	r3, r2
341896b8:	d90c      	bls.n	341896d4 <PCD_EP_OutSetupPacket_int+0x7c>
341896ba:	687b      	ldr	r3, [r7, #4]
341896bc:	799b      	ldrb	r3, [r3, #6]
341896be:	2b01      	cmp	r3, #1
341896c0:	d108      	bne.n	341896d4 <PCD_EP_OutSetupPacket_int+0x7c>
  {
    (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
341896c2:	687b      	ldr	r3, [r7, #4]
341896c4:	6818      	ldr	r0, [r3, #0]
341896c6:	687b      	ldr	r3, [r7, #4]
341896c8:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
341896cc:	461a      	mov	r2, r3
341896ce:	2101      	movs	r1, #1
341896d0:	f009 ffc8 	bl	34193664 <USB_EP0_OutStart>
  }

  return HAL_OK;
341896d4:	2300      	movs	r3, #0
}
341896d6:	4618      	mov	r0, r3
341896d8:	3718      	adds	r7, #24
341896da:	46bd      	mov	sp, r7
341896dc:	bd80      	pop	{r7, pc}
341896de:	bf00      	nop
341896e0:	4f54300a 	.word	0x4f54300a

341896e4 <HAL_PCDEx_SetTxFiFo>:
  * @param  fifo The number of Tx fifo
  * @param  size Fifo size
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetTxFiFo(PCD_HandleTypeDef *hpcd, uint8_t fifo, uint16_t size)
{
341896e4:	b480      	push	{r7}
341896e6:	b085      	sub	sp, #20
341896e8:	af00      	add	r7, sp, #0
341896ea:	6078      	str	r0, [r7, #4]
341896ec:	460b      	mov	r3, r1
341896ee:	70fb      	strb	r3, [r7, #3]
341896f0:	4613      	mov	r3, r2
341896f2:	803b      	strh	r3, [r7, #0]
         --> Txn should be configured with the minimum space of 16 words
     The FIFO is used optimally when used TxFIFOs are allocated in the top
         of the FIFO.Ex: use EP1 and EP2 as IN instead of EP1 and EP3 as IN ones.
     When DMA is used 3n * FIFO locations should be reserved for internal DMA registers */

  Tx_Offset = hpcd->Instance->GRXFSIZ;
341896f4:	687b      	ldr	r3, [r7, #4]
341896f6:	681b      	ldr	r3, [r3, #0]
341896f8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
341896fa:	60bb      	str	r3, [r7, #8]

  if (fifo == 0U)
341896fc:	78fb      	ldrb	r3, [r7, #3]
341896fe:	2b00      	cmp	r3, #0
34189700:	d107      	bne.n	34189712 <HAL_PCDEx_SetTxFiFo+0x2e>
  {
    hpcd->Instance->DIEPTXF0_HNPTXFSIZ = ((uint32_t)size << 16) | Tx_Offset;
34189702:	883b      	ldrh	r3, [r7, #0]
34189704:	0419      	lsls	r1, r3, #16
34189706:	687b      	ldr	r3, [r7, #4]
34189708:	681b      	ldr	r3, [r3, #0]
3418970a:	68ba      	ldr	r2, [r7, #8]
3418970c:	430a      	orrs	r2, r1
3418970e:	629a      	str	r2, [r3, #40]	@ 0x28
34189710:	e028      	b.n	34189764 <HAL_PCDEx_SetTxFiFo+0x80>
  }
  else
  {
    Tx_Offset += (hpcd->Instance->DIEPTXF0_HNPTXFSIZ) >> 16;
34189712:	687b      	ldr	r3, [r7, #4]
34189714:	681b      	ldr	r3, [r3, #0]
34189716:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34189718:	0c1b      	lsrs	r3, r3, #16
3418971a:	68ba      	ldr	r2, [r7, #8]
3418971c:	4413      	add	r3, r2
3418971e:	60bb      	str	r3, [r7, #8]
    for (i = 0U; i < (fifo - 1U); i++)
34189720:	2300      	movs	r3, #0
34189722:	73fb      	strb	r3, [r7, #15]
34189724:	e00d      	b.n	34189742 <HAL_PCDEx_SetTxFiFo+0x5e>
    {
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
34189726:	687b      	ldr	r3, [r7, #4]
34189728:	681a      	ldr	r2, [r3, #0]
3418972a:	7bfb      	ldrb	r3, [r7, #15]
3418972c:	3340      	adds	r3, #64	@ 0x40
3418972e:	009b      	lsls	r3, r3, #2
34189730:	4413      	add	r3, r2
34189732:	685b      	ldr	r3, [r3, #4]
34189734:	0c1b      	lsrs	r3, r3, #16
34189736:	68ba      	ldr	r2, [r7, #8]
34189738:	4413      	add	r3, r2
3418973a:	60bb      	str	r3, [r7, #8]
    for (i = 0U; i < (fifo - 1U); i++)
3418973c:	7bfb      	ldrb	r3, [r7, #15]
3418973e:	3301      	adds	r3, #1
34189740:	73fb      	strb	r3, [r7, #15]
34189742:	7bfa      	ldrb	r2, [r7, #15]
34189744:	78fb      	ldrb	r3, [r7, #3]
34189746:	3b01      	subs	r3, #1
34189748:	429a      	cmp	r2, r3
3418974a:	d3ec      	bcc.n	34189726 <HAL_PCDEx_SetTxFiFo+0x42>
    }

    /* Multiply Tx_Size by 2 to get higher performance */
    hpcd->Instance->DIEPTXF[fifo - 1U] = ((uint32_t)size << 16) | Tx_Offset;
3418974c:	883b      	ldrh	r3, [r7, #0]
3418974e:	0418      	lsls	r0, r3, #16
34189750:	687b      	ldr	r3, [r7, #4]
34189752:	6819      	ldr	r1, [r3, #0]
34189754:	78fb      	ldrb	r3, [r7, #3]
34189756:	3b01      	subs	r3, #1
34189758:	68ba      	ldr	r2, [r7, #8]
3418975a:	4302      	orrs	r2, r0
3418975c:	3340      	adds	r3, #64	@ 0x40
3418975e:	009b      	lsls	r3, r3, #2
34189760:	440b      	add	r3, r1
34189762:	605a      	str	r2, [r3, #4]
  }

  return HAL_OK;
34189764:	2300      	movs	r3, #0
}
34189766:	4618      	mov	r0, r3
34189768:	3714      	adds	r7, #20
3418976a:	46bd      	mov	sp, r7
3418976c:	f85d 7b04 	ldr.w	r7, [sp], #4
34189770:	4770      	bx	lr

34189772 <HAL_PCDEx_SetRxFiFo>:
  * @param  hpcd PCD handle
  * @param  size Size of Rx fifo
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetRxFiFo(PCD_HandleTypeDef *hpcd, uint16_t size)
{
34189772:	b480      	push	{r7}
34189774:	b083      	sub	sp, #12
34189776:	af00      	add	r7, sp, #0
34189778:	6078      	str	r0, [r7, #4]
3418977a:	460b      	mov	r3, r1
3418977c:	807b      	strh	r3, [r7, #2]
  hpcd->Instance->GRXFSIZ = size;
3418977e:	687b      	ldr	r3, [r7, #4]
34189780:	681b      	ldr	r3, [r3, #0]
34189782:	887a      	ldrh	r2, [r7, #2]
34189784:	625a      	str	r2, [r3, #36]	@ 0x24

  return HAL_OK;
34189786:	2300      	movs	r3, #0
}
34189788:	4618      	mov	r0, r3
3418978a:	370c      	adds	r7, #12
3418978c:	46bd      	mov	sp, r7
3418978e:	f85d 7b04 	ldr.w	r7, [sp], #4
34189792:	4770      	bx	lr

34189794 <HAL_PCDEx_ActivateLPM>:
  * @brief  Activate LPM feature.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_ActivateLPM(PCD_HandleTypeDef *hpcd)
{
34189794:	b480      	push	{r7}
34189796:	b085      	sub	sp, #20
34189798:	af00      	add	r7, sp, #0
3418979a:	6078      	str	r0, [r7, #4]
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
3418979c:	687b      	ldr	r3, [r7, #4]
3418979e:	681b      	ldr	r3, [r3, #0]
341897a0:	60fb      	str	r3, [r7, #12]

  hpcd->lpm_active = 1U;
341897a2:	687b      	ldr	r3, [r7, #4]
341897a4:	2201      	movs	r2, #1
341897a6:	f8c3 24d8 	str.w	r2, [r3, #1240]	@ 0x4d8
  hpcd->LPM_State = LPM_L0;
341897aa:	687b      	ldr	r3, [r7, #4]
341897ac:	2200      	movs	r2, #0
341897ae:	f883 24cc 	strb.w	r2, [r3, #1228]	@ 0x4cc
  USBx->GINTMSK |= USB_OTG_GINTMSK_LPMINTM;
341897b2:	68fb      	ldr	r3, [r7, #12]
341897b4:	699b      	ldr	r3, [r3, #24]
341897b6:	f043 6200 	orr.w	r2, r3, #134217728	@ 0x8000000
341897ba:	68fb      	ldr	r3, [r7, #12]
341897bc:	619a      	str	r2, [r3, #24]
  USBx->GLPMCFG |= (USB_OTG_GLPMCFG_LPMEN | USB_OTG_GLPMCFG_LPMACK | USB_OTG_GLPMCFG_ENBESL);
341897be:	68fb      	ldr	r3, [r7, #12]
341897c0:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
341897c2:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
341897c6:	f043 0303 	orr.w	r3, r3, #3
341897ca:	68fa      	ldr	r2, [r7, #12]
341897cc:	6553      	str	r3, [r2, #84]	@ 0x54

  return HAL_OK;
341897ce:	2300      	movs	r3, #0
}
341897d0:	4618      	mov	r0, r3
341897d2:	3714      	adds	r7, #20
341897d4:	46bd      	mov	sp, r7
341897d6:	f85d 7b04 	ldr.w	r7, [sp], #4
341897da:	4770      	bx	lr

341897dc <HAL_PCDEx_LPM_Callback>:
  * @param  hpcd PCD handle
  * @param  msg LPM message
  * @retval HAL status
  */
__weak void HAL_PCDEx_LPM_Callback(PCD_HandleTypeDef *hpcd, PCD_LPM_MsgTypeDef msg)
{
341897dc:	b480      	push	{r7}
341897de:	b083      	sub	sp, #12
341897e0:	af00      	add	r7, sp, #0
341897e2:	6078      	str	r0, [r7, #4]
341897e4:	460b      	mov	r3, r1
341897e6:	70fb      	strb	r3, [r7, #3]
  UNUSED(msg);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PCDEx_LPM_Callback could be implemented in the user file
   */
}
341897e8:	bf00      	nop
341897ea:	370c      	adds	r7, #12
341897ec:	46bd      	mov	sp, r7
341897ee:	f85d 7b04 	ldr.w	r7, [sp], #4
341897f2:	4770      	bx	lr

341897f4 <HAL_PWREx_ConfigSupply>:
  * @note: The power supply configuration is not reset by wakeup from Standby mode and
  *        application reset, but only reset by VDD POR.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_ConfigSupply(uint32_t SupplySource)
{
341897f4:	b580      	push	{r7, lr}
341897f6:	b084      	sub	sp, #16
341897f8:	af00      	add	r7, sp, #0
341897fa:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param(IS_PWR_SUPPLY(SupplySource));

  /* Set the power supply configuration */
  MODIFY_REG(PWR->CR1, PWR_SUPPLY_CONFIG_MASK, SupplySource);
341897fc:	4b10      	ldr	r3, [pc, #64]	@ (34189840 <HAL_PWREx_ConfigSupply+0x4c>)
341897fe:	681b      	ldr	r3, [r3, #0]
34189800:	f023 0204 	bic.w	r2, r3, #4
34189804:	490e      	ldr	r1, [pc, #56]	@ (34189840 <HAL_PWREx_ConfigSupply+0x4c>)
34189806:	687b      	ldr	r3, [r7, #4]
34189808:	4313      	orrs	r3, r2
3418980a:	600b      	str	r3, [r1, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
3418980c:	f7fb fed4 	bl	341855b8 <HAL_GetTick>
34189810:	60f8      	str	r0, [r7, #12]

  /* Wait till voltage level flag is set */
  while ((PWR->VOSCR & PWR_VOSCR_ACTVOSRDY) == 0U)
34189812:	e009      	b.n	34189828 <HAL_PWREx_ConfigSupply+0x34>
  {
    if ((HAL_GetTick() - tickstart) > PWR_FLAG_SETTING_DELAY)
34189814:	f7fb fed0 	bl	341855b8 <HAL_GetTick>
34189818:	4602      	mov	r2, r0
3418981a:	68fb      	ldr	r3, [r7, #12]
3418981c:	1ad3      	subs	r3, r2, r3
3418981e:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
34189822:	d901      	bls.n	34189828 <HAL_PWREx_ConfigSupply+0x34>
    {
      return HAL_ERROR;
34189824:	2301      	movs	r3, #1
34189826:	e006      	b.n	34189836 <HAL_PWREx_ConfigSupply+0x42>
  while ((PWR->VOSCR & PWR_VOSCR_ACTVOSRDY) == 0U)
34189828:	4b05      	ldr	r3, [pc, #20]	@ (34189840 <HAL_PWREx_ConfigSupply+0x4c>)
3418982a:	6a1b      	ldr	r3, [r3, #32]
3418982c:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
34189830:	2b00      	cmp	r3, #0
34189832:	d0ef      	beq.n	34189814 <HAL_PWREx_ConfigSupply+0x20>
    }
  }

  return HAL_OK;
34189834:	2300      	movs	r3, #0
}
34189836:	4618      	mov	r0, r3
34189838:	3710      	adds	r7, #16
3418983a:	46bd      	mov	sp, r7
3418983c:	bd80      	pop	{r7, pc}
3418983e:	bf00      	nop
34189840:	56024800 	.word	0x56024800

34189844 <HAL_PWREx_EnableVddUSB>:
  * @note   Setting this bit is mandatory to use the USB2 HS PHYs.
  *         is present for consumption saving.
  * @retval None.
  */
void HAL_PWREx_EnableVddUSB(void)
{
34189844:	b480      	push	{r7}
34189846:	af00      	add	r7, sp, #0
  SET_BIT(PWR->SVMCR3, PWR_SVMCR3_USB33SV);
34189848:	4b05      	ldr	r3, [pc, #20]	@ (34189860 <HAL_PWREx_EnableVddUSB+0x1c>)
3418984a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3418984c:	4a04      	ldr	r2, [pc, #16]	@ (34189860 <HAL_PWREx_EnableVddUSB+0x1c>)
3418984e:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
34189852:	63d3      	str	r3, [r2, #60]	@ 0x3c
}
34189854:	bf00      	nop
34189856:	46bd      	mov	sp, r7
34189858:	f85d 7b04 	ldr.w	r7, [sp], #4
3418985c:	4770      	bx	lr
3418985e:	bf00      	nop
34189860:	56024800 	.word	0x56024800

34189864 <HAL_PWREx_EnableVddIO2>:
  * @brief  Enable VDDIO2 supply valid.
  * @note   Setting this bit is mandatory to use PO[5:0] and PP[15:0] I/Os.
  * @retval None.
  */
void HAL_PWREx_EnableVddIO2(void)
{
34189864:	b480      	push	{r7}
34189866:	af00      	add	r7, sp, #0
  SET_BIT(PWR->SVMCR3, PWR_SVMCR3_VDDIO2SV);
34189868:	4b05      	ldr	r3, [pc, #20]	@ (34189880 <HAL_PWREx_EnableVddIO2+0x1c>)
3418986a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3418986c:	4a04      	ldr	r2, [pc, #16]	@ (34189880 <HAL_PWREx_EnableVddIO2+0x1c>)
3418986e:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
34189872:	63d3      	str	r3, [r2, #60]	@ 0x3c
}
34189874:	bf00      	nop
34189876:	46bd      	mov	sp, r7
34189878:	f85d 7b04 	ldr.w	r7, [sp], #4
3418987c:	4770      	bx	lr
3418987e:	bf00      	nop
34189880:	56024800 	.word	0x56024800

34189884 <HAL_PWREx_EnableVddIO3>:
  * @brief  Enable VDDIO3 supply valid.
  * @note   Setting this bit is mandatory to use PN[12:0] I/Os.
  * @retval None.
  */
void HAL_PWREx_EnableVddIO3(void)
{
34189884:	b480      	push	{r7}
34189886:	af00      	add	r7, sp, #0
  SET_BIT(PWR->SVMCR3, PWR_SVMCR3_VDDIO3SV);
34189888:	4b05      	ldr	r3, [pc, #20]	@ (341898a0 <HAL_PWREx_EnableVddIO3+0x1c>)
3418988a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3418988c:	4a04      	ldr	r2, [pc, #16]	@ (341898a0 <HAL_PWREx_EnableVddIO3+0x1c>)
3418988e:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
34189892:	63d3      	str	r3, [r2, #60]	@ 0x3c
}
34189894:	bf00      	nop
34189896:	46bd      	mov	sp, r7
34189898:	f85d 7b04 	ldr.w	r7, [sp], #4
3418989c:	4770      	bx	lr
3418989e:	bf00      	nop
341898a0:	56024800 	.word	0x56024800

341898a4 <HAL_PWREx_EnableVddIO4>:
  * @brief  Enable VDDIO4 supply valid.
  * @note   Setting this bit is mandatory to use PB[9,8], PC[12:6], and PD[2] I/Os.
  * @retval None.
  */
void HAL_PWREx_EnableVddIO4(void)
{
341898a4:	b480      	push	{r7}
341898a6:	af00      	add	r7, sp, #0
  SET_BIT(PWR->SVMCR1, PWR_SVMCR1_VDDIO4SV);
341898a8:	4b05      	ldr	r3, [pc, #20]	@ (341898c0 <HAL_PWREx_EnableVddIO4+0x1c>)
341898aa:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
341898ac:	4a04      	ldr	r2, [pc, #16]	@ (341898c0 <HAL_PWREx_EnableVddIO4+0x1c>)
341898ae:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
341898b2:	6353      	str	r3, [r2, #52]	@ 0x34
}
341898b4:	bf00      	nop
341898b6:	46bd      	mov	sp, r7
341898b8:	f85d 7b04 	ldr.w	r7, [sp], #4
341898bc:	4770      	bx	lr
341898be:	bf00      	nop
341898c0:	56024800 	.word	0x56024800

341898c4 <HAL_PWREx_EnableVddIO5>:
  * @brief  Enable VDDIO5 supply valid.
  * @note   Setting this bit is mandatory to use PN[12:0] I/Os.
  * @retval None.
  */
void HAL_PWREx_EnableVddIO5(void)
{
341898c4:	b480      	push	{r7}
341898c6:	af00      	add	r7, sp, #0
  SET_BIT(PWR->SVMCR2, PWR_SVMCR2_VDDIO5SV);
341898c8:	4b05      	ldr	r3, [pc, #20]	@ (341898e0 <HAL_PWREx_EnableVddIO5+0x1c>)
341898ca:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
341898cc:	4a04      	ldr	r2, [pc, #16]	@ (341898e0 <HAL_PWREx_EnableVddIO5+0x1c>)
341898ce:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
341898d2:	6393      	str	r3, [r2, #56]	@ 0x38
}
341898d4:	bf00      	nop
341898d6:	46bd      	mov	sp, r7
341898d8:	f85d 7b04 	ldr.w	r7, [sp], #4
341898dc:	4770      	bx	lr
341898de:	bf00      	nop
341898e0:	56024800 	.word	0x56024800

341898e4 <HAL_PWREx_EnableVddA>:
  * @brief  Enable VDDA supply valid.
  * @note   Setting this bit is mandatory to use the analog to digital converters.
  * @retval None.
  */
void HAL_PWREx_EnableVddA(void)
{
341898e4:	b480      	push	{r7}
341898e6:	af00      	add	r7, sp, #0
  SET_BIT(PWR->SVMCR3, PWR_SVMCR3_ASV);
341898e8:	4b05      	ldr	r3, [pc, #20]	@ (34189900 <HAL_PWREx_EnableVddA+0x1c>)
341898ea:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
341898ec:	4a04      	ldr	r2, [pc, #16]	@ (34189900 <HAL_PWREx_EnableVddA+0x1c>)
341898ee:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
341898f2:	63d3      	str	r3, [r2, #60]	@ 0x3c
}
341898f4:	bf00      	nop
341898f6:	46bd      	mov	sp, r7
341898f8:	f85d 7b04 	ldr.w	r7, [sp], #4
341898fc:	4770      	bx	lr
341898fe:	bf00      	nop
34189900:	56024800 	.word	0x56024800

34189904 <HAL_PWREx_EnableVddUSBVMEN>:
/**
  * @brief  Enable the VDD33USB independent USB 33 voltage monitor.
  * @retval None.
  */
void HAL_PWREx_EnableVddUSBVMEN(void)
{
34189904:	b480      	push	{r7}
34189906:	af00      	add	r7, sp, #0
  SET_BIT(PWR->SVMCR3, PWR_SVMCR3_USB33VMEN);
34189908:	4b05      	ldr	r3, [pc, #20]	@ (34189920 <HAL_PWREx_EnableVddUSBVMEN+0x1c>)
3418990a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3418990c:	4a04      	ldr	r2, [pc, #16]	@ (34189920 <HAL_PWREx_EnableVddUSBVMEN+0x1c>)
3418990e:	f043 0304 	orr.w	r3, r3, #4
34189912:	63d3      	str	r3, [r2, #60]	@ 0x3c
}
34189914:	bf00      	nop
34189916:	46bd      	mov	sp, r7
34189918:	f85d 7b04 	ldr.w	r7, [sp], #4
3418991c:	4770      	bx	lr
3418991e:	bf00      	nop
34189920:	56024800 	.word	0x56024800

34189924 <LL_RCC_HSE_IsReady>:
  * @brief  Check if HSE oscillator Ready
  * @rmtoll SR           HSERDY        LL_RCC_HSE_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_HSE_IsReady(void)
{
34189924:	b480      	push	{r7}
34189926:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_HSERDY) != 0UL) ? 1UL : 0UL);
34189928:	4b06      	ldr	r3, [pc, #24]	@ (34189944 <LL_RCC_HSE_IsReady+0x20>)
3418992a:	685b      	ldr	r3, [r3, #4]
3418992c:	f003 0310 	and.w	r3, r3, #16
34189930:	2b00      	cmp	r3, #0
34189932:	d001      	beq.n	34189938 <LL_RCC_HSE_IsReady+0x14>
34189934:	2301      	movs	r3, #1
34189936:	e000      	b.n	3418993a <LL_RCC_HSE_IsReady+0x16>
34189938:	2300      	movs	r3, #0
}
3418993a:	4618      	mov	r0, r3
3418993c:	46bd      	mov	sp, r7
3418993e:	f85d 7b04 	ldr.w	r7, [sp], #4
34189942:	4770      	bx	lr
34189944:	56028000 	.word	0x56028000

34189948 <LL_RCC_HSI_Enable>:
  * @brief  Enable HSI oscillator
  * @rmtoll CSR          HSIONS        LL_RCC_HSI_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSI_Enable(void)
{
34189948:	b480      	push	{r7}
3418994a:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CSR, RCC_CSR_HSIONS);
3418994c:	4b04      	ldr	r3, [pc, #16]	@ (34189960 <LL_RCC_HSI_Enable+0x18>)
3418994e:	2208      	movs	r2, #8
34189950:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
}
34189954:	bf00      	nop
34189956:	46bd      	mov	sp, r7
34189958:	f85d 7b04 	ldr.w	r7, [sp], #4
3418995c:	4770      	bx	lr
3418995e:	bf00      	nop
34189960:	56028000 	.word	0x56028000

34189964 <LL_RCC_HSI_Disable>:
  * @brief  Disable HSI oscillator
  * @rmtoll CCR          HSIONC        LL_RCC_HSI_Disable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSI_Disable(void)
{
34189964:	b480      	push	{r7}
34189966:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CCR, RCC_CCR_HSIONC);
34189968:	4b05      	ldr	r3, [pc, #20]	@ (34189980 <LL_RCC_HSI_Disable+0x1c>)
3418996a:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3418996e:	461a      	mov	r2, r3
34189970:	2308      	movs	r3, #8
34189972:	6013      	str	r3, [r2, #0]
}
34189974:	bf00      	nop
34189976:	46bd      	mov	sp, r7
34189978:	f85d 7b04 	ldr.w	r7, [sp], #4
3418997c:	4770      	bx	lr
3418997e:	bf00      	nop
34189980:	56028000 	.word	0x56028000

34189984 <LL_RCC_HSI_IsReady>:
  * @brief  Check if HSI clock is ready
  * @rmtoll SR           HSIRDY        LL_RCC_HSI_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_HSI_IsReady(void)
{
34189984:	b480      	push	{r7}
34189986:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_HSIRDY) != 0UL) ? 1UL : 0UL);
34189988:	4b06      	ldr	r3, [pc, #24]	@ (341899a4 <LL_RCC_HSI_IsReady+0x20>)
3418998a:	685b      	ldr	r3, [r3, #4]
3418998c:	f003 0308 	and.w	r3, r3, #8
34189990:	2b00      	cmp	r3, #0
34189992:	d001      	beq.n	34189998 <LL_RCC_HSI_IsReady+0x14>
34189994:	2301      	movs	r3, #1
34189996:	e000      	b.n	3418999a <LL_RCC_HSI_IsReady+0x16>
34189998:	2300      	movs	r3, #0
}
3418999a:	4618      	mov	r0, r3
3418999c:	46bd      	mov	sp, r7
3418999e:	f85d 7b04 	ldr.w	r7, [sp], #4
341899a2:	4770      	bx	lr
341899a4:	56028000 	.word	0x56028000

341899a8 <LL_RCC_HSI_SetDivider>:
  *         @arg @ref LL_RCC_HSI_DIV_4
  *         @arg @ref LL_RCC_HSI_DIV_8
  * @retval None.
  */
__STATIC_INLINE void LL_RCC_HSI_SetDivider(uint32_t Divider)
{
341899a8:	b480      	push	{r7}
341899aa:	b083      	sub	sp, #12
341899ac:	af00      	add	r7, sp, #0
341899ae:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->HSICFGR, RCC_HSICFGR_HSIDIV, Divider);
341899b0:	4b06      	ldr	r3, [pc, #24]	@ (341899cc <LL_RCC_HSI_SetDivider+0x24>)
341899b2:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
341899b4:	f423 72c0 	bic.w	r2, r3, #384	@ 0x180
341899b8:	4904      	ldr	r1, [pc, #16]	@ (341899cc <LL_RCC_HSI_SetDivider+0x24>)
341899ba:	687b      	ldr	r3, [r7, #4]
341899bc:	4313      	orrs	r3, r2
341899be:	648b      	str	r3, [r1, #72]	@ 0x48
}
341899c0:	bf00      	nop
341899c2:	370c      	adds	r7, #12
341899c4:	46bd      	mov	sp, r7
341899c6:	f85d 7b04 	ldr.w	r7, [sp], #4
341899ca:	4770      	bx	lr
341899cc:	56028000 	.word	0x56028000

341899d0 <LL_RCC_HSI_GetDivider>:
  *         @arg @ref LL_RCC_HSI_DIV_2
  *         @arg @ref LL_RCC_HSI_DIV_4
  *         @arg @ref LL_RCC_HSI_DIV_8
  */
__STATIC_INLINE uint32_t LL_RCC_HSI_GetDivider(void)
{
341899d0:	b480      	push	{r7}
341899d2:	af00      	add	r7, sp, #0
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
341899d4:	4b04      	ldr	r3, [pc, #16]	@ (341899e8 <LL_RCC_HSI_GetDivider+0x18>)
341899d6:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
341899d8:	f403 73c0 	and.w	r3, r3, #384	@ 0x180
}
341899dc:	4618      	mov	r0, r3
341899de:	46bd      	mov	sp, r7
341899e0:	f85d 7b04 	ldr.w	r7, [sp], #4
341899e4:	4770      	bx	lr
341899e6:	bf00      	nop
341899e8:	56028000 	.word	0x56028000

341899ec <LL_RCC_HSI_SetCalibTrimming>:
  * @rmtoll HSICFGR      HSITRIM       LL_RCC_HSI_SetCalibTrimming
  * @param  Value This parameter can be a value between 0 and 63
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSI_SetCalibTrimming(uint32_t Value)
{
341899ec:	b480      	push	{r7}
341899ee:	b083      	sub	sp, #12
341899f0:	af00      	add	r7, sp, #0
341899f2:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->HSICFGR, RCC_HSICFGR_HSITRIM, Value << RCC_HSICFGR_HSITRIM_Pos);
341899f4:	4b07      	ldr	r3, [pc, #28]	@ (34189a14 <LL_RCC_HSI_SetCalibTrimming+0x28>)
341899f6:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
341899f8:	f423 02fe 	bic.w	r2, r3, #8323072	@ 0x7f0000
341899fc:	687b      	ldr	r3, [r7, #4]
341899fe:	041b      	lsls	r3, r3, #16
34189a00:	4904      	ldr	r1, [pc, #16]	@ (34189a14 <LL_RCC_HSI_SetCalibTrimming+0x28>)
34189a02:	4313      	orrs	r3, r2
34189a04:	648b      	str	r3, [r1, #72]	@ 0x48
}
34189a06:	bf00      	nop
34189a08:	370c      	adds	r7, #12
34189a0a:	46bd      	mov	sp, r7
34189a0c:	f85d 7b04 	ldr.w	r7, [sp], #4
34189a10:	4770      	bx	lr
34189a12:	bf00      	nop
34189a14:	56028000 	.word	0x56028000

34189a18 <LL_RCC_MSI_Enable>:
  * @brief  Enable MSI oscillator
  * @rmtoll CSR          MSIONS        LL_RCC_MSI_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_MSI_Enable(void)
{
34189a18:	b480      	push	{r7}
34189a1a:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CSR, RCC_CSR_MSIONS);
34189a1c:	4b04      	ldr	r3, [pc, #16]	@ (34189a30 <LL_RCC_MSI_Enable+0x18>)
34189a1e:	2204      	movs	r2, #4
34189a20:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
}
34189a24:	bf00      	nop
34189a26:	46bd      	mov	sp, r7
34189a28:	f85d 7b04 	ldr.w	r7, [sp], #4
34189a2c:	4770      	bx	lr
34189a2e:	bf00      	nop
34189a30:	56028000 	.word	0x56028000

34189a34 <LL_RCC_MSI_Disable>:
  * @brief  Disable MSI oscillator
  * @rmtoll CCR          MSIONC        LL_RCC_MSI_Disable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_MSI_Disable(void)
{
34189a34:	b480      	push	{r7}
34189a36:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CCR, RCC_CCR_MSIONC);
34189a38:	4b05      	ldr	r3, [pc, #20]	@ (34189a50 <LL_RCC_MSI_Disable+0x1c>)
34189a3a:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34189a3e:	461a      	mov	r2, r3
34189a40:	2304      	movs	r3, #4
34189a42:	6013      	str	r3, [r2, #0]
}
34189a44:	bf00      	nop
34189a46:	46bd      	mov	sp, r7
34189a48:	f85d 7b04 	ldr.w	r7, [sp], #4
34189a4c:	4770      	bx	lr
34189a4e:	bf00      	nop
34189a50:	56028000 	.word	0x56028000

34189a54 <LL_RCC_MSI_IsReady>:
  * @brief  Check if MSI clock is ready
  * @rmtoll SR           MSIRDY        LL_RCC_MSI_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_MSI_IsReady(void)
{
34189a54:	b480      	push	{r7}
34189a56:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_MSIRDY) != 0UL) ? 1UL : 0UL);
34189a58:	4b06      	ldr	r3, [pc, #24]	@ (34189a74 <LL_RCC_MSI_IsReady+0x20>)
34189a5a:	685b      	ldr	r3, [r3, #4]
34189a5c:	f003 0304 	and.w	r3, r3, #4
34189a60:	2b00      	cmp	r3, #0
34189a62:	d001      	beq.n	34189a68 <LL_RCC_MSI_IsReady+0x14>
34189a64:	2301      	movs	r3, #1
34189a66:	e000      	b.n	34189a6a <LL_RCC_MSI_IsReady+0x16>
34189a68:	2300      	movs	r3, #0
}
34189a6a:	4618      	mov	r0, r3
34189a6c:	46bd      	mov	sp, r7
34189a6e:	f85d 7b04 	ldr.w	r7, [sp], #4
34189a72:	4770      	bx	lr
34189a74:	56028000 	.word	0x56028000

34189a78 <LL_RCC_MSI_SetFrequency>:
  *         @arg @ref LL_RCC_MSI_FREQ_4MHZ
  *         @arg @ref LL_RCC_MSI_FREQ_16MHZ
  * @retval None.
  */
__STATIC_INLINE void LL_RCC_MSI_SetFrequency(uint32_t Value)
{
34189a78:	b480      	push	{r7}
34189a7a:	b083      	sub	sp, #12
34189a7c:	af00      	add	r7, sp, #0
34189a7e:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL, Value);
34189a80:	4b06      	ldr	r3, [pc, #24]	@ (34189a9c <LL_RCC_MSI_SetFrequency+0x24>)
34189a82:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34189a84:	f423 7200 	bic.w	r2, r3, #512	@ 0x200
34189a88:	4904      	ldr	r1, [pc, #16]	@ (34189a9c <LL_RCC_MSI_SetFrequency+0x24>)
34189a8a:	687b      	ldr	r3, [r7, #4]
34189a8c:	4313      	orrs	r3, r2
34189a8e:	644b      	str	r3, [r1, #68]	@ 0x44
}
34189a90:	bf00      	nop
34189a92:	370c      	adds	r7, #12
34189a94:	46bd      	mov	sp, r7
34189a96:	f85d 7b04 	ldr.w	r7, [sp], #4
34189a9a:	4770      	bx	lr
34189a9c:	56028000 	.word	0x56028000

34189aa0 <LL_RCC_MSI_GetFrequency>:
  * @retval can be one of the following values:
  *         @arg @ref LL_RCC_MSI_FREQ_4MHZ
  *         @arg @ref LL_RCC_MSI_FREQ_16MHZ
  */
__STATIC_INLINE uint32_t LL_RCC_MSI_GetFrequency(void)
{
34189aa0:	b480      	push	{r7}
34189aa2:	af00      	add	r7, sp, #0
  return (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL));
34189aa4:	4b04      	ldr	r3, [pc, #16]	@ (34189ab8 <LL_RCC_MSI_GetFrequency+0x18>)
34189aa6:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34189aa8:	f403 7300 	and.w	r3, r3, #512	@ 0x200
}
34189aac:	4618      	mov	r0, r3
34189aae:	46bd      	mov	sp, r7
34189ab0:	f85d 7b04 	ldr.w	r7, [sp], #4
34189ab4:	4770      	bx	lr
34189ab6:	bf00      	nop
34189ab8:	56028000 	.word	0x56028000

34189abc <LL_RCC_MSI_SetCalibTrimming>:
  * @rmtoll MSICFGR      MSITRIM       LL_RCC_MSI_SetCalibTrimming
  * @param  Value can be a value between 0 and 31
  * @retval None
  */
__STATIC_INLINE void LL_RCC_MSI_SetCalibTrimming(uint32_t Value)
{
34189abc:	b480      	push	{r7}
34189abe:	b083      	sub	sp, #12
34189ac0:	af00      	add	r7, sp, #0
34189ac2:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->MSICFGR, RCC_MSICFGR_MSITRIM, Value << RCC_MSICFGR_MSITRIM_Pos);
34189ac4:	4b07      	ldr	r3, [pc, #28]	@ (34189ae4 <LL_RCC_MSI_SetCalibTrimming+0x28>)
34189ac6:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34189ac8:	f423 12f8 	bic.w	r2, r3, #2031616	@ 0x1f0000
34189acc:	687b      	ldr	r3, [r7, #4]
34189ace:	041b      	lsls	r3, r3, #16
34189ad0:	4904      	ldr	r1, [pc, #16]	@ (34189ae4 <LL_RCC_MSI_SetCalibTrimming+0x28>)
34189ad2:	4313      	orrs	r3, r2
34189ad4:	644b      	str	r3, [r1, #68]	@ 0x44
}
34189ad6:	bf00      	nop
34189ad8:	370c      	adds	r7, #12
34189ada:	46bd      	mov	sp, r7
34189adc:	f85d 7b04 	ldr.w	r7, [sp], #4
34189ae0:	4770      	bx	lr
34189ae2:	bf00      	nop
34189ae4:	56028000 	.word	0x56028000

34189ae8 <LL_RCC_LSE_IsReady>:
  * @brief  Check if LSE oscillator Ready
  * @rmtoll SR           LSERDY        LL_RCC_LSE_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_LSE_IsReady(void)
{
34189ae8:	b480      	push	{r7}
34189aea:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_LSERDY) != 0UL) ? 1UL : 0UL);
34189aec:	4b06      	ldr	r3, [pc, #24]	@ (34189b08 <LL_RCC_LSE_IsReady+0x20>)
34189aee:	685b      	ldr	r3, [r3, #4]
34189af0:	f003 0302 	and.w	r3, r3, #2
34189af4:	2b00      	cmp	r3, #0
34189af6:	d001      	beq.n	34189afc <LL_RCC_LSE_IsReady+0x14>
34189af8:	2301      	movs	r3, #1
34189afa:	e000      	b.n	34189afe <LL_RCC_LSE_IsReady+0x16>
34189afc:	2300      	movs	r3, #0
}
34189afe:	4618      	mov	r0, r3
34189b00:	46bd      	mov	sp, r7
34189b02:	f85d 7b04 	ldr.w	r7, [sp], #4
34189b06:	4770      	bx	lr
34189b08:	56028000 	.word	0x56028000

34189b0c <LL_RCC_LSI_Enable>:
  * @brief  Enable LSI Oscillator
  * @rmtoll CSR          LSIONS        LL_RCC_LSI_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_LSI_Enable(void)
{
34189b0c:	b480      	push	{r7}
34189b0e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CSR, RCC_CSR_LSIONS);
34189b10:	4b04      	ldr	r3, [pc, #16]	@ (34189b24 <LL_RCC_LSI_Enable+0x18>)
34189b12:	2201      	movs	r2, #1
34189b14:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
}
34189b18:	bf00      	nop
34189b1a:	46bd      	mov	sp, r7
34189b1c:	f85d 7b04 	ldr.w	r7, [sp], #4
34189b20:	4770      	bx	lr
34189b22:	bf00      	nop
34189b24:	56028000 	.word	0x56028000

34189b28 <LL_RCC_LSI_Disable>:
  * @brief  Disable LSI Oscillator
  * @rmtoll CCR          LSIONC        LL_RCC_LSI_Disable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_LSI_Disable(void)
{
34189b28:	b480      	push	{r7}
34189b2a:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CCR, RCC_CCR_LSIONC);
34189b2c:	4b05      	ldr	r3, [pc, #20]	@ (34189b44 <LL_RCC_LSI_Disable+0x1c>)
34189b2e:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34189b32:	461a      	mov	r2, r3
34189b34:	2301      	movs	r3, #1
34189b36:	6013      	str	r3, [r2, #0]
}
34189b38:	bf00      	nop
34189b3a:	46bd      	mov	sp, r7
34189b3c:	f85d 7b04 	ldr.w	r7, [sp], #4
34189b40:	4770      	bx	lr
34189b42:	bf00      	nop
34189b44:	56028000 	.word	0x56028000

34189b48 <LL_RCC_LSI_IsReady>:
  * @brief  Check if LSI is Ready
  * @rmtoll SR           LSIRDY        LL_RCC_LSI_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_LSI_IsReady(void)
{
34189b48:	b480      	push	{r7}
34189b4a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_LSIRDY) != 0UL) ? 1UL : 0UL);
34189b4c:	4b04      	ldr	r3, [pc, #16]	@ (34189b60 <LL_RCC_LSI_IsReady+0x18>)
34189b4e:	685b      	ldr	r3, [r3, #4]
34189b50:	f003 0301 	and.w	r3, r3, #1
}
34189b54:	4618      	mov	r0, r3
34189b56:	46bd      	mov	sp, r7
34189b58:	f85d 7b04 	ldr.w	r7, [sp], #4
34189b5c:	4770      	bx	lr
34189b5e:	bf00      	nop
34189b60:	56028000 	.word	0x56028000

34189b64 <LL_RCC_GetCpuClkSource>:
  *         @arg @ref LL_RCC_CPU_CLKSOURCE_STATUS_MSI
  *         @arg @ref LL_RCC_CPU_CLKSOURCE_STATUS_HSE
  *         @arg @ref LL_RCC_CPU_CLKSOURCE_STATUS_IC1
  */
__STATIC_INLINE uint32_t LL_RCC_GetCpuClkSource(void)
{
34189b64:	b480      	push	{r7}
34189b66:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR1, RCC_CFGR1_CPUSWS));
34189b68:	4b04      	ldr	r3, [pc, #16]	@ (34189b7c <LL_RCC_GetCpuClkSource+0x18>)
34189b6a:	6a1b      	ldr	r3, [r3, #32]
34189b6c:	f403 1340 	and.w	r3, r3, #3145728	@ 0x300000
}
34189b70:	4618      	mov	r0, r3
34189b72:	46bd      	mov	sp, r7
34189b74:	f85d 7b04 	ldr.w	r7, [sp], #4
34189b78:	4770      	bx	lr
34189b7a:	bf00      	nop
34189b7c:	56028000 	.word	0x56028000

34189b80 <LL_RCC_GetSysClkSource>:
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_MSI
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_HSE
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_IC2_IC6_IC11
  */
__STATIC_INLINE uint32_t LL_RCC_GetSysClkSource(void)
{
34189b80:	b480      	push	{r7}
34189b82:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR1, RCC_CFGR1_SYSSWS));
34189b84:	4b04      	ldr	r3, [pc, #16]	@ (34189b98 <LL_RCC_GetSysClkSource+0x18>)
34189b86:	6a1b      	ldr	r3, [r3, #32]
34189b88:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
34189b8c:	4618      	mov	r0, r3
34189b8e:	46bd      	mov	sp, r7
34189b90:	f85d 7b04 	ldr.w	r7, [sp], #4
34189b94:	4770      	bx	lr
34189b96:	bf00      	nop
34189b98:	56028000 	.word	0x56028000

34189b9c <LL_RCC_GetAHBPrescaler>:
  *         @arg @ref LL_RCC_AHB_DIV_32
  *         @arg @ref LL_RCC_AHB_DIV_64
  *         @arg @ref LL_RCC_AHB_DIV_128
  */
__STATIC_INLINE uint32_t LL_RCC_GetAHBPrescaler(void)
{
34189b9c:	b480      	push	{r7}
34189b9e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_HPRE));
34189ba0:	4b04      	ldr	r3, [pc, #16]	@ (34189bb4 <LL_RCC_GetAHBPrescaler+0x18>)
34189ba2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34189ba4:	f403 03e0 	and.w	r3, r3, #7340032	@ 0x700000
}
34189ba8:	4618      	mov	r0, r3
34189baa:	46bd      	mov	sp, r7
34189bac:	f85d 7b04 	ldr.w	r7, [sp], #4
34189bb0:	4770      	bx	lr
34189bb2:	bf00      	nop
34189bb4:	56028000 	.word	0x56028000

34189bb8 <LL_RCC_GetAPB1Prescaler>:
  *         @arg @ref LL_RCC_APB1_DIV_32
  *         @arg @ref LL_RCC_APB1_DIV_64
  *         @arg @ref LL_RCC_APB1_DIV_128
  */
__STATIC_INLINE uint32_t LL_RCC_GetAPB1Prescaler(void)
{
34189bb8:	b480      	push	{r7}
34189bba:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE1));
34189bbc:	4b04      	ldr	r3, [pc, #16]	@ (34189bd0 <LL_RCC_GetAPB1Prescaler+0x18>)
34189bbe:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34189bc0:	f003 0307 	and.w	r3, r3, #7
}
34189bc4:	4618      	mov	r0, r3
34189bc6:	46bd      	mov	sp, r7
34189bc8:	f85d 7b04 	ldr.w	r7, [sp], #4
34189bcc:	4770      	bx	lr
34189bce:	bf00      	nop
34189bd0:	56028000 	.word	0x56028000

34189bd4 <LL_RCC_PLL1_GetSource>:
  *         @arg @ref LL_RCC_PLLSOURCE_MSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  *         @arg @ref LL_RCC_PLLSOURCE_I2S_CKIN
  */
__STATIC_INLINE uint32_t LL_RCC_PLL1_GetSource(void)
{
34189bd4:	b480      	push	{r7}
34189bd6:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1SEL));
34189bd8:	4b04      	ldr	r3, [pc, #16]	@ (34189bec <LL_RCC_PLL1_GetSource+0x18>)
34189bda:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34189bde:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
34189be2:	4618      	mov	r0, r3
34189be4:	46bd      	mov	sp, r7
34189be6:	f85d 7b04 	ldr.w	r7, [sp], #4
34189bea:	4770      	bx	lr
34189bec:	56028000 	.word	0x56028000

34189bf0 <LL_RCC_PLL1_IsReady>:
  * @brief  Check if PLL1 Ready
  * @rmtoll SR           PLL1RDY         LL_RCC_PLL1_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL1_IsReady(void)
{
34189bf0:	b480      	push	{r7}
34189bf2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL1RDY) == (RCC_SR_PLL1RDY)) ? 1UL : 0UL);
34189bf4:	4b07      	ldr	r3, [pc, #28]	@ (34189c14 <LL_RCC_PLL1_IsReady+0x24>)
34189bf6:	685b      	ldr	r3, [r3, #4]
34189bf8:	f403 7380 	and.w	r3, r3, #256	@ 0x100
34189bfc:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34189c00:	d101      	bne.n	34189c06 <LL_RCC_PLL1_IsReady+0x16>
34189c02:	2301      	movs	r3, #1
34189c04:	e000      	b.n	34189c08 <LL_RCC_PLL1_IsReady+0x18>
34189c06:	2300      	movs	r3, #0
}
34189c08:	4618      	mov	r0, r3
34189c0a:	46bd      	mov	sp, r7
34189c0c:	f85d 7b04 	ldr.w	r7, [sp], #4
34189c10:	4770      	bx	lr
34189c12:	bf00      	nop
34189c14:	56028000 	.word	0x56028000

34189c18 <LL_RCC_PLL1_IsEnabledBypass>:
  * @brief  Check if PLL1 bypass is enabled
  * @rmtoll PLL1CFGR1    PLL1BYP         LL_RCC_PLL1_IsEnabledBypass
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL1_IsEnabledBypass(void)
{
34189c18:	b480      	push	{r7}
34189c1a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1BYP) == RCC_PLL1CFGR1_PLL1BYP) ? 1UL : 0UL);
34189c1c:	4b07      	ldr	r3, [pc, #28]	@ (34189c3c <LL_RCC_PLL1_IsEnabledBypass+0x24>)
34189c1e:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34189c22:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34189c26:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
34189c2a:	d101      	bne.n	34189c30 <LL_RCC_PLL1_IsEnabledBypass+0x18>
34189c2c:	2301      	movs	r3, #1
34189c2e:	e000      	b.n	34189c32 <LL_RCC_PLL1_IsEnabledBypass+0x1a>
34189c30:	2300      	movs	r3, #0
}
34189c32:	4618      	mov	r0, r3
34189c34:	46bd      	mov	sp, r7
34189c36:	f85d 7b04 	ldr.w	r7, [sp], #4
34189c3a:	4770      	bx	lr
34189c3c:	56028000 	.word	0x56028000

34189c40 <LL_RCC_PLL2_GetSource>:
  *         @arg @ref LL_RCC_PLLSOURCE_MSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  *         @arg @ref LL_RCC_PLLSOURCE_I2S_CKIN
  */
__STATIC_INLINE uint32_t LL_RCC_PLL2_GetSource(void)
{
34189c40:	b480      	push	{r7}
34189c42:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2SEL));
34189c44:	4b04      	ldr	r3, [pc, #16]	@ (34189c58 <LL_RCC_PLL2_GetSource+0x18>)
34189c46:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
34189c4a:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
34189c4e:	4618      	mov	r0, r3
34189c50:	46bd      	mov	sp, r7
34189c52:	f85d 7b04 	ldr.w	r7, [sp], #4
34189c56:	4770      	bx	lr
34189c58:	56028000 	.word	0x56028000

34189c5c <LL_RCC_PLL2_IsReady>:
  * @brief  Check if PLL2 Ready
  * @rmtoll SR           PLL2RDY         LL_RCC_PLL2_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL2_IsReady(void)
{
34189c5c:	b480      	push	{r7}
34189c5e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL2RDY) == (RCC_SR_PLL2RDY)) ? 1UL : 0UL);
34189c60:	4b07      	ldr	r3, [pc, #28]	@ (34189c80 <LL_RCC_PLL2_IsReady+0x24>)
34189c62:	685b      	ldr	r3, [r3, #4]
34189c64:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34189c68:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
34189c6c:	d101      	bne.n	34189c72 <LL_RCC_PLL2_IsReady+0x16>
34189c6e:	2301      	movs	r3, #1
34189c70:	e000      	b.n	34189c74 <LL_RCC_PLL2_IsReady+0x18>
34189c72:	2300      	movs	r3, #0
}
34189c74:	4618      	mov	r0, r3
34189c76:	46bd      	mov	sp, r7
34189c78:	f85d 7b04 	ldr.w	r7, [sp], #4
34189c7c:	4770      	bx	lr
34189c7e:	bf00      	nop
34189c80:	56028000 	.word	0x56028000

34189c84 <LL_RCC_PLL2_IsEnabledBypass>:
  * @brief  Check if PLL2 bypass is enabled
  * @rmtoll PLL2CFGR1    PLL2BYP         LL_RCC_PLL2_IsEnabledBypass
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL2_IsEnabledBypass(void)
{
34189c84:	b480      	push	{r7}
34189c86:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2BYP) == RCC_PLL2CFGR1_PLL2BYP) ? 1UL : 0UL);
34189c88:	4b07      	ldr	r3, [pc, #28]	@ (34189ca8 <LL_RCC_PLL2_IsEnabledBypass+0x24>)
34189c8a:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
34189c8e:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34189c92:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
34189c96:	d101      	bne.n	34189c9c <LL_RCC_PLL2_IsEnabledBypass+0x18>
34189c98:	2301      	movs	r3, #1
34189c9a:	e000      	b.n	34189c9e <LL_RCC_PLL2_IsEnabledBypass+0x1a>
34189c9c:	2300      	movs	r3, #0
}
34189c9e:	4618      	mov	r0, r3
34189ca0:	46bd      	mov	sp, r7
34189ca2:	f85d 7b04 	ldr.w	r7, [sp], #4
34189ca6:	4770      	bx	lr
34189ca8:	56028000 	.word	0x56028000

34189cac <LL_RCC_PLL3_GetSource>:
  *         @arg @ref LL_RCC_PLLSOURCE_MSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  *         @arg @ref LL_RCC_PLLSOURCE_I2S_CKIN
  */
__STATIC_INLINE uint32_t LL_RCC_PLL3_GetSource(void)
{
34189cac:	b480      	push	{r7}
34189cae:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3SEL));
34189cb0:	4b04      	ldr	r3, [pc, #16]	@ (34189cc4 <LL_RCC_PLL3_GetSource+0x18>)
34189cb2:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
34189cb6:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
34189cba:	4618      	mov	r0, r3
34189cbc:	46bd      	mov	sp, r7
34189cbe:	f85d 7b04 	ldr.w	r7, [sp], #4
34189cc2:	4770      	bx	lr
34189cc4:	56028000 	.word	0x56028000

34189cc8 <LL_RCC_PLL3_IsReady>:
  * @brief  Check if PLL3 Ready
  * @rmtoll SR           PLL3RDY         LL_RCC_PLL3_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL3_IsReady(void)
{
34189cc8:	b480      	push	{r7}
34189cca:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL3RDY) == (RCC_SR_PLL3RDY)) ? 1UL : 0UL);
34189ccc:	4b07      	ldr	r3, [pc, #28]	@ (34189cec <LL_RCC_PLL3_IsReady+0x24>)
34189cce:	685b      	ldr	r3, [r3, #4]
34189cd0:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34189cd4:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
34189cd8:	d101      	bne.n	34189cde <LL_RCC_PLL3_IsReady+0x16>
34189cda:	2301      	movs	r3, #1
34189cdc:	e000      	b.n	34189ce0 <LL_RCC_PLL3_IsReady+0x18>
34189cde:	2300      	movs	r3, #0
}
34189ce0:	4618      	mov	r0, r3
34189ce2:	46bd      	mov	sp, r7
34189ce4:	f85d 7b04 	ldr.w	r7, [sp], #4
34189ce8:	4770      	bx	lr
34189cea:	bf00      	nop
34189cec:	56028000 	.word	0x56028000

34189cf0 <LL_RCC_PLL3_IsEnabledBypass>:
  * @brief  Check if PLL3 bypass is enabled
  * @rmtoll PLL3CFGR1    PLL3BYP         LL_RCC_PLL3_IsEnabledBypass
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL3_IsEnabledBypass(void)
{
34189cf0:	b480      	push	{r7}
34189cf2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3BYP) == RCC_PLL3CFGR1_PLL3BYP) ? 1UL : 0UL);
34189cf4:	4b07      	ldr	r3, [pc, #28]	@ (34189d14 <LL_RCC_PLL3_IsEnabledBypass+0x24>)
34189cf6:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
34189cfa:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34189cfe:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
34189d02:	d101      	bne.n	34189d08 <LL_RCC_PLL3_IsEnabledBypass+0x18>
34189d04:	2301      	movs	r3, #1
34189d06:	e000      	b.n	34189d0a <LL_RCC_PLL3_IsEnabledBypass+0x1a>
34189d08:	2300      	movs	r3, #0
}
34189d0a:	4618      	mov	r0, r3
34189d0c:	46bd      	mov	sp, r7
34189d0e:	f85d 7b04 	ldr.w	r7, [sp], #4
34189d12:	4770      	bx	lr
34189d14:	56028000 	.word	0x56028000

34189d18 <LL_RCC_PLL4_GetSource>:
  *         @arg @ref LL_RCC_PLLSOURCE_MSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  *         @arg @ref LL_RCC_PLLSOURCE_I2S_CKIN
  */
__STATIC_INLINE uint32_t LL_RCC_PLL4_GetSource(void)
{
34189d18:	b480      	push	{r7}
34189d1a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4SEL));
34189d1c:	4b04      	ldr	r3, [pc, #16]	@ (34189d30 <LL_RCC_PLL4_GetSource+0x18>)
34189d1e:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
34189d22:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
34189d26:	4618      	mov	r0, r3
34189d28:	46bd      	mov	sp, r7
34189d2a:	f85d 7b04 	ldr.w	r7, [sp], #4
34189d2e:	4770      	bx	lr
34189d30:	56028000 	.word	0x56028000

34189d34 <LL_RCC_PLL4_IsReady>:
  * @brief  Check if PLL4 Ready
  * @rmtoll SR           PLL4RDY         LL_RCC_PLL4_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL4_IsReady(void)
{
34189d34:	b480      	push	{r7}
34189d36:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL4RDY) == (RCC_SR_PLL4RDY)) ? 1UL : 0UL);
34189d38:	4b07      	ldr	r3, [pc, #28]	@ (34189d58 <LL_RCC_PLL4_IsReady+0x24>)
34189d3a:	685b      	ldr	r3, [r3, #4]
34189d3c:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
34189d40:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
34189d44:	d101      	bne.n	34189d4a <LL_RCC_PLL4_IsReady+0x16>
34189d46:	2301      	movs	r3, #1
34189d48:	e000      	b.n	34189d4c <LL_RCC_PLL4_IsReady+0x18>
34189d4a:	2300      	movs	r3, #0
}
34189d4c:	4618      	mov	r0, r3
34189d4e:	46bd      	mov	sp, r7
34189d50:	f85d 7b04 	ldr.w	r7, [sp], #4
34189d54:	4770      	bx	lr
34189d56:	bf00      	nop
34189d58:	56028000 	.word	0x56028000

34189d5c <LL_RCC_PLL4_IsEnabledBypass>:
  * @brief  Check if PLL4 bypass is enabled
  * @rmtoll PLL4CFGR1    PLL4BYP         LL_RCC_PLL4_IsEnabledBypass
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL4_IsEnabledBypass(void)
{
34189d5c:	b480      	push	{r7}
34189d5e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4BYP) == RCC_PLL4CFGR1_PLL4BYP) ? 1UL : 0UL);
34189d60:	4b07      	ldr	r3, [pc, #28]	@ (34189d80 <LL_RCC_PLL4_IsEnabledBypass+0x24>)
34189d62:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
34189d66:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34189d6a:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
34189d6e:	d101      	bne.n	34189d74 <LL_RCC_PLL4_IsEnabledBypass+0x18>
34189d70:	2301      	movs	r3, #1
34189d72:	e000      	b.n	34189d76 <LL_RCC_PLL4_IsEnabledBypass+0x1a>
34189d74:	2300      	movs	r3, #0
}
34189d76:	4618      	mov	r0, r3
34189d78:	46bd      	mov	sp, r7
34189d7a:	f85d 7b04 	ldr.w	r7, [sp], #4
34189d7e:	4770      	bx	lr
34189d80:	56028000 	.word	0x56028000

34189d84 <LL_RCC_IC1_Enable>:
  * @brief  Enable IC1
  * @rmtoll DIVENSR      IC1ENS        LL_RCC_IC1_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC1_Enable(void)
{
34189d84:	b480      	push	{r7}
34189d86:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC1ENS);
34189d88:	4b04      	ldr	r3, [pc, #16]	@ (34189d9c <LL_RCC_IC1_Enable+0x18>)
34189d8a:	2201      	movs	r2, #1
34189d8c:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
34189d90:	bf00      	nop
34189d92:	46bd      	mov	sp, r7
34189d94:	f85d 7b04 	ldr.w	r7, [sp], #4
34189d98:	4770      	bx	lr
34189d9a:	bf00      	nop
34189d9c:	56028000 	.word	0x56028000

34189da0 <LL_RCC_IC1_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC1_GetSource(void)
{
34189da0:	b480      	push	{r7}
34189da2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL));
34189da4:	4b04      	ldr	r3, [pc, #16]	@ (34189db8 <LL_RCC_IC1_GetSource+0x18>)
34189da6:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
34189daa:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
34189dae:	4618      	mov	r0, r3
34189db0:	46bd      	mov	sp, r7
34189db2:	f85d 7b04 	ldr.w	r7, [sp], #4
34189db6:	4770      	bx	lr
34189db8:	56028000 	.word	0x56028000

34189dbc <LL_RCC_IC1_GetDivider>:
  * @brief  Get IC1 divider
  * @rmtoll IC1CFGR      IC1INT        LL_RCC_IC1_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC1_GetDivider(void)
{
34189dbc:	b480      	push	{r7}
34189dbe:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1UL);
34189dc0:	4b05      	ldr	r3, [pc, #20]	@ (34189dd8 <LL_RCC_IC1_GetDivider+0x1c>)
34189dc2:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
34189dc6:	0c1b      	lsrs	r3, r3, #16
34189dc8:	b2db      	uxtb	r3, r3
34189dca:	3301      	adds	r3, #1
}
34189dcc:	4618      	mov	r0, r3
34189dce:	46bd      	mov	sp, r7
34189dd0:	f85d 7b04 	ldr.w	r7, [sp], #4
34189dd4:	4770      	bx	lr
34189dd6:	bf00      	nop
34189dd8:	56028000 	.word	0x56028000

34189ddc <LL_RCC_IC2_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC2_GetSource(void)
{
34189ddc:	b480      	push	{r7}
34189dde:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2SEL));
34189de0:	4b04      	ldr	r3, [pc, #16]	@ (34189df4 <LL_RCC_IC2_GetSource+0x18>)
34189de2:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
34189de6:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
34189dea:	4618      	mov	r0, r3
34189dec:	46bd      	mov	sp, r7
34189dee:	f85d 7b04 	ldr.w	r7, [sp], #4
34189df2:	4770      	bx	lr
34189df4:	56028000 	.word	0x56028000

34189df8 <LL_RCC_IC2_GetDivider>:
  * @brief  Get IC2 divider
  * @rmtoll IC2CFGR      IC2INT        LL_RCC_IC2_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC2_GetDivider(void)
{
34189df8:	b480      	push	{r7}
34189dfa:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2INT) >> RCC_IC2CFGR_IC2INT_Pos) + 1UL);
34189dfc:	4b05      	ldr	r3, [pc, #20]	@ (34189e14 <LL_RCC_IC2_GetDivider+0x1c>)
34189dfe:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
34189e02:	0c1b      	lsrs	r3, r3, #16
34189e04:	b2db      	uxtb	r3, r3
34189e06:	3301      	adds	r3, #1
}
34189e08:	4618      	mov	r0, r3
34189e0a:	46bd      	mov	sp, r7
34189e0c:	f85d 7b04 	ldr.w	r7, [sp], #4
34189e10:	4770      	bx	lr
34189e12:	bf00      	nop
34189e14:	56028000 	.word	0x56028000

34189e18 <LL_RCC_IC6_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC6_GetSource(void)
{
34189e18:	b480      	push	{r7}
34189e1a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC6CFGR, RCC_IC6CFGR_IC6SEL));
34189e1c:	4b04      	ldr	r3, [pc, #16]	@ (34189e30 <LL_RCC_IC6_GetSource+0x18>)
34189e1e:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
34189e22:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
34189e26:	4618      	mov	r0, r3
34189e28:	46bd      	mov	sp, r7
34189e2a:	f85d 7b04 	ldr.w	r7, [sp], #4
34189e2e:	4770      	bx	lr
34189e30:	56028000 	.word	0x56028000

34189e34 <LL_RCC_IC11_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC11_GetSource(void)
{
34189e34:	b480      	push	{r7}
34189e36:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC11CFGR, RCC_IC11CFGR_IC11SEL));
34189e38:	4b04      	ldr	r3, [pc, #16]	@ (34189e4c <LL_RCC_IC11_GetSource+0x18>)
34189e3a:	f8d3 30ec 	ldr.w	r3, [r3, #236]	@ 0xec
34189e3e:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
34189e42:	4618      	mov	r0, r3
34189e44:	46bd      	mov	sp, r7
34189e46:	f85d 7b04 	ldr.w	r7, [sp], #4
34189e4a:	4770      	bx	lr
34189e4c:	56028000 	.word	0x56028000

34189e50 <HAL_RCC_OscConfig>:
  * @note   This function activates HSE but does not wait for the startup time defined in the datasheet.
  *         This must be ensured by the application when the HSE is selected as PLL source.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(const RCC_OscInitTypeDef  *pRCC_OscInitStruct)
{
34189e50:	b580      	push	{r7, lr}
34189e52:	b0a2      	sub	sp, #136	@ 0x88
34189e54:	af00      	add	r7, sp, #0
34189e56:	6078      	str	r0, [r7, #4]
  uint32_t pll3src;
  uint32_t pll4src;
  uint32_t rccsr;

  /* Check Null pointer */
  if (pRCC_OscInitStruct == NULL)
34189e58:	687b      	ldr	r3, [r7, #4]
34189e5a:	2b00      	cmp	r3, #0
34189e5c:	d101      	bne.n	34189e62 <HAL_RCC_OscConfig+0x12>
  {
    return HAL_ERROR;
34189e5e:	2301      	movs	r3, #1
34189e60:	e3d1      	b.n	3418a606 <HAL_RCC_OscConfig+0x7b6>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(pRCC_OscInitStruct->OscillatorType));

  cpuclksrc = LL_RCC_GetCpuClkSource();
34189e62:	f7ff fe7f 	bl	34189b64 <LL_RCC_GetCpuClkSource>
34189e66:	f8c7 0084 	str.w	r0, [r7, #132]	@ 0x84
  sysclksrc = LL_RCC_GetSysClkSource();
34189e6a:	f7ff fe89 	bl	34189b80 <LL_RCC_GetSysClkSource>
34189e6e:	f8c7 0080 	str.w	r0, [r7, #128]	@ 0x80
  pll1src = LL_RCC_PLL1_GetSource();
34189e72:	f7ff feaf 	bl	34189bd4 <LL_RCC_PLL1_GetSource>
34189e76:	67f8      	str	r0, [r7, #124]	@ 0x7c
  pll2src = LL_RCC_PLL2_GetSource();
34189e78:	f7ff fee2 	bl	34189c40 <LL_RCC_PLL2_GetSource>
34189e7c:	67b8      	str	r0, [r7, #120]	@ 0x78
  pll3src = LL_RCC_PLL3_GetSource();
34189e7e:	f7ff ff15 	bl	34189cac <LL_RCC_PLL3_GetSource>
34189e82:	6778      	str	r0, [r7, #116]	@ 0x74
  pll4src = LL_RCC_PLL4_GetSource();
34189e84:	f7ff ff48 	bl	34189d18 <LL_RCC_PLL4_GetSource>
34189e88:	6738      	str	r0, [r7, #112]	@ 0x70
  rccsr = RCC->SR;
34189e8a:	4b91      	ldr	r3, [pc, #580]	@ (3418a0d0 <HAL_RCC_OscConfig+0x280>)
34189e8c:	685b      	ldr	r3, [r3, #4]
34189e8e:	66fb      	str	r3, [r7, #108]	@ 0x6c

  /*------------------------------- HSE Configuration ------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
34189e90:	687b      	ldr	r3, [r7, #4]
34189e92:	681b      	ldr	r3, [r3, #0]
34189e94:	f003 0301 	and.w	r3, r3, #1
34189e98:	2b00      	cmp	r3, #0
34189e9a:	f000 80a8 	beq.w	34189fee <HAL_RCC_OscConfig+0x19e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(pRCC_OscInitStruct->HSEState));

    /* When the HSE is used as cpu/system bus clock or clock source for any PLL, it is not allowed to be disabled */
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_HSE) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSE) ||
34189e9e:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
34189ea2:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
34189ea6:	d028      	beq.n	34189efa <HAL_RCC_OscConfig+0xaa>
34189ea8:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
34189eac:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34189eb0:	d023      	beq.n	34189efa <HAL_RCC_OscConfig+0xaa>
34189eb2:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
34189eb4:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34189eb8:	d104      	bne.n	34189ec4 <HAL_RCC_OscConfig+0x74>
        ((pll1src == LL_RCC_PLLSOURCE_HSE) && (((rccsr & RCC_SR_PLL1RDY) == RCC_SR_PLL1RDY))) ||
34189eba:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
34189ebc:	f403 7380 	and.w	r3, r3, #256	@ 0x100
34189ec0:	2b00      	cmp	r3, #0
34189ec2:	d11a      	bne.n	34189efa <HAL_RCC_OscConfig+0xaa>
34189ec4:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
34189ec6:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34189eca:	d104      	bne.n	34189ed6 <HAL_RCC_OscConfig+0x86>
        ((pll2src == LL_RCC_PLLSOURCE_HSE) && (((rccsr & RCC_SR_PLL2RDY) == RCC_SR_PLL2RDY))) ||
34189ecc:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
34189ece:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34189ed2:	2b00      	cmp	r3, #0
34189ed4:	d111      	bne.n	34189efa <HAL_RCC_OscConfig+0xaa>
34189ed6:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
34189ed8:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34189edc:	d104      	bne.n	34189ee8 <HAL_RCC_OscConfig+0x98>
        ((pll3src == LL_RCC_PLLSOURCE_HSE) && (((rccsr & RCC_SR_PLL3RDY) == RCC_SR_PLL3RDY))) ||
34189ede:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
34189ee0:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34189ee4:	2b00      	cmp	r3, #0
34189ee6:	d108      	bne.n	34189efa <HAL_RCC_OscConfig+0xaa>
34189ee8:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
34189eea:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34189eee:	d10a      	bne.n	34189f06 <HAL_RCC_OscConfig+0xb6>
        ((pll4src == LL_RCC_PLLSOURCE_HSE) && (((rccsr & RCC_SR_PLL4RDY) == RCC_SR_PLL4RDY))))
34189ef0:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
34189ef2:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
34189ef6:	2b00      	cmp	r3, #0
34189ef8:	d005      	beq.n	34189f06 <HAL_RCC_OscConfig+0xb6>
    {
      if (pRCC_OscInitStruct->HSEState == RCC_HSE_OFF)
34189efa:	687b      	ldr	r3, [r7, #4]
34189efc:	685b      	ldr	r3, [r3, #4]
34189efe:	2b00      	cmp	r3, #0
34189f00:	d175      	bne.n	34189fee <HAL_RCC_OscConfig+0x19e>
      {
        return HAL_ERROR;
34189f02:	2301      	movs	r3, #1
34189f04:	e37f      	b.n	3418a606 <HAL_RCC_OscConfig+0x7b6>
      /* HSE ON , nothing to do */
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(pRCC_OscInitStruct->HSEState);
34189f06:	687b      	ldr	r3, [r7, #4]
34189f08:	685b      	ldr	r3, [r3, #4]
34189f0a:	2b10      	cmp	r3, #16
34189f0c:	d104      	bne.n	34189f18 <HAL_RCC_OscConfig+0xc8>
34189f0e:	4b70      	ldr	r3, [pc, #448]	@ (3418a0d0 <HAL_RCC_OscConfig+0x280>)
34189f10:	2210      	movs	r2, #16
34189f12:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
34189f16:	e043      	b.n	34189fa0 <HAL_RCC_OscConfig+0x150>
34189f18:	687b      	ldr	r3, [r7, #4]
34189f1a:	685b      	ldr	r3, [r3, #4]
34189f1c:	2b00      	cmp	r3, #0
34189f1e:	d10c      	bne.n	34189f3a <HAL_RCC_OscConfig+0xea>
34189f20:	4b6b      	ldr	r3, [pc, #428]	@ (3418a0d0 <HAL_RCC_OscConfig+0x280>)
34189f22:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34189f26:	461a      	mov	r2, r3
34189f28:	2310      	movs	r3, #16
34189f2a:	6013      	str	r3, [r2, #0]
34189f2c:	4b68      	ldr	r3, [pc, #416]	@ (3418a0d0 <HAL_RCC_OscConfig+0x280>)
34189f2e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34189f30:	4a67      	ldr	r2, [pc, #412]	@ (3418a0d0 <HAL_RCC_OscConfig+0x280>)
34189f32:	f423 33c0 	bic.w	r3, r3, #98304	@ 0x18000
34189f36:	6553      	str	r3, [r2, #84]	@ 0x54
34189f38:	e032      	b.n	34189fa0 <HAL_RCC_OscConfig+0x150>
34189f3a:	687b      	ldr	r3, [r7, #4]
34189f3c:	685b      	ldr	r3, [r3, #4]
34189f3e:	f248 0210 	movw	r2, #32784	@ 0x8010
34189f42:	4293      	cmp	r3, r2
34189f44:	d110      	bne.n	34189f68 <HAL_RCC_OscConfig+0x118>
34189f46:	4b62      	ldr	r3, [pc, #392]	@ (3418a0d0 <HAL_RCC_OscConfig+0x280>)
34189f48:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34189f4a:	4a61      	ldr	r2, [pc, #388]	@ (3418a0d0 <HAL_RCC_OscConfig+0x280>)
34189f4c:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
34189f50:	6553      	str	r3, [r2, #84]	@ 0x54
34189f52:	4b5f      	ldr	r3, [pc, #380]	@ (3418a0d0 <HAL_RCC_OscConfig+0x280>)
34189f54:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34189f56:	4a5e      	ldr	r2, [pc, #376]	@ (3418a0d0 <HAL_RCC_OscConfig+0x280>)
34189f58:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
34189f5c:	6553      	str	r3, [r2, #84]	@ 0x54
34189f5e:	4b5c      	ldr	r3, [pc, #368]	@ (3418a0d0 <HAL_RCC_OscConfig+0x280>)
34189f60:	2210      	movs	r2, #16
34189f62:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
34189f66:	e01b      	b.n	34189fa0 <HAL_RCC_OscConfig+0x150>
34189f68:	687b      	ldr	r3, [r7, #4]
34189f6a:	685b      	ldr	r3, [r3, #4]
34189f6c:	4a59      	ldr	r2, [pc, #356]	@ (3418a0d4 <HAL_RCC_OscConfig+0x284>)
34189f6e:	4293      	cmp	r3, r2
34189f70:	d10a      	bne.n	34189f88 <HAL_RCC_OscConfig+0x138>
34189f72:	4b57      	ldr	r3, [pc, #348]	@ (3418a0d0 <HAL_RCC_OscConfig+0x280>)
34189f74:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34189f76:	4a56      	ldr	r2, [pc, #344]	@ (3418a0d0 <HAL_RCC_OscConfig+0x280>)
34189f78:	f443 33c0 	orr.w	r3, r3, #98304	@ 0x18000
34189f7c:	6553      	str	r3, [r2, #84]	@ 0x54
34189f7e:	4b54      	ldr	r3, [pc, #336]	@ (3418a0d0 <HAL_RCC_OscConfig+0x280>)
34189f80:	2210      	movs	r2, #16
34189f82:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
34189f86:	e00b      	b.n	34189fa0 <HAL_RCC_OscConfig+0x150>
34189f88:	4b51      	ldr	r3, [pc, #324]	@ (3418a0d0 <HAL_RCC_OscConfig+0x280>)
34189f8a:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34189f8e:	461a      	mov	r2, r3
34189f90:	2310      	movs	r3, #16
34189f92:	6013      	str	r3, [r2, #0]
34189f94:	4b4e      	ldr	r3, [pc, #312]	@ (3418a0d0 <HAL_RCC_OscConfig+0x280>)
34189f96:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34189f98:	4a4d      	ldr	r2, [pc, #308]	@ (3418a0d0 <HAL_RCC_OscConfig+0x280>)
34189f9a:	f423 33c0 	bic.w	r3, r3, #98304	@ 0x18000
34189f9e:	6553      	str	r3, [r2, #84]	@ 0x54

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
34189fa0:	f7fb fb0a 	bl	341855b8 <HAL_GetTick>
34189fa4:	66b8      	str	r0, [r7, #104]	@ 0x68

      /* Check the HSE State */
      if (pRCC_OscInitStruct->HSEState != RCC_HSE_OFF)
34189fa6:	687b      	ldr	r3, [r7, #4]
34189fa8:	685b      	ldr	r3, [r3, #4]
34189faa:	2b00      	cmp	r3, #0
34189fac:	d019      	beq.n	34189fe2 <HAL_RCC_OscConfig+0x192>
      {
        /* Wait till HSE is ready */
        while (READ_BIT(RCC->SR, RCC_SR_HSERDY) == 0U)
34189fae:	e008      	b.n	34189fc2 <HAL_RCC_OscConfig+0x172>
        {
          if ((HAL_GetTick() - tickstart) > RCC_HSE_TIMEOUT_VALUE)
34189fb0:	f7fb fb02 	bl	341855b8 <HAL_GetTick>
34189fb4:	4602      	mov	r2, r0
34189fb6:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
34189fb8:	1ad3      	subs	r3, r2, r3
34189fba:	2b64      	cmp	r3, #100	@ 0x64
34189fbc:	d901      	bls.n	34189fc2 <HAL_RCC_OscConfig+0x172>
          {
            return HAL_TIMEOUT;
34189fbe:	2303      	movs	r3, #3
34189fc0:	e321      	b.n	3418a606 <HAL_RCC_OscConfig+0x7b6>
        while (READ_BIT(RCC->SR, RCC_SR_HSERDY) == 0U)
34189fc2:	4b43      	ldr	r3, [pc, #268]	@ (3418a0d0 <HAL_RCC_OscConfig+0x280>)
34189fc4:	685b      	ldr	r3, [r3, #4]
34189fc6:	f003 0310 	and.w	r3, r3, #16
34189fca:	2b00      	cmp	r3, #0
34189fcc:	d0f0      	beq.n	34189fb0 <HAL_RCC_OscConfig+0x160>
34189fce:	e00e      	b.n	34189fee <HAL_RCC_OscConfig+0x19e>
      else
      {
        /* Wait till HSE is disabled */
        while (READ_BIT(RCC->SR, RCC_SR_HSERDY) != 0U)
        {
          if ((HAL_GetTick() - tickstart) > RCC_HSE_TIMEOUT_VALUE)
34189fd0:	f7fb faf2 	bl	341855b8 <HAL_GetTick>
34189fd4:	4602      	mov	r2, r0
34189fd6:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
34189fd8:	1ad3      	subs	r3, r2, r3
34189fda:	2b64      	cmp	r3, #100	@ 0x64
34189fdc:	d901      	bls.n	34189fe2 <HAL_RCC_OscConfig+0x192>
          {
            return HAL_TIMEOUT;
34189fde:	2303      	movs	r3, #3
34189fe0:	e311      	b.n	3418a606 <HAL_RCC_OscConfig+0x7b6>
        while (READ_BIT(RCC->SR, RCC_SR_HSERDY) != 0U)
34189fe2:	4b3b      	ldr	r3, [pc, #236]	@ (3418a0d0 <HAL_RCC_OscConfig+0x280>)
34189fe4:	685b      	ldr	r3, [r3, #4]
34189fe6:	f003 0310 	and.w	r3, r3, #16
34189fea:	2b00      	cmp	r3, #0
34189fec:	d1f0      	bne.n	34189fd0 <HAL_RCC_OscConfig+0x180>
      }
    }
  }

  /*----------------------------- HSI Configuration --------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
34189fee:	687b      	ldr	r3, [r7, #4]
34189ff0:	681b      	ldr	r3, [r3, #0]
34189ff2:	f003 0302 	and.w	r3, r3, #2
34189ff6:	2b00      	cmp	r3, #0
34189ff8:	d073      	beq.n	3418a0e2 <HAL_RCC_OscConfig+0x292>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI(pRCC_OscInitStruct->HSIState));

    /* When the HSI is used as cpu/system bus clock or clock source for any PLL, it is not allowed to be disabled */
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_HSI) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSI) ||
34189ffa:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
34189ffe:	2b00      	cmp	r3, #0
3418a000:	d023      	beq.n	3418a04a <HAL_RCC_OscConfig+0x1fa>
3418a002:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3418a006:	2b00      	cmp	r3, #0
3418a008:	d01f      	beq.n	3418a04a <HAL_RCC_OscConfig+0x1fa>
3418a00a:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
3418a00c:	2b00      	cmp	r3, #0
3418a00e:	d104      	bne.n	3418a01a <HAL_RCC_OscConfig+0x1ca>
        ((pll1src == LL_RCC_PLLSOURCE_HSI) && (((rccsr & RCC_SR_PLL1RDY) == RCC_SR_PLL1RDY))) ||
3418a010:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3418a012:	f403 7380 	and.w	r3, r3, #256	@ 0x100
3418a016:	2b00      	cmp	r3, #0
3418a018:	d117      	bne.n	3418a04a <HAL_RCC_OscConfig+0x1fa>
3418a01a:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
3418a01c:	2b00      	cmp	r3, #0
3418a01e:	d104      	bne.n	3418a02a <HAL_RCC_OscConfig+0x1da>
        ((pll2src == LL_RCC_PLLSOURCE_HSI) && (((rccsr & RCC_SR_PLL2RDY) == RCC_SR_PLL2RDY))) ||
3418a020:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3418a022:	f403 7300 	and.w	r3, r3, #512	@ 0x200
3418a026:	2b00      	cmp	r3, #0
3418a028:	d10f      	bne.n	3418a04a <HAL_RCC_OscConfig+0x1fa>
3418a02a:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
3418a02c:	2b00      	cmp	r3, #0
3418a02e:	d104      	bne.n	3418a03a <HAL_RCC_OscConfig+0x1ea>
        ((pll3src == LL_RCC_PLLSOURCE_HSI) && (((rccsr & RCC_SR_PLL3RDY) == RCC_SR_PLL3RDY))) ||
3418a030:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3418a032:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
3418a036:	2b00      	cmp	r3, #0
3418a038:	d107      	bne.n	3418a04a <HAL_RCC_OscConfig+0x1fa>
3418a03a:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
3418a03c:	2b00      	cmp	r3, #0
3418a03e:	d115      	bne.n	3418a06c <HAL_RCC_OscConfig+0x21c>
        ((pll4src == LL_RCC_PLLSOURCE_HSI) && (((rccsr & RCC_SR_PLL4RDY) == RCC_SR_PLL4RDY))))
3418a040:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3418a042:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
3418a046:	2b00      	cmp	r3, #0
3418a048:	d010      	beq.n	3418a06c <HAL_RCC_OscConfig+0x21c>
    {
      /* When HSI is used as system clock it will not be disabled */
      if (pRCC_OscInitStruct->HSIState == RCC_HSI_OFF)
3418a04a:	687b      	ldr	r3, [r7, #4]
3418a04c:	68db      	ldr	r3, [r3, #12]
3418a04e:	2b00      	cmp	r3, #0
3418a050:	d101      	bne.n	3418a056 <HAL_RCC_OscConfig+0x206>
      {
        return HAL_ERROR;
3418a052:	2301      	movs	r3, #1
3418a054:	e2d7      	b.n	3418a606 <HAL_RCC_OscConfig+0x7b6>
        /* Check the parameters */
        assert_param(IS_RCC_HSI_DIV(pRCC_OscInitStruct->HSIDiv));
        assert_param(IS_RCC_HSI_CALIBRATION_VALUE(pRCC_OscInitStruct->HSICalibrationValue));

        /* Set the HSI Divider */
        __HAL_RCC_HSI_DIVIDER_CONFIG(pRCC_OscInitStruct->HSIDiv);
3418a056:	687b      	ldr	r3, [r7, #4]
3418a058:	691b      	ldr	r3, [r3, #16]
3418a05a:	4618      	mov	r0, r3
3418a05c:	f7ff fca4 	bl	341899a8 <LL_RCC_HSI_SetDivider>
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(pRCC_OscInitStruct->HSICalibrationValue);
3418a060:	687b      	ldr	r3, [r7, #4]
3418a062:	695b      	ldr	r3, [r3, #20]
3418a064:	4618      	mov	r0, r3
3418a066:	f7ff fcc1 	bl	341899ec <LL_RCC_HSI_SetCalibTrimming>
      if (pRCC_OscInitStruct->HSIState == RCC_HSI_OFF)
3418a06a:	e03a      	b.n	3418a0e2 <HAL_RCC_OscConfig+0x292>
      }
    }
    else
    {
      /* Check the HSI State */
      if (pRCC_OscInitStruct->HSIState != RCC_HSI_OFF)
3418a06c:	687b      	ldr	r3, [r7, #4]
3418a06e:	68db      	ldr	r3, [r3, #12]
3418a070:	2b00      	cmp	r3, #0
3418a072:	d01e      	beq.n	3418a0b2 <HAL_RCC_OscConfig+0x262>
        /* Check the parameters */
        assert_param(IS_RCC_HSI_DIV(pRCC_OscInitStruct->HSIDiv));
        assert_param(IS_RCC_HSI_CALIBRATION_VALUE(pRCC_OscInitStruct->HSICalibrationValue));

        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
3418a074:	f7ff fc68 	bl	34189948 <LL_RCC_HSI_Enable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
3418a078:	f7fb fa9e 	bl	341855b8 <HAL_GetTick>
3418a07c:	66b8      	str	r0, [r7, #104]	@ 0x68

        /* Wait till HSI is ready */
        while (LL_RCC_HSI_IsReady() == 0U)
3418a07e:	e008      	b.n	3418a092 <HAL_RCC_OscConfig+0x242>
        {
          if ((HAL_GetTick() - tickstart) > RCC_HSI_TIMEOUT_VALUE)
3418a080:	f7fb fa9a 	bl	341855b8 <HAL_GetTick>
3418a084:	4602      	mov	r2, r0
3418a086:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3418a088:	1ad3      	subs	r3, r2, r3
3418a08a:	2b01      	cmp	r3, #1
3418a08c:	d901      	bls.n	3418a092 <HAL_RCC_OscConfig+0x242>
          {
            return HAL_TIMEOUT;
3418a08e:	2303      	movs	r3, #3
3418a090:	e2b9      	b.n	3418a606 <HAL_RCC_OscConfig+0x7b6>
        while (LL_RCC_HSI_IsReady() == 0U)
3418a092:	f7ff fc77 	bl	34189984 <LL_RCC_HSI_IsReady>
3418a096:	4603      	mov	r3, r0
3418a098:	2b00      	cmp	r3, #0
3418a09a:	d0f1      	beq.n	3418a080 <HAL_RCC_OscConfig+0x230>
          }
        }

        /* Set the HSI Divider */
        __HAL_RCC_HSI_DIVIDER_CONFIG(pRCC_OscInitStruct->HSIDiv);
3418a09c:	687b      	ldr	r3, [r7, #4]
3418a09e:	691b      	ldr	r3, [r3, #16]
3418a0a0:	4618      	mov	r0, r3
3418a0a2:	f7ff fc81 	bl	341899a8 <LL_RCC_HSI_SetDivider>
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(pRCC_OscInitStruct->HSICalibrationValue);
3418a0a6:	687b      	ldr	r3, [r7, #4]
3418a0a8:	695b      	ldr	r3, [r3, #20]
3418a0aa:	4618      	mov	r0, r3
3418a0ac:	f7ff fc9e 	bl	341899ec <LL_RCC_HSI_SetCalibTrimming>
3418a0b0:	e017      	b.n	3418a0e2 <HAL_RCC_OscConfig+0x292>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
3418a0b2:	f7ff fc57 	bl	34189964 <LL_RCC_HSI_Disable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
3418a0b6:	f7fb fa7f 	bl	341855b8 <HAL_GetTick>
3418a0ba:	66b8      	str	r0, [r7, #104]	@ 0x68

        /* Wait till HSI is disabled */
        while (LL_RCC_HSI_IsReady() != 0U)
3418a0bc:	e00c      	b.n	3418a0d8 <HAL_RCC_OscConfig+0x288>
        {
          if ((HAL_GetTick() - tickstart) > RCC_HSI_TIMEOUT_VALUE)
3418a0be:	f7fb fa7b 	bl	341855b8 <HAL_GetTick>
3418a0c2:	4602      	mov	r2, r0
3418a0c4:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3418a0c6:	1ad3      	subs	r3, r2, r3
3418a0c8:	2b01      	cmp	r3, #1
3418a0ca:	d905      	bls.n	3418a0d8 <HAL_RCC_OscConfig+0x288>
          {
            return HAL_TIMEOUT;
3418a0cc:	2303      	movs	r3, #3
3418a0ce:	e29a      	b.n	3418a606 <HAL_RCC_OscConfig+0x7b6>
3418a0d0:	56028000 	.word	0x56028000
3418a0d4:	00018010 	.word	0x00018010
        while (LL_RCC_HSI_IsReady() != 0U)
3418a0d8:	f7ff fc54 	bl	34189984 <LL_RCC_HSI_IsReady>
3418a0dc:	4603      	mov	r3, r0
3418a0de:	2b00      	cmp	r3, #0
3418a0e0:	d1ed      	bne.n	3418a0be <HAL_RCC_OscConfig+0x26e>
      }
    }
  }

  /*----------------------------- MSI Configuration --------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
3418a0e2:	687b      	ldr	r3, [r7, #4]
3418a0e4:	681b      	ldr	r3, [r3, #0]
3418a0e6:	f003 0310 	and.w	r3, r3, #16
3418a0ea:	2b00      	cmp	r3, #0
3418a0ec:	d070      	beq.n	3418a1d0 <HAL_RCC_OscConfig+0x380>
    /* Check the parameters */
    assert_param(IS_RCC_MSI(pRCC_OscInitStruct->MSIState));

    /* When the MSI is used as cpu/system bus clock or clock source for any PLL, it is not allowed to be disabled */
    /* but just to update the MSI calibration value */
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_MSI) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_MSI) ||
3418a0ee:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
3418a0f2:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
3418a0f6:	d028      	beq.n	3418a14a <HAL_RCC_OscConfig+0x2fa>
3418a0f8:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3418a0fc:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3418a100:	d023      	beq.n	3418a14a <HAL_RCC_OscConfig+0x2fa>
3418a102:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
3418a104:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3418a108:	d104      	bne.n	3418a114 <HAL_RCC_OscConfig+0x2c4>
        ((pll1src == LL_RCC_PLLSOURCE_MSI) && (((rccsr & RCC_SR_PLL1RDY) == RCC_SR_PLL1RDY))) ||
3418a10a:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3418a10c:	f403 7380 	and.w	r3, r3, #256	@ 0x100
3418a110:	2b00      	cmp	r3, #0
3418a112:	d11a      	bne.n	3418a14a <HAL_RCC_OscConfig+0x2fa>
3418a114:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
3418a116:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3418a11a:	d104      	bne.n	3418a126 <HAL_RCC_OscConfig+0x2d6>
        ((pll2src == LL_RCC_PLLSOURCE_MSI) && (((rccsr & RCC_SR_PLL2RDY) == RCC_SR_PLL2RDY))) ||
3418a11c:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3418a11e:	f403 7300 	and.w	r3, r3, #512	@ 0x200
3418a122:	2b00      	cmp	r3, #0
3418a124:	d111      	bne.n	3418a14a <HAL_RCC_OscConfig+0x2fa>
3418a126:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
3418a128:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3418a12c:	d104      	bne.n	3418a138 <HAL_RCC_OscConfig+0x2e8>
        ((pll3src == LL_RCC_PLLSOURCE_MSI) && (((rccsr & RCC_SR_PLL3RDY) == RCC_SR_PLL3RDY))) ||
3418a12e:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3418a130:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
3418a134:	2b00      	cmp	r3, #0
3418a136:	d108      	bne.n	3418a14a <HAL_RCC_OscConfig+0x2fa>
3418a138:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
3418a13a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3418a13e:	d110      	bne.n	3418a162 <HAL_RCC_OscConfig+0x312>
        ((pll4src == LL_RCC_PLLSOURCE_MSI) && (((rccsr & RCC_SR_PLL4RDY) == RCC_SR_PLL4RDY))))
3418a140:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3418a142:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
3418a146:	2b00      	cmp	r3, #0
3418a148:	d00b      	beq.n	3418a162 <HAL_RCC_OscConfig+0x312>
    {
      /* When MSI is used as system clock it will not disabled */
      if (pRCC_OscInitStruct->MSIState == RCC_MSI_OFF)
3418a14a:	687b      	ldr	r3, [r7, #4]
3418a14c:	69db      	ldr	r3, [r3, #28]
3418a14e:	2b00      	cmp	r3, #0
3418a150:	d101      	bne.n	3418a156 <HAL_RCC_OscConfig+0x306>
      {
        return HAL_ERROR;
3418a152:	2301      	movs	r3, #1
3418a154:	e257      	b.n	3418a606 <HAL_RCC_OscConfig+0x7b6>
      {
        /* Check the parameters */
        assert_param(IS_RCC_MSI_CALIBRATION_VALUE(pRCC_OscInitStruct->MSICalibrationValue));

        /* Adjusts the Internal High Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(pRCC_OscInitStruct->MSICalibrationValue);
3418a156:	687b      	ldr	r3, [r7, #4]
3418a158:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418a15a:	4618      	mov	r0, r3
3418a15c:	f7ff fcae 	bl	34189abc <LL_RCC_MSI_SetCalibTrimming>
      if (pRCC_OscInitStruct->MSIState == RCC_MSI_OFF)
3418a160:	e036      	b.n	3418a1d0 <HAL_RCC_OscConfig+0x380>
      }
    }
    else
    {
      /* Check the MSI State */
      if ((pRCC_OscInitStruct->MSIState) != RCC_MSI_OFF)
3418a162:	687b      	ldr	r3, [r7, #4]
3418a164:	69db      	ldr	r3, [r3, #28]
3418a166:	2b00      	cmp	r3, #0
3418a168:	d01e      	beq.n	3418a1a8 <HAL_RCC_OscConfig+0x358>
        /* Check the parameters */
        assert_param(IS_RCC_MSI_FREQUENCY(pRCC_OscInitStruct->MSIFrequency));
        assert_param(IS_RCC_MSI_CALIBRATION_VALUE(pRCC_OscInitStruct->MSICalibrationValue));

        /* Set the frequency */
        __HAL_RCC_MSI_FREQUENCY_CONFIG(pRCC_OscInitStruct->MSIFrequency);
3418a16a:	687b      	ldr	r3, [r7, #4]
3418a16c:	6a1b      	ldr	r3, [r3, #32]
3418a16e:	4618      	mov	r0, r3
3418a170:	f7ff fc82 	bl	34189a78 <LL_RCC_MSI_SetFrequency>

        /* Enable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_ENABLE();
3418a174:	f7ff fc50 	bl	34189a18 <LL_RCC_MSI_Enable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
3418a178:	f7fb fa1e 	bl	341855b8 <HAL_GetTick>
3418a17c:	66b8      	str	r0, [r7, #104]	@ 0x68

        /* Wait till MSI is ready */
        while (LL_RCC_MSI_IsReady() == 0U)
3418a17e:	e008      	b.n	3418a192 <HAL_RCC_OscConfig+0x342>
        {
          if ((HAL_GetTick() - tickstart) > RCC_MSI_TIMEOUT_VALUE)
3418a180:	f7fb fa1a 	bl	341855b8 <HAL_GetTick>
3418a184:	4602      	mov	r2, r0
3418a186:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3418a188:	1ad3      	subs	r3, r2, r3
3418a18a:	2b01      	cmp	r3, #1
3418a18c:	d901      	bls.n	3418a192 <HAL_RCC_OscConfig+0x342>
          {
            return HAL_TIMEOUT;
3418a18e:	2303      	movs	r3, #3
3418a190:	e239      	b.n	3418a606 <HAL_RCC_OscConfig+0x7b6>
        while (LL_RCC_MSI_IsReady() == 0U)
3418a192:	f7ff fc5f 	bl	34189a54 <LL_RCC_MSI_IsReady>
3418a196:	4603      	mov	r3, r0
3418a198:	2b00      	cmp	r3, #0
3418a19a:	d0f1      	beq.n	3418a180 <HAL_RCC_OscConfig+0x330>
          }
        }

        /* Adjusts the Internal High Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(pRCC_OscInitStruct->MSICalibrationValue);
3418a19c:	687b      	ldr	r3, [r7, #4]
3418a19e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418a1a0:	4618      	mov	r0, r3
3418a1a2:	f7ff fc8b 	bl	34189abc <LL_RCC_MSI_SetCalibTrimming>
3418a1a6:	e013      	b.n	3418a1d0 <HAL_RCC_OscConfig+0x380>
      }
      else
      {
        /* Ignore MSI frequency and calibration values in disable case */
        /* Disable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_DISABLE();
3418a1a8:	f7ff fc44 	bl	34189a34 <LL_RCC_MSI_Disable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
3418a1ac:	f7fb fa04 	bl	341855b8 <HAL_GetTick>
3418a1b0:	66b8      	str	r0, [r7, #104]	@ 0x68

        /* Wait till MSI is disabled */
        while (LL_RCC_MSI_IsReady() != 0U)
3418a1b2:	e008      	b.n	3418a1c6 <HAL_RCC_OscConfig+0x376>
        {
          if ((HAL_GetTick() - tickstart) > RCC_MSI_TIMEOUT_VALUE)
3418a1b4:	f7fb fa00 	bl	341855b8 <HAL_GetTick>
3418a1b8:	4602      	mov	r2, r0
3418a1ba:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3418a1bc:	1ad3      	subs	r3, r2, r3
3418a1be:	2b01      	cmp	r3, #1
3418a1c0:	d901      	bls.n	3418a1c6 <HAL_RCC_OscConfig+0x376>
          {
            return HAL_TIMEOUT;
3418a1c2:	2303      	movs	r3, #3
3418a1c4:	e21f      	b.n	3418a606 <HAL_RCC_OscConfig+0x7b6>
        while (LL_RCC_MSI_IsReady() != 0U)
3418a1c6:	f7ff fc45 	bl	34189a54 <LL_RCC_MSI_IsReady>
3418a1ca:	4603      	mov	r3, r0
3418a1cc:	2b00      	cmp	r3, #0
3418a1ce:	d1f1      	bne.n	3418a1b4 <HAL_RCC_OscConfig+0x364>
      }
    }
  }

  /*------------------------------ LSI Configuration -------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
3418a1d0:	687b      	ldr	r3, [r7, #4]
3418a1d2:	681b      	ldr	r3, [r3, #0]
3418a1d4:	f003 0308 	and.w	r3, r3, #8
3418a1d8:	2b00      	cmp	r3, #0
3418a1da:	d02c      	beq.n	3418a236 <HAL_RCC_OscConfig+0x3e6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(pRCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if ((pRCC_OscInitStruct->LSIState) != RCC_LSI_OFF)
3418a1dc:	687b      	ldr	r3, [r7, #4]
3418a1de:	699b      	ldr	r3, [r3, #24]
3418a1e0:	2b00      	cmp	r3, #0
3418a1e2:	d014      	beq.n	3418a20e <HAL_RCC_OscConfig+0x3be>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
3418a1e4:	f7ff fc92 	bl	34189b0c <LL_RCC_LSI_Enable>

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
3418a1e8:	f7fb f9e6 	bl	341855b8 <HAL_GetTick>
3418a1ec:	66b8      	str	r0, [r7, #104]	@ 0x68

      /* Wait till LSI is ready */
      while (LL_RCC_LSI_IsReady() == 0U)
3418a1ee:	e008      	b.n	3418a202 <HAL_RCC_OscConfig+0x3b2>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSI_TIMEOUT_VALUE)
3418a1f0:	f7fb f9e2 	bl	341855b8 <HAL_GetTick>
3418a1f4:	4602      	mov	r2, r0
3418a1f6:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3418a1f8:	1ad3      	subs	r3, r2, r3
3418a1fa:	2b01      	cmp	r3, #1
3418a1fc:	d901      	bls.n	3418a202 <HAL_RCC_OscConfig+0x3b2>
        {
          return HAL_TIMEOUT;
3418a1fe:	2303      	movs	r3, #3
3418a200:	e201      	b.n	3418a606 <HAL_RCC_OscConfig+0x7b6>
      while (LL_RCC_LSI_IsReady() == 0U)
3418a202:	f7ff fca1 	bl	34189b48 <LL_RCC_LSI_IsReady>
3418a206:	4603      	mov	r3, r0
3418a208:	2b00      	cmp	r3, #0
3418a20a:	d0f1      	beq.n	3418a1f0 <HAL_RCC_OscConfig+0x3a0>
3418a20c:	e013      	b.n	3418a236 <HAL_RCC_OscConfig+0x3e6>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
3418a20e:	f7ff fc8b 	bl	34189b28 <LL_RCC_LSI_Disable>

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
3418a212:	f7fb f9d1 	bl	341855b8 <HAL_GetTick>
3418a216:	66b8      	str	r0, [r7, #104]	@ 0x68

      /* Wait till LSI is ready */
      while (LL_RCC_LSI_IsReady() != 0U)
3418a218:	e008      	b.n	3418a22c <HAL_RCC_OscConfig+0x3dc>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSI_TIMEOUT_VALUE)
3418a21a:	f7fb f9cd 	bl	341855b8 <HAL_GetTick>
3418a21e:	4602      	mov	r2, r0
3418a220:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3418a222:	1ad3      	subs	r3, r2, r3
3418a224:	2b01      	cmp	r3, #1
3418a226:	d901      	bls.n	3418a22c <HAL_RCC_OscConfig+0x3dc>
        {
          return HAL_TIMEOUT;
3418a228:	2303      	movs	r3, #3
3418a22a:	e1ec      	b.n	3418a606 <HAL_RCC_OscConfig+0x7b6>
      while (LL_RCC_LSI_IsReady() != 0U)
3418a22c:	f7ff fc8c 	bl	34189b48 <LL_RCC_LSI_IsReady>
3418a230:	4603      	mov	r3, r0
3418a232:	2b00      	cmp	r3, #0
3418a234:	d1f1      	bne.n	3418a21a <HAL_RCC_OscConfig+0x3ca>
      }
    }
  }

  /*------------------------------ LSE Configuration -------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
3418a236:	687b      	ldr	r3, [r7, #4]
3418a238:	681b      	ldr	r3, [r3, #0]
3418a23a:	f003 0304 	and.w	r3, r3, #4
3418a23e:	2b00      	cmp	r3, #0
3418a240:	f000 808c 	beq.w	3418a35c <HAL_RCC_OscConfig+0x50c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(pRCC_OscInitStruct->LSEState));

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(pRCC_OscInitStruct->LSEState);
3418a244:	687b      	ldr	r3, [r7, #4]
3418a246:	689b      	ldr	r3, [r3, #8]
3418a248:	2b02      	cmp	r3, #2
3418a24a:	d104      	bne.n	3418a256 <HAL_RCC_OscConfig+0x406>
3418a24c:	4b96      	ldr	r3, [pc, #600]	@ (3418a4a8 <HAL_RCC_OscConfig+0x658>)
3418a24e:	2202      	movs	r2, #2
3418a250:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
3418a254:	e055      	b.n	3418a302 <HAL_RCC_OscConfig+0x4b2>
3418a256:	687b      	ldr	r3, [r7, #4]
3418a258:	689b      	ldr	r3, [r3, #8]
3418a25a:	2b00      	cmp	r3, #0
3418a25c:	d112      	bne.n	3418a284 <HAL_RCC_OscConfig+0x434>
3418a25e:	4b92      	ldr	r3, [pc, #584]	@ (3418a4a8 <HAL_RCC_OscConfig+0x658>)
3418a260:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3418a264:	461a      	mov	r2, r3
3418a266:	2302      	movs	r3, #2
3418a268:	6013      	str	r3, [r2, #0]
3418a26a:	4b8f      	ldr	r3, [pc, #572]	@ (3418a4a8 <HAL_RCC_OscConfig+0x658>)
3418a26c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3418a26e:	4a8e      	ldr	r2, [pc, #568]	@ (3418a4a8 <HAL_RCC_OscConfig+0x658>)
3418a270:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3418a274:	6413      	str	r3, [r2, #64]	@ 0x40
3418a276:	4b8c      	ldr	r3, [pc, #560]	@ (3418a4a8 <HAL_RCC_OscConfig+0x658>)
3418a278:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3418a27a:	4a8b      	ldr	r2, [pc, #556]	@ (3418a4a8 <HAL_RCC_OscConfig+0x658>)
3418a27c:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
3418a280:	6413      	str	r3, [r2, #64]	@ 0x40
3418a282:	e03e      	b.n	3418a302 <HAL_RCC_OscConfig+0x4b2>
3418a284:	687b      	ldr	r3, [r7, #4]
3418a286:	689b      	ldr	r3, [r3, #8]
3418a288:	f248 0202 	movw	r2, #32770	@ 0x8002
3418a28c:	4293      	cmp	r3, r2
3418a28e:	d110      	bne.n	3418a2b2 <HAL_RCC_OscConfig+0x462>
3418a290:	4b85      	ldr	r3, [pc, #532]	@ (3418a4a8 <HAL_RCC_OscConfig+0x658>)
3418a292:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3418a294:	4a84      	ldr	r2, [pc, #528]	@ (3418a4a8 <HAL_RCC_OscConfig+0x658>)
3418a296:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
3418a29a:	6413      	str	r3, [r2, #64]	@ 0x40
3418a29c:	4b82      	ldr	r3, [pc, #520]	@ (3418a4a8 <HAL_RCC_OscConfig+0x658>)
3418a29e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3418a2a0:	4a81      	ldr	r2, [pc, #516]	@ (3418a4a8 <HAL_RCC_OscConfig+0x658>)
3418a2a2:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3418a2a6:	6413      	str	r3, [r2, #64]	@ 0x40
3418a2a8:	4b7f      	ldr	r3, [pc, #508]	@ (3418a4a8 <HAL_RCC_OscConfig+0x658>)
3418a2aa:	2202      	movs	r2, #2
3418a2ac:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
3418a2b0:	e027      	b.n	3418a302 <HAL_RCC_OscConfig+0x4b2>
3418a2b2:	687b      	ldr	r3, [r7, #4]
3418a2b4:	689b      	ldr	r3, [r3, #8]
3418a2b6:	4a7d      	ldr	r2, [pc, #500]	@ (3418a4ac <HAL_RCC_OscConfig+0x65c>)
3418a2b8:	4293      	cmp	r3, r2
3418a2ba:	d110      	bne.n	3418a2de <HAL_RCC_OscConfig+0x48e>
3418a2bc:	4b7a      	ldr	r3, [pc, #488]	@ (3418a4a8 <HAL_RCC_OscConfig+0x658>)
3418a2be:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3418a2c0:	4a79      	ldr	r2, [pc, #484]	@ (3418a4a8 <HAL_RCC_OscConfig+0x658>)
3418a2c2:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
3418a2c6:	6413      	str	r3, [r2, #64]	@ 0x40
3418a2c8:	4b77      	ldr	r3, [pc, #476]	@ (3418a4a8 <HAL_RCC_OscConfig+0x658>)
3418a2ca:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3418a2cc:	4a76      	ldr	r2, [pc, #472]	@ (3418a4a8 <HAL_RCC_OscConfig+0x658>)
3418a2ce:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
3418a2d2:	6413      	str	r3, [r2, #64]	@ 0x40
3418a2d4:	4b74      	ldr	r3, [pc, #464]	@ (3418a4a8 <HAL_RCC_OscConfig+0x658>)
3418a2d6:	2202      	movs	r2, #2
3418a2d8:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
3418a2dc:	e011      	b.n	3418a302 <HAL_RCC_OscConfig+0x4b2>
3418a2de:	4b72      	ldr	r3, [pc, #456]	@ (3418a4a8 <HAL_RCC_OscConfig+0x658>)
3418a2e0:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3418a2e4:	461a      	mov	r2, r3
3418a2e6:	2302      	movs	r3, #2
3418a2e8:	6013      	str	r3, [r2, #0]
3418a2ea:	4b6f      	ldr	r3, [pc, #444]	@ (3418a4a8 <HAL_RCC_OscConfig+0x658>)
3418a2ec:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3418a2ee:	4a6e      	ldr	r2, [pc, #440]	@ (3418a4a8 <HAL_RCC_OscConfig+0x658>)
3418a2f0:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
3418a2f4:	6413      	str	r3, [r2, #64]	@ 0x40
3418a2f6:	4b6c      	ldr	r3, [pc, #432]	@ (3418a4a8 <HAL_RCC_OscConfig+0x658>)
3418a2f8:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3418a2fa:	4a6b      	ldr	r2, [pc, #428]	@ (3418a4a8 <HAL_RCC_OscConfig+0x658>)
3418a2fc:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3418a300:	6413      	str	r3, [r2, #64]	@ 0x40
    /* Check the LSE State */
    if ((pRCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
3418a302:	687b      	ldr	r3, [r7, #4]
3418a304:	689b      	ldr	r3, [r3, #8]
3418a306:	2b00      	cmp	r3, #0
3418a308:	d014      	beq.n	3418a334 <HAL_RCC_OscConfig+0x4e4>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
3418a30a:	f7fb f955 	bl	341855b8 <HAL_GetTick>
3418a30e:	66b8      	str	r0, [r7, #104]	@ 0x68

      /* Wait till LSE is ready */
      while (LL_RCC_LSE_IsReady() == 0U)
3418a310:	e00a      	b.n	3418a328 <HAL_RCC_OscConfig+0x4d8>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
3418a312:	f7fb f951 	bl	341855b8 <HAL_GetTick>
3418a316:	4602      	mov	r2, r0
3418a318:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3418a31a:	1ad3      	subs	r3, r2, r3
3418a31c:	f241 3288 	movw	r2, #5000	@ 0x1388
3418a320:	4293      	cmp	r3, r2
3418a322:	d901      	bls.n	3418a328 <HAL_RCC_OscConfig+0x4d8>
        {
          return HAL_TIMEOUT;
3418a324:	2303      	movs	r3, #3
3418a326:	e16e      	b.n	3418a606 <HAL_RCC_OscConfig+0x7b6>
      while (LL_RCC_LSE_IsReady() == 0U)
3418a328:	f7ff fbde 	bl	34189ae8 <LL_RCC_LSE_IsReady>
3418a32c:	4603      	mov	r3, r0
3418a32e:	2b00      	cmp	r3, #0
3418a330:	d0ef      	beq.n	3418a312 <HAL_RCC_OscConfig+0x4c2>
3418a332:	e013      	b.n	3418a35c <HAL_RCC_OscConfig+0x50c>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
3418a334:	f7fb f940 	bl	341855b8 <HAL_GetTick>
3418a338:	66b8      	str	r0, [r7, #104]	@ 0x68

      /* Wait till LSE is disabled */
      while (LL_RCC_LSE_IsReady() != 0U)
3418a33a:	e00a      	b.n	3418a352 <HAL_RCC_OscConfig+0x502>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
3418a33c:	f7fb f93c 	bl	341855b8 <HAL_GetTick>
3418a340:	4602      	mov	r2, r0
3418a342:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3418a344:	1ad3      	subs	r3, r2, r3
3418a346:	f241 3288 	movw	r2, #5000	@ 0x1388
3418a34a:	4293      	cmp	r3, r2
3418a34c:	d901      	bls.n	3418a352 <HAL_RCC_OscConfig+0x502>
        {
          return HAL_TIMEOUT;
3418a34e:	2303      	movs	r3, #3
3418a350:	e159      	b.n	3418a606 <HAL_RCC_OscConfig+0x7b6>
      while (LL_RCC_LSE_IsReady() != 0U)
3418a352:	f7ff fbc9 	bl	34189ae8 <LL_RCC_LSE_IsReady>
3418a356:	4603      	mov	r3, r0
3418a358:	2b00      	cmp	r3, #0
3418a35a:	d1ef      	bne.n	3418a33c <HAL_RCC_OscConfig+0x4ec>

  /*-------------------------------- PLL1 Configuration ----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(pRCC_OscInitStruct->PLL1.PLLState));

  if (pRCC_OscInitStruct->PLL1.PLLState != RCC_PLL_NONE)
3418a35c:	687b      	ldr	r3, [r7, #4]
3418a35e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3418a360:	2b00      	cmp	r3, #0
3418a362:	d04c      	beq.n	3418a3fe <HAL_RCC_OscConfig+0x5ae>
  {
    uint32_t new_pll_config = RCC_PLL_IsNewConfig(RCC_PLL1_CONFIG, &(pRCC_OscInitStruct->PLL1));
3418a364:	687b      	ldr	r3, [r7, #4]
3418a366:	3328      	adds	r3, #40	@ 0x28
3418a368:	4619      	mov	r1, r3
3418a36a:	2000      	movs	r0, #0
3418a36c:	f000 fe46 	bl	3418affc <RCC_PLL_IsNewConfig>
3418a370:	6678      	str	r0, [r7, #100]	@ 0x64
    uint32_t pll1_ready = LL_RCC_PLL1_IsReady();
3418a372:	f7ff fc3d 	bl	34189bf0 <LL_RCC_PLL1_IsReady>
3418a376:	6638      	str	r0, [r7, #96]	@ 0x60
    if (new_pll_config == 1U)
3418a378:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3418a37a:	2b01      	cmp	r3, #1
3418a37c:	d130      	bne.n	3418a3e0 <HAL_RCC_OscConfig+0x590>
    {
      uint32_t ic1src = LL_RCC_IC1_GetSource();
3418a37e:	f7ff fd0f 	bl	34189da0 <LL_RCC_IC1_GetSource>
3418a382:	65f8      	str	r0, [r7, #92]	@ 0x5c
      uint32_t ic2src = LL_RCC_IC2_GetSource();
3418a384:	f7ff fd2a 	bl	34189ddc <LL_RCC_IC2_GetSource>
3418a388:	65b8      	str	r0, [r7, #88]	@ 0x58
      uint32_t ic6src = LL_RCC_IC6_GetSource();
3418a38a:	f7ff fd45 	bl	34189e18 <LL_RCC_IC6_GetSource>
3418a38e:	6578      	str	r0, [r7, #84]	@ 0x54
      uint32_t ic11src = LL_RCC_IC11_GetSource();
3418a390:	f7ff fd50 	bl	34189e34 <LL_RCC_IC11_GetSource>
3418a394:	6538      	str	r0, [r7, #80]	@ 0x50
      /* PLL1 should not be disabled / reconfigured if used for IC1 (cpuclksrc) - return HAL_ERROR */
      if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_IC1) && (ic1src == LL_RCC_ICCLKSOURCE_PLL1))
3418a396:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
3418a39a:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
3418a39e:	d104      	bne.n	3418a3aa <HAL_RCC_OscConfig+0x55a>
3418a3a0:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3418a3a2:	2b00      	cmp	r3, #0
3418a3a4:	d101      	bne.n	3418a3aa <HAL_RCC_OscConfig+0x55a>
      {
        return HAL_ERROR;
3418a3a6:	2301      	movs	r3, #1
3418a3a8:	e12d      	b.n	3418a606 <HAL_RCC_OscConfig+0x7b6>
      }

      /* PLL1 should not be disabled / reconfigured if used for IC2, IC6 or IC11 (sysclksrc) - return HAL_ERROR  */
      if ((sysclksrc == RCC_SYSCLKSOURCE_STATUS_IC2_IC6_IC11) && ((ic2src == LL_RCC_ICCLKSOURCE_PLL1) ||
3418a3aa:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3418a3ae:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418a3b2:	d10a      	bne.n	3418a3ca <HAL_RCC_OscConfig+0x57a>
3418a3b4:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
3418a3b6:	2b00      	cmp	r3, #0
3418a3b8:	d005      	beq.n	3418a3c6 <HAL_RCC_OscConfig+0x576>
3418a3ba:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3418a3bc:	2b00      	cmp	r3, #0
3418a3be:	d002      	beq.n	3418a3c6 <HAL_RCC_OscConfig+0x576>
                                                                  (ic6src == LL_RCC_ICCLKSOURCE_PLL1) ||
3418a3c0:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
3418a3c2:	2b00      	cmp	r3, #0
3418a3c4:	d101      	bne.n	3418a3ca <HAL_RCC_OscConfig+0x57a>
                                                                  (ic11src == LL_RCC_ICCLKSOURCE_PLL1)))
      {
        return HAL_ERROR;
3418a3c6:	2301      	movs	r3, #1
3418a3c8:	e11d      	b.n	3418a606 <HAL_RCC_OscConfig+0x7b6>
      }
      /* PLL1 is not used, it can be configured */
      if (RCC_PLL_Config(RCC_PLL1_CONFIG, &(pRCC_OscInitStruct->PLL1)) != HAL_OK)
3418a3ca:	687b      	ldr	r3, [r7, #4]
3418a3cc:	3328      	adds	r3, #40	@ 0x28
3418a3ce:	4619      	mov	r1, r3
3418a3d0:	2000      	movs	r0, #0
3418a3d2:	f000 fcb7 	bl	3418ad44 <RCC_PLL_Config>
3418a3d6:	4603      	mov	r3, r0
3418a3d8:	2b00      	cmp	r3, #0
3418a3da:	d010      	beq.n	3418a3fe <HAL_RCC_OscConfig+0x5ae>
      {
        return HAL_ERROR;
3418a3dc:	2301      	movs	r3, #1
3418a3de:	e112      	b.n	3418a606 <HAL_RCC_OscConfig+0x7b6>
      }
    }
    else if ((pRCC_OscInitStruct->PLL1.PLLState == RCC_PLL_ON) && (pll1_ready == 0U))
3418a3e0:	687b      	ldr	r3, [r7, #4]
3418a3e2:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3418a3e4:	2b02      	cmp	r3, #2
3418a3e6:	d10a      	bne.n	3418a3fe <HAL_RCC_OscConfig+0x5ae>
3418a3e8:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3418a3ea:	2b00      	cmp	r3, #0
3418a3ec:	d107      	bne.n	3418a3fe <HAL_RCC_OscConfig+0x5ae>
    {
      if (RCC_PLL_Enable(RCC_PLL1_CONFIG) != HAL_OK)
3418a3ee:	2000      	movs	r0, #0
3418a3f0:	f000 fdd8 	bl	3418afa4 <RCC_PLL_Enable>
3418a3f4:	4603      	mov	r3, r0
3418a3f6:	2b00      	cmp	r3, #0
3418a3f8:	d001      	beq.n	3418a3fe <HAL_RCC_OscConfig+0x5ae>
      {
        return HAL_ERROR;
3418a3fa:	2301      	movs	r3, #1
3418a3fc:	e103      	b.n	3418a606 <HAL_RCC_OscConfig+0x7b6>

  /*-------------------------------- PLL2 Configuration ----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(pRCC_OscInitStruct->PLL2.PLLState));

  if (pRCC_OscInitStruct->PLL2.PLLState != RCC_PLL_NONE)
3418a3fe:	687b      	ldr	r3, [r7, #4]
3418a400:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3418a402:	2b00      	cmp	r3, #0
3418a404:	d054      	beq.n	3418a4b0 <HAL_RCC_OscConfig+0x660>
  {
    uint32_t new_pll_config = RCC_PLL_IsNewConfig(RCC_PLL2_CONFIG, &(pRCC_OscInitStruct->PLL2));
3418a406:	687b      	ldr	r3, [r7, #4]
3418a408:	3344      	adds	r3, #68	@ 0x44
3418a40a:	4619      	mov	r1, r3
3418a40c:	2001      	movs	r0, #1
3418a40e:	f000 fdf5 	bl	3418affc <RCC_PLL_IsNewConfig>
3418a412:	64f8      	str	r0, [r7, #76]	@ 0x4c
    uint32_t pll2_ready = LL_RCC_PLL2_IsReady();
3418a414:	f7ff fc22 	bl	34189c5c <LL_RCC_PLL2_IsReady>
3418a418:	64b8      	str	r0, [r7, #72]	@ 0x48
    if (new_pll_config == 1U)
3418a41a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3418a41c:	2b01      	cmp	r3, #1
3418a41e:	d134      	bne.n	3418a48a <HAL_RCC_OscConfig+0x63a>
    {
      uint32_t ic1src = LL_RCC_IC1_GetSource();
3418a420:	f7ff fcbe 	bl	34189da0 <LL_RCC_IC1_GetSource>
3418a424:	6478      	str	r0, [r7, #68]	@ 0x44
      uint32_t ic2src = LL_RCC_IC2_GetSource();
3418a426:	f7ff fcd9 	bl	34189ddc <LL_RCC_IC2_GetSource>
3418a42a:	6438      	str	r0, [r7, #64]	@ 0x40
      uint32_t ic6src = LL_RCC_IC6_GetSource();
3418a42c:	f7ff fcf4 	bl	34189e18 <LL_RCC_IC6_GetSource>
3418a430:	63f8      	str	r0, [r7, #60]	@ 0x3c
      uint32_t ic11src = LL_RCC_IC11_GetSource();
3418a432:	f7ff fcff 	bl	34189e34 <LL_RCC_IC11_GetSource>
3418a436:	63b8      	str	r0, [r7, #56]	@ 0x38
      /* PLL2 should not be disabled / reconfigured if used for IC1 (cpuclksrc) - return HAL_ERROR */
      if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_IC1) && (ic1src == LL_RCC_ICCLKSOURCE_PLL2))
3418a438:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
3418a43c:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
3418a440:	d105      	bne.n	3418a44e <HAL_RCC_OscConfig+0x5fe>
3418a442:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3418a444:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3418a448:	d101      	bne.n	3418a44e <HAL_RCC_OscConfig+0x5fe>
      {
        return HAL_ERROR;
3418a44a:	2301      	movs	r3, #1
3418a44c:	e0db      	b.n	3418a606 <HAL_RCC_OscConfig+0x7b6>
      }

      /* PLL2 should not be disabled / reconfigured if used for IC2, IC6 or IC11 (sysclksrc) - return HAL_ERROR  */
      if ((sysclksrc == RCC_SYSCLKSOURCE_STATUS_IC2_IC6_IC11) && ((ic2src == LL_RCC_ICCLKSOURCE_PLL2) ||
3418a44e:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3418a452:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418a456:	d10d      	bne.n	3418a474 <HAL_RCC_OscConfig+0x624>
3418a458:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3418a45a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3418a45e:	d007      	beq.n	3418a470 <HAL_RCC_OscConfig+0x620>
3418a460:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3418a462:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3418a466:	d003      	beq.n	3418a470 <HAL_RCC_OscConfig+0x620>
                                                                  (ic6src == LL_RCC_ICCLKSOURCE_PLL2) ||
3418a468:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3418a46a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3418a46e:	d101      	bne.n	3418a474 <HAL_RCC_OscConfig+0x624>
                                                                  (ic11src == LL_RCC_ICCLKSOURCE_PLL2)))
      {
        return HAL_ERROR;
3418a470:	2301      	movs	r3, #1
3418a472:	e0c8      	b.n	3418a606 <HAL_RCC_OscConfig+0x7b6>
      }
      /* PLL2 is not used, it can be configured */
      if (RCC_PLL_Config(RCC_PLL2_CONFIG, &(pRCC_OscInitStruct->PLL2)) != HAL_OK)
3418a474:	687b      	ldr	r3, [r7, #4]
3418a476:	3344      	adds	r3, #68	@ 0x44
3418a478:	4619      	mov	r1, r3
3418a47a:	2001      	movs	r0, #1
3418a47c:	f000 fc62 	bl	3418ad44 <RCC_PLL_Config>
3418a480:	4603      	mov	r3, r0
3418a482:	2b00      	cmp	r3, #0
3418a484:	d014      	beq.n	3418a4b0 <HAL_RCC_OscConfig+0x660>
      {
        return HAL_ERROR;
3418a486:	2301      	movs	r3, #1
3418a488:	e0bd      	b.n	3418a606 <HAL_RCC_OscConfig+0x7b6>
      }
    }
    else if ((pRCC_OscInitStruct->PLL2.PLLState == RCC_PLL_ON) && (pll2_ready == 0U))
3418a48a:	687b      	ldr	r3, [r7, #4]
3418a48c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3418a48e:	2b02      	cmp	r3, #2
3418a490:	d10e      	bne.n	3418a4b0 <HAL_RCC_OscConfig+0x660>
3418a492:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3418a494:	2b00      	cmp	r3, #0
3418a496:	d10b      	bne.n	3418a4b0 <HAL_RCC_OscConfig+0x660>
    {
      if (RCC_PLL_Enable(RCC_PLL2_CONFIG) != HAL_OK)
3418a498:	2001      	movs	r0, #1
3418a49a:	f000 fd83 	bl	3418afa4 <RCC_PLL_Enable>
3418a49e:	4603      	mov	r3, r0
3418a4a0:	2b00      	cmp	r3, #0
3418a4a2:	d005      	beq.n	3418a4b0 <HAL_RCC_OscConfig+0x660>
      {
        return HAL_ERROR;
3418a4a4:	2301      	movs	r3, #1
3418a4a6:	e0ae      	b.n	3418a606 <HAL_RCC_OscConfig+0x7b6>
3418a4a8:	56028000 	.word	0x56028000
3418a4ac:	00018002 	.word	0x00018002

  /*-------------------------------- PLL3 Configuration ----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(pRCC_OscInitStruct->PLL3.PLLState));

  if (pRCC_OscInitStruct->PLL3.PLLState != RCC_PLL_NONE)
3418a4b0:	687b      	ldr	r3, [r7, #4]
3418a4b2:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3418a4b4:	2b00      	cmp	r3, #0
3418a4b6:	d050      	beq.n	3418a55a <HAL_RCC_OscConfig+0x70a>
  {
    uint32_t new_pll_config = RCC_PLL_IsNewConfig(RCC_PLL3_CONFIG, &(pRCC_OscInitStruct->PLL3));
3418a4b8:	687b      	ldr	r3, [r7, #4]
3418a4ba:	3360      	adds	r3, #96	@ 0x60
3418a4bc:	4619      	mov	r1, r3
3418a4be:	2002      	movs	r0, #2
3418a4c0:	f000 fd9c 	bl	3418affc <RCC_PLL_IsNewConfig>
3418a4c4:	6378      	str	r0, [r7, #52]	@ 0x34
    uint32_t pll3_ready = LL_RCC_PLL1_IsReady();
3418a4c6:	f7ff fb93 	bl	34189bf0 <LL_RCC_PLL1_IsReady>
3418a4ca:	6338      	str	r0, [r7, #48]	@ 0x30
    if (new_pll_config == 1U)
3418a4cc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
3418a4ce:	2b01      	cmp	r3, #1
3418a4d0:	d134      	bne.n	3418a53c <HAL_RCC_OscConfig+0x6ec>
    {
      uint32_t ic1src = LL_RCC_IC1_GetSource();
3418a4d2:	f7ff fc65 	bl	34189da0 <LL_RCC_IC1_GetSource>
3418a4d6:	62f8      	str	r0, [r7, #44]	@ 0x2c
      uint32_t ic2src = LL_RCC_IC2_GetSource();
3418a4d8:	f7ff fc80 	bl	34189ddc <LL_RCC_IC2_GetSource>
3418a4dc:	62b8      	str	r0, [r7, #40]	@ 0x28
      uint32_t ic6src = LL_RCC_IC6_GetSource();
3418a4de:	f7ff fc9b 	bl	34189e18 <LL_RCC_IC6_GetSource>
3418a4e2:	6278      	str	r0, [r7, #36]	@ 0x24
      uint32_t ic11src = LL_RCC_IC11_GetSource();
3418a4e4:	f7ff fca6 	bl	34189e34 <LL_RCC_IC11_GetSource>
3418a4e8:	6238      	str	r0, [r7, #32]
      /* PLL3 should not be disabled / reconfigured if used for IC1 (cpuclksrc) - return HAL_ERROR */
      if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_IC1) && (ic1src == LL_RCC_ICCLKSOURCE_PLL3))
3418a4ea:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
3418a4ee:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
3418a4f2:	d105      	bne.n	3418a500 <HAL_RCC_OscConfig+0x6b0>
3418a4f4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3418a4f6:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418a4fa:	d101      	bne.n	3418a500 <HAL_RCC_OscConfig+0x6b0>
      {
        return HAL_ERROR;
3418a4fc:	2301      	movs	r3, #1
3418a4fe:	e082      	b.n	3418a606 <HAL_RCC_OscConfig+0x7b6>
      }
      /* PLL3 should not be disabled / reconfigured if used for IC2, IC6 or IC11 (sysclksrc) - return HAL_ERROR  */
      if ((sysclksrc == RCC_SYSCLKSOURCE_STATUS_IC2_IC6_IC11) && ((ic2src == LL_RCC_ICCLKSOURCE_PLL3) ||
3418a500:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3418a504:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418a508:	d10d      	bne.n	3418a526 <HAL_RCC_OscConfig+0x6d6>
3418a50a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a50c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418a510:	d007      	beq.n	3418a522 <HAL_RCC_OscConfig+0x6d2>
3418a512:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3418a514:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418a518:	d003      	beq.n	3418a522 <HAL_RCC_OscConfig+0x6d2>
                                                                  (ic6src == LL_RCC_ICCLKSOURCE_PLL3) ||
3418a51a:	6a3b      	ldr	r3, [r7, #32]
3418a51c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418a520:	d101      	bne.n	3418a526 <HAL_RCC_OscConfig+0x6d6>
                                                                  (ic11src == LL_RCC_ICCLKSOURCE_PLL3)))
      {
        return HAL_ERROR;
3418a522:	2301      	movs	r3, #1
3418a524:	e06f      	b.n	3418a606 <HAL_RCC_OscConfig+0x7b6>
      }
      /* PLL3 is not used, it can be configured */
      if (RCC_PLL_Config(RCC_PLL3_CONFIG, &(pRCC_OscInitStruct->PLL3)) != HAL_OK)
3418a526:	687b      	ldr	r3, [r7, #4]
3418a528:	3360      	adds	r3, #96	@ 0x60
3418a52a:	4619      	mov	r1, r3
3418a52c:	2002      	movs	r0, #2
3418a52e:	f000 fc09 	bl	3418ad44 <RCC_PLL_Config>
3418a532:	4603      	mov	r3, r0
3418a534:	2b00      	cmp	r3, #0
3418a536:	d010      	beq.n	3418a55a <HAL_RCC_OscConfig+0x70a>
      {
        return HAL_ERROR;
3418a538:	2301      	movs	r3, #1
3418a53a:	e064      	b.n	3418a606 <HAL_RCC_OscConfig+0x7b6>
      }
    }
    else if ((pRCC_OscInitStruct->PLL3.PLLState == RCC_PLL_ON) && (pll3_ready == 0U))
3418a53c:	687b      	ldr	r3, [r7, #4]
3418a53e:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3418a540:	2b02      	cmp	r3, #2
3418a542:	d10a      	bne.n	3418a55a <HAL_RCC_OscConfig+0x70a>
3418a544:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3418a546:	2b00      	cmp	r3, #0
3418a548:	d107      	bne.n	3418a55a <HAL_RCC_OscConfig+0x70a>
    {
      if (RCC_PLL_Enable(RCC_PLL3_CONFIG) != HAL_OK)
3418a54a:	2002      	movs	r0, #2
3418a54c:	f000 fd2a 	bl	3418afa4 <RCC_PLL_Enable>
3418a550:	4603      	mov	r3, r0
3418a552:	2b00      	cmp	r3, #0
3418a554:	d001      	beq.n	3418a55a <HAL_RCC_OscConfig+0x70a>
      {
        return HAL_ERROR;
3418a556:	2301      	movs	r3, #1
3418a558:	e055      	b.n	3418a606 <HAL_RCC_OscConfig+0x7b6>

  /*-------------------------------- PLL4 Configuration ----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(pRCC_OscInitStruct->PLL4.PLLState));

  if (pRCC_OscInitStruct->PLL4.PLLState != RCC_PLL_NONE)
3418a55a:	687b      	ldr	r3, [r7, #4]
3418a55c:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3418a55e:	2b00      	cmp	r3, #0
3418a560:	d050      	beq.n	3418a604 <HAL_RCC_OscConfig+0x7b4>
  {
    uint32_t new_pll_config = RCC_PLL_IsNewConfig(RCC_PLL4_CONFIG, &(pRCC_OscInitStruct->PLL4));
3418a562:	687b      	ldr	r3, [r7, #4]
3418a564:	337c      	adds	r3, #124	@ 0x7c
3418a566:	4619      	mov	r1, r3
3418a568:	2003      	movs	r0, #3
3418a56a:	f000 fd47 	bl	3418affc <RCC_PLL_IsNewConfig>
3418a56e:	61f8      	str	r0, [r7, #28]
    uint32_t pll4_ready = LL_RCC_PLL4_IsReady();
3418a570:	f7ff fbe0 	bl	34189d34 <LL_RCC_PLL4_IsReady>
3418a574:	61b8      	str	r0, [r7, #24]

    if (new_pll_config == 1U)
3418a576:	69fb      	ldr	r3, [r7, #28]
3418a578:	2b01      	cmp	r3, #1
3418a57a:	d134      	bne.n	3418a5e6 <HAL_RCC_OscConfig+0x796>
    {
      uint32_t ic1src = LL_RCC_IC1_GetSource();
3418a57c:	f7ff fc10 	bl	34189da0 <LL_RCC_IC1_GetSource>
3418a580:	6178      	str	r0, [r7, #20]
      uint32_t ic2src = LL_RCC_IC2_GetSource();
3418a582:	f7ff fc2b 	bl	34189ddc <LL_RCC_IC2_GetSource>
3418a586:	6138      	str	r0, [r7, #16]
      uint32_t ic6src = LL_RCC_IC6_GetSource();
3418a588:	f7ff fc46 	bl	34189e18 <LL_RCC_IC6_GetSource>
3418a58c:	60f8      	str	r0, [r7, #12]
      uint32_t ic11src = LL_RCC_IC11_GetSource();
3418a58e:	f7ff fc51 	bl	34189e34 <LL_RCC_IC11_GetSource>
3418a592:	60b8      	str	r0, [r7, #8]
      /* PLL4 should not be disabled / reconfigured if used for IC1 (cpuclksrc) - return HAL_ERROR */
      if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_IC1) && (ic1src == LL_RCC_ICCLKSOURCE_PLL4))
3418a594:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
3418a598:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
3418a59c:	d105      	bne.n	3418a5aa <HAL_RCC_OscConfig+0x75a>
3418a59e:	697b      	ldr	r3, [r7, #20]
3418a5a0:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418a5a4:	d101      	bne.n	3418a5aa <HAL_RCC_OscConfig+0x75a>
      {
        return HAL_ERROR;
3418a5a6:	2301      	movs	r3, #1
3418a5a8:	e02d      	b.n	3418a606 <HAL_RCC_OscConfig+0x7b6>
      }
      /* PLL4 should not be disabled / reconfigured if used for IC2, IC6 or IC11 (sysclksrc) - return HAL_ERROR  */
      if ((sysclksrc == RCC_SYSCLKSOURCE_STATUS_IC2_IC6_IC11) && ((ic2src == LL_RCC_ICCLKSOURCE_PLL4) ||
3418a5aa:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3418a5ae:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418a5b2:	d10d      	bne.n	3418a5d0 <HAL_RCC_OscConfig+0x780>
3418a5b4:	693b      	ldr	r3, [r7, #16]
3418a5b6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418a5ba:	d007      	beq.n	3418a5cc <HAL_RCC_OscConfig+0x77c>
3418a5bc:	68fb      	ldr	r3, [r7, #12]
3418a5be:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418a5c2:	d003      	beq.n	3418a5cc <HAL_RCC_OscConfig+0x77c>
                                                                  (ic6src == LL_RCC_ICCLKSOURCE_PLL4) ||
3418a5c4:	68bb      	ldr	r3, [r7, #8]
3418a5c6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418a5ca:	d101      	bne.n	3418a5d0 <HAL_RCC_OscConfig+0x780>
                                                                  (ic11src == LL_RCC_ICCLKSOURCE_PLL4)))
      {
        return HAL_ERROR;
3418a5cc:	2301      	movs	r3, #1
3418a5ce:	e01a      	b.n	3418a606 <HAL_RCC_OscConfig+0x7b6>
      }
      /* PLL4 is not used, it can be configured */
      if (RCC_PLL_Config(RCC_PLL4_CONFIG, &(pRCC_OscInitStruct->PLL4)) != HAL_OK)
3418a5d0:	687b      	ldr	r3, [r7, #4]
3418a5d2:	337c      	adds	r3, #124	@ 0x7c
3418a5d4:	4619      	mov	r1, r3
3418a5d6:	2003      	movs	r0, #3
3418a5d8:	f000 fbb4 	bl	3418ad44 <RCC_PLL_Config>
3418a5dc:	4603      	mov	r3, r0
3418a5de:	2b00      	cmp	r3, #0
3418a5e0:	d010      	beq.n	3418a604 <HAL_RCC_OscConfig+0x7b4>
      {
        return HAL_ERROR;
3418a5e2:	2301      	movs	r3, #1
3418a5e4:	e00f      	b.n	3418a606 <HAL_RCC_OscConfig+0x7b6>
      }
    }
    else if ((pRCC_OscInitStruct->PLL4.PLLState == RCC_PLL_ON) && (pll4_ready == 0U))
3418a5e6:	687b      	ldr	r3, [r7, #4]
3418a5e8:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3418a5ea:	2b02      	cmp	r3, #2
3418a5ec:	d10a      	bne.n	3418a604 <HAL_RCC_OscConfig+0x7b4>
3418a5ee:	69bb      	ldr	r3, [r7, #24]
3418a5f0:	2b00      	cmp	r3, #0
3418a5f2:	d107      	bne.n	3418a604 <HAL_RCC_OscConfig+0x7b4>
    {
      if (RCC_PLL_Enable(RCC_PLL4_CONFIG) != HAL_OK)
3418a5f4:	2003      	movs	r0, #3
3418a5f6:	f000 fcd5 	bl	3418afa4 <RCC_PLL_Enable>
3418a5fa:	4603      	mov	r3, r0
3418a5fc:	2b00      	cmp	r3, #0
3418a5fe:	d001      	beq.n	3418a604 <HAL_RCC_OscConfig+0x7b4>
      {
        return HAL_ERROR;
3418a600:	2301      	movs	r3, #1
3418a602:	e000      	b.n	3418a606 <HAL_RCC_OscConfig+0x7b6>
    {
      /* Nothing to do */
    }
  }

  return HAL_OK;
3418a604:	2300      	movs	r3, #0
}
3418a606:	4618      	mov	r0, r3
3418a608:	3788      	adds	r7, #136	@ 0x88
3418a60a:	46bd      	mov	sp, r7
3418a60c:	bd80      	pop	{r7, pc}
3418a60e:	bf00      	nop

3418a610 <HAL_RCC_ClockConfig>:
  *         You can use HAL_RCC_GetClockConfig() function to know which clock is
  *         currently used as system clock source.
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(const RCC_ClkInitTypeDef  *pRCC_ClkInitStruct)
{
3418a610:	b580      	push	{r7, lr}
3418a612:	b084      	sub	sp, #16
3418a614:	af00      	add	r7, sp, #0
3418a616:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Check Null pointer */
  if (pRCC_ClkInitStruct == NULL)
3418a618:	687b      	ldr	r3, [r7, #4]
3418a61a:	2b00      	cmp	r3, #0
3418a61c:	d101      	bne.n	3418a622 <HAL_RCC_ClockConfig+0x12>
  {
    return HAL_ERROR;
3418a61e:	2301      	movs	r3, #1
3418a620:	e1f2      	b.n	3418aa08 <HAL_RCC_ClockConfig+0x3f8>
  assert_param(IS_RCC_CLOCKTYPE(pRCC_ClkInitStruct->ClockType));

  /* Increasing the BUS frequency divider ? */

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
3418a622:	687b      	ldr	r3, [r7, #4]
3418a624:	681b      	ldr	r3, [r3, #0]
3418a626:	f003 0308 	and.w	r3, r3, #8
3418a62a:	2b00      	cmp	r3, #0
3418a62c:	d010      	beq.n	3418a650 <HAL_RCC_ClockConfig+0x40>
  {
    assert_param(IS_RCC_PCLK1(pRCC_ClkInitStruct->APB1CLKDivider));
    if ((pRCC_ClkInitStruct->APB1CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE1))
3418a62e:	687b      	ldr	r3, [r7, #4]
3418a630:	691a      	ldr	r2, [r3, #16]
3418a632:	4ba3      	ldr	r3, [pc, #652]	@ (3418a8c0 <HAL_RCC_ClockConfig+0x2b0>)
3418a634:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418a636:	f003 0307 	and.w	r3, r3, #7
3418a63a:	429a      	cmp	r2, r3
3418a63c:	d908      	bls.n	3418a650 <HAL_RCC_ClockConfig+0x40>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE1, (pRCC_ClkInitStruct->APB1CLKDivider));
3418a63e:	4ba0      	ldr	r3, [pc, #640]	@ (3418a8c0 <HAL_RCC_ClockConfig+0x2b0>)
3418a640:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418a642:	f023 0207 	bic.w	r2, r3, #7
3418a646:	687b      	ldr	r3, [r7, #4]
3418a648:	691b      	ldr	r3, [r3, #16]
3418a64a:	499d      	ldr	r1, [pc, #628]	@ (3418a8c0 <HAL_RCC_ClockConfig+0x2b0>)
3418a64c:	4313      	orrs	r3, r2
3418a64e:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
3418a650:	687b      	ldr	r3, [r7, #4]
3418a652:	681b      	ldr	r3, [r3, #0]
3418a654:	f003 0310 	and.w	r3, r3, #16
3418a658:	2b00      	cmp	r3, #0
3418a65a:	d010      	beq.n	3418a67e <HAL_RCC_ClockConfig+0x6e>
  {
    assert_param(IS_RCC_PCLK2(pRCC_ClkInitStruct->APB2CLKDivider));
    if ((pRCC_ClkInitStruct->APB2CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE2))
3418a65c:	687b      	ldr	r3, [r7, #4]
3418a65e:	695a      	ldr	r2, [r3, #20]
3418a660:	4b97      	ldr	r3, [pc, #604]	@ (3418a8c0 <HAL_RCC_ClockConfig+0x2b0>)
3418a662:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418a664:	f003 0370 	and.w	r3, r3, #112	@ 0x70
3418a668:	429a      	cmp	r2, r3
3418a66a:	d908      	bls.n	3418a67e <HAL_RCC_ClockConfig+0x6e>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE2, (pRCC_ClkInitStruct->APB2CLKDivider));
3418a66c:	4b94      	ldr	r3, [pc, #592]	@ (3418a8c0 <HAL_RCC_ClockConfig+0x2b0>)
3418a66e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418a670:	f023 0270 	bic.w	r2, r3, #112	@ 0x70
3418a674:	687b      	ldr	r3, [r7, #4]
3418a676:	695b      	ldr	r3, [r3, #20]
3418a678:	4991      	ldr	r1, [pc, #580]	@ (3418a8c0 <HAL_RCC_ClockConfig+0x2b0>)
3418a67a:	4313      	orrs	r3, r2
3418a67c:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK4 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK4) == RCC_CLOCKTYPE_PCLK4)
3418a67e:	687b      	ldr	r3, [r7, #4]
3418a680:	681b      	ldr	r3, [r3, #0]
3418a682:	f003 0320 	and.w	r3, r3, #32
3418a686:	2b00      	cmp	r3, #0
3418a688:	d010      	beq.n	3418a6ac <HAL_RCC_ClockConfig+0x9c>
  {
    assert_param(IS_RCC_PCLK4(pRCC_ClkInitStruct->APB4CLKDivider));
    if ((pRCC_ClkInitStruct->APB4CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE4))
3418a68a:	687b      	ldr	r3, [r7, #4]
3418a68c:	699a      	ldr	r2, [r3, #24]
3418a68e:	4b8c      	ldr	r3, [pc, #560]	@ (3418a8c0 <HAL_RCC_ClockConfig+0x2b0>)
3418a690:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418a692:	f403 43e0 	and.w	r3, r3, #28672	@ 0x7000
3418a696:	429a      	cmp	r2, r3
3418a698:	d908      	bls.n	3418a6ac <HAL_RCC_ClockConfig+0x9c>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE4, (pRCC_ClkInitStruct->APB4CLKDivider));
3418a69a:	4b89      	ldr	r3, [pc, #548]	@ (3418a8c0 <HAL_RCC_ClockConfig+0x2b0>)
3418a69c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418a69e:	f423 42e0 	bic.w	r2, r3, #28672	@ 0x7000
3418a6a2:	687b      	ldr	r3, [r7, #4]
3418a6a4:	699b      	ldr	r3, [r3, #24]
3418a6a6:	4986      	ldr	r1, [pc, #536]	@ (3418a8c0 <HAL_RCC_ClockConfig+0x2b0>)
3418a6a8:	4313      	orrs	r3, r2
3418a6aa:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK5 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK5) == RCC_CLOCKTYPE_PCLK5)
3418a6ac:	687b      	ldr	r3, [r7, #4]
3418a6ae:	681b      	ldr	r3, [r3, #0]
3418a6b0:	f003 0340 	and.w	r3, r3, #64	@ 0x40
3418a6b4:	2b00      	cmp	r3, #0
3418a6b6:	d010      	beq.n	3418a6da <HAL_RCC_ClockConfig+0xca>
  {
    assert_param(IS_RCC_PCLK5(pRCC_ClkInitStruct->APB5CLKDivider));
    if ((pRCC_ClkInitStruct->APB5CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE5))
3418a6b8:	687b      	ldr	r3, [r7, #4]
3418a6ba:	69da      	ldr	r2, [r3, #28]
3418a6bc:	4b80      	ldr	r3, [pc, #512]	@ (3418a8c0 <HAL_RCC_ClockConfig+0x2b0>)
3418a6be:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418a6c0:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
3418a6c4:	429a      	cmp	r2, r3
3418a6c6:	d908      	bls.n	3418a6da <HAL_RCC_ClockConfig+0xca>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE5, (pRCC_ClkInitStruct->APB5CLKDivider));
3418a6c8:	4b7d      	ldr	r3, [pc, #500]	@ (3418a8c0 <HAL_RCC_ClockConfig+0x2b0>)
3418a6ca:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418a6cc:	f423 22e0 	bic.w	r2, r3, #458752	@ 0x70000
3418a6d0:	687b      	ldr	r3, [r7, #4]
3418a6d2:	69db      	ldr	r3, [r3, #28]
3418a6d4:	497a      	ldr	r1, [pc, #488]	@ (3418a8c0 <HAL_RCC_ClockConfig+0x2b0>)
3418a6d6:	4313      	orrs	r3, r2
3418a6d8:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
3418a6da:	687b      	ldr	r3, [r7, #4]
3418a6dc:	681b      	ldr	r3, [r3, #0]
3418a6de:	f003 0304 	and.w	r3, r3, #4
3418a6e2:	2b00      	cmp	r3, #0
3418a6e4:	d010      	beq.n	3418a708 <HAL_RCC_ClockConfig+0xf8>
  {
    assert_param(IS_RCC_HCLK(pRCC_ClkInitStruct->AHBCLKDivider));
    if ((pRCC_ClkInitStruct->AHBCLKDivider) > (RCC->CFGR2 & RCC_CFGR2_HPRE))
3418a6e6:	687b      	ldr	r3, [r7, #4]
3418a6e8:	68da      	ldr	r2, [r3, #12]
3418a6ea:	4b75      	ldr	r3, [pc, #468]	@ (3418a8c0 <HAL_RCC_ClockConfig+0x2b0>)
3418a6ec:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418a6ee:	f403 03e0 	and.w	r3, r3, #7340032	@ 0x700000
3418a6f2:	429a      	cmp	r2, r3
3418a6f4:	d908      	bls.n	3418a708 <HAL_RCC_ClockConfig+0xf8>
    {
      /* Set the new HCLK clock divider */
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_HPRE, pRCC_ClkInitStruct->AHBCLKDivider);
3418a6f6:	4b72      	ldr	r3, [pc, #456]	@ (3418a8c0 <HAL_RCC_ClockConfig+0x2b0>)
3418a6f8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418a6fa:	f423 02e0 	bic.w	r2, r3, #7340032	@ 0x700000
3418a6fe:	687b      	ldr	r3, [r7, #4]
3418a700:	68db      	ldr	r3, [r3, #12]
3418a702:	496f      	ldr	r1, [pc, #444]	@ (3418a8c0 <HAL_RCC_ClockConfig+0x2b0>)
3418a704:	4313      	orrs	r3, r2
3418a706:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*------------------------- CPUCLK Configuration -------------------------*/
  if ((pRCC_ClkInitStruct->ClockType & RCC_CLOCKTYPE_CPUCLK) == RCC_CLOCKTYPE_CPUCLK)
3418a708:	687b      	ldr	r3, [r7, #4]
3418a70a:	681b      	ldr	r3, [r3, #0]
3418a70c:	f003 0301 	and.w	r3, r3, #1
3418a710:	2b00      	cmp	r3, #0
3418a712:	d063      	beq.n	3418a7dc <HAL_RCC_ClockConfig+0x1cc>
  {
    assert_param(IS_RCC_CPUCLKSOURCE(pRCC_ClkInitStruct->CPUCLKSource));

    /* HSE is selected as CPU Clock Source */
    if (pRCC_ClkInitStruct->CPUCLKSource == RCC_CPUCLKSOURCE_HSE)
3418a714:	687b      	ldr	r3, [r7, #4]
3418a716:	685b      	ldr	r3, [r3, #4]
3418a718:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
3418a71c:	d106      	bne.n	3418a72c <HAL_RCC_ClockConfig+0x11c>
    {
      /* Check the HSE ready flag */
      if (LL_RCC_HSE_IsReady() == 0U)
3418a71e:	f7ff f901 	bl	34189924 <LL_RCC_HSE_IsReady>
3418a722:	4603      	mov	r3, r0
3418a724:	2b00      	cmp	r3, #0
3418a726:	d134      	bne.n	3418a792 <HAL_RCC_ClockConfig+0x182>
      {
        return HAL_ERROR;
3418a728:	2301      	movs	r3, #1
3418a72a:	e16d      	b.n	3418aa08 <HAL_RCC_ClockConfig+0x3f8>
      }
    }
    /* PLL is selected as CPU Clock Source */
    else if (pRCC_ClkInitStruct->CPUCLKSource == RCC_CPUCLKSOURCE_IC1)
3418a72c:	687b      	ldr	r3, [r7, #4]
3418a72e:	685b      	ldr	r3, [r3, #4]
3418a730:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
3418a734:	d11a      	bne.n	3418a76c <HAL_RCC_ClockConfig+0x15c>
      assert_param(IS_RCC_ICCLKSOURCE(pRCC_ClkInitStruct->IC1Selection.ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(pRCC_ClkInitStruct->IC1Selection.ClockDivider));

      /* ICx clock switch requires both origin and destination clock source to be active */
      /* Check IC1 origin and target clock sources availability */
      if (RCC_IC_CheckPLLSources(LL_RCC_IC1_GetSource(), pRCC_ClkInitStruct->IC1Selection.ClockSelection) != 1U)
3418a736:	f7ff fb33 	bl	34189da0 <LL_RCC_IC1_GetSource>
3418a73a:	4602      	mov	r2, r0
3418a73c:	687b      	ldr	r3, [r7, #4]
3418a73e:	6a1b      	ldr	r3, [r3, #32]
3418a740:	4619      	mov	r1, r3
3418a742:	4610      	mov	r0, r2
3418a744:	f000 fd0e 	bl	3418b164 <RCC_IC_CheckPLLSources>
3418a748:	4603      	mov	r3, r0
3418a74a:	2b01      	cmp	r3, #1
3418a74c:	d001      	beq.n	3418a752 <HAL_RCC_ClockConfig+0x142>
      {
        return HAL_ERROR;
3418a74e:	2301      	movs	r3, #1
3418a750:	e15a      	b.n	3418aa08 <HAL_RCC_ClockConfig+0x3f8>
      }

      /* Configure IC1 source and divider */
      WRITE_REG(RCC->IC1CFGR, pRCC_ClkInitStruct->IC1Selection.ClockSelection | \
3418a752:	687b      	ldr	r3, [r7, #4]
3418a754:	6a1a      	ldr	r2, [r3, #32]
3418a756:	687b      	ldr	r3, [r7, #4]
3418a758:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418a75a:	3b01      	subs	r3, #1
3418a75c:	041b      	lsls	r3, r3, #16
3418a75e:	4958      	ldr	r1, [pc, #352]	@ (3418a8c0 <HAL_RCC_ClockConfig+0x2b0>)
3418a760:	4313      	orrs	r3, r2
3418a762:	f8c1 30c4 	str.w	r3, [r1, #196]	@ 0xc4
                ((pRCC_ClkInitStruct->IC1Selection.ClockDivider - 1U) << RCC_IC1CFGR_IC1INT_Pos));

      /* Enable IC1 */
      LL_RCC_IC1_Enable();
3418a766:	f7ff fb0d 	bl	34189d84 <LL_RCC_IC1_Enable>
3418a76a:	e012      	b.n	3418a792 <HAL_RCC_ClockConfig+0x182>
    }
    /* MSI is selected as CPU Clock Source */
    else if (pRCC_ClkInitStruct->CPUCLKSource == RCC_CPUCLKSOURCE_MSI)
3418a76c:	687b      	ldr	r3, [r7, #4]
3418a76e:	685b      	ldr	r3, [r3, #4]
3418a770:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
3418a774:	d106      	bne.n	3418a784 <HAL_RCC_ClockConfig+0x174>
    {
      /* Check the MSI ready flag */
      if (LL_RCC_MSI_IsReady() == 0U)
3418a776:	f7ff f96d 	bl	34189a54 <LL_RCC_MSI_IsReady>
3418a77a:	4603      	mov	r3, r0
3418a77c:	2b00      	cmp	r3, #0
3418a77e:	d108      	bne.n	3418a792 <HAL_RCC_ClockConfig+0x182>
      {
        return HAL_ERROR;
3418a780:	2301      	movs	r3, #1
3418a782:	e141      	b.n	3418aa08 <HAL_RCC_ClockConfig+0x3f8>
    }
    /* HSI is selected as CPU Clock Source */
    else
    {
      /* Check the HSI ready flag */
      if (LL_RCC_HSI_IsReady() == 0U)
3418a784:	f7ff f8fe 	bl	34189984 <LL_RCC_HSI_IsReady>
3418a788:	4603      	mov	r3, r0
3418a78a:	2b00      	cmp	r3, #0
3418a78c:	d101      	bne.n	3418a792 <HAL_RCC_ClockConfig+0x182>
      {
        return HAL_ERROR;
3418a78e:	2301      	movs	r3, #1
3418a790:	e13a      	b.n	3418aa08 <HAL_RCC_ClockConfig+0x3f8>
      }
    }

    /* Switch the CPU clock */
    MODIFY_REG(RCC->CFGR1, RCC_CFGR1_CPUSW, pRCC_ClkInitStruct->CPUCLKSource);
3418a792:	4b4b      	ldr	r3, [pc, #300]	@ (3418a8c0 <HAL_RCC_ClockConfig+0x2b0>)
3418a794:	6a1b      	ldr	r3, [r3, #32]
3418a796:	f423 3240 	bic.w	r2, r3, #196608	@ 0x30000
3418a79a:	687b      	ldr	r3, [r7, #4]
3418a79c:	685b      	ldr	r3, [r3, #4]
3418a79e:	4948      	ldr	r1, [pc, #288]	@ (3418a8c0 <HAL_RCC_ClockConfig+0x2b0>)
3418a7a0:	4313      	orrs	r3, r2
3418a7a2:	620b      	str	r3, [r1, #32]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
3418a7a4:	f7fa ff08 	bl	341855b8 <HAL_GetTick>
3418a7a8:	60f8      	str	r0, [r7, #12]

    while (__HAL_RCC_GET_CPUCLK_SOURCE() != (pRCC_ClkInitStruct->CPUCLKSource << 4U))
3418a7aa:	e00a      	b.n	3418a7c2 <HAL_RCC_ClockConfig+0x1b2>
    {
      if ((HAL_GetTick() - tickstart) > RCC_CLOCKSWITCH_TIMEOUT_VALUE)
3418a7ac:	f7fa ff04 	bl	341855b8 <HAL_GetTick>
3418a7b0:	4602      	mov	r2, r0
3418a7b2:	68fb      	ldr	r3, [r7, #12]
3418a7b4:	1ad3      	subs	r3, r2, r3
3418a7b6:	f241 3288 	movw	r2, #5000	@ 0x1388
3418a7ba:	4293      	cmp	r3, r2
3418a7bc:	d901      	bls.n	3418a7c2 <HAL_RCC_ClockConfig+0x1b2>
      {
        return HAL_TIMEOUT;
3418a7be:	2303      	movs	r3, #3
3418a7c0:	e122      	b.n	3418aa08 <HAL_RCC_ClockConfig+0x3f8>
    while (__HAL_RCC_GET_CPUCLK_SOURCE() != (pRCC_ClkInitStruct->CPUCLKSource << 4U))
3418a7c2:	f7ff f9cf 	bl	34189b64 <LL_RCC_GetCpuClkSource>
3418a7c6:	4602      	mov	r2, r0
3418a7c8:	687b      	ldr	r3, [r7, #4]
3418a7ca:	685b      	ldr	r3, [r3, #4]
3418a7cc:	011b      	lsls	r3, r3, #4
3418a7ce:	429a      	cmp	r2, r3
3418a7d0:	d1ec      	bne.n	3418a7ac <HAL_RCC_ClockConfig+0x19c>
      }
    }

    /* Update the SystemCoreClock global variable with CPU clock */
    SystemCoreClock = HAL_RCC_GetCpuClockFreq();
3418a7d2:	f000 f921 	bl	3418aa18 <HAL_RCC_GetCpuClockFreq>
3418a7d6:	4603      	mov	r3, r0
3418a7d8:	4a3a      	ldr	r2, [pc, #232]	@ (3418a8c4 <HAL_RCC_ClockConfig+0x2b4>)
3418a7da:	6013      	str	r3, [r2, #0]

  }

  /*------------------------- SYSCLK Configuration -------------------------*/
  if ((pRCC_ClkInitStruct->ClockType & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
3418a7dc:	687b      	ldr	r3, [r7, #4]
3418a7de:	681b      	ldr	r3, [r3, #0]
3418a7e0:	f003 0302 	and.w	r3, r3, #2
3418a7e4:	2b00      	cmp	r3, #0
3418a7e6:	f000 8096 	beq.w	3418a916 <HAL_RCC_ClockConfig+0x306>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(pRCC_ClkInitStruct->SYSCLKSource));

    /* HSE is selected as System bus clock source */
    if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
3418a7ea:	687b      	ldr	r3, [r7, #4]
3418a7ec:	689b      	ldr	r3, [r3, #8]
3418a7ee:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
3418a7f2:	d106      	bne.n	3418a802 <HAL_RCC_ClockConfig+0x1f2>
    {
      /* Check the HSE ready flag */
      if (LL_RCC_HSE_IsReady() == 0U)
3418a7f4:	f7ff f896 	bl	34189924 <LL_RCC_HSE_IsReady>
3418a7f8:	4603      	mov	r3, r0
3418a7fa:	2b00      	cmp	r3, #0
3418a7fc:	d16b      	bne.n	3418a8d6 <HAL_RCC_ClockConfig+0x2c6>
      {
        return HAL_ERROR;
3418a7fe:	2301      	movs	r3, #1
3418a800:	e102      	b.n	3418aa08 <HAL_RCC_ClockConfig+0x3f8>
      }
    }
    /* PLL output is selected as System bus clock source */
    else if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_IC2_IC6_IC11)
3418a802:	687b      	ldr	r3, [r7, #4]
3418a804:	689b      	ldr	r3, [r3, #8]
3418a806:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
3418a80a:	d14d      	bne.n	3418a8a8 <HAL_RCC_ClockConfig+0x298>
      assert_param(IS_RCC_ICCLKSOURCE(pRCC_ClkInitStruct->IC11Selection.ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(pRCC_ClkInitStruct->IC11Selection.ClockDivider));

      /* ICx clock switch requires both origin and destination clock source to be active */
      /* Check IC2/IC6/IC11 origin and target clock sources availability */
      if (RCC_IC_CheckPLLSources(LL_RCC_IC2_GetSource(), pRCC_ClkInitStruct->IC2Selection.ClockSelection) != 1U)
3418a80c:	f7ff fae6 	bl	34189ddc <LL_RCC_IC2_GetSource>
3418a810:	4602      	mov	r2, r0
3418a812:	687b      	ldr	r3, [r7, #4]
3418a814:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3418a816:	4619      	mov	r1, r3
3418a818:	4610      	mov	r0, r2
3418a81a:	f000 fca3 	bl	3418b164 <RCC_IC_CheckPLLSources>
3418a81e:	4603      	mov	r3, r0
3418a820:	2b01      	cmp	r3, #1
3418a822:	d001      	beq.n	3418a828 <HAL_RCC_ClockConfig+0x218>
      {
        return HAL_ERROR;
3418a824:	2301      	movs	r3, #1
3418a826:	e0ef      	b.n	3418aa08 <HAL_RCC_ClockConfig+0x3f8>
      }
      if (RCC_IC_CheckPLLSources(LL_RCC_IC6_GetSource(), pRCC_ClkInitStruct->IC6Selection.ClockSelection) != 1U)
3418a828:	f7ff faf6 	bl	34189e18 <LL_RCC_IC6_GetSource>
3418a82c:	4602      	mov	r2, r0
3418a82e:	687b      	ldr	r3, [r7, #4]
3418a830:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3418a832:	4619      	mov	r1, r3
3418a834:	4610      	mov	r0, r2
3418a836:	f000 fc95 	bl	3418b164 <RCC_IC_CheckPLLSources>
3418a83a:	4603      	mov	r3, r0
3418a83c:	2b01      	cmp	r3, #1
3418a83e:	d001      	beq.n	3418a844 <HAL_RCC_ClockConfig+0x234>
      {
        return HAL_ERROR;
3418a840:	2301      	movs	r3, #1
3418a842:	e0e1      	b.n	3418aa08 <HAL_RCC_ClockConfig+0x3f8>
      }
      if (RCC_IC_CheckPLLSources(LL_RCC_IC11_GetSource(), pRCC_ClkInitStruct->IC11Selection.ClockSelection) != 1U)
3418a844:	f7ff faf6 	bl	34189e34 <LL_RCC_IC11_GetSource>
3418a848:	4602      	mov	r2, r0
3418a84a:	687b      	ldr	r3, [r7, #4]
3418a84c:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3418a84e:	4619      	mov	r1, r3
3418a850:	4610      	mov	r0, r2
3418a852:	f000 fc87 	bl	3418b164 <RCC_IC_CheckPLLSources>
3418a856:	4603      	mov	r3, r0
3418a858:	2b01      	cmp	r3, #1
3418a85a:	d001      	beq.n	3418a860 <HAL_RCC_ClockConfig+0x250>
      {
        return HAL_ERROR;
3418a85c:	2301      	movs	r3, #1
3418a85e:	e0d3      	b.n	3418aa08 <HAL_RCC_ClockConfig+0x3f8>
      }

      /* Configure IC2, IC6 and IC11 sources and dividers */
      WRITE_REG(RCC->IC2CFGR, pRCC_ClkInitStruct->IC2Selection.ClockSelection | \
3418a860:	687b      	ldr	r3, [r7, #4]
3418a862:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
3418a864:	687b      	ldr	r3, [r7, #4]
3418a866:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3418a868:	3b01      	subs	r3, #1
3418a86a:	041b      	lsls	r3, r3, #16
3418a86c:	4914      	ldr	r1, [pc, #80]	@ (3418a8c0 <HAL_RCC_ClockConfig+0x2b0>)
3418a86e:	4313      	orrs	r3, r2
3418a870:	f8c1 30c8 	str.w	r3, [r1, #200]	@ 0xc8
                ((pRCC_ClkInitStruct->IC2Selection.ClockDivider - 1U) << RCC_IC2CFGR_IC2INT_Pos));
      WRITE_REG(RCC->IC6CFGR, pRCC_ClkInitStruct->IC6Selection.ClockSelection | \
3418a874:	687b      	ldr	r3, [r7, #4]
3418a876:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
3418a878:	687b      	ldr	r3, [r7, #4]
3418a87a:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3418a87c:	3b01      	subs	r3, #1
3418a87e:	041b      	lsls	r3, r3, #16
3418a880:	490f      	ldr	r1, [pc, #60]	@ (3418a8c0 <HAL_RCC_ClockConfig+0x2b0>)
3418a882:	4313      	orrs	r3, r2
3418a884:	f8c1 30d8 	str.w	r3, [r1, #216]	@ 0xd8
                ((pRCC_ClkInitStruct->IC6Selection.ClockDivider - 1U) << RCC_IC6CFGR_IC6INT_Pos));
      WRITE_REG(RCC->IC11CFGR, pRCC_ClkInitStruct->IC11Selection.ClockSelection | \
3418a888:	687b      	ldr	r3, [r7, #4]
3418a88a:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
3418a88c:	687b      	ldr	r3, [r7, #4]
3418a88e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3418a890:	3b01      	subs	r3, #1
3418a892:	041b      	lsls	r3, r3, #16
3418a894:	490a      	ldr	r1, [pc, #40]	@ (3418a8c0 <HAL_RCC_ClockConfig+0x2b0>)
3418a896:	4313      	orrs	r3, r2
3418a898:	f8c1 30ec 	str.w	r3, [r1, #236]	@ 0xec
                ((pRCC_ClkInitStruct->IC11Selection.ClockDivider - 1U) << RCC_IC11CFGR_IC11INT_Pos));

      /* Require to have IC2, IC6 and IC11 outputs enabled */
      WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC2ENS | RCC_DIVENSR_IC6ENS | RCC_DIVENSR_IC11ENS);
3418a89c:	4b08      	ldr	r3, [pc, #32]	@ (3418a8c0 <HAL_RCC_ClockConfig+0x2b0>)
3418a89e:	f240 4222 	movw	r2, #1058	@ 0x422
3418a8a2:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
3418a8a6:	e016      	b.n	3418a8d6 <HAL_RCC_ClockConfig+0x2c6>
    }
    /* HSI is selected as System bus clock source */
    else if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
3418a8a8:	687b      	ldr	r3, [r7, #4]
3418a8aa:	689b      	ldr	r3, [r3, #8]
3418a8ac:	2b00      	cmp	r3, #0
3418a8ae:	d10b      	bne.n	3418a8c8 <HAL_RCC_ClockConfig+0x2b8>
    {
      /* Check the HSI ready flag */
      if (LL_RCC_HSI_IsReady() == 0U)
3418a8b0:	f7ff f868 	bl	34189984 <LL_RCC_HSI_IsReady>
3418a8b4:	4603      	mov	r3, r0
3418a8b6:	2b00      	cmp	r3, #0
3418a8b8:	d10d      	bne.n	3418a8d6 <HAL_RCC_ClockConfig+0x2c6>
      {
        return HAL_ERROR;
3418a8ba:	2301      	movs	r3, #1
3418a8bc:	e0a4      	b.n	3418aa08 <HAL_RCC_ClockConfig+0x3f8>
3418a8be:	bf00      	nop
3418a8c0:	56028000 	.word	0x56028000
3418a8c4:	341c0090 	.word	0x341c0090
    }
    /* MSI is selected as System bus clock source */
    else
    {
      /* Check the MSI ready flag */
      if (LL_RCC_MSI_IsReady() == 0U)
3418a8c8:	f7ff f8c4 	bl	34189a54 <LL_RCC_MSI_IsReady>
3418a8cc:	4603      	mov	r3, r0
3418a8ce:	2b00      	cmp	r3, #0
3418a8d0:	d101      	bne.n	3418a8d6 <HAL_RCC_ClockConfig+0x2c6>
      {
        return HAL_ERROR;
3418a8d2:	2301      	movs	r3, #1
3418a8d4:	e098      	b.n	3418aa08 <HAL_RCC_ClockConfig+0x3f8>
      }
    }

    /* Switch the system bus clocks */
    MODIFY_REG(RCC->CFGR1, RCC_CFGR1_SYSSW, pRCC_ClkInitStruct->SYSCLKSource);
3418a8d6:	4b4e      	ldr	r3, [pc, #312]	@ (3418aa10 <HAL_RCC_ClockConfig+0x400>)
3418a8d8:	6a1b      	ldr	r3, [r3, #32]
3418a8da:	f023 7240 	bic.w	r2, r3, #50331648	@ 0x3000000
3418a8de:	687b      	ldr	r3, [r7, #4]
3418a8e0:	689b      	ldr	r3, [r3, #8]
3418a8e2:	494b      	ldr	r1, [pc, #300]	@ (3418aa10 <HAL_RCC_ClockConfig+0x400>)
3418a8e4:	4313      	orrs	r3, r2
3418a8e6:	620b      	str	r3, [r1, #32]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
3418a8e8:	f7fa fe66 	bl	341855b8 <HAL_GetTick>
3418a8ec:	60f8      	str	r0, [r7, #12]

    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (pRCC_ClkInitStruct->SYSCLKSource << 4U))
3418a8ee:	e00a      	b.n	3418a906 <HAL_RCC_ClockConfig+0x2f6>
    {
      if ((HAL_GetTick() - tickstart) > RCC_CLOCKSWITCH_TIMEOUT_VALUE)
3418a8f0:	f7fa fe62 	bl	341855b8 <HAL_GetTick>
3418a8f4:	4602      	mov	r2, r0
3418a8f6:	68fb      	ldr	r3, [r7, #12]
3418a8f8:	1ad3      	subs	r3, r2, r3
3418a8fa:	f241 3288 	movw	r2, #5000	@ 0x1388
3418a8fe:	4293      	cmp	r3, r2
3418a900:	d901      	bls.n	3418a906 <HAL_RCC_ClockConfig+0x2f6>
      {
        return HAL_TIMEOUT;
3418a902:	2303      	movs	r3, #3
3418a904:	e080      	b.n	3418aa08 <HAL_RCC_ClockConfig+0x3f8>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (pRCC_ClkInitStruct->SYSCLKSource << 4U))
3418a906:	f7ff f93b 	bl	34189b80 <LL_RCC_GetSysClkSource>
3418a90a:	4602      	mov	r2, r0
3418a90c:	687b      	ldr	r3, [r7, #4]
3418a90e:	689b      	ldr	r3, [r3, #8]
3418a910:	011b      	lsls	r3, r3, #4
3418a912:	429a      	cmp	r2, r3
3418a914:	d1ec      	bne.n	3418a8f0 <HAL_RCC_ClockConfig+0x2e0>
  }

  /* Decreasing the BUS frequency divider ? */

  /*-------------------------- HCLK Configuration --------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
3418a916:	687b      	ldr	r3, [r7, #4]
3418a918:	681b      	ldr	r3, [r3, #0]
3418a91a:	f003 0304 	and.w	r3, r3, #4
3418a91e:	2b00      	cmp	r3, #0
3418a920:	d010      	beq.n	3418a944 <HAL_RCC_ClockConfig+0x334>
  {
    assert_param(IS_RCC_HCLK(pRCC_ClkInitStruct->AHBCLKDivider));
    if ((pRCC_ClkInitStruct->AHBCLKDivider) < (RCC->CFGR2 & RCC_CFGR2_HPRE))
3418a922:	687b      	ldr	r3, [r7, #4]
3418a924:	68da      	ldr	r2, [r3, #12]
3418a926:	4b3a      	ldr	r3, [pc, #232]	@ (3418aa10 <HAL_RCC_ClockConfig+0x400>)
3418a928:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418a92a:	f403 03e0 	and.w	r3, r3, #7340032	@ 0x700000
3418a92e:	429a      	cmp	r2, r3
3418a930:	d208      	bcs.n	3418a944 <HAL_RCC_ClockConfig+0x334>
    {
      /* Set the new HCLK clock divider */
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_HPRE, pRCC_ClkInitStruct->AHBCLKDivider);
3418a932:	4b37      	ldr	r3, [pc, #220]	@ (3418aa10 <HAL_RCC_ClockConfig+0x400>)
3418a934:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418a936:	f423 02e0 	bic.w	r2, r3, #7340032	@ 0x700000
3418a93a:	687b      	ldr	r3, [r7, #4]
3418a93c:	68db      	ldr	r3, [r3, #12]
3418a93e:	4934      	ldr	r1, [pc, #208]	@ (3418aa10 <HAL_RCC_ClockConfig+0x400>)
3418a940:	4313      	orrs	r3, r2
3418a942:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
3418a944:	687b      	ldr	r3, [r7, #4]
3418a946:	681b      	ldr	r3, [r3, #0]
3418a948:	f003 0308 	and.w	r3, r3, #8
3418a94c:	2b00      	cmp	r3, #0
3418a94e:	d010      	beq.n	3418a972 <HAL_RCC_ClockConfig+0x362>
  {
    assert_param(IS_RCC_PCLK1(pRCC_ClkInitStruct->APB1CLKDivider));
    if ((pRCC_ClkInitStruct->APB1CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE1))
3418a950:	687b      	ldr	r3, [r7, #4]
3418a952:	691a      	ldr	r2, [r3, #16]
3418a954:	4b2e      	ldr	r3, [pc, #184]	@ (3418aa10 <HAL_RCC_ClockConfig+0x400>)
3418a956:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418a958:	f003 0307 	and.w	r3, r3, #7
3418a95c:	429a      	cmp	r2, r3
3418a95e:	d208      	bcs.n	3418a972 <HAL_RCC_ClockConfig+0x362>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE1, (pRCC_ClkInitStruct->APB1CLKDivider));
3418a960:	4b2b      	ldr	r3, [pc, #172]	@ (3418aa10 <HAL_RCC_ClockConfig+0x400>)
3418a962:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418a964:	f023 0207 	bic.w	r2, r3, #7
3418a968:	687b      	ldr	r3, [r7, #4]
3418a96a:	691b      	ldr	r3, [r3, #16]
3418a96c:	4928      	ldr	r1, [pc, #160]	@ (3418aa10 <HAL_RCC_ClockConfig+0x400>)
3418a96e:	4313      	orrs	r3, r2
3418a970:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
3418a972:	687b      	ldr	r3, [r7, #4]
3418a974:	681b      	ldr	r3, [r3, #0]
3418a976:	f003 0310 	and.w	r3, r3, #16
3418a97a:	2b00      	cmp	r3, #0
3418a97c:	d010      	beq.n	3418a9a0 <HAL_RCC_ClockConfig+0x390>
  {
    assert_param(IS_RCC_PCLK2(pRCC_ClkInitStruct->APB2CLKDivider));
    if ((pRCC_ClkInitStruct->APB2CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE2))
3418a97e:	687b      	ldr	r3, [r7, #4]
3418a980:	695a      	ldr	r2, [r3, #20]
3418a982:	4b23      	ldr	r3, [pc, #140]	@ (3418aa10 <HAL_RCC_ClockConfig+0x400>)
3418a984:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418a986:	f003 0370 	and.w	r3, r3, #112	@ 0x70
3418a98a:	429a      	cmp	r2, r3
3418a98c:	d208      	bcs.n	3418a9a0 <HAL_RCC_ClockConfig+0x390>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE2, (pRCC_ClkInitStruct->APB2CLKDivider));
3418a98e:	4b20      	ldr	r3, [pc, #128]	@ (3418aa10 <HAL_RCC_ClockConfig+0x400>)
3418a990:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418a992:	f023 0270 	bic.w	r2, r3, #112	@ 0x70
3418a996:	687b      	ldr	r3, [r7, #4]
3418a998:	695b      	ldr	r3, [r3, #20]
3418a99a:	491d      	ldr	r1, [pc, #116]	@ (3418aa10 <HAL_RCC_ClockConfig+0x400>)
3418a99c:	4313      	orrs	r3, r2
3418a99e:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK4 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK4) == RCC_CLOCKTYPE_PCLK4)
3418a9a0:	687b      	ldr	r3, [r7, #4]
3418a9a2:	681b      	ldr	r3, [r3, #0]
3418a9a4:	f003 0320 	and.w	r3, r3, #32
3418a9a8:	2b00      	cmp	r3, #0
3418a9aa:	d010      	beq.n	3418a9ce <HAL_RCC_ClockConfig+0x3be>
  {
    assert_param(IS_RCC_PCLK4(pRCC_ClkInitStruct->APB4CLKDivider));
    if ((pRCC_ClkInitStruct->APB4CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE4))
3418a9ac:	687b      	ldr	r3, [r7, #4]
3418a9ae:	699a      	ldr	r2, [r3, #24]
3418a9b0:	4b17      	ldr	r3, [pc, #92]	@ (3418aa10 <HAL_RCC_ClockConfig+0x400>)
3418a9b2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418a9b4:	f403 43e0 	and.w	r3, r3, #28672	@ 0x7000
3418a9b8:	429a      	cmp	r2, r3
3418a9ba:	d208      	bcs.n	3418a9ce <HAL_RCC_ClockConfig+0x3be>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE4, (pRCC_ClkInitStruct->APB4CLKDivider));
3418a9bc:	4b14      	ldr	r3, [pc, #80]	@ (3418aa10 <HAL_RCC_ClockConfig+0x400>)
3418a9be:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418a9c0:	f423 42e0 	bic.w	r2, r3, #28672	@ 0x7000
3418a9c4:	687b      	ldr	r3, [r7, #4]
3418a9c6:	699b      	ldr	r3, [r3, #24]
3418a9c8:	4911      	ldr	r1, [pc, #68]	@ (3418aa10 <HAL_RCC_ClockConfig+0x400>)
3418a9ca:	4313      	orrs	r3, r2
3418a9cc:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK5 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK5) == RCC_CLOCKTYPE_PCLK5)
3418a9ce:	687b      	ldr	r3, [r7, #4]
3418a9d0:	681b      	ldr	r3, [r3, #0]
3418a9d2:	f003 0340 	and.w	r3, r3, #64	@ 0x40
3418a9d6:	2b00      	cmp	r3, #0
3418a9d8:	d010      	beq.n	3418a9fc <HAL_RCC_ClockConfig+0x3ec>
  {
    assert_param(IS_RCC_PCLK5(pRCC_ClkInitStruct->APB5CLKDivider));
    if ((pRCC_ClkInitStruct->APB5CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE5))
3418a9da:	687b      	ldr	r3, [r7, #4]
3418a9dc:	69da      	ldr	r2, [r3, #28]
3418a9de:	4b0c      	ldr	r3, [pc, #48]	@ (3418aa10 <HAL_RCC_ClockConfig+0x400>)
3418a9e0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418a9e2:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
3418a9e6:	429a      	cmp	r2, r3
3418a9e8:	d208      	bcs.n	3418a9fc <HAL_RCC_ClockConfig+0x3ec>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE5, (pRCC_ClkInitStruct->APB5CLKDivider));
3418a9ea:	4b09      	ldr	r3, [pc, #36]	@ (3418aa10 <HAL_RCC_ClockConfig+0x400>)
3418a9ec:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418a9ee:	f423 22e0 	bic.w	r2, r3, #458752	@ 0x70000
3418a9f2:	687b      	ldr	r3, [r7, #4]
3418a9f4:	69db      	ldr	r3, [r3, #28]
3418a9f6:	4906      	ldr	r1, [pc, #24]	@ (3418aa10 <HAL_RCC_ClockConfig+0x400>)
3418a9f8:	4313      	orrs	r3, r2
3418a9fa:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /* Configure the source of time base considering new system clocks settings*/
  return HAL_InitTick(uwTickPrio);
3418a9fc:	4b05      	ldr	r3, [pc, #20]	@ (3418aa14 <HAL_RCC_ClockConfig+0x404>)
3418a9fe:	681b      	ldr	r3, [r3, #0]
3418aa00:	4618      	mov	r0, r3
3418aa02:	f7f6 ff69 	bl	341818d8 <HAL_InitTick>
3418aa06:	4603      	mov	r3, r0
}
3418aa08:	4618      	mov	r0, r3
3418aa0a:	3710      	adds	r7, #16
3418aa0c:	46bd      	mov	sp, r7
3418aa0e:	bd80      	pop	{r7, pc}
3418aa10:	56028000 	.word	0x56028000
3418aa14:	341c0094 	.word	0x341c0094

3418aa18 <HAL_RCC_GetCpuClockFreq>:
  *         will be incorrect.
  *
  * @retval CPUCLK frequency
  */
uint32_t HAL_RCC_GetCpuClockFreq(void)
{
3418aa18:	b580      	push	{r7, lr}
3418aa1a:	b082      	sub	sp, #8
3418aa1c:	af00      	add	r7, sp, #0
  uint32_t frequency = 0U;
3418aa1e:	2300      	movs	r3, #0
3418aa20:	607b      	str	r3, [r7, #4]
  uint32_t ic_divider;

  /* Get CPUCLK source -------------------------------------------------------*/
  switch (LL_RCC_GetCpuClkSource())
3418aa22:	f7ff f89f 	bl	34189b64 <LL_RCC_GetCpuClkSource>
3418aa26:	4603      	mov	r3, r0
3418aa28:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
3418aa2c:	d025      	beq.n	3418aa7a <HAL_RCC_GetCpuClockFreq+0x62>
3418aa2e:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
3418aa32:	d860      	bhi.n	3418aaf6 <HAL_RCC_GetCpuClockFreq+0xde>
3418aa34:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
3418aa38:	d01c      	beq.n	3418aa74 <HAL_RCC_GetCpuClockFreq+0x5c>
3418aa3a:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
3418aa3e:	d85a      	bhi.n	3418aaf6 <HAL_RCC_GetCpuClockFreq+0xde>
3418aa40:	2b00      	cmp	r3, #0
3418aa42:	d003      	beq.n	3418aa4c <HAL_RCC_GetCpuClockFreq+0x34>
3418aa44:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
3418aa48:	d009      	beq.n	3418aa5e <HAL_RCC_GetCpuClockFreq+0x46>
      }
      break;

    default:
      /* Unexpected case */
      break;
3418aa4a:	e054      	b.n	3418aaf6 <HAL_RCC_GetCpuClockFreq+0xde>
      frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3418aa4c:	f7fe ffc0 	bl	341899d0 <LL_RCC_HSI_GetDivider>
3418aa50:	4603      	mov	r3, r0
3418aa52:	09db      	lsrs	r3, r3, #7
3418aa54:	4a2b      	ldr	r2, [pc, #172]	@ (3418ab04 <HAL_RCC_GetCpuClockFreq+0xec>)
3418aa56:	fa22 f303 	lsr.w	r3, r2, r3
3418aa5a:	607b      	str	r3, [r7, #4]
      break;
3418aa5c:	e04c      	b.n	3418aaf8 <HAL_RCC_GetCpuClockFreq+0xe0>
      if (LL_RCC_MSI_GetFrequency() == LL_RCC_MSI_FREQ_4MHZ)
3418aa5e:	f7ff f81f 	bl	34189aa0 <LL_RCC_MSI_GetFrequency>
3418aa62:	4603      	mov	r3, r0
3418aa64:	2b00      	cmp	r3, #0
3418aa66:	d102      	bne.n	3418aa6e <HAL_RCC_GetCpuClockFreq+0x56>
        frequency = MSI_VALUE;
3418aa68:	4b27      	ldr	r3, [pc, #156]	@ (3418ab08 <HAL_RCC_GetCpuClockFreq+0xf0>)
3418aa6a:	607b      	str	r3, [r7, #4]
      break;
3418aa6c:	e044      	b.n	3418aaf8 <HAL_RCC_GetCpuClockFreq+0xe0>
        frequency = 16000000UL;
3418aa6e:	4b27      	ldr	r3, [pc, #156]	@ (3418ab0c <HAL_RCC_GetCpuClockFreq+0xf4>)
3418aa70:	607b      	str	r3, [r7, #4]
      break;
3418aa72:	e041      	b.n	3418aaf8 <HAL_RCC_GetCpuClockFreq+0xe0>
      frequency = HSE_VALUE;
3418aa74:	4b26      	ldr	r3, [pc, #152]	@ (3418ab10 <HAL_RCC_GetCpuClockFreq+0xf8>)
3418aa76:	607b      	str	r3, [r7, #4]
      break;
3418aa78:	e03e      	b.n	3418aaf8 <HAL_RCC_GetCpuClockFreq+0xe0>
      ic_divider = LL_RCC_IC1_GetDivider();
3418aa7a:	f7ff f99f 	bl	34189dbc <LL_RCC_IC1_GetDivider>
3418aa7e:	6038      	str	r0, [r7, #0]
      switch (LL_RCC_IC1_GetSource())
3418aa80:	f7ff f98e 	bl	34189da0 <LL_RCC_IC1_GetSource>
3418aa84:	4603      	mov	r3, r0
3418aa86:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418aa8a:	d029      	beq.n	3418aae0 <HAL_RCC_GetCpuClockFreq+0xc8>
3418aa8c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418aa90:	d82f      	bhi.n	3418aaf2 <HAL_RCC_GetCpuClockFreq+0xda>
3418aa92:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418aa96:	d01a      	beq.n	3418aace <HAL_RCC_GetCpuClockFreq+0xb6>
3418aa98:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418aa9c:	d829      	bhi.n	3418aaf2 <HAL_RCC_GetCpuClockFreq+0xda>
3418aa9e:	2b00      	cmp	r3, #0
3418aaa0:	d003      	beq.n	3418aaaa <HAL_RCC_GetCpuClockFreq+0x92>
3418aaa2:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3418aaa6:	d009      	beq.n	3418aabc <HAL_RCC_GetCpuClockFreq+0xa4>
          break;
3418aaa8:	e023      	b.n	3418aaf2 <HAL_RCC_GetCpuClockFreq+0xda>
          frequency = HAL_RCCEx_GetPLL1CLKFreq();
3418aaaa:	f002 f99d 	bl	3418cde8 <HAL_RCCEx_GetPLL1CLKFreq>
3418aaae:	6078      	str	r0, [r7, #4]
          frequency = frequency / ic_divider;
3418aab0:	687a      	ldr	r2, [r7, #4]
3418aab2:	683b      	ldr	r3, [r7, #0]
3418aab4:	fbb2 f3f3 	udiv	r3, r2, r3
3418aab8:	607b      	str	r3, [r7, #4]
          break;
3418aaba:	e01b      	b.n	3418aaf4 <HAL_RCC_GetCpuClockFreq+0xdc>
          frequency = HAL_RCCEx_GetPLL2CLKFreq();
3418aabc:	f002 f9d4 	bl	3418ce68 <HAL_RCCEx_GetPLL2CLKFreq>
3418aac0:	6078      	str	r0, [r7, #4]
          frequency = frequency / ic_divider;
3418aac2:	687a      	ldr	r2, [r7, #4]
3418aac4:	683b      	ldr	r3, [r7, #0]
3418aac6:	fbb2 f3f3 	udiv	r3, r2, r3
3418aaca:	607b      	str	r3, [r7, #4]
          break;
3418aacc:	e012      	b.n	3418aaf4 <HAL_RCC_GetCpuClockFreq+0xdc>
          frequency = HAL_RCCEx_GetPLL3CLKFreq();
3418aace:	f002 fa0b 	bl	3418cee8 <HAL_RCCEx_GetPLL3CLKFreq>
3418aad2:	6078      	str	r0, [r7, #4]
          frequency = frequency / ic_divider;
3418aad4:	687a      	ldr	r2, [r7, #4]
3418aad6:	683b      	ldr	r3, [r7, #0]
3418aad8:	fbb2 f3f3 	udiv	r3, r2, r3
3418aadc:	607b      	str	r3, [r7, #4]
          break;
3418aade:	e009      	b.n	3418aaf4 <HAL_RCC_GetCpuClockFreq+0xdc>
          frequency = HAL_RCCEx_GetPLL4CLKFreq();
3418aae0:	f002 fa42 	bl	3418cf68 <HAL_RCCEx_GetPLL4CLKFreq>
3418aae4:	6078      	str	r0, [r7, #4]
          frequency = frequency / ic_divider;
3418aae6:	687a      	ldr	r2, [r7, #4]
3418aae8:	683b      	ldr	r3, [r7, #0]
3418aaea:	fbb2 f3f3 	udiv	r3, r2, r3
3418aaee:	607b      	str	r3, [r7, #4]
          break;
3418aaf0:	e000      	b.n	3418aaf4 <HAL_RCC_GetCpuClockFreq+0xdc>
          break;
3418aaf2:	bf00      	nop
      break;
3418aaf4:	e000      	b.n	3418aaf8 <HAL_RCC_GetCpuClockFreq+0xe0>
      break;
3418aaf6:	bf00      	nop
  }

  return frequency;
3418aaf8:	687b      	ldr	r3, [r7, #4]
}
3418aafa:	4618      	mov	r0, r3
3418aafc:	3708      	adds	r7, #8
3418aafe:	46bd      	mov	sp, r7
3418ab00:	bd80      	pop	{r7, pc}
3418ab02:	bf00      	nop
3418ab04:	03d09000 	.word	0x03d09000
3418ab08:	003d0900 	.word	0x003d0900
3418ab0c:	00f42400 	.word	0x00f42400
3418ab10:	02dc6c00 	.word	0x02dc6c00

3418ab14 <HAL_RCC_GetSysClockFreq>:
  *         will be incorrect.
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
3418ab14:	b580      	push	{r7, lr}
3418ab16:	b082      	sub	sp, #8
3418ab18:	af00      	add	r7, sp, #0
  uint32_t frequency = 0U;
3418ab1a:	2300      	movs	r3, #0
3418ab1c:	607b      	str	r3, [r7, #4]
  uint32_t ic_divider;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (LL_RCC_GetSysClkSource())
3418ab1e:	f7ff f82f 	bl	34189b80 <LL_RCC_GetSysClkSource>
3418ab22:	4603      	mov	r3, r0
3418ab24:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418ab28:	d025      	beq.n	3418ab76 <HAL_RCC_GetSysClockFreq+0x62>
3418ab2a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418ab2e:	d860      	bhi.n	3418abf2 <HAL_RCC_GetSysClockFreq+0xde>
3418ab30:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418ab34:	d01c      	beq.n	3418ab70 <HAL_RCC_GetSysClockFreq+0x5c>
3418ab36:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418ab3a:	d85a      	bhi.n	3418abf2 <HAL_RCC_GetSysClockFreq+0xde>
3418ab3c:	2b00      	cmp	r3, #0
3418ab3e:	d003      	beq.n	3418ab48 <HAL_RCC_GetSysClockFreq+0x34>
3418ab40:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3418ab44:	d009      	beq.n	3418ab5a <HAL_RCC_GetSysClockFreq+0x46>
      }
      break;

    default:
      /* Unexpected case */
      break;
3418ab46:	e054      	b.n	3418abf2 <HAL_RCC_GetSysClockFreq+0xde>
      frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3418ab48:	f7fe ff42 	bl	341899d0 <LL_RCC_HSI_GetDivider>
3418ab4c:	4603      	mov	r3, r0
3418ab4e:	09db      	lsrs	r3, r3, #7
3418ab50:	4a2b      	ldr	r2, [pc, #172]	@ (3418ac00 <HAL_RCC_GetSysClockFreq+0xec>)
3418ab52:	fa22 f303 	lsr.w	r3, r2, r3
3418ab56:	607b      	str	r3, [r7, #4]
      break;
3418ab58:	e04c      	b.n	3418abf4 <HAL_RCC_GetSysClockFreq+0xe0>
      if (LL_RCC_MSI_GetFrequency() == LL_RCC_MSI_FREQ_4MHZ)
3418ab5a:	f7fe ffa1 	bl	34189aa0 <LL_RCC_MSI_GetFrequency>
3418ab5e:	4603      	mov	r3, r0
3418ab60:	2b00      	cmp	r3, #0
3418ab62:	d102      	bne.n	3418ab6a <HAL_RCC_GetSysClockFreq+0x56>
        frequency = MSI_VALUE;
3418ab64:	4b27      	ldr	r3, [pc, #156]	@ (3418ac04 <HAL_RCC_GetSysClockFreq+0xf0>)
3418ab66:	607b      	str	r3, [r7, #4]
      break;
3418ab68:	e044      	b.n	3418abf4 <HAL_RCC_GetSysClockFreq+0xe0>
        frequency = 16000000UL;
3418ab6a:	4b27      	ldr	r3, [pc, #156]	@ (3418ac08 <HAL_RCC_GetSysClockFreq+0xf4>)
3418ab6c:	607b      	str	r3, [r7, #4]
      break;
3418ab6e:	e041      	b.n	3418abf4 <HAL_RCC_GetSysClockFreq+0xe0>
      frequency = HSE_VALUE;
3418ab70:	4b26      	ldr	r3, [pc, #152]	@ (3418ac0c <HAL_RCC_GetSysClockFreq+0xf8>)
3418ab72:	607b      	str	r3, [r7, #4]
      break;
3418ab74:	e03e      	b.n	3418abf4 <HAL_RCC_GetSysClockFreq+0xe0>
      ic_divider = LL_RCC_IC2_GetDivider();
3418ab76:	f7ff f93f 	bl	34189df8 <LL_RCC_IC2_GetDivider>
3418ab7a:	6038      	str	r0, [r7, #0]
      switch (LL_RCC_IC2_GetSource())
3418ab7c:	f7ff f92e 	bl	34189ddc <LL_RCC_IC2_GetSource>
3418ab80:	4603      	mov	r3, r0
3418ab82:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418ab86:	d029      	beq.n	3418abdc <HAL_RCC_GetSysClockFreq+0xc8>
3418ab88:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418ab8c:	d82f      	bhi.n	3418abee <HAL_RCC_GetSysClockFreq+0xda>
3418ab8e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418ab92:	d01a      	beq.n	3418abca <HAL_RCC_GetSysClockFreq+0xb6>
3418ab94:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418ab98:	d829      	bhi.n	3418abee <HAL_RCC_GetSysClockFreq+0xda>
3418ab9a:	2b00      	cmp	r3, #0
3418ab9c:	d003      	beq.n	3418aba6 <HAL_RCC_GetSysClockFreq+0x92>
3418ab9e:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3418aba2:	d009      	beq.n	3418abb8 <HAL_RCC_GetSysClockFreq+0xa4>
          break;
3418aba4:	e023      	b.n	3418abee <HAL_RCC_GetSysClockFreq+0xda>
          frequency = HAL_RCCEx_GetPLL1CLKFreq();
3418aba6:	f002 f91f 	bl	3418cde8 <HAL_RCCEx_GetPLL1CLKFreq>
3418abaa:	6078      	str	r0, [r7, #4]
          frequency = frequency / ic_divider;
3418abac:	687a      	ldr	r2, [r7, #4]
3418abae:	683b      	ldr	r3, [r7, #0]
3418abb0:	fbb2 f3f3 	udiv	r3, r2, r3
3418abb4:	607b      	str	r3, [r7, #4]
          break;
3418abb6:	e01b      	b.n	3418abf0 <HAL_RCC_GetSysClockFreq+0xdc>
          frequency = HAL_RCCEx_GetPLL2CLKFreq();
3418abb8:	f002 f956 	bl	3418ce68 <HAL_RCCEx_GetPLL2CLKFreq>
3418abbc:	6078      	str	r0, [r7, #4]
          frequency = frequency / ic_divider;
3418abbe:	687a      	ldr	r2, [r7, #4]
3418abc0:	683b      	ldr	r3, [r7, #0]
3418abc2:	fbb2 f3f3 	udiv	r3, r2, r3
3418abc6:	607b      	str	r3, [r7, #4]
          break;
3418abc8:	e012      	b.n	3418abf0 <HAL_RCC_GetSysClockFreq+0xdc>
          frequency = HAL_RCCEx_GetPLL3CLKFreq();
3418abca:	f002 f98d 	bl	3418cee8 <HAL_RCCEx_GetPLL3CLKFreq>
3418abce:	6078      	str	r0, [r7, #4]
          frequency = frequency / ic_divider;
3418abd0:	687a      	ldr	r2, [r7, #4]
3418abd2:	683b      	ldr	r3, [r7, #0]
3418abd4:	fbb2 f3f3 	udiv	r3, r2, r3
3418abd8:	607b      	str	r3, [r7, #4]
          break;
3418abda:	e009      	b.n	3418abf0 <HAL_RCC_GetSysClockFreq+0xdc>
          frequency = HAL_RCCEx_GetPLL4CLKFreq();
3418abdc:	f002 f9c4 	bl	3418cf68 <HAL_RCCEx_GetPLL4CLKFreq>
3418abe0:	6078      	str	r0, [r7, #4]
          frequency = frequency / ic_divider;
3418abe2:	687a      	ldr	r2, [r7, #4]
3418abe4:	683b      	ldr	r3, [r7, #0]
3418abe6:	fbb2 f3f3 	udiv	r3, r2, r3
3418abea:	607b      	str	r3, [r7, #4]
          break;
3418abec:	e000      	b.n	3418abf0 <HAL_RCC_GetSysClockFreq+0xdc>
          break;
3418abee:	bf00      	nop
      break;
3418abf0:	e000      	b.n	3418abf4 <HAL_RCC_GetSysClockFreq+0xe0>
      break;
3418abf2:	bf00      	nop
  }

  return frequency;
3418abf4:	687b      	ldr	r3, [r7, #4]
}
3418abf6:	4618      	mov	r0, r3
3418abf8:	3708      	adds	r7, #8
3418abfa:	46bd      	mov	sp, r7
3418abfc:	bd80      	pop	{r7, pc}
3418abfe:	bf00      	nop
3418ac00:	03d09000 	.word	0x03d09000
3418ac04:	003d0900 	.word	0x003d0900
3418ac08:	00f42400 	.word	0x00f42400
3418ac0c:	02dc6c00 	.word	0x02dc6c00

3418ac10 <HAL_RCC_GetHCLKFreq>:
/**
  * @brief  Return the HCLK frequency.
  * @retval HCLK frequency in Hz
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
3418ac10:	b598      	push	{r3, r4, r7, lr}
3418ac12:	af00      	add	r7, sp, #0
  return LL_RCC_CALC_HCLK_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetAHBPrescaler());
3418ac14:	f7ff ff7e 	bl	3418ab14 <HAL_RCC_GetSysClockFreq>
3418ac18:	4604      	mov	r4, r0
3418ac1a:	f7fe ffbf 	bl	34189b9c <LL_RCC_GetAHBPrescaler>
3418ac1e:	4603      	mov	r3, r0
3418ac20:	0d1b      	lsrs	r3, r3, #20
3418ac22:	f003 0307 	and.w	r3, r3, #7
3418ac26:	fa24 f303 	lsr.w	r3, r4, r3
}
3418ac2a:	4618      	mov	r0, r3
3418ac2c:	bd98      	pop	{r3, r4, r7, pc}

3418ac2e <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
3418ac2e:	b598      	push	{r3, r4, r7, lr}
3418ac30:	af00      	add	r7, sp, #0
  return LL_RCC_CALC_PCLK1_FREQ(LL_RCC_CALC_HCLK_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetAHBPrescaler()),
3418ac32:	f7ff ff6f 	bl	3418ab14 <HAL_RCC_GetSysClockFreq>
3418ac36:	4604      	mov	r4, r0
3418ac38:	f7fe ffb0 	bl	34189b9c <LL_RCC_GetAHBPrescaler>
3418ac3c:	4603      	mov	r3, r0
3418ac3e:	0d1b      	lsrs	r3, r3, #20
3418ac40:	f003 0307 	and.w	r3, r3, #7
3418ac44:	40dc      	lsrs	r4, r3
3418ac46:	f7fe ffb7 	bl	34189bb8 <LL_RCC_GetAPB1Prescaler>
3418ac4a:	4603      	mov	r3, r0
3418ac4c:	f003 0307 	and.w	r3, r3, #7
3418ac50:	fa24 f303 	lsr.w	r3, r4, r3
                                LL_RCC_GetAPB1Prescaler());
}
3418ac54:	4618      	mov	r0, r3
3418ac56:	bd98      	pop	{r3, r4, r7, pc}

3418ac58 <HAL_RCC_GetClockConfig>:
  * @param  pRCC_ClkInitStruct  Pointer to an RCC_ClkInitTypeDef structure that
  *         will return the configuration.
  * @retval None
  */
void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *pRCC_ClkInitStruct)
{
3418ac58:	b480      	push	{r7}
3418ac5a:	b085      	sub	sp, #20
3418ac5c:	af00      	add	r7, sp, #0
3418ac5e:	6078      	str	r0, [r7, #4]
  uint32_t cfgr_value;

  /* Set all possible values for the Clock type parameter --------------------*/
  pRCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_CPUCLK | RCC_CLOCKTYPE_SYSCLK | \
3418ac60:	687b      	ldr	r3, [r7, #4]
3418ac62:	227f      	movs	r2, #127	@ 0x7f
3418ac64:	601a      	str	r2, [r3, #0]
                                  RCC_CLOCKTYPE_HCLK   | \
                                  RCC_CLOCKTYPE_PCLK1  | RCC_CLOCKTYPE_PCLK2 | \
                                  RCC_CLOCKTYPE_PCLK4  | RCC_CLOCKTYPE_PCLK5;

  /* Get the configuration register 1 value */
  cfgr_value = RCC->CFGR1;
3418ac66:	4b36      	ldr	r3, [pc, #216]	@ (3418ad40 <HAL_RCC_GetClockConfig+0xe8>)
3418ac68:	6a1b      	ldr	r3, [r3, #32]
3418ac6a:	60fb      	str	r3, [r7, #12]

  /* Get the active CPU source -----------------------------------------------*/
  pRCC_ClkInitStruct->CPUCLKSource = (cfgr_value & RCC_CFGR1_CPUSWS) >> 4U;
3418ac6c:	68fb      	ldr	r3, [r7, #12]
3418ac6e:	091b      	lsrs	r3, r3, #4
3418ac70:	f403 3240 	and.w	r2, r3, #196608	@ 0x30000
3418ac74:	687b      	ldr	r3, [r7, #4]
3418ac76:	605a      	str	r2, [r3, #4]

  /* Get the active SYSCLK bus source ----------------------------------------*/
  pRCC_ClkInitStruct->SYSCLKSource = (cfgr_value & RCC_CFGR1_SYSSWS) >> 4U;
3418ac78:	68fb      	ldr	r3, [r7, #12]
3418ac7a:	091b      	lsrs	r3, r3, #4
3418ac7c:	f003 7240 	and.w	r2, r3, #50331648	@ 0x3000000
3418ac80:	687b      	ldr	r3, [r7, #4]
3418ac82:	609a      	str	r2, [r3, #8]

  /* Get the configuration register 2 value */
  cfgr_value = RCC->CFGR2;
3418ac84:	4b2e      	ldr	r3, [pc, #184]	@ (3418ad40 <HAL_RCC_GetClockConfig+0xe8>)
3418ac86:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418ac88:	60fb      	str	r3, [r7, #12]

  /* Get the HCLK configuration ----------------------------------------------*/
  pRCC_ClkInitStruct->AHBCLKDivider = (cfgr_value & RCC_CFGR2_HPRE);
3418ac8a:	68fb      	ldr	r3, [r7, #12]
3418ac8c:	f403 02e0 	and.w	r2, r3, #7340032	@ 0x700000
3418ac90:	687b      	ldr	r3, [r7, #4]
3418ac92:	60da      	str	r2, [r3, #12]

  /* Get the APB1 configuration ----------------------------------------------*/
  pRCC_ClkInitStruct->APB1CLKDivider = (cfgr_value & RCC_CFGR2_PPRE1);
3418ac94:	68fb      	ldr	r3, [r7, #12]
3418ac96:	f003 0207 	and.w	r2, r3, #7
3418ac9a:	687b      	ldr	r3, [r7, #4]
3418ac9c:	611a      	str	r2, [r3, #16]

  /* Get the APB2 configuration ----------------------------------------------*/
  pRCC_ClkInitStruct->APB2CLKDivider = (cfgr_value & RCC_CFGR2_PPRE2);
3418ac9e:	68fb      	ldr	r3, [r7, #12]
3418aca0:	f003 0270 	and.w	r2, r3, #112	@ 0x70
3418aca4:	687b      	ldr	r3, [r7, #4]
3418aca6:	615a      	str	r2, [r3, #20]

  /* Get the APB4 configuration ----------------------------------------------*/
  pRCC_ClkInitStruct->APB4CLKDivider = (cfgr_value & RCC_CFGR2_PPRE4);
3418aca8:	68fb      	ldr	r3, [r7, #12]
3418acaa:	f403 42e0 	and.w	r2, r3, #28672	@ 0x7000
3418acae:	687b      	ldr	r3, [r7, #4]
3418acb0:	619a      	str	r2, [r3, #24]

  /* Get the APB5 configuration ----------------------------------------------*/
  pRCC_ClkInitStruct->APB5CLKDivider = (cfgr_value & RCC_CFGR2_PPRE5);
3418acb2:	68fb      	ldr	r3, [r7, #12]
3418acb4:	f403 22e0 	and.w	r2, r3, #458752	@ 0x70000
3418acb8:	687b      	ldr	r3, [r7, #4]
3418acba:	61da      	str	r2, [r3, #28]

  /* Get the IC1 configuration -----------------------------------------------*/
  cfgr_value = RCC->IC1CFGR;
3418acbc:	4b20      	ldr	r3, [pc, #128]	@ (3418ad40 <HAL_RCC_GetClockConfig+0xe8>)
3418acbe:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
3418acc2:	60fb      	str	r3, [r7, #12]
  pRCC_ClkInitStruct->IC1Selection.ClockSelection = cfgr_value & RCC_IC1CFGR_IC1SEL;
3418acc4:	68fb      	ldr	r3, [r7, #12]
3418acc6:	f003 5240 	and.w	r2, r3, #805306368	@ 0x30000000
3418acca:	687b      	ldr	r3, [r7, #4]
3418accc:	621a      	str	r2, [r3, #32]
  pRCC_ClkInitStruct->IC1Selection.ClockDivider = ((cfgr_value & RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1U;
3418acce:	68fb      	ldr	r3, [r7, #12]
3418acd0:	0c1b      	lsrs	r3, r3, #16
3418acd2:	b2db      	uxtb	r3, r3
3418acd4:	1c5a      	adds	r2, r3, #1
3418acd6:	687b      	ldr	r3, [r7, #4]
3418acd8:	625a      	str	r2, [r3, #36]	@ 0x24

  /* Get the IC2 configuration -----------------------------------------------*/
  cfgr_value = RCC->IC2CFGR;
3418acda:	4b19      	ldr	r3, [pc, #100]	@ (3418ad40 <HAL_RCC_GetClockConfig+0xe8>)
3418acdc:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
3418ace0:	60fb      	str	r3, [r7, #12]
  pRCC_ClkInitStruct->IC2Selection.ClockSelection = cfgr_value & RCC_IC2CFGR_IC2SEL;
3418ace2:	68fb      	ldr	r3, [r7, #12]
3418ace4:	f003 5240 	and.w	r2, r3, #805306368	@ 0x30000000
3418ace8:	687b      	ldr	r3, [r7, #4]
3418acea:	629a      	str	r2, [r3, #40]	@ 0x28
  pRCC_ClkInitStruct->IC2Selection.ClockDivider = ((cfgr_value & RCC_IC2CFGR_IC2INT) >> RCC_IC2CFGR_IC2INT_Pos) + 1U;
3418acec:	68fb      	ldr	r3, [r7, #12]
3418acee:	0c1b      	lsrs	r3, r3, #16
3418acf0:	b2db      	uxtb	r3, r3
3418acf2:	1c5a      	adds	r2, r3, #1
3418acf4:	687b      	ldr	r3, [r7, #4]
3418acf6:	62da      	str	r2, [r3, #44]	@ 0x2c

  /* Get the IC6 configuration -----------------------------------------------*/
  cfgr_value = RCC->IC6CFGR;
3418acf8:	4b11      	ldr	r3, [pc, #68]	@ (3418ad40 <HAL_RCC_GetClockConfig+0xe8>)
3418acfa:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
3418acfe:	60fb      	str	r3, [r7, #12]
  pRCC_ClkInitStruct->IC6Selection.ClockSelection = cfgr_value & RCC_IC6CFGR_IC6SEL;
3418ad00:	68fb      	ldr	r3, [r7, #12]
3418ad02:	f003 5240 	and.w	r2, r3, #805306368	@ 0x30000000
3418ad06:	687b      	ldr	r3, [r7, #4]
3418ad08:	631a      	str	r2, [r3, #48]	@ 0x30
  pRCC_ClkInitStruct->IC6Selection.ClockDivider = ((cfgr_value & RCC_IC6CFGR_IC6INT) >> RCC_IC6CFGR_IC6INT_Pos) + 1U;
3418ad0a:	68fb      	ldr	r3, [r7, #12]
3418ad0c:	0c1b      	lsrs	r3, r3, #16
3418ad0e:	b2db      	uxtb	r3, r3
3418ad10:	1c5a      	adds	r2, r3, #1
3418ad12:	687b      	ldr	r3, [r7, #4]
3418ad14:	635a      	str	r2, [r3, #52]	@ 0x34

  /* Get the IC11 configuration ----------------------------------------------*/
  cfgr_value = RCC->IC11CFGR;
3418ad16:	4b0a      	ldr	r3, [pc, #40]	@ (3418ad40 <HAL_RCC_GetClockConfig+0xe8>)
3418ad18:	f8d3 30ec 	ldr.w	r3, [r3, #236]	@ 0xec
3418ad1c:	60fb      	str	r3, [r7, #12]
  pRCC_ClkInitStruct->IC11Selection.ClockSelection = cfgr_value & RCC_IC11CFGR_IC11SEL;
3418ad1e:	68fb      	ldr	r3, [r7, #12]
3418ad20:	f003 5240 	and.w	r2, r3, #805306368	@ 0x30000000
3418ad24:	687b      	ldr	r3, [r7, #4]
3418ad26:	639a      	str	r2, [r3, #56]	@ 0x38
  pRCC_ClkInitStruct->IC11Selection.ClockDivider = ((cfgr_value & RCC_IC11CFGR_IC11INT) >> RCC_IC11CFGR_IC11INT_Pos) + 1U;
3418ad28:	68fb      	ldr	r3, [r7, #12]
3418ad2a:	0c1b      	lsrs	r3, r3, #16
3418ad2c:	b2db      	uxtb	r3, r3
3418ad2e:	1c5a      	adds	r2, r3, #1
3418ad30:	687b      	ldr	r3, [r7, #4]
3418ad32:	63da      	str	r2, [r3, #60]	@ 0x3c
}
3418ad34:	bf00      	nop
3418ad36:	3714      	adds	r7, #20
3418ad38:	46bd      	mov	sp, r7
3418ad3a:	f85d 7b04 	ldr.w	r7, [sp], #4
3418ad3e:	4770      	bx	lr
3418ad40:	56028000 	.word	0x56028000

3418ad44 <RCC_PLL_Config>:
  * @note   PLL is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_PLL_Config(uint32_t PLLnumber, const RCC_PLLInitTypeDef *pPLLInit)
{
3418ad44:	b580      	push	{r7, lr}
3418ad46:	b088      	sub	sp, #32
3418ad48:	af00      	add	r7, sp, #0
3418ad4a:	6078      	str	r0, [r7, #4]
3418ad4c:	6039      	str	r1, [r7, #0]
  __IO uint32_t *p_rcc_pll_cfgr1_reg;
  __IO uint32_t *p_rcc_pll_cfgr2_reg;
  __IO uint32_t *p_rcc_pll_cfgr3_reg;
  HAL_StatusTypeDef ret = HAL_OK;
3418ad4e:	2300      	movs	r3, #0
3418ad50:	77fb      	strb	r3, [r7, #31]
  uint32_t tickstart;

  p_rcc_pll_cfgr1_reg = &(RCC->PLL1CFGR1) + (((uint32_t)0x4) * PLLnumber);
3418ad52:	687b      	ldr	r3, [r7, #4]
3418ad54:	011a      	lsls	r2, r3, #4
3418ad56:	4b8e      	ldr	r3, [pc, #568]	@ (3418af90 <RCC_PLL_Config+0x24c>)
3418ad58:	4413      	add	r3, r2
3418ad5a:	61bb      	str	r3, [r7, #24]
  p_rcc_pll_cfgr2_reg = &(RCC->PLL1CFGR2) + (((uint32_t)0x4) * PLLnumber);
3418ad5c:	687b      	ldr	r3, [r7, #4]
3418ad5e:	011a      	lsls	r2, r3, #4
3418ad60:	4b8c      	ldr	r3, [pc, #560]	@ (3418af94 <RCC_PLL_Config+0x250>)
3418ad62:	4413      	add	r3, r2
3418ad64:	617b      	str	r3, [r7, #20]
  p_rcc_pll_cfgr3_reg = &(RCC->PLL1CFGR3) + (((uint32_t)0x4) * PLLnumber);
3418ad66:	687b      	ldr	r3, [r7, #4]
3418ad68:	011a      	lsls	r2, r3, #4
3418ad6a:	4b8b      	ldr	r3, [pc, #556]	@ (3418af98 <RCC_PLL_Config+0x254>)
3418ad6c:	4413      	add	r3, r2
3418ad6e:	613b      	str	r3, [r7, #16]

  /* !!! WARNING: ONLY INTEGER AND FRACTIONAL MODES MANAGED TODAY !!! */
  if (pPLLInit->PLLState == RCC_PLL_ON)
3418ad70:	683b      	ldr	r3, [r7, #0]
3418ad72:	681b      	ldr	r3, [r3, #0]
3418ad74:	2b02      	cmp	r3, #2
3418ad76:	f040 8091 	bne.w	3418ae9c <RCC_PLL_Config+0x158>
    assert_param(IS_RCC_PLLN_VALUE(pPLLInit->PLLN));
    assert_param(IS_RCC_PLLP_VALUE(pPLLInit->PLLP1));
    assert_param(IS_RCC_PLLP_VALUE(pPLLInit->PLLP2));

    /* Ensure PLLx is disabled */
    WRITE_REG(RCC->CCR, RCC_CCR_PLL1ONC << PLLnumber);
3418ad7a:	4a88      	ldr	r2, [pc, #544]	@ (3418af9c <RCC_PLL_Config+0x258>)
3418ad7c:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418ad80:	687b      	ldr	r3, [r7, #4]
3418ad82:	fa01 f303 	lsl.w	r3, r1, r3
3418ad86:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
3418ad8a:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
3418ad8c:	f7fa fc14 	bl	341855b8 <HAL_GetTick>
3418ad90:	60f8      	str	r0, [r7, #12]

    /* Wait till PLLx is disabled */
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
3418ad92:	e008      	b.n	3418ada6 <RCC_PLL_Config+0x62>
    {
      if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
3418ad94:	f7fa fc10 	bl	341855b8 <HAL_GetTick>
3418ad98:	4602      	mov	r2, r0
3418ad9a:	68fb      	ldr	r3, [r7, #12]
3418ad9c:	1ad3      	subs	r3, r2, r3
3418ad9e:	2b01      	cmp	r3, #1
3418ada0:	d901      	bls.n	3418ada6 <RCC_PLL_Config+0x62>
      {
        return HAL_TIMEOUT;
3418ada2:	2303      	movs	r3, #3
3418ada4:	e0f0      	b.n	3418af88 <RCC_PLL_Config+0x244>
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
3418ada6:	4b7d      	ldr	r3, [pc, #500]	@ (3418af9c <RCC_PLL_Config+0x258>)
3418ada8:	685a      	ldr	r2, [r3, #4]
3418adaa:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418adae:	687b      	ldr	r3, [r7, #4]
3418adb0:	fa01 f303 	lsl.w	r3, r1, r3
3418adb4:	401a      	ands	r2, r3
3418adb6:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418adba:	687b      	ldr	r3, [r7, #4]
3418adbc:	fa01 f303 	lsl.w	r3, r1, r3
3418adc0:	429a      	cmp	r2, r3
3418adc2:	d0e7      	beq.n	3418ad94 <RCC_PLL_Config+0x50>
      }
    }

    /* Ensure PLLxMODSSDIS='1' */
    SET_BIT(*p_rcc_pll_cfgr3_reg, RCC_PLL1CFGR3_PLL1MODSSDIS);
3418adc4:	693b      	ldr	r3, [r7, #16]
3418adc6:	681b      	ldr	r3, [r3, #0]
3418adc8:	f043 0204 	orr.w	r2, r3, #4
3418adcc:	693b      	ldr	r3, [r7, #16]
3418adce:	601a      	str	r2, [r3, #0]

    /* Clear bypass mode */
    CLEAR_BIT(*p_rcc_pll_cfgr1_reg, RCC_PLL1CFGR1_PLL1BYP);
3418add0:	69bb      	ldr	r3, [r7, #24]
3418add2:	681b      	ldr	r3, [r3, #0]
3418add4:	f023 6200 	bic.w	r2, r3, #134217728	@ 0x8000000
3418add8:	69bb      	ldr	r3, [r7, #24]
3418adda:	601a      	str	r2, [r3, #0]

    /* Configure the PLLx clock source, multiplication and division factors. */
    MODIFY_REG(*p_rcc_pll_cfgr1_reg, (RCC_PLL1CFGR1_PLL1SEL | RCC_PLL1CFGR1_PLL1DIVM | RCC_PLL1CFGR1_PLL1DIVN), \
3418addc:	69bb      	ldr	r3, [r7, #24]
3418adde:	681a      	ldr	r2, [r3, #0]
3418ade0:	4b6f      	ldr	r3, [pc, #444]	@ (3418afa0 <RCC_PLL_Config+0x25c>)
3418ade2:	4013      	ands	r3, r2
3418ade4:	683a      	ldr	r2, [r7, #0]
3418ade6:	6851      	ldr	r1, [r2, #4]
3418ade8:	683a      	ldr	r2, [r7, #0]
3418adea:	6892      	ldr	r2, [r2, #8]
3418adec:	0512      	lsls	r2, r2, #20
3418adee:	4311      	orrs	r1, r2
3418adf0:	683a      	ldr	r2, [r7, #0]
3418adf2:	6912      	ldr	r2, [r2, #16]
3418adf4:	0212      	lsls	r2, r2, #8
3418adf6:	430a      	orrs	r2, r1
3418adf8:	431a      	orrs	r2, r3
3418adfa:	69bb      	ldr	r3, [r7, #24]
3418adfc:	601a      	str	r2, [r3, #0]
               (pPLLInit->PLLSource | (pPLLInit->PLLM << RCC_PLL1CFGR1_PLL1DIVM_Pos) \
                | (pPLLInit->PLLN << RCC_PLL1CFGR1_PLL1DIVN_Pos)));
    MODIFY_REG(*p_rcc_pll_cfgr3_reg, (RCC_PLL1CFGR3_PLL1PDIV1 | RCC_PLL1CFGR3_PLL1PDIV2), \
3418adfe:	693b      	ldr	r3, [r7, #16]
3418ae00:	681b      	ldr	r3, [r3, #0]
3418ae02:	f023 527c 	bic.w	r2, r3, #1056964608	@ 0x3f000000
3418ae06:	683b      	ldr	r3, [r7, #0]
3418ae08:	695b      	ldr	r3, [r3, #20]
3418ae0a:	06d9      	lsls	r1, r3, #27
3418ae0c:	683b      	ldr	r3, [r7, #0]
3418ae0e:	699b      	ldr	r3, [r3, #24]
3418ae10:	061b      	lsls	r3, r3, #24
3418ae12:	430b      	orrs	r3, r1
3418ae14:	431a      	orrs	r2, r3
3418ae16:	693b      	ldr	r3, [r7, #16]
3418ae18:	601a      	str	r2, [r3, #0]
               ((pPLLInit->PLLP1 << RCC_PLL1CFGR3_PLL1PDIV1_Pos) | (pPLLInit->PLLP2 << RCC_PLL1CFGR3_PLL1PDIV2_Pos)));

    /* Configure PLLx DIVNFRAC */
    MODIFY_REG(*p_rcc_pll_cfgr2_reg, RCC_PLL1CFGR2_PLL1DIVNFRAC, \
3418ae1a:	697b      	ldr	r3, [r7, #20]
3418ae1c:	681b      	ldr	r3, [r3, #0]
3418ae1e:	f003 427f 	and.w	r2, r3, #4278190080	@ 0xff000000
3418ae22:	683b      	ldr	r3, [r7, #0]
3418ae24:	68db      	ldr	r3, [r3, #12]
3418ae26:	431a      	orrs	r2, r3
3418ae28:	697b      	ldr	r3, [r7, #20]
3418ae2a:	601a      	str	r2, [r3, #0]
               pPLLInit->PLLFractional << RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos);

    /* Clear PLLxMODDSEN (Also clear in Fractional Mode to ensure the latch of updated FRAC value when set again) */
    CLEAR_BIT(*p_rcc_pll_cfgr3_reg, RCC_PLL1CFGR3_PLL1MODDSEN);
3418ae2c:	693b      	ldr	r3, [r7, #16]
3418ae2e:	681b      	ldr	r3, [r3, #0]
3418ae30:	f023 0208 	bic.w	r2, r3, #8
3418ae34:	693b      	ldr	r3, [r7, #16]
3418ae36:	601a      	str	r2, [r3, #0]

    /* Fractional Mode specificities Management */
    if (pPLLInit->PLLFractional != 0U)
3418ae38:	683b      	ldr	r3, [r7, #0]
3418ae3a:	68db      	ldr	r3, [r3, #12]
3418ae3c:	2b00      	cmp	r3, #0
3418ae3e:	d005      	beq.n	3418ae4c <RCC_PLL_Config+0x108>
    {
      /* Set PLLxMODDSEN and DACEN */
      SET_BIT(*p_rcc_pll_cfgr3_reg, (RCC_PLL1CFGR3_PLL1MODDSEN | RCC_PLL1CFGR3_PLL1DACEN));
3418ae40:	693b      	ldr	r3, [r7, #16]
3418ae42:	681b      	ldr	r3, [r3, #0]
3418ae44:	f043 020a 	orr.w	r2, r3, #10
3418ae48:	693b      	ldr	r3, [r7, #16]
3418ae4a:	601a      	str	r2, [r3, #0]
    }

    /* Ensure PLLxMODSSRST='1' and Enable PLLx post divider output */
    SET_BIT(*p_rcc_pll_cfgr3_reg, (RCC_PLL1CFGR3_PLL1MODSSRST | RCC_PLL1CFGR3_PLL1PDIVEN));
3418ae4c:	693b      	ldr	r3, [r7, #16]
3418ae4e:	681b      	ldr	r3, [r3, #0]
3418ae50:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
3418ae54:	f043 0301 	orr.w	r3, r3, #1
3418ae58:	693a      	ldr	r2, [r7, #16]
3418ae5a:	6013      	str	r3, [r2, #0]

    /* Enable the PLLx */
    WRITE_REG(RCC->CSR, RCC_CSR_PLL1ONS << PLLnumber);
3418ae5c:	4a4f      	ldr	r2, [pc, #316]	@ (3418af9c <RCC_PLL_Config+0x258>)
3418ae5e:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418ae62:	687b      	ldr	r3, [r7, #4]
3418ae64:	fa01 f303 	lsl.w	r3, r1, r3
3418ae68:	f8c2 3800 	str.w	r3, [r2, #2048]	@ 0x800

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
3418ae6c:	f7fa fba4 	bl	341855b8 <HAL_GetTick>
3418ae70:	60f8      	str	r0, [r7, #12]

    /* Wait till PLLx is ready */
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == 0U)
3418ae72:	e008      	b.n	3418ae86 <RCC_PLL_Config+0x142>
    {
      if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
3418ae74:	f7fa fba0 	bl	341855b8 <HAL_GetTick>
3418ae78:	4602      	mov	r2, r0
3418ae7a:	68fb      	ldr	r3, [r7, #12]
3418ae7c:	1ad3      	subs	r3, r2, r3
3418ae7e:	2b01      	cmp	r3, #1
3418ae80:	d901      	bls.n	3418ae86 <RCC_PLL_Config+0x142>
      {
        return HAL_TIMEOUT;
3418ae82:	2303      	movs	r3, #3
3418ae84:	e080      	b.n	3418af88 <RCC_PLL_Config+0x244>
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == 0U)
3418ae86:	4b45      	ldr	r3, [pc, #276]	@ (3418af9c <RCC_PLL_Config+0x258>)
3418ae88:	685a      	ldr	r2, [r3, #4]
3418ae8a:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418ae8e:	687b      	ldr	r3, [r7, #4]
3418ae90:	fa01 f303 	lsl.w	r3, r1, r3
3418ae94:	4013      	ands	r3, r2
3418ae96:	2b00      	cmp	r3, #0
3418ae98:	d0ec      	beq.n	3418ae74 <RCC_PLL_Config+0x130>
3418ae9a:	e074      	b.n	3418af86 <RCC_PLL_Config+0x242>
      }
    }
  }
  else if (pPLLInit->PLLState == RCC_PLL_BYPASS)
3418ae9c:	683b      	ldr	r3, [r7, #0]
3418ae9e:	681b      	ldr	r3, [r3, #0]
3418aea0:	2b03      	cmp	r3, #3
3418aea2:	d13b      	bne.n	3418af1c <RCC_PLL_Config+0x1d8>
  {
    assert_param(IS_RCC_PLLSOURCE(pPLLInit->PLLSource));

    /* Check selected source is ready */
    if (RCC_PLL_Source_IsReady(pPLLInit->PLLSource) == 1U)
3418aea4:	683b      	ldr	r3, [r7, #0]
3418aea6:	685b      	ldr	r3, [r3, #4]
3418aea8:	4618      	mov	r0, r3
3418aeaa:	f000 f921 	bl	3418b0f0 <RCC_PLL_Source_IsReady>
3418aeae:	4603      	mov	r3, r0
3418aeb0:	2b01      	cmp	r3, #1
3418aeb2:	d130      	bne.n	3418af16 <RCC_PLL_Config+0x1d2>
    {
      /* Ensure PLLx is disabled */
      WRITE_REG(RCC->CCR, RCC_CCR_PLL1ONC << PLLnumber);
3418aeb4:	4a39      	ldr	r2, [pc, #228]	@ (3418af9c <RCC_PLL_Config+0x258>)
3418aeb6:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418aeba:	687b      	ldr	r3, [r7, #4]
3418aebc:	fa01 f303 	lsl.w	r3, r1, r3
3418aec0:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
3418aec4:	6013      	str	r3, [r2, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
3418aec6:	f7fa fb77 	bl	341855b8 <HAL_GetTick>
3418aeca:	60f8      	str	r0, [r7, #12]

      /* Wait till PLLx is disabled */
      while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
3418aecc:	e008      	b.n	3418aee0 <RCC_PLL_Config+0x19c>
      {
        if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
3418aece:	f7fa fb73 	bl	341855b8 <HAL_GetTick>
3418aed2:	4602      	mov	r2, r0
3418aed4:	68fb      	ldr	r3, [r7, #12]
3418aed6:	1ad3      	subs	r3, r2, r3
3418aed8:	2b01      	cmp	r3, #1
3418aeda:	d901      	bls.n	3418aee0 <RCC_PLL_Config+0x19c>
        {
          return HAL_TIMEOUT;
3418aedc:	2303      	movs	r3, #3
3418aede:	e053      	b.n	3418af88 <RCC_PLL_Config+0x244>
      while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
3418aee0:	4b2e      	ldr	r3, [pc, #184]	@ (3418af9c <RCC_PLL_Config+0x258>)
3418aee2:	685a      	ldr	r2, [r3, #4]
3418aee4:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418aee8:	687b      	ldr	r3, [r7, #4]
3418aeea:	fa01 f303 	lsl.w	r3, r1, r3
3418aeee:	401a      	ands	r2, r3
3418aef0:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418aef4:	687b      	ldr	r3, [r7, #4]
3418aef6:	fa01 f303 	lsl.w	r3, r1, r3
3418aefa:	429a      	cmp	r2, r3
3418aefc:	d0e7      	beq.n	3418aece <RCC_PLL_Config+0x18a>
        }
      }

      /* Set bypass mode with selected source */
      MODIFY_REG(*p_rcc_pll_cfgr1_reg, (RCC_PLL1CFGR1_PLL1BYP | RCC_PLL1CFGR1_PLL1SEL), \
3418aefe:	69bb      	ldr	r3, [r7, #24]
3418af00:	681b      	ldr	r3, [r3, #0]
3418af02:	f023 42f0 	bic.w	r2, r3, #2013265920	@ 0x78000000
3418af06:	683b      	ldr	r3, [r7, #0]
3418af08:	685b      	ldr	r3, [r3, #4]
3418af0a:	4313      	orrs	r3, r2
3418af0c:	f043 6200 	orr.w	r2, r3, #134217728	@ 0x8000000
3418af10:	69bb      	ldr	r3, [r7, #24]
3418af12:	601a      	str	r2, [r3, #0]
3418af14:	e037      	b.n	3418af86 <RCC_PLL_Config+0x242>
                 (RCC_PLL1CFGR1_PLL1BYP | pPLLInit->PLLSource));
    }
    else
    {
      ret = HAL_ERROR;
3418af16:	2301      	movs	r3, #1
3418af18:	77fb      	strb	r3, [r7, #31]
3418af1a:	e034      	b.n	3418af86 <RCC_PLL_Config+0x242>
    }
  }
  else if (pPLLInit->PLLState == RCC_PLL_OFF)
3418af1c:	683b      	ldr	r3, [r7, #0]
3418af1e:	681b      	ldr	r3, [r3, #0]
3418af20:	2b01      	cmp	r3, #1
3418af22:	d130      	bne.n	3418af86 <RCC_PLL_Config+0x242>
  {
    /* Disable PLLx post divider output */
    CLEAR_BIT(*p_rcc_pll_cfgr3_reg, RCC_PLL1CFGR3_PLL1PDIVEN);
3418af24:	693b      	ldr	r3, [r7, #16]
3418af26:	681b      	ldr	r3, [r3, #0]
3418af28:	f023 4280 	bic.w	r2, r3, #1073741824	@ 0x40000000
3418af2c:	693b      	ldr	r3, [r7, #16]
3418af2e:	601a      	str	r2, [r3, #0]

    /* Ensure PLLx is disabled */
    WRITE_REG(RCC->CCR, RCC_CCR_PLL1ONC << PLLnumber);
3418af30:	4a1a      	ldr	r2, [pc, #104]	@ (3418af9c <RCC_PLL_Config+0x258>)
3418af32:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418af36:	687b      	ldr	r3, [r7, #4]
3418af38:	fa01 f303 	lsl.w	r3, r1, r3
3418af3c:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
3418af40:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
3418af42:	f7fa fb39 	bl	341855b8 <HAL_GetTick>
3418af46:	60f8      	str	r0, [r7, #12]

    /* Wait till PLLx is disabled */
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
3418af48:	e008      	b.n	3418af5c <RCC_PLL_Config+0x218>
    {
      if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
3418af4a:	f7fa fb35 	bl	341855b8 <HAL_GetTick>
3418af4e:	4602      	mov	r2, r0
3418af50:	68fb      	ldr	r3, [r7, #12]
3418af52:	1ad3      	subs	r3, r2, r3
3418af54:	2b01      	cmp	r3, #1
3418af56:	d901      	bls.n	3418af5c <RCC_PLL_Config+0x218>
      {
        return HAL_TIMEOUT;
3418af58:	2303      	movs	r3, #3
3418af5a:	e015      	b.n	3418af88 <RCC_PLL_Config+0x244>
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
3418af5c:	4b0f      	ldr	r3, [pc, #60]	@ (3418af9c <RCC_PLL_Config+0x258>)
3418af5e:	685a      	ldr	r2, [r3, #4]
3418af60:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418af64:	687b      	ldr	r3, [r7, #4]
3418af66:	fa01 f303 	lsl.w	r3, r1, r3
3418af6a:	401a      	ands	r2, r3
3418af6c:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418af70:	687b      	ldr	r3, [r7, #4]
3418af72:	fa01 f303 	lsl.w	r3, r1, r3
3418af76:	429a      	cmp	r2, r3
3418af78:	d0e7      	beq.n	3418af4a <RCC_PLL_Config+0x206>
      }
    }

    /* Clear bypass mode */
    CLEAR_BIT(*p_rcc_pll_cfgr1_reg, RCC_PLL1CFGR1_PLL1BYP);
3418af7a:	69bb      	ldr	r3, [r7, #24]
3418af7c:	681b      	ldr	r3, [r3, #0]
3418af7e:	f023 6200 	bic.w	r2, r3, #134217728	@ 0x8000000
3418af82:	69bb      	ldr	r3, [r7, #24]
3418af84:	601a      	str	r2, [r3, #0]
  else
  {
    /* Nothing to do */
  }

  return ret;
3418af86:	7ffb      	ldrb	r3, [r7, #31]
}
3418af88:	4618      	mov	r0, r3
3418af8a:	3720      	adds	r7, #32
3418af8c:	46bd      	mov	sp, r7
3418af8e:	bd80      	pop	{r7, pc}
3418af90:	56028080 	.word	0x56028080
3418af94:	56028084 	.word	0x56028084
3418af98:	56028088 	.word	0x56028088
3418af9c:	56028000 	.word	0x56028000
3418afa0:	8c0000ff 	.word	0x8c0000ff

3418afa4 <RCC_PLL_Enable>:
  * @param  PLLnumber PLL number to enable
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_PLL_Enable(uint32_t PLLnumber)
{
3418afa4:	b580      	push	{r7, lr}
3418afa6:	b084      	sub	sp, #16
3418afa8:	af00      	add	r7, sp, #0
3418afaa:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef ret = HAL_OK;
3418afac:	2300      	movs	r3, #0
3418afae:	73fb      	strb	r3, [r7, #15]
  uint32_t tickstart;

  /* Enable the PLLx */
  WRITE_REG(RCC->CSR, RCC_CSR_PLL1ONS << PLLnumber);
3418afb0:	4a11      	ldr	r2, [pc, #68]	@ (3418aff8 <RCC_PLL_Enable+0x54>)
3418afb2:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418afb6:	687b      	ldr	r3, [r7, #4]
3418afb8:	fa01 f303 	lsl.w	r3, r1, r3
3418afbc:	f8c2 3800 	str.w	r3, [r2, #2048]	@ 0x800

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
3418afc0:	f7fa fafa 	bl	341855b8 <HAL_GetTick>
3418afc4:	60b8      	str	r0, [r7, #8]

  /* Wait till PLLx is ready */
  while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == 0U)
3418afc6:	e008      	b.n	3418afda <RCC_PLL_Enable+0x36>
  {
    if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
3418afc8:	f7fa faf6 	bl	341855b8 <HAL_GetTick>
3418afcc:	4602      	mov	r2, r0
3418afce:	68bb      	ldr	r3, [r7, #8]
3418afd0:	1ad3      	subs	r3, r2, r3
3418afd2:	2b01      	cmp	r3, #1
3418afd4:	d901      	bls.n	3418afda <RCC_PLL_Enable+0x36>
    {
      return HAL_TIMEOUT;
3418afd6:	2303      	movs	r3, #3
3418afd8:	e00a      	b.n	3418aff0 <RCC_PLL_Enable+0x4c>
  while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == 0U)
3418afda:	4b07      	ldr	r3, [pc, #28]	@ (3418aff8 <RCC_PLL_Enable+0x54>)
3418afdc:	685a      	ldr	r2, [r3, #4]
3418afde:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418afe2:	687b      	ldr	r3, [r7, #4]
3418afe4:	fa01 f303 	lsl.w	r3, r1, r3
3418afe8:	4013      	ands	r3, r2
3418afea:	2b00      	cmp	r3, #0
3418afec:	d0ec      	beq.n	3418afc8 <RCC_PLL_Enable+0x24>
    }
  }

  return ret;
3418afee:	7bfb      	ldrb	r3, [r7, #15]
}
3418aff0:	4618      	mov	r0, r3
3418aff2:	3710      	adds	r7, #16
3418aff4:	46bd      	mov	sp, r7
3418aff6:	bd80      	pop	{r7, pc}
3418aff8:	56028000 	.word	0x56028000

3418affc <RCC_PLL_IsNewConfig>:
  * @param  pPLLInit Pointer to an RCC_PLLInitTypeDef structure that
  *                  contains the configuration parameters.  *
  * @retval 1 if success else 0
  */
static uint32_t RCC_PLL_IsNewConfig(uint32_t PLLnumber, const RCC_PLLInitTypeDef *pPLLInit)
{
3418affc:	b480      	push	{r7}
3418affe:	b089      	sub	sp, #36	@ 0x24
3418b000:	af00      	add	r7, sp, #0
3418b002:	6078      	str	r0, [r7, #4]
3418b004:	6039      	str	r1, [r7, #0]
  __IO const uint32_t *p_rcc_pll_cfgr1_reg, *p_rcc_pll_cfgr2_reg, *p_rcc_pll_cfgr3_reg;
  uint32_t ret = 0U;
3418b006:	2300      	movs	r3, #0
3418b008:	61fb      	str	r3, [r7, #28]

  /* No assert since done in calling function */

  p_rcc_pll_cfgr1_reg = &(RCC->PLL1CFGR1) + (((uint32_t)0x4) * PLLnumber);
3418b00a:	687b      	ldr	r3, [r7, #4]
3418b00c:	011a      	lsls	r2, r3, #4
3418b00e:	4b34      	ldr	r3, [pc, #208]	@ (3418b0e0 <RCC_PLL_IsNewConfig+0xe4>)
3418b010:	4413      	add	r3, r2
3418b012:	617b      	str	r3, [r7, #20]
  p_rcc_pll_cfgr2_reg = &(RCC->PLL1CFGR2) + (((uint32_t)0x4) * PLLnumber);
3418b014:	687b      	ldr	r3, [r7, #4]
3418b016:	011a      	lsls	r2, r3, #4
3418b018:	4b32      	ldr	r3, [pc, #200]	@ (3418b0e4 <RCC_PLL_IsNewConfig+0xe8>)
3418b01a:	4413      	add	r3, r2
3418b01c:	613b      	str	r3, [r7, #16]
  p_rcc_pll_cfgr3_reg = &(RCC->PLL1CFGR3) + (((uint32_t)0x4) * PLLnumber);
3418b01e:	687b      	ldr	r3, [r7, #4]
3418b020:	011a      	lsls	r2, r3, #4
3418b022:	4b31      	ldr	r3, [pc, #196]	@ (3418b0e8 <RCC_PLL_IsNewConfig+0xec>)
3418b024:	4413      	add	r3, r2
3418b026:	60fb      	str	r3, [r7, #12]

  /* !!! WARNING: ONLY INTEGER AND FRACTIONAL MODES MANAGED TODAY !!! */

  /* Check for PLLCFGR1, PLLCFGR2 and PLLCFGR3 parameters updates */
  if ((*p_rcc_pll_cfgr1_reg & (RCC_PLL1CFGR1_PLL1SEL | RCC_PLL1CFGR1_PLL1DIVM | RCC_PLL1CFGR1_PLL1DIVN)) != \
3418b028:	697b      	ldr	r3, [r7, #20]
3418b02a:	681b      	ldr	r3, [r3, #0]
3418b02c:	f023 430c 	bic.w	r3, r3, #2348810240	@ 0x8c000000
3418b030:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
      (pPLLInit->PLLSource | (pPLLInit->PLLM << RCC_PLL1CFGR1_PLL1DIVM_Pos) \
3418b034:	683a      	ldr	r2, [r7, #0]
3418b036:	6851      	ldr	r1, [r2, #4]
3418b038:	683a      	ldr	r2, [r7, #0]
3418b03a:	6892      	ldr	r2, [r2, #8]
3418b03c:	0512      	lsls	r2, r2, #20
3418b03e:	4311      	orrs	r1, r2
       | (pPLLInit->PLLN << RCC_PLL1CFGR1_PLL1DIVN_Pos)))
3418b040:	683a      	ldr	r2, [r7, #0]
3418b042:	6912      	ldr	r2, [r2, #16]
3418b044:	0212      	lsls	r2, r2, #8
3418b046:	430a      	orrs	r2, r1
  if ((*p_rcc_pll_cfgr1_reg & (RCC_PLL1CFGR1_PLL1SEL | RCC_PLL1CFGR1_PLL1DIVM | RCC_PLL1CFGR1_PLL1DIVN)) != \
3418b048:	4293      	cmp	r3, r2
3418b04a:	d002      	beq.n	3418b052 <RCC_PLL_IsNewConfig+0x56>
  {
    ret = 1U; /* New PLL configuration */
3418b04c:	2301      	movs	r3, #1
3418b04e:	61fb      	str	r3, [r7, #28]
3418b050:	e03e      	b.n	3418b0d0 <RCC_PLL_IsNewConfig+0xd4>
  }
  else if ((*p_rcc_pll_cfgr2_reg & RCC_PLL1CFGR2_PLL1DIVNFRAC) != \
3418b052:	693b      	ldr	r3, [r7, #16]
3418b054:	681b      	ldr	r3, [r3, #0]
3418b056:	f023 427f 	bic.w	r2, r3, #4278190080	@ 0xff000000
           (pPLLInit->PLLFractional << RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos))
3418b05a:	683b      	ldr	r3, [r7, #0]
3418b05c:	68db      	ldr	r3, [r3, #12]
  else if ((*p_rcc_pll_cfgr2_reg & RCC_PLL1CFGR2_PLL1DIVNFRAC) != \
3418b05e:	429a      	cmp	r2, r3
3418b060:	d002      	beq.n	3418b068 <RCC_PLL_IsNewConfig+0x6c>
  {
    ret = 1U; /* New PLL configuration */
3418b062:	2301      	movs	r3, #1
3418b064:	61fb      	str	r3, [r7, #28]
3418b066:	e033      	b.n	3418b0d0 <RCC_PLL_IsNewConfig+0xd4>
  }
  else if ((*p_rcc_pll_cfgr3_reg & (RCC_PLL1CFGR3_PLL1PDIV1 | RCC_PLL1CFGR3_PLL1PDIV2)) != \
3418b068:	68fb      	ldr	r3, [r7, #12]
3418b06a:	681b      	ldr	r3, [r3, #0]
3418b06c:	f003 527c 	and.w	r2, r3, #1056964608	@ 0x3f000000
           ((pPLLInit->PLLP1 << RCC_PLL1CFGR3_PLL1PDIV1_Pos) | (pPLLInit->PLLP2 << RCC_PLL1CFGR3_PLL1PDIV2_Pos)))
3418b070:	683b      	ldr	r3, [r7, #0]
3418b072:	695b      	ldr	r3, [r3, #20]
3418b074:	06d9      	lsls	r1, r3, #27
3418b076:	683b      	ldr	r3, [r7, #0]
3418b078:	699b      	ldr	r3, [r3, #24]
3418b07a:	061b      	lsls	r3, r3, #24
3418b07c:	430b      	orrs	r3, r1
  else if ((*p_rcc_pll_cfgr3_reg & (RCC_PLL1CFGR3_PLL1PDIV1 | RCC_PLL1CFGR3_PLL1PDIV2)) != \
3418b07e:	429a      	cmp	r2, r3
3418b080:	d002      	beq.n	3418b088 <RCC_PLL_IsNewConfig+0x8c>
  {
    ret = 1U; /* New PLL configuration */
3418b082:	2301      	movs	r3, #1
3418b084:	61fb      	str	r3, [r7, #28]
3418b086:	e023      	b.n	3418b0d0 <RCC_PLL_IsNewConfig+0xd4>
  {
    /* Mode change detection*/
    uint32_t pllState;

    /* Get current Mode*/
    if (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
3418b088:	4b18      	ldr	r3, [pc, #96]	@ (3418b0ec <RCC_PLL_IsNewConfig+0xf0>)
3418b08a:	685a      	ldr	r2, [r3, #4]
3418b08c:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418b090:	687b      	ldr	r3, [r7, #4]
3418b092:	fa01 f303 	lsl.w	r3, r1, r3
3418b096:	401a      	ands	r2, r3
3418b098:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418b09c:	687b      	ldr	r3, [r7, #4]
3418b09e:	fa01 f303 	lsl.w	r3, r1, r3
3418b0a2:	429a      	cmp	r2, r3
3418b0a4:	d102      	bne.n	3418b0ac <RCC_PLL_IsNewConfig+0xb0>
    {
      pllState = RCC_PLL_ON;
3418b0a6:	2302      	movs	r3, #2
3418b0a8:	61bb      	str	r3, [r7, #24]
3418b0aa:	e00a      	b.n	3418b0c2 <RCC_PLL_IsNewConfig+0xc6>
    }
    else
    {
      if ((*p_rcc_pll_cfgr1_reg & RCC_PLL1CFGR1_PLL1BYP) != 0UL)
3418b0ac:	697b      	ldr	r3, [r7, #20]
3418b0ae:	681b      	ldr	r3, [r3, #0]
3418b0b0:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3418b0b4:	2b00      	cmp	r3, #0
3418b0b6:	d002      	beq.n	3418b0be <RCC_PLL_IsNewConfig+0xc2>
      {
        pllState = RCC_PLL_BYPASS;
3418b0b8:	2303      	movs	r3, #3
3418b0ba:	61bb      	str	r3, [r7, #24]
3418b0bc:	e001      	b.n	3418b0c2 <RCC_PLL_IsNewConfig+0xc6>
      }
      else
      {
        pllState = RCC_PLL_OFF;
3418b0be:	2301      	movs	r3, #1
3418b0c0:	61bb      	str	r3, [r7, #24]
      }
    }

    /* Compare with new mode */
    if (pllState != pPLLInit->PLLState)
3418b0c2:	683b      	ldr	r3, [r7, #0]
3418b0c4:	681b      	ldr	r3, [r3, #0]
3418b0c6:	69ba      	ldr	r2, [r7, #24]
3418b0c8:	429a      	cmp	r2, r3
3418b0ca:	d001      	beq.n	3418b0d0 <RCC_PLL_IsNewConfig+0xd4>
    {
      ret = 1U; /* New PLL configuration */
3418b0cc:	2301      	movs	r3, #1
3418b0ce:	61fb      	str	r3, [r7, #28]
    }
  }

  return ret;
3418b0d0:	69fb      	ldr	r3, [r7, #28]
}
3418b0d2:	4618      	mov	r0, r3
3418b0d4:	3724      	adds	r7, #36	@ 0x24
3418b0d6:	46bd      	mov	sp, r7
3418b0d8:	f85d 7b04 	ldr.w	r7, [sp], #4
3418b0dc:	4770      	bx	lr
3418b0de:	bf00      	nop
3418b0e0:	56028080 	.word	0x56028080
3418b0e4:	56028084 	.word	0x56028084
3418b0e8:	56028088 	.word	0x56028088
3418b0ec:	56028000 	.word	0x56028000

3418b0f0 <RCC_PLL_Source_IsReady>:
  * @brief  Check whether the PLL source is ready
  * @param  PLLSource PLL source
  * @retval 1 if success else 0
  */
static uint32_t RCC_PLL_Source_IsReady(uint32_t PLLSource)
{
3418b0f0:	b580      	push	{r7, lr}
3418b0f2:	b084      	sub	sp, #16
3418b0f4:	af00      	add	r7, sp, #0
3418b0f6:	6078      	str	r0, [r7, #4]
  uint32_t ret = 1U;
3418b0f8:	2301      	movs	r3, #1
3418b0fa:	60fb      	str	r3, [r7, #12]

  /* No assert since done in calling function */

  switch (PLLSource)
3418b0fc:	687b      	ldr	r3, [r7, #4]
3418b0fe:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418b102:	d01b      	beq.n	3418b13c <RCC_PLL_Source_IsReady+0x4c>
3418b104:	687b      	ldr	r3, [r7, #4]
3418b106:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418b10a:	d81f      	bhi.n	3418b14c <RCC_PLL_Source_IsReady+0x5c>
3418b10c:	687b      	ldr	r3, [r7, #4]
3418b10e:	2b00      	cmp	r3, #0
3418b110:	d004      	beq.n	3418b11c <RCC_PLL_Source_IsReady+0x2c>
3418b112:	687b      	ldr	r3, [r7, #4]
3418b114:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3418b118:	d008      	beq.n	3418b12c <RCC_PLL_Source_IsReady+0x3c>
        ret = 0U;
      }
      break;
    case RCC_PLLSOURCE_PIN:
    default:
      break;
3418b11a:	e017      	b.n	3418b14c <RCC_PLL_Source_IsReady+0x5c>
      if (LL_RCC_HSI_IsReady() == 0U)
3418b11c:	f7fe fc32 	bl	34189984 <LL_RCC_HSI_IsReady>
3418b120:	4603      	mov	r3, r0
3418b122:	2b00      	cmp	r3, #0
3418b124:	d114      	bne.n	3418b150 <RCC_PLL_Source_IsReady+0x60>
        ret = 0U;
3418b126:	2300      	movs	r3, #0
3418b128:	60fb      	str	r3, [r7, #12]
      break;
3418b12a:	e011      	b.n	3418b150 <RCC_PLL_Source_IsReady+0x60>
      if (LL_RCC_MSI_IsReady() == 0U)
3418b12c:	f7fe fc92 	bl	34189a54 <LL_RCC_MSI_IsReady>
3418b130:	4603      	mov	r3, r0
3418b132:	2b00      	cmp	r3, #0
3418b134:	d10e      	bne.n	3418b154 <RCC_PLL_Source_IsReady+0x64>
        ret = 0U;
3418b136:	2300      	movs	r3, #0
3418b138:	60fb      	str	r3, [r7, #12]
      break;
3418b13a:	e00b      	b.n	3418b154 <RCC_PLL_Source_IsReady+0x64>
      if (LL_RCC_HSE_IsReady() == 0U)
3418b13c:	f7fe fbf2 	bl	34189924 <LL_RCC_HSE_IsReady>
3418b140:	4603      	mov	r3, r0
3418b142:	2b00      	cmp	r3, #0
3418b144:	d108      	bne.n	3418b158 <RCC_PLL_Source_IsReady+0x68>
        ret = 0U;
3418b146:	2300      	movs	r3, #0
3418b148:	60fb      	str	r3, [r7, #12]
      break;
3418b14a:	e005      	b.n	3418b158 <RCC_PLL_Source_IsReady+0x68>
      break;
3418b14c:	bf00      	nop
3418b14e:	e004      	b.n	3418b15a <RCC_PLL_Source_IsReady+0x6a>
      break;
3418b150:	bf00      	nop
3418b152:	e002      	b.n	3418b15a <RCC_PLL_Source_IsReady+0x6a>
      break;
3418b154:	bf00      	nop
3418b156:	e000      	b.n	3418b15a <RCC_PLL_Source_IsReady+0x6a>
      break;
3418b158:	bf00      	nop
  }

  return ret;
3418b15a:	68fb      	ldr	r3, [r7, #12]
}
3418b15c:	4618      	mov	r0, r3
3418b15e:	3710      	adds	r7, #16
3418b160:	46bd      	mov	sp, r7
3418b162:	bd80      	pop	{r7, pc}

3418b164 <RCC_IC_CheckPLLSources>:
  * @param  PLLSource1 First PLL source
  * @param  PLLSource2 Second PLL source
  * @retval 1 if success else 0
  */
static uint32_t RCC_IC_CheckPLLSources(uint32_t PLLSource1, uint32_t PLLSource2)
{
3418b164:	b580      	push	{r7, lr}
3418b166:	b084      	sub	sp, #16
3418b168:	af00      	add	r7, sp, #0
3418b16a:	6078      	str	r0, [r7, #4]
3418b16c:	6039      	str	r1, [r7, #0]
  uint32_t ret = 1U;
3418b16e:	2301      	movs	r3, #1
3418b170:	60fb      	str	r3, [r7, #12]

  /* No assert since done in calling function */

  /* Check PLLSource1 clock source */
  switch (PLLSource1)
3418b172:	687b      	ldr	r3, [r7, #4]
3418b174:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418b178:	d03a      	beq.n	3418b1f0 <RCC_IC_CheckPLLSources+0x8c>
3418b17a:	687b      	ldr	r3, [r7, #4]
3418b17c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418b180:	d843      	bhi.n	3418b20a <RCC_IC_CheckPLLSources+0xa6>
3418b182:	687b      	ldr	r3, [r7, #4]
3418b184:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418b188:	d025      	beq.n	3418b1d6 <RCC_IC_CheckPLLSources+0x72>
3418b18a:	687b      	ldr	r3, [r7, #4]
3418b18c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418b190:	d83b      	bhi.n	3418b20a <RCC_IC_CheckPLLSources+0xa6>
3418b192:	687b      	ldr	r3, [r7, #4]
3418b194:	2b00      	cmp	r3, #0
3418b196:	d004      	beq.n	3418b1a2 <RCC_IC_CheckPLLSources+0x3e>
3418b198:	687b      	ldr	r3, [r7, #4]
3418b19a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3418b19e:	d00d      	beq.n	3418b1bc <RCC_IC_CheckPLLSources+0x58>
3418b1a0:	e033      	b.n	3418b20a <RCC_IC_CheckPLLSources+0xa6>
  {
    case LL_RCC_ICCLKSOURCE_PLL1:
      if (LL_RCC_PLL1_IsReady() == 0U)
3418b1a2:	f7fe fd25 	bl	34189bf0 <LL_RCC_PLL1_IsReady>
3418b1a6:	4603      	mov	r3, r0
3418b1a8:	2b00      	cmp	r3, #0
3418b1aa:	d131      	bne.n	3418b210 <RCC_IC_CheckPLLSources+0xac>
      {
        if (LL_RCC_PLL1_IsEnabledBypass() == 0U)
3418b1ac:	f7fe fd34 	bl	34189c18 <LL_RCC_PLL1_IsEnabledBypass>
3418b1b0:	4603      	mov	r3, r0
3418b1b2:	2b00      	cmp	r3, #0
3418b1b4:	d12c      	bne.n	3418b210 <RCC_IC_CheckPLLSources+0xac>
        {
          ret = 0U;
3418b1b6:	2300      	movs	r3, #0
3418b1b8:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
3418b1ba:	e029      	b.n	3418b210 <RCC_IC_CheckPLLSources+0xac>
    case LL_RCC_ICCLKSOURCE_PLL2:
      if (LL_RCC_PLL2_IsReady() == 0U)
3418b1bc:	f7fe fd4e 	bl	34189c5c <LL_RCC_PLL2_IsReady>
3418b1c0:	4603      	mov	r3, r0
3418b1c2:	2b00      	cmp	r3, #0
3418b1c4:	d126      	bne.n	3418b214 <RCC_IC_CheckPLLSources+0xb0>
      {
        if (LL_RCC_PLL2_IsEnabledBypass() == 0U)
3418b1c6:	f7fe fd5d 	bl	34189c84 <LL_RCC_PLL2_IsEnabledBypass>
3418b1ca:	4603      	mov	r3, r0
3418b1cc:	2b00      	cmp	r3, #0
3418b1ce:	d121      	bne.n	3418b214 <RCC_IC_CheckPLLSources+0xb0>
        {
          ret = 0U;
3418b1d0:	2300      	movs	r3, #0
3418b1d2:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
3418b1d4:	e01e      	b.n	3418b214 <RCC_IC_CheckPLLSources+0xb0>
    case LL_RCC_ICCLKSOURCE_PLL3:
      if (LL_RCC_PLL3_IsReady() == 0U)
3418b1d6:	f7fe fd77 	bl	34189cc8 <LL_RCC_PLL3_IsReady>
3418b1da:	4603      	mov	r3, r0
3418b1dc:	2b00      	cmp	r3, #0
3418b1de:	d11b      	bne.n	3418b218 <RCC_IC_CheckPLLSources+0xb4>
      {
        if (LL_RCC_PLL3_IsEnabledBypass() == 0U)
3418b1e0:	f7fe fd86 	bl	34189cf0 <LL_RCC_PLL3_IsEnabledBypass>
3418b1e4:	4603      	mov	r3, r0
3418b1e6:	2b00      	cmp	r3, #0
3418b1e8:	d116      	bne.n	3418b218 <RCC_IC_CheckPLLSources+0xb4>
        {
          ret = 0U;
3418b1ea:	2300      	movs	r3, #0
3418b1ec:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
3418b1ee:	e013      	b.n	3418b218 <RCC_IC_CheckPLLSources+0xb4>
    case LL_RCC_ICCLKSOURCE_PLL4:
      if (LL_RCC_PLL4_IsReady() == 0U)
3418b1f0:	f7fe fda0 	bl	34189d34 <LL_RCC_PLL4_IsReady>
3418b1f4:	4603      	mov	r3, r0
3418b1f6:	2b00      	cmp	r3, #0
3418b1f8:	d110      	bne.n	3418b21c <RCC_IC_CheckPLLSources+0xb8>
      {
        if (LL_RCC_PLL4_IsEnabledBypass() == 0U)
3418b1fa:	f7fe fdaf 	bl	34189d5c <LL_RCC_PLL4_IsEnabledBypass>
3418b1fe:	4603      	mov	r3, r0
3418b200:	2b00      	cmp	r3, #0
3418b202:	d10b      	bne.n	3418b21c <RCC_IC_CheckPLLSources+0xb8>
        {
          ret = 0U;
3418b204:	2300      	movs	r3, #0
3418b206:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
3418b208:	e008      	b.n	3418b21c <RCC_IC_CheckPLLSources+0xb8>
    default:
      /* Unexpected */
      ret = 0U;
3418b20a:	2300      	movs	r3, #0
3418b20c:	60fb      	str	r3, [r7, #12]
      break;
3418b20e:	e006      	b.n	3418b21e <RCC_IC_CheckPLLSources+0xba>
      break;
3418b210:	bf00      	nop
3418b212:	e004      	b.n	3418b21e <RCC_IC_CheckPLLSources+0xba>
      break;
3418b214:	bf00      	nop
3418b216:	e002      	b.n	3418b21e <RCC_IC_CheckPLLSources+0xba>
      break;
3418b218:	bf00      	nop
3418b21a:	e000      	b.n	3418b21e <RCC_IC_CheckPLLSources+0xba>
      break;
3418b21c:	bf00      	nop
  }

  /* Check PLLSource2 clock source */
  switch (PLLSource2)
3418b21e:	683b      	ldr	r3, [r7, #0]
3418b220:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418b224:	d03a      	beq.n	3418b29c <RCC_IC_CheckPLLSources+0x138>
3418b226:	683b      	ldr	r3, [r7, #0]
3418b228:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418b22c:	d843      	bhi.n	3418b2b6 <RCC_IC_CheckPLLSources+0x152>
3418b22e:	683b      	ldr	r3, [r7, #0]
3418b230:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418b234:	d025      	beq.n	3418b282 <RCC_IC_CheckPLLSources+0x11e>
3418b236:	683b      	ldr	r3, [r7, #0]
3418b238:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418b23c:	d83b      	bhi.n	3418b2b6 <RCC_IC_CheckPLLSources+0x152>
3418b23e:	683b      	ldr	r3, [r7, #0]
3418b240:	2b00      	cmp	r3, #0
3418b242:	d004      	beq.n	3418b24e <RCC_IC_CheckPLLSources+0xea>
3418b244:	683b      	ldr	r3, [r7, #0]
3418b246:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3418b24a:	d00d      	beq.n	3418b268 <RCC_IC_CheckPLLSources+0x104>
3418b24c:	e033      	b.n	3418b2b6 <RCC_IC_CheckPLLSources+0x152>
  {
    case LL_RCC_ICCLKSOURCE_PLL1:
      if (LL_RCC_PLL1_IsReady() == 0U)
3418b24e:	f7fe fccf 	bl	34189bf0 <LL_RCC_PLL1_IsReady>
3418b252:	4603      	mov	r3, r0
3418b254:	2b00      	cmp	r3, #0
3418b256:	d131      	bne.n	3418b2bc <RCC_IC_CheckPLLSources+0x158>
      {
        if (LL_RCC_PLL1_IsEnabledBypass() == 0U)
3418b258:	f7fe fcde 	bl	34189c18 <LL_RCC_PLL1_IsEnabledBypass>
3418b25c:	4603      	mov	r3, r0
3418b25e:	2b00      	cmp	r3, #0
3418b260:	d12c      	bne.n	3418b2bc <RCC_IC_CheckPLLSources+0x158>
        {
          ret = 0U;
3418b262:	2300      	movs	r3, #0
3418b264:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
3418b266:	e029      	b.n	3418b2bc <RCC_IC_CheckPLLSources+0x158>
    case LL_RCC_ICCLKSOURCE_PLL2:
      if (LL_RCC_PLL2_IsReady() == 0U)
3418b268:	f7fe fcf8 	bl	34189c5c <LL_RCC_PLL2_IsReady>
3418b26c:	4603      	mov	r3, r0
3418b26e:	2b00      	cmp	r3, #0
3418b270:	d126      	bne.n	3418b2c0 <RCC_IC_CheckPLLSources+0x15c>
      {
        if (LL_RCC_PLL2_IsEnabledBypass() == 0U)
3418b272:	f7fe fd07 	bl	34189c84 <LL_RCC_PLL2_IsEnabledBypass>
3418b276:	4603      	mov	r3, r0
3418b278:	2b00      	cmp	r3, #0
3418b27a:	d121      	bne.n	3418b2c0 <RCC_IC_CheckPLLSources+0x15c>
        {
          ret = 0U;
3418b27c:	2300      	movs	r3, #0
3418b27e:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
3418b280:	e01e      	b.n	3418b2c0 <RCC_IC_CheckPLLSources+0x15c>
    case LL_RCC_ICCLKSOURCE_PLL3:
      if (LL_RCC_PLL3_IsReady() == 0U)
3418b282:	f7fe fd21 	bl	34189cc8 <LL_RCC_PLL3_IsReady>
3418b286:	4603      	mov	r3, r0
3418b288:	2b00      	cmp	r3, #0
3418b28a:	d11b      	bne.n	3418b2c4 <RCC_IC_CheckPLLSources+0x160>
      {
        if (LL_RCC_PLL3_IsEnabledBypass() == 0U)
3418b28c:	f7fe fd30 	bl	34189cf0 <LL_RCC_PLL3_IsEnabledBypass>
3418b290:	4603      	mov	r3, r0
3418b292:	2b00      	cmp	r3, #0
3418b294:	d116      	bne.n	3418b2c4 <RCC_IC_CheckPLLSources+0x160>
        {
          ret = 0U;
3418b296:	2300      	movs	r3, #0
3418b298:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
3418b29a:	e013      	b.n	3418b2c4 <RCC_IC_CheckPLLSources+0x160>
    case LL_RCC_ICCLKSOURCE_PLL4:
      if (LL_RCC_PLL4_IsReady() == 0U)
3418b29c:	f7fe fd4a 	bl	34189d34 <LL_RCC_PLL4_IsReady>
3418b2a0:	4603      	mov	r3, r0
3418b2a2:	2b00      	cmp	r3, #0
3418b2a4:	d110      	bne.n	3418b2c8 <RCC_IC_CheckPLLSources+0x164>
      {
        if (LL_RCC_PLL4_IsEnabledBypass() == 0U)
3418b2a6:	f7fe fd59 	bl	34189d5c <LL_RCC_PLL4_IsEnabledBypass>
3418b2aa:	4603      	mov	r3, r0
3418b2ac:	2b00      	cmp	r3, #0
3418b2ae:	d10b      	bne.n	3418b2c8 <RCC_IC_CheckPLLSources+0x164>
        {
          ret = 0U;
3418b2b0:	2300      	movs	r3, #0
3418b2b2:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
3418b2b4:	e008      	b.n	3418b2c8 <RCC_IC_CheckPLLSources+0x164>
    default:
      /* Unexpected */
      ret = 0U;
3418b2b6:	2300      	movs	r3, #0
3418b2b8:	60fb      	str	r3, [r7, #12]
      break;
3418b2ba:	e006      	b.n	3418b2ca <RCC_IC_CheckPLLSources+0x166>
      break;
3418b2bc:	bf00      	nop
3418b2be:	e004      	b.n	3418b2ca <RCC_IC_CheckPLLSources+0x166>
      break;
3418b2c0:	bf00      	nop
3418b2c2:	e002      	b.n	3418b2ca <RCC_IC_CheckPLLSources+0x166>
      break;
3418b2c4:	bf00      	nop
3418b2c6:	e000      	b.n	3418b2ca <RCC_IC_CheckPLLSources+0x166>
      break;
3418b2c8:	bf00      	nop
  }

  return ret;
3418b2ca:	68fb      	ldr	r3, [r7, #12]
}
3418b2cc:	4618      	mov	r0, r3
3418b2ce:	3710      	adds	r7, #16
3418b2d0:	46bd      	mov	sp, r7
3418b2d2:	bd80      	pop	{r7, pc}

3418b2d4 <LL_RCC_HSE_SelectHSEAsDiv2Clock>:
  CLEAR_BIT(RCC->HSECFGR, RCC_HSECFGR_HSEDIV2SEL);
3418b2d4:	4a02      	ldr	r2, [pc, #8]	@ (3418b2e0 <LL_RCC_HSE_SelectHSEAsDiv2Clock+0xc>)
3418b2d6:	6d53      	ldr	r3, [r2, #84]	@ 0x54
3418b2d8:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
3418b2dc:	6553      	str	r3, [r2, #84]	@ 0x54
}
3418b2de:	4770      	bx	lr
3418b2e0:	56028000 	.word	0x56028000

3418b2e4 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>:
  SET_BIT(RCC->HSECFGR, RCC_HSECFGR_HSEDIV2SEL);
3418b2e4:	4a02      	ldr	r2, [pc, #8]	@ (3418b2f0 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock+0xc>)
3418b2e6:	6d53      	ldr	r3, [r2, #84]	@ 0x54
3418b2e8:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
3418b2ec:	6553      	str	r3, [r2, #84]	@ 0x54
}
3418b2ee:	4770      	bx	lr
3418b2f0:	56028000 	.word	0x56028000

3418b2f4 <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock>:
  return ((READ_BIT(RCC->HSECFGR, RCC_HSECFGR_HSEDIV2SEL) == RCC_HSECFGR_HSEDIV2SEL) ? 1UL : 0UL);
3418b2f4:	4b02      	ldr	r3, [pc, #8]	@ (3418b300 <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock+0xc>)
3418b2f6:	6d58      	ldr	r0, [r3, #84]	@ 0x54
}
3418b2f8:	f3c0 1080 	ubfx	r0, r0, #6, #1
3418b2fc:	4770      	bx	lr
3418b2fe:	bf00      	nop
3418b300:	56028000 	.word	0x56028000

3418b304 <LL_RCC_HSE_IsReady>:
  return ((READ_BIT(RCC->SR, RCC_SR_HSERDY) != 0UL) ? 1UL : 0UL);
3418b304:	4b02      	ldr	r3, [pc, #8]	@ (3418b310 <LL_RCC_HSE_IsReady+0xc>)
3418b306:	6858      	ldr	r0, [r3, #4]
}
3418b308:	f3c0 1000 	ubfx	r0, r0, #4, #1
3418b30c:	4770      	bx	lr
3418b30e:	bf00      	nop
3418b310:	56028000 	.word	0x56028000

3418b314 <LL_RCC_HSI_IsReady>:
  return ((READ_BIT(RCC->SR, RCC_SR_HSIRDY) != 0UL) ? 1UL : 0UL);
3418b314:	4b02      	ldr	r3, [pc, #8]	@ (3418b320 <LL_RCC_HSI_IsReady+0xc>)
3418b316:	6858      	ldr	r0, [r3, #4]
}
3418b318:	f3c0 00c0 	ubfx	r0, r0, #3, #1
3418b31c:	4770      	bx	lr
3418b31e:	bf00      	nop
3418b320:	56028000 	.word	0x56028000

3418b324 <LL_RCC_MSI_IsReady>:
  return ((READ_BIT(RCC->SR, RCC_SR_MSIRDY) != 0UL) ? 1UL : 0UL);
3418b324:	4b02      	ldr	r3, [pc, #8]	@ (3418b330 <LL_RCC_MSI_IsReady+0xc>)
3418b326:	6858      	ldr	r0, [r3, #4]
}
3418b328:	f3c0 0080 	ubfx	r0, r0, #2, #1
3418b32c:	4770      	bx	lr
3418b32e:	bf00      	nop
3418b330:	56028000 	.word	0x56028000

3418b334 <LL_RCC_LSE_IsReady>:
  return ((READ_BIT(RCC->SR, RCC_SR_LSERDY) != 0UL) ? 1UL : 0UL);
3418b334:	4b02      	ldr	r3, [pc, #8]	@ (3418b340 <LL_RCC_LSE_IsReady+0xc>)
3418b336:	6858      	ldr	r0, [r3, #4]
}
3418b338:	f3c0 0040 	ubfx	r0, r0, #1, #1
3418b33c:	4770      	bx	lr
3418b33e:	bf00      	nop
3418b340:	56028000 	.word	0x56028000

3418b344 <LL_RCC_SetClockSource>:
  volatile uint32_t *pReg = (uint32_t *)((uint32_t)&RCC->CCIPR1 + LL_CLKSOURCE_REG(ClkSource));
3418b344:	4907      	ldr	r1, [pc, #28]	@ (3418b364 <LL_RCC_SetClockSource+0x20>)
{
3418b346:	b530      	push	{r4, r5, lr}
  volatile uint32_t *pReg = (uint32_t *)((uint32_t)&RCC->CCIPR1 + LL_CLKSOURCE_REG(ClkSource));
3418b348:	b2c4      	uxtb	r4, r0
  MODIFY_REG(*pReg, LL_CLKSOURCE_MASK(ClkSource), LL_CLKSOURCE_CONFIG(ClkSource));
3418b34a:	f3c0 2504 	ubfx	r5, r0, #8, #5
3418b34e:	5863      	ldr	r3, [r4, r1]
3418b350:	0e02      	lsrs	r2, r0, #24
3418b352:	40aa      	lsls	r2, r5
3418b354:	f3c0 4007 	ubfx	r0, r0, #16, #8
3418b358:	ea23 0302 	bic.w	r3, r3, r2
3418b35c:	40a8      	lsls	r0, r5
3418b35e:	4303      	orrs	r3, r0
3418b360:	5063      	str	r3, [r4, r1]
}
3418b362:	bd30      	pop	{r4, r5, pc}
3418b364:	56028144 	.word	0x56028144

3418b368 <LL_RCC_GetClockSource>:
  const volatile uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&RCC->CCIPR1) + LL_CLKSOURCE_REG(Periph)));
3418b368:	4b05      	ldr	r3, [pc, #20]	@ (3418b380 <LL_RCC_GetClockSource+0x18>)
3418b36a:	b2c2      	uxtb	r2, r0
  return (uint32_t)(Periph | (((READ_BIT(*pReg, LL_CLKSOURCE_MASK(Periph))) >> LL_CLKSOURCE_SHIFT(Periph)) << LL_RCC_CONFIG_SHIFT));
3418b36c:	58d1      	ldr	r1, [r2, r3]
3418b36e:	f3c0 2204 	ubfx	r2, r0, #8, #5
3418b372:	0e03      	lsrs	r3, r0, #24
3418b374:	4093      	lsls	r3, r2
3418b376:	400b      	ands	r3, r1
3418b378:	40d3      	lsrs	r3, r2
}
3418b37a:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
3418b37e:	4770      	bx	lr
3418b380:	56028144 	.word	0x56028144

3418b384 <LL_RCC_IC7_IsEnabled>:
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC7EN) == RCC_DIVENR_IC7EN) ? 1UL : 0UL);
3418b384:	4b02      	ldr	r3, [pc, #8]	@ (3418b390 <LL_RCC_IC7_IsEnabled+0xc>)
3418b386:	f8d3 0240 	ldr.w	r0, [r3, #576]	@ 0x240
}
3418b38a:	f3c0 1080 	ubfx	r0, r0, #6, #1
3418b38e:	4770      	bx	lr
3418b390:	56028000 	.word	0x56028000

3418b394 <LL_RCC_IC7_GetDivider>:
  return ((READ_BIT(RCC->IC7CFGR, RCC_IC7CFGR_IC7INT) >> RCC_IC7CFGR_IC7INT_Pos) + 1UL);
3418b394:	4b03      	ldr	r3, [pc, #12]	@ (3418b3a4 <LL_RCC_IC7_GetDivider+0x10>)
3418b396:	f8d3 00dc 	ldr.w	r0, [r3, #220]	@ 0xdc
3418b39a:	f3c0 4007 	ubfx	r0, r0, #16, #8
}
3418b39e:	3001      	adds	r0, #1
3418b3a0:	4770      	bx	lr
3418b3a2:	bf00      	nop
3418b3a4:	56028000 	.word	0x56028000

3418b3a8 <LL_RCC_IC8_IsEnabled>:
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC8EN) == RCC_DIVENR_IC8EN) ? 1UL : 0UL);
3418b3a8:	4b02      	ldr	r3, [pc, #8]	@ (3418b3b4 <LL_RCC_IC8_IsEnabled+0xc>)
3418b3aa:	f8d3 0240 	ldr.w	r0, [r3, #576]	@ 0x240
}
3418b3ae:	f3c0 10c0 	ubfx	r0, r0, #7, #1
3418b3b2:	4770      	bx	lr
3418b3b4:	56028000 	.word	0x56028000

3418b3b8 <LL_RCC_IC8_GetDivider>:
  return ((READ_BIT(RCC->IC8CFGR, RCC_IC8CFGR_IC8INT) >> RCC_IC8CFGR_IC8INT_Pos) + 1UL);
3418b3b8:	4b03      	ldr	r3, [pc, #12]	@ (3418b3c8 <LL_RCC_IC8_GetDivider+0x10>)
3418b3ba:	f8d3 00e0 	ldr.w	r0, [r3, #224]	@ 0xe0
3418b3be:	f3c0 4007 	ubfx	r0, r0, #16, #8
}
3418b3c2:	3001      	adds	r0, #1
3418b3c4:	4770      	bx	lr
3418b3c6:	bf00      	nop
3418b3c8:	56028000 	.word	0x56028000

3418b3cc <LL_RCC_IC9_IsEnabled>:
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC9EN) == RCC_DIVENR_IC9EN) ? 1UL : 0UL);
3418b3cc:	4b02      	ldr	r3, [pc, #8]	@ (3418b3d8 <LL_RCC_IC9_IsEnabled+0xc>)
3418b3ce:	f8d3 0240 	ldr.w	r0, [r3, #576]	@ 0x240
}
3418b3d2:	f3c0 2000 	ubfx	r0, r0, #8, #1
3418b3d6:	4770      	bx	lr
3418b3d8:	56028000 	.word	0x56028000

3418b3dc <LL_RCC_IC9_GetDivider>:
  return ((READ_BIT(RCC->IC9CFGR, RCC_IC9CFGR_IC9INT) >> RCC_IC9CFGR_IC9INT_Pos) + 1UL);
3418b3dc:	4b03      	ldr	r3, [pc, #12]	@ (3418b3ec <LL_RCC_IC9_GetDivider+0x10>)
3418b3de:	f8d3 00e4 	ldr.w	r0, [r3, #228]	@ 0xe4
3418b3e2:	f3c0 4007 	ubfx	r0, r0, #16, #8
}
3418b3e6:	3001      	adds	r0, #1
3418b3e8:	4770      	bx	lr
3418b3ea:	bf00      	nop
3418b3ec:	56028000 	.word	0x56028000

3418b3f0 <LL_RCC_IC14_IsEnabled>:
  * @rmtoll DIVENR       IC14EN         LL_RCC_IC14_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC14_IsEnabled(void)
{
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC14EN) == RCC_DIVENR_IC14EN) ? 1UL : 0UL);
3418b3f0:	4b02      	ldr	r3, [pc, #8]	@ (3418b3fc <LL_RCC_IC14_IsEnabled+0xc>)
3418b3f2:	f8d3 0240 	ldr.w	r0, [r3, #576]	@ 0x240
}
3418b3f6:	f3c0 3040 	ubfx	r0, r0, #13, #1
3418b3fa:	4770      	bx	lr
3418b3fc:	56028000 	.word	0x56028000

3418b400 <LL_RCC_IC14_GetDivider>:
  * @rmtoll IC14CFGR      IC14INT        LL_RCC_IC14_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC14_GetDivider(void)
{
  return ((READ_BIT(RCC->IC14CFGR, RCC_IC14CFGR_IC14INT) >> RCC_IC14CFGR_IC14INT_Pos) + 1UL);
3418b400:	4b03      	ldr	r3, [pc, #12]	@ (3418b410 <LL_RCC_IC14_GetDivider+0x10>)
3418b402:	f8d3 00f8 	ldr.w	r0, [r3, #248]	@ 0xf8
3418b406:	f3c0 4007 	ubfx	r0, r0, #16, #8
}
3418b40a:	3001      	adds	r0, #1
3418b40c:	4770      	bx	lr
3418b40e:	bf00      	nop
3418b410:	56028000 	.word	0x56028000

3418b414 <LL_RCC_IC15_IsEnabled>:
  * @rmtoll DIVENR       IC15EN         LL_RCC_IC15_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC15_IsEnabled(void)
{
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC15EN) == RCC_DIVENR_IC15EN) ? 1UL : 0UL);
3418b414:	4b02      	ldr	r3, [pc, #8]	@ (3418b420 <LL_RCC_IC15_IsEnabled+0xc>)
3418b416:	f8d3 0240 	ldr.w	r0, [r3, #576]	@ 0x240
}
3418b41a:	f3c0 3080 	ubfx	r0, r0, #14, #1
3418b41e:	4770      	bx	lr
3418b420:	56028000 	.word	0x56028000

3418b424 <LL_RCC_IC15_GetDivider>:
  * @rmtoll IC15CFGR      IC15INT        LL_RCC_IC15_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC15_GetDivider(void)
{
  return ((READ_BIT(RCC->IC15CFGR, RCC_IC15CFGR_IC15INT) >> RCC_IC15CFGR_IC15INT_Pos) + 1UL);
3418b424:	4b03      	ldr	r3, [pc, #12]	@ (3418b434 <LL_RCC_IC15_GetDivider+0x10>)
3418b426:	f8d3 00fc 	ldr.w	r0, [r3, #252]	@ 0xfc
3418b42a:	f3c0 4007 	ubfx	r0, r0, #16, #8
}
3418b42e:	3001      	adds	r0, #1
3418b430:	4770      	bx	lr
3418b432:	bf00      	nop
3418b434:	56028000 	.word	0x56028000

3418b438 <RCCEx_GetHCLKFreq>:
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_HPRE));
3418b438:	4b02      	ldr	r3, [pc, #8]	@ (3418b444 <RCCEx_GetHCLKFreq+0xc>)
3418b43a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  * @retval HCLK clock frequency (in Hz)
  */
static uint32_t RCCEx_GetHCLKFreq(uint32_t SYSCLK_Frequency)
{
  /* HCLK clock frequency */
  return LL_RCC_CALC_HCLK_FREQ(SYSCLK_Frequency, LL_RCC_GetAHBPrescaler());
3418b43c:	f3c3 5302 	ubfx	r3, r3, #20, #3
}
3418b440:	40d8      	lsrs	r0, r3
3418b442:	4770      	bx	lr
3418b444:	56028000 	.word	0x56028000

3418b448 <RCCEx_GetPLLSourceFreq>:
  */
static uint32_t RCCEx_GetPLLSourceFreq(uint32_t PLLsource)
{
  uint32_t pllinputfreq = RCC_PERIPH_FREQUENCY_NO;

  switch (PLLsource)
3418b448:	f1b0 5f00 	cmp.w	r0, #536870912	@ 0x20000000
{
3418b44c:	b508      	push	{r3, lr}
  switch (PLLsource)
3418b44e:	d01d      	beq.n	3418b48c <RCCEx_GetPLLSourceFreq+0x44>
3418b450:	d80a      	bhi.n	3418b468 <RCCEx_GetPLLSourceFreq+0x20>
3418b452:	b970      	cbnz	r0, 3418b472 <RCCEx_GetPLLSourceFreq+0x2a>
  {
    case LL_RCC_PLLSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
3418b454:	f7ff ff5e 	bl	3418b314 <LL_RCC_HSI_IsReady>
3418b458:	b148      	cbz	r0, 3418b46e <RCCEx_GetPLLSourceFreq+0x26>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3418b45a:	4b10      	ldr	r3, [pc, #64]	@ (3418b49c <RCCEx_GetPLLSourceFreq+0x54>)
      {
        pllinputfreq = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3418b45c:	4810      	ldr	r0, [pc, #64]	@ (3418b4a0 <RCCEx_GetPLLSourceFreq+0x58>)
3418b45e:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3418b460:	f3c3 13c1 	ubfx	r3, r3, #7, #2
3418b464:	40d8      	lsrs	r0, r3
3418b466:	e003      	b.n	3418b470 <RCCEx_GetPLLSourceFreq+0x28>
  switch (PLLsource)
3418b468:	f1b0 5f40 	cmp.w	r0, #805306368	@ 0x30000000
3418b46c:	d014      	beq.n	3418b498 <RCCEx_GetPLLSourceFreq+0x50>
  uint32_t pllinputfreq = RCC_PERIPH_FREQUENCY_NO;
3418b46e:	2000      	movs	r0, #0
      /* unexpected case */
      break;
  }

  return pllinputfreq;
}
3418b470:	bd08      	pop	{r3, pc}
      if (LL_RCC_MSI_IsReady() != 0U)
3418b472:	f7ff ff57 	bl	3418b324 <LL_RCC_MSI_IsReady>
3418b476:	2800      	cmp	r0, #0
3418b478:	d0f9      	beq.n	3418b46e <RCCEx_GetPLLSourceFreq+0x26>
  return (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL));
3418b47a:	4b08      	ldr	r3, [pc, #32]	@ (3418b49c <RCCEx_GetPLLSourceFreq+0x54>)
          pllinputfreq = MSI_VALUE;
3418b47c:	4809      	ldr	r0, [pc, #36]	@ (3418b4a4 <RCCEx_GetPLLSourceFreq+0x5c>)
3418b47e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3418b480:	f413 7f00 	tst.w	r3, #512	@ 0x200
3418b484:	4b08      	ldr	r3, [pc, #32]	@ (3418b4a8 <RCCEx_GetPLLSourceFreq+0x60>)
3418b486:	bf08      	it	eq
3418b488:	4618      	moveq	r0, r3
3418b48a:	e7f1      	b.n	3418b470 <RCCEx_GetPLLSourceFreq+0x28>
      if (LL_RCC_HSE_IsReady() != 0U)
3418b48c:	f7ff ff3a 	bl	3418b304 <LL_RCC_HSE_IsReady>
3418b490:	2800      	cmp	r0, #0
3418b492:	d0ec      	beq.n	3418b46e <RCCEx_GetPLLSourceFreq+0x26>
        pllinputfreq = HSE_VALUE;
3418b494:	4805      	ldr	r0, [pc, #20]	@ (3418b4ac <RCCEx_GetPLLSourceFreq+0x64>)
3418b496:	e7eb      	b.n	3418b470 <RCCEx_GetPLLSourceFreq+0x28>
      pllinputfreq = EXTERNAL_CLOCK_VALUE;
3418b498:	4805      	ldr	r0, [pc, #20]	@ (3418b4b0 <RCCEx_GetPLLSourceFreq+0x68>)
3418b49a:	e7e9      	b.n	3418b470 <RCCEx_GetPLLSourceFreq+0x28>
3418b49c:	56028000 	.word	0x56028000
3418b4a0:	03d09000 	.word	0x03d09000
3418b4a4:	00f42400 	.word	0x00f42400
3418b4a8:	003d0900 	.word	0x003d0900
3418b4ac:	02dc6c00 	.word	0x02dc6c00
3418b4b0:	00bb8000 	.word	0x00bb8000

3418b4b4 <RCCEx_CalcPLLFreq>:
  * @param  P2     VCO output divider P2 between 1 and 7
  * @retval PLL clock frequency (in Hz)
  */
static uint32_t RCCEx_CalcPLLFreq(uint32_t PLLInputFreq, uint32_t M, uint32_t N, uint32_t FRACN, uint32_t P1,
                                  uint32_t P2)
{
3418b4b4:	ee07 2a10 	vmov	s14, r2
3418b4b8:	ee06 3a10 	vmov	s12, r3
3418b4bc:	ee07 0a90 	vmov	s15, r0
  float_t freq;

  freq = ((float_t)PLLInputFreq * ((float_t)N + ((float_t)FRACN / (float_t)0x1000000))) / (float_t)M;
3418b4c0:	eeb8 6ac6 	vcvt.f32.s32	s12, s12
3418b4c4:	eddf 5a10 	vldr	s11, [pc, #64]	@ 3418b508 <RCCEx_CalcPLLFreq+0x54>
3418b4c8:	eeb8 7a47 	vcvt.f32.u32	s14, s14
{
3418b4cc:	ee06 1a90 	vmov	s13, r1
  freq = ((float_t)PLLInputFreq * ((float_t)N + ((float_t)FRACN / (float_t)0x1000000))) / (float_t)M;
3418b4d0:	eea6 7a25 	vfma.f32	s14, s12, s11
3418b4d4:	eef8 7a67 	vcvt.f32.u32	s15, s15
3418b4d8:	ee67 7a87 	vmul.f32	s15, s15, s14
3418b4dc:	eeb8 7a66 	vcvt.f32.u32	s14, s13
3418b4e0:	ee87 6a87 	vdiv.f32	s12, s15, s14

  freq = freq / (float_t)P1;
3418b4e4:	eddd 7a00 	vldr	s15, [sp]
3418b4e8:	eef8 7a67 	vcvt.f32.u32	s15, s15
3418b4ec:	eec6 6a27 	vdiv.f32	s13, s12, s15
  freq = freq / (float_t)P2;
3418b4f0:	eddd 7a01 	vldr	s15, [sp, #4]
3418b4f4:	eef8 7a67 	vcvt.f32.u32	s15, s15
3418b4f8:	ee86 7aa7 	vdiv.f32	s14, s13, s15

  return (uint32_t)freq;
}
3418b4fc:	eefc 7ac7 	vcvt.u32.f32	s15, s14
3418b500:	ee17 0a90 	vmov	r0, s15
3418b504:	4770      	bx	lr
3418b506:	bf00      	nop
3418b508:	33800000 	.word	0x33800000

3418b50c <HAL_RCCEx_PeriphCLKConfig>:
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
3418b50c:	6803      	ldr	r3, [r0, #0]
{
3418b50e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
3418b512:	0119      	lsls	r1, r3, #4
{
3418b514:	4604      	mov	r4, r0
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
3418b516:	d52b      	bpl.n	3418b570 <HAL_RCCEx_PeriphCLKConfig+0x64>
  return (uint32_t)(READ_BIT(RCC->CCIPR7, RCC_CCIPR7_RTCSEL));
3418b518:	4b2a      	ldr	r3, [pc, #168]	@ (3418b5c4 <HAL_RCCEx_PeriphCLKConfig+0xb8>)
    if ((tmpreg != RCC_RTCCLKSOURCE_DISABLE) && (tmpreg != (PeriphClkInit->RTCClockSelection & RCC_CCIPR7_RTCSEL)))
3418b51a:	f8d0 1188 	ldr.w	r1, [r0, #392]	@ 0x188
3418b51e:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
3418b522:	f413 7340 	ands.w	r3, r3, #768	@ 0x300
3418b526:	d136      	bne.n	3418b596 <HAL_RCCEx_PeriphCLKConfig+0x8a>
      if (PeriphClkInit->RTCClockSelection == RCC_RTCCLKSOURCE_LSE)
3418b528:	f5b1 7f80 	cmp.w	r1, #256	@ 0x100
3418b52c:	d108      	bne.n	3418b540 <HAL_RCCEx_PeriphCLKConfig+0x34>
        tickstart = HAL_GetTick();
3418b52e:	f7fa f843 	bl	341855b8 <HAL_GetTick>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
3418b532:	f241 3688 	movw	r6, #5000	@ 0x1388
        tickstart = HAL_GetTick();
3418b536:	4605      	mov	r5, r0
        while (LL_RCC_LSE_IsReady() == 0U)
3418b538:	f7ff fefc 	bl	3418b334 <LL_RCC_LSE_IsReady>
3418b53c:	2800      	cmp	r0, #0
3418b53e:	d039      	beq.n	3418b5b4 <HAL_RCCEx_PeriphCLKConfig+0xa8>
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
3418b540:	f8d4 3188 	ldr.w	r3, [r4, #392]	@ 0x188
3418b544:	4a1f      	ldr	r2, [pc, #124]	@ (3418b5c4 <HAL_RCCEx_PeriphCLKConfig+0xb8>)
3418b546:	f403 7040 	and.w	r0, r3, #768	@ 0x300
3418b54a:	f5b0 7f40 	cmp.w	r0, #768	@ 0x300
3418b54e:	d108      	bne.n	3418b562 <HAL_RCCEx_PeriphCLKConfig+0x56>
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_RTCPRE, Prescaler);
3418b550:	f8d2 115c 	ldr.w	r1, [r2, #348]	@ 0x15c
3418b554:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
3418b558:	f421 317c 	bic.w	r1, r1, #258048	@ 0x3f000
3418b55c:	430b      	orrs	r3, r1
3418b55e:	f8c2 315c 	str.w	r3, [r2, #348]	@ 0x15c
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_RTCSEL, Source);
3418b562:	f8d2 315c 	ldr.w	r3, [r2, #348]	@ 0x15c
3418b566:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
3418b56a:	4303      	orrs	r3, r0
3418b56c:	f8c2 315c 	str.w	r3, [r2, #348]	@ 0x15c
  HAL_StatusTypeDef status = HAL_OK;   /* Final status */
3418b570:	f04f 0800 	mov.w	r8, #0
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_CKPER) == RCC_PERIPHCLK_CKPER)
3418b574:	e9d4 5600 	ldrd	r5, r6, [r4]
3418b578:	076b      	lsls	r3, r5, #29
3418b57a:	d540      	bpl.n	3418b5fe <HAL_RCCEx_PeriphCLKConfig+0xf2>
    if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC5)
3418b57c:	f8d4 10b8 	ldr.w	r1, [r4, #184]	@ 0xb8
3418b580:	4b10      	ldr	r3, [pc, #64]	@ (3418b5c4 <HAL_RCCEx_PeriphCLKConfig+0xb8>)
3418b582:	1eca      	subs	r2, r1, #3
3418b584:	2a04      	cmp	r2, #4
3418b586:	d832      	bhi.n	3418b5ee <HAL_RCCEx_PeriphCLKConfig+0xe2>
3418b588:	e8df f012 	tbh	[pc, r2, lsl #1]
3418b58c:	002006cc 	.word	0x002006cc
3418b590:	06ba06a8 	.word	0x06ba06a8
3418b594:	06f6      	.short	0x06f6
    if ((tmpreg != RCC_RTCCLKSOURCE_DISABLE) && (tmpreg != (PeriphClkInit->RTCClockSelection & RCC_CCIPR7_RTCSEL)))
3418b596:	f401 7240 	and.w	r2, r1, #768	@ 0x300
3418b59a:	429a      	cmp	r2, r3
3418b59c:	d0c4      	beq.n	3418b528 <HAL_RCCEx_PeriphCLKConfig+0x1c>
      SET_BIT(PWR->DBPCR, PWR_DBPCR_DBP);
3418b59e:	4b0a      	ldr	r3, [pc, #40]	@ (3418b5c8 <HAL_RCCEx_PeriphCLKConfig+0xbc>)
3418b5a0:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
3418b5a2:	f042 0201 	orr.w	r2, r2, #1
3418b5a6:	62da      	str	r2, [r3, #44]	@ 0x2c
      if (READ_BIT(PWR->DBPCR, PWR_DBPCR_DBP) == 0U)
3418b5a8:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3418b5aa:	07da      	lsls	r2, r3, #31
3418b5ac:	d4bc      	bmi.n	3418b528 <HAL_RCCEx_PeriphCLKConfig+0x1c>
      status = ret;
3418b5ae:	f04f 0801 	mov.w	r8, #1
3418b5b2:	e7df      	b.n	3418b574 <HAL_RCCEx_PeriphCLKConfig+0x68>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
3418b5b4:	f7fa f800 	bl	341855b8 <HAL_GetTick>
3418b5b8:	1b40      	subs	r0, r0, r5
3418b5ba:	42b0      	cmp	r0, r6
3418b5bc:	d9bc      	bls.n	3418b538 <HAL_RCCEx_PeriphCLKConfig+0x2c>
        status = ret;
3418b5be:	f04f 0803 	mov.w	r8, #3
3418b5c2:	e7d7      	b.n	3418b574 <HAL_RCCEx_PeriphCLKConfig+0x68>
3418b5c4:	56028000 	.word	0x56028000
3418b5c8:	56024800 	.word	0x56024800
      MODIFY_REG(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL | RCC_IC5CFGR_IC5INT,
3418b5cc:	f8d3 20d4 	ldr.w	r2, [r3, #212]	@ 0xd4
3418b5d0:	6ae0      	ldr	r0, [r4, #44]	@ 0x2c
3418b5d2:	6aa7      	ldr	r7, [r4, #40]	@ 0x28
3418b5d4:	f022 5243 	bic.w	r2, r2, #817889280	@ 0x30c00000
3418b5d8:	f422 127c 	bic.w	r2, r2, #4128768	@ 0x3f0000
3418b5dc:	3801      	subs	r0, #1
3418b5de:	433a      	orrs	r2, r7
3418b5e0:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
3418b5e4:	f8c3 20d4 	str.w	r2, [r3, #212]	@ 0xd4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC5ENS);
3418b5e8:	2210      	movs	r2, #16
  * @rmtoll DIVENSR       IC20ENS        LL_RCC_IC20_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC20_Enable(void)
{
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC20ENS);
3418b5ea:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_PERSEL, ClkSource);
3418b5ee:	4ac5      	ldr	r2, [pc, #788]	@ (3418b904 <HAL_RCCEx_PeriphCLKConfig+0x3f8>)
3418b5f0:	f8d2 315c 	ldr.w	r3, [r2, #348]	@ 0x15c
3418b5f4:	f023 0307 	bic.w	r3, r3, #7
3418b5f8:	430b      	orrs	r3, r1
3418b5fa:	f8c2 315c 	str.w	r3, [r2, #348]	@ 0x15c
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_XSPI1) == RCC_PERIPHCLK_XSPI1)
3418b5fe:	0277      	lsls	r7, r6, #9
3418b600:	d519      	bpl.n	3418b636 <HAL_RCCEx_PeriphCLKConfig+0x12a>
    if (PeriphClkInit->Xspi1ClockSelection == RCC_XSPI1CLKSOURCE_IC3)
3418b602:	f8d4 00ac 	ldr.w	r0, [r4, #172]	@ 0xac
3418b606:	4bc0      	ldr	r3, [pc, #768]	@ (3418b908 <HAL_RCCEx_PeriphCLKConfig+0x3fc>)
3418b608:	4298      	cmp	r0, r3
3418b60a:	f040 86c9 	bne.w	3418c3a0 <HAL_RCCEx_PeriphCLKConfig+0xe94>
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
3418b60e:	4abd      	ldr	r2, [pc, #756]	@ (3418b904 <HAL_RCCEx_PeriphCLKConfig+0x3f8>)
3418b610:	69e1      	ldr	r1, [r4, #28]
3418b612:	f8d2 30cc 	ldr.w	r3, [r2, #204]	@ 0xcc
3418b616:	69a7      	ldr	r7, [r4, #24]
3418b618:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418b61c:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418b620:	3901      	subs	r1, #1
3418b622:	433b      	orrs	r3, r7
3418b624:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418b628:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC3ENS);
3418b62c:	2304      	movs	r3, #4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
3418b62e:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3418b632:	f7ff fe87 	bl	3418b344 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_XSPI2) == RCC_PERIPHCLK_XSPI2)
3418b636:	0230      	lsls	r0, r6, #8
3418b638:	d519      	bpl.n	3418b66e <HAL_RCCEx_PeriphCLKConfig+0x162>
    if (PeriphClkInit->Xspi2ClockSelection == RCC_XSPI2CLKSOURCE_IC3)
3418b63a:	f8d4 00b0 	ldr.w	r0, [r4, #176]	@ 0xb0
3418b63e:	4bb3      	ldr	r3, [pc, #716]	@ (3418b90c <HAL_RCCEx_PeriphCLKConfig+0x400>)
3418b640:	4298      	cmp	r0, r3
3418b642:	f040 86cb 	bne.w	3418c3dc <HAL_RCCEx_PeriphCLKConfig+0xed0>
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
3418b646:	4aaf      	ldr	r2, [pc, #700]	@ (3418b904 <HAL_RCCEx_PeriphCLKConfig+0x3f8>)
3418b648:	69e1      	ldr	r1, [r4, #28]
3418b64a:	f8d2 30cc 	ldr.w	r3, [r2, #204]	@ 0xcc
3418b64e:	69a7      	ldr	r7, [r4, #24]
3418b650:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418b654:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418b658:	3901      	subs	r1, #1
3418b65a:	433b      	orrs	r3, r7
3418b65c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418b660:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC3ENS);
3418b664:	2304      	movs	r3, #4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
3418b666:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3418b66a:	f7ff fe6b 	bl	3418b344 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_XSPI3) == RCC_PERIPHCLK_XSPI3)
3418b66e:	01f1      	lsls	r1, r6, #7
3418b670:	d519      	bpl.n	3418b6a6 <HAL_RCCEx_PeriphCLKConfig+0x19a>
    if (PeriphClkInit->Xspi3ClockSelection == RCC_XSPI3CLKSOURCE_IC3)
3418b672:	f8d4 00b4 	ldr.w	r0, [r4, #180]	@ 0xb4
3418b676:	4ba6      	ldr	r3, [pc, #664]	@ (3418b910 <HAL_RCCEx_PeriphCLKConfig+0x404>)
3418b678:	4298      	cmp	r0, r3
3418b67a:	f040 86cd 	bne.w	3418c418 <HAL_RCCEx_PeriphCLKConfig+0xf0c>
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
3418b67e:	4aa1      	ldr	r2, [pc, #644]	@ (3418b904 <HAL_RCCEx_PeriphCLKConfig+0x3f8>)
3418b680:	69e1      	ldr	r1, [r4, #28]
3418b682:	f8d2 30cc 	ldr.w	r3, [r2, #204]	@ 0xcc
3418b686:	69a7      	ldr	r7, [r4, #24]
3418b688:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418b68c:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418b690:	3901      	subs	r1, #1
3418b692:	433b      	orrs	r3, r7
3418b694:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418b698:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC3ENS);
3418b69c:	2304      	movs	r3, #4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
3418b69e:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3418b6a2:	f7ff fe4f 	bl	3418b344 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_FMC) == RCC_PERIPHCLK_FMC)
3418b6a6:	052a      	lsls	r2, r5, #20
3418b6a8:	d51e      	bpl.n	3418b6e8 <HAL_RCCEx_PeriphCLKConfig+0x1dc>
    if (PeriphClkInit->FmcClockSelection == RCC_FMCCLKSOURCE_IC3)
3418b6aa:	f8d4 10a8 	ldr.w	r1, [r4, #168]	@ 0xa8
3418b6ae:	4a95      	ldr	r2, [pc, #596]	@ (3418b904 <HAL_RCCEx_PeriphCLKConfig+0x3f8>)
3418b6b0:	2920      	cmp	r1, #32
3418b6b2:	f040 86cf 	bne.w	3418c454 <HAL_RCCEx_PeriphCLKConfig+0xf48>
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
3418b6b6:	f8d2 30cc 	ldr.w	r3, [r2, #204]	@ 0xcc
3418b6ba:	69e0      	ldr	r0, [r4, #28]
3418b6bc:	69a7      	ldr	r7, [r4, #24]
3418b6be:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418b6c2:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418b6c6:	3801      	subs	r0, #1
3418b6c8:	433b      	orrs	r3, r7
3418b6ca:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
3418b6ce:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC3ENS);
3418b6d2:	2304      	movs	r3, #4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
3418b6d4:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR3, RCC_CCIPR3_FMCSEL, ClkSource);
3418b6d8:	4a8a      	ldr	r2, [pc, #552]	@ (3418b904 <HAL_RCCEx_PeriphCLKConfig+0x3f8>)
3418b6da:	f8d2 314c 	ldr.w	r3, [r2, #332]	@ 0x14c
3418b6de:	f023 0330 	bic.w	r3, r3, #48	@ 0x30
3418b6e2:	430b      	orrs	r3, r1
3418b6e4:	f8c2 314c 	str.w	r3, [r2, #332]	@ 0x14c
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SDMMC1) == RCC_PERIPHCLK_SDMMC1)
3418b6e8:	006b      	lsls	r3, r5, #1
3418b6ea:	d519      	bpl.n	3418b720 <HAL_RCCEx_PeriphCLKConfig+0x214>
    if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_IC4)
3418b6ec:	f8d4 012c 	ldr.w	r0, [r4, #300]	@ 0x12c
3418b6f0:	4b88      	ldr	r3, [pc, #544]	@ (3418b914 <HAL_RCCEx_PeriphCLKConfig+0x408>)
3418b6f2:	4298      	cmp	r0, r3
3418b6f4:	f040 86c8 	bne.w	3418c488 <HAL_RCCEx_PeriphCLKConfig+0xf7c>
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
3418b6f8:	4a82      	ldr	r2, [pc, #520]	@ (3418b904 <HAL_RCCEx_PeriphCLKConfig+0x3f8>)
3418b6fa:	6a61      	ldr	r1, [r4, #36]	@ 0x24
3418b6fc:	f8d2 30d0 	ldr.w	r3, [r2, #208]	@ 0xd0
3418b700:	6a27      	ldr	r7, [r4, #32]
3418b702:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418b706:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418b70a:	3901      	subs	r1, #1
3418b70c:	433b      	orrs	r3, r7
3418b70e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418b712:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
3418b716:	2308      	movs	r3, #8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC5ENS);
3418b718:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3418b71c:	f7ff fe12 	bl	3418b344 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SDMMC2) == RCC_PERIPHCLK_SDMMC2)
3418b720:	2d00      	cmp	r5, #0
3418b722:	da19      	bge.n	3418b758 <HAL_RCCEx_PeriphCLKConfig+0x24c>
    if (PeriphClkInit->Sdmmc2ClockSelection == RCC_SDMMC2CLKSOURCE_IC4)
3418b724:	f8d4 0130 	ldr.w	r0, [r4, #304]	@ 0x130
3418b728:	4b7b      	ldr	r3, [pc, #492]	@ (3418b918 <HAL_RCCEx_PeriphCLKConfig+0x40c>)
3418b72a:	4298      	cmp	r0, r3
3418b72c:	f040 86ca 	bne.w	3418c4c4 <HAL_RCCEx_PeriphCLKConfig+0xfb8>
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
3418b730:	4a74      	ldr	r2, [pc, #464]	@ (3418b904 <HAL_RCCEx_PeriphCLKConfig+0x3f8>)
3418b732:	6a61      	ldr	r1, [r4, #36]	@ 0x24
3418b734:	f8d2 30d0 	ldr.w	r3, [r2, #208]	@ 0xd0
3418b738:	6a27      	ldr	r7, [r4, #32]
3418b73a:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418b73e:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418b742:	3901      	subs	r1, #1
3418b744:	433b      	orrs	r3, r7
3418b746:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418b74a:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
3418b74e:	2308      	movs	r3, #8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC5ENS);
3418b750:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3418b754:	f7ff fdf6 	bl	3418b344 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
3418b758:	07ef      	lsls	r7, r5, #31
3418b75a:	d525      	bpl.n	3418b7a8 <HAL_RCCEx_PeriphCLKConfig+0x29c>
    if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_IC7)
3418b75c:	f8d4 20bc 	ldr.w	r2, [r4, #188]	@ 0xbc
3418b760:	4968      	ldr	r1, [pc, #416]	@ (3418b904 <HAL_RCCEx_PeriphCLKConfig+0x3f8>)
3418b762:	2a20      	cmp	r2, #32
3418b764:	f040 86cc 	bne.w	3418c500 <HAL_RCCEx_PeriphCLKConfig+0xff4>
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
3418b768:	f8d1 30dc 	ldr.w	r3, [r1, #220]	@ 0xdc
3418b76c:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
3418b76e:	6ba7      	ldr	r7, [r4, #56]	@ 0x38
3418b770:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418b774:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418b778:	3801      	subs	r0, #1
3418b77a:	433b      	orrs	r3, r7
3418b77c:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
3418b780:	f8c1 30dc 	str.w	r3, [r1, #220]	@ 0xdc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC7ENS);
3418b784:	2340      	movs	r3, #64	@ 0x40
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3418b786:	f8c1 3a40 	str.w	r3, [r1, #2624]	@ 0xa40
    MODIFY_REG(RCC->CCIPR1, (RCC_CCIPR1_ADCPRE | RCC_CCIPR1_ADC12SEL), \
3418b78a:	485e      	ldr	r0, [pc, #376]	@ (3418b904 <HAL_RCCEx_PeriphCLKConfig+0x3f8>)
3418b78c:	f8d4 10c0 	ldr.w	r1, [r4, #192]	@ 0xc0
3418b790:	f8d0 3144 	ldr.w	r3, [r0, #324]	@ 0x144
3418b794:	3901      	subs	r1, #1
3418b796:	f423 437f 	bic.w	r3, r3, #65280	@ 0xff00
3418b79a:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
3418b79e:	4313      	orrs	r3, r2
3418b7a0:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
3418b7a4:	f8c0 3144 	str.w	r3, [r0, #324]	@ 0x144
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ADF1) == RCC_PERIPHCLK_ADF1)
3418b7a8:	07a8      	lsls	r0, r5, #30
3418b7aa:	d51e      	bpl.n	3418b7ea <HAL_RCCEx_PeriphCLKConfig+0x2de>
    if (PeriphClkInit->Adf1ClockSelection == RCC_ADF1CLKSOURCE_IC7)
3418b7ac:	f8d4 10c4 	ldr.w	r1, [r4, #196]	@ 0xc4
3418b7b0:	4a54      	ldr	r2, [pc, #336]	@ (3418b904 <HAL_RCCEx_PeriphCLKConfig+0x3f8>)
3418b7b2:	2902      	cmp	r1, #2
3418b7b4:	f040 86be 	bne.w	3418c534 <HAL_RCCEx_PeriphCLKConfig+0x1028>
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
3418b7b8:	f8d2 30dc 	ldr.w	r3, [r2, #220]	@ 0xdc
3418b7bc:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
3418b7be:	6ba7      	ldr	r7, [r4, #56]	@ 0x38
3418b7c0:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418b7c4:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418b7c8:	3801      	subs	r0, #1
3418b7ca:	433b      	orrs	r3, r7
3418b7cc:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
3418b7d0:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC7ENS);
3418b7d4:	2340      	movs	r3, #64	@ 0x40
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3418b7d6:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR1, RCC_CCIPR1_ADF1SEL, ClkSource);
3418b7da:	4a4a      	ldr	r2, [pc, #296]	@ (3418b904 <HAL_RCCEx_PeriphCLKConfig+0x3f8>)
3418b7dc:	f8d2 3144 	ldr.w	r3, [r2, #324]	@ 0x144
3418b7e0:	f023 0307 	bic.w	r3, r3, #7
3418b7e4:	430b      	orrs	r3, r1
3418b7e6:	f8c2 3144 	str.w	r3, [r2, #324]	@ 0x144
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_CSI) == RCC_PERIPHCLK_CSI)
3418b7ea:	0729      	lsls	r1, r5, #28
3418b7ec:	d514      	bpl.n	3418b818 <HAL_RCCEx_PeriphCLKConfig+0x30c>
    MODIFY_REG(RCC->IC18CFGR, RCC_IC18CFGR_IC18SEL | RCC_IC18CFGR_IC18INT,
3418b7ee:	4a45      	ldr	r2, [pc, #276]	@ (3418b904 <HAL_RCCEx_PeriphCLKConfig+0x3f8>)
3418b7f0:	f8d4 1094 	ldr.w	r1, [r4, #148]	@ 0x94
3418b7f4:	f8d2 3108 	ldr.w	r3, [r2, #264]	@ 0x108
3418b7f8:	f8d4 0090 	ldr.w	r0, [r4, #144]	@ 0x90
3418b7fc:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418b800:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418b804:	3901      	subs	r1, #1
3418b806:	4303      	orrs	r3, r0
3418b808:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418b80c:	f8c2 3108 	str.w	r3, [r2, #264]	@ 0x108
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC18ENS);
3418b810:	f44f 3300 	mov.w	r3, #131072	@ 0x20000
3418b814:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_DCMIPP) == RCC_PERIPHCLK_DCMIPP)
3418b818:	06ea      	lsls	r2, r5, #27
3418b81a:	d522      	bpl.n	3418b862 <HAL_RCCEx_PeriphCLKConfig+0x356>
    if (PeriphClkInit->DcmippClockSelection == RCC_DCMIPPCLKSOURCE_IC17)
3418b81c:	f8d4 10c8 	ldr.w	r1, [r4, #200]	@ 0xc8
3418b820:	4a38      	ldr	r2, [pc, #224]	@ (3418b904 <HAL_RCCEx_PeriphCLKConfig+0x3f8>)
3418b822:	f5b1 1f00 	cmp.w	r1, #2097152	@ 0x200000
3418b826:	f040 869f 	bne.w	3418c568 <HAL_RCCEx_PeriphCLKConfig+0x105c>
      MODIFY_REG(RCC->IC17CFGR, RCC_IC17CFGR_IC17SEL | RCC_IC17CFGR_IC17INT,
3418b82a:	f8d2 3104 	ldr.w	r3, [r2, #260]	@ 0x104
3418b82e:	f8d4 008c 	ldr.w	r0, [r4, #140]	@ 0x8c
3418b832:	f8d4 7088 	ldr.w	r7, [r4, #136]	@ 0x88
3418b836:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418b83a:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418b83e:	3801      	subs	r0, #1
3418b840:	433b      	orrs	r3, r7
3418b842:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
3418b846:	f8c2 3104 	str.w	r3, [r2, #260]	@ 0x104
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC17ENS);
3418b84a:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
3418b84e:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR1, RCC_CCIPR1_DCMIPPSEL, ClkSource);
3418b852:	4a2c      	ldr	r2, [pc, #176]	@ (3418b904 <HAL_RCCEx_PeriphCLKConfig+0x3f8>)
3418b854:	f8d2 3144 	ldr.w	r3, [r2, #324]	@ 0x144
3418b858:	f423 1340 	bic.w	r3, r3, #3145728	@ 0x300000
3418b85c:	430b      	orrs	r3, r1
3418b85e:	f8c2 3144 	str.w	r3, [r2, #324]	@ 0x144
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1) == RCC_PERIPHCLK_ETH1)
3418b862:	06ab      	lsls	r3, r5, #26
3418b864:	d520      	bpl.n	3418b8a8 <HAL_RCCEx_PeriphCLKConfig+0x39c>
    if (PeriphClkInit->Eth1ClockSelection == RCC_ETH1CLKSOURCE_IC12)
3418b866:	f8d4 10cc 	ldr.w	r1, [r4, #204]	@ 0xcc
3418b86a:	4a26      	ldr	r2, [pc, #152]	@ (3418b904 <HAL_RCCEx_PeriphCLKConfig+0x3f8>)
3418b86c:	f5b1 5f00 	cmp.w	r1, #8192	@ 0x2000
3418b870:	f040 8682 	bne.w	3418c578 <HAL_RCCEx_PeriphCLKConfig+0x106c>
      MODIFY_REG(RCC->IC12CFGR, RCC_IC12CFGR_IC12SEL | RCC_IC12CFGR_IC12INT,
3418b874:	f8d2 30f0 	ldr.w	r3, [r2, #240]	@ 0xf0
3418b878:	6e60      	ldr	r0, [r4, #100]	@ 0x64
3418b87a:	6e27      	ldr	r7, [r4, #96]	@ 0x60
3418b87c:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418b880:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418b884:	3801      	subs	r0, #1
3418b886:	433b      	orrs	r3, r7
3418b888:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
3418b88c:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC12ENS);
3418b890:	f44f 6300 	mov.w	r3, #2048	@ 0x800
3418b894:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1CLKSEL, ClkSource);
3418b898:	4a1a      	ldr	r2, [pc, #104]	@ (3418b904 <HAL_RCCEx_PeriphCLKConfig+0x3f8>)
3418b89a:	f8d2 3148 	ldr.w	r3, [r2, #328]	@ 0x148
3418b89e:	f423 5340 	bic.w	r3, r3, #12288	@ 0x3000
3418b8a2:	430b      	orrs	r3, r1
3418b8a4:	f8c2 3148 	str.w	r3, [r2, #328]	@ 0x148
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1PHY) == RCC_PERIPHCLK_ETH1PHY)
3418b8a8:	066f      	lsls	r7, r5, #25
3418b8aa:	d509      	bpl.n	3418b8c0 <HAL_RCCEx_PeriphCLKConfig+0x3b4>
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1SEL, Interface);
3418b8ac:	4a15      	ldr	r2, [pc, #84]	@ (3418b904 <HAL_RCCEx_PeriphCLKConfig+0x3f8>)
3418b8ae:	f8d4 10d0 	ldr.w	r1, [r4, #208]	@ 0xd0
3418b8b2:	f8d2 3148 	ldr.w	r3, [r2, #328]	@ 0x148
3418b8b6:	f423 23e0 	bic.w	r3, r3, #458752	@ 0x70000
3418b8ba:	430b      	orrs	r3, r1
3418b8bc:	f8c2 3148 	str.w	r3, [r2, #328]	@ 0x148
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1RX) == RCC_PERIPHCLK_ETH1RX)
3418b8c0:	0628      	lsls	r0, r5, #24
3418b8c2:	d509      	bpl.n	3418b8d8 <HAL_RCCEx_PeriphCLKConfig+0x3cc>
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1REFCLKSEL, ClkSource);
3418b8c4:	4a0f      	ldr	r2, [pc, #60]	@ (3418b904 <HAL_RCCEx_PeriphCLKConfig+0x3f8>)
3418b8c6:	f8d4 10d4 	ldr.w	r1, [r4, #212]	@ 0xd4
3418b8ca:	f8d2 3148 	ldr.w	r3, [r2, #328]	@ 0x148
3418b8ce:	f423 1380 	bic.w	r3, r3, #1048576	@ 0x100000
3418b8d2:	430b      	orrs	r3, r1
3418b8d4:	f8c2 3148 	str.w	r3, [r2, #328]	@ 0x148
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1TX) == RCC_PERIPHCLK_ETH1TX)
3418b8d8:	05e9      	lsls	r1, r5, #23
3418b8da:	d509      	bpl.n	3418b8f0 <HAL_RCCEx_PeriphCLKConfig+0x3e4>
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1GTXCLKSEL, ClkSource);
3418b8dc:	4a09      	ldr	r2, [pc, #36]	@ (3418b904 <HAL_RCCEx_PeriphCLKConfig+0x3f8>)
3418b8de:	f8d4 10d8 	ldr.w	r1, [r4, #216]	@ 0xd8
3418b8e2:	f8d2 3148 	ldr.w	r3, [r2, #328]	@ 0x148
3418b8e6:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
3418b8ea:	430b      	orrs	r3, r1
3418b8ec:	f8c2 3148 	str.w	r3, [r2, #328]	@ 0x148
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1PTP) == RCC_PERIPHCLK_ETH1PTP)
3418b8f0:	05aa      	lsls	r2, r5, #22
3418b8f2:	d532      	bpl.n	3418b95a <HAL_RCCEx_PeriphCLKConfig+0x44e>
    if (PeriphClkInit->Eth1PtpClockSelection == RCC_ETH1PTPCLKSOURCE_IC13)
3418b8f4:	f8d4 10dc 	ldr.w	r1, [r4, #220]	@ 0xdc
3418b8f8:	4a02      	ldr	r2, [pc, #8]	@ (3418b904 <HAL_RCCEx_PeriphCLKConfig+0x3f8>)
3418b8fa:	2902      	cmp	r1, #2
3418b8fc:	f040 8644 	bne.w	3418c588 <HAL_RCCEx_PeriphCLKConfig+0x107c>
3418b900:	e00c      	b.n	3418b91c <HAL_RCCEx_PeriphCLKConfig+0x410>
3418b902:	bf00      	nop
3418b904:	56028000 	.word	0x56028000
3418b908:	03020014 	.word	0x03020014
3418b90c:	03020414 	.word	0x03020414
3418b910:	03020814 	.word	0x03020814
3418b914:	0302001c 	.word	0x0302001c
3418b918:	0302041c 	.word	0x0302041c
      MODIFY_REG(RCC->IC13CFGR, RCC_IC13CFGR_IC13SEL | RCC_IC13CFGR_IC13INT,
3418b91c:	f8d2 30f4 	ldr.w	r3, [r2, #244]	@ 0xf4
3418b920:	6ee0      	ldr	r0, [r4, #108]	@ 0x6c
3418b922:	6ea7      	ldr	r7, [r4, #104]	@ 0x68
3418b924:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418b928:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418b92c:	3801      	subs	r0, #1
3418b92e:	433b      	orrs	r3, r7
3418b930:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
3418b934:	f8c2 30f4 	str.w	r3, [r2, #244]	@ 0xf4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC13ENS);
3418b938:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
3418b93c:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
    MODIFY_REG(RCC->CCIPR2, (RCC_CCIPR2_ETH1PTPDIV | RCC_CCIPR2_ETH1PTPSEL), \
3418b940:	48c9      	ldr	r0, [pc, #804]	@ (3418bc68 <HAL_RCCEx_PeriphCLKConfig+0x75c>)
3418b942:	f8d4 20e0 	ldr.w	r2, [r4, #224]	@ 0xe0
3418b946:	f8d0 3148 	ldr.w	r3, [r0, #328]	@ 0x148
3418b94a:	3a01      	subs	r2, #1
3418b94c:	f023 03f3 	bic.w	r3, r3, #243	@ 0xf3
3418b950:	430b      	orrs	r3, r1
3418b952:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
3418b956:	f8c0 3148 	str.w	r3, [r0, #328]	@ 0x148
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_FDCAN) == RCC_PERIPHCLK_FDCAN)
3418b95a:	056b      	lsls	r3, r5, #21
3418b95c:	d521      	bpl.n	3418b9a2 <HAL_RCCEx_PeriphCLKConfig+0x496>
    if (PeriphClkInit->FdcanClockSelection == RCC_FDCANCLKSOURCE_IC19)
3418b95e:	f8d4 10e4 	ldr.w	r1, [r4, #228]	@ 0xe4
3418b962:	4ac1      	ldr	r2, [pc, #772]	@ (3418bc68 <HAL_RCCEx_PeriphCLKConfig+0x75c>)
3418b964:	2902      	cmp	r1, #2
3418b966:	f040 8616 	bne.w	3418c596 <HAL_RCCEx_PeriphCLKConfig+0x108a>
      MODIFY_REG(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL | RCC_IC19CFGR_IC19INT,
3418b96a:	f8d2 310c 	ldr.w	r3, [r2, #268]	@ 0x10c
3418b96e:	f8d4 009c 	ldr.w	r0, [r4, #156]	@ 0x9c
3418b972:	f8d4 7098 	ldr.w	r7, [r4, #152]	@ 0x98
3418b976:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418b97a:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418b97e:	3801      	subs	r0, #1
3418b980:	433b      	orrs	r3, r7
3418b982:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
3418b986:	f8c2 310c 	str.w	r3, [r2, #268]	@ 0x10c
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC19ENS);
3418b98a:	f44f 2380 	mov.w	r3, #262144	@ 0x40000
3418b98e:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR3, RCC_CCIPR3_FDCANSEL, ClkSource);
3418b992:	4ab5      	ldr	r2, [pc, #724]	@ (3418bc68 <HAL_RCCEx_PeriphCLKConfig+0x75c>)
3418b994:	f8d2 314c 	ldr.w	r3, [r2, #332]	@ 0x14c
3418b998:	f023 0303 	bic.w	r3, r3, #3
3418b99c:	430b      	orrs	r3, r1
3418b99e:	f8c2 314c 	str.w	r3, [r2, #332]	@ 0x14c
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
3418b9a2:	04ef      	lsls	r7, r5, #19
3418b9a4:	d51a      	bpl.n	3418b9dc <HAL_RCCEx_PeriphCLKConfig+0x4d0>
    if (PeriphClkInit->I2c1ClockSelection == RCC_I2C1CLKSOURCE_IC10)
3418b9a6:	f8d4 00e8 	ldr.w	r0, [r4, #232]	@ 0xe8
3418b9aa:	4bb0      	ldr	r3, [pc, #704]	@ (3418bc6c <HAL_RCCEx_PeriphCLKConfig+0x760>)
3418b9ac:	4298      	cmp	r0, r3
3418b9ae:	f040 85f9 	bne.w	3418c5a4 <HAL_RCCEx_PeriphCLKConfig+0x1098>
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
3418b9b2:	4aad      	ldr	r2, [pc, #692]	@ (3418bc68 <HAL_RCCEx_PeriphCLKConfig+0x75c>)
3418b9b4:	6d61      	ldr	r1, [r4, #84]	@ 0x54
3418b9b6:	f8d2 30e8 	ldr.w	r3, [r2, #232]	@ 0xe8
3418b9ba:	6d27      	ldr	r7, [r4, #80]	@ 0x50
3418b9bc:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418b9c0:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418b9c4:	3901      	subs	r1, #1
3418b9c6:	433b      	orrs	r3, r7
3418b9c8:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418b9cc:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC10ENS);
3418b9d0:	f44f 7300 	mov.w	r3, #512	@ 0x200
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3418b9d4:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3418b9d8:	f7ff fcb4 	bl	3418b344 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
3418b9dc:	04a8      	lsls	r0, r5, #18
3418b9de:	d51a      	bpl.n	3418ba16 <HAL_RCCEx_PeriphCLKConfig+0x50a>
    if (PeriphClkInit->I2c2ClockSelection == RCC_I2C2CLKSOURCE_IC10)
3418b9e0:	f8d4 00ec 	ldr.w	r0, [r4, #236]	@ 0xec
3418b9e4:	4ba2      	ldr	r3, [pc, #648]	@ (3418bc70 <HAL_RCCEx_PeriphCLKConfig+0x764>)
3418b9e6:	4298      	cmp	r0, r3
3418b9e8:	f040 85fb 	bne.w	3418c5e2 <HAL_RCCEx_PeriphCLKConfig+0x10d6>
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
3418b9ec:	4a9e      	ldr	r2, [pc, #632]	@ (3418bc68 <HAL_RCCEx_PeriphCLKConfig+0x75c>)
3418b9ee:	6d61      	ldr	r1, [r4, #84]	@ 0x54
3418b9f0:	f8d2 30e8 	ldr.w	r3, [r2, #232]	@ 0xe8
3418b9f4:	6d27      	ldr	r7, [r4, #80]	@ 0x50
3418b9f6:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418b9fa:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418b9fe:	3901      	subs	r1, #1
3418ba00:	433b      	orrs	r3, r7
3418ba02:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418ba06:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC10ENS);
3418ba0a:	f44f 7300 	mov.w	r3, #512	@ 0x200
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3418ba0e:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3418ba12:	f7ff fc97 	bl	3418b344 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
3418ba16:	0469      	lsls	r1, r5, #17
3418ba18:	d51a      	bpl.n	3418ba50 <HAL_RCCEx_PeriphCLKConfig+0x544>
    if (PeriphClkInit->I2c3ClockSelection == RCC_I2C3CLKSOURCE_IC10)
3418ba1a:	f8d4 00f0 	ldr.w	r0, [r4, #240]	@ 0xf0
3418ba1e:	4b95      	ldr	r3, [pc, #596]	@ (3418bc74 <HAL_RCCEx_PeriphCLKConfig+0x768>)
3418ba20:	4298      	cmp	r0, r3
3418ba22:	f040 85fd 	bne.w	3418c620 <HAL_RCCEx_PeriphCLKConfig+0x1114>
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
3418ba26:	4a90      	ldr	r2, [pc, #576]	@ (3418bc68 <HAL_RCCEx_PeriphCLKConfig+0x75c>)
3418ba28:	6d61      	ldr	r1, [r4, #84]	@ 0x54
3418ba2a:	f8d2 30e8 	ldr.w	r3, [r2, #232]	@ 0xe8
3418ba2e:	6d27      	ldr	r7, [r4, #80]	@ 0x50
3418ba30:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418ba34:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418ba38:	3901      	subs	r1, #1
3418ba3a:	433b      	orrs	r3, r7
3418ba3c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418ba40:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC10ENS);
3418ba44:	f44f 7300 	mov.w	r3, #512	@ 0x200
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3418ba48:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3418ba4c:	f7ff fc7a 	bl	3418b344 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
3418ba50:	042a      	lsls	r2, r5, #16
3418ba52:	d51a      	bpl.n	3418ba8a <HAL_RCCEx_PeriphCLKConfig+0x57e>
    if (PeriphClkInit->I2c4ClockSelection == RCC_I2C4CLKSOURCE_IC10)
3418ba54:	f8d4 00f4 	ldr.w	r0, [r4, #244]	@ 0xf4
3418ba58:	4b87      	ldr	r3, [pc, #540]	@ (3418bc78 <HAL_RCCEx_PeriphCLKConfig+0x76c>)
3418ba5a:	4298      	cmp	r0, r3
3418ba5c:	f040 85ff 	bne.w	3418c65e <HAL_RCCEx_PeriphCLKConfig+0x1152>
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
3418ba60:	4a81      	ldr	r2, [pc, #516]	@ (3418bc68 <HAL_RCCEx_PeriphCLKConfig+0x75c>)
3418ba62:	6d61      	ldr	r1, [r4, #84]	@ 0x54
3418ba64:	f8d2 30e8 	ldr.w	r3, [r2, #232]	@ 0xe8
3418ba68:	6d27      	ldr	r7, [r4, #80]	@ 0x50
3418ba6a:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418ba6e:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418ba72:	3901      	subs	r1, #1
3418ba74:	433b      	orrs	r3, r7
3418ba76:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418ba7a:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC10ENS);
3418ba7e:	f44f 7300 	mov.w	r3, #512	@ 0x200
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3418ba82:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3418ba86:	f7ff fc5d 	bl	3418b344 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I3C1) == RCC_PERIPHCLK_I3C1)
3418ba8a:	03eb      	lsls	r3, r5, #15
3418ba8c:	d51a      	bpl.n	3418bac4 <HAL_RCCEx_PeriphCLKConfig+0x5b8>
    if (PeriphClkInit->I3c1ClockSelection == RCC_I3C1CLKSOURCE_IC10)
3418ba8e:	f8d4 00f8 	ldr.w	r0, [r4, #248]	@ 0xf8
3418ba92:	4b7a      	ldr	r3, [pc, #488]	@ (3418bc7c <HAL_RCCEx_PeriphCLKConfig+0x770>)
3418ba94:	4298      	cmp	r0, r3
3418ba96:	f040 8627 	bne.w	3418c6e8 <HAL_RCCEx_PeriphCLKConfig+0x11dc>
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
3418ba9a:	4a73      	ldr	r2, [pc, #460]	@ (3418bc68 <HAL_RCCEx_PeriphCLKConfig+0x75c>)
3418ba9c:	6d61      	ldr	r1, [r4, #84]	@ 0x54
3418ba9e:	f8d2 30e8 	ldr.w	r3, [r2, #232]	@ 0xe8
3418baa2:	6d27      	ldr	r7, [r4, #80]	@ 0x50
3418baa4:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418baa8:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418baac:	3901      	subs	r1, #1
3418baae:	433b      	orrs	r3, r7
3418bab0:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418bab4:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC10ENS);
3418bab8:	f44f 7300 	mov.w	r3, #512	@ 0x200
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3418babc:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3418bac0:	f7ff fc40 	bl	3418b344 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I3C2) == RCC_PERIPHCLK_I3C2)
3418bac4:	03af      	lsls	r7, r5, #14
3418bac6:	d51a      	bpl.n	3418bafe <HAL_RCCEx_PeriphCLKConfig+0x5f2>
    if (PeriphClkInit->I3c2ClockSelection == RCC_I3C2CLKSOURCE_IC10)
3418bac8:	f8d4 00fc 	ldr.w	r0, [r4, #252]	@ 0xfc
3418bacc:	4b6c      	ldr	r3, [pc, #432]	@ (3418bc80 <HAL_RCCEx_PeriphCLKConfig+0x774>)
3418bace:	4298      	cmp	r0, r3
3418bad0:	f040 8629 	bne.w	3418c726 <HAL_RCCEx_PeriphCLKConfig+0x121a>
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
3418bad4:	4a64      	ldr	r2, [pc, #400]	@ (3418bc68 <HAL_RCCEx_PeriphCLKConfig+0x75c>)
3418bad6:	6d61      	ldr	r1, [r4, #84]	@ 0x54
3418bad8:	f8d2 30e8 	ldr.w	r3, [r2, #232]	@ 0xe8
3418badc:	6d27      	ldr	r7, [r4, #80]	@ 0x50
3418bade:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418bae2:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418bae6:	3901      	subs	r1, #1
3418bae8:	433b      	orrs	r3, r7
3418baea:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418baee:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC10ENS);
3418baf2:	f44f 7300 	mov.w	r3, #512	@ 0x200
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3418baf6:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3418bafa:	f7ff fc23 	bl	3418b344 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
3418bafe:	0368      	lsls	r0, r5, #13
3418bb00:	d51a      	bpl.n	3418bb38 <HAL_RCCEx_PeriphCLKConfig+0x62c>
    if (PeriphClkInit->Lptim1ClockSelection == RCC_LPTIM1CLKSOURCE_IC15)
3418bb02:	f8d4 0100 	ldr.w	r0, [r4, #256]	@ 0x100
3418bb06:	4b5f      	ldr	r3, [pc, #380]	@ (3418bc84 <HAL_RCCEx_PeriphCLKConfig+0x778>)
3418bb08:	4298      	cmp	r0, r3
3418bb0a:	f040 862b 	bne.w	3418c764 <HAL_RCCEx_PeriphCLKConfig+0x1258>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3418bb0e:	4a56      	ldr	r2, [pc, #344]	@ (3418bc68 <HAL_RCCEx_PeriphCLKConfig+0x75c>)
3418bb10:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3418bb12:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3418bb16:	6fa7      	ldr	r7, [r4, #120]	@ 0x78
3418bb18:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418bb1c:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418bb20:	3901      	subs	r1, #1
3418bb22:	433b      	orrs	r3, r7
3418bb24:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418bb28:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3418bb2c:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3418bb30:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3418bb34:	f7ff fc06 	bl	3418b344 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM2) == RCC_PERIPHCLK_LPTIM2)
3418bb38:	0329      	lsls	r1, r5, #12
3418bb3a:	d51a      	bpl.n	3418bb72 <HAL_RCCEx_PeriphCLKConfig+0x666>
    if (PeriphClkInit->Lptim2ClockSelection == RCC_LPTIM2CLKSOURCE_IC15)
3418bb3c:	f8d4 0104 	ldr.w	r0, [r4, #260]	@ 0x104
3418bb40:	4b51      	ldr	r3, [pc, #324]	@ (3418bc88 <HAL_RCCEx_PeriphCLKConfig+0x77c>)
3418bb42:	4298      	cmp	r0, r3
3418bb44:	f040 8617 	bne.w	3418c776 <HAL_RCCEx_PeriphCLKConfig+0x126a>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3418bb48:	4a47      	ldr	r2, [pc, #284]	@ (3418bc68 <HAL_RCCEx_PeriphCLKConfig+0x75c>)
3418bb4a:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3418bb4c:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3418bb50:	6fa7      	ldr	r7, [r4, #120]	@ 0x78
3418bb52:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418bb56:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418bb5a:	3901      	subs	r1, #1
3418bb5c:	433b      	orrs	r3, r7
3418bb5e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418bb62:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3418bb66:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3418bb6a:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3418bb6e:	f7ff fbe9 	bl	3418b344 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM3) == RCC_PERIPHCLK_LPTIM3)
3418bb72:	02ea      	lsls	r2, r5, #11
3418bb74:	d51a      	bpl.n	3418bbac <HAL_RCCEx_PeriphCLKConfig+0x6a0>
    if (PeriphClkInit->Lptim3ClockSelection == RCC_LPTIM3CLKSOURCE_IC15)
3418bb76:	f8d4 0108 	ldr.w	r0, [r4, #264]	@ 0x108
3418bb7a:	4b44      	ldr	r3, [pc, #272]	@ (3418bc8c <HAL_RCCEx_PeriphCLKConfig+0x780>)
3418bb7c:	4298      	cmp	r0, r3
3418bb7e:	f040 8603 	bne.w	3418c788 <HAL_RCCEx_PeriphCLKConfig+0x127c>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3418bb82:	4a39      	ldr	r2, [pc, #228]	@ (3418bc68 <HAL_RCCEx_PeriphCLKConfig+0x75c>)
3418bb84:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3418bb86:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3418bb8a:	6fa7      	ldr	r7, [r4, #120]	@ 0x78
3418bb8c:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418bb90:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418bb94:	3901      	subs	r1, #1
3418bb96:	433b      	orrs	r3, r7
3418bb98:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418bb9c:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3418bba0:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3418bba4:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3418bba8:	f7ff fbcc 	bl	3418b344 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM4) == RCC_PERIPHCLK_LPTIM4)
3418bbac:	02ab      	lsls	r3, r5, #10
3418bbae:	d51a      	bpl.n	3418bbe6 <HAL_RCCEx_PeriphCLKConfig+0x6da>
    if (PeriphClkInit->Lptim4ClockSelection == RCC_LPTIM4CLKSOURCE_IC15)
3418bbb0:	f8d4 010c 	ldr.w	r0, [r4, #268]	@ 0x10c
3418bbb4:	4b36      	ldr	r3, [pc, #216]	@ (3418bc90 <HAL_RCCEx_PeriphCLKConfig+0x784>)
3418bbb6:	4298      	cmp	r0, r3
3418bbb8:	f040 85ef 	bne.w	3418c79a <HAL_RCCEx_PeriphCLKConfig+0x128e>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3418bbbc:	4a2a      	ldr	r2, [pc, #168]	@ (3418bc68 <HAL_RCCEx_PeriphCLKConfig+0x75c>)
3418bbbe:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3418bbc0:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3418bbc4:	6fa7      	ldr	r7, [r4, #120]	@ 0x78
3418bbc6:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418bbca:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418bbce:	3901      	subs	r1, #1
3418bbd0:	433b      	orrs	r3, r7
3418bbd2:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418bbd6:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3418bbda:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3418bbde:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3418bbe2:	f7ff fbaf 	bl	3418b344 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM5) == RCC_PERIPHCLK_LPTIM5)
3418bbe6:	026f      	lsls	r7, r5, #9
3418bbe8:	d51a      	bpl.n	3418bc20 <HAL_RCCEx_PeriphCLKConfig+0x714>
    if (PeriphClkInit->Lptim5ClockSelection == RCC_LPTIM5CLKSOURCE_IC15)
3418bbea:	f8d4 0110 	ldr.w	r0, [r4, #272]	@ 0x110
3418bbee:	4b29      	ldr	r3, [pc, #164]	@ (3418bc94 <HAL_RCCEx_PeriphCLKConfig+0x788>)
3418bbf0:	4298      	cmp	r0, r3
3418bbf2:	f040 85db 	bne.w	3418c7ac <HAL_RCCEx_PeriphCLKConfig+0x12a0>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3418bbf6:	4a1c      	ldr	r2, [pc, #112]	@ (3418bc68 <HAL_RCCEx_PeriphCLKConfig+0x75c>)
3418bbf8:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3418bbfa:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3418bbfe:	6fa7      	ldr	r7, [r4, #120]	@ 0x78
3418bc00:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418bc04:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418bc08:	3901      	subs	r1, #1
3418bc0a:	433b      	orrs	r3, r7
3418bc0c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418bc10:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3418bc14:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3418bc18:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3418bc1c:	f7ff fb92 	bl	3418b344 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
3418bc20:	0228      	lsls	r0, r5, #8
3418bc22:	d539      	bpl.n	3418bc98 <HAL_RCCEx_PeriphCLKConfig+0x78c>
    if (PeriphClkInit->Lpuart1ClockSelection == RCC_LPUART1CLKSOURCE_IC9)
3418bc24:	f8d4 1114 	ldr.w	r1, [r4, #276]	@ 0x114
3418bc28:	4a0f      	ldr	r2, [pc, #60]	@ (3418bc68 <HAL_RCCEx_PeriphCLKConfig+0x75c>)
3418bc2a:	f5b1 7f00 	cmp.w	r1, #512	@ 0x200
3418bc2e:	f040 85c6 	bne.w	3418c7be <HAL_RCCEx_PeriphCLKConfig+0x12b2>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3418bc32:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3418bc36:	6ce0      	ldr	r0, [r4, #76]	@ 0x4c
3418bc38:	6ca7      	ldr	r7, [r4, #72]	@ 0x48
3418bc3a:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418bc3e:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418bc42:	3801      	subs	r0, #1
3418bc44:	433b      	orrs	r3, r7
3418bc46:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
3418bc4a:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3418bc4e:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3418bc52:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR14, RCC_CCIPR14_LPUART1SEL, ClkSource);
3418bc56:	4a04      	ldr	r2, [pc, #16]	@ (3418bc68 <HAL_RCCEx_PeriphCLKConfig+0x75c>)
3418bc58:	f8d2 3178 	ldr.w	r3, [r2, #376]	@ 0x178
3418bc5c:	f423 63e0 	bic.w	r3, r3, #1792	@ 0x700
3418bc60:	430b      	orrs	r3, r1
3418bc62:	f8c2 3178 	str.w	r3, [r2, #376]	@ 0x178
3418bc66:	e017      	b.n	3418bc98 <HAL_RCCEx_PeriphCLKConfig+0x78c>
3418bc68:	56028000 	.word	0x56028000
3418bc6c:	0702000c 	.word	0x0702000c
3418bc70:	0702040c 	.word	0x0702040c
3418bc74:	0702080c 	.word	0x0702080c
3418bc78:	07020c0c 	.word	0x07020c0c
3418bc7c:	0702100c 	.word	0x0702100c
3418bc80:	0702140c 	.word	0x0702140c
3418bc84:	0702082c 	.word	0x0702082c
3418bc88:	07020c2c 	.word	0x07020c2c
3418bc8c:	0702102c 	.word	0x0702102c
3418bc90:	0702142c 	.word	0x0702142c
3418bc94:	0702182c 	.word	0x0702182c
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
3418bc98:	01e9      	lsls	r1, r5, #7
3418bc9a:	d522      	bpl.n	3418bce2 <HAL_RCCEx_PeriphCLKConfig+0x7d6>
    if (PeriphClkInit->LtdcClockSelection == RCC_LTDCCLKSOURCE_IC16)
3418bc9c:	f8d4 1118 	ldr.w	r1, [r4, #280]	@ 0x118
3418bca0:	4ac9      	ldr	r2, [pc, #804]	@ (3418bfc8 <HAL_RCCEx_PeriphCLKConfig+0xabc>)
3418bca2:	f1b1 7f00 	cmp.w	r1, #33554432	@ 0x2000000
3418bca6:	f040 85a7 	bne.w	3418c7f8 <HAL_RCCEx_PeriphCLKConfig+0x12ec>
      MODIFY_REG(RCC->IC16CFGR, RCC_IC16CFGR_IC16SEL | RCC_IC16CFGR_IC16INT,
3418bcaa:	f8d2 3100 	ldr.w	r3, [r2, #256]	@ 0x100
3418bcae:	f8d4 0084 	ldr.w	r0, [r4, #132]	@ 0x84
3418bcb2:	f8d4 7080 	ldr.w	r7, [r4, #128]	@ 0x80
3418bcb6:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418bcba:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418bcbe:	3801      	subs	r0, #1
3418bcc0:	433b      	orrs	r3, r7
3418bcc2:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
3418bcc6:	f8c2 3100 	str.w	r3, [r2, #256]	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC16ENS);
3418bcca:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
3418bcce:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR4, RCC_CCIPR4_LTDCSEL, ClkSource);
3418bcd2:	4abd      	ldr	r2, [pc, #756]	@ (3418bfc8 <HAL_RCCEx_PeriphCLKConfig+0xabc>)
3418bcd4:	f8d2 3150 	ldr.w	r3, [r2, #336]	@ 0x150
3418bcd8:	f023 7340 	bic.w	r3, r3, #50331648	@ 0x3000000
3418bcdc:	430b      	orrs	r3, r1
3418bcde:	f8c2 3150 	str.w	r3, [r2, #336]	@ 0x150
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_MDF1) == RCC_PERIPHCLK_MDF1)
3418bce2:	01aa      	lsls	r2, r5, #6
3418bce4:	d51f      	bpl.n	3418bd26 <HAL_RCCEx_PeriphCLKConfig+0x81a>
    if (PeriphClkInit->Mdf1ClockSelection == RCC_MDF1CLKSOURCE_IC7)
3418bce6:	f8d4 111c 	ldr.w	r1, [r4, #284]	@ 0x11c
3418bcea:	4ab7      	ldr	r2, [pc, #732]	@ (3418bfc8 <HAL_RCCEx_PeriphCLKConfig+0xabc>)
3418bcec:	f5b1 3f00 	cmp.w	r1, #131072	@ 0x20000
3418bcf0:	f040 858a 	bne.w	3418c808 <HAL_RCCEx_PeriphCLKConfig+0x12fc>
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
3418bcf4:	f8d2 30dc 	ldr.w	r3, [r2, #220]	@ 0xdc
3418bcf8:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
3418bcfa:	6ba7      	ldr	r7, [r4, #56]	@ 0x38
3418bcfc:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418bd00:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418bd04:	3801      	subs	r0, #1
3418bd06:	433b      	orrs	r3, r7
3418bd08:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
3418bd0c:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC7ENS);
3418bd10:	2340      	movs	r3, #64	@ 0x40
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3418bd12:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR5, RCC_CCIPR5_MDF1SEL, ClkSource);
3418bd16:	4aac      	ldr	r2, [pc, #688]	@ (3418bfc8 <HAL_RCCEx_PeriphCLKConfig+0xabc>)
3418bd18:	f8d2 3154 	ldr.w	r3, [r2, #340]	@ 0x154
3418bd1c:	f423 23e0 	bic.w	r3, r3, #458752	@ 0x70000
3418bd20:	430b      	orrs	r3, r1
3418bd22:	f8c2 3154 	str.w	r3, [r2, #340]	@ 0x154
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PSSI) == RCC_PERIPHCLK_PSSI)
3418bd26:	016b      	lsls	r3, r5, #5
3418bd28:	d521      	bpl.n	3418bd6e <HAL_RCCEx_PeriphCLKConfig+0x862>
    if (PeriphClkInit->PssiClockSelection == RCC_PSSICLKSOURCE_IC20)
3418bd2a:	f8d4 1120 	ldr.w	r1, [r4, #288]	@ 0x120
3418bd2e:	4aa6      	ldr	r2, [pc, #664]	@ (3418bfc8 <HAL_RCCEx_PeriphCLKConfig+0xabc>)
3418bd30:	2920      	cmp	r1, #32
3418bd32:	f040 8585 	bne.w	3418c840 <HAL_RCCEx_PeriphCLKConfig+0x1334>
      MODIFY_REG(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL | RCC_IC20CFGR_IC20INT,
3418bd36:	f8d2 3110 	ldr.w	r3, [r2, #272]	@ 0x110
3418bd3a:	f8d4 00a4 	ldr.w	r0, [r4, #164]	@ 0xa4
3418bd3e:	f8d4 70a0 	ldr.w	r7, [r4, #160]	@ 0xa0
3418bd42:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418bd46:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418bd4a:	3801      	subs	r0, #1
3418bd4c:	433b      	orrs	r3, r7
3418bd4e:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
3418bd52:	f8c2 3110 	str.w	r3, [r2, #272]	@ 0x110
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC20ENS);
3418bd56:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
3418bd5a:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_PSSISEL, ClkSource);
3418bd5e:	4a9a      	ldr	r2, [pc, #616]	@ (3418bfc8 <HAL_RCCEx_PeriphCLKConfig+0xabc>)
3418bd60:	f8d2 315c 	ldr.w	r3, [r2, #348]	@ 0x15c
3418bd64:	f023 0330 	bic.w	r3, r3, #48	@ 0x30
3418bd68:	430b      	orrs	r3, r1
3418bd6a:	f8c2 315c 	str.w	r3, [r2, #348]	@ 0x15c
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1)
3418bd6e:	00ef      	lsls	r7, r5, #3
3418bd70:	d519      	bpl.n	3418bda6 <HAL_RCCEx_PeriphCLKConfig+0x89a>
    if (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_IC7)
3418bd72:	f8d4 0124 	ldr.w	r0, [r4, #292]	@ 0x124
3418bd76:	4b95      	ldr	r3, [pc, #596]	@ (3418bfcc <HAL_RCCEx_PeriphCLKConfig+0xac0>)
3418bd78:	4298      	cmp	r0, r3
3418bd7a:	f040 8568 	bne.w	3418c84e <HAL_RCCEx_PeriphCLKConfig+0x1342>
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
3418bd7e:	4a92      	ldr	r2, [pc, #584]	@ (3418bfc8 <HAL_RCCEx_PeriphCLKConfig+0xabc>)
3418bd80:	6be1      	ldr	r1, [r4, #60]	@ 0x3c
3418bd82:	f8d2 30dc 	ldr.w	r3, [r2, #220]	@ 0xdc
3418bd86:	6ba7      	ldr	r7, [r4, #56]	@ 0x38
3418bd88:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418bd8c:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418bd90:	3901      	subs	r1, #1
3418bd92:	433b      	orrs	r3, r7
3418bd94:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418bd98:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC7ENS);
3418bd9c:	2340      	movs	r3, #64	@ 0x40
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3418bd9e:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3418bda2:	f7ff facf 	bl	3418b344 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2)
3418bda6:	00ad      	lsls	r5, r5, #2
3418bda8:	d519      	bpl.n	3418bdde <HAL_RCCEx_PeriphCLKConfig+0x8d2>
    if (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_IC7)
3418bdaa:	f8d4 0128 	ldr.w	r0, [r4, #296]	@ 0x128
3418bdae:	4b88      	ldr	r3, [pc, #544]	@ (3418bfd0 <HAL_RCCEx_PeriphCLKConfig+0xac4>)
3418bdb0:	4298      	cmp	r0, r3
3418bdb2:	f040 856a 	bne.w	3418c88a <HAL_RCCEx_PeriphCLKConfig+0x137e>
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
3418bdb6:	4a84      	ldr	r2, [pc, #528]	@ (3418bfc8 <HAL_RCCEx_PeriphCLKConfig+0xabc>)
3418bdb8:	6be1      	ldr	r1, [r4, #60]	@ 0x3c
3418bdba:	f8d2 30dc 	ldr.w	r3, [r2, #220]	@ 0xdc
3418bdbe:	6ba5      	ldr	r5, [r4, #56]	@ 0x38
3418bdc0:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418bdc4:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418bdc8:	3901      	subs	r1, #1
3418bdca:	432b      	orrs	r3, r5
3418bdcc:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418bdd0:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC7ENS);
3418bdd4:	2340      	movs	r3, #64	@ 0x40
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3418bdd6:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3418bdda:	f7ff fab3 	bl	3418b344 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPDIFRX1) == RCC_PERIPHCLK_SPDIFRX1)
3418bdde:	07f0      	lsls	r0, r6, #31
3418bde0:	d51e      	bpl.n	3418be20 <HAL_RCCEx_PeriphCLKConfig+0x914>
    if (PeriphClkInit->Spdifrx1ClockSelection == RCC_SPDIFRX1CLKSOURCE_IC7)
3418bde2:	f8d4 114c 	ldr.w	r1, [r4, #332]	@ 0x14c
3418bde6:	4a78      	ldr	r2, [pc, #480]	@ (3418bfc8 <HAL_RCCEx_PeriphCLKConfig+0xabc>)
3418bde8:	2902      	cmp	r1, #2
3418bdea:	f040 856c 	bne.w	3418c8c6 <HAL_RCCEx_PeriphCLKConfig+0x13ba>
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
3418bdee:	f8d2 30dc 	ldr.w	r3, [r2, #220]	@ 0xdc
3418bdf2:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
3418bdf4:	6ba5      	ldr	r5, [r4, #56]	@ 0x38
3418bdf6:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418bdfa:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418bdfe:	3801      	subs	r0, #1
3418be00:	432b      	orrs	r3, r5
3418be02:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
3418be06:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC7ENS);
3418be0a:	2340      	movs	r3, #64	@ 0x40
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3418be0c:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  MODIFY_REG(RCC->CCIPR9, RCC_CCIPR9_SPDIFRX1SEL, ClkSource);
3418be10:	4a6d      	ldr	r2, [pc, #436]	@ (3418bfc8 <HAL_RCCEx_PeriphCLKConfig+0xabc>)
3418be12:	f8d2 3164 	ldr.w	r3, [r2, #356]	@ 0x164
3418be16:	f023 0307 	bic.w	r3, r3, #7
3418be1a:	430b      	orrs	r3, r1
3418be1c:	f8c2 3164 	str.w	r3, [r2, #356]	@ 0x164
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI1) == RCC_PERIPHCLK_SPI1)
3418be20:	07b1      	lsls	r1, r6, #30
3418be22:	d519      	bpl.n	3418be58 <HAL_RCCEx_PeriphCLKConfig+0x94c>
    if (PeriphClkInit->Spi1ClockSelection == RCC_SPI1CLKSOURCE_IC8)
3418be24:	f8d4 0134 	ldr.w	r0, [r4, #308]	@ 0x134
3418be28:	4b6a      	ldr	r3, [pc, #424]	@ (3418bfd4 <HAL_RCCEx_PeriphCLKConfig+0xac8>)
3418be2a:	4298      	cmp	r0, r3
3418be2c:	f040 8565 	bne.w	3418c8fa <HAL_RCCEx_PeriphCLKConfig+0x13ee>
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3418be30:	4a65      	ldr	r2, [pc, #404]	@ (3418bfc8 <HAL_RCCEx_PeriphCLKConfig+0xabc>)
3418be32:	6c61      	ldr	r1, [r4, #68]	@ 0x44
3418be34:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
3418be38:	6c25      	ldr	r5, [r4, #64]	@ 0x40
3418be3a:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418be3e:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418be42:	3901      	subs	r1, #1
3418be44:	432b      	orrs	r3, r5
3418be46:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418be4a:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3418be4e:	2380      	movs	r3, #128	@ 0x80
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3418be50:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3418be54:	f7ff fa76 	bl	3418b344 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI2) == RCC_PERIPHCLK_SPI2)
3418be58:	0772      	lsls	r2, r6, #29
3418be5a:	d519      	bpl.n	3418be90 <HAL_RCCEx_PeriphCLKConfig+0x984>
    if (PeriphClkInit->Spi2ClockSelection == RCC_SPI2CLKSOURCE_IC8)
3418be5c:	f8d4 0138 	ldr.w	r0, [r4, #312]	@ 0x138
3418be60:	4b5d      	ldr	r3, [pc, #372]	@ (3418bfd8 <HAL_RCCEx_PeriphCLKConfig+0xacc>)
3418be62:	4298      	cmp	r0, r3
3418be64:	f040 8568 	bne.w	3418c938 <HAL_RCCEx_PeriphCLKConfig+0x142c>
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3418be68:	4a57      	ldr	r2, [pc, #348]	@ (3418bfc8 <HAL_RCCEx_PeriphCLKConfig+0xabc>)
3418be6a:	6c61      	ldr	r1, [r4, #68]	@ 0x44
3418be6c:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
3418be70:	6c25      	ldr	r5, [r4, #64]	@ 0x40
3418be72:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418be76:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418be7a:	3901      	subs	r1, #1
3418be7c:	432b      	orrs	r3, r5
3418be7e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418be82:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3418be86:	2380      	movs	r3, #128	@ 0x80
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3418be88:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3418be8c:	f7ff fa5a 	bl	3418b344 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI3) == RCC_PERIPHCLK_SPI3)
3418be90:	0733      	lsls	r3, r6, #28
3418be92:	d519      	bpl.n	3418bec8 <HAL_RCCEx_PeriphCLKConfig+0x9bc>
    if (PeriphClkInit->Spi3ClockSelection == RCC_SPI3CLKSOURCE_IC8)
3418be94:	f8d4 013c 	ldr.w	r0, [r4, #316]	@ 0x13c
3418be98:	4b50      	ldr	r3, [pc, #320]	@ (3418bfdc <HAL_RCCEx_PeriphCLKConfig+0xad0>)
3418be9a:	4298      	cmp	r0, r3
3418be9c:	f040 856b 	bne.w	3418c976 <HAL_RCCEx_PeriphCLKConfig+0x146a>
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3418bea0:	4a49      	ldr	r2, [pc, #292]	@ (3418bfc8 <HAL_RCCEx_PeriphCLKConfig+0xabc>)
3418bea2:	6c61      	ldr	r1, [r4, #68]	@ 0x44
3418bea4:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
3418bea8:	6c25      	ldr	r5, [r4, #64]	@ 0x40
3418beaa:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418beae:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418beb2:	3901      	subs	r1, #1
3418beb4:	432b      	orrs	r3, r5
3418beb6:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418beba:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3418bebe:	2380      	movs	r3, #128	@ 0x80
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3418bec0:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3418bec4:	f7ff fa3e 	bl	3418b344 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI4) == RCC_PERIPHCLK_SPI4)
3418bec8:	06f7      	lsls	r7, r6, #27
3418beca:	d51a      	bpl.n	3418bf02 <HAL_RCCEx_PeriphCLKConfig+0x9f6>
    if (PeriphClkInit->Spi4ClockSelection == RCC_SPI4CLKSOURCE_IC9)
3418becc:	f8d4 0140 	ldr.w	r0, [r4, #320]	@ 0x140
3418bed0:	4b43      	ldr	r3, [pc, #268]	@ (3418bfe0 <HAL_RCCEx_PeriphCLKConfig+0xad4>)
3418bed2:	4298      	cmp	r0, r3
3418bed4:	f040 8596 	bne.w	3418ca04 <HAL_RCCEx_PeriphCLKConfig+0x14f8>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3418bed8:	4a3b      	ldr	r2, [pc, #236]	@ (3418bfc8 <HAL_RCCEx_PeriphCLKConfig+0xabc>)
3418beda:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3418bedc:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3418bee0:	6ca5      	ldr	r5, [r4, #72]	@ 0x48
3418bee2:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418bee6:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418beea:	3901      	subs	r1, #1
3418beec:	432b      	orrs	r3, r5
3418beee:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418bef2:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3418bef6:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3418befa:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3418befe:	f7ff fa21 	bl	3418b344 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI5) == RCC_PERIPHCLK_SPI5)
3418bf02:	06b5      	lsls	r5, r6, #26
3418bf04:	d51a      	bpl.n	3418bf3c <HAL_RCCEx_PeriphCLKConfig+0xa30>
    if (PeriphClkInit->Spi5ClockSelection == RCC_SPI5CLKSOURCE_IC9)
3418bf06:	f8d4 0144 	ldr.w	r0, [r4, #324]	@ 0x144
3418bf0a:	4b36      	ldr	r3, [pc, #216]	@ (3418bfe4 <HAL_RCCEx_PeriphCLKConfig+0xad8>)
3418bf0c:	4298      	cmp	r0, r3
3418bf0e:	f040 8598 	bne.w	3418ca42 <HAL_RCCEx_PeriphCLKConfig+0x1536>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3418bf12:	4a2d      	ldr	r2, [pc, #180]	@ (3418bfc8 <HAL_RCCEx_PeriphCLKConfig+0xabc>)
3418bf14:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3418bf16:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3418bf1a:	6ca5      	ldr	r5, [r4, #72]	@ 0x48
3418bf1c:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418bf20:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418bf24:	3901      	subs	r1, #1
3418bf26:	432b      	orrs	r3, r5
3418bf28:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418bf2c:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3418bf30:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3418bf34:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3418bf38:	f7ff fa04 	bl	3418b344 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI6) == RCC_PERIPHCLK_SPI6)
3418bf3c:	0670      	lsls	r0, r6, #25
3418bf3e:	d519      	bpl.n	3418bf74 <HAL_RCCEx_PeriphCLKConfig+0xa68>
    if (PeriphClkInit->Spi6ClockSelection == RCC_SPI6CLKSOURCE_IC8)
3418bf40:	f8d4 0148 	ldr.w	r0, [r4, #328]	@ 0x148
3418bf44:	4b28      	ldr	r3, [pc, #160]	@ (3418bfe8 <HAL_RCCEx_PeriphCLKConfig+0xadc>)
3418bf46:	4298      	cmp	r0, r3
3418bf48:	f040 859a 	bne.w	3418ca80 <HAL_RCCEx_PeriphCLKConfig+0x1574>
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3418bf4c:	4a1e      	ldr	r2, [pc, #120]	@ (3418bfc8 <HAL_RCCEx_PeriphCLKConfig+0xabc>)
3418bf4e:	6c61      	ldr	r1, [r4, #68]	@ 0x44
3418bf50:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
3418bf54:	6c25      	ldr	r5, [r4, #64]	@ 0x40
3418bf56:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418bf5a:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418bf5e:	3901      	subs	r1, #1
3418bf60:	432b      	orrs	r3, r5
3418bf62:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418bf66:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3418bf6a:	2380      	movs	r3, #128	@ 0x80
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3418bf6c:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3418bf70:	f7ff f9e8 	bl	3418b344 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
3418bf74:	05f1      	lsls	r1, r6, #23
3418bf76:	d51a      	bpl.n	3418bfae <HAL_RCCEx_PeriphCLKConfig+0xaa2>
    if (PeriphClkInit->Usart1ClockSelection == RCC_USART1CLKSOURCE_IC9)
3418bf78:	f8d4 0150 	ldr.w	r0, [r4, #336]	@ 0x150
3418bf7c:	4b1b      	ldr	r3, [pc, #108]	@ (3418bfec <HAL_RCCEx_PeriphCLKConfig+0xae0>)
3418bf7e:	4298      	cmp	r0, r3
3418bf80:	f040 859d 	bne.w	3418cabe <HAL_RCCEx_PeriphCLKConfig+0x15b2>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3418bf84:	4a10      	ldr	r2, [pc, #64]	@ (3418bfc8 <HAL_RCCEx_PeriphCLKConfig+0xabc>)
3418bf86:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3418bf88:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3418bf8c:	6ca5      	ldr	r5, [r4, #72]	@ 0x48
3418bf8e:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418bf92:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418bf96:	3901      	subs	r1, #1
3418bf98:	432b      	orrs	r3, r5
3418bf9a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418bf9e:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3418bfa2:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3418bfa6:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3418bfaa:	f7ff f9cb 	bl	3418b344 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
3418bfae:	05b2      	lsls	r2, r6, #22
3418bfb0:	d531      	bpl.n	3418c016 <HAL_RCCEx_PeriphCLKConfig+0xb0a>
    if (PeriphClkInit->Usart2ClockSelection == RCC_USART2CLKSOURCE_IC9)
3418bfb2:	f8d4 0154 	ldr.w	r0, [r4, #340]	@ 0x154
3418bfb6:	4b0e      	ldr	r3, [pc, #56]	@ (3418bff0 <HAL_RCCEx_PeriphCLKConfig+0xae4>)
3418bfb8:	4298      	cmp	r0, r3
3418bfba:	f040 859f 	bne.w	3418cafc <HAL_RCCEx_PeriphCLKConfig+0x15f0>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3418bfbe:	4a02      	ldr	r2, [pc, #8]	@ (3418bfc8 <HAL_RCCEx_PeriphCLKConfig+0xabc>)
3418bfc0:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3418bfc2:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3418bfc6:	e015      	b.n	3418bff4 <HAL_RCCEx_PeriphCLKConfig+0xae8>
3418bfc8:	56028000 	.word	0x56028000
3418bfcc:	07021418 	.word	0x07021418
3418bfd0:	07021818 	.word	0x07021818
3418bfd4:	07020420 	.word	0x07020420
3418bfd8:	07020820 	.word	0x07020820
3418bfdc:	07020c20 	.word	0x07020c20
3418bfe0:	07021020 	.word	0x07021020
3418bfe4:	07021420 	.word	0x07021420
3418bfe8:	07021820 	.word	0x07021820
3418bfec:	07020030 	.word	0x07020030
3418bff0:	07020430 	.word	0x07020430
3418bff4:	6ca5      	ldr	r5, [r4, #72]	@ 0x48
3418bff6:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418bffa:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418bffe:	3901      	subs	r1, #1
3418c000:	432b      	orrs	r3, r5
3418c002:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418c006:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3418c00a:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3418c00e:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3418c012:	f7ff f997 	bl	3418b344 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
3418c016:	0573      	lsls	r3, r6, #21
3418c018:	d51a      	bpl.n	3418c050 <HAL_RCCEx_PeriphCLKConfig+0xb44>
    if (PeriphClkInit->Usart3ClockSelection == RCC_USART3CLKSOURCE_IC9)
3418c01a:	f8d4 0158 	ldr.w	r0, [r4, #344]	@ 0x158
3418c01e:	4bcb      	ldr	r3, [pc, #812]	@ (3418c34c <HAL_RCCEx_PeriphCLKConfig+0xe40>)
3418c020:	4298      	cmp	r0, r3
3418c022:	f040 858a 	bne.w	3418cb3a <HAL_RCCEx_PeriphCLKConfig+0x162e>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3418c026:	4aca      	ldr	r2, [pc, #808]	@ (3418c350 <HAL_RCCEx_PeriphCLKConfig+0xe44>)
3418c028:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3418c02a:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3418c02e:	6ca5      	ldr	r5, [r4, #72]	@ 0x48
3418c030:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418c034:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418c038:	3901      	subs	r1, #1
3418c03a:	432b      	orrs	r3, r5
3418c03c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418c040:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3418c044:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3418c048:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3418c04c:	f7ff f97a 	bl	3418b344 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
3418c050:	0537      	lsls	r7, r6, #20
3418c052:	d51a      	bpl.n	3418c08a <HAL_RCCEx_PeriphCLKConfig+0xb7e>
    if (PeriphClkInit->Uart4ClockSelection == RCC_UART4CLKSOURCE_IC9)
3418c054:	f8d4 015c 	ldr.w	r0, [r4, #348]	@ 0x15c
3418c058:	4bbe      	ldr	r3, [pc, #760]	@ (3418c354 <HAL_RCCEx_PeriphCLKConfig+0xe48>)
3418c05a:	4298      	cmp	r0, r3
3418c05c:	f040 858c 	bne.w	3418cb78 <HAL_RCCEx_PeriphCLKConfig+0x166c>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3418c060:	4abb      	ldr	r2, [pc, #748]	@ (3418c350 <HAL_RCCEx_PeriphCLKConfig+0xe44>)
3418c062:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3418c064:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3418c068:	6ca5      	ldr	r5, [r4, #72]	@ 0x48
3418c06a:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418c06e:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418c072:	3901      	subs	r1, #1
3418c074:	432b      	orrs	r3, r5
3418c076:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418c07a:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3418c07e:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3418c082:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3418c086:	f7ff f95d 	bl	3418b344 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
3418c08a:	04f5      	lsls	r5, r6, #19
3418c08c:	d51a      	bpl.n	3418c0c4 <HAL_RCCEx_PeriphCLKConfig+0xbb8>
    if (PeriphClkInit->Uart5ClockSelection == RCC_UART5CLKSOURCE_IC9)
3418c08e:	f8d4 0160 	ldr.w	r0, [r4, #352]	@ 0x160
3418c092:	4bb1      	ldr	r3, [pc, #708]	@ (3418c358 <HAL_RCCEx_PeriphCLKConfig+0xe4c>)
3418c094:	4298      	cmp	r0, r3
3418c096:	f040 858e 	bne.w	3418cbb6 <HAL_RCCEx_PeriphCLKConfig+0x16aa>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3418c09a:	4aad      	ldr	r2, [pc, #692]	@ (3418c350 <HAL_RCCEx_PeriphCLKConfig+0xe44>)
3418c09c:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3418c09e:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3418c0a2:	6ca5      	ldr	r5, [r4, #72]	@ 0x48
3418c0a4:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418c0a8:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418c0ac:	3901      	subs	r1, #1
3418c0ae:	432b      	orrs	r3, r5
3418c0b0:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418c0b4:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3418c0b8:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3418c0bc:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3418c0c0:	f7ff f940 	bl	3418b344 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART6) == RCC_PERIPHCLK_USART6)
3418c0c4:	04b0      	lsls	r0, r6, #18
3418c0c6:	d51a      	bpl.n	3418c0fe <HAL_RCCEx_PeriphCLKConfig+0xbf2>
    if (PeriphClkInit->Usart6ClockSelection == RCC_USART6CLKSOURCE_IC9)
3418c0c8:	f8d4 0164 	ldr.w	r0, [r4, #356]	@ 0x164
3418c0cc:	4ba3      	ldr	r3, [pc, #652]	@ (3418c35c <HAL_RCCEx_PeriphCLKConfig+0xe50>)
3418c0ce:	4298      	cmp	r0, r3
3418c0d0:	f040 8590 	bne.w	3418cbf4 <HAL_RCCEx_PeriphCLKConfig+0x16e8>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3418c0d4:	4a9e      	ldr	r2, [pc, #632]	@ (3418c350 <HAL_RCCEx_PeriphCLKConfig+0xe44>)
3418c0d6:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3418c0d8:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3418c0dc:	6ca5      	ldr	r5, [r4, #72]	@ 0x48
3418c0de:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418c0e2:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418c0e6:	3901      	subs	r1, #1
3418c0e8:	432b      	orrs	r3, r5
3418c0ea:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418c0ee:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3418c0f2:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3418c0f6:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3418c0fa:	f7ff f923 	bl	3418b344 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART7) == RCC_PERIPHCLK_UART7)
3418c0fe:	0471      	lsls	r1, r6, #17
3418c100:	d51a      	bpl.n	3418c138 <HAL_RCCEx_PeriphCLKConfig+0xc2c>
    if (PeriphClkInit->Uart7ClockSelection == RCC_UART7CLKSOURCE_IC9)
3418c102:	f8d4 0168 	ldr.w	r0, [r4, #360]	@ 0x168
3418c106:	4b96      	ldr	r3, [pc, #600]	@ (3418c360 <HAL_RCCEx_PeriphCLKConfig+0xe54>)
3418c108:	4298      	cmp	r0, r3
3418c10a:	f040 8592 	bne.w	3418cc32 <HAL_RCCEx_PeriphCLKConfig+0x1726>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3418c10e:	4a90      	ldr	r2, [pc, #576]	@ (3418c350 <HAL_RCCEx_PeriphCLKConfig+0xe44>)
3418c110:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3418c112:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3418c116:	6ca5      	ldr	r5, [r4, #72]	@ 0x48
3418c118:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418c11c:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418c120:	3901      	subs	r1, #1
3418c122:	432b      	orrs	r3, r5
3418c124:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418c128:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3418c12c:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3418c130:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3418c134:	f7ff f906 	bl	3418b344 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART8) == RCC_PERIPHCLK_UART8)
3418c138:	0432      	lsls	r2, r6, #16
3418c13a:	d51a      	bpl.n	3418c172 <HAL_RCCEx_PeriphCLKConfig+0xc66>
    if (PeriphClkInit->Uart8ClockSelection == RCC_UART8CLKSOURCE_IC9)
3418c13c:	f8d4 016c 	ldr.w	r0, [r4, #364]	@ 0x16c
3418c140:	4b88      	ldr	r3, [pc, #544]	@ (3418c364 <HAL_RCCEx_PeriphCLKConfig+0xe58>)
3418c142:	4298      	cmp	r0, r3
3418c144:	f040 8594 	bne.w	3418cc70 <HAL_RCCEx_PeriphCLKConfig+0x1764>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3418c148:	4a81      	ldr	r2, [pc, #516]	@ (3418c350 <HAL_RCCEx_PeriphCLKConfig+0xe44>)
3418c14a:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3418c14c:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3418c150:	6ca5      	ldr	r5, [r4, #72]	@ 0x48
3418c152:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418c156:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418c15a:	3901      	subs	r1, #1
3418c15c:	432b      	orrs	r3, r5
3418c15e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418c162:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3418c166:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3418c16a:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3418c16e:	f7ff f8e9 	bl	3418b344 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART9) == RCC_PERIPHCLK_UART9)
3418c172:	03f3      	lsls	r3, r6, #15
3418c174:	d51a      	bpl.n	3418c1ac <HAL_RCCEx_PeriphCLKConfig+0xca0>
    if (PeriphClkInit->Uart9ClockSelection == RCC_UART9CLKSOURCE_IC9)
3418c176:	f8d4 0170 	ldr.w	r0, [r4, #368]	@ 0x170
3418c17a:	4b7b      	ldr	r3, [pc, #492]	@ (3418c368 <HAL_RCCEx_PeriphCLKConfig+0xe5c>)
3418c17c:	4298      	cmp	r0, r3
3418c17e:	f040 8596 	bne.w	3418ccae <HAL_RCCEx_PeriphCLKConfig+0x17a2>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3418c182:	4a73      	ldr	r2, [pc, #460]	@ (3418c350 <HAL_RCCEx_PeriphCLKConfig+0xe44>)
3418c184:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3418c186:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3418c18a:	6ca5      	ldr	r5, [r4, #72]	@ 0x48
3418c18c:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418c190:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418c194:	3901      	subs	r1, #1
3418c196:	432b      	orrs	r3, r5
3418c198:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418c19c:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3418c1a0:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3418c1a4:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3418c1a8:	f7ff f8cc 	bl	3418b344 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART10) == RCC_PERIPHCLK_USART10)
3418c1ac:	03b7      	lsls	r7, r6, #14
3418c1ae:	d51a      	bpl.n	3418c1e6 <HAL_RCCEx_PeriphCLKConfig+0xcda>
    if (PeriphClkInit->Usart10ClockSelection == RCC_USART10CLKSOURCE_IC9)
3418c1b0:	f8d4 0174 	ldr.w	r0, [r4, #372]	@ 0x174
3418c1b4:	4b6d      	ldr	r3, [pc, #436]	@ (3418c36c <HAL_RCCEx_PeriphCLKConfig+0xe60>)
3418c1b6:	4298      	cmp	r0, r3
3418c1b8:	f040 85ca 	bne.w	3418cd50 <HAL_RCCEx_PeriphCLKConfig+0x1844>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3418c1bc:	4a64      	ldr	r2, [pc, #400]	@ (3418c350 <HAL_RCCEx_PeriphCLKConfig+0xe44>)
3418c1be:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3418c1c0:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3418c1c4:	6ca5      	ldr	r5, [r4, #72]	@ 0x48
3418c1c6:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418c1ca:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418c1ce:	3901      	subs	r1, #1
3418c1d0:	432b      	orrs	r3, r5
3418c1d2:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418c1d6:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3418c1da:	f44f 7380 	mov.w	r3, #256	@ 0x100
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3418c1de:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3418c1e2:	f7ff f8af 	bl	3418b344 <LL_RCC_SetClockSource>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBPHY1) == RCC_PERIPHCLK_USBPHY1)
3418c1e6:	0375      	lsls	r5, r6, #13
3418c1e8:	d50c      	bpl.n	3418c204 <HAL_RCCEx_PeriphCLKConfig+0xcf8>
    __HAL_RCC_USBPHY1_CONFIG(PeriphClkInit->UsbPhy1ClockSelection);
3418c1ea:	f8d4 0178 	ldr.w	r0, [r4, #376]	@ 0x178
  LL_RCC_SetClockSource(ClkSource);
3418c1ee:	f020 4000 	bic.w	r0, r0, #2147483648	@ 0x80000000
3418c1f2:	f7ff f8a7 	bl	3418b344 <LL_RCC_SetClockSource>
3418c1f6:	f8d4 3178 	ldr.w	r3, [r4, #376]	@ 0x178
3418c1fa:	2b00      	cmp	r3, #0
3418c1fc:	f280 85c7 	bge.w	3418cd8e <HAL_RCCEx_PeriphCLKConfig+0x1882>
3418c200:	f7ff f870 	bl	3418b2e4 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBPHY2) == RCC_PERIPHCLK_USBPHY2)
3418c204:	02f0      	lsls	r0, r6, #11
3418c206:	d50c      	bpl.n	3418c222 <HAL_RCCEx_PeriphCLKConfig+0xd16>
    __HAL_RCC_USBPHY2_CONFIG(PeriphClkInit->UsbPhy2ClockSelection);
3418c208:	f8d4 0180 	ldr.w	r0, [r4, #384]	@ 0x180
3418c20c:	f020 4000 	bic.w	r0, r0, #2147483648	@ 0x80000000
3418c210:	f7ff f898 	bl	3418b344 <LL_RCC_SetClockSource>
3418c214:	f8d4 3180 	ldr.w	r3, [r4, #384]	@ 0x180
3418c218:	2b00      	cmp	r3, #0
3418c21a:	f280 85bc 	bge.w	3418cd96 <HAL_RCCEx_PeriphCLKConfig+0x188a>
3418c21e:	f7ff f861 	bl	3418b2e4 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBOTGHS1) == RCC_PERIPHCLK_USBOTGHS1)
3418c222:	0331      	lsls	r1, r6, #12
3418c224:	d523      	bpl.n	3418c26e <HAL_RCCEx_PeriphCLKConfig+0xd62>
    if (PeriphClkInit->UsbOtgHs1ClockSelection == RCC_USBOTGHS1CLKSOURCE_IC15)
3418c226:	f8d4 017c 	ldr.w	r0, [r4, #380]	@ 0x17c
3418c22a:	4b51      	ldr	r3, [pc, #324]	@ (3418c370 <HAL_RCCEx_PeriphCLKConfig+0xe64>)
3418c22c:	4298      	cmp	r0, r3
3418c22e:	f040 85b6 	bne.w	3418cd9e <HAL_RCCEx_PeriphCLKConfig+0x1892>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3418c232:	4a47      	ldr	r2, [pc, #284]	@ (3418c350 <HAL_RCCEx_PeriphCLKConfig+0xe44>)
3418c234:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3418c236:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3418c23a:	6fa5      	ldr	r5, [r4, #120]	@ 0x78
3418c23c:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418c240:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418c244:	3901      	subs	r1, #1
3418c246:	432b      	orrs	r3, r5
3418c248:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418c24c:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3418c250:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3418c254:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3418c258:	f020 4000 	bic.w	r0, r0, #2147483648	@ 0x80000000
3418c25c:	f7ff f872 	bl	3418b344 <LL_RCC_SetClockSource>
    __HAL_RCC_USBOTGHS1_CONFIG(PeriphClkInit->UsbOtgHs1ClockSelection);
3418c260:	f8d4 317c 	ldr.w	r3, [r4, #380]	@ 0x17c
3418c264:	2b00      	cmp	r3, #0
3418c266:	f280 85a3 	bge.w	3418cdb0 <HAL_RCCEx_PeriphCLKConfig+0x18a4>
3418c26a:	f7ff f83b 	bl	3418b2e4 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBOTGHS2) == RCC_PERIPHCLK_USBOTGHS2)
3418c26e:	02b2      	lsls	r2, r6, #10
3418c270:	d523      	bpl.n	3418c2ba <HAL_RCCEx_PeriphCLKConfig+0xdae>
    if (PeriphClkInit->UsbOtgHs2ClockSelection == RCC_USBOTGHS2CLKSOURCE_IC15)
3418c272:	f8d4 0184 	ldr.w	r0, [r4, #388]	@ 0x184
3418c276:	4b3f      	ldr	r3, [pc, #252]	@ (3418c374 <HAL_RCCEx_PeriphCLKConfig+0xe68>)
3418c278:	4298      	cmp	r0, r3
3418c27a:	f040 859d 	bne.w	3418cdb8 <HAL_RCCEx_PeriphCLKConfig+0x18ac>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3418c27e:	4a34      	ldr	r2, [pc, #208]	@ (3418c350 <HAL_RCCEx_PeriphCLKConfig+0xe44>)
3418c280:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3418c282:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3418c286:	6fa5      	ldr	r5, [r4, #120]	@ 0x78
3418c288:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418c28c:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418c290:	3901      	subs	r1, #1
3418c292:	432b      	orrs	r3, r5
3418c294:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418c298:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3418c29c:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3418c2a0:	f8c2 3a40 	str.w	r3, [r2, #2624]	@ 0xa40
  LL_RCC_SetClockSource(ClkSource);
3418c2a4:	f020 4000 	bic.w	r0, r0, #2147483648	@ 0x80000000
3418c2a8:	f7ff f84c 	bl	3418b344 <LL_RCC_SetClockSource>
    __HAL_RCC_USBOTGHS2_CONFIG(PeriphClkInit->UsbOtgHs2ClockSelection);
3418c2ac:	f8d4 3184 	ldr.w	r3, [r4, #388]	@ 0x184
3418c2b0:	2b00      	cmp	r3, #0
3418c2b2:	f280 858a 	bge.w	3418cdca <HAL_RCCEx_PeriphCLKConfig+0x18be>
3418c2b6:	f7ff f815 	bl	3418b2e4 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_TIM) == RCC_PERIPHCLK_TIM)
3418c2ba:	0633      	lsls	r3, r6, #24
3418c2bc:	d508      	bpl.n	3418c2d0 <HAL_RCCEx_PeriphCLKConfig+0xdc4>
  MODIFY_REG(RCC->CFGR2, RCC_CFGR2_TIMPRE, Prescaler << RCC_CFGR2_TIMPRE_Pos);
3418c2be:	4a24      	ldr	r2, [pc, #144]	@ (3418c350 <HAL_RCCEx_PeriphCLKConfig+0xe44>)
3418c2c0:	f8d4 118c 	ldr.w	r1, [r4, #396]	@ 0x18c
3418c2c4:	6a53      	ldr	r3, [r2, #36]	@ 0x24
3418c2c6:	f023 7340 	bic.w	r3, r3, #50331648	@ 0x3000000
3418c2ca:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
3418c2ce:	6253      	str	r3, [r2, #36]	@ 0x24
}
3418c2d0:	f1b8 0000 	subs.w	r0, r8, #0
3418c2d4:	bf18      	it	ne
3418c2d6:	2001      	movne	r0, #1
3418c2d8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
3418c2dc:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
3418c2e0:	6d60      	ldr	r0, [r4, #84]	@ 0x54
3418c2e2:	6d27      	ldr	r7, [r4, #80]	@ 0x50
3418c2e4:	f022 5243 	bic.w	r2, r2, #817889280	@ 0x30c00000
3418c2e8:	f422 127c 	bic.w	r2, r2, #4128768	@ 0x3f0000
3418c2ec:	3801      	subs	r0, #1
3418c2ee:	433a      	orrs	r2, r7
3418c2f0:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
3418c2f4:	f8c3 20e8 	str.w	r2, [r3, #232]	@ 0xe8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC10ENS);
3418c2f8:	f44f 7200 	mov.w	r2, #512	@ 0x200
3418c2fc:	f7ff b975 	b.w	3418b5ea <HAL_RCCEx_PeriphCLKConfig+0xde>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3418c300:	f8d3 20fc 	ldr.w	r2, [r3, #252]	@ 0xfc
3418c304:	6fe0      	ldr	r0, [r4, #124]	@ 0x7c
3418c306:	6fa7      	ldr	r7, [r4, #120]	@ 0x78
3418c308:	f022 5243 	bic.w	r2, r2, #817889280	@ 0x30c00000
3418c30c:	f422 127c 	bic.w	r2, r2, #4128768	@ 0x3f0000
3418c310:	3801      	subs	r0, #1
3418c312:	433a      	orrs	r2, r7
3418c314:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
3418c318:	f8c3 20fc 	str.w	r2, [r3, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3418c31c:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
3418c320:	f7ff b963 	b.w	3418b5ea <HAL_RCCEx_PeriphCLKConfig+0xde>
      MODIFY_REG(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL | RCC_IC19CFGR_IC19INT,
3418c324:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
3418c328:	f8d4 009c 	ldr.w	r0, [r4, #156]	@ 0x9c
3418c32c:	f8d4 7098 	ldr.w	r7, [r4, #152]	@ 0x98
3418c330:	f022 5243 	bic.w	r2, r2, #817889280	@ 0x30c00000
3418c334:	f422 127c 	bic.w	r2, r2, #4128768	@ 0x3f0000
3418c338:	3801      	subs	r0, #1
3418c33a:	433a      	orrs	r2, r7
3418c33c:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
3418c340:	f8c3 210c 	str.w	r2, [r3, #268]	@ 0x10c
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC19ENS);
3418c344:	f44f 2280 	mov.w	r2, #262144	@ 0x40000
3418c348:	f7ff b94f 	b.w	3418b5ea <HAL_RCCEx_PeriphCLKConfig+0xde>
3418c34c:	07020830 	.word	0x07020830
3418c350:	56028000 	.word	0x56028000
3418c354:	07020c30 	.word	0x07020c30
3418c358:	07021030 	.word	0x07021030
3418c35c:	07021430 	.word	0x07021430
3418c360:	07021830 	.word	0x07021830
3418c364:	07021c30 	.word	0x07021c30
3418c368:	07020034 	.word	0x07020034
3418c36c:	07020434 	.word	0x07020434
3418c370:	03020c14 	.word	0x03020c14
3418c374:	03021414 	.word	0x03021414
      MODIFY_REG(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL | RCC_IC20CFGR_IC20INT,
3418c378:	f8d3 2110 	ldr.w	r2, [r3, #272]	@ 0x110
3418c37c:	f8d4 00a4 	ldr.w	r0, [r4, #164]	@ 0xa4
3418c380:	f8d4 70a0 	ldr.w	r7, [r4, #160]	@ 0xa0
3418c384:	f022 5243 	bic.w	r2, r2, #817889280	@ 0x30c00000
3418c388:	f422 127c 	bic.w	r2, r2, #4128768	@ 0x3f0000
3418c38c:	3801      	subs	r0, #1
3418c38e:	433a      	orrs	r2, r7
3418c390:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
3418c394:	f8c3 2110 	str.w	r2, [r3, #272]	@ 0x110
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC20ENS);
3418c398:	f44f 2200 	mov.w	r2, #524288	@ 0x80000
3418c39c:	f7ff b925 	b.w	3418b5ea <HAL_RCCEx_PeriphCLKConfig+0xde>
    else if (PeriphClkInit->Xspi1ClockSelection == RCC_XSPI1CLKSOURCE_IC4)
3418c3a0:	4bbe      	ldr	r3, [pc, #760]	@ (3418c69c <HAL_RCCEx_PeriphCLKConfig+0x1190>)
3418c3a2:	4298      	cmp	r0, r3
3418c3a4:	d111      	bne.n	3418c3ca <HAL_RCCEx_PeriphCLKConfig+0xebe>
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
3418c3a6:	4abe      	ldr	r2, [pc, #760]	@ (3418c6a0 <HAL_RCCEx_PeriphCLKConfig+0x1194>)
3418c3a8:	6a61      	ldr	r1, [r4, #36]	@ 0x24
3418c3aa:	f8d2 30d0 	ldr.w	r3, [r2, #208]	@ 0xd0
3418c3ae:	6a27      	ldr	r7, [r4, #32]
3418c3b0:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418c3b4:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418c3b8:	3901      	subs	r1, #1
3418c3ba:	433b      	orrs	r3, r7
3418c3bc:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418c3c0:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
3418c3c4:	2308      	movs	r3, #8
3418c3c6:	f7ff b932 	b.w	3418b62e <HAL_RCCEx_PeriphCLKConfig+0x122>
    else if (PeriphClkInit->Xspi1ClockSelection == RCC_XSPI1CLKSOURCE_CLKP)
3418c3ca:	4bb6      	ldr	r3, [pc, #728]	@ (3418c6a4 <HAL_RCCEx_PeriphCLKConfig+0x1198>)
3418c3cc:	4298      	cmp	r0, r3
  * @rmtoll MISCENSR      PERENS        LL_RCC_CLKP_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_CLKP_Enable(void)
{
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3418c3ce:	bf02      	ittt	eq
3418c3d0:	2240      	moveq	r2, #64	@ 0x40
3418c3d2:	4bb3      	ldreq	r3, [pc, #716]	@ (3418c6a0 <HAL_RCCEx_PeriphCLKConfig+0x1194>)
3418c3d4:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3418c3d8:	f7ff b92b 	b.w	3418b632 <HAL_RCCEx_PeriphCLKConfig+0x126>
    else if (PeriphClkInit->Xspi2ClockSelection == RCC_XSPI2CLKSOURCE_IC4)
3418c3dc:	4bb2      	ldr	r3, [pc, #712]	@ (3418c6a8 <HAL_RCCEx_PeriphCLKConfig+0x119c>)
3418c3de:	4298      	cmp	r0, r3
3418c3e0:	d111      	bne.n	3418c406 <HAL_RCCEx_PeriphCLKConfig+0xefa>
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
3418c3e2:	4aaf      	ldr	r2, [pc, #700]	@ (3418c6a0 <HAL_RCCEx_PeriphCLKConfig+0x1194>)
3418c3e4:	6a61      	ldr	r1, [r4, #36]	@ 0x24
3418c3e6:	f8d2 30d0 	ldr.w	r3, [r2, #208]	@ 0xd0
3418c3ea:	6a27      	ldr	r7, [r4, #32]
3418c3ec:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418c3f0:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418c3f4:	3901      	subs	r1, #1
3418c3f6:	433b      	orrs	r3, r7
3418c3f8:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418c3fc:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
3418c400:	2308      	movs	r3, #8
3418c402:	f7ff b930 	b.w	3418b666 <HAL_RCCEx_PeriphCLKConfig+0x15a>
    else if (PeriphClkInit->Xspi2ClockSelection == RCC_XSPI2CLKSOURCE_CLKP)
3418c406:	4ba9      	ldr	r3, [pc, #676]	@ (3418c6ac <HAL_RCCEx_PeriphCLKConfig+0x11a0>)
3418c408:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3418c40a:	bf02      	ittt	eq
3418c40c:	2240      	moveq	r2, #64	@ 0x40
3418c40e:	4ba4      	ldreq	r3, [pc, #656]	@ (3418c6a0 <HAL_RCCEx_PeriphCLKConfig+0x1194>)
3418c410:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3418c414:	f7ff b929 	b.w	3418b66a <HAL_RCCEx_PeriphCLKConfig+0x15e>
    else if (PeriphClkInit->Xspi3ClockSelection == RCC_XSPI3CLKSOURCE_IC4)
3418c418:	4ba5      	ldr	r3, [pc, #660]	@ (3418c6b0 <HAL_RCCEx_PeriphCLKConfig+0x11a4>)
3418c41a:	4298      	cmp	r0, r3
3418c41c:	d111      	bne.n	3418c442 <HAL_RCCEx_PeriphCLKConfig+0xf36>
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
3418c41e:	4aa0      	ldr	r2, [pc, #640]	@ (3418c6a0 <HAL_RCCEx_PeriphCLKConfig+0x1194>)
3418c420:	6a61      	ldr	r1, [r4, #36]	@ 0x24
3418c422:	f8d2 30d0 	ldr.w	r3, [r2, #208]	@ 0xd0
3418c426:	6a27      	ldr	r7, [r4, #32]
3418c428:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418c42c:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418c430:	3901      	subs	r1, #1
3418c432:	433b      	orrs	r3, r7
3418c434:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418c438:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
3418c43c:	2308      	movs	r3, #8
3418c43e:	f7ff b92e 	b.w	3418b69e <HAL_RCCEx_PeriphCLKConfig+0x192>
    else if (PeriphClkInit->Xspi3ClockSelection == RCC_XSPI3CLKSOURCE_CLKP)
3418c442:	4b9c      	ldr	r3, [pc, #624]	@ (3418c6b4 <HAL_RCCEx_PeriphCLKConfig+0x11a8>)
3418c444:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3418c446:	bf02      	ittt	eq
3418c448:	2240      	moveq	r2, #64	@ 0x40
3418c44a:	4b95      	ldreq	r3, [pc, #596]	@ (3418c6a0 <HAL_RCCEx_PeriphCLKConfig+0x1194>)
3418c44c:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3418c450:	f7ff b927 	b.w	3418b6a2 <HAL_RCCEx_PeriphCLKConfig+0x196>
    else if (PeriphClkInit->FmcClockSelection == RCC_FMCCLKSOURCE_IC4)
3418c454:	2930      	cmp	r1, #48	@ 0x30
3418c456:	d110      	bne.n	3418c47a <HAL_RCCEx_PeriphCLKConfig+0xf6e>
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
3418c458:	f8d2 30d0 	ldr.w	r3, [r2, #208]	@ 0xd0
3418c45c:	6a60      	ldr	r0, [r4, #36]	@ 0x24
3418c45e:	6a27      	ldr	r7, [r4, #32]
3418c460:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418c464:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418c468:	3801      	subs	r0, #1
3418c46a:	433b      	orrs	r3, r7
3418c46c:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
3418c470:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
3418c474:	2308      	movs	r3, #8
3418c476:	f7ff b92d 	b.w	3418b6d4 <HAL_RCCEx_PeriphCLKConfig+0x1c8>
    else if (PeriphClkInit->FmcClockSelection == RCC_FMCCLKSOURCE_CLKP)
3418c47a:	2910      	cmp	r1, #16
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3418c47c:	bf04      	itt	eq
3418c47e:	2340      	moveq	r3, #64	@ 0x40
3418c480:	f8c2 3a48 	streq.w	r3, [r2, #2632]	@ 0xa48
}
3418c484:	f7ff b928 	b.w	3418b6d8 <HAL_RCCEx_PeriphCLKConfig+0x1cc>
    else if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_IC5)
3418c488:	4b8b      	ldr	r3, [pc, #556]	@ (3418c6b8 <HAL_RCCEx_PeriphCLKConfig+0x11ac>)
3418c48a:	4298      	cmp	r0, r3
3418c48c:	d111      	bne.n	3418c4b2 <HAL_RCCEx_PeriphCLKConfig+0xfa6>
      MODIFY_REG(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL | RCC_IC5CFGR_IC5INT,
3418c48e:	4a84      	ldr	r2, [pc, #528]	@ (3418c6a0 <HAL_RCCEx_PeriphCLKConfig+0x1194>)
3418c490:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
3418c492:	f8d2 30d4 	ldr.w	r3, [r2, #212]	@ 0xd4
3418c496:	6aa7      	ldr	r7, [r4, #40]	@ 0x28
3418c498:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418c49c:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418c4a0:	3901      	subs	r1, #1
3418c4a2:	433b      	orrs	r3, r7
3418c4a4:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418c4a8:	f8c2 30d4 	str.w	r3, [r2, #212]	@ 0xd4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC5ENS);
3418c4ac:	2310      	movs	r3, #16
3418c4ae:	f7ff b933 	b.w	3418b718 <HAL_RCCEx_PeriphCLKConfig+0x20c>
    else if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_CLKP)
3418c4b2:	4b82      	ldr	r3, [pc, #520]	@ (3418c6bc <HAL_RCCEx_PeriphCLKConfig+0x11b0>)
3418c4b4:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3418c4b6:	bf02      	ittt	eq
3418c4b8:	2240      	moveq	r2, #64	@ 0x40
3418c4ba:	4b79      	ldreq	r3, [pc, #484]	@ (3418c6a0 <HAL_RCCEx_PeriphCLKConfig+0x1194>)
3418c4bc:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3418c4c0:	f7ff b92c 	b.w	3418b71c <HAL_RCCEx_PeriphCLKConfig+0x210>
    else if (PeriphClkInit->Sdmmc2ClockSelection == RCC_SDMMC2CLKSOURCE_IC5)
3418c4c4:	4b7e      	ldr	r3, [pc, #504]	@ (3418c6c0 <HAL_RCCEx_PeriphCLKConfig+0x11b4>)
3418c4c6:	4298      	cmp	r0, r3
3418c4c8:	d111      	bne.n	3418c4ee <HAL_RCCEx_PeriphCLKConfig+0xfe2>
      MODIFY_REG(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL | RCC_IC5CFGR_IC5INT,
3418c4ca:	4a75      	ldr	r2, [pc, #468]	@ (3418c6a0 <HAL_RCCEx_PeriphCLKConfig+0x1194>)
3418c4cc:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
3418c4ce:	f8d2 30d4 	ldr.w	r3, [r2, #212]	@ 0xd4
3418c4d2:	6aa7      	ldr	r7, [r4, #40]	@ 0x28
3418c4d4:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418c4d8:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418c4dc:	3901      	subs	r1, #1
3418c4de:	433b      	orrs	r3, r7
3418c4e0:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418c4e4:	f8c2 30d4 	str.w	r3, [r2, #212]	@ 0xd4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC5ENS);
3418c4e8:	2310      	movs	r3, #16
3418c4ea:	f7ff b931 	b.w	3418b750 <HAL_RCCEx_PeriphCLKConfig+0x244>
    else if (PeriphClkInit->Sdmmc2ClockSelection == RCC_SDMMC2CLKSOURCE_CLKP)
3418c4ee:	4b75      	ldr	r3, [pc, #468]	@ (3418c6c4 <HAL_RCCEx_PeriphCLKConfig+0x11b8>)
3418c4f0:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3418c4f2:	bf02      	ittt	eq
3418c4f4:	2240      	moveq	r2, #64	@ 0x40
3418c4f6:	4b6a      	ldreq	r3, [pc, #424]	@ (3418c6a0 <HAL_RCCEx_PeriphCLKConfig+0x1194>)
3418c4f8:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3418c4fc:	f7ff b92a 	b.w	3418b754 <HAL_RCCEx_PeriphCLKConfig+0x248>
    else if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_IC8)
3418c500:	2a30      	cmp	r2, #48	@ 0x30
3418c502:	d110      	bne.n	3418c526 <HAL_RCCEx_PeriphCLKConfig+0x101a>
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3418c504:	f8d1 30e0 	ldr.w	r3, [r1, #224]	@ 0xe0
3418c508:	6c60      	ldr	r0, [r4, #68]	@ 0x44
3418c50a:	6c27      	ldr	r7, [r4, #64]	@ 0x40
3418c50c:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418c510:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418c514:	3801      	subs	r0, #1
3418c516:	433b      	orrs	r3, r7
3418c518:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
3418c51c:	f8c1 30e0 	str.w	r3, [r1, #224]	@ 0xe0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3418c520:	2380      	movs	r3, #128	@ 0x80
3418c522:	f7ff b930 	b.w	3418b786 <HAL_RCCEx_PeriphCLKConfig+0x27a>
    else if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_CLKP)
3418c526:	2a10      	cmp	r2, #16
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3418c528:	bf04      	itt	eq
3418c52a:	2340      	moveq	r3, #64	@ 0x40
3418c52c:	f8c1 3a48 	streq.w	r3, [r1, #2632]	@ 0xa48
}
3418c530:	f7ff b92b 	b.w	3418b78a <HAL_RCCEx_PeriphCLKConfig+0x27e>
    else if (PeriphClkInit->Adf1ClockSelection == RCC_ADF1CLKSOURCE_IC8)
3418c534:	2903      	cmp	r1, #3
3418c536:	d110      	bne.n	3418c55a <HAL_RCCEx_PeriphCLKConfig+0x104e>
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3418c538:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
3418c53c:	6c60      	ldr	r0, [r4, #68]	@ 0x44
3418c53e:	6c27      	ldr	r7, [r4, #64]	@ 0x40
3418c540:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418c544:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418c548:	3801      	subs	r0, #1
3418c54a:	433b      	orrs	r3, r7
3418c54c:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
3418c550:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3418c554:	2380      	movs	r3, #128	@ 0x80
3418c556:	f7ff b93e 	b.w	3418b7d6 <HAL_RCCEx_PeriphCLKConfig+0x2ca>
    else if (PeriphClkInit->Adf1ClockSelection == RCC_ADF1CLKSOURCE_CLKP)
3418c55a:	2901      	cmp	r1, #1
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3418c55c:	bf04      	itt	eq
3418c55e:	2340      	moveq	r3, #64	@ 0x40
3418c560:	f8c2 3a48 	streq.w	r3, [r2, #2632]	@ 0xa48
}
3418c564:	f7ff b939 	b.w	3418b7da <HAL_RCCEx_PeriphCLKConfig+0x2ce>
    else if (PeriphClkInit->DcmippClockSelection == RCC_DCMIPPCLKSOURCE_CLKP)
3418c568:	f5b1 1f80 	cmp.w	r1, #1048576	@ 0x100000
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3418c56c:	bf04      	itt	eq
3418c56e:	2340      	moveq	r3, #64	@ 0x40
3418c570:	f8c2 3a48 	streq.w	r3, [r2, #2632]	@ 0xa48
}
3418c574:	f7ff b96d 	b.w	3418b852 <HAL_RCCEx_PeriphCLKConfig+0x346>
    else if (PeriphClkInit->Eth1ClockSelection == RCC_ETH1CLKSOURCE_CLKP)
3418c578:	f5b1 5f80 	cmp.w	r1, #4096	@ 0x1000
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3418c57c:	bf04      	itt	eq
3418c57e:	2340      	moveq	r3, #64	@ 0x40
3418c580:	f8c2 3a48 	streq.w	r3, [r2, #2632]	@ 0xa48
}
3418c584:	f7ff b988 	b.w	3418b898 <HAL_RCCEx_PeriphCLKConfig+0x38c>
    else if (PeriphClkInit->Eth1PtpClockSelection == RCC_ETH1PTPCLKSOURCE_CLKP)
3418c588:	2901      	cmp	r1, #1
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3418c58a:	bf04      	itt	eq
3418c58c:	2340      	moveq	r3, #64	@ 0x40
3418c58e:	f8c2 3a48 	streq.w	r3, [r2, #2632]	@ 0xa48
}
3418c592:	f7ff b9d5 	b.w	3418b940 <HAL_RCCEx_PeriphCLKConfig+0x434>
    else if (PeriphClkInit->FdcanClockSelection == RCC_FDCANCLKSOURCE_CLKP)
3418c596:	2901      	cmp	r1, #1
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3418c598:	bf04      	itt	eq
3418c59a:	2340      	moveq	r3, #64	@ 0x40
3418c59c:	f8c2 3a48 	streq.w	r3, [r2, #2632]	@ 0xa48
}
3418c5a0:	f7ff b9f7 	b.w	3418b992 <HAL_RCCEx_PeriphCLKConfig+0x486>
    else if (PeriphClkInit->I2c1ClockSelection == RCC_I2C1CLKSOURCE_IC15)
3418c5a4:	4b48      	ldr	r3, [pc, #288]	@ (3418c6c8 <HAL_RCCEx_PeriphCLKConfig+0x11bc>)
3418c5a6:	4298      	cmp	r0, r3
3418c5a8:	d112      	bne.n	3418c5d0 <HAL_RCCEx_PeriphCLKConfig+0x10c4>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3418c5aa:	4a3d      	ldr	r2, [pc, #244]	@ (3418c6a0 <HAL_RCCEx_PeriphCLKConfig+0x1194>)
3418c5ac:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3418c5ae:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3418c5b2:	6fa7      	ldr	r7, [r4, #120]	@ 0x78
3418c5b4:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418c5b8:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418c5bc:	3901      	subs	r1, #1
3418c5be:	433b      	orrs	r3, r7
3418c5c0:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418c5c4:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3418c5c8:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3418c5cc:	f7ff ba02 	b.w	3418b9d4 <HAL_RCCEx_PeriphCLKConfig+0x4c8>
    else if (PeriphClkInit->I2c1ClockSelection == RCC_I2C1CLKSOURCE_CLKP)
3418c5d0:	4b3e      	ldr	r3, [pc, #248]	@ (3418c6cc <HAL_RCCEx_PeriphCLKConfig+0x11c0>)
3418c5d2:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3418c5d4:	bf02      	ittt	eq
3418c5d6:	2240      	moveq	r2, #64	@ 0x40
3418c5d8:	4b31      	ldreq	r3, [pc, #196]	@ (3418c6a0 <HAL_RCCEx_PeriphCLKConfig+0x1194>)
3418c5da:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3418c5de:	f7ff b9fb 	b.w	3418b9d8 <HAL_RCCEx_PeriphCLKConfig+0x4cc>
    else if (PeriphClkInit->I2c2ClockSelection == RCC_I2C2CLKSOURCE_IC15)
3418c5e2:	4b3b      	ldr	r3, [pc, #236]	@ (3418c6d0 <HAL_RCCEx_PeriphCLKConfig+0x11c4>)
3418c5e4:	4298      	cmp	r0, r3
3418c5e6:	d112      	bne.n	3418c60e <HAL_RCCEx_PeriphCLKConfig+0x1102>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3418c5e8:	4a2d      	ldr	r2, [pc, #180]	@ (3418c6a0 <HAL_RCCEx_PeriphCLKConfig+0x1194>)
3418c5ea:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3418c5ec:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3418c5f0:	6fa7      	ldr	r7, [r4, #120]	@ 0x78
3418c5f2:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418c5f6:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418c5fa:	3901      	subs	r1, #1
3418c5fc:	433b      	orrs	r3, r7
3418c5fe:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418c602:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3418c606:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3418c60a:	f7ff ba00 	b.w	3418ba0e <HAL_RCCEx_PeriphCLKConfig+0x502>
    else if (PeriphClkInit->I2c2ClockSelection == RCC_I2C2CLKSOURCE_CLKP)
3418c60e:	4b31      	ldr	r3, [pc, #196]	@ (3418c6d4 <HAL_RCCEx_PeriphCLKConfig+0x11c8>)
3418c610:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3418c612:	bf02      	ittt	eq
3418c614:	2240      	moveq	r2, #64	@ 0x40
3418c616:	4b22      	ldreq	r3, [pc, #136]	@ (3418c6a0 <HAL_RCCEx_PeriphCLKConfig+0x1194>)
3418c618:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3418c61c:	f7ff b9f9 	b.w	3418ba12 <HAL_RCCEx_PeriphCLKConfig+0x506>
    else if (PeriphClkInit->I2c3ClockSelection == RCC_I2C3CLKSOURCE_IC15)
3418c620:	4b2d      	ldr	r3, [pc, #180]	@ (3418c6d8 <HAL_RCCEx_PeriphCLKConfig+0x11cc>)
3418c622:	4298      	cmp	r0, r3
3418c624:	d112      	bne.n	3418c64c <HAL_RCCEx_PeriphCLKConfig+0x1140>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3418c626:	4a1e      	ldr	r2, [pc, #120]	@ (3418c6a0 <HAL_RCCEx_PeriphCLKConfig+0x1194>)
3418c628:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3418c62a:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3418c62e:	6fa7      	ldr	r7, [r4, #120]	@ 0x78
3418c630:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418c634:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418c638:	3901      	subs	r1, #1
3418c63a:	433b      	orrs	r3, r7
3418c63c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418c640:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3418c644:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3418c648:	f7ff b9fe 	b.w	3418ba48 <HAL_RCCEx_PeriphCLKConfig+0x53c>
    else if (PeriphClkInit->I2c3ClockSelection == RCC_I2C3CLKSOURCE_CLKP)
3418c64c:	4b23      	ldr	r3, [pc, #140]	@ (3418c6dc <HAL_RCCEx_PeriphCLKConfig+0x11d0>)
3418c64e:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3418c650:	bf02      	ittt	eq
3418c652:	2240      	moveq	r2, #64	@ 0x40
3418c654:	4b12      	ldreq	r3, [pc, #72]	@ (3418c6a0 <HAL_RCCEx_PeriphCLKConfig+0x1194>)
3418c656:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3418c65a:	f7ff b9f7 	b.w	3418ba4c <HAL_RCCEx_PeriphCLKConfig+0x540>
    else if (PeriphClkInit->I2c4ClockSelection == RCC_I2C4CLKSOURCE_IC15)
3418c65e:	4b20      	ldr	r3, [pc, #128]	@ (3418c6e0 <HAL_RCCEx_PeriphCLKConfig+0x11d4>)
3418c660:	4298      	cmp	r0, r3
3418c662:	d112      	bne.n	3418c68a <HAL_RCCEx_PeriphCLKConfig+0x117e>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3418c664:	4a0e      	ldr	r2, [pc, #56]	@ (3418c6a0 <HAL_RCCEx_PeriphCLKConfig+0x1194>)
3418c666:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3418c668:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3418c66c:	6fa7      	ldr	r7, [r4, #120]	@ 0x78
3418c66e:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418c672:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418c676:	3901      	subs	r1, #1
3418c678:	433b      	orrs	r3, r7
3418c67a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418c67e:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3418c682:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3418c686:	f7ff b9fc 	b.w	3418ba82 <HAL_RCCEx_PeriphCLKConfig+0x576>
    else if (PeriphClkInit->I2c4ClockSelection == RCC_I2C4CLKSOURCE_CLKP)
3418c68a:	4b16      	ldr	r3, [pc, #88]	@ (3418c6e4 <HAL_RCCEx_PeriphCLKConfig+0x11d8>)
3418c68c:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3418c68e:	bf02      	ittt	eq
3418c690:	2240      	moveq	r2, #64	@ 0x40
3418c692:	4b03      	ldreq	r3, [pc, #12]	@ (3418c6a0 <HAL_RCCEx_PeriphCLKConfig+0x1194>)
3418c694:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3418c698:	f7ff b9f5 	b.w	3418ba86 <HAL_RCCEx_PeriphCLKConfig+0x57a>
3418c69c:	03030014 	.word	0x03030014
3418c6a0:	56028000 	.word	0x56028000
3418c6a4:	03010014 	.word	0x03010014
3418c6a8:	03030414 	.word	0x03030414
3418c6ac:	03010414 	.word	0x03010414
3418c6b0:	03030814 	.word	0x03030814
3418c6b4:	03010814 	.word	0x03010814
3418c6b8:	0303001c 	.word	0x0303001c
3418c6bc:	0301001c 	.word	0x0301001c
3418c6c0:	0303041c 	.word	0x0303041c
3418c6c4:	0301041c 	.word	0x0301041c
3418c6c8:	0703000c 	.word	0x0703000c
3418c6cc:	0701000c 	.word	0x0701000c
3418c6d0:	0703040c 	.word	0x0703040c
3418c6d4:	0701040c 	.word	0x0701040c
3418c6d8:	0703080c 	.word	0x0703080c
3418c6dc:	0701080c 	.word	0x0701080c
3418c6e0:	07030c0c 	.word	0x07030c0c
3418c6e4:	07010c0c 	.word	0x07010c0c
    else if (PeriphClkInit->I3c1ClockSelection == RCC_I3C1CLKSOURCE_IC15)
3418c6e8:	4bb2      	ldr	r3, [pc, #712]	@ (3418c9b4 <HAL_RCCEx_PeriphCLKConfig+0x14a8>)
3418c6ea:	4298      	cmp	r0, r3
3418c6ec:	d112      	bne.n	3418c714 <HAL_RCCEx_PeriphCLKConfig+0x1208>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3418c6ee:	4ab2      	ldr	r2, [pc, #712]	@ (3418c9b8 <HAL_RCCEx_PeriphCLKConfig+0x14ac>)
3418c6f0:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3418c6f2:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3418c6f6:	6fa7      	ldr	r7, [r4, #120]	@ 0x78
3418c6f8:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418c6fc:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418c700:	3901      	subs	r1, #1
3418c702:	433b      	orrs	r3, r7
3418c704:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418c708:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3418c70c:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3418c710:	f7ff b9d4 	b.w	3418babc <HAL_RCCEx_PeriphCLKConfig+0x5b0>
    else if (PeriphClkInit->I3c1ClockSelection == RCC_I3C1CLKSOURCE_CLKP)
3418c714:	4ba9      	ldr	r3, [pc, #676]	@ (3418c9bc <HAL_RCCEx_PeriphCLKConfig+0x14b0>)
3418c716:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3418c718:	bf02      	ittt	eq
3418c71a:	2240      	moveq	r2, #64	@ 0x40
3418c71c:	4ba6      	ldreq	r3, [pc, #664]	@ (3418c9b8 <HAL_RCCEx_PeriphCLKConfig+0x14ac>)
3418c71e:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3418c722:	f7ff b9cd 	b.w	3418bac0 <HAL_RCCEx_PeriphCLKConfig+0x5b4>
    else if (PeriphClkInit->I3c2ClockSelection == RCC_I3C2CLKSOURCE_IC15)
3418c726:	4ba6      	ldr	r3, [pc, #664]	@ (3418c9c0 <HAL_RCCEx_PeriphCLKConfig+0x14b4>)
3418c728:	4298      	cmp	r0, r3
3418c72a:	d112      	bne.n	3418c752 <HAL_RCCEx_PeriphCLKConfig+0x1246>
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3418c72c:	4aa2      	ldr	r2, [pc, #648]	@ (3418c9b8 <HAL_RCCEx_PeriphCLKConfig+0x14ac>)
3418c72e:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
3418c730:	f8d2 30fc 	ldr.w	r3, [r2, #252]	@ 0xfc
3418c734:	6fa7      	ldr	r7, [r4, #120]	@ 0x78
3418c736:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418c73a:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418c73e:	3901      	subs	r1, #1
3418c740:	433b      	orrs	r3, r7
3418c742:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418c746:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3418c74a:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3418c74e:	f7ff b9d2 	b.w	3418baf6 <HAL_RCCEx_PeriphCLKConfig+0x5ea>
    else if (PeriphClkInit->I3c2ClockSelection == RCC_I3C2CLKSOURCE_CLKP)
3418c752:	4b9c      	ldr	r3, [pc, #624]	@ (3418c9c4 <HAL_RCCEx_PeriphCLKConfig+0x14b8>)
3418c754:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3418c756:	bf02      	ittt	eq
3418c758:	2240      	moveq	r2, #64	@ 0x40
3418c75a:	4b97      	ldreq	r3, [pc, #604]	@ (3418c9b8 <HAL_RCCEx_PeriphCLKConfig+0x14ac>)
3418c75c:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3418c760:	f7ff b9cb 	b.w	3418bafa <HAL_RCCEx_PeriphCLKConfig+0x5ee>
    else if (PeriphClkInit->Lptim1ClockSelection == RCC_LPTIM1CLKSOURCE_CLKP)
3418c764:	4b98      	ldr	r3, [pc, #608]	@ (3418c9c8 <HAL_RCCEx_PeriphCLKConfig+0x14bc>)
3418c766:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3418c768:	bf02      	ittt	eq
3418c76a:	2240      	moveq	r2, #64	@ 0x40
3418c76c:	4b92      	ldreq	r3, [pc, #584]	@ (3418c9b8 <HAL_RCCEx_PeriphCLKConfig+0x14ac>)
3418c76e:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3418c772:	f7ff b9df 	b.w	3418bb34 <HAL_RCCEx_PeriphCLKConfig+0x628>
    else if (PeriphClkInit->Lptim2ClockSelection == RCC_LPTIM2CLKSOURCE_CLKP)
3418c776:	4b95      	ldr	r3, [pc, #596]	@ (3418c9cc <HAL_RCCEx_PeriphCLKConfig+0x14c0>)
3418c778:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3418c77a:	bf02      	ittt	eq
3418c77c:	2240      	moveq	r2, #64	@ 0x40
3418c77e:	4b8e      	ldreq	r3, [pc, #568]	@ (3418c9b8 <HAL_RCCEx_PeriphCLKConfig+0x14ac>)
3418c780:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3418c784:	f7ff b9f3 	b.w	3418bb6e <HAL_RCCEx_PeriphCLKConfig+0x662>
    else if (PeriphClkInit->Lptim3ClockSelection == RCC_LPTIM3CLKSOURCE_CLKP)
3418c788:	4b91      	ldr	r3, [pc, #580]	@ (3418c9d0 <HAL_RCCEx_PeriphCLKConfig+0x14c4>)
3418c78a:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3418c78c:	bf02      	ittt	eq
3418c78e:	2240      	moveq	r2, #64	@ 0x40
3418c790:	4b89      	ldreq	r3, [pc, #548]	@ (3418c9b8 <HAL_RCCEx_PeriphCLKConfig+0x14ac>)
3418c792:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3418c796:	f7ff ba07 	b.w	3418bba8 <HAL_RCCEx_PeriphCLKConfig+0x69c>
    else if (PeriphClkInit->Lptim4ClockSelection == RCC_LPTIM4CLKSOURCE_CLKP)
3418c79a:	4b8e      	ldr	r3, [pc, #568]	@ (3418c9d4 <HAL_RCCEx_PeriphCLKConfig+0x14c8>)
3418c79c:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3418c79e:	bf02      	ittt	eq
3418c7a0:	2240      	moveq	r2, #64	@ 0x40
3418c7a2:	4b85      	ldreq	r3, [pc, #532]	@ (3418c9b8 <HAL_RCCEx_PeriphCLKConfig+0x14ac>)
3418c7a4:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3418c7a8:	f7ff ba1b 	b.w	3418bbe2 <HAL_RCCEx_PeriphCLKConfig+0x6d6>
    else if (PeriphClkInit->Lptim5ClockSelection == RCC_LPTIM5CLKSOURCE_CLKP)
3418c7ac:	4b8a      	ldr	r3, [pc, #552]	@ (3418c9d8 <HAL_RCCEx_PeriphCLKConfig+0x14cc>)
3418c7ae:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3418c7b0:	bf02      	ittt	eq
3418c7b2:	2240      	moveq	r2, #64	@ 0x40
3418c7b4:	4b80      	ldreq	r3, [pc, #512]	@ (3418c9b8 <HAL_RCCEx_PeriphCLKConfig+0x14ac>)
3418c7b6:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3418c7ba:	f7ff ba2f 	b.w	3418bc1c <HAL_RCCEx_PeriphCLKConfig+0x710>
    else if (PeriphClkInit->Lpuart1ClockSelection == RCC_LPUART1CLKSOURCE_IC14)
3418c7be:	f5b1 7f40 	cmp.w	r1, #768	@ 0x300
3418c7c2:	d111      	bne.n	3418c7e8 <HAL_RCCEx_PeriphCLKConfig+0x12dc>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3418c7c4:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3418c7c8:	6f60      	ldr	r0, [r4, #116]	@ 0x74
3418c7ca:	6f27      	ldr	r7, [r4, #112]	@ 0x70
3418c7cc:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418c7d0:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418c7d4:	3801      	subs	r0, #1
3418c7d6:	433b      	orrs	r3, r7
3418c7d8:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
3418c7dc:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3418c7e0:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3418c7e4:	f7ff ba35 	b.w	3418bc52 <HAL_RCCEx_PeriphCLKConfig+0x746>
    else if (PeriphClkInit->Lpuart1ClockSelection == RCC_LPUART1CLKSOURCE_CLKP)
3418c7e8:	f5b1 7f80 	cmp.w	r1, #256	@ 0x100
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3418c7ec:	bf04      	itt	eq
3418c7ee:	2340      	moveq	r3, #64	@ 0x40
3418c7f0:	f8c2 3a48 	streq.w	r3, [r2, #2632]	@ 0xa48
}
3418c7f4:	f7ff ba2f 	b.w	3418bc56 <HAL_RCCEx_PeriphCLKConfig+0x74a>
    else if (PeriphClkInit->LtdcClockSelection == RCC_LTDCCLKSOURCE_CLKP)
3418c7f8:	f1b1 7f80 	cmp.w	r1, #16777216	@ 0x1000000
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3418c7fc:	bf04      	itt	eq
3418c7fe:	2340      	moveq	r3, #64	@ 0x40
3418c800:	f8c2 3a48 	streq.w	r3, [r2, #2632]	@ 0xa48
}
3418c804:	f7ff ba65 	b.w	3418bcd2 <HAL_RCCEx_PeriphCLKConfig+0x7c6>
    else if (PeriphClkInit->Mdf1ClockSelection == RCC_MDF1CLKSOURCE_IC8)
3418c808:	f5b1 3f40 	cmp.w	r1, #196608	@ 0x30000
3418c80c:	d110      	bne.n	3418c830 <HAL_RCCEx_PeriphCLKConfig+0x1324>
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3418c80e:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
3418c812:	6c60      	ldr	r0, [r4, #68]	@ 0x44
3418c814:	6c27      	ldr	r7, [r4, #64]	@ 0x40
3418c816:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418c81a:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418c81e:	3801      	subs	r0, #1
3418c820:	433b      	orrs	r3, r7
3418c822:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
3418c826:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3418c82a:	2380      	movs	r3, #128	@ 0x80
3418c82c:	f7ff ba71 	b.w	3418bd12 <HAL_RCCEx_PeriphCLKConfig+0x806>
    else if (PeriphClkInit->Mdf1ClockSelection == RCC_MDF1CLKSOURCE_CLKP)
3418c830:	f5b1 3f80 	cmp.w	r1, #65536	@ 0x10000
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3418c834:	bf04      	itt	eq
3418c836:	2340      	moveq	r3, #64	@ 0x40
3418c838:	f8c2 3a48 	streq.w	r3, [r2, #2632]	@ 0xa48
}
3418c83c:	f7ff ba6b 	b.w	3418bd16 <HAL_RCCEx_PeriphCLKConfig+0x80a>
    else if (PeriphClkInit->PssiClockSelection == RCC_PSSICLKSOURCE_CLKP)
3418c840:	2910      	cmp	r1, #16
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3418c842:	bf04      	itt	eq
3418c844:	2340      	moveq	r3, #64	@ 0x40
3418c846:	f8c2 3a48 	streq.w	r3, [r2, #2632]	@ 0xa48
}
3418c84a:	f7ff ba88 	b.w	3418bd5e <HAL_RCCEx_PeriphCLKConfig+0x852>
    else if (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_IC8)
3418c84e:	4b63      	ldr	r3, [pc, #396]	@ (3418c9dc <HAL_RCCEx_PeriphCLKConfig+0x14d0>)
3418c850:	4298      	cmp	r0, r3
3418c852:	d111      	bne.n	3418c878 <HAL_RCCEx_PeriphCLKConfig+0x136c>
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3418c854:	4a58      	ldr	r2, [pc, #352]	@ (3418c9b8 <HAL_RCCEx_PeriphCLKConfig+0x14ac>)
3418c856:	6c61      	ldr	r1, [r4, #68]	@ 0x44
3418c858:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
3418c85c:	6c27      	ldr	r7, [r4, #64]	@ 0x40
3418c85e:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418c862:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418c866:	3901      	subs	r1, #1
3418c868:	433b      	orrs	r3, r7
3418c86a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418c86e:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3418c872:	2380      	movs	r3, #128	@ 0x80
3418c874:	f7ff ba93 	b.w	3418bd9e <HAL_RCCEx_PeriphCLKConfig+0x892>
    else if (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_CLKP)
3418c878:	4b59      	ldr	r3, [pc, #356]	@ (3418c9e0 <HAL_RCCEx_PeriphCLKConfig+0x14d4>)
3418c87a:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3418c87c:	bf02      	ittt	eq
3418c87e:	2240      	moveq	r2, #64	@ 0x40
3418c880:	4b4d      	ldreq	r3, [pc, #308]	@ (3418c9b8 <HAL_RCCEx_PeriphCLKConfig+0x14ac>)
3418c882:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3418c886:	f7ff ba8c 	b.w	3418bda2 <HAL_RCCEx_PeriphCLKConfig+0x896>
    else if (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_IC8)
3418c88a:	4b56      	ldr	r3, [pc, #344]	@ (3418c9e4 <HAL_RCCEx_PeriphCLKConfig+0x14d8>)
3418c88c:	4298      	cmp	r0, r3
3418c88e:	d111      	bne.n	3418c8b4 <HAL_RCCEx_PeriphCLKConfig+0x13a8>
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3418c890:	4a49      	ldr	r2, [pc, #292]	@ (3418c9b8 <HAL_RCCEx_PeriphCLKConfig+0x14ac>)
3418c892:	6c61      	ldr	r1, [r4, #68]	@ 0x44
3418c894:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
3418c898:	6c25      	ldr	r5, [r4, #64]	@ 0x40
3418c89a:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418c89e:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418c8a2:	3901      	subs	r1, #1
3418c8a4:	432b      	orrs	r3, r5
3418c8a6:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418c8aa:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3418c8ae:	2380      	movs	r3, #128	@ 0x80
3418c8b0:	f7ff ba91 	b.w	3418bdd6 <HAL_RCCEx_PeriphCLKConfig+0x8ca>
    else if (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_CLKP)
3418c8b4:	4b4c      	ldr	r3, [pc, #304]	@ (3418c9e8 <HAL_RCCEx_PeriphCLKConfig+0x14dc>)
3418c8b6:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3418c8b8:	bf02      	ittt	eq
3418c8ba:	2240      	moveq	r2, #64	@ 0x40
3418c8bc:	4b3e      	ldreq	r3, [pc, #248]	@ (3418c9b8 <HAL_RCCEx_PeriphCLKConfig+0x14ac>)
3418c8be:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3418c8c2:	f7ff ba8a 	b.w	3418bdda <HAL_RCCEx_PeriphCLKConfig+0x8ce>
    else if (PeriphClkInit->Spdifrx1ClockSelection == RCC_SPDIFRX1CLKSOURCE_IC8)
3418c8c6:	2903      	cmp	r1, #3
3418c8c8:	d110      	bne.n	3418c8ec <HAL_RCCEx_PeriphCLKConfig+0x13e0>
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3418c8ca:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
3418c8ce:	6c60      	ldr	r0, [r4, #68]	@ 0x44
3418c8d0:	6c25      	ldr	r5, [r4, #64]	@ 0x40
3418c8d2:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418c8d6:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418c8da:	3801      	subs	r0, #1
3418c8dc:	432b      	orrs	r3, r5
3418c8de:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
3418c8e2:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3418c8e6:	2380      	movs	r3, #128	@ 0x80
3418c8e8:	f7ff ba90 	b.w	3418be0c <HAL_RCCEx_PeriphCLKConfig+0x900>
    else if (PeriphClkInit->Spdifrx1ClockSelection == RCC_SPDIFRX1CLKSOURCE_CLKP)
3418c8ec:	2901      	cmp	r1, #1
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3418c8ee:	bf04      	itt	eq
3418c8f0:	2340      	moveq	r3, #64	@ 0x40
3418c8f2:	f8c2 3a48 	streq.w	r3, [r2, #2632]	@ 0xa48
}
3418c8f6:	f7ff ba8b 	b.w	3418be10 <HAL_RCCEx_PeriphCLKConfig+0x904>
    else if (PeriphClkInit->Spi1ClockSelection == RCC_SPI1CLKSOURCE_IC9)
3418c8fa:	4b3c      	ldr	r3, [pc, #240]	@ (3418c9ec <HAL_RCCEx_PeriphCLKConfig+0x14e0>)
3418c8fc:	4298      	cmp	r0, r3
3418c8fe:	d112      	bne.n	3418c926 <HAL_RCCEx_PeriphCLKConfig+0x141a>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3418c900:	4a2d      	ldr	r2, [pc, #180]	@ (3418c9b8 <HAL_RCCEx_PeriphCLKConfig+0x14ac>)
3418c902:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3418c904:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3418c908:	6ca5      	ldr	r5, [r4, #72]	@ 0x48
3418c90a:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418c90e:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418c912:	3901      	subs	r1, #1
3418c914:	432b      	orrs	r3, r5
3418c916:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418c91a:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3418c91e:	f44f 7380 	mov.w	r3, #256	@ 0x100
3418c922:	f7ff ba95 	b.w	3418be50 <HAL_RCCEx_PeriphCLKConfig+0x944>
    else if (PeriphClkInit->Spi1ClockSelection == RCC_SPI1CLKSOURCE_CLKP)
3418c926:	4b32      	ldr	r3, [pc, #200]	@ (3418c9f0 <HAL_RCCEx_PeriphCLKConfig+0x14e4>)
3418c928:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3418c92a:	bf02      	ittt	eq
3418c92c:	2240      	moveq	r2, #64	@ 0x40
3418c92e:	4b22      	ldreq	r3, [pc, #136]	@ (3418c9b8 <HAL_RCCEx_PeriphCLKConfig+0x14ac>)
3418c930:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3418c934:	f7ff ba8e 	b.w	3418be54 <HAL_RCCEx_PeriphCLKConfig+0x948>
    else if (PeriphClkInit->Spi2ClockSelection == RCC_SPI2CLKSOURCE_IC9)
3418c938:	4b2e      	ldr	r3, [pc, #184]	@ (3418c9f4 <HAL_RCCEx_PeriphCLKConfig+0x14e8>)
3418c93a:	4298      	cmp	r0, r3
3418c93c:	d112      	bne.n	3418c964 <HAL_RCCEx_PeriphCLKConfig+0x1458>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3418c93e:	4a1e      	ldr	r2, [pc, #120]	@ (3418c9b8 <HAL_RCCEx_PeriphCLKConfig+0x14ac>)
3418c940:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3418c942:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3418c946:	6ca5      	ldr	r5, [r4, #72]	@ 0x48
3418c948:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418c94c:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418c950:	3901      	subs	r1, #1
3418c952:	432b      	orrs	r3, r5
3418c954:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418c958:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3418c95c:	f44f 7380 	mov.w	r3, #256	@ 0x100
3418c960:	f7ff ba92 	b.w	3418be88 <HAL_RCCEx_PeriphCLKConfig+0x97c>
    else if (PeriphClkInit->Spi2ClockSelection == RCC_SPI2CLKSOURCE_CLKP)
3418c964:	4b24      	ldr	r3, [pc, #144]	@ (3418c9f8 <HAL_RCCEx_PeriphCLKConfig+0x14ec>)
3418c966:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3418c968:	bf02      	ittt	eq
3418c96a:	2240      	moveq	r2, #64	@ 0x40
3418c96c:	4b12      	ldreq	r3, [pc, #72]	@ (3418c9b8 <HAL_RCCEx_PeriphCLKConfig+0x14ac>)
3418c96e:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3418c972:	f7ff ba8b 	b.w	3418be8c <HAL_RCCEx_PeriphCLKConfig+0x980>
    else if (PeriphClkInit->Spi3ClockSelection == RCC_SPI3CLKSOURCE_IC9)
3418c976:	4b21      	ldr	r3, [pc, #132]	@ (3418c9fc <HAL_RCCEx_PeriphCLKConfig+0x14f0>)
3418c978:	4298      	cmp	r0, r3
3418c97a:	d112      	bne.n	3418c9a2 <HAL_RCCEx_PeriphCLKConfig+0x1496>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3418c97c:	4a0e      	ldr	r2, [pc, #56]	@ (3418c9b8 <HAL_RCCEx_PeriphCLKConfig+0x14ac>)
3418c97e:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3418c980:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3418c984:	6ca5      	ldr	r5, [r4, #72]	@ 0x48
3418c986:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418c98a:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418c98e:	3901      	subs	r1, #1
3418c990:	432b      	orrs	r3, r5
3418c992:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418c996:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3418c99a:	f44f 7380 	mov.w	r3, #256	@ 0x100
3418c99e:	f7ff ba8f 	b.w	3418bec0 <HAL_RCCEx_PeriphCLKConfig+0x9b4>
    else if (PeriphClkInit->Spi3ClockSelection == RCC_SPI3CLKSOURCE_CLKP)
3418c9a2:	4b17      	ldr	r3, [pc, #92]	@ (3418ca00 <HAL_RCCEx_PeriphCLKConfig+0x14f4>)
3418c9a4:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3418c9a6:	bf02      	ittt	eq
3418c9a8:	2240      	moveq	r2, #64	@ 0x40
3418c9aa:	4b03      	ldreq	r3, [pc, #12]	@ (3418c9b8 <HAL_RCCEx_PeriphCLKConfig+0x14ac>)
3418c9ac:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3418c9b0:	f7ff ba88 	b.w	3418bec4 <HAL_RCCEx_PeriphCLKConfig+0x9b8>
3418c9b4:	0703100c 	.word	0x0703100c
3418c9b8:	56028000 	.word	0x56028000
3418c9bc:	0701100c 	.word	0x0701100c
3418c9c0:	0703140c 	.word	0x0703140c
3418c9c4:	0701140c 	.word	0x0701140c
3418c9c8:	0701082c 	.word	0x0701082c
3418c9cc:	07010c2c 	.word	0x07010c2c
3418c9d0:	0701102c 	.word	0x0701102c
3418c9d4:	0701142c 	.word	0x0701142c
3418c9d8:	0701182c 	.word	0x0701182c
3418c9dc:	07031418 	.word	0x07031418
3418c9e0:	07011418 	.word	0x07011418
3418c9e4:	07031818 	.word	0x07031818
3418c9e8:	07011818 	.word	0x07011818
3418c9ec:	07030420 	.word	0x07030420
3418c9f0:	07010420 	.word	0x07010420
3418c9f4:	07030820 	.word	0x07030820
3418c9f8:	07010820 	.word	0x07010820
3418c9fc:	07030c20 	.word	0x07030c20
3418ca00:	07010c20 	.word	0x07010c20
    else if (PeriphClkInit->Spi4ClockSelection == RCC_SPI4CLKSOURCE_IC14)
3418ca04:	4bb9      	ldr	r3, [pc, #740]	@ (3418ccec <HAL_RCCEx_PeriphCLKConfig+0x17e0>)
3418ca06:	4298      	cmp	r0, r3
3418ca08:	d112      	bne.n	3418ca30 <HAL_RCCEx_PeriphCLKConfig+0x1524>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3418ca0a:	4ab9      	ldr	r2, [pc, #740]	@ (3418ccf0 <HAL_RCCEx_PeriphCLKConfig+0x17e4>)
3418ca0c:	6f61      	ldr	r1, [r4, #116]	@ 0x74
3418ca0e:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3418ca12:	6f25      	ldr	r5, [r4, #112]	@ 0x70
3418ca14:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418ca18:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418ca1c:	3901      	subs	r1, #1
3418ca1e:	432b      	orrs	r3, r5
3418ca20:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418ca24:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3418ca28:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3418ca2c:	f7ff ba65 	b.w	3418befa <HAL_RCCEx_PeriphCLKConfig+0x9ee>
    else if (PeriphClkInit->Spi4ClockSelection == RCC_SPI4CLKSOURCE_CLKP)
3418ca30:	4bb0      	ldr	r3, [pc, #704]	@ (3418ccf4 <HAL_RCCEx_PeriphCLKConfig+0x17e8>)
3418ca32:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3418ca34:	bf02      	ittt	eq
3418ca36:	2240      	moveq	r2, #64	@ 0x40
3418ca38:	4bad      	ldreq	r3, [pc, #692]	@ (3418ccf0 <HAL_RCCEx_PeriphCLKConfig+0x17e4>)
3418ca3a:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3418ca3e:	f7ff ba5e 	b.w	3418befe <HAL_RCCEx_PeriphCLKConfig+0x9f2>
    else if (PeriphClkInit->Spi5ClockSelection == RCC_SPI5CLKSOURCE_IC14)
3418ca42:	4bad      	ldr	r3, [pc, #692]	@ (3418ccf8 <HAL_RCCEx_PeriphCLKConfig+0x17ec>)
3418ca44:	4298      	cmp	r0, r3
3418ca46:	d112      	bne.n	3418ca6e <HAL_RCCEx_PeriphCLKConfig+0x1562>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3418ca48:	4aa9      	ldr	r2, [pc, #676]	@ (3418ccf0 <HAL_RCCEx_PeriphCLKConfig+0x17e4>)
3418ca4a:	6f61      	ldr	r1, [r4, #116]	@ 0x74
3418ca4c:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3418ca50:	6f25      	ldr	r5, [r4, #112]	@ 0x70
3418ca52:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418ca56:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418ca5a:	3901      	subs	r1, #1
3418ca5c:	432b      	orrs	r3, r5
3418ca5e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418ca62:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3418ca66:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3418ca6a:	f7ff ba63 	b.w	3418bf34 <HAL_RCCEx_PeriphCLKConfig+0xa28>
    else if (PeriphClkInit->Spi5ClockSelection == RCC_SPI5CLKSOURCE_CLKP)
3418ca6e:	4ba3      	ldr	r3, [pc, #652]	@ (3418ccfc <HAL_RCCEx_PeriphCLKConfig+0x17f0>)
3418ca70:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3418ca72:	bf02      	ittt	eq
3418ca74:	2240      	moveq	r2, #64	@ 0x40
3418ca76:	4b9e      	ldreq	r3, [pc, #632]	@ (3418ccf0 <HAL_RCCEx_PeriphCLKConfig+0x17e4>)
3418ca78:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3418ca7c:	f7ff ba5c 	b.w	3418bf38 <HAL_RCCEx_PeriphCLKConfig+0xa2c>
    else if (PeriphClkInit->Spi6ClockSelection == RCC_SPI6CLKSOURCE_IC9)
3418ca80:	4b9f      	ldr	r3, [pc, #636]	@ (3418cd00 <HAL_RCCEx_PeriphCLKConfig+0x17f4>)
3418ca82:	4298      	cmp	r0, r3
3418ca84:	d112      	bne.n	3418caac <HAL_RCCEx_PeriphCLKConfig+0x15a0>
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3418ca86:	4a9a      	ldr	r2, [pc, #616]	@ (3418ccf0 <HAL_RCCEx_PeriphCLKConfig+0x17e4>)
3418ca88:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
3418ca8a:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
3418ca8e:	6ca5      	ldr	r5, [r4, #72]	@ 0x48
3418ca90:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418ca94:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418ca98:	3901      	subs	r1, #1
3418ca9a:	432b      	orrs	r3, r5
3418ca9c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418caa0:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3418caa4:	f44f 7380 	mov.w	r3, #256	@ 0x100
3418caa8:	f7ff ba60 	b.w	3418bf6c <HAL_RCCEx_PeriphCLKConfig+0xa60>
    else if (PeriphClkInit->Spi6ClockSelection == RCC_SPI6CLKSOURCE_CLKP)
3418caac:	4b95      	ldr	r3, [pc, #596]	@ (3418cd04 <HAL_RCCEx_PeriphCLKConfig+0x17f8>)
3418caae:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3418cab0:	bf02      	ittt	eq
3418cab2:	2240      	moveq	r2, #64	@ 0x40
3418cab4:	4b8e      	ldreq	r3, [pc, #568]	@ (3418ccf0 <HAL_RCCEx_PeriphCLKConfig+0x17e4>)
3418cab6:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3418caba:	f7ff ba59 	b.w	3418bf70 <HAL_RCCEx_PeriphCLKConfig+0xa64>
    else if (PeriphClkInit->Usart1ClockSelection == RCC_USART1CLKSOURCE_IC14)
3418cabe:	4b92      	ldr	r3, [pc, #584]	@ (3418cd08 <HAL_RCCEx_PeriphCLKConfig+0x17fc>)
3418cac0:	4298      	cmp	r0, r3
3418cac2:	d112      	bne.n	3418caea <HAL_RCCEx_PeriphCLKConfig+0x15de>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3418cac4:	4a8a      	ldr	r2, [pc, #552]	@ (3418ccf0 <HAL_RCCEx_PeriphCLKConfig+0x17e4>)
3418cac6:	6f61      	ldr	r1, [r4, #116]	@ 0x74
3418cac8:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3418cacc:	6f25      	ldr	r5, [r4, #112]	@ 0x70
3418cace:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418cad2:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418cad6:	3901      	subs	r1, #1
3418cad8:	432b      	orrs	r3, r5
3418cada:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418cade:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3418cae2:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3418cae6:	f7ff ba5e 	b.w	3418bfa6 <HAL_RCCEx_PeriphCLKConfig+0xa9a>
    else if (PeriphClkInit->Usart1ClockSelection == RCC_USART1CLKSOURCE_CLKP)
3418caea:	4b88      	ldr	r3, [pc, #544]	@ (3418cd0c <HAL_RCCEx_PeriphCLKConfig+0x1800>)
3418caec:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3418caee:	bf02      	ittt	eq
3418caf0:	2240      	moveq	r2, #64	@ 0x40
3418caf2:	4b7f      	ldreq	r3, [pc, #508]	@ (3418ccf0 <HAL_RCCEx_PeriphCLKConfig+0x17e4>)
3418caf4:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3418caf8:	f7ff ba57 	b.w	3418bfaa <HAL_RCCEx_PeriphCLKConfig+0xa9e>
    else if (PeriphClkInit->Usart2ClockSelection == RCC_USART2CLKSOURCE_IC14)
3418cafc:	4b84      	ldr	r3, [pc, #528]	@ (3418cd10 <HAL_RCCEx_PeriphCLKConfig+0x1804>)
3418cafe:	4298      	cmp	r0, r3
3418cb00:	d112      	bne.n	3418cb28 <HAL_RCCEx_PeriphCLKConfig+0x161c>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3418cb02:	4a7b      	ldr	r2, [pc, #492]	@ (3418ccf0 <HAL_RCCEx_PeriphCLKConfig+0x17e4>)
3418cb04:	6f61      	ldr	r1, [r4, #116]	@ 0x74
3418cb06:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3418cb0a:	6f25      	ldr	r5, [r4, #112]	@ 0x70
3418cb0c:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418cb10:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418cb14:	3901      	subs	r1, #1
3418cb16:	432b      	orrs	r3, r5
3418cb18:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418cb1c:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3418cb20:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3418cb24:	f7ff ba73 	b.w	3418c00e <HAL_RCCEx_PeriphCLKConfig+0xb02>
    else if (PeriphClkInit->Usart2ClockSelection == RCC_USART2CLKSOURCE_CLKP)
3418cb28:	4b7a      	ldr	r3, [pc, #488]	@ (3418cd14 <HAL_RCCEx_PeriphCLKConfig+0x1808>)
3418cb2a:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3418cb2c:	bf02      	ittt	eq
3418cb2e:	2240      	moveq	r2, #64	@ 0x40
3418cb30:	4b6f      	ldreq	r3, [pc, #444]	@ (3418ccf0 <HAL_RCCEx_PeriphCLKConfig+0x17e4>)
3418cb32:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3418cb36:	f7ff ba6c 	b.w	3418c012 <HAL_RCCEx_PeriphCLKConfig+0xb06>
    else if (PeriphClkInit->Usart3ClockSelection == RCC_USART3CLKSOURCE_IC14)
3418cb3a:	4b77      	ldr	r3, [pc, #476]	@ (3418cd18 <HAL_RCCEx_PeriphCLKConfig+0x180c>)
3418cb3c:	4298      	cmp	r0, r3
3418cb3e:	d112      	bne.n	3418cb66 <HAL_RCCEx_PeriphCLKConfig+0x165a>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3418cb40:	4a6b      	ldr	r2, [pc, #428]	@ (3418ccf0 <HAL_RCCEx_PeriphCLKConfig+0x17e4>)
3418cb42:	6f61      	ldr	r1, [r4, #116]	@ 0x74
3418cb44:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3418cb48:	6f25      	ldr	r5, [r4, #112]	@ 0x70
3418cb4a:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418cb4e:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418cb52:	3901      	subs	r1, #1
3418cb54:	432b      	orrs	r3, r5
3418cb56:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418cb5a:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3418cb5e:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3418cb62:	f7ff ba71 	b.w	3418c048 <HAL_RCCEx_PeriphCLKConfig+0xb3c>
    else if (PeriphClkInit->Usart3ClockSelection == RCC_USART3CLKSOURCE_CLKP)
3418cb66:	4b6d      	ldr	r3, [pc, #436]	@ (3418cd1c <HAL_RCCEx_PeriphCLKConfig+0x1810>)
3418cb68:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3418cb6a:	bf02      	ittt	eq
3418cb6c:	2240      	moveq	r2, #64	@ 0x40
3418cb6e:	4b60      	ldreq	r3, [pc, #384]	@ (3418ccf0 <HAL_RCCEx_PeriphCLKConfig+0x17e4>)
3418cb70:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3418cb74:	f7ff ba6a 	b.w	3418c04c <HAL_RCCEx_PeriphCLKConfig+0xb40>
    else if (PeriphClkInit->Uart4ClockSelection == RCC_UART4CLKSOURCE_IC14)
3418cb78:	4b69      	ldr	r3, [pc, #420]	@ (3418cd20 <HAL_RCCEx_PeriphCLKConfig+0x1814>)
3418cb7a:	4298      	cmp	r0, r3
3418cb7c:	d112      	bne.n	3418cba4 <HAL_RCCEx_PeriphCLKConfig+0x1698>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3418cb7e:	4a5c      	ldr	r2, [pc, #368]	@ (3418ccf0 <HAL_RCCEx_PeriphCLKConfig+0x17e4>)
3418cb80:	6f61      	ldr	r1, [r4, #116]	@ 0x74
3418cb82:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3418cb86:	6f25      	ldr	r5, [r4, #112]	@ 0x70
3418cb88:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418cb8c:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418cb90:	3901      	subs	r1, #1
3418cb92:	432b      	orrs	r3, r5
3418cb94:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418cb98:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3418cb9c:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3418cba0:	f7ff ba6f 	b.w	3418c082 <HAL_RCCEx_PeriphCLKConfig+0xb76>
    else if (PeriphClkInit->Uart4ClockSelection == RCC_UART4CLKSOURCE_CLKP)
3418cba4:	4b5f      	ldr	r3, [pc, #380]	@ (3418cd24 <HAL_RCCEx_PeriphCLKConfig+0x1818>)
3418cba6:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3418cba8:	bf02      	ittt	eq
3418cbaa:	2240      	moveq	r2, #64	@ 0x40
3418cbac:	4b50      	ldreq	r3, [pc, #320]	@ (3418ccf0 <HAL_RCCEx_PeriphCLKConfig+0x17e4>)
3418cbae:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3418cbb2:	f7ff ba68 	b.w	3418c086 <HAL_RCCEx_PeriphCLKConfig+0xb7a>
    else if (PeriphClkInit->Uart5ClockSelection == RCC_UART5CLKSOURCE_IC14)
3418cbb6:	4b5c      	ldr	r3, [pc, #368]	@ (3418cd28 <HAL_RCCEx_PeriphCLKConfig+0x181c>)
3418cbb8:	4298      	cmp	r0, r3
3418cbba:	d112      	bne.n	3418cbe2 <HAL_RCCEx_PeriphCLKConfig+0x16d6>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3418cbbc:	4a4c      	ldr	r2, [pc, #304]	@ (3418ccf0 <HAL_RCCEx_PeriphCLKConfig+0x17e4>)
3418cbbe:	6f61      	ldr	r1, [r4, #116]	@ 0x74
3418cbc0:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3418cbc4:	6f25      	ldr	r5, [r4, #112]	@ 0x70
3418cbc6:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418cbca:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418cbce:	3901      	subs	r1, #1
3418cbd0:	432b      	orrs	r3, r5
3418cbd2:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418cbd6:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3418cbda:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3418cbde:	f7ff ba6d 	b.w	3418c0bc <HAL_RCCEx_PeriphCLKConfig+0xbb0>
    else if (PeriphClkInit->Uart5ClockSelection == RCC_UART5CLKSOURCE_CLKP)
3418cbe2:	4b52      	ldr	r3, [pc, #328]	@ (3418cd2c <HAL_RCCEx_PeriphCLKConfig+0x1820>)
3418cbe4:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3418cbe6:	bf02      	ittt	eq
3418cbe8:	2240      	moveq	r2, #64	@ 0x40
3418cbea:	4b41      	ldreq	r3, [pc, #260]	@ (3418ccf0 <HAL_RCCEx_PeriphCLKConfig+0x17e4>)
3418cbec:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3418cbf0:	f7ff ba66 	b.w	3418c0c0 <HAL_RCCEx_PeriphCLKConfig+0xbb4>
    else if (PeriphClkInit->Usart6ClockSelection == RCC_USART6CLKSOURCE_IC14)
3418cbf4:	4b4e      	ldr	r3, [pc, #312]	@ (3418cd30 <HAL_RCCEx_PeriphCLKConfig+0x1824>)
3418cbf6:	4298      	cmp	r0, r3
3418cbf8:	d112      	bne.n	3418cc20 <HAL_RCCEx_PeriphCLKConfig+0x1714>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3418cbfa:	4a3d      	ldr	r2, [pc, #244]	@ (3418ccf0 <HAL_RCCEx_PeriphCLKConfig+0x17e4>)
3418cbfc:	6f61      	ldr	r1, [r4, #116]	@ 0x74
3418cbfe:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3418cc02:	6f25      	ldr	r5, [r4, #112]	@ 0x70
3418cc04:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418cc08:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418cc0c:	3901      	subs	r1, #1
3418cc0e:	432b      	orrs	r3, r5
3418cc10:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418cc14:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3418cc18:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3418cc1c:	f7ff ba6b 	b.w	3418c0f6 <HAL_RCCEx_PeriphCLKConfig+0xbea>
    else if (PeriphClkInit->Usart6ClockSelection == RCC_USART6CLKSOURCE_CLKP)
3418cc20:	4b44      	ldr	r3, [pc, #272]	@ (3418cd34 <HAL_RCCEx_PeriphCLKConfig+0x1828>)
3418cc22:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3418cc24:	bf02      	ittt	eq
3418cc26:	2240      	moveq	r2, #64	@ 0x40
3418cc28:	4b31      	ldreq	r3, [pc, #196]	@ (3418ccf0 <HAL_RCCEx_PeriphCLKConfig+0x17e4>)
3418cc2a:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3418cc2e:	f7ff ba64 	b.w	3418c0fa <HAL_RCCEx_PeriphCLKConfig+0xbee>
    else if (PeriphClkInit->Uart7ClockSelection == RCC_UART7CLKSOURCE_IC14)
3418cc32:	4b41      	ldr	r3, [pc, #260]	@ (3418cd38 <HAL_RCCEx_PeriphCLKConfig+0x182c>)
3418cc34:	4298      	cmp	r0, r3
3418cc36:	d112      	bne.n	3418cc5e <HAL_RCCEx_PeriphCLKConfig+0x1752>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3418cc38:	4a2d      	ldr	r2, [pc, #180]	@ (3418ccf0 <HAL_RCCEx_PeriphCLKConfig+0x17e4>)
3418cc3a:	6f61      	ldr	r1, [r4, #116]	@ 0x74
3418cc3c:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3418cc40:	6f25      	ldr	r5, [r4, #112]	@ 0x70
3418cc42:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418cc46:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418cc4a:	3901      	subs	r1, #1
3418cc4c:	432b      	orrs	r3, r5
3418cc4e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418cc52:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3418cc56:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3418cc5a:	f7ff ba69 	b.w	3418c130 <HAL_RCCEx_PeriphCLKConfig+0xc24>
    else if (PeriphClkInit->Uart7ClockSelection == RCC_UART7CLKSOURCE_CLKP)
3418cc5e:	4b37      	ldr	r3, [pc, #220]	@ (3418cd3c <HAL_RCCEx_PeriphCLKConfig+0x1830>)
3418cc60:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3418cc62:	bf02      	ittt	eq
3418cc64:	2240      	moveq	r2, #64	@ 0x40
3418cc66:	4b22      	ldreq	r3, [pc, #136]	@ (3418ccf0 <HAL_RCCEx_PeriphCLKConfig+0x17e4>)
3418cc68:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3418cc6c:	f7ff ba62 	b.w	3418c134 <HAL_RCCEx_PeriphCLKConfig+0xc28>
    else if (PeriphClkInit->Uart8ClockSelection == RCC_UART8CLKSOURCE_IC14)
3418cc70:	4b33      	ldr	r3, [pc, #204]	@ (3418cd40 <HAL_RCCEx_PeriphCLKConfig+0x1834>)
3418cc72:	4298      	cmp	r0, r3
3418cc74:	d112      	bne.n	3418cc9c <HAL_RCCEx_PeriphCLKConfig+0x1790>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3418cc76:	4a1e      	ldr	r2, [pc, #120]	@ (3418ccf0 <HAL_RCCEx_PeriphCLKConfig+0x17e4>)
3418cc78:	6f61      	ldr	r1, [r4, #116]	@ 0x74
3418cc7a:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3418cc7e:	6f25      	ldr	r5, [r4, #112]	@ 0x70
3418cc80:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418cc84:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418cc88:	3901      	subs	r1, #1
3418cc8a:	432b      	orrs	r3, r5
3418cc8c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418cc90:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3418cc94:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3418cc98:	f7ff ba67 	b.w	3418c16a <HAL_RCCEx_PeriphCLKConfig+0xc5e>
    else if (PeriphClkInit->Uart8ClockSelection == RCC_UART8CLKSOURCE_CLKP)
3418cc9c:	4b29      	ldr	r3, [pc, #164]	@ (3418cd44 <HAL_RCCEx_PeriphCLKConfig+0x1838>)
3418cc9e:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3418cca0:	bf02      	ittt	eq
3418cca2:	2240      	moveq	r2, #64	@ 0x40
3418cca4:	4b12      	ldreq	r3, [pc, #72]	@ (3418ccf0 <HAL_RCCEx_PeriphCLKConfig+0x17e4>)
3418cca6:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3418ccaa:	f7ff ba60 	b.w	3418c16e <HAL_RCCEx_PeriphCLKConfig+0xc62>
    else if (PeriphClkInit->Uart9ClockSelection == RCC_UART9CLKSOURCE_IC14)
3418ccae:	4b26      	ldr	r3, [pc, #152]	@ (3418cd48 <HAL_RCCEx_PeriphCLKConfig+0x183c>)
3418ccb0:	4298      	cmp	r0, r3
3418ccb2:	d112      	bne.n	3418ccda <HAL_RCCEx_PeriphCLKConfig+0x17ce>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3418ccb4:	4a0e      	ldr	r2, [pc, #56]	@ (3418ccf0 <HAL_RCCEx_PeriphCLKConfig+0x17e4>)
3418ccb6:	6f61      	ldr	r1, [r4, #116]	@ 0x74
3418ccb8:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3418ccbc:	6f25      	ldr	r5, [r4, #112]	@ 0x70
3418ccbe:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418ccc2:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418ccc6:	3901      	subs	r1, #1
3418ccc8:	432b      	orrs	r3, r5
3418ccca:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418ccce:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3418ccd2:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3418ccd6:	f7ff ba65 	b.w	3418c1a4 <HAL_RCCEx_PeriphCLKConfig+0xc98>
    else if (PeriphClkInit->Uart9ClockSelection == RCC_UART9CLKSOURCE_CLKP)
3418ccda:	4b1c      	ldr	r3, [pc, #112]	@ (3418cd4c <HAL_RCCEx_PeriphCLKConfig+0x1840>)
3418ccdc:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3418ccde:	bf02      	ittt	eq
3418cce0:	2240      	moveq	r2, #64	@ 0x40
3418cce2:	4b03      	ldreq	r3, [pc, #12]	@ (3418ccf0 <HAL_RCCEx_PeriphCLKConfig+0x17e4>)
3418cce4:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3418cce8:	f7ff ba5e 	b.w	3418c1a8 <HAL_RCCEx_PeriphCLKConfig+0xc9c>
3418ccec:	07031020 	.word	0x07031020
3418ccf0:	56028000 	.word	0x56028000
3418ccf4:	07011020 	.word	0x07011020
3418ccf8:	07031420 	.word	0x07031420
3418ccfc:	07011420 	.word	0x07011420
3418cd00:	07031820 	.word	0x07031820
3418cd04:	07011820 	.word	0x07011820
3418cd08:	07030030 	.word	0x07030030
3418cd0c:	07010030 	.word	0x07010030
3418cd10:	07030430 	.word	0x07030430
3418cd14:	07010430 	.word	0x07010430
3418cd18:	07030830 	.word	0x07030830
3418cd1c:	07010830 	.word	0x07010830
3418cd20:	07030c30 	.word	0x07030c30
3418cd24:	07010c30 	.word	0x07010c30
3418cd28:	07031030 	.word	0x07031030
3418cd2c:	07011030 	.word	0x07011030
3418cd30:	07031430 	.word	0x07031430
3418cd34:	07011430 	.word	0x07011430
3418cd38:	07031830 	.word	0x07031830
3418cd3c:	07011830 	.word	0x07011830
3418cd40:	07031c30 	.word	0x07031c30
3418cd44:	07011c30 	.word	0x07011c30
3418cd48:	07030034 	.word	0x07030034
3418cd4c:	07010034 	.word	0x07010034
    else if (PeriphClkInit->Usart10ClockSelection == RCC_USART10CLKSOURCE_IC14)
3418cd50:	4b20      	ldr	r3, [pc, #128]	@ (3418cdd4 <HAL_RCCEx_PeriphCLKConfig+0x18c8>)
3418cd52:	4298      	cmp	r0, r3
3418cd54:	d112      	bne.n	3418cd7c <HAL_RCCEx_PeriphCLKConfig+0x1870>
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3418cd56:	4a20      	ldr	r2, [pc, #128]	@ (3418cdd8 <HAL_RCCEx_PeriphCLKConfig+0x18cc>)
3418cd58:	6f61      	ldr	r1, [r4, #116]	@ 0x74
3418cd5a:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3418cd5e:	6f25      	ldr	r5, [r4, #112]	@ 0x70
3418cd60:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3418cd64:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3418cd68:	3901      	subs	r1, #1
3418cd6a:	432b      	orrs	r3, r5
3418cd6c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3418cd70:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3418cd74:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3418cd78:	f7ff ba31 	b.w	3418c1de <HAL_RCCEx_PeriphCLKConfig+0xcd2>
    else if (PeriphClkInit->Usart10ClockSelection == RCC_USART10CLKSOURCE_CLKP)
3418cd7c:	4b17      	ldr	r3, [pc, #92]	@ (3418cddc <HAL_RCCEx_PeriphCLKConfig+0x18d0>)
3418cd7e:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3418cd80:	bf02      	ittt	eq
3418cd82:	2240      	moveq	r2, #64	@ 0x40
3418cd84:	4b14      	ldreq	r3, [pc, #80]	@ (3418cdd8 <HAL_RCCEx_PeriphCLKConfig+0x18cc>)
3418cd86:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3418cd8a:	f7ff ba2a 	b.w	3418c1e2 <HAL_RCCEx_PeriphCLKConfig+0xcd6>
    __HAL_RCC_USBPHY1_CONFIG(PeriphClkInit->UsbPhy1ClockSelection);
3418cd8e:	f7fe faa1 	bl	3418b2d4 <LL_RCC_HSE_SelectHSEAsDiv2Clock>
3418cd92:	f7ff ba37 	b.w	3418c204 <HAL_RCCEx_PeriphCLKConfig+0xcf8>
    __HAL_RCC_USBPHY2_CONFIG(PeriphClkInit->UsbPhy2ClockSelection);
3418cd96:	f7fe fa9d 	bl	3418b2d4 <LL_RCC_HSE_SelectHSEAsDiv2Clock>
3418cd9a:	f7ff ba42 	b.w	3418c222 <HAL_RCCEx_PeriphCLKConfig+0xd16>
    else if (PeriphClkInit->UsbOtgHs1ClockSelection == RCC_USBOTGHS1CLKSOURCE_CLKP)
3418cd9e:	4b10      	ldr	r3, [pc, #64]	@ (3418cde0 <HAL_RCCEx_PeriphCLKConfig+0x18d4>)
3418cda0:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3418cda2:	bf02      	ittt	eq
3418cda4:	2240      	moveq	r2, #64	@ 0x40
3418cda6:	4b0c      	ldreq	r3, [pc, #48]	@ (3418cdd8 <HAL_RCCEx_PeriphCLKConfig+0x18cc>)
3418cda8:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3418cdac:	f7ff ba54 	b.w	3418c258 <HAL_RCCEx_PeriphCLKConfig+0xd4c>
    __HAL_RCC_USBOTGHS1_CONFIG(PeriphClkInit->UsbOtgHs1ClockSelection);
3418cdb0:	f7fe fa90 	bl	3418b2d4 <LL_RCC_HSE_SelectHSEAsDiv2Clock>
3418cdb4:	f7ff ba5b 	b.w	3418c26e <HAL_RCCEx_PeriphCLKConfig+0xd62>
    else if (PeriphClkInit->UsbOtgHs2ClockSelection == RCC_USBOTGHS2CLKSOURCE_CLKP)
3418cdb8:	4b0a      	ldr	r3, [pc, #40]	@ (3418cde4 <HAL_RCCEx_PeriphCLKConfig+0x18d8>)
3418cdba:	4298      	cmp	r0, r3
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3418cdbc:	bf02      	ittt	eq
3418cdbe:	2240      	moveq	r2, #64	@ 0x40
3418cdc0:	4b05      	ldreq	r3, [pc, #20]	@ (3418cdd8 <HAL_RCCEx_PeriphCLKConfig+0x18cc>)
3418cdc2:	f8c3 2a48 	streq.w	r2, [r3, #2632]	@ 0xa48
}
3418cdc6:	f7ff ba6d 	b.w	3418c2a4 <HAL_RCCEx_PeriphCLKConfig+0xd98>
    __HAL_RCC_USBOTGHS2_CONFIG(PeriphClkInit->UsbOtgHs2ClockSelection);
3418cdca:	f7fe fa83 	bl	3418b2d4 <LL_RCC_HSE_SelectHSEAsDiv2Clock>
3418cdce:	f7ff ba74 	b.w	3418c2ba <HAL_RCCEx_PeriphCLKConfig+0xdae>
3418cdd2:	bf00      	nop
3418cdd4:	07030434 	.word	0x07030434
3418cdd8:	56028000 	.word	0x56028000
3418cddc:	07010434 	.word	0x07010434
3418cde0:	03010c14 	.word	0x03010c14
3418cde4:	03011414 	.word	0x03011414

3418cde8 <HAL_RCCEx_GetPLL1CLKFreq>:
{
3418cde8:	b537      	push	{r0, r1, r2, r4, r5, lr}
  return ((READ_BIT(RCC->SR, RCC_SR_PLL1RDY) == (RCC_SR_PLL1RDY)) ? 1UL : 0UL);
3418cdea:	4c1e      	ldr	r4, [pc, #120]	@ (3418ce64 <HAL_RCCEx_GetPLL1CLKFreq+0x7c>)
3418cdec:	6863      	ldr	r3, [r4, #4]
3418cdee:	05d9      	lsls	r1, r3, #23
3418cdf0:	d506      	bpl.n	3418ce00 <HAL_RCCEx_GetPLL1CLKFreq+0x18>
  return ((READ_BIT(RCC->PLL1CFGR3, RCC_PLL1CFGR3_PLL1PDIVEN) == RCC_PLL1CFGR3_PLL1PDIVEN) ? 1UL : 0UL);
3418cdf2:	f8d4 3088 	ldr.w	r3, [r4, #136]	@ 0x88
3418cdf6:	005a      	lsls	r2, r3, #1
3418cdf8:	d40f      	bmi.n	3418ce1a <HAL_RCCEx_GetPLL1CLKFreq+0x32>
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
3418cdfa:	2000      	movs	r0, #0
}
3418cdfc:	b003      	add	sp, #12
3418cdfe:	bd30      	pop	{r4, r5, pc}
  return ((READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1BYP) == RCC_PLL1CFGR1_PLL1BYP) ? 1UL : 0UL);
3418ce00:	f8d4 3080 	ldr.w	r3, [r4, #128]	@ 0x80
3418ce04:	011b      	lsls	r3, r3, #4
3418ce06:	d5f8      	bpl.n	3418cdfa <HAL_RCCEx_GetPLL1CLKFreq+0x12>
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1SEL));
3418ce08:	f8d4 0080 	ldr.w	r0, [r4, #128]	@ 0x80
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL1_GetSource());
3418ce0c:	f000 40e0 	and.w	r0, r0, #1879048192	@ 0x70000000
}
3418ce10:	b003      	add	sp, #12
3418ce12:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL1_GetSource());
3418ce16:	f7fe bb17 	b.w	3418b448 <RCCEx_GetPLLSourceFreq>
3418ce1a:	f8d4 0080 	ldr.w	r0, [r4, #128]	@ 0x80
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL1_GetSource());
3418ce1e:	f000 40e0 	and.w	r0, r0, #1879048192	@ 0x70000000
3418ce22:	f7fe fb11 	bl	3418b448 <RCCEx_GetPLLSourceFreq>
      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
3418ce26:	2800      	cmp	r0, #0
3418ce28:	d0e7      	beq.n	3418cdfa <HAL_RCCEx_GetPLL1CLKFreq+0x12>
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1DIVM) >> RCC_PLL1CFGR1_PLL1DIVM_Pos);
3418ce2a:	f8d4 3080 	ldr.w	r3, [r4, #128]	@ 0x80
        if (divm != 0U)
3418ce2e:	f013 7f7c 	tst.w	r3, #66060288	@ 0x3f00000
3418ce32:	f3c3 5105 	ubfx	r1, r3, #20, #6
3418ce36:	d0e0      	beq.n	3418cdfa <HAL_RCCEx_GetPLL1CLKFreq+0x12>
  return (uint32_t)((READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1DIVN) >> RCC_PLL1CFGR1_PLL1DIVN_Pos));
3418ce38:	f8d4 2080 	ldr.w	r2, [r4, #128]	@ 0x80
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR2, RCC_PLL1CFGR2_PLL1DIVNFRAC) >> RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos);
3418ce3c:	f8d4 3084 	ldr.w	r3, [r4, #132]	@ 0x84
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR3, RCC_PLL1CFGR3_PLL1PDIV1) >> RCC_PLL1CFGR3_PLL1PDIV1_Pos);
3418ce40:	f8d4 5088 	ldr.w	r5, [r4, #136]	@ 0x88
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR3, RCC_PLL1CFGR3_PLL1PDIV2) >> RCC_PLL1CFGR3_PLL1PDIV2_Pos);
3418ce44:	f8d4 4088 	ldr.w	r4, [r4, #136]	@ 0x88
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR3, RCC_PLL1CFGR3_PLL1PDIV1) >> RCC_PLL1CFGR3_PLL1PDIV1_Pos);
3418ce48:	f3c5 65c2 	ubfx	r5, r5, #27, #3
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR3, RCC_PLL1CFGR3_PLL1PDIV2) >> RCC_PLL1CFGR3_PLL1PDIV2_Pos);
3418ce4c:	f3c4 6402 	ubfx	r4, r4, #24, #3
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL1_GetN(), LL_RCC_PLL1_GetFRACN(), \
3418ce50:	9401      	str	r4, [sp, #4]
3418ce52:	9500      	str	r5, [sp, #0]
3418ce54:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
3418ce58:	f3c2 220b 	ubfx	r2, r2, #8, #12
3418ce5c:	f7fe fb2a 	bl	3418b4b4 <RCCEx_CalcPLLFreq>
3418ce60:	e7cc      	b.n	3418cdfc <HAL_RCCEx_GetPLL1CLKFreq+0x14>
3418ce62:	bf00      	nop
3418ce64:	56028000 	.word	0x56028000

3418ce68 <HAL_RCCEx_GetPLL2CLKFreq>:
{
3418ce68:	b537      	push	{r0, r1, r2, r4, r5, lr}
  return ((READ_BIT(RCC->SR, RCC_SR_PLL2RDY) == (RCC_SR_PLL2RDY)) ? 1UL : 0UL);
3418ce6a:	4c1e      	ldr	r4, [pc, #120]	@ (3418cee4 <HAL_RCCEx_GetPLL2CLKFreq+0x7c>)
3418ce6c:	6863      	ldr	r3, [r4, #4]
3418ce6e:	0599      	lsls	r1, r3, #22
3418ce70:	d506      	bpl.n	3418ce80 <HAL_RCCEx_GetPLL2CLKFreq+0x18>
  return ((READ_BIT(RCC->PLL2CFGR3, RCC_PLL2CFGR3_PLL2PDIVEN) == RCC_PLL2CFGR3_PLL2PDIVEN) ? 1UL : 0UL);
3418ce72:	f8d4 3098 	ldr.w	r3, [r4, #152]	@ 0x98
3418ce76:	005a      	lsls	r2, r3, #1
3418ce78:	d40f      	bmi.n	3418ce9a <HAL_RCCEx_GetPLL2CLKFreq+0x32>
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
3418ce7a:	2000      	movs	r0, #0
}
3418ce7c:	b003      	add	sp, #12
3418ce7e:	bd30      	pop	{r4, r5, pc}
  return ((READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2BYP) == RCC_PLL2CFGR1_PLL2BYP) ? 1UL : 0UL);
3418ce80:	f8d4 3090 	ldr.w	r3, [r4, #144]	@ 0x90
3418ce84:	011b      	lsls	r3, r3, #4
3418ce86:	d5f8      	bpl.n	3418ce7a <HAL_RCCEx_GetPLL2CLKFreq+0x12>
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2SEL));
3418ce88:	f8d4 0090 	ldr.w	r0, [r4, #144]	@ 0x90
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL2_GetSource());
3418ce8c:	f000 40e0 	and.w	r0, r0, #1879048192	@ 0x70000000
}
3418ce90:	b003      	add	sp, #12
3418ce92:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL2_GetSource());
3418ce96:	f7fe bad7 	b.w	3418b448 <RCCEx_GetPLLSourceFreq>
3418ce9a:	f8d4 0090 	ldr.w	r0, [r4, #144]	@ 0x90
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL2_GetSource());
3418ce9e:	f000 40e0 	and.w	r0, r0, #1879048192	@ 0x70000000
3418cea2:	f7fe fad1 	bl	3418b448 <RCCEx_GetPLLSourceFreq>
      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
3418cea6:	2800      	cmp	r0, #0
3418cea8:	d0e7      	beq.n	3418ce7a <HAL_RCCEx_GetPLL2CLKFreq+0x12>
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2DIVM) >> RCC_PLL2CFGR1_PLL2DIVM_Pos);
3418ceaa:	f8d4 3090 	ldr.w	r3, [r4, #144]	@ 0x90
        if (divm != 0U)
3418ceae:	f013 7f7c 	tst.w	r3, #66060288	@ 0x3f00000
3418ceb2:	f3c3 5105 	ubfx	r1, r3, #20, #6
3418ceb6:	d0e0      	beq.n	3418ce7a <HAL_RCCEx_GetPLL2CLKFreq+0x12>
  return (uint32_t)((READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2DIVN) >> RCC_PLL2CFGR1_PLL2DIVN_Pos));
3418ceb8:	f8d4 2090 	ldr.w	r2, [r4, #144]	@ 0x90
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR2, RCC_PLL2CFGR2_PLL2DIVNFRAC) >> RCC_PLL2CFGR2_PLL2DIVNFRAC_Pos);
3418cebc:	f8d4 3094 	ldr.w	r3, [r4, #148]	@ 0x94
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR3, RCC_PLL2CFGR3_PLL2PDIV1) >> RCC_PLL2CFGR3_PLL2PDIV1_Pos);
3418cec0:	f8d4 5098 	ldr.w	r5, [r4, #152]	@ 0x98
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR3, RCC_PLL2CFGR3_PLL2PDIV2) >> RCC_PLL2CFGR3_PLL2PDIV2_Pos);
3418cec4:	f8d4 4098 	ldr.w	r4, [r4, #152]	@ 0x98
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR3, RCC_PLL2CFGR3_PLL2PDIV1) >> RCC_PLL2CFGR3_PLL2PDIV1_Pos);
3418cec8:	f3c5 65c2 	ubfx	r5, r5, #27, #3
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR3, RCC_PLL2CFGR3_PLL2PDIV2) >> RCC_PLL2CFGR3_PLL2PDIV2_Pos);
3418cecc:	f3c4 6402 	ubfx	r4, r4, #24, #3
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL2_GetN(), LL_RCC_PLL2_GetFRACN(), \
3418ced0:	9401      	str	r4, [sp, #4]
3418ced2:	9500      	str	r5, [sp, #0]
3418ced4:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
3418ced8:	f3c2 220b 	ubfx	r2, r2, #8, #12
3418cedc:	f7fe faea 	bl	3418b4b4 <RCCEx_CalcPLLFreq>
3418cee0:	e7cc      	b.n	3418ce7c <HAL_RCCEx_GetPLL2CLKFreq+0x14>
3418cee2:	bf00      	nop
3418cee4:	56028000 	.word	0x56028000

3418cee8 <HAL_RCCEx_GetPLL3CLKFreq>:
{
3418cee8:	b537      	push	{r0, r1, r2, r4, r5, lr}
  return ((READ_BIT(RCC->SR, RCC_SR_PLL3RDY) == (RCC_SR_PLL3RDY)) ? 1UL : 0UL);
3418ceea:	4c1e      	ldr	r4, [pc, #120]	@ (3418cf64 <HAL_RCCEx_GetPLL3CLKFreq+0x7c>)
3418ceec:	6863      	ldr	r3, [r4, #4]
3418ceee:	0559      	lsls	r1, r3, #21
3418cef0:	d506      	bpl.n	3418cf00 <HAL_RCCEx_GetPLL3CLKFreq+0x18>
  return ((READ_BIT(RCC->PLL3CFGR3, RCC_PLL3CFGR3_PLL3PDIVEN) == RCC_PLL3CFGR3_PLL3PDIVEN) ? 1UL : 0UL);
3418cef2:	f8d4 30a8 	ldr.w	r3, [r4, #168]	@ 0xa8
3418cef6:	005a      	lsls	r2, r3, #1
3418cef8:	d40f      	bmi.n	3418cf1a <HAL_RCCEx_GetPLL3CLKFreq+0x32>
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
3418cefa:	2000      	movs	r0, #0
}
3418cefc:	b003      	add	sp, #12
3418cefe:	bd30      	pop	{r4, r5, pc}
  return ((READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3BYP) == RCC_PLL3CFGR1_PLL3BYP) ? 1UL : 0UL);
3418cf00:	f8d4 30a0 	ldr.w	r3, [r4, #160]	@ 0xa0
3418cf04:	011b      	lsls	r3, r3, #4
3418cf06:	d5f8      	bpl.n	3418cefa <HAL_RCCEx_GetPLL3CLKFreq+0x12>
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3SEL));
3418cf08:	f8d4 00a0 	ldr.w	r0, [r4, #160]	@ 0xa0
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL3_GetSource());
3418cf0c:	f000 40e0 	and.w	r0, r0, #1879048192	@ 0x70000000
}
3418cf10:	b003      	add	sp, #12
3418cf12:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL3_GetSource());
3418cf16:	f7fe ba97 	b.w	3418b448 <RCCEx_GetPLLSourceFreq>
3418cf1a:	f8d4 00a0 	ldr.w	r0, [r4, #160]	@ 0xa0
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL3_GetSource());
3418cf1e:	f000 40e0 	and.w	r0, r0, #1879048192	@ 0x70000000
3418cf22:	f7fe fa91 	bl	3418b448 <RCCEx_GetPLLSourceFreq>
      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
3418cf26:	2800      	cmp	r0, #0
3418cf28:	d0e7      	beq.n	3418cefa <HAL_RCCEx_GetPLL3CLKFreq+0x12>
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3DIVM) >> RCC_PLL3CFGR1_PLL3DIVM_Pos);
3418cf2a:	f8d4 30a0 	ldr.w	r3, [r4, #160]	@ 0xa0
        if (divm != 0U)
3418cf2e:	f013 7f7c 	tst.w	r3, #66060288	@ 0x3f00000
3418cf32:	f3c3 5105 	ubfx	r1, r3, #20, #6
3418cf36:	d0e0      	beq.n	3418cefa <HAL_RCCEx_GetPLL3CLKFreq+0x12>
  return (uint32_t)((READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3DIVN) >> RCC_PLL3CFGR1_PLL3DIVN_Pos));
3418cf38:	f8d4 20a0 	ldr.w	r2, [r4, #160]	@ 0xa0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR2, RCC_PLL3CFGR2_PLL3DIVNFRAC) >> RCC_PLL3CFGR2_PLL3DIVNFRAC_Pos);
3418cf3c:	f8d4 30a4 	ldr.w	r3, [r4, #164]	@ 0xa4
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR3, RCC_PLL3CFGR3_PLL3PDIV1) >> RCC_PLL3CFGR3_PLL3PDIV1_Pos);
3418cf40:	f8d4 50a8 	ldr.w	r5, [r4, #168]	@ 0xa8
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR3, RCC_PLL3CFGR3_PLL3PDIV2) >> RCC_PLL3CFGR3_PLL3PDIV2_Pos);
3418cf44:	f8d4 40a8 	ldr.w	r4, [r4, #168]	@ 0xa8
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR3, RCC_PLL3CFGR3_PLL3PDIV1) >> RCC_PLL3CFGR3_PLL3PDIV1_Pos);
3418cf48:	f3c5 65c2 	ubfx	r5, r5, #27, #3
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR3, RCC_PLL3CFGR3_PLL3PDIV2) >> RCC_PLL3CFGR3_PLL3PDIV2_Pos);
3418cf4c:	f3c4 6402 	ubfx	r4, r4, #24, #3
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL3_GetN(), LL_RCC_PLL3_GetFRACN(), \
3418cf50:	9401      	str	r4, [sp, #4]
3418cf52:	9500      	str	r5, [sp, #0]
3418cf54:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
3418cf58:	f3c2 220b 	ubfx	r2, r2, #8, #12
3418cf5c:	f7fe faaa 	bl	3418b4b4 <RCCEx_CalcPLLFreq>
3418cf60:	e7cc      	b.n	3418cefc <HAL_RCCEx_GetPLL3CLKFreq+0x14>
3418cf62:	bf00      	nop
3418cf64:	56028000 	.word	0x56028000

3418cf68 <HAL_RCCEx_GetPLL4CLKFreq>:
{
3418cf68:	b537      	push	{r0, r1, r2, r4, r5, lr}
  return ((READ_BIT(RCC->SR, RCC_SR_PLL4RDY) == (RCC_SR_PLL4RDY)) ? 1UL : 0UL);
3418cf6a:	4c1e      	ldr	r4, [pc, #120]	@ (3418cfe4 <HAL_RCCEx_GetPLL4CLKFreq+0x7c>)
3418cf6c:	6863      	ldr	r3, [r4, #4]
3418cf6e:	0519      	lsls	r1, r3, #20
3418cf70:	d506      	bpl.n	3418cf80 <HAL_RCCEx_GetPLL4CLKFreq+0x18>
  return ((READ_BIT(RCC->PLL4CFGR3, RCC_PLL4CFGR3_PLL4PDIVEN) == RCC_PLL4CFGR3_PLL4PDIVEN) ? 1UL : 0UL);
3418cf72:	f8d4 30b8 	ldr.w	r3, [r4, #184]	@ 0xb8
3418cf76:	005a      	lsls	r2, r3, #1
3418cf78:	d40f      	bmi.n	3418cf9a <HAL_RCCEx_GetPLL4CLKFreq+0x32>
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
3418cf7a:	2000      	movs	r0, #0
}
3418cf7c:	b003      	add	sp, #12
3418cf7e:	bd30      	pop	{r4, r5, pc}
  return ((READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4BYP) == RCC_PLL4CFGR1_PLL4BYP) ? 1UL : 0UL);
3418cf80:	f8d4 30b0 	ldr.w	r3, [r4, #176]	@ 0xb0
3418cf84:	011b      	lsls	r3, r3, #4
3418cf86:	d5f8      	bpl.n	3418cf7a <HAL_RCCEx_GetPLL4CLKFreq+0x12>
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4SEL));
3418cf88:	f8d4 00b0 	ldr.w	r0, [r4, #176]	@ 0xb0
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL4_GetSource());
3418cf8c:	f000 40e0 	and.w	r0, r0, #1879048192	@ 0x70000000
}
3418cf90:	b003      	add	sp, #12
3418cf92:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL4_GetSource());
3418cf96:	f7fe ba57 	b.w	3418b448 <RCCEx_GetPLLSourceFreq>
3418cf9a:	f8d4 00b0 	ldr.w	r0, [r4, #176]	@ 0xb0
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL4_GetSource());
3418cf9e:	f000 40e0 	and.w	r0, r0, #1879048192	@ 0x70000000
3418cfa2:	f7fe fa51 	bl	3418b448 <RCCEx_GetPLLSourceFreq>
      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
3418cfa6:	2800      	cmp	r0, #0
3418cfa8:	d0e7      	beq.n	3418cf7a <HAL_RCCEx_GetPLL4CLKFreq+0x12>
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4DIVM) >> RCC_PLL4CFGR1_PLL4DIVM_Pos);
3418cfaa:	f8d4 30b0 	ldr.w	r3, [r4, #176]	@ 0xb0
        if (divm != 0U)
3418cfae:	f013 7f7c 	tst.w	r3, #66060288	@ 0x3f00000
3418cfb2:	f3c3 5105 	ubfx	r1, r3, #20, #6
3418cfb6:	d0e0      	beq.n	3418cf7a <HAL_RCCEx_GetPLL4CLKFreq+0x12>
  return (uint32_t)((READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4DIVN) >> RCC_PLL4CFGR1_PLL4DIVN_Pos));
3418cfb8:	f8d4 20b0 	ldr.w	r2, [r4, #176]	@ 0xb0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR2, RCC_PLL4CFGR2_PLL4DIVNFRAC) >> RCC_PLL4CFGR2_PLL4DIVNFRAC_Pos);
3418cfbc:	f8d4 30b4 	ldr.w	r3, [r4, #180]	@ 0xb4
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR3, RCC_PLL4CFGR3_PLL4PDIV1) >> RCC_PLL4CFGR3_PLL4PDIV1_Pos);
3418cfc0:	f8d4 50b8 	ldr.w	r5, [r4, #184]	@ 0xb8
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR3, RCC_PLL4CFGR3_PLL4PDIV2) >> RCC_PLL4CFGR3_PLL4PDIV2_Pos);
3418cfc4:	f8d4 40b8 	ldr.w	r4, [r4, #184]	@ 0xb8
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR3, RCC_PLL4CFGR3_PLL4PDIV1) >> RCC_PLL4CFGR3_PLL4PDIV1_Pos);
3418cfc8:	f3c5 65c2 	ubfx	r5, r5, #27, #3
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR3, RCC_PLL4CFGR3_PLL4PDIV2) >> RCC_PLL4CFGR3_PLL4PDIV2_Pos);
3418cfcc:	f3c4 6402 	ubfx	r4, r4, #24, #3
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL4_GetN(), LL_RCC_PLL4_GetFRACN(), \
3418cfd0:	9401      	str	r4, [sp, #4]
3418cfd2:	9500      	str	r5, [sp, #0]
3418cfd4:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
3418cfd8:	f3c2 220b 	ubfx	r2, r2, #8, #12
3418cfdc:	f7fe fa6a 	bl	3418b4b4 <RCCEx_CalcPLLFreq>
3418cfe0:	e7cc      	b.n	3418cf7c <HAL_RCCEx_GetPLL4CLKFreq+0x14>
3418cfe2:	bf00      	nop
3418cfe4:	56028000 	.word	0x56028000

3418cfe8 <RCCEx_GetCLKPCLKFreq.constprop.0>:
  * @rmtoll MISCENR       PEREN         LL_RCC_CLKP_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_CLKP_IsEnabled(void)
{
  return ((READ_BIT(RCC->MISCENR, RCC_MISCENR_PEREN) == RCC_MISCENR_PEREN) ? 1UL : 0UL);
3418cfe8:	4b3e      	ldr	r3, [pc, #248]	@ (3418d0e4 <RCCEx_GetCLKPCLKFreq.constprop.0+0xfc>)
  * @param  CLKPxSource This parameter can be one of the following values:
  *         @arg @ref RCCEx_CLKP_Clock_Source
  * @retval CLKP clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetCLKPCLKFreq(uint32_t CLKPxSource)
3418cfea:	b510      	push	{r4, lr}
3418cfec:	f8d3 2248 	ldr.w	r2, [r3, #584]	@ 0x248
3418cff0:	0652      	lsls	r2, r2, #25
3418cff2:	d56b      	bpl.n	3418d0cc <RCCEx_GetCLKPCLKFreq.constprop.0+0xe4>
  return (uint32_t)(READ_BIT(RCC->CCIPR7, RCC_CCIPR7_PERSEL));
3418cff4:	f8d3 215c 	ldr.w	r2, [r3, #348]	@ 0x15c
3418cff8:	f002 0207 	and.w	r2, r2, #7
  uint32_t clkp_frequency = RCC_PERIPH_FREQUENCY_NO;
  uint32_t ic_divider;

  if (LL_RCC_CLKP_IsEnabled() == 1U)
  {
    switch (LL_RCC_GetCLKPClockSource(CLKPxSource))
3418cffc:	3a01      	subs	r2, #1
3418cffe:	2a06      	cmp	r2, #6
3418d000:	d805      	bhi.n	3418d00e <RCCEx_GetCLKPCLKFreq.constprop.0+0x26>
3418d002:	e8df f002 	tbb	[pc, r2]
3418d006:	150f      	.short	0x150f
3418d008:	3e321b48 	.word	0x3e321b48
3418d00c:	54          	.byte	0x54
3418d00d:	00          	.byte	0x00
    {
      case LL_RCC_CLKP_CLKSOURCE_HSI:
        if (LL_RCC_HSI_IsReady() != 0U)
3418d00e:	f7fe f981 	bl	3418b314 <LL_RCC_HSI_IsReady>
3418d012:	2800      	cmp	r0, #0
3418d014:	d05a      	beq.n	3418d0cc <RCCEx_GetCLKPCLKFreq.constprop.0+0xe4>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3418d016:	4b33      	ldr	r3, [pc, #204]	@ (3418d0e4 <RCCEx_GetCLKPCLKFreq.constprop.0+0xfc>)
        {
          clkp_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3418d018:	4833      	ldr	r0, [pc, #204]	@ (3418d0e8 <RCCEx_GetCLKPCLKFreq.constprop.0+0x100>)
3418d01a:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3418d01c:	f3c3 13c1 	ubfx	r3, r3, #7, #2
3418d020:	40d8      	lsrs	r0, r3
3418d022:	e054      	b.n	3418d0ce <RCCEx_GetCLKPCLKFreq.constprop.0+0xe6>
        }
        break;

      case LL_RCC_CLKP_CLKSOURCE_MSI:
        if (LL_RCC_MSI_IsReady() != 0U)
3418d024:	f7fe f97e 	bl	3418b324 <LL_RCC_MSI_IsReady>
3418d028:	2800      	cmp	r0, #0
3418d02a:	d04f      	beq.n	3418d0cc <RCCEx_GetCLKPCLKFreq.constprop.0+0xe4>
        {
          clkp_frequency = MSI_VALUE;
3418d02c:	482f      	ldr	r0, [pc, #188]	@ (3418d0ec <RCCEx_GetCLKPCLKFreq.constprop.0+0x104>)
3418d02e:	e04e      	b.n	3418d0ce <RCCEx_GetCLKPCLKFreq.constprop.0+0xe6>
        }
        break;

      case LL_RCC_CLKP_CLKSOURCE_HSE:
        if (LL_RCC_HSE_IsReady() != 0U)
3418d030:	f7fe f968 	bl	3418b304 <LL_RCC_HSE_IsReady>
3418d034:	2800      	cmp	r0, #0
3418d036:	d049      	beq.n	3418d0cc <RCCEx_GetCLKPCLKFreq.constprop.0+0xe4>
        {
          clkp_frequency = HSE_VALUE;
3418d038:	482d      	ldr	r0, [pc, #180]	@ (3418d0f0 <RCCEx_GetCLKPCLKFreq.constprop.0+0x108>)
        /* Unexpected case */
        break;
    }
  }

  return clkp_frequency;
3418d03a:	e048      	b.n	3418d0ce <RCCEx_GetCLKPCLKFreq.constprop.0+0xe6>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC5EN) == RCC_DIVENR_IC5EN) ? 1UL : 0UL);
3418d03c:	f8d3 2240 	ldr.w	r2, [r3, #576]	@ 0x240
3418d040:	06d4      	lsls	r4, r2, #27
3418d042:	d543      	bpl.n	3418d0cc <RCCEx_GetCLKPCLKFreq.constprop.0+0xe4>
  return ((READ_BIT(RCC->IC5CFGR, RCC_IC5CFGR_IC5INT) >> RCC_IC5CFGR_IC5INT_Pos) + 1UL);
3418d044:	f8d3 00d4 	ldr.w	r0, [r3, #212]	@ 0xd4
  return (uint32_t)(READ_BIT(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL));
3418d048:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
  return ((READ_BIT(RCC->IC5CFGR, RCC_IC5CFGR_IC5INT) >> RCC_IC5CFGR_IC5INT_Pos) + 1UL);
3418d04c:	f3c0 4007 	ubfx	r0, r0, #16, #8
3418d050:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL));
3418d052:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
          switch (LL_RCC_IC20_GetSource())
3418d056:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418d05a:	d03c      	beq.n	3418d0d6 <RCCEx_GetCLKPCLKFreq.constprop.0+0xee>
3418d05c:	d833      	bhi.n	3418d0c6 <RCCEx_GetCLKPCLKFreq.constprop.0+0xde>
3418d05e:	bbbb      	cbnz	r3, 3418d0d0 <RCCEx_GetCLKPCLKFreq.constprop.0+0xe8>
              clkp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3418d060:	f7ff fec2 	bl	3418cde8 <HAL_RCCEx_GetPLL1CLKFreq>
              clkp_frequency = clkp_frequency / ic_divider;
3418d064:	fbb0 f0f4 	udiv	r0, r0, r4
              break;
3418d068:	e031      	b.n	3418d0ce <RCCEx_GetCLKPCLKFreq.constprop.0+0xe6>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC10EN) == RCC_DIVENR_IC10EN) ? 1UL : 0UL);
3418d06a:	f8d3 2240 	ldr.w	r2, [r3, #576]	@ 0x240
3418d06e:	0590      	lsls	r0, r2, #22
3418d070:	d52c      	bpl.n	3418d0cc <RCCEx_GetCLKPCLKFreq.constprop.0+0xe4>
  return ((READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10INT) >> RCC_IC10CFGR_IC10INT_Pos) + 1UL);
3418d072:	f8d3 00e8 	ldr.w	r0, [r3, #232]	@ 0xe8
  return (uint32_t)(READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL));
3418d076:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
  return ((READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10INT) >> RCC_IC10CFGR_IC10INT_Pos) + 1UL);
3418d07a:	f3c0 4007 	ubfx	r0, r0, #16, #8
3418d07e:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL));
3418d080:	e7e7      	b.n	3418d052 <RCCEx_GetCLKPCLKFreq.constprop.0+0x6a>
        if (LL_RCC_IC15_IsEnabled() != 0U)
3418d082:	f7fe f9c7 	bl	3418b414 <LL_RCC_IC15_IsEnabled>
3418d086:	b308      	cbz	r0, 3418d0cc <RCCEx_GetCLKPCLKFreq.constprop.0+0xe4>
          ic_divider = LL_RCC_IC15_GetDivider();
3418d088:	f7fe f9cc 	bl	3418b424 <LL_RCC_IC15_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL));
3418d08c:	4b15      	ldr	r3, [pc, #84]	@ (3418d0e4 <RCCEx_GetCLKPCLKFreq.constprop.0+0xfc>)
3418d08e:	4604      	mov	r4, r0
3418d090:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3418d094:	e7dd      	b.n	3418d052 <RCCEx_GetCLKPCLKFreq.constprop.0+0x6a>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC19EN) == RCC_DIVENR_IC19EN) ? 1UL : 0UL);
3418d096:	f8d3 2240 	ldr.w	r2, [r3, #576]	@ 0x240
3418d09a:	0351      	lsls	r1, r2, #13
3418d09c:	d516      	bpl.n	3418d0cc <RCCEx_GetCLKPCLKFreq.constprop.0+0xe4>
  return ((READ_BIT(RCC->IC19CFGR, RCC_IC19CFGR_IC19INT) >> RCC_IC19CFGR_IC19INT_Pos) + 1UL);
3418d09e:	f8d3 010c 	ldr.w	r0, [r3, #268]	@ 0x10c
  return (uint32_t)(READ_BIT(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL));
3418d0a2:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
  return ((READ_BIT(RCC->IC19CFGR, RCC_IC19CFGR_IC19INT) >> RCC_IC19CFGR_IC19INT_Pos) + 1UL);
3418d0a6:	f3c0 4007 	ubfx	r0, r0, #16, #8
3418d0aa:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL));
3418d0ac:	e7d1      	b.n	3418d052 <RCCEx_GetCLKPCLKFreq.constprop.0+0x6a>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC20EN) == RCC_DIVENR_IC20EN) ? 1UL : 0UL);
3418d0ae:	f8d3 2240 	ldr.w	r2, [r3, #576]	@ 0x240
3418d0b2:	0312      	lsls	r2, r2, #12
3418d0b4:	d50a      	bpl.n	3418d0cc <RCCEx_GetCLKPCLKFreq.constprop.0+0xe4>
  return ((READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20INT) >> RCC_IC20CFGR_IC20INT_Pos) + 1UL);
3418d0b6:	f8d3 0110 	ldr.w	r0, [r3, #272]	@ 0x110
  return (uint32_t)(READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL));
3418d0ba:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
  return ((READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20INT) >> RCC_IC20CFGR_IC20INT_Pos) + 1UL);
3418d0be:	f3c0 4007 	ubfx	r0, r0, #16, #8
3418d0c2:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL));
3418d0c4:	e7c5      	b.n	3418d052 <RCCEx_GetCLKPCLKFreq.constprop.0+0x6a>
          switch (LL_RCC_IC20_GetSource())
3418d0c6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418d0ca:	d007      	beq.n	3418d0dc <RCCEx_GetCLKPCLKFreq.constprop.0+0xf4>
  uint32_t clkp_frequency = RCC_PERIPH_FREQUENCY_NO;
3418d0cc:	2000      	movs	r0, #0
}
3418d0ce:	bd10      	pop	{r4, pc}
              clkp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3418d0d0:	f7ff feca 	bl	3418ce68 <HAL_RCCEx_GetPLL2CLKFreq>
3418d0d4:	e7c6      	b.n	3418d064 <RCCEx_GetCLKPCLKFreq.constprop.0+0x7c>
              clkp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3418d0d6:	f7ff ff07 	bl	3418cee8 <HAL_RCCEx_GetPLL3CLKFreq>
3418d0da:	e7c3      	b.n	3418d064 <RCCEx_GetCLKPCLKFreq.constprop.0+0x7c>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3418d0dc:	f7ff ff44 	bl	3418cf68 <HAL_RCCEx_GetPLL4CLKFreq>
3418d0e0:	e7c0      	b.n	3418d064 <RCCEx_GetCLKPCLKFreq.constprop.0+0x7c>
3418d0e2:	bf00      	nop
3418d0e4:	56028000 	.word	0x56028000
3418d0e8:	03d09000 	.word	0x03d09000
3418d0ec:	003d0900 	.word	0x003d0900
3418d0f0:	02dc6c00 	.word	0x02dc6c00

3418d0f4 <RCCEx_GetSPDIFRXCLKFreq.constprop.0>:
  * @param  SPDIFRXxSource This parameter can be one of the following values:
  *         @arg @ref RCCEx_SPDIFRX1_Clock_Source
  * @retval SPDIF clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetSPDIFRXCLKFreq(uint32_t SPDIFRXxSource)
3418d0f4:	b538      	push	{r3, r4, r5, lr}
  return (uint32_t)(READ_BIT(RCC->CCIPR9, RCC_CCIPR9_SPDIFRX1SEL));
3418d0f6:	4d2b      	ldr	r5, [pc, #172]	@ (3418d1a4 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0xb0>)
3418d0f8:	f8d5 3164 	ldr.w	r3, [r5, #356]	@ 0x164
3418d0fc:	f003 0307 	and.w	r3, r3, #7
{
  uint32_t spdifrx_frequency = RCC_PERIPH_FREQUENCY_NO;
  uint32_t ic_divider;

  switch (LL_RCC_GetSPDIFRXClockSource(SPDIFRXxSource))
3418d100:	2b06      	cmp	r3, #6
3418d102:	d835      	bhi.n	3418d170 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x7c>
3418d104:	e8df f003 	tbb	[pc, r3]
3418d108:	28110d04 	.word	0x28110d04
3418d10c:	3c45      	.short	0x3c45
3418d10e:	4b          	.byte	0x4b
3418d10f:	00          	.byte	0x00
  {
    case LL_RCC_SPDIFRX1_CLKSOURCE_PCLK1:
      spdifrx_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3418d110:	f7fd fd00 	bl	3418ab14 <HAL_RCC_GetSysClockFreq>
3418d114:	f7fe f990 	bl	3418b438 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE1));
3418d118:	6a6b      	ldr	r3, [r5, #36]	@ 0x24
3418d11a:	f003 0307 	and.w	r3, r3, #7
      break;

    case LL_RCC_SPDIFRX1_CLKSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
      {
        spdifrx_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3418d11e:	40d8      	lsrs	r0, r3
3418d120:	e027      	b.n	3418d172 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x7e>
      /* Unexpected case */
      break;
  }

  return spdifrx_frequency;
}
3418d122:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      spdifrx_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3418d126:	f7ff bf5f 	b.w	3418cfe8 <RCCEx_GetCLKPCLKFreq.constprop.0>
      if (LL_RCC_IC7_IsEnabled() != 0U)
3418d12a:	f7fe f92b 	bl	3418b384 <LL_RCC_IC7_IsEnabled>
3418d12e:	b1f8      	cbz	r0, 3418d170 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x7c>
        ic_divider = LL_RCC_IC7_GetDivider();
3418d130:	f7fe f930 	bl	3418b394 <LL_RCC_IC7_GetDivider>
3418d134:	4604      	mov	r4, r0
  return (uint32_t)(READ_BIT(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL));
3418d136:	f8d5 30dc 	ldr.w	r3, [r5, #220]	@ 0xdc
  return (uint32_t)(READ_BIT(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL));
3418d13a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC8_GetSource())
3418d13e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418d142:	d017      	beq.n	3418d174 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x80>
3418d144:	d811      	bhi.n	3418d16a <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x76>
3418d146:	b913      	cbnz	r3, 3418d14e <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x5a>
            spdifrx_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3418d148:	f7ff fe4e 	bl	3418cde8 <HAL_RCCEx_GetPLL1CLKFreq>
3418d14c:	e001      	b.n	3418d152 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x5e>
            spdifrx_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3418d14e:	f7ff fe8b 	bl	3418ce68 <HAL_RCCEx_GetPLL2CLKFreq>
            spdifrx_frequency = spdifrx_frequency / ic_divider;
3418d152:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
3418d156:	e00c      	b.n	3418d172 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x7e>
      if (LL_RCC_IC8_IsEnabled() != 0U)
3418d158:	f7fe f926 	bl	3418b3a8 <LL_RCC_IC8_IsEnabled>
3418d15c:	b140      	cbz	r0, 3418d170 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x7c>
        ic_divider = LL_RCC_IC8_GetDivider();
3418d15e:	f7fe f92b 	bl	3418b3b8 <LL_RCC_IC8_GetDivider>
3418d162:	f8d5 30e0 	ldr.w	r3, [r5, #224]	@ 0xe0
3418d166:	4604      	mov	r4, r0
3418d168:	e7e7      	b.n	3418d13a <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x46>
        switch (LL_RCC_IC8_GetSource())
3418d16a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418d16e:	d004      	beq.n	3418d17a <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x86>
  uint32_t spdifrx_frequency = RCC_PERIPH_FREQUENCY_NO;
3418d170:	2000      	movs	r0, #0
}
3418d172:	bd38      	pop	{r3, r4, r5, pc}
            spdifrx_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3418d174:	f7ff feb8 	bl	3418cee8 <HAL_RCCEx_GetPLL3CLKFreq>
3418d178:	e7eb      	b.n	3418d152 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x5e>
            spdifrx_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3418d17a:	f7ff fef5 	bl	3418cf68 <HAL_RCCEx_GetPLL4CLKFreq>
3418d17e:	e7e8      	b.n	3418d152 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x5e>
      if (LL_RCC_HSI_IsReady() != 0U)
3418d180:	f7fe f8c8 	bl	3418b314 <LL_RCC_HSI_IsReady>
3418d184:	2800      	cmp	r0, #0
3418d186:	d0f3      	beq.n	3418d170 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x7c>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3418d188:	6cab      	ldr	r3, [r5, #72]	@ 0x48
        spdifrx_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3418d18a:	4807      	ldr	r0, [pc, #28]	@ (3418d1a8 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0xb4>)
3418d18c:	f3c3 13c1 	ubfx	r3, r3, #7, #2
3418d190:	e7c5      	b.n	3418d11e <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x2a>
      if (LL_RCC_MSI_IsReady() != 0U)
3418d192:	f7fe f8c7 	bl	3418b324 <LL_RCC_MSI_IsReady>
3418d196:	2800      	cmp	r0, #0
3418d198:	d0ea      	beq.n	3418d170 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x7c>
        spdifrx_frequency = MSI_VALUE;
3418d19a:	4804      	ldr	r0, [pc, #16]	@ (3418d1ac <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0xb8>)
3418d19c:	e7e9      	b.n	3418d172 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x7e>
  switch (LL_RCC_GetSPDIFRXClockSource(SPDIFRXxSource))
3418d19e:	4804      	ldr	r0, [pc, #16]	@ (3418d1b0 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0xbc>)
  return spdifrx_frequency;
3418d1a0:	e7e7      	b.n	3418d172 <RCCEx_GetSPDIFRXCLKFreq.constprop.0+0x7e>
3418d1a2:	bf00      	nop
3418d1a4:	56028000 	.word	0x56028000
3418d1a8:	03d09000 	.word	0x03d09000
3418d1ac:	003d0900 	.word	0x003d0900
3418d1b0:	00bb8000 	.word	0x00bb8000

3418d1b4 <RCCEx_GetXSPICLKFreq>:
  * @retval XSPI clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */

static uint32_t RCCEx_GetXSPICLKFreq(uint32_t XSPIxSource)
{
3418d1b4:	b510      	push	{r4, lr}
  return LL_RCC_GetClockSource(Periph);
3418d1b6:	f7fe f8d7 	bl	3418b368 <LL_RCC_GetClockSource>
  uint32_t xspi_frequency = RCC_PERIPH_FREQUENCY_NO;
  uint32_t ic_divider;

  switch (LL_RCC_GetXSPIClockSource(XSPIxSource))
3418d1ba:	4b36      	ldr	r3, [pc, #216]	@ (3418d294 <RCCEx_GetXSPICLKFreq+0xe0>)
3418d1bc:	4298      	cmp	r0, r3
3418d1be:	d028      	beq.n	3418d212 <RCCEx_GetXSPICLKFreq+0x5e>
3418d1c0:	d81b      	bhi.n	3418d1fa <RCCEx_GetXSPICLKFreq+0x46>
3418d1c2:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3418d1c6:	4298      	cmp	r0, r3
3418d1c8:	d013      	beq.n	3418d1f2 <RCCEx_GetXSPICLKFreq+0x3e>
3418d1ca:	d80b      	bhi.n	3418d1e4 <RCCEx_GetXSPICLKFreq+0x30>
3418d1cc:	f420 6280 	bic.w	r2, r0, #1024	@ 0x400
3418d1d0:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3418d1d4:	429a      	cmp	r2, r3
3418d1d6:	d04a      	beq.n	3418d26e <RCCEx_GetXSPICLKFreq+0xba>
3418d1d8:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
3418d1dc:	4298      	cmp	r0, r3
3418d1de:	d046      	beq.n	3418d26e <RCCEx_GetXSPICLKFreq+0xba>
  uint32_t xspi_frequency = RCC_PERIPH_FREQUENCY_NO;
3418d1e0:	2000      	movs	r0, #0
      /* Nothing to do */
      break;
  }

  return xspi_frequency;
}
3418d1e2:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetXSPIClockSource(XSPIxSource))
3418d1e4:	4b2c      	ldr	r3, [pc, #176]	@ (3418d298 <RCCEx_GetXSPICLKFreq+0xe4>)
3418d1e6:	4298      	cmp	r0, r3
3418d1e8:	d003      	beq.n	3418d1f2 <RCCEx_GetXSPICLKFreq+0x3e>
3418d1ea:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3418d1ee:	4298      	cmp	r0, r3
3418d1f0:	d1f6      	bne.n	3418d1e0 <RCCEx_GetXSPICLKFreq+0x2c>
}
3418d1f2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      xspi_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3418d1f6:	f7ff bef7 	b.w	3418cfe8 <RCCEx_GetCLKPCLKFreq.constprop.0>
  switch (LL_RCC_GetXSPIClockSource(XSPIxSource))
3418d1fa:	4b28      	ldr	r3, [pc, #160]	@ (3418d29c <RCCEx_GetXSPICLKFreq+0xe8>)
3418d1fc:	4298      	cmp	r0, r3
3418d1fe:	d028      	beq.n	3418d252 <RCCEx_GetXSPICLKFreq+0x9e>
3418d200:	d820      	bhi.n	3418d244 <RCCEx_GetXSPICLKFreq+0x90>
3418d202:	f5a3 437c 	sub.w	r3, r3, #64512	@ 0xfc00
3418d206:	4298      	cmp	r0, r3
3418d208:	d003      	beq.n	3418d212 <RCCEx_GetXSPICLKFreq+0x5e>
3418d20a:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3418d20e:	4298      	cmp	r0, r3
3418d210:	d1e6      	bne.n	3418d1e0 <RCCEx_GetXSPICLKFreq+0x2c>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC3EN) == RCC_DIVENR_IC3EN) ? 1UL : 0UL);
3418d212:	4b23      	ldr	r3, [pc, #140]	@ (3418d2a0 <RCCEx_GetXSPICLKFreq+0xec>)
3418d214:	f8d3 0240 	ldr.w	r0, [r3, #576]	@ 0x240
3418d218:	f010 0004 	ands.w	r0, r0, #4
3418d21c:	d0e1      	beq.n	3418d1e2 <RCCEx_GetXSPICLKFreq+0x2e>
  return ((READ_BIT(RCC->IC3CFGR, RCC_IC3CFGR_IC3INT) >> RCC_IC3CFGR_IC3INT_Pos) + 1UL);
3418d21e:	f8d3 00cc 	ldr.w	r0, [r3, #204]	@ 0xcc
  return (uint32_t)(READ_BIT(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL));
3418d222:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
  return ((READ_BIT(RCC->IC3CFGR, RCC_IC3CFGR_IC3INT) >> RCC_IC3CFGR_IC3INT_Pos) + 1UL);
3418d226:	f3c0 4007 	ubfx	r0, r0, #16, #8
3418d22a:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL));
3418d22c:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC4_GetSource())
3418d230:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418d234:	d02a      	beq.n	3418d28c <RCCEx_GetXSPICLKFreq+0xd8>
3418d236:	d820      	bhi.n	3418d27a <RCCEx_GetXSPICLKFreq+0xc6>
3418d238:	bb2b      	cbnz	r3, 3418d286 <RCCEx_GetXSPICLKFreq+0xd2>
            xspi_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3418d23a:	f7ff fdd5 	bl	3418cde8 <HAL_RCCEx_GetPLL1CLKFreq>
            xspi_frequency = xspi_frequency / ic_divider;
3418d23e:	fbb0 f0f4 	udiv	r0, r0, r4
  return xspi_frequency;
3418d242:	e7ce      	b.n	3418d1e2 <RCCEx_GetXSPICLKFreq+0x2e>
  switch (LL_RCC_GetXSPIClockSource(XSPIxSource))
3418d244:	4b17      	ldr	r3, [pc, #92]	@ (3418d2a4 <RCCEx_GetXSPICLKFreq+0xf0>)
3418d246:	4298      	cmp	r0, r3
3418d248:	d003      	beq.n	3418d252 <RCCEx_GetXSPICLKFreq+0x9e>
3418d24a:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3418d24e:	4298      	cmp	r0, r3
3418d250:	d1c6      	bne.n	3418d1e0 <RCCEx_GetXSPICLKFreq+0x2c>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC4EN) == RCC_DIVENR_IC4EN) ? 1UL : 0UL);
3418d252:	4b13      	ldr	r3, [pc, #76]	@ (3418d2a0 <RCCEx_GetXSPICLKFreq+0xec>)
3418d254:	f8d3 0240 	ldr.w	r0, [r3, #576]	@ 0x240
3418d258:	f010 0008 	ands.w	r0, r0, #8
3418d25c:	d0c1      	beq.n	3418d1e2 <RCCEx_GetXSPICLKFreq+0x2e>
  return ((READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4INT) >> RCC_IC4CFGR_IC4INT_Pos) + 1UL);
3418d25e:	f8d3 00d0 	ldr.w	r0, [r3, #208]	@ 0xd0
  return (uint32_t)(READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL));
3418d262:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
  return ((READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4INT) >> RCC_IC4CFGR_IC4INT_Pos) + 1UL);
3418d266:	f3c0 4007 	ubfx	r0, r0, #16, #8
3418d26a:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL));
3418d26c:	e7de      	b.n	3418d22c <RCCEx_GetXSPICLKFreq+0x78>
      xspi_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
3418d26e:	f7fd fc51 	bl	3418ab14 <HAL_RCC_GetSysClockFreq>
}
3418d272:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      xspi_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
3418d276:	f7fe b8df 	b.w	3418b438 <RCCEx_GetHCLKFreq>
        switch (LL_RCC_IC4_GetSource())
3418d27a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418d27e:	d1af      	bne.n	3418d1e0 <RCCEx_GetXSPICLKFreq+0x2c>
            xspi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3418d280:	f7ff fe72 	bl	3418cf68 <HAL_RCCEx_GetPLL4CLKFreq>
3418d284:	e7db      	b.n	3418d23e <RCCEx_GetXSPICLKFreq+0x8a>
            xspi_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3418d286:	f7ff fdef 	bl	3418ce68 <HAL_RCCEx_GetPLL2CLKFreq>
3418d28a:	e7d8      	b.n	3418d23e <RCCEx_GetXSPICLKFreq+0x8a>
            xspi_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3418d28c:	f7ff fe2c 	bl	3418cee8 <HAL_RCCEx_GetPLL3CLKFreq>
3418d290:	e7d5      	b.n	3418d23e <RCCEx_GetXSPICLKFreq+0x8a>
3418d292:	bf00      	nop
3418d294:	03020014 	.word	0x03020014
3418d298:	03010414 	.word	0x03010414
3418d29c:	03030014 	.word	0x03030014
3418d2a0:	56028000 	.word	0x56028000
3418d2a4:	03030414 	.word	0x03030414

3418d2a8 <RCCEx_GetOTGPHYCLKFreq>:
{
3418d2a8:	b510      	push	{r4, lr}
  return LL_RCC_GetClockSource(Periph);
3418d2aa:	f7fe f85d 	bl	3418b368 <LL_RCC_GetClockSource>
  switch (LL_RCC_GetUSBClockSource(OTGPHYxSource))
3418d2ae:	4b2b      	ldr	r3, [pc, #172]	@ (3418d35c <RCCEx_GetOTGPHYCLKFreq+0xb4>)
3418d2b0:	4298      	cmp	r0, r3
3418d2b2:	d021      	beq.n	3418d2f8 <RCCEx_GetOTGPHYCLKFreq+0x50>
3418d2b4:	d815      	bhi.n	3418d2e2 <RCCEx_GetOTGPHYCLKFreq+0x3a>
3418d2b6:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3418d2ba:	4298      	cmp	r0, r3
3418d2bc:	d00d      	beq.n	3418d2da <RCCEx_GetOTGPHYCLKFreq+0x32>
3418d2be:	d809      	bhi.n	3418d2d4 <RCCEx_GetOTGPHYCLKFreq+0x2c>
3418d2c0:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3418d2c4:	4298      	cmp	r0, r3
3418d2c6:	d02d      	beq.n	3418d324 <RCCEx_GetOTGPHYCLKFreq+0x7c>
3418d2c8:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
3418d2cc:	4298      	cmp	r0, r3
3418d2ce:	d029      	beq.n	3418d324 <RCCEx_GetOTGPHYCLKFreq+0x7c>
  uint32_t usb_frequency = RCC_PERIPH_FREQUENCY_NO;
3418d2d0:	2000      	movs	r0, #0
}
3418d2d2:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetUSBClockSource(OTGPHYxSource))
3418d2d4:	4b22      	ldr	r3, [pc, #136]	@ (3418d360 <RCCEx_GetOTGPHYCLKFreq+0xb8>)
3418d2d6:	4298      	cmp	r0, r3
3418d2d8:	d1fa      	bne.n	3418d2d0 <RCCEx_GetOTGPHYCLKFreq+0x28>
}
3418d2da:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      usb_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3418d2de:	f7ff be83 	b.w	3418cfe8 <RCCEx_GetCLKPCLKFreq.constprop.0>
  switch (LL_RCC_GetUSBClockSource(OTGPHYxSource))
3418d2e2:	4b20      	ldr	r3, [pc, #128]	@ (3418d364 <RCCEx_GetOTGPHYCLKFreq+0xbc>)
3418d2e4:	4298      	cmp	r0, r3
3418d2e6:	d023      	beq.n	3418d330 <RCCEx_GetOTGPHYCLKFreq+0x88>
3418d2e8:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
3418d2ec:	4298      	cmp	r0, r3
3418d2ee:	d01f      	beq.n	3418d330 <RCCEx_GetOTGPHYCLKFreq+0x88>
3418d2f0:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3418d2f4:	4298      	cmp	r0, r3
3418d2f6:	d1eb      	bne.n	3418d2d0 <RCCEx_GetOTGPHYCLKFreq+0x28>
      if (LL_RCC_IC15_IsEnabled() != 0U)
3418d2f8:	f7fe f88c 	bl	3418b414 <LL_RCC_IC15_IsEnabled>
3418d2fc:	2800      	cmp	r0, #0
3418d2fe:	d0e7      	beq.n	3418d2d0 <RCCEx_GetOTGPHYCLKFreq+0x28>
        uint32_t ic_divider = LL_RCC_IC15_GetDivider();
3418d300:	f7fe f890 	bl	3418b424 <LL_RCC_IC15_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL));
3418d304:	4b18      	ldr	r3, [pc, #96]	@ (3418d368 <RCCEx_GetOTGPHYCLKFreq+0xc0>)
3418d306:	4604      	mov	r4, r0
3418d308:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3418d30c:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC15_GetSource())
3418d310:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418d314:	d01f      	beq.n	3418d356 <RCCEx_GetOTGPHYCLKFreq+0xae>
3418d316:	d815      	bhi.n	3418d344 <RCCEx_GetOTGPHYCLKFreq+0x9c>
3418d318:	b9d3      	cbnz	r3, 3418d350 <RCCEx_GetOTGPHYCLKFreq+0xa8>
            usb_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3418d31a:	f7ff fd65 	bl	3418cde8 <HAL_RCCEx_GetPLL1CLKFreq>
            usb_frequency = usb_frequency / ic_divider;
3418d31e:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
3418d322:	e7d6      	b.n	3418d2d2 <RCCEx_GetOTGPHYCLKFreq+0x2a>
      if (LL_RCC_HSE_IsReady() != 0U)
3418d324:	f7fd ffee 	bl	3418b304 <LL_RCC_HSE_IsReady>
3418d328:	2800      	cmp	r0, #0
3418d32a:	d0d1      	beq.n	3418d2d0 <RCCEx_GetOTGPHYCLKFreq+0x28>
        usb_frequency = HSE_VALUE / 2U;
3418d32c:	480f      	ldr	r0, [pc, #60]	@ (3418d36c <RCCEx_GetOTGPHYCLKFreq+0xc4>)
3418d32e:	e7d0      	b.n	3418d2d2 <RCCEx_GetOTGPHYCLKFreq+0x2a>
      if (LL_RCC_HSE_IsReady() != 0U)
3418d330:	f7fd ffe8 	bl	3418b304 <LL_RCC_HSE_IsReady>
3418d334:	2800      	cmp	r0, #0
3418d336:	d0cb      	beq.n	3418d2d0 <RCCEx_GetOTGPHYCLKFreq+0x28>
        if (LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock() == 0UL)
3418d338:	f7fd ffdc 	bl	3418b2f4 <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock>
3418d33c:	2800      	cmp	r0, #0
3418d33e:	d1f5      	bne.n	3418d32c <RCCEx_GetOTGPHYCLKFreq+0x84>
          usb_frequency = HSE_VALUE;
3418d340:	480b      	ldr	r0, [pc, #44]	@ (3418d370 <RCCEx_GetOTGPHYCLKFreq+0xc8>)
  return usb_frequency;
3418d342:	e7c6      	b.n	3418d2d2 <RCCEx_GetOTGPHYCLKFreq+0x2a>
        switch (LL_RCC_IC15_GetSource())
3418d344:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418d348:	d1c2      	bne.n	3418d2d0 <RCCEx_GetOTGPHYCLKFreq+0x28>
            usb_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3418d34a:	f7ff fe0d 	bl	3418cf68 <HAL_RCCEx_GetPLL4CLKFreq>
3418d34e:	e7e6      	b.n	3418d31e <RCCEx_GetOTGPHYCLKFreq+0x76>
            usb_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3418d350:	f7ff fd8a 	bl	3418ce68 <HAL_RCCEx_GetPLL2CLKFreq>
3418d354:	e7e3      	b.n	3418d31e <RCCEx_GetOTGPHYCLKFreq+0x76>
            usb_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3418d356:	f7ff fdc7 	bl	3418cee8 <HAL_RCCEx_GetPLL3CLKFreq>
3418d35a:	e7e0      	b.n	3418d31e <RCCEx_GetOTGPHYCLKFreq+0x76>
3418d35c:	03020c14 	.word	0x03020c14
3418d360:	03011414 	.word	0x03011414
3418d364:	03030c14 	.word	0x03030c14
3418d368:	56028000 	.word	0x56028000
3418d36c:	016e3600 	.word	0x016e3600
3418d370:	02dc6c00 	.word	0x02dc6c00

3418d374 <RCCEx_GetOTGPHYCKREFCLKFreq>:
{
3418d374:	b508      	push	{r3, lr}
  return LL_RCC_GetClockSource(Periph);
3418d376:	f7fd fff7 	bl	3418b368 <LL_RCC_GetClockSource>
  switch (LL_RCC_GetUSBClockSource(OTGPHYxCKREFSource))
3418d37a:	4b11      	ldr	r3, [pc, #68]	@ (3418d3c0 <RCCEx_GetOTGPHYCKREFCLKFreq+0x4c>)
3418d37c:	4298      	cmp	r0, r3
3418d37e:	d01c      	beq.n	3418d3ba <RCCEx_GetOTGPHYCKREFCLKFreq+0x46>
3418d380:	d805      	bhi.n	3418d38e <RCCEx_GetOTGPHYCKREFCLKFreq+0x1a>
3418d382:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
3418d386:	4298      	cmp	r0, r3
3418d388:	d012      	beq.n	3418d3b0 <RCCEx_GetOTGPHYCKREFCLKFreq+0x3c>
  uint32_t usb_frequency = RCC_PERIPH_FREQUENCY_NO;
3418d38a:	2000      	movs	r0, #0
}
3418d38c:	bd08      	pop	{r3, pc}
  switch (LL_RCC_GetUSBClockSource(OTGPHYxCKREFSource))
3418d38e:	4b0d      	ldr	r3, [pc, #52]	@ (3418d3c4 <RCCEx_GetOTGPHYCKREFCLKFreq+0x50>)
3418d390:	f420 6000 	bic.w	r0, r0, #2048	@ 0x800
3418d394:	4298      	cmp	r0, r3
3418d396:	d1f8      	bne.n	3418d38a <RCCEx_GetOTGPHYCKREFCLKFreq+0x16>
      if (LL_RCC_HSE_IsReady() != 0U)
3418d398:	f7fd ffb4 	bl	3418b304 <LL_RCC_HSE_IsReady>
3418d39c:	2800      	cmp	r0, #0
3418d39e:	d0f4      	beq.n	3418d38a <RCCEx_GetOTGPHYCKREFCLKFreq+0x16>
        if (LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock() == 0UL)
3418d3a0:	f7fd ffa8 	bl	3418b2f4 <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock>
          usb_frequency = HSE_VALUE;
3418d3a4:	4b08      	ldr	r3, [pc, #32]	@ (3418d3c8 <RCCEx_GetOTGPHYCKREFCLKFreq+0x54>)
3418d3a6:	2800      	cmp	r0, #0
3418d3a8:	4808      	ldr	r0, [pc, #32]	@ (3418d3cc <RCCEx_GetOTGPHYCKREFCLKFreq+0x58>)
3418d3aa:	bf08      	it	eq
3418d3ac:	4618      	moveq	r0, r3
3418d3ae:	e7ed      	b.n	3418d38c <RCCEx_GetOTGPHYCKREFCLKFreq+0x18>
      usb_frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY1_CLKSOURCE);
3418d3b0:	4807      	ldr	r0, [pc, #28]	@ (3418d3d0 <RCCEx_GetOTGPHYCKREFCLKFreq+0x5c>)
}
3418d3b2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
      usb_frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY2_CLKSOURCE);
3418d3b6:	f7ff bf77 	b.w	3418d2a8 <RCCEx_GetOTGPHYCLKFreq>
3418d3ba:	4806      	ldr	r0, [pc, #24]	@ (3418d3d4 <RCCEx_GetOTGPHYCKREFCLKFreq+0x60>)
3418d3bc:	e7f9      	b.n	3418d3b2 <RCCEx_GetOTGPHYCKREFCLKFreq+0x3e>
3418d3be:	bf00      	nop
3418d3c0:	01001814 	.word	0x01001814
3418d3c4:	01011014 	.word	0x01011014
3418d3c8:	02dc6c00 	.word	0x02dc6c00
3418d3cc:	016e3600 	.word	0x016e3600
3418d3d0:	03000c14 	.word	0x03000c14
3418d3d4:	03001414 	.word	0x03001414

3418d3d8 <RCCEx_GetUSARTCLKFreq>:
{
3418d3d8:	b510      	push	{r4, lr}
  return LL_RCC_GetClockSource(Periph);
3418d3da:	f7fd ffc5 	bl	3418b368 <LL_RCC_GetClockSource>
  switch (LL_RCC_GetUSARTClockSource(USARTxSource))
3418d3de:	4b6f      	ldr	r3, [pc, #444]	@ (3418d59c <RCCEx_GetUSARTCLKFreq+0x1c4>)
3418d3e0:	4298      	cmp	r0, r3
3418d3e2:	d039      	beq.n	3418d458 <RCCEx_GetUSARTCLKFreq+0x80>
3418d3e4:	d852      	bhi.n	3418d48c <RCCEx_GetUSARTCLKFreq+0xb4>
3418d3e6:	f5a3 3300 	sub.w	r3, r3, #131072	@ 0x20000
3418d3ea:	4298      	cmp	r0, r3
3418d3ec:	f000 80b5 	beq.w	3418d55a <RCCEx_GetUSARTCLKFreq+0x182>
3418d3f0:	d813      	bhi.n	3418d41a <RCCEx_GetUSARTCLKFreq+0x42>
3418d3f2:	f6a3 73fc 	subw	r3, r3, #4092	@ 0xffc
3418d3f6:	4298      	cmp	r0, r3
3418d3f8:	f000 80af 	beq.w	3418d55a <RCCEx_GetUSARTCLKFreq+0x182>
3418d3fc:	d80b      	bhi.n	3418d416 <RCCEx_GetUSARTCLKFreq+0x3e>
3418d3fe:	f2a3 4304 	subw	r3, r3, #1028	@ 0x404
3418d402:	4298      	cmp	r0, r3
3418d404:	f000 80a9 	beq.w	3418d55a <RCCEx_GetUSARTCLKFreq+0x182>
3418d408:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3418d40c:	4298      	cmp	r0, r3
3418d40e:	f000 80ae 	beq.w	3418d56e <RCCEx_GetUSARTCLKFreq+0x196>
  uint32_t usart_frequency = RCC_PERIPH_FREQUENCY_NO;
3418d412:	2000      	movs	r0, #0
}
3418d414:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetUSARTClockSource(USARTxSource))
3418d416:	4b62      	ldr	r3, [pc, #392]	@ (3418d5a0 <RCCEx_GetUSARTCLKFreq+0x1c8>)
3418d418:	e7f8      	b.n	3418d40c <RCCEx_GetUSARTCLKFreq+0x34>
3418d41a:	4b62      	ldr	r3, [pc, #392]	@ (3418d5a4 <RCCEx_GetUSARTCLKFreq+0x1cc>)
3418d41c:	4298      	cmp	r0, r3
3418d41e:	d00c      	beq.n	3418d43a <RCCEx_GetUSARTCLKFreq+0x62>
3418d420:	d80f      	bhi.n	3418d442 <RCCEx_GetUSARTCLKFreq+0x6a>
3418d422:	f6a3 73fc 	subw	r3, r3, #4092	@ 0xffc
3418d426:	4298      	cmp	r0, r3
3418d428:	d007      	beq.n	3418d43a <RCCEx_GetUSARTCLKFreq+0x62>
3418d42a:	bf8e      	itee	hi
3418d42c:	4b5e      	ldrhi	r3, [pc, #376]	@ (3418d5a8 <RCCEx_GetUSARTCLKFreq+0x1d0>)
3418d42e:	f420 6080 	bicls.w	r0, r0, #1024	@ 0x400
3418d432:	f2a3 4304 	subwls	r3, r3, #1028	@ 0x404
3418d436:	4298      	cmp	r0, r3
3418d438:	d1eb      	bne.n	3418d412 <RCCEx_GetUSARTCLKFreq+0x3a>
}
3418d43a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      usart_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3418d43e:	f7ff bdd3 	b.w	3418cfe8 <RCCEx_GetCLKPCLKFreq.constprop.0>
  switch (LL_RCC_GetUSARTClockSource(USARTxSource))
3418d442:	4b5a      	ldr	r3, [pc, #360]	@ (3418d5ac <RCCEx_GetUSARTCLKFreq+0x1d4>)
3418d444:	4298      	cmp	r0, r3
3418d446:	d007      	beq.n	3418d458 <RCCEx_GetUSARTCLKFreq+0x80>
3418d448:	bf8e      	itee	hi
3418d44a:	4b59      	ldrhi	r3, [pc, #356]	@ (3418d5b0 <RCCEx_GetUSARTCLKFreq+0x1d8>)
3418d44c:	f420 6080 	bicls.w	r0, r0, #1024	@ 0x400
3418d450:	f2a3 4304 	subwls	r3, r3, #1028	@ 0x404
3418d454:	4298      	cmp	r0, r3
3418d456:	d1dc      	bne.n	3418d412 <RCCEx_GetUSARTCLKFreq+0x3a>
      if (LL_RCC_IC9_IsEnabled() != 0U)
3418d458:	f7fd ffb8 	bl	3418b3cc <LL_RCC_IC9_IsEnabled>
3418d45c:	2800      	cmp	r0, #0
3418d45e:	d0d8      	beq.n	3418d412 <RCCEx_GetUSARTCLKFreq+0x3a>
        ic_divider = LL_RCC_IC9_GetDivider();
3418d460:	f7fd ffbc 	bl	3418b3dc <LL_RCC_IC9_GetDivider>
3418d464:	4604      	mov	r4, r0
  return (uint32_t)(READ_BIT(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL));
3418d466:	4b53      	ldr	r3, [pc, #332]	@ (3418d5b4 <RCCEx_GetUSARTCLKFreq+0x1dc>)
3418d468:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
  return (uint32_t)(READ_BIT(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL));
3418d46c:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC14_GetSource())
3418d470:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418d474:	f000 808e 	beq.w	3418d594 <RCCEx_GetUSARTCLKFreq+0x1bc>
3418d478:	f200 8082 	bhi.w	3418d580 <RCCEx_GetUSARTCLKFreq+0x1a8>
3418d47c:	2b00      	cmp	r3, #0
3418d47e:	f040 8086 	bne.w	3418d58e <RCCEx_GetUSARTCLKFreq+0x1b6>
            usart_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3418d482:	f7ff fcb1 	bl	3418cde8 <HAL_RCCEx_GetPLL1CLKFreq>
            usart_frequency = usart_frequency / ic_divider;
3418d486:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
3418d48a:	e7c3      	b.n	3418d414 <RCCEx_GetUSARTCLKFreq+0x3c>
  switch (LL_RCC_GetUSARTClockSource(USARTxSource))
3418d48c:	4b4a      	ldr	r3, [pc, #296]	@ (3418d5b8 <RCCEx_GetUSARTCLKFreq+0x1e0>)
3418d48e:	4298      	cmp	r0, r3
3418d490:	d045      	beq.n	3418d51e <RCCEx_GetUSARTCLKFreq+0x146>
3418d492:	d833      	bhi.n	3418d4fc <RCCEx_GetUSARTCLKFreq+0x124>
3418d494:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3418d498:	4298      	cmp	r0, r3
3418d49a:	d028      	beq.n	3418d4ee <RCCEx_GetUSARTCLKFreq+0x116>
3418d49c:	d81c      	bhi.n	3418d4d8 <RCCEx_GetUSARTCLKFreq+0x100>
3418d49e:	f5a3 437b 	sub.w	r3, r3, #64256	@ 0xfb00
3418d4a2:	3bfc      	subs	r3, #252	@ 0xfc
3418d4a4:	4298      	cmp	r0, r3
3418d4a6:	d006      	beq.n	3418d4b6 <RCCEx_GetUSARTCLKFreq+0xde>
3418d4a8:	d810      	bhi.n	3418d4cc <RCCEx_GetUSARTCLKFreq+0xf4>
3418d4aa:	f420 6080 	bic.w	r0, r0, #1024	@ 0x400
3418d4ae:	f2a3 4304 	subw	r3, r3, #1028	@ 0x404
3418d4b2:	4298      	cmp	r0, r3
3418d4b4:	d1ad      	bne.n	3418d412 <RCCEx_GetUSARTCLKFreq+0x3a>
      if (LL_RCC_IC14_IsEnabled() != 0U)
3418d4b6:	f7fd ff9b 	bl	3418b3f0 <LL_RCC_IC14_IsEnabled>
3418d4ba:	2800      	cmp	r0, #0
3418d4bc:	d0a9      	beq.n	3418d412 <RCCEx_GetUSARTCLKFreq+0x3a>
        ic_divider = LL_RCC_IC14_GetDivider();
3418d4be:	f7fd ff9f 	bl	3418b400 <LL_RCC_IC14_GetDivider>
3418d4c2:	4b3c      	ldr	r3, [pc, #240]	@ (3418d5b4 <RCCEx_GetUSARTCLKFreq+0x1dc>)
3418d4c4:	4604      	mov	r4, r0
3418d4c6:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3418d4ca:	e7cf      	b.n	3418d46c <RCCEx_GetUSARTCLKFreq+0x94>
  switch (LL_RCC_GetUSARTClockSource(USARTxSource))
3418d4cc:	4b3b      	ldr	r3, [pc, #236]	@ (3418d5bc <RCCEx_GetUSARTCLKFreq+0x1e4>)
3418d4ce:	4298      	cmp	r0, r3
3418d4d0:	d0f1      	beq.n	3418d4b6 <RCCEx_GetUSARTCLKFreq+0xde>
3418d4d2:	f503 6340 	add.w	r3, r3, #3072	@ 0xc00
3418d4d6:	e7ec      	b.n	3418d4b2 <RCCEx_GetUSARTCLKFreq+0xda>
3418d4d8:	4b39      	ldr	r3, [pc, #228]	@ (3418d5c0 <RCCEx_GetUSARTCLKFreq+0x1e8>)
3418d4da:	4298      	cmp	r0, r3
3418d4dc:	d007      	beq.n	3418d4ee <RCCEx_GetUSARTCLKFreq+0x116>
3418d4de:	bf8e      	itee	hi
3418d4e0:	4b38      	ldrhi	r3, [pc, #224]	@ (3418d5c4 <RCCEx_GetUSARTCLKFreq+0x1ec>)
3418d4e2:	f020 0004 	bicls.w	r0, r0, #4
3418d4e6:	f5a3 6380 	subls.w	r3, r3, #1024	@ 0x400
3418d4ea:	4298      	cmp	r0, r3
3418d4ec:	d191      	bne.n	3418d412 <RCCEx_GetUSARTCLKFreq+0x3a>
      if (LL_RCC_LSE_IsReady() != 0U)
3418d4ee:	f7fd ff21 	bl	3418b334 <LL_RCC_LSE_IsReady>
3418d4f2:	3800      	subs	r0, #0
3418d4f4:	bf18      	it	ne
3418d4f6:	2001      	movne	r0, #1
3418d4f8:	03c0      	lsls	r0, r0, #15
3418d4fa:	e78b      	b.n	3418d414 <RCCEx_GetUSARTCLKFreq+0x3c>
  switch (LL_RCC_GetUSARTClockSource(USARTxSource))
3418d4fc:	4b32      	ldr	r3, [pc, #200]	@ (3418d5c8 <RCCEx_GetUSARTCLKFreq+0x1f0>)
3418d4fe:	4298      	cmp	r0, r3
3418d500:	d020      	beq.n	3418d544 <RCCEx_GetUSARTCLKFreq+0x16c>
3418d502:	d813      	bhi.n	3418d52c <RCCEx_GetUSARTCLKFreq+0x154>
3418d504:	f5a3 4378 	sub.w	r3, r3, #63488	@ 0xf800
3418d508:	4298      	cmp	r0, r3
3418d50a:	d008      	beq.n	3418d51e <RCCEx_GetUSARTCLKFreq+0x146>
3418d50c:	bf8e      	itee	hi
3418d50e:	4b2f      	ldrhi	r3, [pc, #188]	@ (3418d5cc <RCCEx_GetUSARTCLKFreq+0x1f4>)
3418d510:	f020 0004 	bicls.w	r0, r0, #4
3418d514:	f5a3 6380 	subls.w	r3, r3, #1024	@ 0x400
3418d518:	4298      	cmp	r0, r3
3418d51a:	f47f af7a 	bne.w	3418d412 <RCCEx_GetUSARTCLKFreq+0x3a>
      if (LL_RCC_MSI_IsReady() != 0U)
3418d51e:	f7fd ff01 	bl	3418b324 <LL_RCC_MSI_IsReady>
3418d522:	2800      	cmp	r0, #0
3418d524:	f43f af75 	beq.w	3418d412 <RCCEx_GetUSARTCLKFreq+0x3a>
        usart_frequency = MSI_VALUE;
3418d528:	4829      	ldr	r0, [pc, #164]	@ (3418d5d0 <RCCEx_GetUSARTCLKFreq+0x1f8>)
  return usart_frequency;
3418d52a:	e773      	b.n	3418d414 <RCCEx_GetUSARTCLKFreq+0x3c>
  switch (LL_RCC_GetUSARTClockSource(USARTxSource))
3418d52c:	4b29      	ldr	r3, [pc, #164]	@ (3418d5d4 <RCCEx_GetUSARTCLKFreq+0x1fc>)
3418d52e:	4298      	cmp	r0, r3
3418d530:	d008      	beq.n	3418d544 <RCCEx_GetUSARTCLKFreq+0x16c>
3418d532:	bf8e      	itee	hi
3418d534:	4b28      	ldrhi	r3, [pc, #160]	@ (3418d5d8 <RCCEx_GetUSARTCLKFreq+0x200>)
3418d536:	f020 0004 	bicls.w	r0, r0, #4
3418d53a:	f5a3 6380 	subls.w	r3, r3, #1024	@ 0x400
3418d53e:	4298      	cmp	r0, r3
3418d540:	f47f af67 	bne.w	3418d412 <RCCEx_GetUSARTCLKFreq+0x3a>
      if (LL_RCC_HSI_IsReady() != 0U)
3418d544:	f7fd fee6 	bl	3418b314 <LL_RCC_HSI_IsReady>
3418d548:	2800      	cmp	r0, #0
3418d54a:	f43f af62 	beq.w	3418d412 <RCCEx_GetUSARTCLKFreq+0x3a>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3418d54e:	4b19      	ldr	r3, [pc, #100]	@ (3418d5b4 <RCCEx_GetUSARTCLKFreq+0x1dc>)
        usart_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3418d550:	4822      	ldr	r0, [pc, #136]	@ (3418d5dc <RCCEx_GetUSARTCLKFreq+0x204>)
3418d552:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3418d554:	f3c3 13c1 	ubfx	r3, r3, #7, #2
3418d558:	e007      	b.n	3418d56a <RCCEx_GetUSARTCLKFreq+0x192>
      usart_frequency = RCCEx_GetPCLK2Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3418d55a:	f7fd fadb 	bl	3418ab14 <HAL_RCC_GetSysClockFreq>
3418d55e:	f7fd ff6b 	bl	3418b438 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE2));
3418d562:	4b14      	ldr	r3, [pc, #80]	@ (3418d5b4 <RCCEx_GetUSARTCLKFreq+0x1dc>)
3418d564:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  return LL_RCC_CALC_PCLK2_FREQ(HCLK_Frequency, LL_RCC_GetAPB2Prescaler());
3418d566:	f3c3 1302 	ubfx	r3, r3, #4, #3
        usart_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3418d56a:	40d8      	lsrs	r0, r3
3418d56c:	e752      	b.n	3418d414 <RCCEx_GetUSARTCLKFreq+0x3c>
      usart_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3418d56e:	f7fd fad1 	bl	3418ab14 <HAL_RCC_GetSysClockFreq>
3418d572:	f7fd ff61 	bl	3418b438 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE1));
3418d576:	4b0f      	ldr	r3, [pc, #60]	@ (3418d5b4 <RCCEx_GetUSARTCLKFreq+0x1dc>)
3418d578:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418d57a:	f003 0307 	and.w	r3, r3, #7
3418d57e:	e7f4      	b.n	3418d56a <RCCEx_GetUSARTCLKFreq+0x192>
        switch (LL_RCC_IC14_GetSource())
3418d580:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418d584:	f47f af45 	bne.w	3418d412 <RCCEx_GetUSARTCLKFreq+0x3a>
            usart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3418d588:	f7ff fcee 	bl	3418cf68 <HAL_RCCEx_GetPLL4CLKFreq>
3418d58c:	e77b      	b.n	3418d486 <RCCEx_GetUSARTCLKFreq+0xae>
            usart_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3418d58e:	f7ff fc6b 	bl	3418ce68 <HAL_RCCEx_GetPLL2CLKFreq>
3418d592:	e778      	b.n	3418d486 <RCCEx_GetUSARTCLKFreq+0xae>
            usart_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3418d594:	f7ff fca8 	bl	3418cee8 <HAL_RCCEx_GetPLL3CLKFreq>
3418d598:	e775      	b.n	3418d486 <RCCEx_GetUSARTCLKFreq+0xae>
3418d59a:	bf00      	nop
3418d59c:	07021430 	.word	0x07021430
3418d5a0:	07000830 	.word	0x07000830
3418d5a4:	07011430 	.word	0x07011430
3418d5a8:	07010830 	.word	0x07010830
3418d5ac:	07020434 	.word	0x07020434
3418d5b0:	07020830 	.word	0x07020830
3418d5b4:	56028000 	.word	0x56028000
3418d5b8:	07050030 	.word	0x07050030
3418d5bc:	07030830 	.word	0x07030830
3418d5c0:	07040830 	.word	0x07040830
3418d5c4:	07041430 	.word	0x07041430
3418d5c8:	07060030 	.word	0x07060030
3418d5cc:	07051430 	.word	0x07051430
3418d5d0:	003d0900 	.word	0x003d0900
3418d5d4:	07060830 	.word	0x07060830
3418d5d8:	07061430 	.word	0x07061430
3418d5dc:	03d09000 	.word	0x03d09000

3418d5e0 <RCCEx_GetUARTCLKFreq>:
{
3418d5e0:	b510      	push	{r4, lr}
  return LL_RCC_GetClockSource(Periph);
3418d5e2:	f7fd fec1 	bl	3418b368 <LL_RCC_GetClockSource>
  switch (LL_RCC_GetUARTClockSource(UARTxSource))
3418d5e6:	4b77      	ldr	r3, [pc, #476]	@ (3418d7c4 <RCCEx_GetUARTCLKFreq+0x1e4>)
3418d5e8:	4298      	cmp	r0, r3
3418d5ea:	d03e      	beq.n	3418d66a <RCCEx_GetUARTCLKFreq+0x8a>
3418d5ec:	d859      	bhi.n	3418d6a2 <RCCEx_GetUARTCLKFreq+0xc2>
3418d5ee:	f5a3 3300 	sub.w	r3, r3, #131072	@ 0x20000
3418d5f2:	4298      	cmp	r0, r3
3418d5f4:	f000 80c6 	beq.w	3418d784 <RCCEx_GetUARTCLKFreq+0x1a4>
3418d5f8:	d814      	bhi.n	3418d624 <RCCEx_GetUARTCLKFreq+0x44>
3418d5fa:	4b73      	ldr	r3, [pc, #460]	@ (3418d7c8 <RCCEx_GetUARTCLKFreq+0x1e8>)
3418d5fc:	4298      	cmp	r0, r3
3418d5fe:	f000 80cb 	beq.w	3418d798 <RCCEx_GetUARTCLKFreq+0x1b8>
3418d602:	3b01      	subs	r3, #1
3418d604:	4298      	cmp	r0, r3
3418d606:	d90b      	bls.n	3418d620 <RCCEx_GetUARTCLKFreq+0x40>
3418d608:	f420 6200 	bic.w	r2, r0, #2048	@ 0x800
3418d60c:	f603 73fd 	addw	r3, r3, #4093	@ 0xffd
3418d610:	429a      	cmp	r2, r3
3418d612:	f000 80b7 	beq.w	3418d784 <RCCEx_GetUARTCLKFreq+0x1a4>
3418d616:	f5a3 6380 	sub.w	r3, r3, #1024	@ 0x400
3418d61a:	4298      	cmp	r0, r3
3418d61c:	f000 80b2 	beq.w	3418d784 <RCCEx_GetUARTCLKFreq+0x1a4>
  uint32_t uart_frequency = RCC_PERIPH_FREQUENCY_NO;
3418d620:	2000      	movs	r0, #0
}
3418d622:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetUARTClockSource(UARTxSource))
3418d624:	4b69      	ldr	r3, [pc, #420]	@ (3418d7cc <RCCEx_GetUARTCLKFreq+0x1ec>)
3418d626:	4298      	cmp	r0, r3
3418d628:	d00d      	beq.n	3418d646 <RCCEx_GetUARTCLKFreq+0x66>
3418d62a:	d812      	bhi.n	3418d652 <RCCEx_GetUARTCLKFreq+0x72>
3418d62c:	f5a3 6340 	sub.w	r3, r3, #3072	@ 0xc00
3418d630:	4298      	cmp	r0, r3
3418d632:	d008      	beq.n	3418d646 <RCCEx_GetUARTCLKFreq+0x66>
3418d634:	d80b      	bhi.n	3418d64e <RCCEx_GetUARTCLKFreq+0x6e>
3418d636:	f6a3 73fc 	subw	r3, r3, #4092	@ 0xffc
3418d63a:	4298      	cmp	r0, r3
3418d63c:	d003      	beq.n	3418d646 <RCCEx_GetUARTCLKFreq+0x66>
3418d63e:	f603 33fc 	addw	r3, r3, #3068	@ 0xbfc
3418d642:	4298      	cmp	r0, r3
3418d644:	d1ec      	bne.n	3418d620 <RCCEx_GetUARTCLKFreq+0x40>
}
3418d646:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      uart_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3418d64a:	f7ff bccd 	b.w	3418cfe8 <RCCEx_GetCLKPCLKFreq.constprop.0>
  switch (LL_RCC_GetUARTClockSource(UARTxSource))
3418d64e:	4b60      	ldr	r3, [pc, #384]	@ (3418d7d0 <RCCEx_GetUARTCLKFreq+0x1f0>)
3418d650:	e7f7      	b.n	3418d642 <RCCEx_GetUARTCLKFreq+0x62>
3418d652:	4b60      	ldr	r3, [pc, #384]	@ (3418d7d4 <RCCEx_GetUARTCLKFreq+0x1f4>)
3418d654:	4298      	cmp	r0, r3
3418d656:	d008      	beq.n	3418d66a <RCCEx_GetUARTCLKFreq+0x8a>
3418d658:	d821      	bhi.n	3418d69e <RCCEx_GetUARTCLKFreq+0xbe>
3418d65a:	f6a3 73fc 	subw	r3, r3, #4092	@ 0xffc
3418d65e:	4298      	cmp	r0, r3
3418d660:	d003      	beq.n	3418d66a <RCCEx_GetUARTCLKFreq+0x8a>
3418d662:	f603 33fc 	addw	r3, r3, #3068	@ 0xbfc
3418d666:	4298      	cmp	r0, r3
3418d668:	d1da      	bne.n	3418d620 <RCCEx_GetUARTCLKFreq+0x40>
      if (LL_RCC_IC9_IsEnabled() != 0U)
3418d66a:	f7fd feaf 	bl	3418b3cc <LL_RCC_IC9_IsEnabled>
3418d66e:	2800      	cmp	r0, #0
3418d670:	d0d6      	beq.n	3418d620 <RCCEx_GetUARTCLKFreq+0x40>
        ic_divider = LL_RCC_IC9_GetDivider();
3418d672:	f7fd feb3 	bl	3418b3dc <LL_RCC_IC9_GetDivider>
3418d676:	4604      	mov	r4, r0
  return (uint32_t)(READ_BIT(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL));
3418d678:	4b57      	ldr	r3, [pc, #348]	@ (3418d7d8 <RCCEx_GetUARTCLKFreq+0x1f8>)
3418d67a:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
  return (uint32_t)(READ_BIT(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL));
3418d67e:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC14_GetSource())
3418d682:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418d686:	f000 809a 	beq.w	3418d7be <RCCEx_GetUARTCLKFreq+0x1de>
3418d68a:	f200 808e 	bhi.w	3418d7aa <RCCEx_GetUARTCLKFreq+0x1ca>
3418d68e:	2b00      	cmp	r3, #0
3418d690:	f040 8092 	bne.w	3418d7b8 <RCCEx_GetUARTCLKFreq+0x1d8>
            uart_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3418d694:	f7ff fba8 	bl	3418cde8 <HAL_RCCEx_GetPLL1CLKFreq>
            uart_frequency = uart_frequency / ic_divider;
3418d698:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
3418d69c:	e7c1      	b.n	3418d622 <RCCEx_GetUARTCLKFreq+0x42>
  switch (LL_RCC_GetUARTClockSource(UARTxSource))
3418d69e:	4b4f      	ldr	r3, [pc, #316]	@ (3418d7dc <RCCEx_GetUARTCLKFreq+0x1fc>)
3418d6a0:	e7e1      	b.n	3418d666 <RCCEx_GetUARTCLKFreq+0x86>
3418d6a2:	4b4f      	ldr	r3, [pc, #316]	@ (3418d7e0 <RCCEx_GetUARTCLKFreq+0x200>)
3418d6a4:	4298      	cmp	r0, r3
3418d6a6:	d04a      	beq.n	3418d73e <RCCEx_GetUARTCLKFreq+0x15e>
3418d6a8:	d836      	bhi.n	3418d718 <RCCEx_GetUARTCLKFreq+0x138>
3418d6aa:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3418d6ae:	4298      	cmp	r0, r3
3418d6b0:	d029      	beq.n	3418d706 <RCCEx_GetUARTCLKFreq+0x126>
3418d6b2:	d81c      	bhi.n	3418d6ee <RCCEx_GetUARTCLKFreq+0x10e>
3418d6b4:	f5a3 4370 	sub.w	r3, r3, #61440	@ 0xf000
3418d6b8:	3b04      	subs	r3, #4
3418d6ba:	4298      	cmp	r0, r3
3418d6bc:	d008      	beq.n	3418d6d0 <RCCEx_GetUARTCLKFreq+0xf0>
3418d6be:	d812      	bhi.n	3418d6e6 <RCCEx_GetUARTCLKFreq+0x106>
3418d6c0:	f6a3 73fc 	subw	r3, r3, #4092	@ 0xffc
3418d6c4:	4298      	cmp	r0, r3
3418d6c6:	d003      	beq.n	3418d6d0 <RCCEx_GetUARTCLKFreq+0xf0>
3418d6c8:	f603 33fc 	addw	r3, r3, #3068	@ 0xbfc
3418d6cc:	4298      	cmp	r0, r3
3418d6ce:	d1a7      	bne.n	3418d620 <RCCEx_GetUARTCLKFreq+0x40>
      if (LL_RCC_IC14_IsEnabled() != 0U)
3418d6d0:	f7fd fe8e 	bl	3418b3f0 <LL_RCC_IC14_IsEnabled>
3418d6d4:	2800      	cmp	r0, #0
3418d6d6:	d0a3      	beq.n	3418d620 <RCCEx_GetUARTCLKFreq+0x40>
        ic_divider = LL_RCC_IC14_GetDivider();
3418d6d8:	f7fd fe92 	bl	3418b400 <LL_RCC_IC14_GetDivider>
3418d6dc:	4b3e      	ldr	r3, [pc, #248]	@ (3418d7d8 <RCCEx_GetUARTCLKFreq+0x1f8>)
3418d6de:	4604      	mov	r4, r0
3418d6e0:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3418d6e4:	e7cb      	b.n	3418d67e <RCCEx_GetUARTCLKFreq+0x9e>
  switch (LL_RCC_GetUARTClockSource(UARTxSource))
3418d6e6:	4b3f      	ldr	r3, [pc, #252]	@ (3418d7e4 <RCCEx_GetUARTCLKFreq+0x204>)
3418d6e8:	f420 6080 	bic.w	r0, r0, #1024	@ 0x400
3418d6ec:	e7ee      	b.n	3418d6cc <RCCEx_GetUARTCLKFreq+0xec>
3418d6ee:	4b3e      	ldr	r3, [pc, #248]	@ (3418d7e8 <RCCEx_GetUARTCLKFreq+0x208>)
3418d6f0:	4298      	cmp	r0, r3
3418d6f2:	d008      	beq.n	3418d706 <RCCEx_GetUARTCLKFreq+0x126>
3418d6f4:	d80e      	bhi.n	3418d714 <RCCEx_GetUARTCLKFreq+0x134>
3418d6f6:	f5a3 6340 	sub.w	r3, r3, #3072	@ 0xc00
3418d6fa:	4298      	cmp	r0, r3
3418d6fc:	d003      	beq.n	3418d706 <RCCEx_GetUARTCLKFreq+0x126>
3418d6fe:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3418d702:	4298      	cmp	r0, r3
3418d704:	d18c      	bne.n	3418d620 <RCCEx_GetUARTCLKFreq+0x40>
      if (LL_RCC_LSE_IsReady() != 0U)
3418d706:	f7fd fe15 	bl	3418b334 <LL_RCC_LSE_IsReady>
3418d70a:	3800      	subs	r0, #0
3418d70c:	bf18      	it	ne
3418d70e:	2001      	movne	r0, #1
3418d710:	03c0      	lsls	r0, r0, #15
3418d712:	e786      	b.n	3418d622 <RCCEx_GetUARTCLKFreq+0x42>
  switch (LL_RCC_GetUARTClockSource(UARTxSource))
3418d714:	4b35      	ldr	r3, [pc, #212]	@ (3418d7ec <RCCEx_GetUARTCLKFreq+0x20c>)
3418d716:	e7f4      	b.n	3418d702 <RCCEx_GetUARTCLKFreq+0x122>
3418d718:	4b35      	ldr	r3, [pc, #212]	@ (3418d7f0 <RCCEx_GetUARTCLKFreq+0x210>)
3418d71a:	4298      	cmp	r0, r3
3418d71c:	d025      	beq.n	3418d76a <RCCEx_GetUARTCLKFreq+0x18a>
3418d71e:	d817      	bhi.n	3418d750 <RCCEx_GetUARTCLKFreq+0x170>
3418d720:	f5a3 4368 	sub.w	r3, r3, #59392	@ 0xe800
3418d724:	3b04      	subs	r3, #4
3418d726:	4298      	cmp	r0, r3
3418d728:	d009      	beq.n	3418d73e <RCCEx_GetUARTCLKFreq+0x15e>
3418d72a:	d80f      	bhi.n	3418d74c <RCCEx_GetUARTCLKFreq+0x16c>
3418d72c:	f5a3 6340 	sub.w	r3, r3, #3072	@ 0xc00
3418d730:	4298      	cmp	r0, r3
3418d732:	d004      	beq.n	3418d73e <RCCEx_GetUARTCLKFreq+0x15e>
3418d734:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3418d738:	4298      	cmp	r0, r3
3418d73a:	f47f af71 	bne.w	3418d620 <RCCEx_GetUARTCLKFreq+0x40>
      if (LL_RCC_MSI_IsReady() != 0U)
3418d73e:	f7fd fdf1 	bl	3418b324 <LL_RCC_MSI_IsReady>
3418d742:	2800      	cmp	r0, #0
3418d744:	f43f af6c 	beq.w	3418d620 <RCCEx_GetUARTCLKFreq+0x40>
        uart_frequency = MSI_VALUE;
3418d748:	482a      	ldr	r0, [pc, #168]	@ (3418d7f4 <RCCEx_GetUARTCLKFreq+0x214>)
  return uart_frequency;
3418d74a:	e76a      	b.n	3418d622 <RCCEx_GetUARTCLKFreq+0x42>
  switch (LL_RCC_GetUARTClockSource(UARTxSource))
3418d74c:	4b2a      	ldr	r3, [pc, #168]	@ (3418d7f8 <RCCEx_GetUARTCLKFreq+0x218>)
3418d74e:	e7f3      	b.n	3418d738 <RCCEx_GetUARTCLKFreq+0x158>
3418d750:	4b2a      	ldr	r3, [pc, #168]	@ (3418d7fc <RCCEx_GetUARTCLKFreq+0x21c>)
3418d752:	4298      	cmp	r0, r3
3418d754:	d009      	beq.n	3418d76a <RCCEx_GetUARTCLKFreq+0x18a>
3418d756:	d813      	bhi.n	3418d780 <RCCEx_GetUARTCLKFreq+0x1a0>
3418d758:	f5a3 6340 	sub.w	r3, r3, #3072	@ 0xc00
3418d75c:	4298      	cmp	r0, r3
3418d75e:	d004      	beq.n	3418d76a <RCCEx_GetUARTCLKFreq+0x18a>
3418d760:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3418d764:	4298      	cmp	r0, r3
3418d766:	f47f af5b 	bne.w	3418d620 <RCCEx_GetUARTCLKFreq+0x40>
      if (LL_RCC_HSI_IsReady() != 0U)
3418d76a:	f7fd fdd3 	bl	3418b314 <LL_RCC_HSI_IsReady>
3418d76e:	2800      	cmp	r0, #0
3418d770:	f43f af56 	beq.w	3418d620 <RCCEx_GetUARTCLKFreq+0x40>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3418d774:	4b18      	ldr	r3, [pc, #96]	@ (3418d7d8 <RCCEx_GetUARTCLKFreq+0x1f8>)
        uart_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3418d776:	4822      	ldr	r0, [pc, #136]	@ (3418d800 <RCCEx_GetUARTCLKFreq+0x220>)
3418d778:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3418d77a:	f3c3 13c1 	ubfx	r3, r3, #7, #2
3418d77e:	e009      	b.n	3418d794 <RCCEx_GetUARTCLKFreq+0x1b4>
  switch (LL_RCC_GetUARTClockSource(UARTxSource))
3418d780:	4b20      	ldr	r3, [pc, #128]	@ (3418d804 <RCCEx_GetUARTCLKFreq+0x224>)
3418d782:	e7ef      	b.n	3418d764 <RCCEx_GetUARTCLKFreq+0x184>
      uart_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3418d784:	f7fd f9c6 	bl	3418ab14 <HAL_RCC_GetSysClockFreq>
3418d788:	f7fd fe56 	bl	3418b438 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE1));
3418d78c:	4b12      	ldr	r3, [pc, #72]	@ (3418d7d8 <RCCEx_GetUARTCLKFreq+0x1f8>)
3418d78e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418d790:	f003 0307 	and.w	r3, r3, #7
        uart_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3418d794:	40d8      	lsrs	r0, r3
3418d796:	e744      	b.n	3418d622 <RCCEx_GetUARTCLKFreq+0x42>
      uart_frequency = RCCEx_GetPCLK2Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3418d798:	f7fd f9bc 	bl	3418ab14 <HAL_RCC_GetSysClockFreq>
3418d79c:	f7fd fe4c 	bl	3418b438 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE2));
3418d7a0:	4b0d      	ldr	r3, [pc, #52]	@ (3418d7d8 <RCCEx_GetUARTCLKFreq+0x1f8>)
3418d7a2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  return LL_RCC_CALC_PCLK2_FREQ(HCLK_Frequency, LL_RCC_GetAPB2Prescaler());
3418d7a4:	f3c3 1302 	ubfx	r3, r3, #4, #3
3418d7a8:	e7f4      	b.n	3418d794 <RCCEx_GetUARTCLKFreq+0x1b4>
        switch (LL_RCC_IC14_GetSource())
3418d7aa:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418d7ae:	f47f af37 	bne.w	3418d620 <RCCEx_GetUARTCLKFreq+0x40>
            uart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3418d7b2:	f7ff fbd9 	bl	3418cf68 <HAL_RCCEx_GetPLL4CLKFreq>
3418d7b6:	e76f      	b.n	3418d698 <RCCEx_GetUARTCLKFreq+0xb8>
            uart_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3418d7b8:	f7ff fb56 	bl	3418ce68 <HAL_RCCEx_GetPLL2CLKFreq>
3418d7bc:	e76c      	b.n	3418d698 <RCCEx_GetUARTCLKFreq+0xb8>
            uart_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3418d7be:	f7ff fb93 	bl	3418cee8 <HAL_RCCEx_GetPLL3CLKFreq>
3418d7c2:	e769      	b.n	3418d698 <RCCEx_GetUARTCLKFreq+0xb8>
3418d7c4:	07021c30 	.word	0x07021c30
3418d7c8:	07000034 	.word	0x07000034
3418d7cc:	07011c30 	.word	0x07011c30
3418d7d0:	07011830 	.word	0x07011830
3418d7d4:	07021030 	.word	0x07021030
3418d7d8:	56028000 	.word	0x56028000
3418d7dc:	07021830 	.word	0x07021830
3418d7e0:	07050034 	.word	0x07050034
3418d7e4:	07031830 	.word	0x07031830
3418d7e8:	07041830 	.word	0x07041830
3418d7ec:	07041c30 	.word	0x07041c30
3418d7f0:	07060034 	.word	0x07060034
3418d7f4:	003d0900 	.word	0x003d0900
3418d7f8:	07051c30 	.word	0x07051c30
3418d7fc:	07061830 	.word	0x07061830
3418d800:	03d09000 	.word	0x03d09000
3418d804:	07061c30 	.word	0x07061c30

3418d808 <RCCEx_GetSPICLKFreq>:
{
3418d808:	b510      	push	{r4, lr}
  return LL_RCC_GetClockSource(Periph);
3418d80a:	f7fd fdad 	bl	3418b368 <LL_RCC_GetClockSource>
  switch (LL_RCC_GetSPIClockSource(SPIxSource))
3418d80e:	4b89      	ldr	r3, [pc, #548]	@ (3418da34 <RCCEx_GetSPICLKFreq+0x22c>)
3418d810:	4298      	cmp	r0, r3
3418d812:	d055      	beq.n	3418d8c0 <RCCEx_GetSPICLKFreq+0xb8>
3418d814:	d865      	bhi.n	3418d8e2 <RCCEx_GetSPICLKFreq+0xda>
3418d816:	f5a3 333c 	sub.w	r3, r3, #192512	@ 0x2f000
3418d81a:	4298      	cmp	r0, r3
3418d81c:	f000 80ca 	beq.w	3418d9b4 <RCCEx_GetSPICLKFreq+0x1ac>
3418d820:	d81e      	bhi.n	3418d860 <RCCEx_GetSPICLKFreq+0x58>
3418d822:	f5a3 6340 	sub.w	r3, r3, #3072	@ 0xc00
3418d826:	4298      	cmp	r0, r3
3418d828:	f000 80ba 	beq.w	3418d9a0 <RCCEx_GetSPICLKFreq+0x198>
3418d82c:	d80a      	bhi.n	3418d844 <RCCEx_GetSPICLKFreq+0x3c>
3418d82e:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
3418d832:	4298      	cmp	r0, r3
3418d834:	d00b      	beq.n	3418d84e <RCCEx_GetSPICLKFreq+0x46>
3418d836:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3418d83a:	4298      	cmp	r0, r3
3418d83c:	f000 80b0 	beq.w	3418d9a0 <RCCEx_GetSPICLKFreq+0x198>
  uint32_t spi_frequency = RCC_PERIPH_FREQUENCY_NO;
3418d840:	2000      	movs	r0, #0
}
3418d842:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetSPIClockSource(SPIxSource))
3418d844:	4b7c      	ldr	r3, [pc, #496]	@ (3418da38 <RCCEx_GetSPICLKFreq+0x230>)
3418d846:	f420 6080 	bic.w	r0, r0, #1024	@ 0x400
3418d84a:	4298      	cmp	r0, r3
3418d84c:	d1f8      	bne.n	3418d840 <RCCEx_GetSPICLKFreq+0x38>
      spi_frequency = RCCEx_GetPCLK2Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3418d84e:	f7fd f961 	bl	3418ab14 <HAL_RCC_GetSysClockFreq>
3418d852:	f7fd fdf1 	bl	3418b438 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE2));
3418d856:	4b79      	ldr	r3, [pc, #484]	@ (3418da3c <RCCEx_GetSPICLKFreq+0x234>)
3418d858:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  return LL_RCC_CALC_PCLK2_FREQ(HCLK_Frequency, LL_RCC_GetAPB2Prescaler());
3418d85a:	f3c3 1302 	ubfx	r3, r3, #4, #3
3418d85e:	e0a7      	b.n	3418d9b0 <RCCEx_GetSPICLKFreq+0x1a8>
  switch (LL_RCC_GetSPIClockSource(SPIxSource))
3418d860:	4b77      	ldr	r3, [pc, #476]	@ (3418da40 <RCCEx_GetSPICLKFreq+0x238>)
3418d862:	4298      	cmp	r0, r3
3418d864:	f000 80af 	beq.w	3418d9c6 <RCCEx_GetSPICLKFreq+0x1be>
3418d868:	d81d      	bhi.n	3418d8a6 <RCCEx_GetSPICLKFreq+0x9e>
3418d86a:	f5a3 4378 	sub.w	r3, r3, #63488	@ 0xf800
3418d86e:	4298      	cmp	r0, r3
3418d870:	d00a      	beq.n	3418d888 <RCCEx_GetSPICLKFreq+0x80>
3418d872:	d80d      	bhi.n	3418d890 <RCCEx_GetSPICLKFreq+0x88>
3418d874:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
3418d878:	4298      	cmp	r0, r3
3418d87a:	d005      	beq.n	3418d888 <RCCEx_GetSPICLKFreq+0x80>
3418d87c:	f420 6000 	bic.w	r0, r0, #2048	@ 0x800
3418d880:	f5a3 6380 	sub.w	r3, r3, #1024	@ 0x400
3418d884:	4298      	cmp	r0, r3
3418d886:	d1db      	bne.n	3418d840 <RCCEx_GetSPICLKFreq+0x38>
}
3418d888:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      spi_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3418d88c:	f7ff bbac 	b.w	3418cfe8 <RCCEx_GetCLKPCLKFreq.constprop.0>
  switch (LL_RCC_GetSPIClockSource(SPIxSource))
3418d890:	4b6c      	ldr	r3, [pc, #432]	@ (3418da44 <RCCEx_GetSPICLKFreq+0x23c>)
3418d892:	4298      	cmp	r0, r3
3418d894:	d0f8      	beq.n	3418d888 <RCCEx_GetSPICLKFreq+0x80>
3418d896:	f503 436c 	add.w	r3, r3, #60416	@ 0xec00
3418d89a:	4298      	cmp	r0, r3
3418d89c:	f000 8093 	beq.w	3418d9c6 <RCCEx_GetSPICLKFreq+0x1be>
3418d8a0:	f5a3 4370 	sub.w	r3, r3, #61440	@ 0xf000
3418d8a4:	e7ee      	b.n	3418d884 <RCCEx_GetSPICLKFreq+0x7c>
3418d8a6:	4b68      	ldr	r3, [pc, #416]	@ (3418da48 <RCCEx_GetSPICLKFreq+0x240>)
3418d8a8:	4298      	cmp	r0, r3
3418d8aa:	d009      	beq.n	3418d8c0 <RCCEx_GetSPICLKFreq+0xb8>
3418d8ac:	d813      	bhi.n	3418d8d6 <RCCEx_GetSPICLKFreq+0xce>
3418d8ae:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
3418d8b2:	4298      	cmp	r0, r3
3418d8b4:	f000 8087 	beq.w	3418d9c6 <RCCEx_GetSPICLKFreq+0x1be>
3418d8b8:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3418d8bc:	4298      	cmp	r0, r3
3418d8be:	d1bf      	bne.n	3418d840 <RCCEx_GetSPICLKFreq+0x38>
      if (LL_RCC_IC9_IsEnabled() != 0U)
3418d8c0:	f7fd fd84 	bl	3418b3cc <LL_RCC_IC9_IsEnabled>
3418d8c4:	2800      	cmp	r0, #0
3418d8c6:	d0bb      	beq.n	3418d840 <RCCEx_GetSPICLKFreq+0x38>
        ic_divider = LL_RCC_IC9_GetDivider();
3418d8c8:	f7fd fd88 	bl	3418b3dc <LL_RCC_IC9_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL));
3418d8cc:	4b5b      	ldr	r3, [pc, #364]	@ (3418da3c <RCCEx_GetSPICLKFreq+0x234>)
3418d8ce:	4604      	mov	r4, r0
3418d8d0:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3418d8d4:	e082      	b.n	3418d9dc <RCCEx_GetSPICLKFreq+0x1d4>
  switch (LL_RCC_GetSPIClockSource(SPIxSource))
3418d8d6:	4b5d      	ldr	r3, [pc, #372]	@ (3418da4c <RCCEx_GetSPICLKFreq+0x244>)
3418d8d8:	4298      	cmp	r0, r3
3418d8da:	d074      	beq.n	3418d9c6 <RCCEx_GetSPICLKFreq+0x1be>
3418d8dc:	f503 436c 	add.w	r3, r3, #60416	@ 0xec00
3418d8e0:	e7ec      	b.n	3418d8bc <RCCEx_GetSPICLKFreq+0xb4>
3418d8e2:	4b5b      	ldr	r3, [pc, #364]	@ (3418da50 <RCCEx_GetSPICLKFreq+0x248>)
3418d8e4:	4298      	cmp	r0, r3
3418d8e6:	d043      	beq.n	3418d970 <RCCEx_GetSPICLKFreq+0x168>
3418d8e8:	d830      	bhi.n	3418d94c <RCCEx_GetSPICLKFreq+0x144>
3418d8ea:	f5a3 33fa 	sub.w	r3, r3, #128000	@ 0x1f400
3418d8ee:	4298      	cmp	r0, r3
3418d8f0:	d0e6      	beq.n	3418d8c0 <RCCEx_GetSPICLKFreq+0xb8>
3418d8f2:	d808      	bhi.n	3418d906 <RCCEx_GetSPICLKFreq+0xfe>
3418d8f4:	f420 6280 	bic.w	r2, r0, #1024	@ 0x400
3418d8f8:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
3418d8fc:	429a      	cmp	r2, r3
3418d8fe:	d079      	beq.n	3418d9f4 <RCCEx_GetSPICLKFreq+0x1ec>
3418d900:	f5a3 6380 	sub.w	r3, r3, #1024	@ 0x400
3418d904:	e7da      	b.n	3418d8bc <RCCEx_GetSPICLKFreq+0xb4>
3418d906:	4b53      	ldr	r3, [pc, #332]	@ (3418da54 <RCCEx_GetSPICLKFreq+0x24c>)
3418d908:	4298      	cmp	r0, r3
3418d90a:	d00d      	beq.n	3418d928 <RCCEx_GetSPICLKFreq+0x120>
3418d90c:	d814      	bhi.n	3418d938 <RCCEx_GetSPICLKFreq+0x130>
3418d90e:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
3418d912:	4298      	cmp	r0, r3
3418d914:	d008      	beq.n	3418d928 <RCCEx_GetSPICLKFreq+0x120>
3418d916:	d80d      	bhi.n	3418d934 <RCCEx_GetSPICLKFreq+0x12c>
3418d918:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
3418d91c:	4298      	cmp	r0, r3
3418d91e:	d003      	beq.n	3418d928 <RCCEx_GetSPICLKFreq+0x120>
3418d920:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3418d924:	4298      	cmp	r0, r3
3418d926:	d18b      	bne.n	3418d840 <RCCEx_GetSPICLKFreq+0x38>
      if (LL_RCC_MSI_IsReady() != 0U)
3418d928:	f7fd fcfc 	bl	3418b324 <LL_RCC_MSI_IsReady>
3418d92c:	2800      	cmp	r0, #0
3418d92e:	d087      	beq.n	3418d840 <RCCEx_GetSPICLKFreq+0x38>
        spi_frequency = MSI_VALUE;
3418d930:	4849      	ldr	r0, [pc, #292]	@ (3418da58 <RCCEx_GetSPICLKFreq+0x250>)
  return spi_frequency;
3418d932:	e786      	b.n	3418d842 <RCCEx_GetSPICLKFreq+0x3a>
  switch (LL_RCC_GetSPIClockSource(SPIxSource))
3418d934:	4b49      	ldr	r3, [pc, #292]	@ (3418da5c <RCCEx_GetSPICLKFreq+0x254>)
3418d936:	e7f5      	b.n	3418d924 <RCCEx_GetSPICLKFreq+0x11c>
3418d938:	4b49      	ldr	r3, [pc, #292]	@ (3418da60 <RCCEx_GetSPICLKFreq+0x258>)
3418d93a:	4298      	cmp	r0, r3
3418d93c:	d018      	beq.n	3418d970 <RCCEx_GetSPICLKFreq+0x168>
3418d93e:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3418d942:	4298      	cmp	r0, r3
3418d944:	d014      	beq.n	3418d970 <RCCEx_GetSPICLKFreq+0x168>
3418d946:	f5a3 4370 	sub.w	r3, r3, #61440	@ 0xf000
3418d94a:	e7eb      	b.n	3418d924 <RCCEx_GetSPICLKFreq+0x11c>
3418d94c:	4b45      	ldr	r3, [pc, #276]	@ (3418da64 <RCCEx_GetSPICLKFreq+0x25c>)
3418d94e:	4298      	cmp	r0, r3
3418d950:	d069      	beq.n	3418da26 <RCCEx_GetSPICLKFreq+0x21e>
3418d952:	d81e      	bhi.n	3418d992 <RCCEx_GetSPICLKFreq+0x18a>
3418d954:	f5a3 6340 	sub.w	r3, r3, #3072	@ 0xc00
3418d958:	4298      	cmp	r0, r3
3418d95a:	d018      	beq.n	3418d98e <RCCEx_GetSPICLKFreq+0x186>
3418d95c:	f420 6380 	bic.w	r3, r0, #1024	@ 0x400
3418d960:	d811      	bhi.n	3418d986 <RCCEx_GetSPICLKFreq+0x17e>
3418d962:	4a41      	ldr	r2, [pc, #260]	@ (3418da68 <RCCEx_GetSPICLKFreq+0x260>)
3418d964:	4293      	cmp	r3, r2
3418d966:	d003      	beq.n	3418d970 <RCCEx_GetSPICLKFreq+0x168>
3418d968:	4b40      	ldr	r3, [pc, #256]	@ (3418da6c <RCCEx_GetSPICLKFreq+0x264>)
3418d96a:	4298      	cmp	r0, r3
3418d96c:	f47f af68 	bne.w	3418d840 <RCCEx_GetSPICLKFreq+0x38>
      if (LL_RCC_HSI_IsReady() != 0U)
3418d970:	f7fd fcd0 	bl	3418b314 <LL_RCC_HSI_IsReady>
3418d974:	2800      	cmp	r0, #0
3418d976:	f43f af63 	beq.w	3418d840 <RCCEx_GetSPICLKFreq+0x38>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3418d97a:	4b30      	ldr	r3, [pc, #192]	@ (3418da3c <RCCEx_GetSPICLKFreq+0x234>)
        spi_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3418d97c:	483c      	ldr	r0, [pc, #240]	@ (3418da70 <RCCEx_GetSPICLKFreq+0x268>)
3418d97e:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3418d980:	f3c3 13c1 	ubfx	r3, r3, #7, #2
3418d984:	e014      	b.n	3418d9b0 <RCCEx_GetSPICLKFreq+0x1a8>
  switch (LL_RCC_GetSPIClockSource(SPIxSource))
3418d986:	4a3b      	ldr	r2, [pc, #236]	@ (3418da74 <RCCEx_GetSPICLKFreq+0x26c>)
3418d988:	4293      	cmp	r3, r2
3418d98a:	f47f af59 	bne.w	3418d840 <RCCEx_GetSPICLKFreq+0x38>
3418d98e:	483a      	ldr	r0, [pc, #232]	@ (3418da78 <RCCEx_GetSPICLKFreq+0x270>)
3418d990:	e757      	b.n	3418d842 <RCCEx_GetSPICLKFreq+0x3a>
3418d992:	4b3a      	ldr	r3, [pc, #232]	@ (3418da7c <RCCEx_GetSPICLKFreq+0x274>)
3418d994:	4298      	cmp	r0, r3
3418d996:	d046      	beq.n	3418da26 <RCCEx_GetSPICLKFreq+0x21e>
3418d998:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3418d99c:	4298      	cmp	r0, r3
3418d99e:	e7f4      	b.n	3418d98a <RCCEx_GetSPICLKFreq+0x182>
      spi_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3418d9a0:	f7fd f8b8 	bl	3418ab14 <HAL_RCC_GetSysClockFreq>
3418d9a4:	f7fd fd48 	bl	3418b438 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE1));
3418d9a8:	4b24      	ldr	r3, [pc, #144]	@ (3418da3c <RCCEx_GetSPICLKFreq+0x234>)
3418d9aa:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418d9ac:	f003 0307 	and.w	r3, r3, #7
  return LL_RCC_CALC_PCLK2_FREQ(HCLK_Frequency, LL_RCC_GetAPB2Prescaler());
3418d9b0:	40d8      	lsrs	r0, r3
      break;
3418d9b2:	e746      	b.n	3418d842 <RCCEx_GetSPICLKFreq+0x3a>
      spi_frequency = RCCEx_GetPCLK4Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3418d9b4:	f7fd f8ae 	bl	3418ab14 <HAL_RCC_GetSysClockFreq>
3418d9b8:	f7fd fd3e 	bl	3418b438 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE4));
3418d9bc:	4b1f      	ldr	r3, [pc, #124]	@ (3418da3c <RCCEx_GetSPICLKFreq+0x234>)
3418d9be:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  return LL_RCC_CALC_PCLK4_FREQ(HCLK_Frequency, LL_RCC_GetAPB4Prescaler());
3418d9c0:	f3c3 3302 	ubfx	r3, r3, #12, #3
3418d9c4:	e7f4      	b.n	3418d9b0 <RCCEx_GetSPICLKFreq+0x1a8>
      if (LL_RCC_IC8_IsEnabled() != 0U)
3418d9c6:	f7fd fcef 	bl	3418b3a8 <LL_RCC_IC8_IsEnabled>
3418d9ca:	2800      	cmp	r0, #0
3418d9cc:	f43f af38 	beq.w	3418d840 <RCCEx_GetSPICLKFreq+0x38>
        ic_divider = LL_RCC_IC8_GetDivider();
3418d9d0:	f7fd fcf2 	bl	3418b3b8 <LL_RCC_IC8_GetDivider>
3418d9d4:	4604      	mov	r4, r0
  return (uint32_t)(READ_BIT(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL));
3418d9d6:	4b19      	ldr	r3, [pc, #100]	@ (3418da3c <RCCEx_GetSPICLKFreq+0x234>)
3418d9d8:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
  return (uint32_t)(READ_BIT(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL));
3418d9dc:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC14_GetSource())
3418d9e0:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418d9e4:	d01c      	beq.n	3418da20 <RCCEx_GetSPICLKFreq+0x218>
3418d9e6:	d811      	bhi.n	3418da0c <RCCEx_GetSPICLKFreq+0x204>
3418d9e8:	b9bb      	cbnz	r3, 3418da1a <RCCEx_GetSPICLKFreq+0x212>
            spi_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3418d9ea:	f7ff f9fd 	bl	3418cde8 <HAL_RCCEx_GetPLL1CLKFreq>
            spi_frequency = spi_frequency / ic_divider;
3418d9ee:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
3418d9f2:	e726      	b.n	3418d842 <RCCEx_GetSPICLKFreq+0x3a>
      if (LL_RCC_IC14_IsEnabled() != 0U)
3418d9f4:	f7fd fcfc 	bl	3418b3f0 <LL_RCC_IC14_IsEnabled>
3418d9f8:	2800      	cmp	r0, #0
3418d9fa:	f43f af21 	beq.w	3418d840 <RCCEx_GetSPICLKFreq+0x38>
        ic_divider = LL_RCC_IC14_GetDivider();
3418d9fe:	f7fd fcff 	bl	3418b400 <LL_RCC_IC14_GetDivider>
3418da02:	4b0e      	ldr	r3, [pc, #56]	@ (3418da3c <RCCEx_GetSPICLKFreq+0x234>)
3418da04:	4604      	mov	r4, r0
3418da06:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3418da0a:	e7e7      	b.n	3418d9dc <RCCEx_GetSPICLKFreq+0x1d4>
        switch (LL_RCC_IC14_GetSource())
3418da0c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418da10:	f47f af16 	bne.w	3418d840 <RCCEx_GetSPICLKFreq+0x38>
            spi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3418da14:	f7ff faa8 	bl	3418cf68 <HAL_RCCEx_GetPLL4CLKFreq>
3418da18:	e7e9      	b.n	3418d9ee <RCCEx_GetSPICLKFreq+0x1e6>
            spi_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3418da1a:	f7ff fa25 	bl	3418ce68 <HAL_RCCEx_GetPLL2CLKFreq>
3418da1e:	e7e6      	b.n	3418d9ee <RCCEx_GetSPICLKFreq+0x1e6>
            spi_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3418da20:	f7ff fa62 	bl	3418cee8 <HAL_RCCEx_GetPLL3CLKFreq>
3418da24:	e7e3      	b.n	3418d9ee <RCCEx_GetSPICLKFreq+0x1e6>
      if (LL_RCC_HSE_IsReady() != 0U)
3418da26:	f7fd fc6d 	bl	3418b304 <LL_RCC_HSE_IsReady>
3418da2a:	2800      	cmp	r0, #0
3418da2c:	f43f af08 	beq.w	3418d840 <RCCEx_GetSPICLKFreq+0x38>
        spi_frequency = HSE_VALUE;
3418da30:	4813      	ldr	r0, [pc, #76]	@ (3418da80 <RCCEx_GetSPICLKFreq+0x278>)
3418da32:	e706      	b.n	3418d842 <RCCEx_GetSPICLKFreq+0x3a>
3418da34:	07030820 	.word	0x07030820
3418da38:	07001020 	.word	0x07001020
3418da3c:	56028000 	.word	0x56028000
3418da40:	07020820 	.word	0x07020820
3418da44:	07011820 	.word	0x07011820
3418da48:	07021420 	.word	0x07021420
3418da4c:	07021820 	.word	0x07021820
3418da50:	07050c20 	.word	0x07050c20
3418da54:	07041420 	.word	0x07041420
3418da58:	003d0900 	.word	0x003d0900
3418da5c:	07041020 	.word	0x07041020
3418da60:	07050420 	.word	0x07050420
3418da64:	07061020 	.word	0x07061020
3418da68:	07051020 	.word	0x07051020
3418da6c:	07051820 	.word	0x07051820
3418da70:	03d09000 	.word	0x03d09000
3418da74:	07060820 	.word	0x07060820
3418da78:	00bb8000 	.word	0x00bb8000
3418da7c:	07061420 	.word	0x07061420
3418da80:	02dc6c00 	.word	0x02dc6c00

3418da84 <RCCEx_GetSAICLKFreq>:
{
3418da84:	b510      	push	{r4, lr}
  return LL_RCC_GetClockSource(Periph);
3418da86:	f7fd fc6f 	bl	3418b368 <LL_RCC_GetClockSource>
  switch (LL_RCC_GetSAIClockSource(SAIxSource))
3418da8a:	4b49      	ldr	r3, [pc, #292]	@ (3418dbb0 <RCCEx_GetSAICLKFreq+0x12c>)
3418da8c:	4298      	cmp	r0, r3
3418da8e:	d04a      	beq.n	3418db26 <RCCEx_GetSAICLKFreq+0xa2>
3418da90:	d839      	bhi.n	3418db06 <RCCEx_GetSAICLKFreq+0x82>
3418da92:	f5a3 3300 	sub.w	r3, r3, #131072	@ 0x20000
3418da96:	4298      	cmp	r0, r3
3418da98:	d021      	beq.n	3418dade <RCCEx_GetSAICLKFreq+0x5a>
3418da9a:	d815      	bhi.n	3418dac8 <RCCEx_GetSAICLKFreq+0x44>
3418da9c:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3418daa0:	4298      	cmp	r0, r3
3418daa2:	d00d      	beq.n	3418dac0 <RCCEx_GetSAICLKFreq+0x3c>
3418daa4:	d809      	bhi.n	3418daba <RCCEx_GetSAICLKFreq+0x36>
3418daa6:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3418daaa:	4298      	cmp	r0, r3
3418daac:	d04e      	beq.n	3418db4c <RCCEx_GetSAICLKFreq+0xc8>
3418daae:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3418dab2:	4298      	cmp	r0, r3
3418dab4:	d04a      	beq.n	3418db4c <RCCEx_GetSAICLKFreq+0xc8>
  uint32_t sai_frequency = RCC_PERIPH_FREQUENCY_NO;
3418dab6:	2000      	movs	r0, #0
}
3418dab8:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetSAIClockSource(SAIxSource))
3418daba:	4b3e      	ldr	r3, [pc, #248]	@ (3418dbb4 <RCCEx_GetSAICLKFreq+0x130>)
3418dabc:	4298      	cmp	r0, r3
3418dabe:	d1fa      	bne.n	3418dab6 <RCCEx_GetSAICLKFreq+0x32>
}
3418dac0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      sai_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3418dac4:	f7ff ba90 	b.w	3418cfe8 <RCCEx_GetCLKPCLKFreq.constprop.0>
  switch (LL_RCC_GetSAIClockSource(SAIxSource))
3418dac8:	4b3b      	ldr	r3, [pc, #236]	@ (3418dbb8 <RCCEx_GetSAICLKFreq+0x134>)
3418daca:	4298      	cmp	r0, r3
3418dacc:	d04d      	beq.n	3418db6a <RCCEx_GetSAICLKFreq+0xe6>
3418dace:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3418dad2:	4298      	cmp	r0, r3
3418dad4:	d049      	beq.n	3418db6a <RCCEx_GetSAICLKFreq+0xe6>
3418dad6:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3418dada:	4298      	cmp	r0, r3
3418dadc:	d1eb      	bne.n	3418dab6 <RCCEx_GetSAICLKFreq+0x32>
      if (LL_RCC_IC7_IsEnabled() != 0U)
3418dade:	f7fd fc51 	bl	3418b384 <LL_RCC_IC7_IsEnabled>
3418dae2:	2800      	cmp	r0, #0
3418dae4:	d0e7      	beq.n	3418dab6 <RCCEx_GetSAICLKFreq+0x32>
        ic_divider = LL_RCC_IC7_GetDivider();
3418dae6:	f7fd fc55 	bl	3418b394 <LL_RCC_IC7_GetDivider>
3418daea:	4604      	mov	r4, r0
  return (uint32_t)(READ_BIT(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL));
3418daec:	4b33      	ldr	r3, [pc, #204]	@ (3418dbbc <RCCEx_GetSAICLKFreq+0x138>)
3418daee:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
  return (uint32_t)(READ_BIT(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL));
3418daf2:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC8_GetSource())
3418daf6:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418dafa:	d047      	beq.n	3418db8c <RCCEx_GetSAICLKFreq+0x108>
3418dafc:	d840      	bhi.n	3418db80 <RCCEx_GetSAICLKFreq+0xfc>
3418dafe:	bb7b      	cbnz	r3, 3418db60 <RCCEx_GetSAICLKFreq+0xdc>
            sai_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3418db00:	f7ff f972 	bl	3418cde8 <HAL_RCCEx_GetPLL1CLKFreq>
3418db04:	e02e      	b.n	3418db64 <RCCEx_GetSAICLKFreq+0xe0>
  switch (LL_RCC_GetSAIClockSource(SAIxSource))
3418db06:	4b2e      	ldr	r3, [pc, #184]	@ (3418dbc0 <RCCEx_GetSAICLKFreq+0x13c>)
3418db08:	4298      	cmp	r0, r3
3418db0a:	d01d      	beq.n	3418db48 <RCCEx_GetSAICLKFreq+0xc4>
3418db0c:	d811      	bhi.n	3418db32 <RCCEx_GetSAICLKFreq+0xae>
3418db0e:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3418db12:	4298      	cmp	r0, r3
3418db14:	d03d      	beq.n	3418db92 <RCCEx_GetSAICLKFreq+0x10e>
3418db16:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3418db1a:	4298      	cmp	r0, r3
3418db1c:	d039      	beq.n	3418db92 <RCCEx_GetSAICLKFreq+0x10e>
3418db1e:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3418db22:	4298      	cmp	r0, r3
3418db24:	d1c7      	bne.n	3418dab6 <RCCEx_GetSAICLKFreq+0x32>
      if (LL_RCC_MSI_IsReady() != 0U)
3418db26:	f7fd fbfd 	bl	3418b324 <LL_RCC_MSI_IsReady>
3418db2a:	2800      	cmp	r0, #0
3418db2c:	d0c3      	beq.n	3418dab6 <RCCEx_GetSAICLKFreq+0x32>
        sai_frequency = MSI_VALUE;
3418db2e:	4825      	ldr	r0, [pc, #148]	@ (3418dbc4 <RCCEx_GetSAICLKFreq+0x140>)
  return sai_frequency;
3418db30:	e7c2      	b.n	3418dab8 <RCCEx_GetSAICLKFreq+0x34>
  switch (LL_RCC_GetSAIClockSource(SAIxSource))
3418db32:	4b25      	ldr	r3, [pc, #148]	@ (3418dbc8 <RCCEx_GetSAICLKFreq+0x144>)
3418db34:	4298      	cmp	r0, r3
3418db36:	d036      	beq.n	3418dba6 <RCCEx_GetSAICLKFreq+0x122>
3418db38:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3418db3c:	4298      	cmp	r0, r3
3418db3e:	d032      	beq.n	3418dba6 <RCCEx_GetSAICLKFreq+0x122>
3418db40:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3418db44:	4298      	cmp	r0, r3
3418db46:	d1b6      	bne.n	3418dab6 <RCCEx_GetSAICLKFreq+0x32>
3418db48:	4820      	ldr	r0, [pc, #128]	@ (3418dbcc <RCCEx_GetSAICLKFreq+0x148>)
3418db4a:	e7b5      	b.n	3418dab8 <RCCEx_GetSAICLKFreq+0x34>
      sai_frequency = RCCEx_GetPCLK2Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3418db4c:	f7fc ffe2 	bl	3418ab14 <HAL_RCC_GetSysClockFreq>
3418db50:	f7fd fc72 	bl	3418b438 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE2));
3418db54:	4b19      	ldr	r3, [pc, #100]	@ (3418dbbc <RCCEx_GetSAICLKFreq+0x138>)
3418db56:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  return LL_RCC_CALC_PCLK2_FREQ(HCLK_Frequency, LL_RCC_GetAPB2Prescaler());
3418db58:	f3c3 1302 	ubfx	r3, r3, #4, #3
        sai_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3418db5c:	40d8      	lsrs	r0, r3
3418db5e:	e7ab      	b.n	3418dab8 <RCCEx_GetSAICLKFreq+0x34>
            sai_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3418db60:	f7ff f982 	bl	3418ce68 <HAL_RCCEx_GetPLL2CLKFreq>
            sai_frequency = sai_frequency / ic_divider;
3418db64:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
3418db68:	e7a6      	b.n	3418dab8 <RCCEx_GetSAICLKFreq+0x34>
      if (LL_RCC_IC8_IsEnabled() != 0U)
3418db6a:	f7fd fc1d 	bl	3418b3a8 <LL_RCC_IC8_IsEnabled>
3418db6e:	2800      	cmp	r0, #0
3418db70:	d0a1      	beq.n	3418dab6 <RCCEx_GetSAICLKFreq+0x32>
        ic_divider = LL_RCC_IC8_GetDivider();
3418db72:	f7fd fc21 	bl	3418b3b8 <LL_RCC_IC8_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL));
3418db76:	4b11      	ldr	r3, [pc, #68]	@ (3418dbbc <RCCEx_GetSAICLKFreq+0x138>)
3418db78:	4604      	mov	r4, r0
3418db7a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3418db7e:	e7b8      	b.n	3418daf2 <RCCEx_GetSAICLKFreq+0x6e>
        switch (LL_RCC_IC8_GetSource())
3418db80:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418db84:	d197      	bne.n	3418dab6 <RCCEx_GetSAICLKFreq+0x32>
            sai_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3418db86:	f7ff f9ef 	bl	3418cf68 <HAL_RCCEx_GetPLL4CLKFreq>
3418db8a:	e7eb      	b.n	3418db64 <RCCEx_GetSAICLKFreq+0xe0>
            sai_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3418db8c:	f7ff f9ac 	bl	3418cee8 <HAL_RCCEx_GetPLL3CLKFreq>
3418db90:	e7e8      	b.n	3418db64 <RCCEx_GetSAICLKFreq+0xe0>
      if (LL_RCC_HSI_IsReady() != 0U)
3418db92:	f7fd fbbf 	bl	3418b314 <LL_RCC_HSI_IsReady>
3418db96:	2800      	cmp	r0, #0
3418db98:	d08d      	beq.n	3418dab6 <RCCEx_GetSAICLKFreq+0x32>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3418db9a:	4b08      	ldr	r3, [pc, #32]	@ (3418dbbc <RCCEx_GetSAICLKFreq+0x138>)
        sai_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3418db9c:	480c      	ldr	r0, [pc, #48]	@ (3418dbd0 <RCCEx_GetSAICLKFreq+0x14c>)
3418db9e:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3418dba0:	f3c3 13c1 	ubfx	r3, r3, #7, #2
3418dba4:	e7da      	b.n	3418db5c <RCCEx_GetSAICLKFreq+0xd8>
}
3418dba6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      sai_frequency = RCCEx_GetSPDIFRXCLKFreq(LL_RCC_SPDIFRX1_CLKSOURCE);
3418dbaa:	f7ff baa3 	b.w	3418d0f4 <RCCEx_GetSPDIFRXCLKFreq.constprop.0>
3418dbae:	bf00      	nop
3418dbb0:	07041418 	.word	0x07041418
3418dbb4:	07011818 	.word	0x07011818
3418dbb8:	07031418 	.word	0x07031418
3418dbbc:	56028000 	.word	0x56028000
3418dbc0:	07061418 	.word	0x07061418
3418dbc4:	003d0900 	.word	0x003d0900
3418dbc8:	07071418 	.word	0x07071418
3418dbcc:	00bb8000 	.word	0x00bb8000
3418dbd0:	03d09000 	.word	0x03d09000

3418dbd4 <RCCEx_GetI3CCLKFreq>:
{
3418dbd4:	b510      	push	{r4, lr}
  return LL_RCC_GetClockSource(Periph);
3418dbd6:	f7fd fbc7 	bl	3418b368 <LL_RCC_GetClockSource>
  switch (LL_RCC_GetI3CClockSource(I3CxSource))
3418dbda:	4b3d      	ldr	r3, [pc, #244]	@ (3418dcd0 <RCCEx_GetI3CCLKFreq+0xfc>)
3418dbdc:	4298      	cmp	r0, r3
3418dbde:	d060      	beq.n	3418dca2 <RCCEx_GetI3CCLKFreq+0xce>
3418dbe0:	d830      	bhi.n	3418dc44 <RCCEx_GetI3CCLKFreq+0x70>
3418dbe2:	f5a3 33fe 	sub.w	r3, r3, #130048	@ 0x1fc00
3418dbe6:	4298      	cmp	r0, r3
3418dbe8:	d057      	beq.n	3418dc9a <RCCEx_GetI3CCLKFreq+0xc6>
3418dbea:	d80d      	bhi.n	3418dc08 <RCCEx_GetI3CCLKFreq+0x34>
3418dbec:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3418dbf0:	4298      	cmp	r0, r3
3418dbf2:	d048      	beq.n	3418dc86 <RCCEx_GetI3CCLKFreq+0xb2>
3418dbf4:	f503 437c 	add.w	r3, r3, #64512	@ 0xfc00
3418dbf8:	4298      	cmp	r0, r3
3418dbfa:	d04e      	beq.n	3418dc9a <RCCEx_GetI3CCLKFreq+0xc6>
3418dbfc:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3418dc00:	4298      	cmp	r0, r3
3418dc02:	d040      	beq.n	3418dc86 <RCCEx_GetI3CCLKFreq+0xb2>
  uint32_t i3c_frequency = RCC_PERIPH_FREQUENCY_NO;
3418dc04:	2000      	movs	r0, #0
}
3418dc06:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetI3CClockSource(I3CxSource))
3418dc08:	4b32      	ldr	r3, [pc, #200]	@ (3418dcd4 <RCCEx_GetI3CCLKFreq+0x100>)
3418dc0a:	f420 6080 	bic.w	r0, r0, #1024	@ 0x400
3418dc0e:	4298      	cmp	r0, r3
3418dc10:	d1f8      	bne.n	3418dc04 <RCCEx_GetI3CCLKFreq+0x30>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC10EN) == RCC_DIVENR_IC10EN) ? 1UL : 0UL);
3418dc12:	4b31      	ldr	r3, [pc, #196]	@ (3418dcd8 <RCCEx_GetI3CCLKFreq+0x104>)
3418dc14:	f8d3 2240 	ldr.w	r2, [r3, #576]	@ 0x240
3418dc18:	0592      	lsls	r2, r2, #22
3418dc1a:	d5f3      	bpl.n	3418dc04 <RCCEx_GetI3CCLKFreq+0x30>
  return ((READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10INT) >> RCC_IC10CFGR_IC10INT_Pos) + 1UL);
3418dc1c:	f8d3 00e8 	ldr.w	r0, [r3, #232]	@ 0xe8
  return (uint32_t)(READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL));
3418dc20:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
  return ((READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10INT) >> RCC_IC10CFGR_IC10INT_Pos) + 1UL);
3418dc24:	f3c0 4007 	ubfx	r0, r0, #16, #8
3418dc28:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL));
3418dc2a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC15_GetSource())
3418dc2e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418dc32:	d04a      	beq.n	3418dcca <RCCEx_GetI3CCLKFreq+0xf6>
3418dc34:	d840      	bhi.n	3418dcb8 <RCCEx_GetI3CCLKFreq+0xe4>
3418dc36:	2b00      	cmp	r3, #0
3418dc38:	d144      	bne.n	3418dcc4 <RCCEx_GetI3CCLKFreq+0xf0>
            i3c_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3418dc3a:	f7ff f8d5 	bl	3418cde8 <HAL_RCCEx_GetPLL1CLKFreq>
            i3c_frequency = i3c_frequency / ic_divider;
3418dc3e:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
3418dc42:	e7e0      	b.n	3418dc06 <RCCEx_GetI3CCLKFreq+0x32>
  switch (LL_RCC_GetI3CClockSource(I3CxSource))
3418dc44:	4b25      	ldr	r3, [pc, #148]	@ (3418dcdc <RCCEx_GetI3CCLKFreq+0x108>)
3418dc46:	4298      	cmp	r0, r3
3418dc48:	d008      	beq.n	3418dc5c <RCCEx_GetI3CCLKFreq+0x88>
3418dc4a:	d80d      	bhi.n	3418dc68 <RCCEx_GetI3CCLKFreq+0x94>
3418dc4c:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3418dc50:	4298      	cmp	r0, r3
3418dc52:	d026      	beq.n	3418dca2 <RCCEx_GetI3CCLKFreq+0xce>
3418dc54:	f503 437c 	add.w	r3, r3, #64512	@ 0xfc00
3418dc58:	4298      	cmp	r0, r3
3418dc5a:	d1d3      	bne.n	3418dc04 <RCCEx_GetI3CCLKFreq+0x30>
      if (LL_RCC_MSI_IsReady() != 0U)
3418dc5c:	f7fd fb62 	bl	3418b324 <LL_RCC_MSI_IsReady>
3418dc60:	2800      	cmp	r0, #0
3418dc62:	d0cf      	beq.n	3418dc04 <RCCEx_GetI3CCLKFreq+0x30>
        i3c_frequency = MSI_VALUE;
3418dc64:	481e      	ldr	r0, [pc, #120]	@ (3418dce0 <RCCEx_GetI3CCLKFreq+0x10c>)
  return i3c_frequency;
3418dc66:	e7ce      	b.n	3418dc06 <RCCEx_GetI3CCLKFreq+0x32>
  switch (LL_RCC_GetI3CClockSource(I3CxSource))
3418dc68:	4b1e      	ldr	r3, [pc, #120]	@ (3418dce4 <RCCEx_GetI3CCLKFreq+0x110>)
3418dc6a:	f420 6080 	bic.w	r0, r0, #1024	@ 0x400
3418dc6e:	4298      	cmp	r0, r3
3418dc70:	d1c8      	bne.n	3418dc04 <RCCEx_GetI3CCLKFreq+0x30>
      if (LL_RCC_HSI_IsReady() != 0U)
3418dc72:	f7fd fb4f 	bl	3418b314 <LL_RCC_HSI_IsReady>
3418dc76:	2800      	cmp	r0, #0
3418dc78:	d0c4      	beq.n	3418dc04 <RCCEx_GetI3CCLKFreq+0x30>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3418dc7a:	4b17      	ldr	r3, [pc, #92]	@ (3418dcd8 <RCCEx_GetI3CCLKFreq+0x104>)
        i3c_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3418dc7c:	481a      	ldr	r0, [pc, #104]	@ (3418dce8 <RCCEx_GetI3CCLKFreq+0x114>)
3418dc7e:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3418dc80:	f3c3 13c1 	ubfx	r3, r3, #7, #2
3418dc84:	e007      	b.n	3418dc96 <RCCEx_GetI3CCLKFreq+0xc2>
      i3c_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3418dc86:	f7fc ff45 	bl	3418ab14 <HAL_RCC_GetSysClockFreq>
3418dc8a:	f7fd fbd5 	bl	3418b438 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE1));
3418dc8e:	4b12      	ldr	r3, [pc, #72]	@ (3418dcd8 <RCCEx_GetI3CCLKFreq+0x104>)
3418dc90:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418dc92:	f003 0307 	and.w	r3, r3, #7
        i3c_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3418dc96:	40d8      	lsrs	r0, r3
3418dc98:	e7b5      	b.n	3418dc06 <RCCEx_GetI3CCLKFreq+0x32>
}
3418dc9a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      i3c_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3418dc9e:	f7ff b9a3 	b.w	3418cfe8 <RCCEx_GetCLKPCLKFreq.constprop.0>
      if (LL_RCC_IC15_IsEnabled() != 0U)
3418dca2:	f7fd fbb7 	bl	3418b414 <LL_RCC_IC15_IsEnabled>
3418dca6:	2800      	cmp	r0, #0
3418dca8:	d0ac      	beq.n	3418dc04 <RCCEx_GetI3CCLKFreq+0x30>
        ic_divider = LL_RCC_IC15_GetDivider();
3418dcaa:	f7fd fbbb 	bl	3418b424 <LL_RCC_IC15_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL));
3418dcae:	4b0a      	ldr	r3, [pc, #40]	@ (3418dcd8 <RCCEx_GetI3CCLKFreq+0x104>)
3418dcb0:	4604      	mov	r4, r0
3418dcb2:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3418dcb6:	e7b8      	b.n	3418dc2a <RCCEx_GetI3CCLKFreq+0x56>
        switch (LL_RCC_IC15_GetSource())
3418dcb8:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418dcbc:	d1a2      	bne.n	3418dc04 <RCCEx_GetI3CCLKFreq+0x30>
            i3c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3418dcbe:	f7ff f953 	bl	3418cf68 <HAL_RCCEx_GetPLL4CLKFreq>
3418dcc2:	e7bc      	b.n	3418dc3e <RCCEx_GetI3CCLKFreq+0x6a>
            i3c_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3418dcc4:	f7ff f8d0 	bl	3418ce68 <HAL_RCCEx_GetPLL2CLKFreq>
3418dcc8:	e7b9      	b.n	3418dc3e <RCCEx_GetI3CCLKFreq+0x6a>
            i3c_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3418dcca:	f7ff f90d 	bl	3418cee8 <HAL_RCCEx_GetPLL3CLKFreq>
3418dcce:	e7b6      	b.n	3418dc3e <RCCEx_GetI3CCLKFreq+0x6a>
3418dcd0:	0703100c 	.word	0x0703100c
3418dcd4:	0702100c 	.word	0x0702100c
3418dcd8:	56028000 	.word	0x56028000
3418dcdc:	0704140c 	.word	0x0704140c
3418dce0:	003d0900 	.word	0x003d0900
3418dce4:	0705100c 	.word	0x0705100c
3418dce8:	03d09000 	.word	0x03d09000

3418dcec <RCCEx_GetSDMMCCLKFreq>:
{
3418dcec:	b510      	push	{r4, lr}
  return LL_RCC_GetClockSource(Periph);
3418dcee:	f7fd fb3b 	bl	3418b368 <LL_RCC_GetClockSource>
  switch (LL_RCC_GetSDMMCClockSource(SDMMCxSource))
3418dcf2:	4b2d      	ldr	r3, [pc, #180]	@ (3418dda8 <RCCEx_GetSDMMCCLKFreq+0xbc>)
3418dcf4:	4298      	cmp	r0, r3
3418dcf6:	d01d      	beq.n	3418dd34 <RCCEx_GetSDMMCCLKFreq+0x48>
3418dcf8:	d813      	bhi.n	3418dd22 <RCCEx_GetSDMMCCLKFreq+0x36>
3418dcfa:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3418dcfe:	4298      	cmp	r0, r3
3418dd00:	d00b      	beq.n	3418dd1a <RCCEx_GetSDMMCCLKFreq+0x2e>
3418dd02:	d807      	bhi.n	3418dd14 <RCCEx_GetSDMMCCLKFreq+0x28>
3418dd04:	f420 6080 	bic.w	r0, r0, #1024	@ 0x400
3418dd08:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
3418dd0c:	4298      	cmp	r0, r3
3418dd0e:	d02a      	beq.n	3418dd66 <RCCEx_GetSDMMCCLKFreq+0x7a>
  uint32_t sdmmc_frequency = RCC_PERIPH_FREQUENCY_NO;
3418dd10:	2000      	movs	r0, #0
}
3418dd12:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetSDMMCClockSource(SDMMCxSource))
3418dd14:	4b25      	ldr	r3, [pc, #148]	@ (3418ddac <RCCEx_GetSDMMCCLKFreq+0xc0>)
3418dd16:	4298      	cmp	r0, r3
3418dd18:	d1fa      	bne.n	3418dd10 <RCCEx_GetSDMMCCLKFreq+0x24>
}
3418dd1a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      sdmmc_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3418dd1e:	f7ff b963 	b.w	3418cfe8 <RCCEx_GetCLKPCLKFreq.constprop.0>
  switch (LL_RCC_GetSDMMCClockSource(SDMMCxSource))
3418dd22:	4b23      	ldr	r3, [pc, #140]	@ (3418ddb0 <RCCEx_GetSDMMCCLKFreq+0xc4>)
3418dd24:	f420 6280 	bic.w	r2, r0, #1024	@ 0x400
3418dd28:	429a      	cmp	r2, r3
3418dd2a:	d022      	beq.n	3418dd72 <RCCEx_GetSDMMCCLKFreq+0x86>
3418dd2c:	f5a3 437c 	sub.w	r3, r3, #64512	@ 0xfc00
3418dd30:	4298      	cmp	r0, r3
3418dd32:	d1ed      	bne.n	3418dd10 <RCCEx_GetSDMMCCLKFreq+0x24>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC4EN) == RCC_DIVENR_IC4EN) ? 1UL : 0UL);
3418dd34:	4b1f      	ldr	r3, [pc, #124]	@ (3418ddb4 <RCCEx_GetSDMMCCLKFreq+0xc8>)
3418dd36:	f8d3 0240 	ldr.w	r0, [r3, #576]	@ 0x240
3418dd3a:	f010 0008 	ands.w	r0, r0, #8
3418dd3e:	d0e8      	beq.n	3418dd12 <RCCEx_GetSDMMCCLKFreq+0x26>
  return ((READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4INT) >> RCC_IC4CFGR_IC4INT_Pos) + 1UL);
3418dd40:	f8d3 00d0 	ldr.w	r0, [r3, #208]	@ 0xd0
  return (uint32_t)(READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL));
3418dd44:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
  return ((READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4INT) >> RCC_IC4CFGR_IC4INT_Pos) + 1UL);
3418dd48:	f3c0 4007 	ubfx	r0, r0, #16, #8
3418dd4c:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL));
3418dd4e:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC5_GetSource())
3418dd52:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418dd56:	d023      	beq.n	3418dda0 <RCCEx_GetSDMMCCLKFreq+0xb4>
3418dd58:	d819      	bhi.n	3418dd8e <RCCEx_GetSDMMCCLKFreq+0xa2>
3418dd5a:	b9f3      	cbnz	r3, 3418dd9a <RCCEx_GetSDMMCCLKFreq+0xae>
            sdmmc_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3418dd5c:	f7ff f844 	bl	3418cde8 <HAL_RCCEx_GetPLL1CLKFreq>
            sdmmc_frequency = sdmmc_frequency / ic_divider;
3418dd60:	fbb0 f0f4 	udiv	r0, r0, r4
  return sdmmc_frequency;
3418dd64:	e7d5      	b.n	3418dd12 <RCCEx_GetSDMMCCLKFreq+0x26>
      sdmmc_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
3418dd66:	f7fc fed5 	bl	3418ab14 <HAL_RCC_GetSysClockFreq>
}
3418dd6a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      sdmmc_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
3418dd6e:	f7fd bb63 	b.w	3418b438 <RCCEx_GetHCLKFreq>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC5EN) == RCC_DIVENR_IC5EN) ? 1UL : 0UL);
3418dd72:	4b10      	ldr	r3, [pc, #64]	@ (3418ddb4 <RCCEx_GetSDMMCCLKFreq+0xc8>)
3418dd74:	f8d3 0240 	ldr.w	r0, [r3, #576]	@ 0x240
3418dd78:	f010 0010 	ands.w	r0, r0, #16
3418dd7c:	d0c9      	beq.n	3418dd12 <RCCEx_GetSDMMCCLKFreq+0x26>
  return ((READ_BIT(RCC->IC5CFGR, RCC_IC5CFGR_IC5INT) >> RCC_IC5CFGR_IC5INT_Pos) + 1UL);
3418dd7e:	f8d3 00d4 	ldr.w	r0, [r3, #212]	@ 0xd4
  return (uint32_t)(READ_BIT(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL));
3418dd82:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
  return ((READ_BIT(RCC->IC5CFGR, RCC_IC5CFGR_IC5INT) >> RCC_IC5CFGR_IC5INT_Pos) + 1UL);
3418dd86:	f3c0 4007 	ubfx	r0, r0, #16, #8
3418dd8a:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL));
3418dd8c:	e7df      	b.n	3418dd4e <RCCEx_GetSDMMCCLKFreq+0x62>
        switch (LL_RCC_IC5_GetSource())
3418dd8e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418dd92:	d1bd      	bne.n	3418dd10 <RCCEx_GetSDMMCCLKFreq+0x24>
            sdmmc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3418dd94:	f7ff f8e8 	bl	3418cf68 <HAL_RCCEx_GetPLL4CLKFreq>
3418dd98:	e7e2      	b.n	3418dd60 <RCCEx_GetSDMMCCLKFreq+0x74>
            sdmmc_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3418dd9a:	f7ff f865 	bl	3418ce68 <HAL_RCCEx_GetPLL2CLKFreq>
3418dd9e:	e7df      	b.n	3418dd60 <RCCEx_GetSDMMCCLKFreq+0x74>
            sdmmc_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3418dda0:	f7ff f8a2 	bl	3418cee8 <HAL_RCCEx_GetPLL3CLKFreq>
3418dda4:	e7dc      	b.n	3418dd60 <RCCEx_GetSDMMCCLKFreq+0x74>
3418dda6:	bf00      	nop
3418dda8:	0302001c 	.word	0x0302001c
3418ddac:	0301041c 	.word	0x0301041c
3418ddb0:	0303001c 	.word	0x0303001c
3418ddb4:	56028000 	.word	0x56028000

3418ddb8 <RCCEx_GetI2CCLKFreq>:
{
3418ddb8:	b510      	push	{r4, lr}
  return LL_RCC_GetClockSource(Periph);
3418ddba:	f7fd fad5 	bl	3418b368 <LL_RCC_GetClockSource>
  switch (LL_RCC_GetI2CClockSource(I2CxSource))
3418ddbe:	4b50      	ldr	r3, [pc, #320]	@ (3418df00 <RCCEx_GetI2CCLKFreq+0x148>)
3418ddc0:	4298      	cmp	r0, r3
3418ddc2:	f000 8085 	beq.w	3418ded0 <RCCEx_GetI2CCLKFreq+0x118>
3418ddc6:	d84b      	bhi.n	3418de60 <RCCEx_GetI2CCLKFreq+0xa8>
3418ddc8:	f5a3 33fc 	sub.w	r3, r3, #129024	@ 0x1f800
3418ddcc:	4298      	cmp	r0, r3
3418ddce:	d01a      	beq.n	3418de06 <RCCEx_GetI2CCLKFreq+0x4e>
3418ddd0:	d81d      	bhi.n	3418de0e <RCCEx_GetI2CCLKFreq+0x56>
3418ddd2:	f5a3 437c 	sub.w	r3, r3, #64512	@ 0xfc00
3418ddd6:	4298      	cmp	r0, r3
3418ddd8:	d008      	beq.n	3418ddec <RCCEx_GetI2CCLKFreq+0x34>
3418ddda:	f420 6380 	bic.w	r3, r0, #1024	@ 0x400
3418ddde:	d80f      	bhi.n	3418de00 <RCCEx_GetI2CCLKFreq+0x48>
3418dde0:	4a48      	ldr	r2, [pc, #288]	@ (3418df04 <RCCEx_GetI2CCLKFreq+0x14c>)
3418dde2:	4293      	cmp	r3, r2
3418dde4:	d002      	beq.n	3418ddec <RCCEx_GetI2CCLKFreq+0x34>
3418dde6:	4b48      	ldr	r3, [pc, #288]	@ (3418df08 <RCCEx_GetI2CCLKFreq+0x150>)
3418dde8:	4298      	cmp	r0, r3
3418ddea:	d14a      	bne.n	3418de82 <RCCEx_GetI2CCLKFreq+0xca>
      i2c_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3418ddec:	f7fc fe92 	bl	3418ab14 <HAL_RCC_GetSysClockFreq>
3418ddf0:	f7fd fb22 	bl	3418b438 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE1));
3418ddf4:	4b45      	ldr	r3, [pc, #276]	@ (3418df0c <RCCEx_GetI2CCLKFreq+0x154>)
3418ddf6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418ddf8:	f003 0307 	and.w	r3, r3, #7
        i2c_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3418ddfc:	40d8      	lsrs	r0, r3
3418ddfe:	e041      	b.n	3418de84 <RCCEx_GetI2CCLKFreq+0xcc>
  switch (LL_RCC_GetI2CClockSource(I2CxSource))
3418de00:	4a43      	ldr	r2, [pc, #268]	@ (3418df10 <RCCEx_GetI2CCLKFreq+0x158>)
3418de02:	4293      	cmp	r3, r2
3418de04:	d13d      	bne.n	3418de82 <RCCEx_GetI2CCLKFreq+0xca>
}
3418de06:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      i2c_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3418de0a:	f7ff b8ed 	b.w	3418cfe8 <RCCEx_GetCLKPCLKFreq.constprop.0>
  switch (LL_RCC_GetI2CClockSource(I2CxSource))
3418de0e:	4b41      	ldr	r3, [pc, #260]	@ (3418df14 <RCCEx_GetI2CCLKFreq+0x15c>)
3418de10:	4298      	cmp	r0, r3
3418de12:	d008      	beq.n	3418de26 <RCCEx_GetI2CCLKFreq+0x6e>
3418de14:	d820      	bhi.n	3418de58 <RCCEx_GetI2CCLKFreq+0xa0>
3418de16:	f5a3 4378 	sub.w	r3, r3, #63488	@ 0xf800
3418de1a:	4298      	cmp	r0, r3
3418de1c:	d0f3      	beq.n	3418de06 <RCCEx_GetI2CCLKFreq+0x4e>
3418de1e:	f503 4374 	add.w	r3, r3, #62464	@ 0xf400
3418de22:	4298      	cmp	r0, r3
3418de24:	d12d      	bne.n	3418de82 <RCCEx_GetI2CCLKFreq+0xca>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC10EN) == RCC_DIVENR_IC10EN) ? 1UL : 0UL);
3418de26:	4b39      	ldr	r3, [pc, #228]	@ (3418df0c <RCCEx_GetI2CCLKFreq+0x154>)
3418de28:	f8d3 2240 	ldr.w	r2, [r3, #576]	@ 0x240
3418de2c:	0592      	lsls	r2, r2, #22
3418de2e:	d528      	bpl.n	3418de82 <RCCEx_GetI2CCLKFreq+0xca>
  return ((READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10INT) >> RCC_IC10CFGR_IC10INT_Pos) + 1UL);
3418de30:	f8d3 00e8 	ldr.w	r0, [r3, #232]	@ 0xe8
  return (uint32_t)(READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL));
3418de34:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
  return ((READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10INT) >> RCC_IC10CFGR_IC10INT_Pos) + 1UL);
3418de38:	f3c0 4007 	ubfx	r0, r0, #16, #8
3418de3c:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL));
3418de3e:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC15_GetSource())
3418de42:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418de46:	d057      	beq.n	3418def8 <RCCEx_GetI2CCLKFreq+0x140>
3418de48:	d84d      	bhi.n	3418dee6 <RCCEx_GetI2CCLKFreq+0x12e>
3418de4a:	2b00      	cmp	r3, #0
3418de4c:	d151      	bne.n	3418def2 <RCCEx_GetI2CCLKFreq+0x13a>
            i2c_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3418de4e:	f7fe ffcb 	bl	3418cde8 <HAL_RCCEx_GetPLL1CLKFreq>
            i2c_frequency = i2c_frequency / ic_divider;
3418de52:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
3418de56:	e015      	b.n	3418de84 <RCCEx_GetI2CCLKFreq+0xcc>
  switch (LL_RCC_GetI2CClockSource(I2CxSource))
3418de58:	4b2f      	ldr	r3, [pc, #188]	@ (3418df18 <RCCEx_GetI2CCLKFreq+0x160>)
3418de5a:	f420 6080 	bic.w	r0, r0, #1024	@ 0x400
3418de5e:	e7e0      	b.n	3418de22 <RCCEx_GetI2CCLKFreq+0x6a>
3418de60:	4b2e      	ldr	r3, [pc, #184]	@ (3418df1c <RCCEx_GetI2CCLKFreq+0x164>)
3418de62:	4298      	cmp	r0, r3
3418de64:	d014      	beq.n	3418de90 <RCCEx_GetI2CCLKFreq+0xd8>
3418de66:	d819      	bhi.n	3418de9c <RCCEx_GetI2CCLKFreq+0xe4>
3418de68:	f5a3 437c 	sub.w	r3, r3, #64512	@ 0xfc00
3418de6c:	4298      	cmp	r0, r3
3418de6e:	d02f      	beq.n	3418ded0 <RCCEx_GetI2CCLKFreq+0x118>
3418de70:	d809      	bhi.n	3418de86 <RCCEx_GetI2CCLKFreq+0xce>
3418de72:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
3418de76:	4298      	cmp	r0, r3
3418de78:	d02a      	beq.n	3418ded0 <RCCEx_GetI2CCLKFreq+0x118>
3418de7a:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3418de7e:	4298      	cmp	r0, r3
3418de80:	d026      	beq.n	3418ded0 <RCCEx_GetI2CCLKFreq+0x118>
  uint32_t i2c_frequency = RCC_PERIPH_FREQUENCY_NO;
3418de82:	2000      	movs	r0, #0
}
3418de84:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetI2CClockSource(I2CxSource))
3418de86:	4b26      	ldr	r3, [pc, #152]	@ (3418df20 <RCCEx_GetI2CCLKFreq+0x168>)
3418de88:	f420 6080 	bic.w	r0, r0, #1024	@ 0x400
3418de8c:	4298      	cmp	r0, r3
3418de8e:	d1f8      	bne.n	3418de82 <RCCEx_GetI2CCLKFreq+0xca>
      if (LL_RCC_MSI_IsReady() != 0U)
3418de90:	f7fd fa48 	bl	3418b324 <LL_RCC_MSI_IsReady>
3418de94:	2800      	cmp	r0, #0
3418de96:	d0f4      	beq.n	3418de82 <RCCEx_GetI2CCLKFreq+0xca>
        i2c_frequency = MSI_VALUE;
3418de98:	4822      	ldr	r0, [pc, #136]	@ (3418df24 <RCCEx_GetI2CCLKFreq+0x16c>)
  return i2c_frequency;
3418de9a:	e7f3      	b.n	3418de84 <RCCEx_GetI2CCLKFreq+0xcc>
  switch (LL_RCC_GetI2CClockSource(I2CxSource))
3418de9c:	4b22      	ldr	r3, [pc, #136]	@ (3418df28 <RCCEx_GetI2CCLKFreq+0x170>)
3418de9e:	4298      	cmp	r0, r3
3418dea0:	d008      	beq.n	3418deb4 <RCCEx_GetI2CCLKFreq+0xfc>
3418dea2:	d811      	bhi.n	3418dec8 <RCCEx_GetI2CCLKFreq+0x110>
3418dea4:	f5a3 4378 	sub.w	r3, r3, #63488	@ 0xf800
3418dea8:	4298      	cmp	r0, r3
3418deaa:	d0f1      	beq.n	3418de90 <RCCEx_GetI2CCLKFreq+0xd8>
3418deac:	f503 4374 	add.w	r3, r3, #62464	@ 0xf400
3418deb0:	4298      	cmp	r0, r3
3418deb2:	d1e6      	bne.n	3418de82 <RCCEx_GetI2CCLKFreq+0xca>
      if (LL_RCC_HSI_IsReady() != 0U)
3418deb4:	f7fd fa2e 	bl	3418b314 <LL_RCC_HSI_IsReady>
3418deb8:	2800      	cmp	r0, #0
3418deba:	d0e2      	beq.n	3418de82 <RCCEx_GetI2CCLKFreq+0xca>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3418debc:	4b13      	ldr	r3, [pc, #76]	@ (3418df0c <RCCEx_GetI2CCLKFreq+0x154>)
        i2c_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3418debe:	481b      	ldr	r0, [pc, #108]	@ (3418df2c <RCCEx_GetI2CCLKFreq+0x174>)
3418dec0:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3418dec2:	f3c3 13c1 	ubfx	r3, r3, #7, #2
3418dec6:	e799      	b.n	3418ddfc <RCCEx_GetI2CCLKFreq+0x44>
  switch (LL_RCC_GetI2CClockSource(I2CxSource))
3418dec8:	4b19      	ldr	r3, [pc, #100]	@ (3418df30 <RCCEx_GetI2CCLKFreq+0x178>)
3418deca:	f420 6080 	bic.w	r0, r0, #1024	@ 0x400
3418dece:	e7ef      	b.n	3418deb0 <RCCEx_GetI2CCLKFreq+0xf8>
      if (LL_RCC_IC15_IsEnabled() != 0U)
3418ded0:	f7fd faa0 	bl	3418b414 <LL_RCC_IC15_IsEnabled>
3418ded4:	2800      	cmp	r0, #0
3418ded6:	d0d4      	beq.n	3418de82 <RCCEx_GetI2CCLKFreq+0xca>
        ic_divider = LL_RCC_IC15_GetDivider();
3418ded8:	f7fd faa4 	bl	3418b424 <LL_RCC_IC15_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL));
3418dedc:	4b0b      	ldr	r3, [pc, #44]	@ (3418df0c <RCCEx_GetI2CCLKFreq+0x154>)
3418dede:	4604      	mov	r4, r0
3418dee0:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3418dee4:	e7ab      	b.n	3418de3e <RCCEx_GetI2CCLKFreq+0x86>
        switch (LL_RCC_IC15_GetSource())
3418dee6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418deea:	d1ca      	bne.n	3418de82 <RCCEx_GetI2CCLKFreq+0xca>
            i2c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3418deec:	f7ff f83c 	bl	3418cf68 <HAL_RCCEx_GetPLL4CLKFreq>
3418def0:	e7af      	b.n	3418de52 <RCCEx_GetI2CCLKFreq+0x9a>
            i2c_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3418def2:	f7fe ffb9 	bl	3418ce68 <HAL_RCCEx_GetPLL2CLKFreq>
3418def6:	e7ac      	b.n	3418de52 <RCCEx_GetI2CCLKFreq+0x9a>
            i2c_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3418def8:	f7fe fff6 	bl	3418cee8 <HAL_RCCEx_GetPLL3CLKFreq>
3418defc:	e7a9      	b.n	3418de52 <RCCEx_GetI2CCLKFreq+0x9a>
3418defe:	bf00      	nop
3418df00:	0703000c 	.word	0x0703000c
3418df04:	0700000c 	.word	0x0700000c
3418df08:	0700080c 	.word	0x0700080c
3418df0c:	56028000 	.word	0x56028000
3418df10:	0701000c 	.word	0x0701000c
3418df14:	0702040c 	.word	0x0702040c
3418df18:	0702080c 	.word	0x0702080c
3418df1c:	0704080c 	.word	0x0704080c
3418df20:	0704000c 	.word	0x0704000c
3418df24:	003d0900 	.word	0x003d0900
3418df28:	0705040c 	.word	0x0705040c
3418df2c:	03d09000 	.word	0x03d09000
3418df30:	0705080c 	.word	0x0705080c

3418df34 <RCCEx_GetLPTIMCLKFreq>:
{
3418df34:	b510      	push	{r4, lr}
  return LL_RCC_GetClockSource(Periph);
3418df36:	f7fd fa17 	bl	3418b368 <LL_RCC_GetClockSource>
  switch (LL_RCC_GetLPTIMClockSource(LPTIMxSource))
3418df3a:	4b63      	ldr	r3, [pc, #396]	@ (3418e0c8 <RCCEx_GetLPTIMCLKFreq+0x194>)
3418df3c:	4298      	cmp	r0, r3
3418df3e:	d03a      	beq.n	3418dfb6 <RCCEx_GetLPTIMCLKFreq+0x82>
3418df40:	d850      	bhi.n	3418dfe4 <RCCEx_GetLPTIMCLKFreq+0xb0>
3418df42:	f5a3 33fe 	sub.w	r3, r3, #130048	@ 0x1fc00
3418df46:	4298      	cmp	r0, r3
3418df48:	f000 80a7 	beq.w	3418e09a <RCCEx_GetLPTIMCLKFreq+0x166>
3418df4c:	d813      	bhi.n	3418df76 <RCCEx_GetLPTIMCLKFreq+0x42>
3418df4e:	f5a3 6340 	sub.w	r3, r3, #3072	@ 0xc00
3418df52:	4298      	cmp	r0, r3
3418df54:	f000 8097 	beq.w	3418e086 <RCCEx_GetLPTIMCLKFreq+0x152>
3418df58:	3b01      	subs	r3, #1
3418df5a:	4298      	cmp	r0, r3
3418df5c:	d909      	bls.n	3418df72 <RCCEx_GetLPTIMCLKFreq+0x3e>
3418df5e:	f203 4301 	addw	r3, r3, #1025	@ 0x401
3418df62:	4298      	cmp	r0, r3
3418df64:	f000 8099 	beq.w	3418e09a <RCCEx_GetLPTIMCLKFreq+0x166>
3418df68:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3418df6c:	4298      	cmp	r0, r3
3418df6e:	f000 8094 	beq.w	3418e09a <RCCEx_GetLPTIMCLKFreq+0x166>
  uint32_t lptim_frequency = RCC_PERIPH_FREQUENCY_NO;
3418df72:	2000      	movs	r0, #0
}
3418df74:	bd10      	pop	{r4, pc}
  switch (LL_RCC_GetLPTIMClockSource(LPTIMxSource))
3418df76:	4b55      	ldr	r3, [pc, #340]	@ (3418e0cc <RCCEx_GetLPTIMCLKFreq+0x198>)
3418df78:	4298      	cmp	r0, r3
3418df7a:	d015      	beq.n	3418dfa8 <RCCEx_GetLPTIMCLKFreq+0x74>
3418df7c:	d808      	bhi.n	3418df90 <RCCEx_GetLPTIMCLKFreq+0x5c>
3418df7e:	f420 6280 	bic.w	r2, r0, #1024	@ 0x400
3418df82:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
3418df86:	429a      	cmp	r2, r3
3418df88:	d00e      	beq.n	3418dfa8 <RCCEx_GetLPTIMCLKFreq+0x74>
3418df8a:	f5a3 4370 	sub.w	r3, r3, #61440	@ 0xf000
3418df8e:	e7ed      	b.n	3418df6c <RCCEx_GetLPTIMCLKFreq+0x38>
3418df90:	4b4f      	ldr	r3, [pc, #316]	@ (3418e0d0 <RCCEx_GetLPTIMCLKFreq+0x19c>)
3418df92:	4298      	cmp	r0, r3
3418df94:	d00f      	beq.n	3418dfb6 <RCCEx_GetLPTIMCLKFreq+0x82>
3418df96:	d80b      	bhi.n	3418dfb0 <RCCEx_GetLPTIMCLKFreq+0x7c>
3418df98:	f5a3 4374 	sub.w	r3, r3, #62464	@ 0xf400
3418df9c:	4298      	cmp	r0, r3
3418df9e:	d003      	beq.n	3418dfa8 <RCCEx_GetLPTIMCLKFreq+0x74>
3418dfa0:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3418dfa4:	4298      	cmp	r0, r3
3418dfa6:	d1e4      	bne.n	3418df72 <RCCEx_GetLPTIMCLKFreq+0x3e>
}
3418dfa8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      lptim_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3418dfac:	f7ff b81c 	b.w	3418cfe8 <RCCEx_GetCLKPCLKFreq.constprop.0>
  switch (LL_RCC_GetLPTIMClockSource(LPTIMxSource))
3418dfb0:	4b48      	ldr	r3, [pc, #288]	@ (3418e0d4 <RCCEx_GetLPTIMCLKFreq+0x1a0>)
3418dfb2:	4298      	cmp	r0, r3
3418dfb4:	d1dd      	bne.n	3418df72 <RCCEx_GetLPTIMCLKFreq+0x3e>
      if (LL_RCC_IC15_IsEnabled() != 0U)
3418dfb6:	f7fd fa2d 	bl	3418b414 <LL_RCC_IC15_IsEnabled>
3418dfba:	2800      	cmp	r0, #0
3418dfbc:	d0d9      	beq.n	3418df72 <RCCEx_GetLPTIMCLKFreq+0x3e>
        ic_divider = LL_RCC_IC15_GetDivider();
3418dfbe:	f7fd fa31 	bl	3418b424 <LL_RCC_IC15_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL));
3418dfc2:	4b45      	ldr	r3, [pc, #276]	@ (3418e0d8 <RCCEx_GetLPTIMCLKFreq+0x1a4>)
3418dfc4:	4604      	mov	r4, r0
3418dfc6:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3418dfca:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC15_GetSource())
3418dfce:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418dfd2:	d075      	beq.n	3418e0c0 <RCCEx_GetLPTIMCLKFreq+0x18c>
3418dfd4:	d86a      	bhi.n	3418e0ac <RCCEx_GetLPTIMCLKFreq+0x178>
3418dfd6:	2b00      	cmp	r3, #0
3418dfd8:	d16f      	bne.n	3418e0ba <RCCEx_GetLPTIMCLKFreq+0x186>
            lptim_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3418dfda:	f7fe ff05 	bl	3418cde8 <HAL_RCCEx_GetPLL1CLKFreq>
            lptim_frequency = lptim_frequency / ic_divider;
3418dfde:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
3418dfe2:	e7c7      	b.n	3418df74 <RCCEx_GetLPTIMCLKFreq+0x40>
  switch (LL_RCC_GetLPTIMClockSource(LPTIMxSource))
3418dfe4:	4b3d      	ldr	r3, [pc, #244]	@ (3418e0dc <RCCEx_GetLPTIMCLKFreq+0x1a8>)
3418dfe6:	4298      	cmp	r0, r3
3418dfe8:	d034      	beq.n	3418e054 <RCCEx_GetLPTIMCLKFreq+0x120>
3418dfea:	d824      	bhi.n	3418e036 <RCCEx_GetLPTIMCLKFreq+0x102>
3418dfec:	f5a3 437c 	sub.w	r3, r3, #64512	@ 0xfc00
3418dff0:	4298      	cmp	r0, r3
3418dff2:	d00f      	beq.n	3418e014 <RCCEx_GetLPTIMCLKFreq+0xe0>
3418dff4:	d815      	bhi.n	3418e022 <RCCEx_GetLPTIMCLKFreq+0xee>
3418dff6:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
3418dffa:	4298      	cmp	r0, r3
3418dffc:	d00a      	beq.n	3418e014 <RCCEx_GetLPTIMCLKFreq+0xe0>
3418dffe:	d806      	bhi.n	3418e00e <RCCEx_GetLPTIMCLKFreq+0xda>
3418e000:	f5a3 4374 	sub.w	r3, r3, #62464	@ 0xf400
3418e004:	4298      	cmp	r0, r3
3418e006:	d0d6      	beq.n	3418dfb6 <RCCEx_GetLPTIMCLKFreq+0x82>
3418e008:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
3418e00c:	e7d1      	b.n	3418dfb2 <RCCEx_GetLPTIMCLKFreq+0x7e>
3418e00e:	4b34      	ldr	r3, [pc, #208]	@ (3418e0e0 <RCCEx_GetLPTIMCLKFreq+0x1ac>)
3418e010:	4298      	cmp	r0, r3
3418e012:	d1ae      	bne.n	3418df72 <RCCEx_GetLPTIMCLKFreq+0x3e>
      if (LL_RCC_LSE_IsReady() != 0U)
3418e014:	f7fd f98e 	bl	3418b334 <LL_RCC_LSE_IsReady>
3418e018:	3800      	subs	r0, #0
3418e01a:	bf18      	it	ne
3418e01c:	2001      	movne	r0, #1
3418e01e:	03c0      	lsls	r0, r0, #15
3418e020:	e7a8      	b.n	3418df74 <RCCEx_GetLPTIMCLKFreq+0x40>
  switch (LL_RCC_GetLPTIMClockSource(LPTIMxSource))
3418e022:	4b30      	ldr	r3, [pc, #192]	@ (3418e0e4 <RCCEx_GetLPTIMCLKFreq+0x1b0>)
3418e024:	4298      	cmp	r0, r3
3418e026:	d0f5      	beq.n	3418e014 <RCCEx_GetLPTIMCLKFreq+0xe0>
3418e028:	f503 4370 	add.w	r3, r3, #61440	@ 0xf000
3418e02c:	4298      	cmp	r0, r3
3418e02e:	d011      	beq.n	3418e054 <RCCEx_GetLPTIMCLKFreq+0x120>
3418e030:	f5a3 4374 	sub.w	r3, r3, #62464	@ 0xf400
3418e034:	e7ec      	b.n	3418e010 <RCCEx_GetLPTIMCLKFreq+0xdc>
3418e036:	4b2c      	ldr	r3, [pc, #176]	@ (3418e0e8 <RCCEx_GetLPTIMCLKFreq+0x1b4>)
3418e038:	4298      	cmp	r0, r3
3418e03a:	d015      	beq.n	3418e068 <RCCEx_GetLPTIMCLKFreq+0x134>
3418e03c:	d81b      	bhi.n	3418e076 <RCCEx_GetLPTIMCLKFreq+0x142>
3418e03e:	f5a3 4374 	sub.w	r3, r3, #62464	@ 0xf400
3418e042:	4298      	cmp	r0, r3
3418e044:	d006      	beq.n	3418e054 <RCCEx_GetLPTIMCLKFreq+0x120>
3418e046:	d80c      	bhi.n	3418e062 <RCCEx_GetLPTIMCLKFreq+0x12e>
3418e048:	f420 6080 	bic.w	r0, r0, #1024	@ 0x400
3418e04c:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
3418e050:	4298      	cmp	r0, r3
3418e052:	d18e      	bne.n	3418df72 <RCCEx_GetLPTIMCLKFreq+0x3e>
  return ((READ_BIT(RCC->SR, RCC_SR_LSIRDY) != 0UL) ? 1UL : 0UL);
3418e054:	4b20      	ldr	r3, [pc, #128]	@ (3418e0d8 <RCCEx_GetLPTIMCLKFreq+0x1a4>)
3418e056:	685b      	ldr	r3, [r3, #4]
      if (LL_RCC_LSI_IsReady() != 0U)
3418e058:	07db      	lsls	r3, r3, #31
3418e05a:	d58a      	bpl.n	3418df72 <RCCEx_GetLPTIMCLKFreq+0x3e>
        lptim_frequency = LSI_VALUE;
3418e05c:	f44f 40fa 	mov.w	r0, #32000	@ 0x7d00
  return lptim_frequency;
3418e060:	e788      	b.n	3418df74 <RCCEx_GetLPTIMCLKFreq+0x40>
  switch (LL_RCC_GetLPTIMClockSource(LPTIMxSource))
3418e062:	4b22      	ldr	r3, [pc, #136]	@ (3418e0ec <RCCEx_GetLPTIMCLKFreq+0x1b8>)
3418e064:	4298      	cmp	r0, r3
3418e066:	d184      	bne.n	3418df72 <RCCEx_GetLPTIMCLKFreq+0x3e>
      lptim_frequency = HAL_RCC_GetSysClockFreq() / (1UL << LL_RCC_GetTIMPrescaler());
3418e068:	f7fc fd54 	bl	3418ab14 <HAL_RCC_GetSysClockFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_TIMPRE) >> RCC_CFGR2_TIMPRE_Pos);
3418e06c:	4b1a      	ldr	r3, [pc, #104]	@ (3418e0d8 <RCCEx_GetLPTIMCLKFreq+0x1a4>)
3418e06e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418e070:	f3c3 6301 	ubfx	r3, r3, #24, #2
3418e074:	e00f      	b.n	3418e096 <RCCEx_GetLPTIMCLKFreq+0x162>
  switch (LL_RCC_GetLPTIMClockSource(LPTIMxSource))
3418e076:	4b1e      	ldr	r3, [pc, #120]	@ (3418e0f0 <RCCEx_GetLPTIMCLKFreq+0x1bc>)
3418e078:	f420 6280 	bic.w	r2, r0, #1024	@ 0x400
3418e07c:	429a      	cmp	r2, r3
3418e07e:	d0f3      	beq.n	3418e068 <RCCEx_GetLPTIMCLKFreq+0x134>
3418e080:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
3418e084:	e7ee      	b.n	3418e064 <RCCEx_GetLPTIMCLKFreq+0x130>
      lptim_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3418e086:	f7fc fd45 	bl	3418ab14 <HAL_RCC_GetSysClockFreq>
3418e08a:	f7fd f9d5 	bl	3418b438 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE1));
3418e08e:	4b12      	ldr	r3, [pc, #72]	@ (3418e0d8 <RCCEx_GetLPTIMCLKFreq+0x1a4>)
3418e090:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418e092:	f003 0307 	and.w	r3, r3, #7
  return LL_RCC_CALC_PCLK4_FREQ(HCLK_Frequency, LL_RCC_GetAPB4Prescaler());
3418e096:	40d8      	lsrs	r0, r3
      break;
3418e098:	e76c      	b.n	3418df74 <RCCEx_GetLPTIMCLKFreq+0x40>
      lptim_frequency = RCCEx_GetPCLK4Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3418e09a:	f7fc fd3b 	bl	3418ab14 <HAL_RCC_GetSysClockFreq>
3418e09e:	f7fd f9cb 	bl	3418b438 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE4));
3418e0a2:	4b0d      	ldr	r3, [pc, #52]	@ (3418e0d8 <RCCEx_GetLPTIMCLKFreq+0x1a4>)
3418e0a4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  return LL_RCC_CALC_PCLK4_FREQ(HCLK_Frequency, LL_RCC_GetAPB4Prescaler());
3418e0a6:	f3c3 3302 	ubfx	r3, r3, #12, #3
3418e0aa:	e7f4      	b.n	3418e096 <RCCEx_GetLPTIMCLKFreq+0x162>
        switch (LL_RCC_IC15_GetSource())
3418e0ac:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418e0b0:	f47f af5f 	bne.w	3418df72 <RCCEx_GetLPTIMCLKFreq+0x3e>
            lptim_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3418e0b4:	f7fe ff58 	bl	3418cf68 <HAL_RCCEx_GetPLL4CLKFreq>
3418e0b8:	e791      	b.n	3418dfde <RCCEx_GetLPTIMCLKFreq+0xaa>
            lptim_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3418e0ba:	f7fe fed5 	bl	3418ce68 <HAL_RCCEx_GetPLL2CLKFreq>
3418e0be:	e78e      	b.n	3418dfde <RCCEx_GetLPTIMCLKFreq+0xaa>
            lptim_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3418e0c0:	f7fe ff12 	bl	3418cee8 <HAL_RCCEx_GetPLL3CLKFreq>
3418e0c4:	e78b      	b.n	3418dfde <RCCEx_GetLPTIMCLKFreq+0xaa>
3418e0c6:	bf00      	nop
3418e0c8:	0702102c 	.word	0x0702102c
3418e0cc:	0701102c 	.word	0x0701102c
3418e0d0:	0702082c 	.word	0x0702082c
3418e0d4:	07020c2c 	.word	0x07020c2c
3418e0d8:	56028000 	.word	0x56028000
3418e0dc:	07040c2c 	.word	0x07040c2c
3418e0e0:	07030c2c 	.word	0x07030c2c
3418e0e4:	0703182c 	.word	0x0703182c
3418e0e8:	07050c2c 	.word	0x07050c2c
3418e0ec:	0705082c 	.word	0x0705082c
3418e0f0:	0705102c 	.word	0x0705102c

3418e0f4 <HAL_RCCEx_GetPeriphCLKFreq>:
{
3418e0f4:	b538      	push	{r3, r4, r5, lr}
  switch (PeriphClk)
3418e0f6:	f100 4360 	add.w	r3, r0, #3758096384	@ 0xe0000000
3418e0fa:	430b      	orrs	r3, r1
3418e0fc:	f000 8447 	beq.w	3418e98e <HAL_RCCEx_GetPeriphCLKFreq+0x89a>
3418e100:	4bbf      	ldr	r3, [pc, #764]	@ (3418e400 <HAL_RCCEx_GetPeriphCLKFreq+0x30c>)
3418e102:	4298      	cmp	r0, r3
3418e104:	f171 0300 	sbcs.w	r3, r1, #0
3418e108:	f080 80e6 	bcs.w	3418e2d8 <HAL_RCCEx_GetPeriphCLKFreq+0x1e4>
3418e10c:	f5a0 3380 	sub.w	r3, r0, #65536	@ 0x10000
3418e110:	430b      	orrs	r3, r1
3418e112:	f000 835b 	beq.w	3418e7cc <HAL_RCCEx_GetPeriphCLKFreq+0x6d8>
3418e116:	f1b0 1f01 	cmp.w	r0, #65537	@ 0x10001
3418e11a:	f171 0300 	sbcs.w	r3, r1, #0
3418e11e:	d26a      	bcs.n	3418e1f6 <HAL_RCCEx_GetPeriphCLKFreq+0x102>
3418e120:	f5a0 7300 	sub.w	r3, r0, #512	@ 0x200
3418e124:	430b      	orrs	r3, r1
3418e126:	f000 82b9 	beq.w	3418e69c <HAL_RCCEx_GetPeriphCLKFreq+0x5a8>
3418e12a:	f240 2301 	movw	r3, #513	@ 0x201
3418e12e:	4298      	cmp	r0, r3
3418e130:	f171 0300 	sbcs.w	r3, r1, #0
3418e134:	d224      	bcs.n	3418e180 <HAL_RCCEx_GetPeriphCLKFreq+0x8c>
3418e136:	2809      	cmp	r0, #9
3418e138:	f171 0300 	sbcs.w	r3, r1, #0
3418e13c:	d215      	bcs.n	3418e16a <HAL_RCCEx_GetPeriphCLKFreq+0x76>
3418e13e:	ea50 0301 	orrs.w	r3, r0, r1
3418e142:	d01b      	beq.n	3418e17c <HAL_RCCEx_GetPeriphCLKFreq+0x88>
3418e144:	3801      	subs	r0, #1
3418e146:	f141 31ff 	adc.w	r1, r1, #4294967295
3418e14a:	2808      	cmp	r0, #8
3418e14c:	f171 0100 	sbcs.w	r1, r1, #0
3418e150:	d214      	bcs.n	3418e17c <HAL_RCCEx_GetPeriphCLKFreq+0x88>
3418e152:	2807      	cmp	r0, #7
3418e154:	d812      	bhi.n	3418e17c <HAL_RCCEx_GetPeriphCLKFreq+0x88>
3418e156:	e8df f010 	tbh	[pc, r0, lsl #1]
3418e15a:	01a6      	.short	0x01a6
3418e15c:	0011020f 	.word	0x0011020f
3418e160:	00110285 	.word	0x00110285
3418e164:	00110011 	.word	0x00110011
3418e168:	0235      	.short	0x0235
3418e16a:	f1a0 0310 	sub.w	r3, r0, #16
3418e16e:	430b      	orrs	r3, r1
3418e170:	f000 8242 	beq.w	3418e5f8 <HAL_RCCEx_GetPeriphCLKFreq+0x504>
3418e174:	3820      	subs	r0, #32
3418e176:	4308      	orrs	r0, r1
3418e178:	f000 8268 	beq.w	3418e64c <HAL_RCCEx_GetPeriphCLKFreq+0x558>
  uint32_t adf_frequency = RCC_PERIPH_FREQUENCY_NO;
3418e17c:	2000      	movs	r0, #0
3418e17e:	e219      	b.n	3418e5b4 <HAL_RCCEx_GetPeriphCLKFreq+0x4c0>
  switch (PeriphClk)
3418e180:	f5a0 5300 	sub.w	r3, r0, #8192	@ 0x2000
3418e184:	430b      	orrs	r3, r1
3418e186:	f000 831d 	beq.w	3418e7c4 <HAL_RCCEx_GetPeriphCLKFreq+0x6d0>
3418e18a:	f242 0301 	movw	r3, #8193	@ 0x2001
3418e18e:	4298      	cmp	r0, r3
3418e190:	f171 0300 	sbcs.w	r3, r1, #0
3418e194:	d224      	bcs.n	3418e1e0 <HAL_RCCEx_GetPeriphCLKFreq+0xec>
3418e196:	f5a0 6300 	sub.w	r3, r0, #2048	@ 0x800
3418e19a:	430b      	orrs	r3, r1
3418e19c:	f000 82df 	beq.w	3418e75e <HAL_RCCEx_GetPeriphCLKFreq+0x66a>
3418e1a0:	f5a0 5380 	sub.w	r3, r0, #4096	@ 0x1000
3418e1a4:	430b      	orrs	r3, r1
3418e1a6:	f000 8308 	beq.w	3418e7ba <HAL_RCCEx_GetPeriphCLKFreq+0x6c6>
3418e1aa:	f5a0 6080 	sub.w	r0, r0, #1024	@ 0x400
3418e1ae:	4308      	orrs	r0, r1
3418e1b0:	d1e4      	bne.n	3418e17c <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return (uint32_t)(READ_BIT(RCC->CCIPR3, RCC_CCIPR3_FDCANSEL));
3418e1b2:	4d94      	ldr	r5, [pc, #592]	@ (3418e404 <HAL_RCCEx_GetPeriphCLKFreq+0x310>)
3418e1b4:	f8d5 314c 	ldr.w	r3, [r5, #332]	@ 0x14c
3418e1b8:	f003 0303 	and.w	r3, r3, #3
  switch (LL_RCC_GetFDCANClockSource(FDCANxSource))
3418e1bc:	2b02      	cmp	r3, #2
3418e1be:	f000 82c1 	beq.w	3418e744 <HAL_RCCEx_GetPeriphCLKFreq+0x650>
3418e1c2:	2b03      	cmp	r3, #3
3418e1c4:	f000 8256 	beq.w	3418e674 <HAL_RCCEx_GetPeriphCLKFreq+0x580>
3418e1c8:	2b01      	cmp	r3, #1
3418e1ca:	f000 824b 	beq.w	3418e664 <HAL_RCCEx_GetPeriphCLKFreq+0x570>
      fdcan_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3418e1ce:	f7fc fca1 	bl	3418ab14 <HAL_RCC_GetSysClockFreq>
3418e1d2:	f7fd f931 	bl	3418b438 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE1));
3418e1d6:	6a6b      	ldr	r3, [r5, #36]	@ 0x24
3418e1d8:	f003 0307 	and.w	r3, r3, #7
        pssi_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3418e1dc:	40d8      	lsrs	r0, r3
3418e1de:	e1e9      	b.n	3418e5b4 <HAL_RCCEx_GetPeriphCLKFreq+0x4c0>
  switch (PeriphClk)
3418e1e0:	f5a0 4380 	sub.w	r3, r0, #16384	@ 0x4000
3418e1e4:	430b      	orrs	r3, r1
3418e1e6:	f000 82ef 	beq.w	3418e7c8 <HAL_RCCEx_GetPeriphCLKFreq+0x6d4>
3418e1ea:	f5a0 4000 	sub.w	r0, r0, #32768	@ 0x8000
3418e1ee:	4308      	orrs	r0, r1
3418e1f0:	d1c4      	bne.n	3418e17c <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetI2CCLKFreq(LL_RCC_I2C4_CLKSOURCE);
3418e1f2:	4885      	ldr	r0, [pc, #532]	@ (3418e408 <HAL_RCCEx_GetPeriphCLKFreq+0x314>)
3418e1f4:	e2e2      	b.n	3418e7bc <HAL_RCCEx_GetPeriphCLKFreq+0x6c8>
  switch (PeriphClk)
3418e1f6:	f5a0 0300 	sub.w	r3, r0, #8388608	@ 0x800000
3418e1fa:	430b      	orrs	r3, r1
3418e1fc:	f000 82f6 	beq.w	3418e7ec <HAL_RCCEx_GetPeriphCLKFreq+0x6f8>
3418e200:	4b82      	ldr	r3, [pc, #520]	@ (3418e40c <HAL_RCCEx_GetPeriphCLKFreq+0x318>)
3418e202:	4298      	cmp	r0, r3
3418e204:	f171 0300 	sbcs.w	r3, r1, #0
3418e208:	d224      	bcs.n	3418e254 <HAL_RCCEx_GetPeriphCLKFreq+0x160>
3418e20a:	f5a0 1380 	sub.w	r3, r0, #1048576	@ 0x100000
3418e20e:	430b      	orrs	r3, r1
3418e210:	f000 82e8 	beq.w	3418e7e4 <HAL_RCCEx_GetPeriphCLKFreq+0x6f0>
3418e214:	4b7e      	ldr	r3, [pc, #504]	@ (3418e410 <HAL_RCCEx_GetPeriphCLKFreq+0x31c>)
3418e216:	4298      	cmp	r0, r3
3418e218:	f171 0300 	sbcs.w	r3, r1, #0
3418e21c:	d20f      	bcs.n	3418e23e <HAL_RCCEx_GetPeriphCLKFreq+0x14a>
3418e21e:	f5a0 2380 	sub.w	r3, r0, #262144	@ 0x40000
3418e222:	430b      	orrs	r3, r1
3418e224:	f000 82d7 	beq.w	3418e7d6 <HAL_RCCEx_GetPeriphCLKFreq+0x6e2>
3418e228:	f5a0 2300 	sub.w	r3, r0, #524288	@ 0x80000
3418e22c:	430b      	orrs	r3, r1
3418e22e:	f000 82d7 	beq.w	3418e7e0 <HAL_RCCEx_GetPeriphCLKFreq+0x6ec>
3418e232:	f5a0 3000 	sub.w	r0, r0, #131072	@ 0x20000
3418e236:	4308      	orrs	r0, r1
3418e238:	d1a0      	bne.n	3418e17c <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetI3CCLKFreq(LL_RCC_I3C2_CLKSOURCE);
3418e23a:	4876      	ldr	r0, [pc, #472]	@ (3418e414 <HAL_RCCEx_GetPeriphCLKFreq+0x320>)
3418e23c:	e2c7      	b.n	3418e7ce <HAL_RCCEx_GetPeriphCLKFreq+0x6da>
  switch (PeriphClk)
3418e23e:	f5a0 1300 	sub.w	r3, r0, #2097152	@ 0x200000
3418e242:	430b      	orrs	r3, r1
3418e244:	f000 82d0 	beq.w	3418e7e8 <HAL_RCCEx_GetPeriphCLKFreq+0x6f4>
3418e248:	f5a0 0080 	sub.w	r0, r0, #4194304	@ 0x400000
3418e24c:	4308      	orrs	r0, r1
3418e24e:	d195      	bne.n	3418e17c <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM5_CLKSOURCE);
3418e250:	4871      	ldr	r0, [pc, #452]	@ (3418e418 <HAL_RCCEx_GetPeriphCLKFreq+0x324>)
3418e252:	e2c1      	b.n	3418e7d8 <HAL_RCCEx_GetPeriphCLKFreq+0x6e4>
  switch (PeriphClk)
3418e254:	f100 437c 	add.w	r3, r0, #4227858432	@ 0xfc000000
3418e258:	430b      	orrs	r3, r1
3418e25a:	f000 834d 	beq.w	3418e8f8 <HAL_RCCEx_GetPeriphCLKFreq+0x804>
3418e25e:	4b6f      	ldr	r3, [pc, #444]	@ (3418e41c <HAL_RCCEx_GetPeriphCLKFreq+0x328>)
3418e260:	4298      	cmp	r0, r3
3418e262:	f171 0300 	sbcs.w	r3, r1, #0
3418e266:	d228      	bcs.n	3418e2ba <HAL_RCCEx_GetPeriphCLKFreq+0x1c6>
3418e268:	f100 437f 	add.w	r3, r0, #4278190080	@ 0xff000000
3418e26c:	430b      	orrs	r3, r1
3418e26e:	f000 8302 	beq.w	3418e876 <HAL_RCCEx_GetPeriphCLKFreq+0x782>
3418e272:	f100 407e 	add.w	r0, r0, #4261412864	@ 0xfe000000
3418e276:	4308      	orrs	r0, r1
3418e278:	d180      	bne.n	3418e17c <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return (uint32_t)(READ_BIT(RCC->CCIPR5, RCC_CCIPR5_MDF1SEL));
3418e27a:	4d62      	ldr	r5, [pc, #392]	@ (3418e404 <HAL_RCCEx_GetPeriphCLKFreq+0x310>)
3418e27c:	f8d5 3154 	ldr.w	r3, [r5, #340]	@ 0x154
3418e280:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
  switch (LL_RCC_GetMDFClockSource(MDFxSource))
3418e284:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
3418e288:	f000 8195 	beq.w	3418e5b6 <HAL_RCCEx_GetPeriphCLKFreq+0x4c2>
3418e28c:	f200 8319 	bhi.w	3418e8c2 <HAL_RCCEx_GetPeriphCLKFreq+0x7ce>
3418e290:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
3418e294:	f000 831f 	beq.w	3418e8d6 <HAL_RCCEx_GetPeriphCLKFreq+0x7e2>
3418e298:	f240 81e1 	bls.w	3418e65e <HAL_RCCEx_GetPeriphCLKFreq+0x56a>
3418e29c:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
3418e2a0:	f47f af6c 	bne.w	3418e17c <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      if (LL_RCC_IC8_IsEnabled() != 0U)
3418e2a4:	f7fd f880 	bl	3418b3a8 <LL_RCC_IC8_IsEnabled>
3418e2a8:	2800      	cmp	r0, #0
3418e2aa:	f43f af67 	beq.w	3418e17c <HAL_RCCEx_GetPeriphCLKFreq+0x88>
        ic_divider = LL_RCC_IC8_GetDivider();
3418e2ae:	f7fd f883 	bl	3418b3b8 <LL_RCC_IC8_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL));
3418e2b2:	f8d5 30e0 	ldr.w	r3, [r5, #224]	@ 0xe0
3418e2b6:	4604      	mov	r4, r0
3418e2b8:	e191      	b.n	3418e5de <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
  switch (PeriphClk)
3418e2ba:	f100 4378 	add.w	r3, r0, #4160749568	@ 0xf8000000
3418e2be:	430b      	orrs	r3, r1
3418e2c0:	f000 8344 	beq.w	3418e94c <HAL_RCCEx_GetPeriphCLKFreq+0x858>
3418e2c4:	f100 4070 	add.w	r0, r0, #4026531840	@ 0xf0000000
3418e2c8:	4308      	orrs	r0, r1
3418e2ca:	f47f af57 	bne.w	3418e17c <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetSAICLKFreq(LL_RCC_SAI1_CLKSOURCE);
3418e2ce:	4854      	ldr	r0, [pc, #336]	@ (3418e420 <HAL_RCCEx_GetPeriphCLKFreq+0x32c>)
}
3418e2d0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetSAICLKFreq(LL_RCC_SAI2_CLKSOURCE);
3418e2d4:	f7ff bbd6 	b.w	3418da84 <RCCEx_GetSAICLKFreq>
  switch (PeriphClk)
3418e2d8:	2300      	movs	r3, #0
3418e2da:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
3418e2de:	4291      	cmp	r1, r2
3418e2e0:	bf08      	it	eq
3418e2e2:	4298      	cmpeq	r0, r3
3418e2e4:	f000 836f 	beq.w	3418e9c6 <HAL_RCCEx_GetPeriphCLKFreq+0x8d2>
3418e2e8:	4283      	cmp	r3, r0
3418e2ea:	418a      	sbcs	r2, r1
3418e2ec:	d35f      	bcc.n	3418e3ae <HAL_RCCEx_GetPeriphCLKFreq+0x2ba>
3418e2ee:	2210      	movs	r2, #16
3418e2f0:	4291      	cmp	r1, r2
3418e2f2:	bf08      	it	eq
3418e2f4:	4298      	cmpeq	r0, r3
3418e2f6:	f000 8359 	beq.w	3418e9ac <HAL_RCCEx_GetPeriphCLKFreq+0x8b8>
3418e2fa:	4283      	cmp	r3, r0
3418e2fc:	418a      	sbcs	r2, r1
3418e2fe:	d329      	bcc.n	3418e354 <HAL_RCCEx_GetPeriphCLKFreq+0x260>
3418e300:	2202      	movs	r2, #2
3418e302:	4291      	cmp	r1, r2
3418e304:	bf08      	it	eq
3418e306:	4298      	cmpeq	r0, r3
3418e308:	f000 8349 	beq.w	3418e99e <HAL_RCCEx_GetPeriphCLKFreq+0x8aa>
3418e30c:	4283      	cmp	r3, r0
3418e30e:	418a      	sbcs	r2, r1
3418e310:	d314      	bcc.n	3418e33c <HAL_RCCEx_GetPeriphCLKFreq+0x248>
3418e312:	4299      	cmp	r1, r3
3418e314:	bf08      	it	eq
3418e316:	f1b0 4f00 	cmpeq.w	r0, #2147483648	@ 0x80000000
3418e31a:	f000 833a 	beq.w	3418e992 <HAL_RCCEx_GetPeriphCLKFreq+0x89e>
3418e31e:	2901      	cmp	r1, #1
3418e320:	bf08      	it	eq
3418e322:	4298      	cmpeq	r0, r3
3418e324:	f000 8337 	beq.w	3418e996 <HAL_RCCEx_GetPeriphCLKFreq+0x8a2>
3418e328:	f100 4040 	add.w	r0, r0, #3221225472	@ 0xc0000000
3418e32c:	4308      	orrs	r0, r1
3418e32e:	f47f af25 	bne.w	3418e17c <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetSDMMCCLKFreq(LL_RCC_SDMMC1_CLKSOURCE);
3418e332:	483c      	ldr	r0, [pc, #240]	@ (3418e424 <HAL_RCCEx_GetPeriphCLKFreq+0x330>)
}
3418e334:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetSDMMCCLKFreq(LL_RCC_SDMMC2_CLKSOURCE);
3418e338:	f7ff bcd8 	b.w	3418dcec <RCCEx_GetSDMMCCLKFreq>
  switch (PeriphClk)
3418e33c:	2904      	cmp	r1, #4
3418e33e:	bf08      	it	eq
3418e340:	4298      	cmpeq	r0, r3
3418e342:	f000 8331 	beq.w	3418e9a8 <HAL_RCCEx_GetPeriphCLKFreq+0x8b4>
3418e346:	2908      	cmp	r1, #8
3418e348:	bf08      	it	eq
3418e34a:	4298      	cmpeq	r0, r3
3418e34c:	f47f af16 	bne.w	3418e17c <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI3_CLKSOURCE);
3418e350:	4835      	ldr	r0, [pc, #212]	@ (3418e428 <HAL_RCCEx_GetPeriphCLKFreq+0x334>)
3418e352:	e325      	b.n	3418e9a0 <HAL_RCCEx_GetPeriphCLKFreq+0x8ac>
  switch (PeriphClk)
3418e354:	f44f 7200 	mov.w	r2, #512	@ 0x200
3418e358:	4291      	cmp	r1, r2
3418e35a:	bf08      	it	eq
3418e35c:	4298      	cmpeq	r0, r3
3418e35e:	f000 832e 	beq.w	3418e9be <HAL_RCCEx_GetPeriphCLKFreq+0x8ca>
3418e362:	4283      	cmp	r3, r0
3418e364:	418a      	sbcs	r2, r1
3418e366:	d311      	bcc.n	3418e38c <HAL_RCCEx_GetPeriphCLKFreq+0x298>
3418e368:	2940      	cmp	r1, #64	@ 0x40
3418e36a:	bf08      	it	eq
3418e36c:	4298      	cmpeq	r0, r3
3418e36e:	f000 831f 	beq.w	3418e9b0 <HAL_RCCEx_GetPeriphCLKFreq+0x8bc>
3418e372:	f5b1 7f80 	cmp.w	r1, #256	@ 0x100
3418e376:	bf08      	it	eq
3418e378:	4298      	cmpeq	r0, r3
3418e37a:	f000 831b 	beq.w	3418e9b4 <HAL_RCCEx_GetPeriphCLKFreq+0x8c0>
3418e37e:	2920      	cmp	r1, #32
3418e380:	bf08      	it	eq
3418e382:	2800      	cmpeq	r0, #0
3418e384:	f47f aefa 	bne.w	3418e17c <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI5_CLKSOURCE);
3418e388:	4828      	ldr	r0, [pc, #160]	@ (3418e42c <HAL_RCCEx_GetPeriphCLKFreq+0x338>)
3418e38a:	e309      	b.n	3418e9a0 <HAL_RCCEx_GetPeriphCLKFreq+0x8ac>
  switch (PeriphClk)
3418e38c:	f5b1 6f80 	cmp.w	r1, #1024	@ 0x400
3418e390:	bf08      	it	eq
3418e392:	4298      	cmpeq	r0, r3
3418e394:	f000 8315 	beq.w	3418e9c2 <HAL_RCCEx_GetPeriphCLKFreq+0x8ce>
3418e398:	f5b1 6f00 	cmp.w	r1, #2048	@ 0x800
3418e39c:	bf08      	it	eq
3418e39e:	4298      	cmpeq	r0, r3
3418e3a0:	f47f aeec 	bne.w	3418e17c <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART4_CLKSOURCE);
3418e3a4:	4822      	ldr	r0, [pc, #136]	@ (3418e430 <HAL_RCCEx_GetPeriphCLKFreq+0x33c>)
}
3418e3a6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART9_CLKSOURCE);
3418e3aa:	f7ff b919 	b.w	3418d5e0 <RCCEx_GetUARTCLKFreq>
  switch (PeriphClk)
3418e3ae:	f44f 2200 	mov.w	r2, #524288	@ 0x80000
3418e3b2:	4291      	cmp	r1, r2
3418e3b4:	bf08      	it	eq
3418e3b6:	4298      	cmpeq	r0, r3
3418e3b8:	f000 830f 	beq.w	3418e9da <HAL_RCCEx_GetPeriphCLKFreq+0x8e6>
3418e3bc:	4283      	cmp	r3, r0
3418e3be:	418a      	sbcs	r2, r1
3418e3c0:	d34b      	bcc.n	3418e45a <HAL_RCCEx_GetPeriphCLKFreq+0x366>
3418e3c2:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
3418e3c6:	4291      	cmp	r1, r2
3418e3c8:	bf08      	it	eq
3418e3ca:	4298      	cmpeq	r0, r3
3418e3cc:	f000 8301 	beq.w	3418e9d2 <HAL_RCCEx_GetPeriphCLKFreq+0x8de>
3418e3d0:	4283      	cmp	r3, r0
3418e3d2:	418a      	sbcs	r2, r1
3418e3d4:	d330      	bcc.n	3418e438 <HAL_RCCEx_GetPeriphCLKFreq+0x344>
3418e3d6:	f5b1 4f80 	cmp.w	r1, #16384	@ 0x4000
3418e3da:	bf08      	it	eq
3418e3dc:	4298      	cmpeq	r0, r3
3418e3de:	f000 82f4 	beq.w	3418e9ca <HAL_RCCEx_GetPeriphCLKFreq+0x8d6>
3418e3e2:	f5b1 4f00 	cmp.w	r1, #32768	@ 0x8000
3418e3e6:	bf08      	it	eq
3418e3e8:	4298      	cmpeq	r0, r3
3418e3ea:	f000 82f0 	beq.w	3418e9ce <HAL_RCCEx_GetPeriphCLKFreq+0x8da>
3418e3ee:	f5b1 5f00 	cmp.w	r1, #8192	@ 0x2000
3418e3f2:	bf08      	it	eq
3418e3f4:	2800      	cmpeq	r0, #0
3418e3f6:	f47f aec1 	bne.w	3418e17c <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART6_CLKSOURCE);
3418e3fa:	480e      	ldr	r0, [pc, #56]	@ (3418e434 <HAL_RCCEx_GetPeriphCLKFreq+0x340>)
3418e3fc:	e2db      	b.n	3418e9b6 <HAL_RCCEx_GetPeriphCLKFreq+0x8c2>
3418e3fe:	bf00      	nop
3418e400:	20000001 	.word	0x20000001
3418e404:	56028000 	.word	0x56028000
3418e408:	07000c0c 	.word	0x07000c0c
3418e40c:	00800001 	.word	0x00800001
3418e410:	00100001 	.word	0x00100001
3418e414:	0700140c 	.word	0x0700140c
3418e418:	0700182c 	.word	0x0700182c
3418e41c:	04000001 	.word	0x04000001
3418e420:	07001418 	.word	0x07001418
3418e424:	0300001c 	.word	0x0300001c
3418e428:	07000c20 	.word	0x07000c20
3418e42c:	07001420 	.word	0x07001420
3418e430:	07000c30 	.word	0x07000c30
3418e434:	07001430 	.word	0x07001430
  switch (PeriphClk)
3418e438:	f5b1 3f00 	cmp.w	r1, #131072	@ 0x20000
3418e43c:	bf08      	it	eq
3418e43e:	4298      	cmpeq	r0, r3
3418e440:	f000 82c9 	beq.w	3418e9d6 <HAL_RCCEx_GetPeriphCLKFreq+0x8e2>
3418e444:	f5b1 2f80 	cmp.w	r1, #262144	@ 0x40000
3418e448:	bf08      	it	eq
3418e44a:	4298      	cmpeq	r0, r3
3418e44c:	f47f ae96 	bne.w	3418e17c <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetOTGPHYCKREFCLKFreq(LL_RCC_OTGPHY1CKREF_CLKSOURCE);
3418e450:	48b4      	ldr	r0, [pc, #720]	@ (3418e724 <HAL_RCCEx_GetPeriphCLKFreq+0x630>)
}
3418e452:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetOTGPHYCKREFCLKFreq(LL_RCC_OTGPHY2CKREF_CLKSOURCE);
3418e456:	f7fe bf8d 	b.w	3418d374 <RCCEx_GetOTGPHYCKREFCLKFreq>
  switch (PeriphClk)
3418e45a:	f44f 0280 	mov.w	r2, #4194304	@ 0x400000
3418e45e:	4291      	cmp	r1, r2
3418e460:	bf08      	it	eq
3418e462:	4298      	cmpeq	r0, r3
3418e464:	f000 82c0 	beq.w	3418e9e8 <HAL_RCCEx_GetPeriphCLKFreq+0x8f4>
3418e468:	4283      	cmp	r3, r0
3418e46a:	418a      	sbcs	r2, r1
3418e46c:	d30d      	bcc.n	3418e48a <HAL_RCCEx_GetPeriphCLKFreq+0x396>
3418e46e:	f5b1 1f80 	cmp.w	r1, #1048576	@ 0x100000
3418e472:	bf08      	it	eq
3418e474:	4298      	cmpeq	r0, r3
3418e476:	f000 82b5 	beq.w	3418e9e4 <HAL_RCCEx_GetPeriphCLKFreq+0x8f0>
3418e47a:	f5b1 1f00 	cmp.w	r1, #2097152	@ 0x200000
3418e47e:	bf08      	it	eq
3418e480:	4298      	cmpeq	r0, r3
3418e482:	f47f ae7b 	bne.w	3418e17c <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY2_CLKSOURCE);
3418e486:	48a8      	ldr	r0, [pc, #672]	@ (3418e728 <HAL_RCCEx_GetPeriphCLKFreq+0x634>)
3418e488:	e2a8      	b.n	3418e9dc <HAL_RCCEx_GetPeriphCLKFreq+0x8e8>
  switch (PeriphClk)
3418e48a:	f5b1 0f00 	cmp.w	r1, #8388608	@ 0x800000
3418e48e:	bf08      	it	eq
3418e490:	4298      	cmpeq	r0, r3
3418e492:	f000 82ae 	beq.w	3418e9f2 <HAL_RCCEx_GetPeriphCLKFreq+0x8fe>
3418e496:	f1b1 7f80 	cmp.w	r1, #16777216	@ 0x1000000
3418e49a:	bf08      	it	eq
3418e49c:	4298      	cmpeq	r0, r3
3418e49e:	f47f ae6d 	bne.w	3418e17c <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      frequency = RCCEx_GetXSPICLKFreq(LL_RCC_XSPI3_CLKSOURCE);
3418e4a2:	48a2      	ldr	r0, [pc, #648]	@ (3418e72c <HAL_RCCEx_GetPeriphCLKFreq+0x638>)
3418e4a4:	e2a1      	b.n	3418e9ea <HAL_RCCEx_GetPeriphCLKFreq+0x8f6>
  return (uint32_t)(READ_BIT(RCC->CCIPR1, RCC_CCIPR1_ADC12SEL));
3418e4a6:	4da2      	ldr	r5, [pc, #648]	@ (3418e730 <HAL_RCCEx_GetPeriphCLKFreq+0x63c>)
3418e4a8:	f8d5 3144 	ldr.w	r3, [r5, #324]	@ 0x144
3418e4ac:	f003 0370 	and.w	r3, r3, #112	@ 0x70
  switch (LL_RCC_GetADCClockSource(ADCxSource))
3418e4b0:	2b40      	cmp	r3, #64	@ 0x40
3418e4b2:	d053      	beq.n	3418e55c <HAL_RCCEx_GetPeriphCLKFreq+0x468>
3418e4b4:	d814      	bhi.n	3418e4e0 <HAL_RCCEx_GetPeriphCLKFreq+0x3ec>
3418e4b6:	2b20      	cmp	r3, #32
3418e4b8:	d025      	beq.n	3418e506 <HAL_RCCEx_GetPeriphCLKFreq+0x412>
3418e4ba:	d805      	bhi.n	3418e4c8 <HAL_RCCEx_GetPeriphCLKFreq+0x3d4>
3418e4bc:	bb03      	cbnz	r3, 3418e500 <HAL_RCCEx_GetPeriphCLKFreq+0x40c>
      adc_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
3418e4be:	f7fc fb29 	bl	3418ab14 <HAL_RCC_GetSysClockFreq>
3418e4c2:	f7fc ffb9 	bl	3418b438 <RCCEx_GetHCLKFreq>
      break;
3418e4c6:	e002      	b.n	3418e4ce <HAL_RCCEx_GetPeriphCLKFreq+0x3da>
  switch (LL_RCC_GetADCClockSource(ADCxSource))
3418e4c8:	2b30      	cmp	r3, #48	@ 0x30
3418e4ca:	d034      	beq.n	3418e536 <HAL_RCCEx_GetPeriphCLKFreq+0x442>
  uint32_t adc_frequency = RCC_PERIPH_FREQUENCY_NO;
3418e4cc:	2000      	movs	r0, #0
  return (uint32_t)(READ_BIT(RCC->CCIPR1, RCC_CCIPR1_ADCPRE) >> RCC_CCIPR1_ADCPRE_Pos);
3418e4ce:	4b98      	ldr	r3, [pc, #608]	@ (3418e730 <HAL_RCCEx_GetPeriphCLKFreq+0x63c>)
3418e4d0:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
3418e4d4:	f3c3 2307 	ubfx	r3, r3, #8, #8
  return (eth1ptp_frequency / __HAL_RCC_GET_ETH1PTP_DIVIDER());
3418e4d8:	3301      	adds	r3, #1
3418e4da:	fbb0 f0f3 	udiv	r0, r0, r3
      break;
3418e4de:	e069      	b.n	3418e5b4 <HAL_RCCEx_GetPeriphCLKFreq+0x4c0>
  switch (LL_RCC_GetADCClockSource(ADCxSource))
3418e4e0:	2b60      	cmp	r3, #96	@ 0x60
3418e4e2:	d047      	beq.n	3418e574 <HAL_RCCEx_GetPeriphCLKFreq+0x480>
3418e4e4:	2b70      	cmp	r3, #112	@ 0x70
3418e4e6:	d03f      	beq.n	3418e568 <HAL_RCCEx_GetPeriphCLKFreq+0x474>
3418e4e8:	2b50      	cmp	r3, #80	@ 0x50
3418e4ea:	d1ef      	bne.n	3418e4cc <HAL_RCCEx_GetPeriphCLKFreq+0x3d8>
      if (LL_RCC_HSI_IsReady() != 0U)
3418e4ec:	f7fc ff12 	bl	3418b314 <LL_RCC_HSI_IsReady>
3418e4f0:	2800      	cmp	r0, #0
3418e4f2:	d0eb      	beq.n	3418e4cc <HAL_RCCEx_GetPeriphCLKFreq+0x3d8>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3418e4f4:	6cab      	ldr	r3, [r5, #72]	@ 0x48
        adc_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3418e4f6:	488f      	ldr	r0, [pc, #572]	@ (3418e734 <HAL_RCCEx_GetPeriphCLKFreq+0x640>)
3418e4f8:	f3c3 13c1 	ubfx	r3, r3, #7, #2
      adc_frequency = HAL_RCC_GetSysClockFreq() / (1UL << LL_RCC_GetTIMPrescaler());
3418e4fc:	40d8      	lsrs	r0, r3
      break;
3418e4fe:	e7e6      	b.n	3418e4ce <HAL_RCCEx_GetPeriphCLKFreq+0x3da>
      adc_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3418e500:	f7fe fd72 	bl	3418cfe8 <RCCEx_GetCLKPCLKFreq.constprop.0>
      break;
3418e504:	e7e3      	b.n	3418e4ce <HAL_RCCEx_GetPeriphCLKFreq+0x3da>
      if (LL_RCC_IC7_IsEnabled() != 0U)
3418e506:	f7fc ff3d 	bl	3418b384 <LL_RCC_IC7_IsEnabled>
3418e50a:	2800      	cmp	r0, #0
3418e50c:	d0de      	beq.n	3418e4cc <HAL_RCCEx_GetPeriphCLKFreq+0x3d8>
        ic_divider = LL_RCC_IC7_GetDivider();
3418e50e:	f7fc ff41 	bl	3418b394 <LL_RCC_IC7_GetDivider>
3418e512:	4604      	mov	r4, r0
  return (uint32_t)(READ_BIT(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL));
3418e514:	f8d5 30dc 	ldr.w	r3, [r5, #220]	@ 0xdc
  return (uint32_t)(READ_BIT(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL));
3418e518:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC8_GetSource())
3418e51c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418e520:	d019      	beq.n	3418e556 <HAL_RCCEx_GetPeriphCLKFreq+0x462>
3418e522:	d812      	bhi.n	3418e54a <HAL_RCCEx_GetPeriphCLKFreq+0x456>
3418e524:	b913      	cbnz	r3, 3418e52c <HAL_RCCEx_GetPeriphCLKFreq+0x438>
            adc_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3418e526:	f7fe fc5f 	bl	3418cde8 <HAL_RCCEx_GetPLL1CLKFreq>
3418e52a:	e001      	b.n	3418e530 <HAL_RCCEx_GetPeriphCLKFreq+0x43c>
            adc_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3418e52c:	f7fe fc9c 	bl	3418ce68 <HAL_RCCEx_GetPLL2CLKFreq>
            adc_frequency = adc_frequency / ic_divider;
3418e530:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
3418e534:	e7cb      	b.n	3418e4ce <HAL_RCCEx_GetPeriphCLKFreq+0x3da>
      if (LL_RCC_IC8_IsEnabled() != 0U)
3418e536:	f7fc ff37 	bl	3418b3a8 <LL_RCC_IC8_IsEnabled>
3418e53a:	2800      	cmp	r0, #0
3418e53c:	d0c6      	beq.n	3418e4cc <HAL_RCCEx_GetPeriphCLKFreq+0x3d8>
        ic_divider = LL_RCC_IC8_GetDivider();
3418e53e:	f7fc ff3b 	bl	3418b3b8 <LL_RCC_IC8_GetDivider>
3418e542:	f8d5 30e0 	ldr.w	r3, [r5, #224]	@ 0xe0
3418e546:	4604      	mov	r4, r0
3418e548:	e7e6      	b.n	3418e518 <HAL_RCCEx_GetPeriphCLKFreq+0x424>
        switch (LL_RCC_IC8_GetSource())
3418e54a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418e54e:	d1bd      	bne.n	3418e4cc <HAL_RCCEx_GetPeriphCLKFreq+0x3d8>
            adc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3418e550:	f7fe fd0a 	bl	3418cf68 <HAL_RCCEx_GetPLL4CLKFreq>
3418e554:	e7ec      	b.n	3418e530 <HAL_RCCEx_GetPeriphCLKFreq+0x43c>
            adc_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3418e556:	f7fe fcc7 	bl	3418cee8 <HAL_RCCEx_GetPLL3CLKFreq>
3418e55a:	e7e9      	b.n	3418e530 <HAL_RCCEx_GetPeriphCLKFreq+0x43c>
      if (LL_RCC_MSI_IsReady() != 0U)
3418e55c:	f7fc fee2 	bl	3418b324 <LL_RCC_MSI_IsReady>
3418e560:	2800      	cmp	r0, #0
3418e562:	d0b3      	beq.n	3418e4cc <HAL_RCCEx_GetPeriphCLKFreq+0x3d8>
        adc_frequency = MSI_VALUE;
3418e564:	4874      	ldr	r0, [pc, #464]	@ (3418e738 <HAL_RCCEx_GetPeriphCLKFreq+0x644>)
3418e566:	e7b2      	b.n	3418e4ce <HAL_RCCEx_GetPeriphCLKFreq+0x3da>
      adc_frequency = HAL_RCC_GetSysClockFreq() / (1UL << LL_RCC_GetTIMPrescaler());
3418e568:	f7fc fad4 	bl	3418ab14 <HAL_RCC_GetSysClockFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_TIMPRE) >> RCC_CFGR2_TIMPRE_Pos);
3418e56c:	6a6b      	ldr	r3, [r5, #36]	@ 0x24
3418e56e:	f3c3 6301 	ubfx	r3, r3, #24, #2
3418e572:	e7c3      	b.n	3418e4fc <HAL_RCCEx_GetPeriphCLKFreq+0x408>
  switch (LL_RCC_GetADCClockSource(ADCxSource))
3418e574:	4871      	ldr	r0, [pc, #452]	@ (3418e73c <HAL_RCCEx_GetPeriphCLKFreq+0x648>)
3418e576:	e7aa      	b.n	3418e4ce <HAL_RCCEx_GetPeriphCLKFreq+0x3da>
  return (uint32_t)(READ_BIT(RCC->CCIPR1, RCC_CCIPR1_ADF1SEL));
3418e578:	4d6d      	ldr	r5, [pc, #436]	@ (3418e730 <HAL_RCCEx_GetPeriphCLKFreq+0x63c>)
3418e57a:	f8d5 3144 	ldr.w	r3, [r5, #324]	@ 0x144
3418e57e:	f003 0307 	and.w	r3, r3, #7
  switch (LL_RCC_GetADFClockSource(ADFxSource))
3418e582:	3b01      	subs	r3, #1
3418e584:	2b06      	cmp	r3, #6
3418e586:	f200 80f5 	bhi.w	3418e774 <HAL_RCCEx_GetPeriphCLKFreq+0x680>
3418e58a:	a201      	add	r2, pc, #4	@ (adr r2, 3418e590 <HAL_RCCEx_GetPeriphCLKFreq+0x49c>)
3418e58c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3418e590:	3418e665 	.word	0x3418e665
3418e594:	3418e8d7 	.word	0x3418e8d7
3418e598:	3418e2a5 	.word	0x3418e2a5
3418e59c:	3418e5b7 	.word	0x3418e5b7
3418e5a0:	3418e625 	.word	0x3418e625
3418e5a4:	3418e9f7 	.word	0x3418e9f7
3418e5a8:	3418e8ed 	.word	0x3418e8ed
            adf_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3418e5ac:	f7fe fc5c 	bl	3418ce68 <HAL_RCCEx_GetPLL2CLKFreq>
            adf_frequency = adf_frequency / ic_divider;
3418e5b0:	fbb0 f0f4 	udiv	r0, r0, r4
}
3418e5b4:	bd38      	pop	{r3, r4, r5, pc}
      if (LL_RCC_MSI_IsReady() != 0U)
3418e5b6:	f7fc feb5 	bl	3418b324 <LL_RCC_MSI_IsReady>
3418e5ba:	2800      	cmp	r0, #0
3418e5bc:	f43f adde 	beq.w	3418e17c <HAL_RCCEx_GetPeriphCLKFreq+0x88>
        adf_frequency = MSI_VALUE;
3418e5c0:	485d      	ldr	r0, [pc, #372]	@ (3418e738 <HAL_RCCEx_GetPeriphCLKFreq+0x644>)
3418e5c2:	e7f7      	b.n	3418e5b4 <HAL_RCCEx_GetPeriphCLKFreq+0x4c0>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC18EN) == RCC_DIVENR_IC18EN) ? 1UL : 0UL);
3418e5c4:	4b5a      	ldr	r3, [pc, #360]	@ (3418e730 <HAL_RCCEx_GetPeriphCLKFreq+0x63c>)
3418e5c6:	f8d3 2240 	ldr.w	r2, [r3, #576]	@ 0x240
3418e5ca:	0395      	lsls	r5, r2, #14
3418e5cc:	f57f add6 	bpl.w	3418e17c <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return ((READ_BIT(RCC->IC18CFGR, RCC_IC18CFGR_IC18INT) >> RCC_IC18CFGR_IC18INT_Pos) + 1UL);
3418e5d0:	f8d3 0108 	ldr.w	r0, [r3, #264]	@ 0x108
  return (uint32_t)(READ_BIT(RCC->IC18CFGR, RCC_IC18CFGR_IC18SEL));
3418e5d4:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
  return ((READ_BIT(RCC->IC18CFGR, RCC_IC18CFGR_IC18INT) >> RCC_IC18CFGR_IC18INT_Pos) + 1UL);
3418e5d8:	f3c0 4007 	ubfx	r0, r0, #16, #8
3418e5dc:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL));
3418e5de:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC20_GetSource())
3418e5e2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418e5e6:	f000 81ae 	beq.w	3418e946 <HAL_RCCEx_GetPeriphCLKFreq+0x852>
3418e5ea:	f200 81a5 	bhi.w	3418e938 <HAL_RCCEx_GetPeriphCLKFreq+0x844>
3418e5ee:	2b00      	cmp	r3, #0
3418e5f0:	d1dc      	bne.n	3418e5ac <HAL_RCCEx_GetPeriphCLKFreq+0x4b8>
            pssi_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3418e5f2:	f7fe fbf9 	bl	3418cde8 <HAL_RCCEx_GetPLL1CLKFreq>
3418e5f6:	e7db      	b.n	3418e5b0 <HAL_RCCEx_GetPeriphCLKFreq+0x4bc>
  return (uint32_t)(READ_BIT(RCC->CCIPR1, RCC_CCIPR1_DCMIPPSEL));
3418e5f8:	4d4d      	ldr	r5, [pc, #308]	@ (3418e730 <HAL_RCCEx_GetPeriphCLKFreq+0x63c>)
3418e5fa:	f8d5 3144 	ldr.w	r3, [r5, #324]	@ 0x144
3418e5fe:	f403 1340 	and.w	r3, r3, #3145728	@ 0x300000
  switch (LL_RCC_GetDCMIPPClockSource(DCMIPPxSource))
3418e602:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
3418e606:	d014      	beq.n	3418e632 <HAL_RCCEx_GetPeriphCLKFreq+0x53e>
3418e608:	d808      	bhi.n	3418e61c <HAL_RCCEx_GetPeriphCLKFreq+0x528>
  switch (LL_RCC_GetLTDCClockSource(LTDCxSource))
3418e60a:	bb5b      	cbnz	r3, 3418e664 <HAL_RCCEx_GetPeriphCLKFreq+0x570>
      ltdc_frequency = RCCEx_GetPCLK5Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3418e60c:	f7fc fa82 	bl	3418ab14 <HAL_RCC_GetSysClockFreq>
3418e610:	f7fc ff12 	bl	3418b438 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE5));
3418e614:	6a6b      	ldr	r3, [r5, #36]	@ 0x24
  return LL_RCC_CALC_PCLK5_FREQ(HCLK_Frequency, LL_RCC_GetAPB5Prescaler());
3418e616:	f3c3 4302 	ubfx	r3, r3, #16, #3
3418e61a:	e5df      	b.n	3418e1dc <HAL_RCCEx_GetPeriphCLKFreq+0xe8>
  switch (LL_RCC_GetDCMIPPClockSource(DCMIPPxSource))
3418e61c:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
  switch (LL_RCC_GetMDFClockSource(MDFxSource))
3418e620:	f47f adac 	bne.w	3418e17c <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      if (LL_RCC_HSI_IsReady() != 0U)
3418e624:	f7fc fe76 	bl	3418b314 <LL_RCC_HSI_IsReady>
3418e628:	2800      	cmp	r0, #0
3418e62a:	f43f ada7 	beq.w	3418e17c <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3418e62e:	6cab      	ldr	r3, [r5, #72]	@ 0x48
3418e630:	e136      	b.n	3418e8a0 <HAL_RCCEx_GetPeriphCLKFreq+0x7ac>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC17EN) == RCC_DIVENR_IC17EN) ? 1UL : 0UL);
3418e632:	f8d5 3240 	ldr.w	r3, [r5, #576]	@ 0x240
3418e636:	03dc      	lsls	r4, r3, #15
3418e638:	f57f ada0 	bpl.w	3418e17c <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return ((READ_BIT(RCC->IC17CFGR, RCC_IC17CFGR_IC17INT) >> RCC_IC17CFGR_IC17INT_Pos) + 1UL);
3418e63c:	f8d5 0104 	ldr.w	r0, [r5, #260]	@ 0x104
  return (uint32_t)(READ_BIT(RCC->IC17CFGR, RCC_IC17CFGR_IC17SEL));
3418e640:	f8d5 3104 	ldr.w	r3, [r5, #260]	@ 0x104
  return ((READ_BIT(RCC->IC17CFGR, RCC_IC17CFGR_IC17INT) >> RCC_IC17CFGR_IC17INT_Pos) + 1UL);
3418e644:	f3c0 4007 	ubfx	r0, r0, #16, #8
3418e648:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC17CFGR, RCC_IC17CFGR_IC17SEL));
3418e64a:	e7c8      	b.n	3418e5de <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
  return (uint32_t)(READ_BIT(RCC->CCIPR2, RCC_CCIPR2_ETH1CLKSEL));
3418e64c:	4a38      	ldr	r2, [pc, #224]	@ (3418e730 <HAL_RCCEx_GetPeriphCLKFreq+0x63c>)
3418e64e:	f8d2 3148 	ldr.w	r3, [r2, #328]	@ 0x148
3418e652:	f403 5340 	and.w	r3, r3, #12288	@ 0x3000
  switch (LL_RCC_GetETHClockSource(ETH1xSource))
3418e656:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
3418e65a:	d012      	beq.n	3418e682 <HAL_RCCEx_GetPeriphCLKFreq+0x58e>
3418e65c:	d806      	bhi.n	3418e66c <HAL_RCCEx_GetPeriphCLKFreq+0x578>
  switch (LL_RCC_GetPSSIClockSource(PSSIxSource))
3418e65e:	2b00      	cmp	r3, #0
3418e660:	f000 8088 	beq.w	3418e774 <HAL_RCCEx_GetPeriphCLKFreq+0x680>
}
3418e664:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      adf_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3418e668:	f7fe bcbe 	b.w	3418cfe8 <RCCEx_GetCLKPCLKFreq.constprop.0>
  switch (LL_RCC_GetETHClockSource(ETH1xSource))
3418e66c:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
3418e670:	f47f ad84 	bne.w	3418e17c <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      if (LL_RCC_HSE_IsReady() != 0U)
3418e674:	f7fc fe46 	bl	3418b304 <LL_RCC_HSE_IsReady>
3418e678:	2800      	cmp	r0, #0
3418e67a:	f43f ad7f 	beq.w	3418e17c <HAL_RCCEx_GetPeriphCLKFreq+0x88>
        eth1_frequency = HSE_VALUE;
3418e67e:	4830      	ldr	r0, [pc, #192]	@ (3418e740 <HAL_RCCEx_GetPeriphCLKFreq+0x64c>)
3418e680:	e798      	b.n	3418e5b4 <HAL_RCCEx_GetPeriphCLKFreq+0x4c0>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC12EN) == RCC_DIVENR_IC12EN) ? 1UL : 0UL);
3418e682:	f8d2 3240 	ldr.w	r3, [r2, #576]	@ 0x240
3418e686:	0518      	lsls	r0, r3, #20
3418e688:	f57f ad78 	bpl.w	3418e17c <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return ((READ_BIT(RCC->IC12CFGR, RCC_IC12CFGR_IC12INT) >> RCC_IC12CFGR_IC12INT_Pos) + 1UL);
3418e68c:	f8d2 00f0 	ldr.w	r0, [r2, #240]	@ 0xf0
  return (uint32_t)(READ_BIT(RCC->IC12CFGR, RCC_IC12CFGR_IC12SEL));
3418e690:	f8d2 30f0 	ldr.w	r3, [r2, #240]	@ 0xf0
  return ((READ_BIT(RCC->IC12CFGR, RCC_IC12CFGR_IC12INT) >> RCC_IC12CFGR_IC12INT_Pos) + 1UL);
3418e694:	f3c0 4007 	ubfx	r0, r0, #16, #8
3418e698:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC12CFGR, RCC_IC12CFGR_IC12SEL));
3418e69a:	e7a0      	b.n	3418e5de <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
  return (uint32_t)(READ_BIT(RCC->CCIPR2, RCC_CCIPR2_ETH1PTPSEL));
3418e69c:	4a24      	ldr	r2, [pc, #144]	@ (3418e730 <HAL_RCCEx_GetPeriphCLKFreq+0x63c>)
3418e69e:	f8d2 3148 	ldr.w	r3, [r2, #328]	@ 0x148
3418e6a2:	f003 0303 	and.w	r3, r3, #3
  switch (LL_RCC_GetETHPTPClockSource(ETH1PTPxSource))
3418e6a6:	2b02      	cmp	r3, #2
3418e6a8:	d010      	beq.n	3418e6cc <HAL_RCCEx_GetPeriphCLKFreq+0x5d8>
3418e6aa:	2b03      	cmp	r3, #3
3418e6ac:	d034      	beq.n	3418e718 <HAL_RCCEx_GetPeriphCLKFreq+0x624>
3418e6ae:	2b01      	cmp	r3, #1
3418e6b0:	d009      	beq.n	3418e6c6 <HAL_RCCEx_GetPeriphCLKFreq+0x5d2>
      eth1ptp_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
3418e6b2:	f7fc fa2f 	bl	3418ab14 <HAL_RCC_GetSysClockFreq>
3418e6b6:	f7fc febf 	bl	3418b438 <RCCEx_GetHCLKFreq>
  return (READ_BIT(RCC->CCIPR2, RCC_CCIPR2_ETH1PTPDIV));
3418e6ba:	4b1d      	ldr	r3, [pc, #116]	@ (3418e730 <HAL_RCCEx_GetPeriphCLKFreq+0x63c>)
3418e6bc:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
  return (eth1ptp_frequency / __HAL_RCC_GET_ETH1PTP_DIVIDER());
3418e6c0:	f3c3 1303 	ubfx	r3, r3, #4, #4
3418e6c4:	e708      	b.n	3418e4d8 <HAL_RCCEx_GetPeriphCLKFreq+0x3e4>
      eth1ptp_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3418e6c6:	f7fe fc8f 	bl	3418cfe8 <RCCEx_GetCLKPCLKFreq.constprop.0>
      break;
3418e6ca:	e7f6      	b.n	3418e6ba <HAL_RCCEx_GetPeriphCLKFreq+0x5c6>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC13EN) == RCC_DIVENR_IC13EN) ? 1UL : 0UL);
3418e6cc:	f8d2 3240 	ldr.w	r3, [r2, #576]	@ 0x240
3418e6d0:	04d9      	lsls	r1, r3, #19
3418e6d2:	d516      	bpl.n	3418e702 <HAL_RCCEx_GetPeriphCLKFreq+0x60e>
  return ((READ_BIT(RCC->IC13CFGR, RCC_IC13CFGR_IC13INT) >> RCC_IC13CFGR_IC13INT_Pos) + 1UL);
3418e6d4:	f8d2 00f4 	ldr.w	r0, [r2, #244]	@ 0xf4
  return (uint32_t)(READ_BIT(RCC->IC13CFGR, RCC_IC13CFGR_IC13SEL));
3418e6d8:	f8d2 30f4 	ldr.w	r3, [r2, #244]	@ 0xf4
  return ((READ_BIT(RCC->IC13CFGR, RCC_IC13CFGR_IC13INT) >> RCC_IC13CFGR_IC13INT_Pos) + 1UL);
3418e6dc:	f3c0 4007 	ubfx	r0, r0, #16, #8
  return (uint32_t)(READ_BIT(RCC->IC13CFGR, RCC_IC13CFGR_IC13SEL));
3418e6e0:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
        switch (LL_RCC_IC13_GetSource())
3418e6e4:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
  return ((READ_BIT(RCC->IC13CFGR, RCC_IC13CFGR_IC13INT) >> RCC_IC13CFGR_IC13INT_Pos) + 1UL);
3418e6e8:	f100 0401 	add.w	r4, r0, #1
3418e6ec:	d00e      	beq.n	3418e70c <HAL_RCCEx_GetPeriphCLKFreq+0x618>
3418e6ee:	d805      	bhi.n	3418e6fc <HAL_RCCEx_GetPeriphCLKFreq+0x608>
3418e6f0:	b94b      	cbnz	r3, 3418e706 <HAL_RCCEx_GetPeriphCLKFreq+0x612>
            eth1ptp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3418e6f2:	f7fe fb79 	bl	3418cde8 <HAL_RCCEx_GetPLL1CLKFreq>
            eth1ptp_frequency = eth1ptp_frequency / ic_divider;
3418e6f6:	fbb0 f0f4 	udiv	r0, r0, r4
            break;
3418e6fa:	e7de      	b.n	3418e6ba <HAL_RCCEx_GetPeriphCLKFreq+0x5c6>
        switch (LL_RCC_IC13_GetSource())
3418e6fc:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418e700:	d007      	beq.n	3418e712 <HAL_RCCEx_GetPeriphCLKFreq+0x61e>
        eth1ptp_frequency = HSE_VALUE;
3418e702:	2000      	movs	r0, #0
3418e704:	e7d9      	b.n	3418e6ba <HAL_RCCEx_GetPeriphCLKFreq+0x5c6>
            eth1ptp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3418e706:	f7fe fbaf 	bl	3418ce68 <HAL_RCCEx_GetPLL2CLKFreq>
3418e70a:	e7f4      	b.n	3418e6f6 <HAL_RCCEx_GetPeriphCLKFreq+0x602>
            eth1ptp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3418e70c:	f7fe fbec 	bl	3418cee8 <HAL_RCCEx_GetPLL3CLKFreq>
3418e710:	e7f1      	b.n	3418e6f6 <HAL_RCCEx_GetPeriphCLKFreq+0x602>
            eth1ptp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3418e712:	f7fe fc29 	bl	3418cf68 <HAL_RCCEx_GetPLL4CLKFreq>
3418e716:	e7ee      	b.n	3418e6f6 <HAL_RCCEx_GetPeriphCLKFreq+0x602>
      if (LL_RCC_HSE_IsReady() != 0U)
3418e718:	f7fc fdf4 	bl	3418b304 <LL_RCC_HSE_IsReady>
3418e71c:	2800      	cmp	r0, #0
3418e71e:	d0f0      	beq.n	3418e702 <HAL_RCCEx_GetPeriphCLKFreq+0x60e>
        eth1ptp_frequency = HSE_VALUE;
3418e720:	4807      	ldr	r0, [pc, #28]	@ (3418e740 <HAL_RCCEx_GetPeriphCLKFreq+0x64c>)
3418e722:	e7ca      	b.n	3418e6ba <HAL_RCCEx_GetPeriphCLKFreq+0x5c6>
3418e724:	01001014 	.word	0x01001014
3418e728:	03001414 	.word	0x03001414
3418e72c:	03000814 	.word	0x03000814
3418e730:	56028000 	.word	0x56028000
3418e734:	03d09000 	.word	0x03d09000
3418e738:	003d0900 	.word	0x003d0900
3418e73c:	00bb8000 	.word	0x00bb8000
3418e740:	02dc6c00 	.word	0x02dc6c00
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC19EN) == RCC_DIVENR_IC19EN) ? 1UL : 0UL);
3418e744:	f8d5 3240 	ldr.w	r3, [r5, #576]	@ 0x240
3418e748:	035b      	lsls	r3, r3, #13
3418e74a:	f57f ad17 	bpl.w	3418e17c <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return ((READ_BIT(RCC->IC19CFGR, RCC_IC19CFGR_IC19INT) >> RCC_IC19CFGR_IC19INT_Pos) + 1UL);
3418e74e:	f8d5 010c 	ldr.w	r0, [r5, #268]	@ 0x10c
  return (uint32_t)(READ_BIT(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL));
3418e752:	f8d5 310c 	ldr.w	r3, [r5, #268]	@ 0x10c
  return ((READ_BIT(RCC->IC19CFGR, RCC_IC19CFGR_IC19INT) >> RCC_IC19CFGR_IC19INT_Pos) + 1UL);
3418e756:	f3c0 4007 	ubfx	r0, r0, #16, #8
3418e75a:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL));
3418e75c:	e73f      	b.n	3418e5de <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
  return (uint32_t)(READ_BIT(RCC->CCIPR3, RCC_CCIPR3_FMCSEL));
3418e75e:	4ba7      	ldr	r3, [pc, #668]	@ (3418e9fc <HAL_RCCEx_GetPeriphCLKFreq+0x908>)
3418e760:	f8d3 214c 	ldr.w	r2, [r3, #332]	@ 0x14c
3418e764:	f002 0230 	and.w	r2, r2, #48	@ 0x30
  switch (LL_RCC_GetFMCClockSource(FMCxSource))
3418e768:	2a20      	cmp	r2, #32
3418e76a:	d019      	beq.n	3418e7a0 <HAL_RCCEx_GetPeriphCLKFreq+0x6ac>
3418e76c:	d808      	bhi.n	3418e780 <HAL_RCCEx_GetPeriphCLKFreq+0x68c>
3418e76e:	2a00      	cmp	r2, #0
3418e770:	f47f af78 	bne.w	3418e664 <HAL_RCCEx_GetPeriphCLKFreq+0x570>
      adf_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
3418e774:	f7fc f9ce 	bl	3418ab14 <HAL_RCC_GetSysClockFreq>
}
3418e778:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      adf_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
3418e77c:	f7fc be5c 	b.w	3418b438 <RCCEx_GetHCLKFreq>
  switch (LL_RCC_GetFMCClockSource(FMCxSource))
3418e780:	2a30      	cmp	r2, #48	@ 0x30
3418e782:	f47f acfb 	bne.w	3418e17c <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC4EN) == RCC_DIVENR_IC4EN) ? 1UL : 0UL);
3418e786:	f8d3 2240 	ldr.w	r2, [r3, #576]	@ 0x240
3418e78a:	0714      	lsls	r4, r2, #28
3418e78c:	f57f acf6 	bpl.w	3418e17c <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return ((READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4INT) >> RCC_IC4CFGR_IC4INT_Pos) + 1UL);
3418e790:	f8d3 00d0 	ldr.w	r0, [r3, #208]	@ 0xd0
  return (uint32_t)(READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL));
3418e794:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
  return ((READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4INT) >> RCC_IC4CFGR_IC4INT_Pos) + 1UL);
3418e798:	f3c0 4007 	ubfx	r0, r0, #16, #8
3418e79c:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL));
3418e79e:	e71e      	b.n	3418e5de <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC3EN) == RCC_DIVENR_IC3EN) ? 1UL : 0UL);
3418e7a0:	f8d3 2240 	ldr.w	r2, [r3, #576]	@ 0x240
3418e7a4:	0755      	lsls	r5, r2, #29
3418e7a6:	f57f ace9 	bpl.w	3418e17c <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return ((READ_BIT(RCC->IC3CFGR, RCC_IC3CFGR_IC3INT) >> RCC_IC3CFGR_IC3INT_Pos) + 1UL);
3418e7aa:	f8d3 00cc 	ldr.w	r0, [r3, #204]	@ 0xcc
  return (uint32_t)(READ_BIT(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL));
3418e7ae:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
  return ((READ_BIT(RCC->IC3CFGR, RCC_IC3CFGR_IC3INT) >> RCC_IC3CFGR_IC3INT_Pos) + 1UL);
3418e7b2:	f3c0 4007 	ubfx	r0, r0, #16, #8
3418e7b6:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL));
3418e7b8:	e711      	b.n	3418e5de <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
      frequency = RCCEx_GetI2CCLKFreq(LL_RCC_I2C1_CLKSOURCE);
3418e7ba:	4891      	ldr	r0, [pc, #580]	@ (3418ea00 <HAL_RCCEx_GetPeriphCLKFreq+0x90c>)
}
3418e7bc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetI2CCLKFreq(LL_RCC_I2C2_CLKSOURCE);
3418e7c0:	f7ff bafa 	b.w	3418ddb8 <RCCEx_GetI2CCLKFreq>
3418e7c4:	488f      	ldr	r0, [pc, #572]	@ (3418ea04 <HAL_RCCEx_GetPeriphCLKFreq+0x910>)
3418e7c6:	e7f9      	b.n	3418e7bc <HAL_RCCEx_GetPeriphCLKFreq+0x6c8>
      frequency = RCCEx_GetI2CCLKFreq(LL_RCC_I2C3_CLKSOURCE);
3418e7c8:	488f      	ldr	r0, [pc, #572]	@ (3418ea08 <HAL_RCCEx_GetPeriphCLKFreq+0x914>)
3418e7ca:	e7f7      	b.n	3418e7bc <HAL_RCCEx_GetPeriphCLKFreq+0x6c8>
      frequency = RCCEx_GetI3CCLKFreq(LL_RCC_I3C1_CLKSOURCE);
3418e7cc:	488f      	ldr	r0, [pc, #572]	@ (3418ea0c <HAL_RCCEx_GetPeriphCLKFreq+0x918>)
}
3418e7ce:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetI3CCLKFreq(LL_RCC_I3C2_CLKSOURCE);
3418e7d2:	f7ff b9ff 	b.w	3418dbd4 <RCCEx_GetI3CCLKFreq>
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM1_CLKSOURCE);
3418e7d6:	488e      	ldr	r0, [pc, #568]	@ (3418ea10 <HAL_RCCEx_GetPeriphCLKFreq+0x91c>)
}
3418e7d8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM2_CLKSOURCE);
3418e7dc:	f7ff bbaa 	b.w	3418df34 <RCCEx_GetLPTIMCLKFreq>
3418e7e0:	488c      	ldr	r0, [pc, #560]	@ (3418ea14 <HAL_RCCEx_GetPeriphCLKFreq+0x920>)
3418e7e2:	e7f9      	b.n	3418e7d8 <HAL_RCCEx_GetPeriphCLKFreq+0x6e4>
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM3_CLKSOURCE);
3418e7e4:	488c      	ldr	r0, [pc, #560]	@ (3418ea18 <HAL_RCCEx_GetPeriphCLKFreq+0x924>)
3418e7e6:	e7f7      	b.n	3418e7d8 <HAL_RCCEx_GetPeriphCLKFreq+0x6e4>
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM4_CLKSOURCE);
3418e7e8:	488c      	ldr	r0, [pc, #560]	@ (3418ea1c <HAL_RCCEx_GetPeriphCLKFreq+0x928>)
3418e7ea:	e7f5      	b.n	3418e7d8 <HAL_RCCEx_GetPeriphCLKFreq+0x6e4>
  return (uint32_t)(READ_BIT(RCC->CCIPR14, RCC_CCIPR14_LPUART1SEL));
3418e7ec:	4a83      	ldr	r2, [pc, #524]	@ (3418e9fc <HAL_RCCEx_GetPeriphCLKFreq+0x908>)
3418e7ee:	f8d2 3178 	ldr.w	r3, [r2, #376]	@ 0x178
3418e7f2:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
  switch (LL_RCC_GetLPUARTClockSource(LPUARTxSource))
3418e7f6:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
3418e7fa:	d031      	beq.n	3418e860 <HAL_RCCEx_GetPeriphCLKFreq+0x76c>
3418e7fc:	d812      	bhi.n	3418e824 <HAL_RCCEx_GetPeriphCLKFreq+0x730>
3418e7fe:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3418e802:	f43f af2f 	beq.w	3418e664 <HAL_RCCEx_GetPeriphCLKFreq+0x570>
3418e806:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3418e80a:	d01d      	beq.n	3418e848 <HAL_RCCEx_GetPeriphCLKFreq+0x754>
3418e80c:	2b00      	cmp	r3, #0
3418e80e:	f47f acb5 	bne.w	3418e17c <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      lpuart_frequency = RCCEx_GetPCLK4Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3418e812:	f7fc f97f 	bl	3418ab14 <HAL_RCC_GetSysClockFreq>
3418e816:	f7fc fe0f 	bl	3418b438 <RCCEx_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE4));
3418e81a:	4b78      	ldr	r3, [pc, #480]	@ (3418e9fc <HAL_RCCEx_GetPeriphCLKFreq+0x908>)
3418e81c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  return LL_RCC_CALC_PCLK4_FREQ(HCLK_Frequency, LL_RCC_GetAPB4Prescaler());
3418e81e:	f3c3 3302 	ubfx	r3, r3, #12, #3
3418e822:	e4db      	b.n	3418e1dc <HAL_RCCEx_GetPeriphCLKFreq+0xe8>
  switch (LL_RCC_GetLPUARTClockSource(LPUARTxSource))
3418e824:	f5b3 6fa0 	cmp.w	r3, #1280	@ 0x500
3418e828:	f43f aec5 	beq.w	3418e5b6 <HAL_RCCEx_GetPeriphCLKFreq+0x4c2>
3418e82c:	f5b3 6fc0 	cmp.w	r3, #1536	@ 0x600
3418e830:	d02f      	beq.n	3418e892 <HAL_RCCEx_GetPeriphCLKFreq+0x79e>
3418e832:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
  switch (LL_RCC_GetRTCClockSource())
3418e836:	f47f aca1 	bne.w	3418e17c <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      if (LL_RCC_LSE_IsReady() != 0U)
3418e83a:	f7fc fd7b 	bl	3418b334 <LL_RCC_LSE_IsReady>
3418e83e:	3800      	subs	r0, #0
3418e840:	bf18      	it	ne
3418e842:	2001      	movne	r0, #1
3418e844:	03c0      	lsls	r0, r0, #15
3418e846:	e6b5      	b.n	3418e5b4 <HAL_RCCEx_GetPeriphCLKFreq+0x4c0>
      if (LL_RCC_IC9_IsEnabled() != 0U)
3418e848:	f7fc fdc0 	bl	3418b3cc <LL_RCC_IC9_IsEnabled>
3418e84c:	2800      	cmp	r0, #0
3418e84e:	f43f ac95 	beq.w	3418e17c <HAL_RCCEx_GetPeriphCLKFreq+0x88>
        ic_divider = LL_RCC_IC9_GetDivider();
3418e852:	f7fc fdc3 	bl	3418b3dc <LL_RCC_IC9_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL));
3418e856:	4b69      	ldr	r3, [pc, #420]	@ (3418e9fc <HAL_RCCEx_GetPeriphCLKFreq+0x908>)
3418e858:	4604      	mov	r4, r0
3418e85a:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3418e85e:	e6be      	b.n	3418e5de <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
      if (LL_RCC_IC14_IsEnabled() != 0U)
3418e860:	f7fc fdc6 	bl	3418b3f0 <LL_RCC_IC14_IsEnabled>
3418e864:	2800      	cmp	r0, #0
3418e866:	f43f ac89 	beq.w	3418e17c <HAL_RCCEx_GetPeriphCLKFreq+0x88>
        ic_divider = LL_RCC_IC14_GetDivider();
3418e86a:	f7fc fdc9 	bl	3418b400 <LL_RCC_IC14_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL));
3418e86e:	f8d2 30f8 	ldr.w	r3, [r2, #248]	@ 0xf8
3418e872:	4604      	mov	r4, r0
3418e874:	e6b3      	b.n	3418e5de <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
  return (uint32_t)(READ_BIT(RCC->CCIPR4, RCC_CCIPR4_LTDCSEL));
3418e876:	4d61      	ldr	r5, [pc, #388]	@ (3418e9fc <HAL_RCCEx_GetPeriphCLKFreq+0x908>)
3418e878:	f8d5 3150 	ldr.w	r3, [r5, #336]	@ 0x150
3418e87c:	f003 7340 	and.w	r3, r3, #50331648	@ 0x3000000
  switch (LL_RCC_GetLTDCClockSource(LTDCxSource))
3418e880:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
3418e884:	d010      	beq.n	3418e8a8 <HAL_RCCEx_GetPeriphCLKFreq+0x7b4>
3418e886:	f67f aec0 	bls.w	3418e60a <HAL_RCCEx_GetPeriphCLKFreq+0x516>
3418e88a:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
3418e88e:	f47f ac75 	bne.w	3418e17c <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      if (LL_RCC_HSI_IsReady() != 0U)
3418e892:	f7fc fd3f 	bl	3418b314 <LL_RCC_HSI_IsReady>
3418e896:	2800      	cmp	r0, #0
3418e898:	f43f ac70 	beq.w	3418e17c <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3418e89c:	4b57      	ldr	r3, [pc, #348]	@ (3418e9fc <HAL_RCCEx_GetPeriphCLKFreq+0x908>)
3418e89e:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
        pssi_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3418e8a0:	485f      	ldr	r0, [pc, #380]	@ (3418ea20 <HAL_RCCEx_GetPeriphCLKFreq+0x92c>)
3418e8a2:	f3c3 13c1 	ubfx	r3, r3, #7, #2
3418e8a6:	e499      	b.n	3418e1dc <HAL_RCCEx_GetPeriphCLKFreq+0xe8>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC16EN) == RCC_DIVENR_IC16EN) ? 1UL : 0UL);
3418e8a8:	f8d5 3240 	ldr.w	r3, [r5, #576]	@ 0x240
3418e8ac:	0418      	lsls	r0, r3, #16
3418e8ae:	f57f ac65 	bpl.w	3418e17c <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return ((READ_BIT(RCC->IC16CFGR, RCC_IC16CFGR_IC16INT) >> RCC_IC16CFGR_IC16INT_Pos) + 1UL);
3418e8b2:	f8d5 0100 	ldr.w	r0, [r5, #256]	@ 0x100
  return (uint32_t)(READ_BIT(RCC->IC16CFGR, RCC_IC16CFGR_IC16SEL));
3418e8b6:	f8d5 3100 	ldr.w	r3, [r5, #256]	@ 0x100
  return ((READ_BIT(RCC->IC16CFGR, RCC_IC16CFGR_IC16INT) >> RCC_IC16CFGR_IC16INT_Pos) + 1UL);
3418e8ba:	f3c0 4007 	ubfx	r0, r0, #16, #8
3418e8be:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC16CFGR, RCC_IC16CFGR_IC16SEL));
3418e8c0:	e68d      	b.n	3418e5de <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
  switch (LL_RCC_GetMDFClockSource(MDFxSource))
3418e8c2:	f5b3 2fc0 	cmp.w	r3, #393216	@ 0x60000
3418e8c6:	f000 8096 	beq.w	3418e9f6 <HAL_RCCEx_GetPeriphCLKFreq+0x902>
3418e8ca:	f5b3 2fe0 	cmp.w	r3, #458752	@ 0x70000
3418e8ce:	d00d      	beq.n	3418e8ec <HAL_RCCEx_GetPeriphCLKFreq+0x7f8>
3418e8d0:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
3418e8d4:	e6a4      	b.n	3418e620 <HAL_RCCEx_GetPeriphCLKFreq+0x52c>
      if (LL_RCC_IC7_IsEnabled() != 0U)
3418e8d6:	f7fc fd55 	bl	3418b384 <LL_RCC_IC7_IsEnabled>
3418e8da:	2800      	cmp	r0, #0
3418e8dc:	f43f ac4e 	beq.w	3418e17c <HAL_RCCEx_GetPeriphCLKFreq+0x88>
        ic_divider = LL_RCC_IC7_GetDivider();
3418e8e0:	f7fc fd58 	bl	3418b394 <LL_RCC_IC7_GetDivider>
  return (uint32_t)(READ_BIT(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL));
3418e8e4:	f8d5 30dc 	ldr.w	r3, [r5, #220]	@ 0xdc
3418e8e8:	4604      	mov	r4, r0
3418e8ea:	e678      	b.n	3418e5de <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
      adf_frequency = HAL_RCC_GetSysClockFreq() / (1UL << LL_RCC_GetTIMPrescaler());
3418e8ec:	f7fc f912 	bl	3418ab14 <HAL_RCC_GetSysClockFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_TIMPRE) >> RCC_CFGR2_TIMPRE_Pos);
3418e8f0:	6a6b      	ldr	r3, [r5, #36]	@ 0x24
3418e8f2:	f3c3 6301 	ubfx	r3, r3, #24, #2
3418e8f6:	e471      	b.n	3418e1dc <HAL_RCCEx_GetPeriphCLKFreq+0xe8>
  return (uint32_t)(READ_BIT(RCC->CCIPR7, RCC_CCIPR7_PSSISEL));
3418e8f8:	4a40      	ldr	r2, [pc, #256]	@ (3418e9fc <HAL_RCCEx_GetPeriphCLKFreq+0x908>)
3418e8fa:	f8d2 315c 	ldr.w	r3, [r2, #348]	@ 0x15c
3418e8fe:	f003 0330 	and.w	r3, r3, #48	@ 0x30
  switch (LL_RCC_GetPSSIClockSource(PSSIxSource))
3418e902:	2b20      	cmp	r3, #32
3418e904:	d00b      	beq.n	3418e91e <HAL_RCCEx_GetPeriphCLKFreq+0x82a>
3418e906:	f67f aeaa 	bls.w	3418e65e <HAL_RCCEx_GetPeriphCLKFreq+0x56a>
3418e90a:	2b30      	cmp	r3, #48	@ 0x30
3418e90c:	f47f ac36 	bne.w	3418e17c <HAL_RCCEx_GetPeriphCLKFreq+0x88>
      if (LL_RCC_HSI_IsReady() != 0U)
3418e910:	f7fc fd00 	bl	3418b314 <LL_RCC_HSI_IsReady>
3418e914:	2800      	cmp	r0, #0
3418e916:	f43f ac31 	beq.w	3418e17c <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3418e91a:	6c93      	ldr	r3, [r2, #72]	@ 0x48
3418e91c:	e7c0      	b.n	3418e8a0 <HAL_RCCEx_GetPeriphCLKFreq+0x7ac>
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC20EN) == RCC_DIVENR_IC20EN) ? 1UL : 0UL);
3418e91e:	f8d2 3240 	ldr.w	r3, [r2, #576]	@ 0x240
3418e922:	0319      	lsls	r1, r3, #12
3418e924:	f57f ac2a 	bpl.w	3418e17c <HAL_RCCEx_GetPeriphCLKFreq+0x88>
  return ((READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20INT) >> RCC_IC20CFGR_IC20INT_Pos) + 1UL);
3418e928:	f8d2 0110 	ldr.w	r0, [r2, #272]	@ 0x110
  return (uint32_t)(READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL));
3418e92c:	f8d2 3110 	ldr.w	r3, [r2, #272]	@ 0x110
  return ((READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20INT) >> RCC_IC20CFGR_IC20INT_Pos) + 1UL);
3418e930:	f3c0 4007 	ubfx	r0, r0, #16, #8
3418e934:	1c44      	adds	r4, r0, #1
  return (uint32_t)(READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL));
3418e936:	e652      	b.n	3418e5de <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
        switch (LL_RCC_IC20_GetSource())
3418e938:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418e93c:	f47f ac1e 	bne.w	3418e17c <HAL_RCCEx_GetPeriphCLKFreq+0x88>
            pssi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3418e940:	f7fe fb12 	bl	3418cf68 <HAL_RCCEx_GetPLL4CLKFreq>
3418e944:	e634      	b.n	3418e5b0 <HAL_RCCEx_GetPeriphCLKFreq+0x4bc>
            pssi_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3418e946:	f7fe facf 	bl	3418cee8 <HAL_RCCEx_GetPLL3CLKFreq>
3418e94a:	e631      	b.n	3418e5b0 <HAL_RCCEx_GetPeriphCLKFreq+0x4bc>
  return (uint32_t)(READ_BIT(RCC->CCIPR7, RCC_CCIPR7_RTCSEL));
3418e94c:	4a2b      	ldr	r2, [pc, #172]	@ (3418e9fc <HAL_RCCEx_GetPeriphCLKFreq+0x908>)
3418e94e:	f8d2 315c 	ldr.w	r3, [r2, #348]	@ 0x15c
3418e952:	f403 7340 	and.w	r3, r3, #768	@ 0x300
  switch (LL_RCC_GetRTCClockSource())
3418e956:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3418e95a:	d005      	beq.n	3418e968 <HAL_RCCEx_GetPeriphCLKFreq+0x874>
3418e95c:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
3418e960:	d009      	beq.n	3418e976 <HAL_RCCEx_GetPeriphCLKFreq+0x882>
3418e962:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3418e966:	e766      	b.n	3418e836 <HAL_RCCEx_GetPeriphCLKFreq+0x742>
  return ((READ_BIT(RCC->SR, RCC_SR_LSIRDY) != 0UL) ? 1UL : 0UL);
3418e968:	6853      	ldr	r3, [r2, #4]
      if (LL_RCC_LSI_IsReady() != 0U)
3418e96a:	07db      	lsls	r3, r3, #31
3418e96c:	f57f ac06 	bpl.w	3418e17c <HAL_RCCEx_GetPeriphCLKFreq+0x88>
        rtc_frequency = LSI_VALUE;
3418e970:	f44f 40fa 	mov.w	r0, #32000	@ 0x7d00
  return frequency;
3418e974:	e61e      	b.n	3418e5b4 <HAL_RCCEx_GetPeriphCLKFreq+0x4c0>
      if (LL_RCC_HSE_IsReady() != 0U)
3418e976:	f7fc fcc5 	bl	3418b304 <LL_RCC_HSE_IsReady>
3418e97a:	2800      	cmp	r0, #0
3418e97c:	f43f abfe 	beq.w	3418e17c <HAL_RCCEx_GetPeriphCLKFreq+0x88>
        uint32_t prescaler = (READ_BIT(RCC->CCIPR7, RCC_CCIPR7_RTCPRE) >> RCC_CCIPR7_RTCPRE_Pos) + 1U;
3418e980:	f8d2 315c 	ldr.w	r3, [r2, #348]	@ 0x15c
        rtc_frequency = HSE_VALUE / prescaler;
3418e984:	4827      	ldr	r0, [pc, #156]	@ (3418ea24 <HAL_RCCEx_GetPeriphCLKFreq+0x930>)
        uint32_t prescaler = (READ_BIT(RCC->CCIPR7, RCC_CCIPR7_RTCPRE) >> RCC_CCIPR7_RTCPRE_Pos) + 1U;
3418e986:	f3c3 3305 	ubfx	r3, r3, #12, #6
3418e98a:	3301      	adds	r3, #1
3418e98c:	e5a5      	b.n	3418e4da <HAL_RCCEx_GetPeriphCLKFreq+0x3e6>
      frequency = RCCEx_GetSAICLKFreq(LL_RCC_SAI2_CLKSOURCE);
3418e98e:	4826      	ldr	r0, [pc, #152]	@ (3418ea28 <HAL_RCCEx_GetPeriphCLKFreq+0x934>)
3418e990:	e49e      	b.n	3418e2d0 <HAL_RCCEx_GetPeriphCLKFreq+0x1dc>
      frequency = RCCEx_GetSDMMCCLKFreq(LL_RCC_SDMMC2_CLKSOURCE);
3418e992:	4826      	ldr	r0, [pc, #152]	@ (3418ea2c <HAL_RCCEx_GetPeriphCLKFreq+0x938>)
3418e994:	e4ce      	b.n	3418e334 <HAL_RCCEx_GetPeriphCLKFreq+0x240>
}
3418e996:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetSPDIFRXCLKFreq(LL_RCC_SPDIFRX1_CLKSOURCE);
3418e99a:	f7fe bbab 	b.w	3418d0f4 <RCCEx_GetSPDIFRXCLKFreq.constprop.0>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI1_CLKSOURCE);
3418e99e:	4824      	ldr	r0, [pc, #144]	@ (3418ea30 <HAL_RCCEx_GetPeriphCLKFreq+0x93c>)
}
3418e9a0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI6_CLKSOURCE);
3418e9a4:	f7fe bf30 	b.w	3418d808 <RCCEx_GetSPICLKFreq>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI2_CLKSOURCE);
3418e9a8:	4822      	ldr	r0, [pc, #136]	@ (3418ea34 <HAL_RCCEx_GetPeriphCLKFreq+0x940>)
3418e9aa:	e7f9      	b.n	3418e9a0 <HAL_RCCEx_GetPeriphCLKFreq+0x8ac>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI4_CLKSOURCE);
3418e9ac:	4822      	ldr	r0, [pc, #136]	@ (3418ea38 <HAL_RCCEx_GetPeriphCLKFreq+0x944>)
3418e9ae:	e7f7      	b.n	3418e9a0 <HAL_RCCEx_GetPeriphCLKFreq+0x8ac>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI6_CLKSOURCE);
3418e9b0:	4822      	ldr	r0, [pc, #136]	@ (3418ea3c <HAL_RCCEx_GetPeriphCLKFreq+0x948>)
3418e9b2:	e7f5      	b.n	3418e9a0 <HAL_RCCEx_GetPeriphCLKFreq+0x8ac>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART1_CLKSOURCE);
3418e9b4:	4822      	ldr	r0, [pc, #136]	@ (3418ea40 <HAL_RCCEx_GetPeriphCLKFreq+0x94c>)
}
3418e9b6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART10_CLKSOURCE);
3418e9ba:	f7fe bd0d 	b.w	3418d3d8 <RCCEx_GetUSARTCLKFreq>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART2_CLKSOURCE);
3418e9be:	4821      	ldr	r0, [pc, #132]	@ (3418ea44 <HAL_RCCEx_GetPeriphCLKFreq+0x950>)
3418e9c0:	e7f9      	b.n	3418e9b6 <HAL_RCCEx_GetPeriphCLKFreq+0x8c2>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART3_CLKSOURCE);
3418e9c2:	4821      	ldr	r0, [pc, #132]	@ (3418ea48 <HAL_RCCEx_GetPeriphCLKFreq+0x954>)
3418e9c4:	e7f7      	b.n	3418e9b6 <HAL_RCCEx_GetPeriphCLKFreq+0x8c2>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART5_CLKSOURCE);
3418e9c6:	4821      	ldr	r0, [pc, #132]	@ (3418ea4c <HAL_RCCEx_GetPeriphCLKFreq+0x958>)
3418e9c8:	e4ed      	b.n	3418e3a6 <HAL_RCCEx_GetPeriphCLKFreq+0x2b2>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART7_CLKSOURCE);
3418e9ca:	4821      	ldr	r0, [pc, #132]	@ (3418ea50 <HAL_RCCEx_GetPeriphCLKFreq+0x95c>)
3418e9cc:	e4eb      	b.n	3418e3a6 <HAL_RCCEx_GetPeriphCLKFreq+0x2b2>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART8_CLKSOURCE);
3418e9ce:	4821      	ldr	r0, [pc, #132]	@ (3418ea54 <HAL_RCCEx_GetPeriphCLKFreq+0x960>)
3418e9d0:	e4e9      	b.n	3418e3a6 <HAL_RCCEx_GetPeriphCLKFreq+0x2b2>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART9_CLKSOURCE);
3418e9d2:	4821      	ldr	r0, [pc, #132]	@ (3418ea58 <HAL_RCCEx_GetPeriphCLKFreq+0x964>)
3418e9d4:	e4e7      	b.n	3418e3a6 <HAL_RCCEx_GetPeriphCLKFreq+0x2b2>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART10_CLKSOURCE);
3418e9d6:	4821      	ldr	r0, [pc, #132]	@ (3418ea5c <HAL_RCCEx_GetPeriphCLKFreq+0x968>)
3418e9d8:	e7ed      	b.n	3418e9b6 <HAL_RCCEx_GetPeriphCLKFreq+0x8c2>
      frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY1_CLKSOURCE);
3418e9da:	4821      	ldr	r0, [pc, #132]	@ (3418ea60 <HAL_RCCEx_GetPeriphCLKFreq+0x96c>)
}
3418e9dc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY2_CLKSOURCE);
3418e9e0:	f7fe bc62 	b.w	3418d2a8 <RCCEx_GetOTGPHYCLKFreq>
      frequency = RCCEx_GetOTGPHYCKREFCLKFreq(LL_RCC_OTGPHY2CKREF_CLKSOURCE);
3418e9e4:	481f      	ldr	r0, [pc, #124]	@ (3418ea64 <HAL_RCCEx_GetPeriphCLKFreq+0x970>)
3418e9e6:	e534      	b.n	3418e452 <HAL_RCCEx_GetPeriphCLKFreq+0x35e>
      frequency = RCCEx_GetXSPICLKFreq(LL_RCC_XSPI1_CLKSOURCE);
3418e9e8:	481f      	ldr	r0, [pc, #124]	@ (3418ea68 <HAL_RCCEx_GetPeriphCLKFreq+0x974>)
}
3418e9ea:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      frequency = RCCEx_GetXSPICLKFreq(LL_RCC_XSPI3_CLKSOURCE);
3418e9ee:	f7fe bbe1 	b.w	3418d1b4 <RCCEx_GetXSPICLKFreq>
      frequency = RCCEx_GetXSPICLKFreq(LL_RCC_XSPI2_CLKSOURCE);
3418e9f2:	481e      	ldr	r0, [pc, #120]	@ (3418ea6c <HAL_RCCEx_GetPeriphCLKFreq+0x978>)
3418e9f4:	e7f9      	b.n	3418e9ea <HAL_RCCEx_GetPeriphCLKFreq+0x8f6>
  switch (LL_RCC_GetMDFClockSource(MDFxSource))
3418e9f6:	481e      	ldr	r0, [pc, #120]	@ (3418ea70 <HAL_RCCEx_GetPeriphCLKFreq+0x97c>)
3418e9f8:	e5dc      	b.n	3418e5b4 <HAL_RCCEx_GetPeriphCLKFreq+0x4c0>
3418e9fa:	bf00      	nop
3418e9fc:	56028000 	.word	0x56028000
3418ea00:	0700000c 	.word	0x0700000c
3418ea04:	0700040c 	.word	0x0700040c
3418ea08:	0700080c 	.word	0x0700080c
3418ea0c:	0700100c 	.word	0x0700100c
3418ea10:	0700082c 	.word	0x0700082c
3418ea14:	07000c2c 	.word	0x07000c2c
3418ea18:	0700102c 	.word	0x0700102c
3418ea1c:	0700142c 	.word	0x0700142c
3418ea20:	03d09000 	.word	0x03d09000
3418ea24:	02dc6c00 	.word	0x02dc6c00
3418ea28:	07001818 	.word	0x07001818
3418ea2c:	0300041c 	.word	0x0300041c
3418ea30:	07000420 	.word	0x07000420
3418ea34:	07000820 	.word	0x07000820
3418ea38:	07001020 	.word	0x07001020
3418ea3c:	07001820 	.word	0x07001820
3418ea40:	07000030 	.word	0x07000030
3418ea44:	07000430 	.word	0x07000430
3418ea48:	07000830 	.word	0x07000830
3418ea4c:	07001030 	.word	0x07001030
3418ea50:	07001830 	.word	0x07001830
3418ea54:	07001c30 	.word	0x07001c30
3418ea58:	07000034 	.word	0x07000034
3418ea5c:	07000434 	.word	0x07000434
3418ea60:	03000c14 	.word	0x03000c14
3418ea64:	01001814 	.word	0x01001814
3418ea68:	03000014 	.word	0x03000014
3418ea6c:	03000414 	.word	0x03000414
3418ea70:	00bb8000 	.word	0x00bb8000

3418ea74 <HAL_RIF_RIMC_ConfigMasterAttributes>:
  *         This parameter can be one of @ref RIF_MASTER_INDEX
  * @param  pConfig Pointer on Master Isolation configuration structure
  * @retval None
  */
void HAL_RIF_RIMC_ConfigMasterAttributes(uint32_t MasterId, const RIMC_MasterConfig_t *pConfig)
{
3418ea74:	b480      	push	{r7}
3418ea76:	b089      	sub	sp, #36	@ 0x24
3418ea78:	af00      	add	r7, sp, #0
3418ea7a:	6078      	str	r0, [r7, #4]
3418ea7c:	6039      	str	r1, [r7, #0]
  assert_param(IS_RIF_MASTER_INDEX(MasterId));
  assert_param(IS_RIF_SINGLE_CID(pConfig->MasterCID));
  assert_param(IS_RIF_MASTER_CID(pConfig->MasterCID));
  assert_param(IS_RIF_SEC_PRIV_ATTRIBUTE(pConfig->SecPriv));

  master_cid = POSITION_VAL(pConfig->MasterCID);
3418ea7e:	683b      	ldr	r3, [r7, #0]
3418ea80:	681b      	ldr	r3, [r3, #0]
3418ea82:	613b      	str	r3, [r7, #16]
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
3418ea84:	693b      	ldr	r3, [r7, #16]
3418ea86:	fa93 f3a3 	rbit	r3, r3
3418ea8a:	60fb      	str	r3, [r7, #12]
  return result;
3418ea8c:	68fb      	ldr	r3, [r7, #12]
3418ea8e:	617b      	str	r3, [r7, #20]
  if (value == 0U)
3418ea90:	697b      	ldr	r3, [r7, #20]
3418ea92:	2b00      	cmp	r3, #0
3418ea94:	d101      	bne.n	3418ea9a <HAL_RIF_RIMC_ConfigMasterAttributes+0x26>
    return 32U;
3418ea96:	2320      	movs	r3, #32
3418ea98:	e003      	b.n	3418eaa2 <HAL_RIF_RIMC_ConfigMasterAttributes+0x2e>
  return __builtin_clz(value);
3418ea9a:	697b      	ldr	r3, [r7, #20]
3418ea9c:	fab3 f383 	clz	r3, r3
3418eaa0:	b2db      	uxtb	r3, r3
3418eaa2:	61fb      	str	r3, [r7, #28]
  rimc_attr_val = RIFSC->RIMC_ATTRx[MasterId];
3418eaa4:	4a10      	ldr	r2, [pc, #64]	@ (3418eae8 <HAL_RIF_RIMC_ConfigMasterAttributes+0x74>)
3418eaa6:	687b      	ldr	r3, [r7, #4]
3418eaa8:	f503 7341 	add.w	r3, r3, #772	@ 0x304
3418eaac:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
3418eab0:	61bb      	str	r3, [r7, #24]
  rimc_attr_val &= (~(RIFSC_RIMC_ATTRx_MCID | RIFSC_RIMC_ATTRx_MPRIV | RIFSC_RIMC_ATTRx_MSEC));
3418eab2:	69bb      	ldr	r3, [r7, #24]
3418eab4:	f423 735c 	bic.w	r3, r3, #880	@ 0x370
3418eab8:	61bb      	str	r3, [r7, #24]
  rimc_attr_val |= ((master_cid << RIFSC_RIMC_ATTRx_MCID_Pos) | (pConfig->SecPriv << RIFSC_RIMC_ATTRx_MSEC_Pos));
3418eaba:	69fb      	ldr	r3, [r7, #28]
3418eabc:	011a      	lsls	r2, r3, #4
3418eabe:	683b      	ldr	r3, [r7, #0]
3418eac0:	685b      	ldr	r3, [r3, #4]
3418eac2:	021b      	lsls	r3, r3, #8
3418eac4:	4313      	orrs	r3, r2
3418eac6:	69ba      	ldr	r2, [r7, #24]
3418eac8:	4313      	orrs	r3, r2
3418eaca:	61bb      	str	r3, [r7, #24]
  RIFSC->RIMC_ATTRx[MasterId] = rimc_attr_val;
3418eacc:	4906      	ldr	r1, [pc, #24]	@ (3418eae8 <HAL_RIF_RIMC_ConfigMasterAttributes+0x74>)
3418eace:	687b      	ldr	r3, [r7, #4]
3418ead0:	f503 7341 	add.w	r3, r3, #772	@ 0x304
3418ead4:	69ba      	ldr	r2, [r7, #24]
3418ead6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
3418eada:	bf00      	nop
3418eadc:	3724      	adds	r7, #36	@ 0x24
3418eade:	46bd      	mov	sp, r7
3418eae0:	f85d 7b04 	ldr.w	r7, [sp], #4
3418eae4:	4770      	bx	lr
3418eae6:	bf00      	nop
3418eae8:	54024000 	.word	0x54024000

3418eaec <HAL_RIF_RISC_SetSlaveSecureAttributes>:
  * @param  SecPriv specifies the security and privilege attributes of the peripheral.
  *         This parameter can be one or a combination of @ref RIF_SEC_PRIV
  * @retval None
  */
void HAL_RIF_RISC_SetSlaveSecureAttributes(uint32_t PeriphId, uint32_t SecPriv)
{
3418eaec:	b480      	push	{r7}
3418eaee:	b085      	sub	sp, #20
3418eaf0:	af00      	add	r7, sp, #0
3418eaf2:	6078      	str	r0, [r7, #4]
3418eaf4:	6039      	str	r1, [r7, #0]
  __IO uint32_t sec_reg_val;

  assert_param(IS_RIF_RISC_PERIPH_INDEX(PeriphId) || IS_RIF_RCC_PERIPH_INDEX(PeriphId));
  assert_param(IS_RIF_SEC_PRIV_ATTRIBUTE(SecPriv));

  sec_reg_val = RIFSC->RISC_SECCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT];
3418eaf6:	4a25      	ldr	r2, [pc, #148]	@ (3418eb8c <HAL_RIF_RISC_SetSlaveSecureAttributes+0xa0>)
3418eaf8:	687b      	ldr	r3, [r7, #4]
3418eafa:	0f1b      	lsrs	r3, r3, #28
3418eafc:	3304      	adds	r3, #4
3418eafe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
3418eb02:	60fb      	str	r3, [r7, #12]
  sec_reg_val &= (~(1U << (PeriphId & RIF_PERIPH_BIT_POSITION)));
3418eb04:	687b      	ldr	r3, [r7, #4]
3418eb06:	f003 031f 	and.w	r3, r3, #31
3418eb0a:	2201      	movs	r2, #1
3418eb0c:	fa02 f303 	lsl.w	r3, r2, r3
3418eb10:	43da      	mvns	r2, r3
3418eb12:	68fb      	ldr	r3, [r7, #12]
3418eb14:	4013      	ands	r3, r2
3418eb16:	60fb      	str	r3, [r7, #12]
  sec_reg_val |= ((SecPriv & RIF_ATTRIBUTE_SEC) << (PeriphId & RIF_PERIPH_BIT_POSITION));
3418eb18:	683b      	ldr	r3, [r7, #0]
3418eb1a:	f003 0201 	and.w	r2, r3, #1
3418eb1e:	687b      	ldr	r3, [r7, #4]
3418eb20:	f003 031f 	and.w	r3, r3, #31
3418eb24:	409a      	lsls	r2, r3
3418eb26:	68fb      	ldr	r3, [r7, #12]
3418eb28:	4313      	orrs	r3, r2
3418eb2a:	60fb      	str	r3, [r7, #12]
  RIFSC->RISC_SECCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT] = sec_reg_val;
3418eb2c:	4917      	ldr	r1, [pc, #92]	@ (3418eb8c <HAL_RIF_RISC_SetSlaveSecureAttributes+0xa0>)
3418eb2e:	687b      	ldr	r3, [r7, #4]
3418eb30:	0f1b      	lsrs	r3, r3, #28
3418eb32:	68fa      	ldr	r2, [r7, #12]
3418eb34:	3304      	adds	r3, #4
3418eb36:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

  sec_reg_val = RIFSC->RISC_PRIVCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT];
3418eb3a:	4a14      	ldr	r2, [pc, #80]	@ (3418eb8c <HAL_RIF_RISC_SetSlaveSecureAttributes+0xa0>)
3418eb3c:	687b      	ldr	r3, [r7, #4]
3418eb3e:	0f1b      	lsrs	r3, r3, #28
3418eb40:	330c      	adds	r3, #12
3418eb42:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
3418eb46:	60fb      	str	r3, [r7, #12]
  sec_reg_val &= (~(1U << (PeriphId & RIF_PERIPH_BIT_POSITION)));
3418eb48:	687b      	ldr	r3, [r7, #4]
3418eb4a:	f003 031f 	and.w	r3, r3, #31
3418eb4e:	2201      	movs	r2, #1
3418eb50:	fa02 f303 	lsl.w	r3, r2, r3
3418eb54:	43da      	mvns	r2, r3
3418eb56:	68fb      	ldr	r3, [r7, #12]
3418eb58:	4013      	ands	r3, r2
3418eb5a:	60fb      	str	r3, [r7, #12]
  sec_reg_val |= (((SecPriv & RIF_ATTRIBUTE_PRIV) >> 1U) << (PeriphId & RIF_PERIPH_BIT_POSITION));
3418eb5c:	683b      	ldr	r3, [r7, #0]
3418eb5e:	085b      	lsrs	r3, r3, #1
3418eb60:	f003 0201 	and.w	r2, r3, #1
3418eb64:	687b      	ldr	r3, [r7, #4]
3418eb66:	f003 031f 	and.w	r3, r3, #31
3418eb6a:	409a      	lsls	r2, r3
3418eb6c:	68fb      	ldr	r3, [r7, #12]
3418eb6e:	4313      	orrs	r3, r2
3418eb70:	60fb      	str	r3, [r7, #12]
  RIFSC->RISC_PRIVCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT] = sec_reg_val;
3418eb72:	4906      	ldr	r1, [pc, #24]	@ (3418eb8c <HAL_RIF_RISC_SetSlaveSecureAttributes+0xa0>)
3418eb74:	687b      	ldr	r3, [r7, #4]
3418eb76:	0f1b      	lsrs	r3, r3, #28
3418eb78:	68fa      	ldr	r2, [r7, #12]
3418eb7a:	330c      	adds	r3, #12
3418eb7c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
3418eb80:	bf00      	nop
3418eb82:	3714      	adds	r7, #20
3418eb84:	46bd      	mov	sp, r7
3418eb86:	f85d 7b04 	ldr.w	r7, [sp], #4
3418eb8a:	4770      	bx	lr
3418eb8c:	54024000 	.word	0x54024000

3418eb90 <HAL_SD_Init>:
            SD_HandleTypeDef and create the associated handle.
  * @param  hsd: Pointer to the SD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_Init(SD_HandleTypeDef *hsd)
{
3418eb90:	b580      	push	{r7, lr}
3418eb92:	b08a      	sub	sp, #40	@ 0x28
3418eb94:	af00      	add	r7, sp, #0
3418eb96:	6078      	str	r0, [r7, #4]
  uint32_t speedgrade;
  uint32_t unitsize;
  uint32_t tickstart;

  /* Check the SD handle allocation */
  if (hsd == NULL)
3418eb98:	687b      	ldr	r3, [r7, #4]
3418eb9a:	2b00      	cmp	r3, #0
3418eb9c:	d101      	bne.n	3418eba2 <HAL_SD_Init+0x12>
  {
    return HAL_ERROR;
3418eb9e:	2301      	movs	r3, #1
3418eba0:	e075      	b.n	3418ec8e <HAL_SD_Init+0xfe>
  assert_param(IS_SDMMC_CLOCK_POWER_SAVE(hsd->Init.ClockPowerSave));
  assert_param(IS_SDMMC_BUS_WIDE(hsd->Init.BusWide));
  assert_param(IS_SDMMC_HARDWARE_FLOW_CONTROL(hsd->Init.HardwareFlowControl));
  assert_param(IS_SDMMC_CLKDIV(hsd->Init.ClockDiv));

  if (hsd->State == HAL_SD_STATE_RESET)
3418eba2:	687b      	ldr	r3, [r7, #4]
3418eba4:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
3418eba8:	b2db      	uxtb	r3, r3
3418ebaa:	2b00      	cmp	r3, #0
3418ebac:	d105      	bne.n	3418ebba <HAL_SD_Init+0x2a>
  {
    /* Allocate lock resource and initialize it */
    hsd->Lock = HAL_UNLOCKED;
3418ebae:	687b      	ldr	r3, [r7, #4]
3418ebb0:	2200      	movs	r2, #0
3418ebb2:	761a      	strb	r2, [r3, #24]

    /* Init the low level hardware */
    hsd->MspInitCallback(hsd);
#else
    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    HAL_SD_MspInit(hsd);
3418ebb4:	6878      	ldr	r0, [r7, #4]
3418ebb6:	f7f2 fe37 	bl	34181828 <HAL_SD_MspInit>
#endif /* USE_HAL_SD_REGISTER_CALLBACKS */
  }

  hsd->State = HAL_SD_STATE_PROGRAMMING;
3418ebba:	687b      	ldr	r3, [r7, #4]
3418ebbc:	2204      	movs	r2, #4
3418ebbe:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30

  /* Initialize the Card parameters */
  if (HAL_SD_InitCard(hsd) != HAL_OK)
3418ebc2:	6878      	ldr	r0, [r7, #4]
3418ebc4:	f000 f868 	bl	3418ec98 <HAL_SD_InitCard>
3418ebc8:	4603      	mov	r3, r0
3418ebca:	2b00      	cmp	r3, #0
3418ebcc:	d001      	beq.n	3418ebd2 <HAL_SD_Init+0x42>
  {
    return HAL_ERROR;
3418ebce:	2301      	movs	r3, #1
3418ebd0:	e05d      	b.n	3418ec8e <HAL_SD_Init+0xfe>
  }

  if (HAL_SD_GetCardStatus(hsd, &CardStatus) != HAL_OK)
3418ebd2:	f107 0308 	add.w	r3, r7, #8
3418ebd6:	4619      	mov	r1, r3
3418ebd8:	6878      	ldr	r0, [r7, #4]
3418ebda:	f000 fdb1 	bl	3418f740 <HAL_SD_GetCardStatus>
3418ebde:	4603      	mov	r3, r0
3418ebe0:	2b00      	cmp	r3, #0
3418ebe2:	d001      	beq.n	3418ebe8 <HAL_SD_Init+0x58>
  {
    return HAL_ERROR;
3418ebe4:	2301      	movs	r3, #1
3418ebe6:	e052      	b.n	3418ec8e <HAL_SD_Init+0xfe>
  }
  /* Get Initial Card Speed from Card Status*/
  speedgrade = CardStatus.UhsSpeedGrade;
3418ebe8:	7e3b      	ldrb	r3, [r7, #24]
3418ebea:	b2db      	uxtb	r3, r3
3418ebec:	627b      	str	r3, [r7, #36]	@ 0x24
  unitsize = CardStatus.UhsAllocationUnitSize;
3418ebee:	7e7b      	ldrb	r3, [r7, #25]
3418ebf0:	b2db      	uxtb	r3, r3
3418ebf2:	623b      	str	r3, [r7, #32]
  if ((hsd->SdCard.CardType == CARD_SDHC_SDXC) && ((speedgrade != 0U) || (unitsize != 0U)))
3418ebf4:	687b      	ldr	r3, [r7, #4]
3418ebf6:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3418ebf8:	2b01      	cmp	r3, #1
3418ebfa:	d10a      	bne.n	3418ec12 <HAL_SD_Init+0x82>
3418ebfc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3418ebfe:	2b00      	cmp	r3, #0
3418ec00:	d102      	bne.n	3418ec08 <HAL_SD_Init+0x78>
3418ec02:	6a3b      	ldr	r3, [r7, #32]
3418ec04:	2b00      	cmp	r3, #0
3418ec06:	d004      	beq.n	3418ec12 <HAL_SD_Init+0x82>
  {
    hsd->SdCard.CardSpeed = CARD_ULTRA_HIGH_SPEED;
3418ec08:	687b      	ldr	r3, [r7, #4]
3418ec0a:	f44f 7200 	mov.w	r2, #512	@ 0x200
3418ec0e:	659a      	str	r2, [r3, #88]	@ 0x58
3418ec10:	e00b      	b.n	3418ec2a <HAL_SD_Init+0x9a>
  }
  else
  {
    if (hsd->SdCard.CardType == CARD_SDHC_SDXC)
3418ec12:	687b      	ldr	r3, [r7, #4]
3418ec14:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3418ec16:	2b01      	cmp	r3, #1
3418ec18:	d104      	bne.n	3418ec24 <HAL_SD_Init+0x94>
    {
      hsd->SdCard.CardSpeed  = CARD_HIGH_SPEED;
3418ec1a:	687b      	ldr	r3, [r7, #4]
3418ec1c:	f44f 7280 	mov.w	r2, #256	@ 0x100
3418ec20:	659a      	str	r2, [r3, #88]	@ 0x58
3418ec22:	e002      	b.n	3418ec2a <HAL_SD_Init+0x9a>
    }
    else
    {
      hsd->SdCard.CardSpeed  = CARD_NORMAL_SPEED;
3418ec24:	687b      	ldr	r3, [r7, #4]
3418ec26:	2200      	movs	r2, #0
3418ec28:	659a      	str	r2, [r3, #88]	@ 0x58
    }

  }
  /* Configure the bus wide */
  if (HAL_SD_ConfigWideBusOperation(hsd, hsd->Init.BusWide) != HAL_OK)
3418ec2a:	687b      	ldr	r3, [r7, #4]
3418ec2c:	68db      	ldr	r3, [r3, #12]
3418ec2e:	4619      	mov	r1, r3
3418ec30:	6878      	ldr	r0, [r7, #4]
3418ec32:	f000 fe6f 	bl	3418f914 <HAL_SD_ConfigWideBusOperation>
3418ec36:	4603      	mov	r3, r0
3418ec38:	2b00      	cmp	r3, #0
3418ec3a:	d001      	beq.n	3418ec40 <HAL_SD_Init+0xb0>
  {
    return HAL_ERROR;
3418ec3c:	2301      	movs	r3, #1
3418ec3e:	e026      	b.n	3418ec8e <HAL_SD_Init+0xfe>
  }

  /* Verify that SD card is ready to use after Initialization */
  tickstart = HAL_GetTick();
3418ec40:	f7f6 fcba 	bl	341855b8 <HAL_GetTick>
3418ec44:	61f8      	str	r0, [r7, #28]
  while ((HAL_SD_GetCardState(hsd) != HAL_SD_CARD_TRANSFER))
3418ec46:	e011      	b.n	3418ec6c <HAL_SD_Init+0xdc>
  {
    if ((HAL_GetTick() - tickstart) >=  SDMMC_SWDATATIMEOUT)
3418ec48:	f7f6 fcb6 	bl	341855b8 <HAL_GetTick>
3418ec4c:	4602      	mov	r2, r0
3418ec4e:	69fb      	ldr	r3, [r7, #28]
3418ec50:	1ad3      	subs	r3, r2, r3
3418ec52:	f1b3 3fff 	cmp.w	r3, #4294967295
3418ec56:	d109      	bne.n	3418ec6c <HAL_SD_Init+0xdc>
    {
      hsd->ErrorCode = HAL_SD_ERROR_TIMEOUT;
3418ec58:	687b      	ldr	r3, [r7, #4]
3418ec5a:	f04f 4200 	mov.w	r2, #2147483648	@ 0x80000000
3418ec5e:	635a      	str	r2, [r3, #52]	@ 0x34
      hsd->State = HAL_SD_STATE_READY;
3418ec60:	687b      	ldr	r3, [r7, #4]
3418ec62:	2201      	movs	r2, #1
3418ec64:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
      return HAL_TIMEOUT;
3418ec68:	2303      	movs	r3, #3
3418ec6a:	e010      	b.n	3418ec8e <HAL_SD_Init+0xfe>
  while ((HAL_SD_GetCardState(hsd) != HAL_SD_CARD_TRANSFER))
3418ec6c:	6878      	ldr	r0, [r7, #4]
3418ec6e:	f000 ff73 	bl	3418fb58 <HAL_SD_GetCardState>
3418ec72:	4603      	mov	r3, r0
3418ec74:	2b04      	cmp	r3, #4
3418ec76:	d1e7      	bne.n	3418ec48 <HAL_SD_Init+0xb8>
    }
  }

  /* Initialize the error code */
  hsd->ErrorCode = HAL_SD_ERROR_NONE;
3418ec78:	687b      	ldr	r3, [r7, #4]
3418ec7a:	2200      	movs	r2, #0
3418ec7c:	635a      	str	r2, [r3, #52]	@ 0x34

  /* Initialize the SD operation */
  hsd->Context = SD_CONTEXT_NONE;
3418ec7e:	687b      	ldr	r3, [r7, #4]
3418ec80:	2200      	movs	r2, #0
3418ec82:	62da      	str	r2, [r3, #44]	@ 0x2c

  /* Initialize the SD state */
  hsd->State = HAL_SD_STATE_READY;
3418ec84:	687b      	ldr	r3, [r7, #4]
3418ec86:	2201      	movs	r2, #1
3418ec88:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30

  return HAL_OK;
3418ec8c:	2300      	movs	r3, #0
}
3418ec8e:	4618      	mov	r0, r3
3418ec90:	3728      	adds	r7, #40	@ 0x28
3418ec92:	46bd      	mov	sp, r7
3418ec94:	bd80      	pop	{r7, pc}
	...

3418ec98 <HAL_SD_InitCard>:
  * @note   This function initializes the SD card. It could be used when a card
            re-initialization is needed.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_InitCard(SD_HandleTypeDef *hsd)
{
3418ec98:	b590      	push	{r4, r7, lr}
3418ec9a:	b08d      	sub	sp, #52	@ 0x34
3418ec9c:	af02      	add	r7, sp, #8
3418ec9e:	6078      	str	r0, [r7, #4]
  uint32_t errorstate;
  SD_InitTypeDef Init;
  uint32_t sdmmc_clk;

  /* Default SDMMC peripheral configuration for SD card initialization */
  Init.ClockEdge           = SDMMC_CLOCK_EDGE_RISING;
3418eca0:	2300      	movs	r3, #0
3418eca2:	60fb      	str	r3, [r7, #12]
  Init.ClockPowerSave      = SDMMC_CLOCK_POWER_SAVE_DISABLE;
3418eca4:	2300      	movs	r3, #0
3418eca6:	613b      	str	r3, [r7, #16]
  Init.BusWide             = SDMMC_BUS_WIDE_1B;
3418eca8:	2300      	movs	r3, #0
3418ecaa:	617b      	str	r3, [r7, #20]
  Init.HardwareFlowControl = SDMMC_HARDWARE_FLOW_CONTROL_DISABLE;
3418ecac:	2300      	movs	r3, #0
3418ecae:	61bb      	str	r3, [r7, #24]

  /* Init Clock should be less or equal to 400Khz*/
  if (hsd->Instance == SDMMC1)
3418ecb0:	687b      	ldr	r3, [r7, #4]
3418ecb2:	681b      	ldr	r3, [r3, #0]
3418ecb4:	4a4d      	ldr	r2, [pc, #308]	@ (3418edec <HAL_SD_InitCard+0x154>)
3418ecb6:	4293      	cmp	r3, r2
3418ecb8:	d107      	bne.n	3418ecca <HAL_SD_InitCard+0x32>
  {
    sdmmc_clk = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SDMMC1);
3418ecba:	f04f 4080 	mov.w	r0, #1073741824	@ 0x40000000
3418ecbe:	f04f 0100 	mov.w	r1, #0
3418ecc2:	f7ff fa17 	bl	3418e0f4 <HAL_RCCEx_GetPeriphCLKFreq>
3418ecc6:	6278      	str	r0, [r7, #36]	@ 0x24
3418ecc8:	e00e      	b.n	3418ece8 <HAL_SD_InitCard+0x50>
  }
  else if (hsd->Instance == SDMMC2)
3418ecca:	687b      	ldr	r3, [r7, #4]
3418eccc:	681b      	ldr	r3, [r3, #0]
3418ecce:	4a48      	ldr	r2, [pc, #288]	@ (3418edf0 <HAL_SD_InitCard+0x158>)
3418ecd0:	4293      	cmp	r3, r2
3418ecd2:	d107      	bne.n	3418ece4 <HAL_SD_InitCard+0x4c>
  {
    sdmmc_clk = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SDMMC2);
3418ecd4:	f04f 4000 	mov.w	r0, #2147483648	@ 0x80000000
3418ecd8:	f04f 0100 	mov.w	r1, #0
3418ecdc:	f7ff fa0a 	bl	3418e0f4 <HAL_RCCEx_GetPeriphCLKFreq>
3418ece0:	6278      	str	r0, [r7, #36]	@ 0x24
3418ece2:	e001      	b.n	3418ece8 <HAL_SD_InitCard+0x50>
  }
  else
  {
    sdmmc_clk = 0;
3418ece4:	2300      	movs	r3, #0
3418ece6:	627b      	str	r3, [r7, #36]	@ 0x24
  }
  if (sdmmc_clk == 0U)
3418ece8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3418ecea:	2b00      	cmp	r3, #0
3418ecec:	d109      	bne.n	3418ed02 <HAL_SD_InitCard+0x6a>
  {
    hsd->State = HAL_SD_STATE_READY;
3418ecee:	687b      	ldr	r3, [r7, #4]
3418ecf0:	2201      	movs	r2, #1
3418ecf2:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
    hsd->ErrorCode = SDMMC_ERROR_INVALID_PARAMETER;
3418ecf6:	687b      	ldr	r3, [r7, #4]
3418ecf8:	f04f 6200 	mov.w	r2, #134217728	@ 0x8000000
3418ecfc:	635a      	str	r2, [r3, #52]	@ 0x34
    return HAL_ERROR;
3418ecfe:	2301      	movs	r3, #1
3418ed00:	e070      	b.n	3418ede4 <HAL_SD_InitCard+0x14c>
  }
  Init.ClockDiv = sdmmc_clk / (2U * SD_INIT_FREQ);
3418ed02:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3418ed04:	0a1b      	lsrs	r3, r3, #8
3418ed06:	4a3b      	ldr	r2, [pc, #236]	@ (3418edf4 <HAL_SD_InitCard+0x15c>)
3418ed08:	fba2 2303 	umull	r2, r3, r2, r3
3418ed0c:	091b      	lsrs	r3, r3, #4
3418ed0e:	61fb      	str	r3, [r7, #28]
  /* Set Transceiver polarity */
  hsd->Instance->POWER |= SDMMC_POWER_DIRPOL;
#endif /* USE_SD_TRANSCEIVER  */

  /* Initialize SDMMC peripheral interface with default configuration */
  (void)SDMMC_Init(hsd->Instance, Init);
3418ed10:	687b      	ldr	r3, [r7, #4]
3418ed12:	681c      	ldr	r4, [r3, #0]
3418ed14:	466a      	mov	r2, sp
3418ed16:	f107 0318 	add.w	r3, r7, #24
3418ed1a:	e893 0003 	ldmia.w	r3, {r0, r1}
3418ed1e:	e882 0003 	stmia.w	r2, {r0, r1}
3418ed22:	f107 030c 	add.w	r3, r7, #12
3418ed26:	cb0e      	ldmia	r3, {r1, r2, r3}
3418ed28:	4620      	mov	r0, r4
3418ed2a:	f002 fbdf 	bl	341914ec <SDMMC_Init>

  /* Set Power State to ON */
  (void)SDMMC_PowerState_ON(hsd->Instance);
3418ed2e:	687b      	ldr	r3, [r7, #4]
3418ed30:	681b      	ldr	r3, [r3, #0]
3418ed32:	4618      	mov	r0, r3
3418ed34:	f002 fc22 	bl	3419157c <SDMMC_PowerState_ON>

  /* wait 74 Cycles: required power up waiting time before starting
     the SD initialization sequence */
  if (Init.ClockDiv != 0U)
3418ed38:	69fb      	ldr	r3, [r7, #28]
3418ed3a:	2b00      	cmp	r3, #0
3418ed3c:	d005      	beq.n	3418ed4a <HAL_SD_InitCard+0xb2>
  {
    sdmmc_clk = sdmmc_clk / (2U * Init.ClockDiv);
3418ed3e:	69fb      	ldr	r3, [r7, #28]
3418ed40:	005b      	lsls	r3, r3, #1
3418ed42:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
3418ed44:	fbb2 f3f3 	udiv	r3, r2, r3
3418ed48:	627b      	str	r3, [r7, #36]	@ 0x24
  }

  if (sdmmc_clk != 0U)
3418ed4a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3418ed4c:	2b00      	cmp	r3, #0
3418ed4e:	d007      	beq.n	3418ed60 <HAL_SD_InitCard+0xc8>
  {
    HAL_Delay(1U + (74U * 1000U / (sdmmc_clk)));
3418ed50:	4a29      	ldr	r2, [pc, #164]	@ (3418edf8 <HAL_SD_InitCard+0x160>)
3418ed52:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3418ed54:	fbb2 f3f3 	udiv	r3, r2, r3
3418ed58:	3301      	adds	r3, #1
3418ed5a:	4618      	mov	r0, r3
3418ed5c:	f7f6 fc38 	bl	341855d0 <HAL_Delay>
  }

  /* Identify card operating voltage */
  errorstate = SD_PowerON(hsd);
3418ed60:	6878      	ldr	r0, [r7, #4]
3418ed62:	f000 ffe7 	bl	3418fd34 <SD_PowerON>
3418ed66:	6238      	str	r0, [r7, #32]
  if (errorstate != HAL_SD_ERROR_NONE)
3418ed68:	6a3b      	ldr	r3, [r7, #32]
3418ed6a:	2b00      	cmp	r3, #0
3418ed6c:	d00b      	beq.n	3418ed86 <HAL_SD_InitCard+0xee>
  {
    hsd->State = HAL_SD_STATE_READY;
3418ed6e:	687b      	ldr	r3, [r7, #4]
3418ed70:	2201      	movs	r2, #1
3418ed72:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
    hsd->ErrorCode |= errorstate;
3418ed76:	687b      	ldr	r3, [r7, #4]
3418ed78:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
3418ed7a:	6a3b      	ldr	r3, [r7, #32]
3418ed7c:	431a      	orrs	r2, r3
3418ed7e:	687b      	ldr	r3, [r7, #4]
3418ed80:	635a      	str	r2, [r3, #52]	@ 0x34
    return HAL_ERROR;
3418ed82:	2301      	movs	r3, #1
3418ed84:	e02e      	b.n	3418ede4 <HAL_SD_InitCard+0x14c>
  }

  /* Card initialization */
  errorstate = SD_InitCard(hsd);
3418ed86:	6878      	ldr	r0, [r7, #4]
3418ed88:	f000 ff06 	bl	3418fb98 <SD_InitCard>
3418ed8c:	6238      	str	r0, [r7, #32]
  if (errorstate != HAL_SD_ERROR_NONE)
3418ed8e:	6a3b      	ldr	r3, [r7, #32]
3418ed90:	2b00      	cmp	r3, #0
3418ed92:	d00b      	beq.n	3418edac <HAL_SD_InitCard+0x114>
  {
    hsd->State = HAL_SD_STATE_READY;
3418ed94:	687b      	ldr	r3, [r7, #4]
3418ed96:	2201      	movs	r2, #1
3418ed98:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
    hsd->ErrorCode |= errorstate;
3418ed9c:	687b      	ldr	r3, [r7, #4]
3418ed9e:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
3418eda0:	6a3b      	ldr	r3, [r7, #32]
3418eda2:	431a      	orrs	r2, r3
3418eda4:	687b      	ldr	r3, [r7, #4]
3418eda6:	635a      	str	r2, [r3, #52]	@ 0x34
    return HAL_ERROR;
3418eda8:	2301      	movs	r3, #1
3418edaa:	e01b      	b.n	3418ede4 <HAL_SD_InitCard+0x14c>
  }

  /* Set Block Size for Card */
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
3418edac:	687b      	ldr	r3, [r7, #4]
3418edae:	681b      	ldr	r3, [r3, #0]
3418edb0:	f44f 7100 	mov.w	r1, #512	@ 0x200
3418edb4:	4618      	mov	r0, r3
3418edb6:	f002 fc77 	bl	341916a8 <SDMMC_CmdBlockLength>
3418edba:	6238      	str	r0, [r7, #32]
  if (errorstate != HAL_SD_ERROR_NONE)
3418edbc:	6a3b      	ldr	r3, [r7, #32]
3418edbe:	2b00      	cmp	r3, #0
3418edc0:	d00f      	beq.n	3418ede2 <HAL_SD_InitCard+0x14a>
  {
    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
3418edc2:	687b      	ldr	r3, [r7, #4]
3418edc4:	681b      	ldr	r3, [r3, #0]
3418edc6:	4a0d      	ldr	r2, [pc, #52]	@ (3418edfc <HAL_SD_InitCard+0x164>)
3418edc8:	639a      	str	r2, [r3, #56]	@ 0x38
    hsd->ErrorCode |= errorstate;
3418edca:	687b      	ldr	r3, [r7, #4]
3418edcc:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
3418edce:	6a3b      	ldr	r3, [r7, #32]
3418edd0:	431a      	orrs	r2, r3
3418edd2:	687b      	ldr	r3, [r7, #4]
3418edd4:	635a      	str	r2, [r3, #52]	@ 0x34
    hsd->State = HAL_SD_STATE_READY;
3418edd6:	687b      	ldr	r3, [r7, #4]
3418edd8:	2201      	movs	r2, #1
3418edda:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
    return HAL_ERROR;
3418edde:	2301      	movs	r3, #1
3418ede0:	e000      	b.n	3418ede4 <HAL_SD_InitCard+0x14c>
  }

  return HAL_OK;
3418ede2:	2300      	movs	r3, #0
}
3418ede4:	4618      	mov	r0, r3
3418ede6:	372c      	adds	r7, #44	@ 0x2c
3418ede8:	46bd      	mov	sp, r7
3418edea:	bd90      	pop	{r4, r7, pc}
3418edec:	58027000 	.word	0x58027000
3418edf0:	58026800 	.word	0x58026800
3418edf4:	014f8b59 	.word	0x014f8b59
3418edf8:	00012110 	.word	0x00012110
3418edfc:	1fe00fff 	.word	0x1fe00fff

3418ee00 <HAL_SD_ReadBlocks_DMA>:
  * @param  NumberOfBlocks: Number of blocks to read.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_ReadBlocks_DMA(SD_HandleTypeDef *hsd, uint8_t *pData, uint32_t BlockAdd,
                                        uint32_t NumberOfBlocks)
{
3418ee00:	b580      	push	{r7, lr}
3418ee02:	b08c      	sub	sp, #48	@ 0x30
3418ee04:	af00      	add	r7, sp, #0
3418ee06:	60f8      	str	r0, [r7, #12]
3418ee08:	60b9      	str	r1, [r7, #8]
3418ee0a:	607a      	str	r2, [r7, #4]
3418ee0c:	603b      	str	r3, [r7, #0]
  SDMMC_DataInitTypeDef config;
  uint32_t errorstate;
  uint32_t add = BlockAdd;
3418ee0e:	687b      	ldr	r3, [r7, #4]
3418ee10:	62bb      	str	r3, [r7, #40]	@ 0x28

  if (NULL == pData)
3418ee12:	68bb      	ldr	r3, [r7, #8]
3418ee14:	2b00      	cmp	r3, #0
3418ee16:	d107      	bne.n	3418ee28 <HAL_SD_ReadBlocks_DMA+0x28>
  {
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
3418ee18:	68fb      	ldr	r3, [r7, #12]
3418ee1a:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3418ee1c:	f043 6200 	orr.w	r2, r3, #134217728	@ 0x8000000
3418ee20:	68fb      	ldr	r3, [r7, #12]
3418ee22:	635a      	str	r2, [r3, #52]	@ 0x34
    return HAL_ERROR;
3418ee24:	2301      	movs	r3, #1
3418ee26:	e08d      	b.n	3418ef44 <HAL_SD_ReadBlocks_DMA+0x144>
  }

  if (hsd->State == HAL_SD_STATE_READY)
3418ee28:	68fb      	ldr	r3, [r7, #12]
3418ee2a:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
3418ee2e:	b2db      	uxtb	r3, r3
3418ee30:	2b01      	cmp	r3, #1
3418ee32:	f040 8086 	bne.w	3418ef42 <HAL_SD_ReadBlocks_DMA+0x142>
  {
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
3418ee36:	68fb      	ldr	r3, [r7, #12]
3418ee38:	2200      	movs	r2, #0
3418ee3a:	635a      	str	r2, [r3, #52]	@ 0x34

    if ((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
3418ee3c:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418ee3e:	683b      	ldr	r3, [r7, #0]
3418ee40:	441a      	add	r2, r3
3418ee42:	68fb      	ldr	r3, [r7, #12]
3418ee44:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
3418ee46:	429a      	cmp	r2, r3
3418ee48:	d907      	bls.n	3418ee5a <HAL_SD_ReadBlocks_DMA+0x5a>
    {
      hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
3418ee4a:	68fb      	ldr	r3, [r7, #12]
3418ee4c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3418ee4e:	f043 7200 	orr.w	r2, r3, #33554432	@ 0x2000000
3418ee52:	68fb      	ldr	r3, [r7, #12]
3418ee54:	635a      	str	r2, [r3, #52]	@ 0x34
      return HAL_ERROR;
3418ee56:	2301      	movs	r3, #1
3418ee58:	e074      	b.n	3418ef44 <HAL_SD_ReadBlocks_DMA+0x144>
    }

    hsd->State = HAL_SD_STATE_BUSY;
3418ee5a:	68fb      	ldr	r3, [r7, #12]
3418ee5c:	2203      	movs	r2, #3
3418ee5e:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30

    /* Initialize data control register */
    hsd->Instance->DCTRL = 0U;
3418ee62:	68fb      	ldr	r3, [r7, #12]
3418ee64:	681b      	ldr	r3, [r3, #0]
3418ee66:	2200      	movs	r2, #0
3418ee68:	62da      	str	r2, [r3, #44]	@ 0x2c

    hsd->pRxBuffPtr = pData;
3418ee6a:	68fb      	ldr	r3, [r7, #12]
3418ee6c:	68ba      	ldr	r2, [r7, #8]
3418ee6e:	625a      	str	r2, [r3, #36]	@ 0x24
    hsd->RxXferSize = BLOCKSIZE * NumberOfBlocks;
3418ee70:	683b      	ldr	r3, [r7, #0]
3418ee72:	025a      	lsls	r2, r3, #9
3418ee74:	68fb      	ldr	r3, [r7, #12]
3418ee76:	629a      	str	r2, [r3, #40]	@ 0x28

    if (hsd->SdCard.CardType != CARD_SDHC_SDXC)
3418ee78:	68fb      	ldr	r3, [r7, #12]
3418ee7a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3418ee7c:	2b01      	cmp	r3, #1
3418ee7e:	d002      	beq.n	3418ee86 <HAL_SD_ReadBlocks_DMA+0x86>
    {
      add *= BLOCKSIZE;
3418ee80:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418ee82:	025b      	lsls	r3, r3, #9
3418ee84:	62bb      	str	r3, [r7, #40]	@ 0x28
    }

    /* Configure the SD DPSM (Data Path State Machine) */
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
3418ee86:	f04f 33ff 	mov.w	r3, #4294967295
3418ee8a:	613b      	str	r3, [r7, #16]
    config.DataLength    = BLOCKSIZE * NumberOfBlocks;
3418ee8c:	683b      	ldr	r3, [r7, #0]
3418ee8e:	025b      	lsls	r3, r3, #9
3418ee90:	617b      	str	r3, [r7, #20]
    config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
3418ee92:	2390      	movs	r3, #144	@ 0x90
3418ee94:	61bb      	str	r3, [r7, #24]
    config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
3418ee96:	2302      	movs	r3, #2
3418ee98:	61fb      	str	r3, [r7, #28]
    config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
3418ee9a:	2300      	movs	r3, #0
3418ee9c:	623b      	str	r3, [r7, #32]
    config.DPSM          = SDMMC_DPSM_DISABLE;
3418ee9e:	2300      	movs	r3, #0
3418eea0:	627b      	str	r3, [r7, #36]	@ 0x24
    (void)SDMMC_ConfigData(hsd->Instance, &config);
3418eea2:	68fb      	ldr	r3, [r7, #12]
3418eea4:	681b      	ldr	r3, [r3, #0]
3418eea6:	f107 0210 	add.w	r2, r7, #16
3418eeaa:	4611      	mov	r1, r2
3418eeac:	4618      	mov	r0, r3
3418eeae:	f002 fbcf 	bl	34191650 <SDMMC_ConfigData>

    __SDMMC_CMDTRANS_ENABLE(hsd->Instance);
3418eeb2:	68fb      	ldr	r3, [r7, #12]
3418eeb4:	681b      	ldr	r3, [r3, #0]
3418eeb6:	68da      	ldr	r2, [r3, #12]
3418eeb8:	68fb      	ldr	r3, [r7, #12]
3418eeba:	681b      	ldr	r3, [r3, #0]
3418eebc:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
3418eec0:	60da      	str	r2, [r3, #12]
    hsd->Instance->IDMABASER = (uint32_t) pData ;
3418eec2:	68fb      	ldr	r3, [r7, #12]
3418eec4:	681b      	ldr	r3, [r3, #0]
3418eec6:	68ba      	ldr	r2, [r7, #8]
3418eec8:	659a      	str	r2, [r3, #88]	@ 0x58
    hsd->Instance->IDMACTRL  = SDMMC_ENABLE_IDMA_SINGLE_BUFF;
3418eeca:	68fb      	ldr	r3, [r7, #12]
3418eecc:	681b      	ldr	r3, [r3, #0]
3418eece:	2201      	movs	r2, #1
3418eed0:	651a      	str	r2, [r3, #80]	@ 0x50

    /* Read Blocks in DMA mode */
    if (NumberOfBlocks > 1U)
3418eed2:	683b      	ldr	r3, [r7, #0]
3418eed4:	2b01      	cmp	r3, #1
3418eed6:	d90a      	bls.n	3418eeee <HAL_SD_ReadBlocks_DMA+0xee>
    {
      hsd->Context = (SD_CONTEXT_READ_MULTIPLE_BLOCK | SD_CONTEXT_DMA);
3418eed8:	68fb      	ldr	r3, [r7, #12]
3418eeda:	2282      	movs	r2, #130	@ 0x82
3418eedc:	62da      	str	r2, [r3, #44]	@ 0x2c

      /* Read Multi Block command */
      errorstate = SDMMC_CmdReadMultiBlock(hsd->Instance, add);
3418eede:	68fb      	ldr	r3, [r7, #12]
3418eee0:	681b      	ldr	r3, [r3, #0]
3418eee2:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3418eee4:	4618      	mov	r0, r3
3418eee6:	f002 fc25 	bl	34191734 <SDMMC_CmdReadMultiBlock>
3418eeea:	62f8      	str	r0, [r7, #44]	@ 0x2c
3418eeec:	e009      	b.n	3418ef02 <HAL_SD_ReadBlocks_DMA+0x102>
    }
    else
    {
      hsd->Context = (SD_CONTEXT_READ_SINGLE_BLOCK | SD_CONTEXT_DMA);
3418eeee:	68fb      	ldr	r3, [r7, #12]
3418eef0:	2281      	movs	r2, #129	@ 0x81
3418eef2:	62da      	str	r2, [r3, #44]	@ 0x2c

      /* Read Single Block command */
      errorstate = SDMMC_CmdReadSingleBlock(hsd->Instance, add);
3418eef4:	68fb      	ldr	r3, [r7, #12]
3418eef6:	681b      	ldr	r3, [r3, #0]
3418eef8:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3418eefa:	4618      	mov	r0, r3
3418eefc:	f002 fbf7 	bl	341916ee <SDMMC_CmdReadSingleBlock>
3418ef00:	62f8      	str	r0, [r7, #44]	@ 0x2c
    }
    if (errorstate != HAL_SD_ERROR_NONE)
3418ef02:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3418ef04:	2b00      	cmp	r3, #0
3418ef06:	d012      	beq.n	3418ef2e <HAL_SD_ReadBlocks_DMA+0x12e>
    {
      /* Clear all the static flags */
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
3418ef08:	68fb      	ldr	r3, [r7, #12]
3418ef0a:	681b      	ldr	r3, [r3, #0]
3418ef0c:	4a0f      	ldr	r2, [pc, #60]	@ (3418ef4c <HAL_SD_ReadBlocks_DMA+0x14c>)
3418ef0e:	639a      	str	r2, [r3, #56]	@ 0x38
      hsd->ErrorCode |= errorstate;
3418ef10:	68fb      	ldr	r3, [r7, #12]
3418ef12:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
3418ef14:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3418ef16:	431a      	orrs	r2, r3
3418ef18:	68fb      	ldr	r3, [r7, #12]
3418ef1a:	635a      	str	r2, [r3, #52]	@ 0x34
      hsd->State = HAL_SD_STATE_READY;
3418ef1c:	68fb      	ldr	r3, [r7, #12]
3418ef1e:	2201      	movs	r2, #1
3418ef20:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
      hsd->Context = SD_CONTEXT_NONE;
3418ef24:	68fb      	ldr	r3, [r7, #12]
3418ef26:	2200      	movs	r2, #0
3418ef28:	62da      	str	r2, [r3, #44]	@ 0x2c
      return HAL_ERROR;
3418ef2a:	2301      	movs	r3, #1
3418ef2c:	e00a      	b.n	3418ef44 <HAL_SD_ReadBlocks_DMA+0x144>
    }

    /* Enable transfer interrupts */
    __HAL_SD_ENABLE_IT(hsd, (SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT | SDMMC_IT_RXOVERR | SDMMC_IT_DATAEND));
3418ef2e:	68fb      	ldr	r3, [r7, #12]
3418ef30:	681b      	ldr	r3, [r3, #0]
3418ef32:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
3418ef34:	68fb      	ldr	r3, [r7, #12]
3418ef36:	681b      	ldr	r3, [r3, #0]
3418ef38:	f442 7295 	orr.w	r2, r2, #298	@ 0x12a
3418ef3c:	63da      	str	r2, [r3, #60]	@ 0x3c

    return HAL_OK;
3418ef3e:	2300      	movs	r3, #0
3418ef40:	e000      	b.n	3418ef44 <HAL_SD_ReadBlocks_DMA+0x144>
  }
  else
  {
    return HAL_BUSY;
3418ef42:	2302      	movs	r3, #2
  }
}
3418ef44:	4618      	mov	r0, r3
3418ef46:	3730      	adds	r7, #48	@ 0x30
3418ef48:	46bd      	mov	sp, r7
3418ef4a:	bd80      	pop	{r7, pc}
3418ef4c:	1fe00fff 	.word	0x1fe00fff

3418ef50 <HAL_SD_WriteBlocks_DMA>:
  * @param  NumberOfBlocks: Number of blocks to write
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_WriteBlocks_DMA(SD_HandleTypeDef *hsd, const uint8_t *pData, uint32_t BlockAdd,
                                         uint32_t NumberOfBlocks)
{
3418ef50:	b580      	push	{r7, lr}
3418ef52:	b08c      	sub	sp, #48	@ 0x30
3418ef54:	af00      	add	r7, sp, #0
3418ef56:	60f8      	str	r0, [r7, #12]
3418ef58:	60b9      	str	r1, [r7, #8]
3418ef5a:	607a      	str	r2, [r7, #4]
3418ef5c:	603b      	str	r3, [r7, #0]
  SDMMC_DataInitTypeDef config;
  uint32_t errorstate;
  uint32_t add = BlockAdd;
3418ef5e:	687b      	ldr	r3, [r7, #4]
3418ef60:	62bb      	str	r3, [r7, #40]	@ 0x28

  if (NULL == pData)
3418ef62:	68bb      	ldr	r3, [r7, #8]
3418ef64:	2b00      	cmp	r3, #0
3418ef66:	d107      	bne.n	3418ef78 <HAL_SD_WriteBlocks_DMA+0x28>
  {
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
3418ef68:	68fb      	ldr	r3, [r7, #12]
3418ef6a:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3418ef6c:	f043 6200 	orr.w	r2, r3, #134217728	@ 0x8000000
3418ef70:	68fb      	ldr	r3, [r7, #12]
3418ef72:	635a      	str	r2, [r3, #52]	@ 0x34
    return HAL_ERROR;
3418ef74:	2301      	movs	r3, #1
3418ef76:	e08d      	b.n	3418f094 <HAL_SD_WriteBlocks_DMA+0x144>
  }

  if (hsd->State == HAL_SD_STATE_READY)
3418ef78:	68fb      	ldr	r3, [r7, #12]
3418ef7a:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
3418ef7e:	b2db      	uxtb	r3, r3
3418ef80:	2b01      	cmp	r3, #1
3418ef82:	f040 8086 	bne.w	3418f092 <HAL_SD_WriteBlocks_DMA+0x142>
  {
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
3418ef86:	68fb      	ldr	r3, [r7, #12]
3418ef88:	2200      	movs	r2, #0
3418ef8a:	635a      	str	r2, [r3, #52]	@ 0x34

    if ((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
3418ef8c:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418ef8e:	683b      	ldr	r3, [r7, #0]
3418ef90:	441a      	add	r2, r3
3418ef92:	68fb      	ldr	r3, [r7, #12]
3418ef94:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
3418ef96:	429a      	cmp	r2, r3
3418ef98:	d907      	bls.n	3418efaa <HAL_SD_WriteBlocks_DMA+0x5a>
    {
      hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
3418ef9a:	68fb      	ldr	r3, [r7, #12]
3418ef9c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3418ef9e:	f043 7200 	orr.w	r2, r3, #33554432	@ 0x2000000
3418efa2:	68fb      	ldr	r3, [r7, #12]
3418efa4:	635a      	str	r2, [r3, #52]	@ 0x34
      return HAL_ERROR;
3418efa6:	2301      	movs	r3, #1
3418efa8:	e074      	b.n	3418f094 <HAL_SD_WriteBlocks_DMA+0x144>
    }

    hsd->State = HAL_SD_STATE_BUSY;
3418efaa:	68fb      	ldr	r3, [r7, #12]
3418efac:	2203      	movs	r2, #3
3418efae:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30

    /* Initialize data control register */
    hsd->Instance->DCTRL = 0U;
3418efb2:	68fb      	ldr	r3, [r7, #12]
3418efb4:	681b      	ldr	r3, [r3, #0]
3418efb6:	2200      	movs	r2, #0
3418efb8:	62da      	str	r2, [r3, #44]	@ 0x2c

    hsd->pTxBuffPtr = pData;
3418efba:	68fb      	ldr	r3, [r7, #12]
3418efbc:	68ba      	ldr	r2, [r7, #8]
3418efbe:	61da      	str	r2, [r3, #28]
    hsd->TxXferSize = BLOCKSIZE * NumberOfBlocks;
3418efc0:	683b      	ldr	r3, [r7, #0]
3418efc2:	025a      	lsls	r2, r3, #9
3418efc4:	68fb      	ldr	r3, [r7, #12]
3418efc6:	621a      	str	r2, [r3, #32]

    if (hsd->SdCard.CardType != CARD_SDHC_SDXC)
3418efc8:	68fb      	ldr	r3, [r7, #12]
3418efca:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3418efcc:	2b01      	cmp	r3, #1
3418efce:	d002      	beq.n	3418efd6 <HAL_SD_WriteBlocks_DMA+0x86>
    {
      add *= BLOCKSIZE;
3418efd0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418efd2:	025b      	lsls	r3, r3, #9
3418efd4:	62bb      	str	r3, [r7, #40]	@ 0x28
    }

    /* Configure the SD DPSM (Data Path State Machine) */
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
3418efd6:	f04f 33ff 	mov.w	r3, #4294967295
3418efda:	613b      	str	r3, [r7, #16]
    config.DataLength    = BLOCKSIZE * NumberOfBlocks;
3418efdc:	683b      	ldr	r3, [r7, #0]
3418efde:	025b      	lsls	r3, r3, #9
3418efe0:	617b      	str	r3, [r7, #20]
    config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
3418efe2:	2390      	movs	r3, #144	@ 0x90
3418efe4:	61bb      	str	r3, [r7, #24]
    config.TransferDir   = SDMMC_TRANSFER_DIR_TO_CARD;
3418efe6:	2300      	movs	r3, #0
3418efe8:	61fb      	str	r3, [r7, #28]
    config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
3418efea:	2300      	movs	r3, #0
3418efec:	623b      	str	r3, [r7, #32]
    config.DPSM          = SDMMC_DPSM_DISABLE;
3418efee:	2300      	movs	r3, #0
3418eff0:	627b      	str	r3, [r7, #36]	@ 0x24
    (void)SDMMC_ConfigData(hsd->Instance, &config);
3418eff2:	68fb      	ldr	r3, [r7, #12]
3418eff4:	681b      	ldr	r3, [r3, #0]
3418eff6:	f107 0210 	add.w	r2, r7, #16
3418effa:	4611      	mov	r1, r2
3418effc:	4618      	mov	r0, r3
3418effe:	f002 fb27 	bl	34191650 <SDMMC_ConfigData>

    __SDMMC_CMDTRANS_ENABLE(hsd->Instance);
3418f002:	68fb      	ldr	r3, [r7, #12]
3418f004:	681b      	ldr	r3, [r3, #0]
3418f006:	68da      	ldr	r2, [r3, #12]
3418f008:	68fb      	ldr	r3, [r7, #12]
3418f00a:	681b      	ldr	r3, [r3, #0]
3418f00c:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
3418f010:	60da      	str	r2, [r3, #12]

    hsd->Instance->IDMABASER = (uint32_t) pData ;
3418f012:	68fb      	ldr	r3, [r7, #12]
3418f014:	681b      	ldr	r3, [r3, #0]
3418f016:	68ba      	ldr	r2, [r7, #8]
3418f018:	659a      	str	r2, [r3, #88]	@ 0x58
    hsd->Instance->IDMACTRL  = SDMMC_ENABLE_IDMA_SINGLE_BUFF;
3418f01a:	68fb      	ldr	r3, [r7, #12]
3418f01c:	681b      	ldr	r3, [r3, #0]
3418f01e:	2201      	movs	r2, #1
3418f020:	651a      	str	r2, [r3, #80]	@ 0x50

    /* Write Blocks in Polling mode */
    if (NumberOfBlocks > 1U)
3418f022:	683b      	ldr	r3, [r7, #0]
3418f024:	2b01      	cmp	r3, #1
3418f026:	d90a      	bls.n	3418f03e <HAL_SD_WriteBlocks_DMA+0xee>
    {
      hsd->Context = (SD_CONTEXT_WRITE_MULTIPLE_BLOCK | SD_CONTEXT_DMA);
3418f028:	68fb      	ldr	r3, [r7, #12]
3418f02a:	22a0      	movs	r2, #160	@ 0xa0
3418f02c:	62da      	str	r2, [r3, #44]	@ 0x2c

      /* Write Multi Block command */
      errorstate = SDMMC_CmdWriteMultiBlock(hsd->Instance, add);
3418f02e:	68fb      	ldr	r3, [r7, #12]
3418f030:	681b      	ldr	r3, [r3, #0]
3418f032:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3418f034:	4618      	mov	r0, r3
3418f036:	f002 fbc3 	bl	341917c0 <SDMMC_CmdWriteMultiBlock>
3418f03a:	62f8      	str	r0, [r7, #44]	@ 0x2c
3418f03c:	e009      	b.n	3418f052 <HAL_SD_WriteBlocks_DMA+0x102>
    }
    else
    {
      hsd->Context = (SD_CONTEXT_WRITE_SINGLE_BLOCK | SD_CONTEXT_DMA);
3418f03e:	68fb      	ldr	r3, [r7, #12]
3418f040:	2290      	movs	r2, #144	@ 0x90
3418f042:	62da      	str	r2, [r3, #44]	@ 0x2c

      /* Write Single Block command */
      errorstate = SDMMC_CmdWriteSingleBlock(hsd->Instance, add);
3418f044:	68fb      	ldr	r3, [r7, #12]
3418f046:	681b      	ldr	r3, [r3, #0]
3418f048:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3418f04a:	4618      	mov	r0, r3
3418f04c:	f002 fb95 	bl	3419177a <SDMMC_CmdWriteSingleBlock>
3418f050:	62f8      	str	r0, [r7, #44]	@ 0x2c
    }
    if (errorstate != HAL_SD_ERROR_NONE)
3418f052:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3418f054:	2b00      	cmp	r3, #0
3418f056:	d012      	beq.n	3418f07e <HAL_SD_WriteBlocks_DMA+0x12e>
    {
      /* Clear all the static flags */
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
3418f058:	68fb      	ldr	r3, [r7, #12]
3418f05a:	681b      	ldr	r3, [r3, #0]
3418f05c:	4a0f      	ldr	r2, [pc, #60]	@ (3418f09c <HAL_SD_WriteBlocks_DMA+0x14c>)
3418f05e:	639a      	str	r2, [r3, #56]	@ 0x38
      hsd->ErrorCode |= errorstate;
3418f060:	68fb      	ldr	r3, [r7, #12]
3418f062:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
3418f064:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3418f066:	431a      	orrs	r2, r3
3418f068:	68fb      	ldr	r3, [r7, #12]
3418f06a:	635a      	str	r2, [r3, #52]	@ 0x34
      hsd->State = HAL_SD_STATE_READY;
3418f06c:	68fb      	ldr	r3, [r7, #12]
3418f06e:	2201      	movs	r2, #1
3418f070:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
      hsd->Context = SD_CONTEXT_NONE;
3418f074:	68fb      	ldr	r3, [r7, #12]
3418f076:	2200      	movs	r2, #0
3418f078:	62da      	str	r2, [r3, #44]	@ 0x2c
      return HAL_ERROR;
3418f07a:	2301      	movs	r3, #1
3418f07c:	e00a      	b.n	3418f094 <HAL_SD_WriteBlocks_DMA+0x144>
    }

    /* Enable transfer interrupts */
    __HAL_SD_ENABLE_IT(hsd, (SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT | SDMMC_IT_TXUNDERR | SDMMC_IT_DATAEND));
3418f07e:	68fb      	ldr	r3, [r7, #12]
3418f080:	681b      	ldr	r3, [r3, #0]
3418f082:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
3418f084:	68fb      	ldr	r3, [r7, #12]
3418f086:	681b      	ldr	r3, [r3, #0]
3418f088:	f442 728d 	orr.w	r2, r2, #282	@ 0x11a
3418f08c:	63da      	str	r2, [r3, #60]	@ 0x3c

    return HAL_OK;
3418f08e:	2300      	movs	r3, #0
3418f090:	e000      	b.n	3418f094 <HAL_SD_WriteBlocks_DMA+0x144>
  }
  else
  {
    return HAL_BUSY;
3418f092:	2302      	movs	r3, #2
  }
}
3418f094:	4618      	mov	r0, r3
3418f096:	3730      	adds	r7, #48	@ 0x30
3418f098:	46bd      	mov	sp, r7
3418f09a:	bd80      	pop	{r7, pc}
3418f09c:	1fe00fff 	.word	0x1fe00fff

3418f0a0 <HAL_SD_IRQHandler>:
  * @brief  This function handles SD card interrupt request.
  * @param  hsd: Pointer to SD handle
  * @retval None
  */
void HAL_SD_IRQHandler(SD_HandleTypeDef *hsd)
{
3418f0a0:	b580      	push	{r7, lr}
3418f0a2:	b084      	sub	sp, #16
3418f0a4:	af00      	add	r7, sp, #0
3418f0a6:	6078      	str	r0, [r7, #4]
  uint32_t errorstate;
  uint32_t context = hsd->Context;
3418f0a8:	687b      	ldr	r3, [r7, #4]
3418f0aa:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3418f0ac:	60fb      	str	r3, [r7, #12]

  /* Check for SDMMC interrupt flags */
  if ((__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF) != RESET) && ((context & SD_CONTEXT_IT) != 0U))
3418f0ae:	687b      	ldr	r3, [r7, #4]
3418f0b0:	681b      	ldr	r3, [r3, #0]
3418f0b2:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3418f0b4:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
3418f0b8:	2b00      	cmp	r3, #0
3418f0ba:	d008      	beq.n	3418f0ce <HAL_SD_IRQHandler+0x2e>
3418f0bc:	68fb      	ldr	r3, [r7, #12]
3418f0be:	f003 0308 	and.w	r3, r3, #8
3418f0c2:	2b00      	cmp	r3, #0
3418f0c4:	d003      	beq.n	3418f0ce <HAL_SD_IRQHandler+0x2e>
  {
    SD_Read_IT(hsd);
3418f0c6:	6878      	ldr	r0, [r7, #4]
3418f0c8:	f001 f920 	bl	3419030c <SD_Read_IT>
3418f0cc:	e186      	b.n	3418f3dc <HAL_SD_IRQHandler+0x33c>
  }

  else if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DATAEND) != RESET)
3418f0ce:	687b      	ldr	r3, [r7, #4]
3418f0d0:	681b      	ldr	r3, [r3, #0]
3418f0d2:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3418f0d4:	f403 7380 	and.w	r3, r3, #256	@ 0x100
3418f0d8:	2b00      	cmp	r3, #0
3418f0da:	f000 80ae 	beq.w	3418f23a <HAL_SD_IRQHandler+0x19a>
  {
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DATAEND);
3418f0de:	687b      	ldr	r3, [r7, #4]
3418f0e0:	681b      	ldr	r3, [r3, #0]
3418f0e2:	f44f 7280 	mov.w	r2, #256	@ 0x100
3418f0e6:	639a      	str	r2, [r3, #56]	@ 0x38

    __HAL_SD_DISABLE_IT(hsd, SDMMC_IT_DATAEND  | SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT | \
3418f0e8:	687b      	ldr	r3, [r7, #4]
3418f0ea:	681b      	ldr	r3, [r3, #0]
3418f0ec:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3418f0ee:	687a      	ldr	r2, [r7, #4]
3418f0f0:	6812      	ldr	r2, [r2, #0]
3418f0f2:	f423 4341 	bic.w	r3, r3, #49408	@ 0xc100
3418f0f6:	f023 033a 	bic.w	r3, r3, #58	@ 0x3a
3418f0fa:	63d3      	str	r3, [r2, #60]	@ 0x3c
                        SDMMC_IT_TXUNDERR | SDMMC_IT_RXOVERR  | SDMMC_IT_TXFIFOHE | \
                        SDMMC_IT_RXFIFOHF);

    __HAL_SD_DISABLE_IT(hsd, SDMMC_IT_IDMABTC);
3418f0fc:	687b      	ldr	r3, [r7, #4]
3418f0fe:	681b      	ldr	r3, [r3, #0]
3418f100:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
3418f102:	687b      	ldr	r3, [r7, #4]
3418f104:	681b      	ldr	r3, [r3, #0]
3418f106:	f022 5280 	bic.w	r2, r2, #268435456	@ 0x10000000
3418f10a:	63da      	str	r2, [r3, #60]	@ 0x3c
    __SDMMC_CMDTRANS_DISABLE(hsd->Instance);
3418f10c:	687b      	ldr	r3, [r7, #4]
3418f10e:	681b      	ldr	r3, [r3, #0]
3418f110:	68da      	ldr	r2, [r3, #12]
3418f112:	687b      	ldr	r3, [r7, #4]
3418f114:	681b      	ldr	r3, [r3, #0]
3418f116:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
3418f11a:	60da      	str	r2, [r3, #12]

    if ((context & SD_CONTEXT_IT) != 0U)
3418f11c:	68fb      	ldr	r3, [r7, #12]
3418f11e:	f003 0308 	and.w	r3, r3, #8
3418f122:	2b00      	cmp	r3, #0
3418f124:	d038      	beq.n	3418f198 <HAL_SD_IRQHandler+0xf8>
    {
      if (((context & SD_CONTEXT_READ_MULTIPLE_BLOCK) != 0U) || ((context & SD_CONTEXT_WRITE_MULTIPLE_BLOCK) != 0U))
3418f126:	68fb      	ldr	r3, [r7, #12]
3418f128:	f003 0302 	and.w	r3, r3, #2
3418f12c:	2b00      	cmp	r3, #0
3418f12e:	d104      	bne.n	3418f13a <HAL_SD_IRQHandler+0x9a>
3418f130:	68fb      	ldr	r3, [r7, #12]
3418f132:	f003 0320 	and.w	r3, r3, #32
3418f136:	2b00      	cmp	r3, #0
3418f138:	d011      	beq.n	3418f15e <HAL_SD_IRQHandler+0xbe>
      {
        errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
3418f13a:	687b      	ldr	r3, [r7, #4]
3418f13c:	681b      	ldr	r3, [r3, #0]
3418f13e:	4618      	mov	r0, r3
3418f140:	f002 fb62 	bl	34191808 <SDMMC_CmdStopTransfer>
3418f144:	60b8      	str	r0, [r7, #8]
        if (errorstate != HAL_SD_ERROR_NONE)
3418f146:	68bb      	ldr	r3, [r7, #8]
3418f148:	2b00      	cmp	r3, #0
3418f14a:	d008      	beq.n	3418f15e <HAL_SD_IRQHandler+0xbe>
        {
          hsd->ErrorCode |= errorstate;
3418f14c:	687b      	ldr	r3, [r7, #4]
3418f14e:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
3418f150:	68bb      	ldr	r3, [r7, #8]
3418f152:	431a      	orrs	r2, r3
3418f154:	687b      	ldr	r3, [r7, #4]
3418f156:	635a      	str	r2, [r3, #52]	@ 0x34
#if defined (USE_HAL_SD_REGISTER_CALLBACKS) && (USE_HAL_SD_REGISTER_CALLBACKS == 1U)
          hsd->ErrorCallback(hsd);
#else
          HAL_SD_ErrorCallback(hsd);
3418f158:	6878      	ldr	r0, [r7, #4]
3418f15a:	f000 f943 	bl	3418f3e4 <HAL_SD_ErrorCallback>
#endif /* USE_HAL_SD_REGISTER_CALLBACKS */
        }
      }

      /* Clear all the static flags */
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
3418f15e:	687b      	ldr	r3, [r7, #4]
3418f160:	681b      	ldr	r3, [r3, #0]
3418f162:	4a9b      	ldr	r2, [pc, #620]	@ (3418f3d0 <HAL_SD_IRQHandler+0x330>)
3418f164:	639a      	str	r2, [r3, #56]	@ 0x38

      hsd->State = HAL_SD_STATE_READY;
3418f166:	687b      	ldr	r3, [r7, #4]
3418f168:	2201      	movs	r2, #1
3418f16a:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
      hsd->Context = SD_CONTEXT_NONE;
3418f16e:	687b      	ldr	r3, [r7, #4]
3418f170:	2200      	movs	r2, #0
3418f172:	62da      	str	r2, [r3, #44]	@ 0x2c
      if (((context & SD_CONTEXT_READ_SINGLE_BLOCK) != 0U) || ((context & SD_CONTEXT_READ_MULTIPLE_BLOCK) != 0U))
3418f174:	68fb      	ldr	r3, [r7, #12]
3418f176:	f003 0301 	and.w	r3, r3, #1
3418f17a:	2b00      	cmp	r3, #0
3418f17c:	d104      	bne.n	3418f188 <HAL_SD_IRQHandler+0xe8>
3418f17e:	68fb      	ldr	r3, [r7, #12]
3418f180:	f003 0302 	and.w	r3, r3, #2
3418f184:	2b00      	cmp	r3, #0
3418f186:	d003      	beq.n	3418f190 <HAL_SD_IRQHandler+0xf0>
      {
#if defined (USE_HAL_SD_REGISTER_CALLBACKS) && (USE_HAL_SD_REGISTER_CALLBACKS == 1U)
        hsd->RxCpltCallback(hsd);
#else
        HAL_SD_RxCpltCallback(hsd);
3418f188:	6878      	ldr	r0, [r7, #4]
3418f18a:	f7f3 ff19 	bl	34182fc0 <HAL_SD_RxCpltCallback>
3418f18e:	e125      	b.n	3418f3dc <HAL_SD_IRQHandler+0x33c>
      else
      {
#if defined (USE_HAL_SD_REGISTER_CALLBACKS) && (USE_HAL_SD_REGISTER_CALLBACKS == 1U)
        hsd->TxCpltCallback(hsd);
#else
        HAL_SD_TxCpltCallback(hsd);
3418f190:	6878      	ldr	r0, [r7, #4]
3418f192:	f7f3 ff01 	bl	34182f98 <HAL_SD_TxCpltCallback>
  }
  else
  {
    /* Nothing to do */
  }
}
3418f196:	e121      	b.n	3418f3dc <HAL_SD_IRQHandler+0x33c>
    else if ((context & SD_CONTEXT_DMA) != 0U)
3418f198:	68fb      	ldr	r3, [r7, #12]
3418f19a:	f003 0380 	and.w	r3, r3, #128	@ 0x80
3418f19e:	2b00      	cmp	r3, #0
3418f1a0:	f000 811c 	beq.w	3418f3dc <HAL_SD_IRQHandler+0x33c>
      hsd->Instance->DLEN = 0;
3418f1a4:	687b      	ldr	r3, [r7, #4]
3418f1a6:	681b      	ldr	r3, [r3, #0]
3418f1a8:	2200      	movs	r2, #0
3418f1aa:	629a      	str	r2, [r3, #40]	@ 0x28
      hsd->Instance->DCTRL = 0;
3418f1ac:	687b      	ldr	r3, [r7, #4]
3418f1ae:	681b      	ldr	r3, [r3, #0]
3418f1b0:	2200      	movs	r2, #0
3418f1b2:	62da      	str	r2, [r3, #44]	@ 0x2c
      hsd->Instance->IDMACTRL = SDMMC_DISABLE_IDMA;
3418f1b4:	687b      	ldr	r3, [r7, #4]
3418f1b6:	681b      	ldr	r3, [r3, #0]
3418f1b8:	2200      	movs	r2, #0
3418f1ba:	651a      	str	r2, [r3, #80]	@ 0x50
      if (((context & SD_CONTEXT_READ_MULTIPLE_BLOCK) != 0U) || ((context & SD_CONTEXT_WRITE_MULTIPLE_BLOCK) != 0U))
3418f1bc:	68fb      	ldr	r3, [r7, #12]
3418f1be:	f003 0302 	and.w	r3, r3, #2
3418f1c2:	2b00      	cmp	r3, #0
3418f1c4:	d104      	bne.n	3418f1d0 <HAL_SD_IRQHandler+0x130>
3418f1c6:	68fb      	ldr	r3, [r7, #12]
3418f1c8:	f003 0320 	and.w	r3, r3, #32
3418f1cc:	2b00      	cmp	r3, #0
3418f1ce:	d011      	beq.n	3418f1f4 <HAL_SD_IRQHandler+0x154>
        errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
3418f1d0:	687b      	ldr	r3, [r7, #4]
3418f1d2:	681b      	ldr	r3, [r3, #0]
3418f1d4:	4618      	mov	r0, r3
3418f1d6:	f002 fb17 	bl	34191808 <SDMMC_CmdStopTransfer>
3418f1da:	60b8      	str	r0, [r7, #8]
        if (errorstate != HAL_SD_ERROR_NONE)
3418f1dc:	68bb      	ldr	r3, [r7, #8]
3418f1de:	2b00      	cmp	r3, #0
3418f1e0:	d008      	beq.n	3418f1f4 <HAL_SD_IRQHandler+0x154>
          hsd->ErrorCode |= errorstate;
3418f1e2:	687b      	ldr	r3, [r7, #4]
3418f1e4:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
3418f1e6:	68bb      	ldr	r3, [r7, #8]
3418f1e8:	431a      	orrs	r2, r3
3418f1ea:	687b      	ldr	r3, [r7, #4]
3418f1ec:	635a      	str	r2, [r3, #52]	@ 0x34
          HAL_SD_ErrorCallback(hsd);
3418f1ee:	6878      	ldr	r0, [r7, #4]
3418f1f0:	f000 f8f8 	bl	3418f3e4 <HAL_SD_ErrorCallback>
      hsd->State = HAL_SD_STATE_READY;
3418f1f4:	687b      	ldr	r3, [r7, #4]
3418f1f6:	2201      	movs	r2, #1
3418f1f8:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
      hsd->Context = SD_CONTEXT_NONE;
3418f1fc:	687b      	ldr	r3, [r7, #4]
3418f1fe:	2200      	movs	r2, #0
3418f200:	62da      	str	r2, [r3, #44]	@ 0x2c
      if (((context & SD_CONTEXT_WRITE_SINGLE_BLOCK) != 0U) || ((context & SD_CONTEXT_WRITE_MULTIPLE_BLOCK) != 0U))
3418f202:	68fb      	ldr	r3, [r7, #12]
3418f204:	f003 0310 	and.w	r3, r3, #16
3418f208:	2b00      	cmp	r3, #0
3418f20a:	d104      	bne.n	3418f216 <HAL_SD_IRQHandler+0x176>
3418f20c:	68fb      	ldr	r3, [r7, #12]
3418f20e:	f003 0320 	and.w	r3, r3, #32
3418f212:	2b00      	cmp	r3, #0
3418f214:	d002      	beq.n	3418f21c <HAL_SD_IRQHandler+0x17c>
        HAL_SD_TxCpltCallback(hsd);
3418f216:	6878      	ldr	r0, [r7, #4]
3418f218:	f7f3 febe 	bl	34182f98 <HAL_SD_TxCpltCallback>
      if (((context & SD_CONTEXT_READ_SINGLE_BLOCK) != 0U) || ((context & SD_CONTEXT_READ_MULTIPLE_BLOCK) != 0U))
3418f21c:	68fb      	ldr	r3, [r7, #12]
3418f21e:	f003 0301 	and.w	r3, r3, #1
3418f222:	2b00      	cmp	r3, #0
3418f224:	d105      	bne.n	3418f232 <HAL_SD_IRQHandler+0x192>
3418f226:	68fb      	ldr	r3, [r7, #12]
3418f228:	f003 0302 	and.w	r3, r3, #2
3418f22c:	2b00      	cmp	r3, #0
3418f22e:	f000 80d5 	beq.w	3418f3dc <HAL_SD_IRQHandler+0x33c>
        HAL_SD_RxCpltCallback(hsd);
3418f232:	6878      	ldr	r0, [r7, #4]
3418f234:	f7f3 fec4 	bl	34182fc0 <HAL_SD_RxCpltCallback>
}
3418f238:	e0d0      	b.n	3418f3dc <HAL_SD_IRQHandler+0x33c>
  else if ((__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXFIFOHE) != RESET) && ((context & SD_CONTEXT_IT) != 0U))
3418f23a:	687b      	ldr	r3, [r7, #4]
3418f23c:	681b      	ldr	r3, [r3, #0]
3418f23e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3418f240:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
3418f244:	2b00      	cmp	r3, #0
3418f246:	d008      	beq.n	3418f25a <HAL_SD_IRQHandler+0x1ba>
3418f248:	68fb      	ldr	r3, [r7, #12]
3418f24a:	f003 0308 	and.w	r3, r3, #8
3418f24e:	2b00      	cmp	r3, #0
3418f250:	d003      	beq.n	3418f25a <HAL_SD_IRQHandler+0x1ba>
    SD_Write_IT(hsd);
3418f252:	6878      	ldr	r0, [r7, #4]
3418f254:	f001 f8a1 	bl	3419039a <SD_Write_IT>
3418f258:	e0c0      	b.n	3418f3dc <HAL_SD_IRQHandler+0x33c>
  else if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_RXOVERR |
3418f25a:	687b      	ldr	r3, [r7, #4]
3418f25c:	681b      	ldr	r3, [r3, #0]
3418f25e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3418f260:	f003 033a 	and.w	r3, r3, #58	@ 0x3a
3418f264:	2b00      	cmp	r3, #0
3418f266:	f000 809d 	beq.w	3418f3a4 <HAL_SD_IRQHandler+0x304>
    if (__HAL_SD_GET_FLAG(hsd, SDMMC_IT_DCRCFAIL) != RESET)
3418f26a:	687b      	ldr	r3, [r7, #4]
3418f26c:	681b      	ldr	r3, [r3, #0]
3418f26e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3418f270:	f003 0302 	and.w	r3, r3, #2
3418f274:	2b00      	cmp	r3, #0
3418f276:	d005      	beq.n	3418f284 <HAL_SD_IRQHandler+0x1e4>
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_CRC_FAIL;
3418f278:	687b      	ldr	r3, [r7, #4]
3418f27a:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3418f27c:	f043 0202 	orr.w	r2, r3, #2
3418f280:	687b      	ldr	r3, [r7, #4]
3418f282:	635a      	str	r2, [r3, #52]	@ 0x34
    if (__HAL_SD_GET_FLAG(hsd, SDMMC_IT_DTIMEOUT) != RESET)
3418f284:	687b      	ldr	r3, [r7, #4]
3418f286:	681b      	ldr	r3, [r3, #0]
3418f288:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3418f28a:	f003 0308 	and.w	r3, r3, #8
3418f28e:	2b00      	cmp	r3, #0
3418f290:	d005      	beq.n	3418f29e <HAL_SD_IRQHandler+0x1fe>
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_TIMEOUT;
3418f292:	687b      	ldr	r3, [r7, #4]
3418f294:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3418f296:	f043 0208 	orr.w	r2, r3, #8
3418f29a:	687b      	ldr	r3, [r7, #4]
3418f29c:	635a      	str	r2, [r3, #52]	@ 0x34
    if (__HAL_SD_GET_FLAG(hsd, SDMMC_IT_RXOVERR) != RESET)
3418f29e:	687b      	ldr	r3, [r7, #4]
3418f2a0:	681b      	ldr	r3, [r3, #0]
3418f2a2:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3418f2a4:	f003 0320 	and.w	r3, r3, #32
3418f2a8:	2b00      	cmp	r3, #0
3418f2aa:	d005      	beq.n	3418f2b8 <HAL_SD_IRQHandler+0x218>
      hsd->ErrorCode |= HAL_SD_ERROR_RX_OVERRUN;
3418f2ac:	687b      	ldr	r3, [r7, #4]
3418f2ae:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3418f2b0:	f043 0220 	orr.w	r2, r3, #32
3418f2b4:	687b      	ldr	r3, [r7, #4]
3418f2b6:	635a      	str	r2, [r3, #52]	@ 0x34
    if (__HAL_SD_GET_FLAG(hsd, SDMMC_IT_TXUNDERR) != RESET)
3418f2b8:	687b      	ldr	r3, [r7, #4]
3418f2ba:	681b      	ldr	r3, [r3, #0]
3418f2bc:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3418f2be:	f003 0310 	and.w	r3, r3, #16
3418f2c2:	2b00      	cmp	r3, #0
3418f2c4:	d005      	beq.n	3418f2d2 <HAL_SD_IRQHandler+0x232>
      hsd->ErrorCode |= HAL_SD_ERROR_TX_UNDERRUN;
3418f2c6:	687b      	ldr	r3, [r7, #4]
3418f2c8:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3418f2ca:	f043 0210 	orr.w	r2, r3, #16
3418f2ce:	687b      	ldr	r3, [r7, #4]
3418f2d0:	635a      	str	r2, [r3, #52]	@ 0x34
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
3418f2d2:	687b      	ldr	r3, [r7, #4]
3418f2d4:	681b      	ldr	r3, [r3, #0]
3418f2d6:	4a3e      	ldr	r2, [pc, #248]	@ (3418f3d0 <HAL_SD_IRQHandler+0x330>)
3418f2d8:	639a      	str	r2, [r3, #56]	@ 0x38
    __HAL_SD_DISABLE_IT(hsd, SDMMC_IT_DATAEND | SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT | \
3418f2da:	687b      	ldr	r3, [r7, #4]
3418f2dc:	681b      	ldr	r3, [r3, #0]
3418f2de:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
3418f2e0:	687b      	ldr	r3, [r7, #4]
3418f2e2:	681b      	ldr	r3, [r3, #0]
3418f2e4:	f422 729d 	bic.w	r2, r2, #314	@ 0x13a
3418f2e8:	63da      	str	r2, [r3, #60]	@ 0x3c
    __SDMMC_CMDTRANS_DISABLE(hsd->Instance);
3418f2ea:	687b      	ldr	r3, [r7, #4]
3418f2ec:	681b      	ldr	r3, [r3, #0]
3418f2ee:	68da      	ldr	r2, [r3, #12]
3418f2f0:	687b      	ldr	r3, [r7, #4]
3418f2f2:	681b      	ldr	r3, [r3, #0]
3418f2f4:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
3418f2f8:	60da      	str	r2, [r3, #12]
    hsd->Instance->DCTRL |= SDMMC_DCTRL_FIFORST;
3418f2fa:	687b      	ldr	r3, [r7, #4]
3418f2fc:	681b      	ldr	r3, [r3, #0]
3418f2fe:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
3418f300:	687b      	ldr	r3, [r7, #4]
3418f302:	681b      	ldr	r3, [r3, #0]
3418f304:	f442 5200 	orr.w	r2, r2, #8192	@ 0x2000
3418f308:	62da      	str	r2, [r3, #44]	@ 0x2c
    hsd->Instance->CMD |= SDMMC_CMD_CMDSTOP;
3418f30a:	687b      	ldr	r3, [r7, #4]
3418f30c:	681b      	ldr	r3, [r3, #0]
3418f30e:	68da      	ldr	r2, [r3, #12]
3418f310:	687b      	ldr	r3, [r7, #4]
3418f312:	681b      	ldr	r3, [r3, #0]
3418f314:	f042 0280 	orr.w	r2, r2, #128	@ 0x80
3418f318:	60da      	str	r2, [r3, #12]
    hsd->ErrorCode |= SDMMC_CmdStopTransfer(hsd->Instance);
3418f31a:	687b      	ldr	r3, [r7, #4]
3418f31c:	681b      	ldr	r3, [r3, #0]
3418f31e:	4618      	mov	r0, r3
3418f320:	f002 fa72 	bl	34191808 <SDMMC_CmdStopTransfer>
3418f324:	4602      	mov	r2, r0
3418f326:	687b      	ldr	r3, [r7, #4]
3418f328:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3418f32a:	431a      	orrs	r2, r3
3418f32c:	687b      	ldr	r3, [r7, #4]
3418f32e:	635a      	str	r2, [r3, #52]	@ 0x34
    hsd->Instance->CMD &= ~(SDMMC_CMD_CMDSTOP);
3418f330:	687b      	ldr	r3, [r7, #4]
3418f332:	681b      	ldr	r3, [r3, #0]
3418f334:	68da      	ldr	r2, [r3, #12]
3418f336:	687b      	ldr	r3, [r7, #4]
3418f338:	681b      	ldr	r3, [r3, #0]
3418f33a:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
3418f33e:	60da      	str	r2, [r3, #12]
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DABORT);
3418f340:	687b      	ldr	r3, [r7, #4]
3418f342:	681b      	ldr	r3, [r3, #0]
3418f344:	f44f 6200 	mov.w	r2, #2048	@ 0x800
3418f348:	639a      	str	r2, [r3, #56]	@ 0x38
    if ((context & SD_CONTEXT_IT) != 0U)
3418f34a:	68fb      	ldr	r3, [r7, #12]
3418f34c:	f003 0308 	and.w	r3, r3, #8
3418f350:	2b00      	cmp	r3, #0
3418f352:	d00a      	beq.n	3418f36a <HAL_SD_IRQHandler+0x2ca>
      hsd->State = HAL_SD_STATE_READY;
3418f354:	687b      	ldr	r3, [r7, #4]
3418f356:	2201      	movs	r2, #1
3418f358:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
      hsd->Context = SD_CONTEXT_NONE;
3418f35c:	687b      	ldr	r3, [r7, #4]
3418f35e:	2200      	movs	r2, #0
3418f360:	62da      	str	r2, [r3, #44]	@ 0x2c
      HAL_SD_ErrorCallback(hsd);
3418f362:	6878      	ldr	r0, [r7, #4]
3418f364:	f000 f83e 	bl	3418f3e4 <HAL_SD_ErrorCallback>
}
3418f368:	e038      	b.n	3418f3dc <HAL_SD_IRQHandler+0x33c>
    else if ((context & SD_CONTEXT_DMA) != 0U)
3418f36a:	68fb      	ldr	r3, [r7, #12]
3418f36c:	f003 0380 	and.w	r3, r3, #128	@ 0x80
3418f370:	2b00      	cmp	r3, #0
3418f372:	d033      	beq.n	3418f3dc <HAL_SD_IRQHandler+0x33c>
      if (hsd->ErrorCode != HAL_SD_ERROR_NONE)
3418f374:	687b      	ldr	r3, [r7, #4]
3418f376:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3418f378:	2b00      	cmp	r3, #0
3418f37a:	d02f      	beq.n	3418f3dc <HAL_SD_IRQHandler+0x33c>
        __HAL_SD_DISABLE_IT(hsd, SDMMC_IT_IDMABTC);
3418f37c:	687b      	ldr	r3, [r7, #4]
3418f37e:	681b      	ldr	r3, [r3, #0]
3418f380:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
3418f382:	687b      	ldr	r3, [r7, #4]
3418f384:	681b      	ldr	r3, [r3, #0]
3418f386:	f022 5280 	bic.w	r2, r2, #268435456	@ 0x10000000
3418f38a:	63da      	str	r2, [r3, #60]	@ 0x3c
        hsd->Instance->IDMACTRL = SDMMC_DISABLE_IDMA;
3418f38c:	687b      	ldr	r3, [r7, #4]
3418f38e:	681b      	ldr	r3, [r3, #0]
3418f390:	2200      	movs	r2, #0
3418f392:	651a      	str	r2, [r3, #80]	@ 0x50
        hsd->State = HAL_SD_STATE_READY;
3418f394:	687b      	ldr	r3, [r7, #4]
3418f396:	2201      	movs	r2, #1
3418f398:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
        HAL_SD_ErrorCallback(hsd);
3418f39c:	6878      	ldr	r0, [r7, #4]
3418f39e:	f000 f821 	bl	3418f3e4 <HAL_SD_ErrorCallback>
}
3418f3a2:	e01b      	b.n	3418f3dc <HAL_SD_IRQHandler+0x33c>
  else if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_IDMABTC) != RESET)
3418f3a4:	687b      	ldr	r3, [r7, #4]
3418f3a6:	681b      	ldr	r3, [r3, #0]
3418f3a8:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3418f3aa:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
3418f3ae:	2b00      	cmp	r3, #0
3418f3b0:	d014      	beq.n	3418f3dc <HAL_SD_IRQHandler+0x33c>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_IDMABTC);
3418f3b2:	687b      	ldr	r3, [r7, #4]
3418f3b4:	681b      	ldr	r3, [r3, #0]
3418f3b6:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
3418f3ba:	639a      	str	r2, [r3, #56]	@ 0x38
    if ((context & SD_CONTEXT_WRITE_MULTIPLE_BLOCK) != 0U)
3418f3bc:	68fb      	ldr	r3, [r7, #12]
3418f3be:	f003 0320 	and.w	r3, r3, #32
3418f3c2:	2b00      	cmp	r3, #0
3418f3c4:	d006      	beq.n	3418f3d4 <HAL_SD_IRQHandler+0x334>
      HAL_SDEx_Write_DMALnkLstBufCpltCallback(hsd);
3418f3c6:	6878      	ldr	r0, [r7, #4]
3418f3c8:	f001 f83c 	bl	34190444 <HAL_SDEx_Write_DMALnkLstBufCpltCallback>
}
3418f3cc:	e006      	b.n	3418f3dc <HAL_SD_IRQHandler+0x33c>
3418f3ce:	bf00      	nop
3418f3d0:	18000f3a 	.word	0x18000f3a
      HAL_SDEx_Read_DMALnkLstBufCpltCallback(hsd);
3418f3d4:	6878      	ldr	r0, [r7, #4]
3418f3d6:	f001 f82b 	bl	34190430 <HAL_SDEx_Read_DMALnkLstBufCpltCallback>
}
3418f3da:	e7ff      	b.n	3418f3dc <HAL_SD_IRQHandler+0x33c>
3418f3dc:	bf00      	nop
3418f3de:	3710      	adds	r7, #16
3418f3e0:	46bd      	mov	sp, r7
3418f3e2:	bd80      	pop	{r7, pc}

3418f3e4 <HAL_SD_ErrorCallback>:
  * @brief SD error callbacks
  * @param hsd: Pointer SD handle
  * @retval None
  */
__weak void HAL_SD_ErrorCallback(SD_HandleTypeDef *hsd)
{
3418f3e4:	b480      	push	{r7}
3418f3e6:	b083      	sub	sp, #12
3418f3e8:	af00      	add	r7, sp, #0
3418f3ea:	6078      	str	r0, [r7, #4]
  UNUSED(hsd);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SD_ErrorCallback can be implemented in the user file
   */
}
3418f3ec:	bf00      	nop
3418f3ee:	370c      	adds	r7, #12
3418f3f0:	46bd      	mov	sp, r7
3418f3f2:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f3f6:	4770      	bx	lr

3418f3f8 <HAL_SD_GetCardCSD>:
  * @param  pCSD: Pointer to a HAL_SD_CardCSDTypeDef structure that
  *         contains all CSD register parameters
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_GetCardCSD(SD_HandleTypeDef *hsd, HAL_SD_CardCSDTypeDef *pCSD)
{
3418f3f8:	b480      	push	{r7}
3418f3fa:	b083      	sub	sp, #12
3418f3fc:	af00      	add	r7, sp, #0
3418f3fe:	6078      	str	r0, [r7, #4]
3418f400:	6039      	str	r1, [r7, #0]
  pCSD->CSDStruct = (uint8_t)((hsd->CSD[0] & 0xC0000000U) >> 30U);
3418f402:	687b      	ldr	r3, [r7, #4]
3418f404:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
3418f406:	0f9b      	lsrs	r3, r3, #30
3418f408:	b2da      	uxtb	r2, r3
3418f40a:	683b      	ldr	r3, [r7, #0]
3418f40c:	701a      	strb	r2, [r3, #0]

  pCSD->SysSpecVersion = (uint8_t)((hsd->CSD[0] & 0x3C000000U) >> 26U);
3418f40e:	687b      	ldr	r3, [r7, #4]
3418f410:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
3418f412:	0e9b      	lsrs	r3, r3, #26
3418f414:	b2db      	uxtb	r3, r3
3418f416:	f003 030f 	and.w	r3, r3, #15
3418f41a:	b2da      	uxtb	r2, r3
3418f41c:	683b      	ldr	r3, [r7, #0]
3418f41e:	705a      	strb	r2, [r3, #1]

  pCSD->Reserved1 = (uint8_t)((hsd->CSD[0] & 0x03000000U) >> 24U);
3418f420:	687b      	ldr	r3, [r7, #4]
3418f422:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
3418f424:	0e1b      	lsrs	r3, r3, #24
3418f426:	b2db      	uxtb	r3, r3
3418f428:	f003 0303 	and.w	r3, r3, #3
3418f42c:	b2da      	uxtb	r2, r3
3418f42e:	683b      	ldr	r3, [r7, #0]
3418f430:	709a      	strb	r2, [r3, #2]

  pCSD->TAAC = (uint8_t)((hsd->CSD[0] & 0x00FF0000U) >> 16U);
3418f432:	687b      	ldr	r3, [r7, #4]
3418f434:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
3418f436:	0c1b      	lsrs	r3, r3, #16
3418f438:	b2da      	uxtb	r2, r3
3418f43a:	683b      	ldr	r3, [r7, #0]
3418f43c:	70da      	strb	r2, [r3, #3]

  pCSD->NSAC = (uint8_t)((hsd->CSD[0] & 0x0000FF00U) >> 8U);
3418f43e:	687b      	ldr	r3, [r7, #4]
3418f440:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
3418f442:	0a1b      	lsrs	r3, r3, #8
3418f444:	b2da      	uxtb	r2, r3
3418f446:	683b      	ldr	r3, [r7, #0]
3418f448:	711a      	strb	r2, [r3, #4]

  pCSD->MaxBusClkFrec = (uint8_t)(hsd->CSD[0] & 0x000000FFU);
3418f44a:	687b      	ldr	r3, [r7, #4]
3418f44c:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
3418f44e:	b2da      	uxtb	r2, r3
3418f450:	683b      	ldr	r3, [r7, #0]
3418f452:	715a      	strb	r2, [r3, #5]

  pCSD->CardComdClasses = (uint16_t)((hsd->CSD[1] & 0xFFF00000U) >> 20U);
3418f454:	687b      	ldr	r3, [r7, #4]
3418f456:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3418f458:	0d1b      	lsrs	r3, r3, #20
3418f45a:	b29a      	uxth	r2, r3
3418f45c:	683b      	ldr	r3, [r7, #0]
3418f45e:	80da      	strh	r2, [r3, #6]

  pCSD->RdBlockLen = (uint8_t)((hsd->CSD[1] & 0x000F0000U) >> 16U);
3418f460:	687b      	ldr	r3, [r7, #4]
3418f462:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3418f464:	0c1b      	lsrs	r3, r3, #16
3418f466:	b2db      	uxtb	r3, r3
3418f468:	f003 030f 	and.w	r3, r3, #15
3418f46c:	b2da      	uxtb	r2, r3
3418f46e:	683b      	ldr	r3, [r7, #0]
3418f470:	721a      	strb	r2, [r3, #8]

  pCSD->PartBlockRead   = (uint8_t)((hsd->CSD[1] & 0x00008000U) >> 15U);
3418f472:	687b      	ldr	r3, [r7, #4]
3418f474:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3418f476:	0bdb      	lsrs	r3, r3, #15
3418f478:	b2db      	uxtb	r3, r3
3418f47a:	f003 0301 	and.w	r3, r3, #1
3418f47e:	b2da      	uxtb	r2, r3
3418f480:	683b      	ldr	r3, [r7, #0]
3418f482:	725a      	strb	r2, [r3, #9]

  pCSD->WrBlockMisalign = (uint8_t)((hsd->CSD[1] & 0x00004000U) >> 14U);
3418f484:	687b      	ldr	r3, [r7, #4]
3418f486:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3418f488:	0b9b      	lsrs	r3, r3, #14
3418f48a:	b2db      	uxtb	r3, r3
3418f48c:	f003 0301 	and.w	r3, r3, #1
3418f490:	b2da      	uxtb	r2, r3
3418f492:	683b      	ldr	r3, [r7, #0]
3418f494:	729a      	strb	r2, [r3, #10]

  pCSD->RdBlockMisalign = (uint8_t)((hsd->CSD[1] & 0x00002000U) >> 13U);
3418f496:	687b      	ldr	r3, [r7, #4]
3418f498:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3418f49a:	0b5b      	lsrs	r3, r3, #13
3418f49c:	b2db      	uxtb	r3, r3
3418f49e:	f003 0301 	and.w	r3, r3, #1
3418f4a2:	b2da      	uxtb	r2, r3
3418f4a4:	683b      	ldr	r3, [r7, #0]
3418f4a6:	72da      	strb	r2, [r3, #11]

  pCSD->DSRImpl = (uint8_t)((hsd->CSD[1] & 0x00001000U) >> 12U);
3418f4a8:	687b      	ldr	r3, [r7, #4]
3418f4aa:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3418f4ac:	0b1b      	lsrs	r3, r3, #12
3418f4ae:	b2db      	uxtb	r3, r3
3418f4b0:	f003 0301 	and.w	r3, r3, #1
3418f4b4:	b2da      	uxtb	r2, r3
3418f4b6:	683b      	ldr	r3, [r7, #0]
3418f4b8:	731a      	strb	r2, [r3, #12]

  pCSD->Reserved2 = 0U; /*!< Reserved */
3418f4ba:	683b      	ldr	r3, [r7, #0]
3418f4bc:	2200      	movs	r2, #0
3418f4be:	735a      	strb	r2, [r3, #13]

  if (hsd->SdCard.CardType == CARD_SDSC)
3418f4c0:	687b      	ldr	r3, [r7, #4]
3418f4c2:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3418f4c4:	2b00      	cmp	r3, #0
3418f4c6:	d163      	bne.n	3418f590 <HAL_SD_GetCardCSD+0x198>
  {
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x000003FFU) << 2U) | ((hsd->CSD[2] & 0xC0000000U) >> 30U));
3418f4c8:	687b      	ldr	r3, [r7, #4]
3418f4ca:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3418f4cc:	009a      	lsls	r2, r3, #2
3418f4ce:	f640 73fc 	movw	r3, #4092	@ 0xffc
3418f4d2:	4013      	ands	r3, r2
3418f4d4:	687a      	ldr	r2, [r7, #4]
3418f4d6:	6e52      	ldr	r2, [r2, #100]	@ 0x64
3418f4d8:	0f92      	lsrs	r2, r2, #30
3418f4da:	431a      	orrs	r2, r3
3418f4dc:	683b      	ldr	r3, [r7, #0]
3418f4de:	611a      	str	r2, [r3, #16]

    pCSD->MaxRdCurrentVDDMin = (uint8_t)((hsd->CSD[2] & 0x38000000U) >> 27U);
3418f4e0:	687b      	ldr	r3, [r7, #4]
3418f4e2:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
3418f4e4:	0edb      	lsrs	r3, r3, #27
3418f4e6:	b2db      	uxtb	r3, r3
3418f4e8:	f003 0307 	and.w	r3, r3, #7
3418f4ec:	b2da      	uxtb	r2, r3
3418f4ee:	683b      	ldr	r3, [r7, #0]
3418f4f0:	751a      	strb	r2, [r3, #20]

    pCSD->MaxRdCurrentVDDMax = (uint8_t)((hsd->CSD[2] & 0x07000000U) >> 24U);
3418f4f2:	687b      	ldr	r3, [r7, #4]
3418f4f4:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
3418f4f6:	0e1b      	lsrs	r3, r3, #24
3418f4f8:	b2db      	uxtb	r3, r3
3418f4fa:	f003 0307 	and.w	r3, r3, #7
3418f4fe:	b2da      	uxtb	r2, r3
3418f500:	683b      	ldr	r3, [r7, #0]
3418f502:	755a      	strb	r2, [r3, #21]

    pCSD->MaxWrCurrentVDDMin = (uint8_t)((hsd->CSD[2] & 0x00E00000U) >> 21U);
3418f504:	687b      	ldr	r3, [r7, #4]
3418f506:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
3418f508:	0d5b      	lsrs	r3, r3, #21
3418f50a:	b2db      	uxtb	r3, r3
3418f50c:	f003 0307 	and.w	r3, r3, #7
3418f510:	b2da      	uxtb	r2, r3
3418f512:	683b      	ldr	r3, [r7, #0]
3418f514:	759a      	strb	r2, [r3, #22]

    pCSD->MaxWrCurrentVDDMax = (uint8_t)((hsd->CSD[2] & 0x001C0000U) >> 18U);
3418f516:	687b      	ldr	r3, [r7, #4]
3418f518:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
3418f51a:	0c9b      	lsrs	r3, r3, #18
3418f51c:	b2db      	uxtb	r3, r3
3418f51e:	f003 0307 	and.w	r3, r3, #7
3418f522:	b2da      	uxtb	r2, r3
3418f524:	683b      	ldr	r3, [r7, #0]
3418f526:	75da      	strb	r2, [r3, #23]

    pCSD->DeviceSizeMul = (uint8_t)((hsd->CSD[2] & 0x00038000U) >> 15U);
3418f528:	687b      	ldr	r3, [r7, #4]
3418f52a:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
3418f52c:	0bdb      	lsrs	r3, r3, #15
3418f52e:	b2db      	uxtb	r3, r3
3418f530:	f003 0307 	and.w	r3, r3, #7
3418f534:	b2da      	uxtb	r2, r3
3418f536:	683b      	ldr	r3, [r7, #0]
3418f538:	761a      	strb	r2, [r3, #24]

    hsd->SdCard.BlockNbr  = (pCSD->DeviceSize + 1U) ;
3418f53a:	683b      	ldr	r3, [r7, #0]
3418f53c:	691b      	ldr	r3, [r3, #16]
3418f53e:	1c5a      	adds	r2, r3, #1
3418f540:	687b      	ldr	r3, [r7, #4]
3418f542:	649a      	str	r2, [r3, #72]	@ 0x48
    hsd->SdCard.BlockNbr *= (1UL << ((pCSD->DeviceSizeMul & 0x07U) + 2U));
3418f544:	683b      	ldr	r3, [r7, #0]
3418f546:	7e1b      	ldrb	r3, [r3, #24]
3418f548:	b2db      	uxtb	r3, r3
3418f54a:	f003 0307 	and.w	r3, r3, #7
3418f54e:	3302      	adds	r3, #2
3418f550:	2201      	movs	r2, #1
3418f552:	fa02 f303 	lsl.w	r3, r2, r3
3418f556:	687a      	ldr	r2, [r7, #4]
3418f558:	6c92      	ldr	r2, [r2, #72]	@ 0x48
3418f55a:	fb03 f202 	mul.w	r2, r3, r2
3418f55e:	687b      	ldr	r3, [r7, #4]
3418f560:	649a      	str	r2, [r3, #72]	@ 0x48
    hsd->SdCard.BlockSize = (1UL << (pCSD->RdBlockLen & 0x0FU));
3418f562:	683b      	ldr	r3, [r7, #0]
3418f564:	7a1b      	ldrb	r3, [r3, #8]
3418f566:	b2db      	uxtb	r3, r3
3418f568:	f003 030f 	and.w	r3, r3, #15
3418f56c:	2201      	movs	r2, #1
3418f56e:	409a      	lsls	r2, r3
3418f570:	687b      	ldr	r3, [r7, #4]
3418f572:	64da      	str	r2, [r3, #76]	@ 0x4c

    hsd->SdCard.LogBlockNbr = (hsd->SdCard.BlockNbr) * ((hsd->SdCard.BlockSize) / BLOCKSIZE);
3418f574:	687b      	ldr	r3, [r7, #4]
3418f576:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3418f578:	687a      	ldr	r2, [r7, #4]
3418f57a:	6cd2      	ldr	r2, [r2, #76]	@ 0x4c
3418f57c:	0a52      	lsrs	r2, r2, #9
3418f57e:	fb03 f202 	mul.w	r2, r3, r2
3418f582:	687b      	ldr	r3, [r7, #4]
3418f584:	651a      	str	r2, [r3, #80]	@ 0x50
    hsd->SdCard.LogBlockSize = BLOCKSIZE;
3418f586:	687b      	ldr	r3, [r7, #4]
3418f588:	f44f 7200 	mov.w	r2, #512	@ 0x200
3418f58c:	655a      	str	r2, [r3, #84]	@ 0x54
3418f58e:	e031      	b.n	3418f5f4 <HAL_SD_GetCardCSD+0x1fc>
  }
  else if (hsd->SdCard.CardType == CARD_SDHC_SDXC)
3418f590:	687b      	ldr	r3, [r7, #4]
3418f592:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3418f594:	2b01      	cmp	r3, #1
3418f596:	d11d      	bne.n	3418f5d4 <HAL_SD_GetCardCSD+0x1dc>
  {
    /* Byte 7 */
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x0000003FU) << 16U) | ((hsd->CSD[2] & 0xFFFF0000U) >> 16U));
3418f598:	687b      	ldr	r3, [r7, #4]
3418f59a:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3418f59c:	041b      	lsls	r3, r3, #16
3418f59e:	f403 127c 	and.w	r2, r3, #4128768	@ 0x3f0000
3418f5a2:	687b      	ldr	r3, [r7, #4]
3418f5a4:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
3418f5a6:	0c1b      	lsrs	r3, r3, #16
3418f5a8:	431a      	orrs	r2, r3
3418f5aa:	683b      	ldr	r3, [r7, #0]
3418f5ac:	611a      	str	r2, [r3, #16]

    hsd->SdCard.BlockNbr = ((pCSD->DeviceSize + 1U) * 1024U);
3418f5ae:	683b      	ldr	r3, [r7, #0]
3418f5b0:	691b      	ldr	r3, [r3, #16]
3418f5b2:	3301      	adds	r3, #1
3418f5b4:	029a      	lsls	r2, r3, #10
3418f5b6:	687b      	ldr	r3, [r7, #4]
3418f5b8:	649a      	str	r2, [r3, #72]	@ 0x48
    hsd->SdCard.LogBlockNbr = hsd->SdCard.BlockNbr;
3418f5ba:	687b      	ldr	r3, [r7, #4]
3418f5bc:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3418f5be:	687b      	ldr	r3, [r7, #4]
3418f5c0:	651a      	str	r2, [r3, #80]	@ 0x50
    hsd->SdCard.BlockSize = BLOCKSIZE;
3418f5c2:	687b      	ldr	r3, [r7, #4]
3418f5c4:	f44f 7200 	mov.w	r2, #512	@ 0x200
3418f5c8:	64da      	str	r2, [r3, #76]	@ 0x4c
    hsd->SdCard.LogBlockSize = hsd->SdCard.BlockSize;
3418f5ca:	687b      	ldr	r3, [r7, #4]
3418f5cc:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
3418f5ce:	687b      	ldr	r3, [r7, #4]
3418f5d0:	655a      	str	r2, [r3, #84]	@ 0x54
3418f5d2:	e00f      	b.n	3418f5f4 <HAL_SD_GetCardCSD+0x1fc>
  }
  else
  {
    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
3418f5d4:	687b      	ldr	r3, [r7, #4]
3418f5d6:	681b      	ldr	r3, [r3, #0]
3418f5d8:	4a58      	ldr	r2, [pc, #352]	@ (3418f73c <HAL_SD_GetCardCSD+0x344>)
3418f5da:	639a      	str	r2, [r3, #56]	@ 0x38
    hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
3418f5dc:	687b      	ldr	r3, [r7, #4]
3418f5de:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3418f5e0:	f043 5280 	orr.w	r2, r3, #268435456	@ 0x10000000
3418f5e4:	687b      	ldr	r3, [r7, #4]
3418f5e6:	635a      	str	r2, [r3, #52]	@ 0x34
    hsd->State = HAL_SD_STATE_READY;
3418f5e8:	687b      	ldr	r3, [r7, #4]
3418f5ea:	2201      	movs	r2, #1
3418f5ec:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
    return HAL_ERROR;
3418f5f0:	2301      	movs	r3, #1
3418f5f2:	e09d      	b.n	3418f730 <HAL_SD_GetCardCSD+0x338>
  }

  pCSD->EraseGrSize = (uint8_t)((hsd->CSD[2] & 0x00004000U) >> 14U);
3418f5f4:	687b      	ldr	r3, [r7, #4]
3418f5f6:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
3418f5f8:	0b9b      	lsrs	r3, r3, #14
3418f5fa:	b2db      	uxtb	r3, r3
3418f5fc:	f003 0301 	and.w	r3, r3, #1
3418f600:	b2da      	uxtb	r2, r3
3418f602:	683b      	ldr	r3, [r7, #0]
3418f604:	765a      	strb	r2, [r3, #25]

  pCSD->EraseGrMul = (uint8_t)((hsd->CSD[2] & 0x00003F80U) >> 7U);
3418f606:	687b      	ldr	r3, [r7, #4]
3418f608:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
3418f60a:	09db      	lsrs	r3, r3, #7
3418f60c:	b2db      	uxtb	r3, r3
3418f60e:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
3418f612:	b2da      	uxtb	r2, r3
3418f614:	683b      	ldr	r3, [r7, #0]
3418f616:	769a      	strb	r2, [r3, #26]

  pCSD->WrProtectGrSize = (uint8_t)(hsd->CSD[2] & 0x0000007FU);
3418f618:	687b      	ldr	r3, [r7, #4]
3418f61a:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
3418f61c:	b2db      	uxtb	r3, r3
3418f61e:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
3418f622:	b2da      	uxtb	r2, r3
3418f624:	683b      	ldr	r3, [r7, #0]
3418f626:	76da      	strb	r2, [r3, #27]

  pCSD->WrProtectGrEnable = (uint8_t)((hsd->CSD[3] & 0x80000000U) >> 31U);
3418f628:	687b      	ldr	r3, [r7, #4]
3418f62a:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
3418f62c:	0fdb      	lsrs	r3, r3, #31
3418f62e:	b2da      	uxtb	r2, r3
3418f630:	683b      	ldr	r3, [r7, #0]
3418f632:	771a      	strb	r2, [r3, #28]

  pCSD->ManDeflECC = (uint8_t)((hsd->CSD[3] & 0x60000000U) >> 29U);
3418f634:	687b      	ldr	r3, [r7, #4]
3418f636:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
3418f638:	0f5b      	lsrs	r3, r3, #29
3418f63a:	b2db      	uxtb	r3, r3
3418f63c:	f003 0303 	and.w	r3, r3, #3
3418f640:	b2da      	uxtb	r2, r3
3418f642:	683b      	ldr	r3, [r7, #0]
3418f644:	775a      	strb	r2, [r3, #29]

  pCSD->WrSpeedFact = (uint8_t)((hsd->CSD[3] & 0x1C000000U) >> 26U);
3418f646:	687b      	ldr	r3, [r7, #4]
3418f648:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
3418f64a:	0e9b      	lsrs	r3, r3, #26
3418f64c:	b2db      	uxtb	r3, r3
3418f64e:	f003 0307 	and.w	r3, r3, #7
3418f652:	b2da      	uxtb	r2, r3
3418f654:	683b      	ldr	r3, [r7, #0]
3418f656:	779a      	strb	r2, [r3, #30]

  pCSD->MaxWrBlockLen = (uint8_t)((hsd->CSD[3] & 0x03C00000U) >> 22U);
3418f658:	687b      	ldr	r3, [r7, #4]
3418f65a:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
3418f65c:	0d9b      	lsrs	r3, r3, #22
3418f65e:	b2db      	uxtb	r3, r3
3418f660:	f003 030f 	and.w	r3, r3, #15
3418f664:	b2da      	uxtb	r2, r3
3418f666:	683b      	ldr	r3, [r7, #0]
3418f668:	77da      	strb	r2, [r3, #31]

  pCSD->WriteBlockPaPartial = (uint8_t)((hsd->CSD[3] & 0x00200000U) >> 21U);
3418f66a:	687b      	ldr	r3, [r7, #4]
3418f66c:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
3418f66e:	0d5b      	lsrs	r3, r3, #21
3418f670:	b2db      	uxtb	r3, r3
3418f672:	f003 0301 	and.w	r3, r3, #1
3418f676:	b2da      	uxtb	r2, r3
3418f678:	683b      	ldr	r3, [r7, #0]
3418f67a:	f883 2020 	strb.w	r2, [r3, #32]

  pCSD->Reserved3 = 0;
3418f67e:	683b      	ldr	r3, [r7, #0]
3418f680:	2200      	movs	r2, #0
3418f682:	f883 2021 	strb.w	r2, [r3, #33]	@ 0x21

  pCSD->ContentProtectAppli = (uint8_t)((hsd->CSD[3] & 0x00010000U) >> 16U);
3418f686:	687b      	ldr	r3, [r7, #4]
3418f688:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
3418f68a:	0c1b      	lsrs	r3, r3, #16
3418f68c:	b2db      	uxtb	r3, r3
3418f68e:	f003 0301 	and.w	r3, r3, #1
3418f692:	b2da      	uxtb	r2, r3
3418f694:	683b      	ldr	r3, [r7, #0]
3418f696:	f883 2022 	strb.w	r2, [r3, #34]	@ 0x22

  pCSD->FileFormatGroup = (uint8_t)((hsd->CSD[3] & 0x00008000U) >> 15U);
3418f69a:	687b      	ldr	r3, [r7, #4]
3418f69c:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
3418f69e:	0bdb      	lsrs	r3, r3, #15
3418f6a0:	b2db      	uxtb	r3, r3
3418f6a2:	f003 0301 	and.w	r3, r3, #1
3418f6a6:	b2da      	uxtb	r2, r3
3418f6a8:	683b      	ldr	r3, [r7, #0]
3418f6aa:	f883 2023 	strb.w	r2, [r3, #35]	@ 0x23

  pCSD->CopyFlag = (uint8_t)((hsd->CSD[3] & 0x00004000U) >> 14U);
3418f6ae:	687b      	ldr	r3, [r7, #4]
3418f6b0:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
3418f6b2:	0b9b      	lsrs	r3, r3, #14
3418f6b4:	b2db      	uxtb	r3, r3
3418f6b6:	f003 0301 	and.w	r3, r3, #1
3418f6ba:	b2da      	uxtb	r2, r3
3418f6bc:	683b      	ldr	r3, [r7, #0]
3418f6be:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24

  pCSD->PermWrProtect = (uint8_t)((hsd->CSD[3] & 0x00002000U) >> 13U);
3418f6c2:	687b      	ldr	r3, [r7, #4]
3418f6c4:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
3418f6c6:	0b5b      	lsrs	r3, r3, #13
3418f6c8:	b2db      	uxtb	r3, r3
3418f6ca:	f003 0301 	and.w	r3, r3, #1
3418f6ce:	b2da      	uxtb	r2, r3
3418f6d0:	683b      	ldr	r3, [r7, #0]
3418f6d2:	f883 2025 	strb.w	r2, [r3, #37]	@ 0x25

  pCSD->TempWrProtect = (uint8_t)((hsd->CSD[3] & 0x00001000U) >> 12U);
3418f6d6:	687b      	ldr	r3, [r7, #4]
3418f6d8:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
3418f6da:	0b1b      	lsrs	r3, r3, #12
3418f6dc:	b2db      	uxtb	r3, r3
3418f6de:	f003 0301 	and.w	r3, r3, #1
3418f6e2:	b2da      	uxtb	r2, r3
3418f6e4:	683b      	ldr	r3, [r7, #0]
3418f6e6:	f883 2026 	strb.w	r2, [r3, #38]	@ 0x26

  pCSD->FileFormat = (uint8_t)((hsd->CSD[3] & 0x00000C00U) >> 10U);
3418f6ea:	687b      	ldr	r3, [r7, #4]
3418f6ec:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
3418f6ee:	0a9b      	lsrs	r3, r3, #10
3418f6f0:	b2db      	uxtb	r3, r3
3418f6f2:	f003 0303 	and.w	r3, r3, #3
3418f6f6:	b2da      	uxtb	r2, r3
3418f6f8:	683b      	ldr	r3, [r7, #0]
3418f6fa:	f883 2027 	strb.w	r2, [r3, #39]	@ 0x27

  pCSD->ECC = (uint8_t)((hsd->CSD[3] & 0x00000300U) >> 8U);
3418f6fe:	687b      	ldr	r3, [r7, #4]
3418f700:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
3418f702:	0a1b      	lsrs	r3, r3, #8
3418f704:	b2db      	uxtb	r3, r3
3418f706:	f003 0303 	and.w	r3, r3, #3
3418f70a:	b2da      	uxtb	r2, r3
3418f70c:	683b      	ldr	r3, [r7, #0]
3418f70e:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28

  pCSD->CSD_CRC = (uint8_t)((hsd->CSD[3] & 0x000000FEU) >> 1U);
3418f712:	687b      	ldr	r3, [r7, #4]
3418f714:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
3418f716:	085b      	lsrs	r3, r3, #1
3418f718:	b2db      	uxtb	r3, r3
3418f71a:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
3418f71e:	b2da      	uxtb	r2, r3
3418f720:	683b      	ldr	r3, [r7, #0]
3418f722:	f883 2029 	strb.w	r2, [r3, #41]	@ 0x29

  pCSD->Reserved4 = 1;
3418f726:	683b      	ldr	r3, [r7, #0]
3418f728:	2201      	movs	r2, #1
3418f72a:	f883 202a 	strb.w	r2, [r3, #42]	@ 0x2a

  return HAL_OK;
3418f72e:	2300      	movs	r3, #0
}
3418f730:	4618      	mov	r0, r3
3418f732:	370c      	adds	r7, #12
3418f734:	46bd      	mov	sp, r7
3418f736:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f73a:	4770      	bx	lr
3418f73c:	1fe00fff 	.word	0x1fe00fff

3418f740 <HAL_SD_GetCardStatus>:
  * @param  pStatus: Pointer to the HAL_SD_CardStatusTypeDef structure that
  *         will contain the SD card status information
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_GetCardStatus(SD_HandleTypeDef *hsd, HAL_SD_CardStatusTypeDef *pStatus)
{
3418f740:	b580      	push	{r7, lr}
3418f742:	b094      	sub	sp, #80	@ 0x50
3418f744:	af00      	add	r7, sp, #0
3418f746:	6078      	str	r0, [r7, #4]
3418f748:	6039      	str	r1, [r7, #0]
  uint32_t sd_status[16];
  uint32_t errorstate;
  HAL_StatusTypeDef status = HAL_OK;
3418f74a:	2300      	movs	r3, #0
3418f74c:	f887 304f 	strb.w	r3, [r7, #79]	@ 0x4f

  if (hsd->State == HAL_SD_STATE_BUSY)
3418f750:	687b      	ldr	r3, [r7, #4]
3418f752:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
3418f756:	b2db      	uxtb	r3, r3
3418f758:	2b03      	cmp	r3, #3
3418f75a:	d101      	bne.n	3418f760 <HAL_SD_GetCardStatus+0x20>
  {
    return HAL_ERROR;
3418f75c:	2301      	movs	r3, #1
3418f75e:	e0a7      	b.n	3418f8b0 <HAL_SD_GetCardStatus+0x170>
  }

  errorstate = SD_SendSDStatus(hsd, sd_status);
3418f760:	f107 0308 	add.w	r3, r7, #8
3418f764:	4619      	mov	r1, r3
3418f766:	6878      	ldr	r0, [r7, #4]
3418f768:	f000 fb72 	bl	3418fe50 <SD_SendSDStatus>
3418f76c:	64b8      	str	r0, [r7, #72]	@ 0x48
  if (errorstate != HAL_SD_ERROR_NONE)
3418f76e:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3418f770:	2b00      	cmp	r3, #0
3418f772:	d011      	beq.n	3418f798 <HAL_SD_GetCardStatus+0x58>
  {
    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
3418f774:	687b      	ldr	r3, [r7, #4]
3418f776:	681b      	ldr	r3, [r3, #0]
3418f778:	4a4f      	ldr	r2, [pc, #316]	@ (3418f8b8 <HAL_SD_GetCardStatus+0x178>)
3418f77a:	639a      	str	r2, [r3, #56]	@ 0x38
    hsd->ErrorCode |= errorstate;
3418f77c:	687b      	ldr	r3, [r7, #4]
3418f77e:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
3418f780:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3418f782:	431a      	orrs	r2, r3
3418f784:	687b      	ldr	r3, [r7, #4]
3418f786:	635a      	str	r2, [r3, #52]	@ 0x34
    hsd->State = HAL_SD_STATE_READY;
3418f788:	687b      	ldr	r3, [r7, #4]
3418f78a:	2201      	movs	r2, #1
3418f78c:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
    status = HAL_ERROR;
3418f790:	2301      	movs	r3, #1
3418f792:	f887 304f 	strb.w	r3, [r7, #79]	@ 0x4f
3418f796:	e070      	b.n	3418f87a <HAL_SD_GetCardStatus+0x13a>
  }
  else
  {
    pStatus->DataBusWidth = (uint8_t)((sd_status[0] & 0xC0U) >> 6U);
3418f798:	68bb      	ldr	r3, [r7, #8]
3418f79a:	099b      	lsrs	r3, r3, #6
3418f79c:	b2db      	uxtb	r3, r3
3418f79e:	f003 0303 	and.w	r3, r3, #3
3418f7a2:	b2da      	uxtb	r2, r3
3418f7a4:	683b      	ldr	r3, [r7, #0]
3418f7a6:	701a      	strb	r2, [r3, #0]

    pStatus->SecuredMode = (uint8_t)((sd_status[0] & 0x20U) >> 5U);
3418f7a8:	68bb      	ldr	r3, [r7, #8]
3418f7aa:	095b      	lsrs	r3, r3, #5
3418f7ac:	b2db      	uxtb	r3, r3
3418f7ae:	f003 0301 	and.w	r3, r3, #1
3418f7b2:	b2da      	uxtb	r2, r3
3418f7b4:	683b      	ldr	r3, [r7, #0]
3418f7b6:	705a      	strb	r2, [r3, #1]

    pStatus->CardType = (uint16_t)(((sd_status[0] & 0x00FF0000U) >> 8U) | ((sd_status[0] & 0xFF000000U) >> 24U));
3418f7b8:	68bb      	ldr	r3, [r7, #8]
3418f7ba:	0a1b      	lsrs	r3, r3, #8
3418f7bc:	b29b      	uxth	r3, r3
3418f7be:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
3418f7c2:	b29a      	uxth	r2, r3
3418f7c4:	68bb      	ldr	r3, [r7, #8]
3418f7c6:	0e1b      	lsrs	r3, r3, #24
3418f7c8:	b29b      	uxth	r3, r3
3418f7ca:	4313      	orrs	r3, r2
3418f7cc:	b29a      	uxth	r2, r3
3418f7ce:	683b      	ldr	r3, [r7, #0]
3418f7d0:	805a      	strh	r2, [r3, #2]

    pStatus->ProtectedAreaSize = (((sd_status[1] & 0xFFU) << 24U)    | ((sd_status[1] & 0xFF00U) << 8U) |
3418f7d2:	68fb      	ldr	r3, [r7, #12]
3418f7d4:	061a      	lsls	r2, r3, #24
3418f7d6:	68fb      	ldr	r3, [r7, #12]
3418f7d8:	021b      	lsls	r3, r3, #8
3418f7da:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
3418f7de:	431a      	orrs	r2, r3
                                  ((sd_status[1] & 0xFF0000U) >> 8U) | ((sd_status[1] & 0xFF000000U) >> 24U));
3418f7e0:	68fb      	ldr	r3, [r7, #12]
3418f7e2:	0a1b      	lsrs	r3, r3, #8
3418f7e4:	f403 437f 	and.w	r3, r3, #65280	@ 0xff00
    pStatus->ProtectedAreaSize = (((sd_status[1] & 0xFFU) << 24U)    | ((sd_status[1] & 0xFF00U) << 8U) |
3418f7e8:	431a      	orrs	r2, r3
                                  ((sd_status[1] & 0xFF0000U) >> 8U) | ((sd_status[1] & 0xFF000000U) >> 24U));
3418f7ea:	68fb      	ldr	r3, [r7, #12]
3418f7ec:	0e1b      	lsrs	r3, r3, #24
3418f7ee:	431a      	orrs	r2, r3
    pStatus->ProtectedAreaSize = (((sd_status[1] & 0xFFU) << 24U)    | ((sd_status[1] & 0xFF00U) << 8U) |
3418f7f0:	683b      	ldr	r3, [r7, #0]
3418f7f2:	605a      	str	r2, [r3, #4]

    pStatus->SpeedClass = (uint8_t)(sd_status[2] & 0xFFU);
3418f7f4:	693b      	ldr	r3, [r7, #16]
3418f7f6:	b2da      	uxtb	r2, r3
3418f7f8:	683b      	ldr	r3, [r7, #0]
3418f7fa:	721a      	strb	r2, [r3, #8]

    pStatus->PerformanceMove = (uint8_t)((sd_status[2] & 0xFF00U) >> 8U);
3418f7fc:	693b      	ldr	r3, [r7, #16]
3418f7fe:	0a1b      	lsrs	r3, r3, #8
3418f800:	b2da      	uxtb	r2, r3
3418f802:	683b      	ldr	r3, [r7, #0]
3418f804:	725a      	strb	r2, [r3, #9]

    pStatus->AllocationUnitSize = (uint8_t)((sd_status[2] & 0xF00000U) >> 20U);
3418f806:	693b      	ldr	r3, [r7, #16]
3418f808:	0d1b      	lsrs	r3, r3, #20
3418f80a:	b2db      	uxtb	r3, r3
3418f80c:	f003 030f 	and.w	r3, r3, #15
3418f810:	b2da      	uxtb	r2, r3
3418f812:	683b      	ldr	r3, [r7, #0]
3418f814:	729a      	strb	r2, [r3, #10]

    pStatus->EraseSize = (uint16_t)(((sd_status[2] & 0xFF000000U) >> 16U) | (sd_status[3] & 0xFFU));
3418f816:	693b      	ldr	r3, [r7, #16]
3418f818:	0c1b      	lsrs	r3, r3, #16
3418f81a:	b29b      	uxth	r3, r3
3418f81c:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
3418f820:	b29a      	uxth	r2, r3
3418f822:	697b      	ldr	r3, [r7, #20]
3418f824:	b29b      	uxth	r3, r3
3418f826:	b2db      	uxtb	r3, r3
3418f828:	b29b      	uxth	r3, r3
3418f82a:	4313      	orrs	r3, r2
3418f82c:	b29a      	uxth	r2, r3
3418f82e:	683b      	ldr	r3, [r7, #0]
3418f830:	819a      	strh	r2, [r3, #12]

    pStatus->EraseTimeout = (uint8_t)((sd_status[3] & 0xFC00U) >> 10U);
3418f832:	697b      	ldr	r3, [r7, #20]
3418f834:	0a9b      	lsrs	r3, r3, #10
3418f836:	b2db      	uxtb	r3, r3
3418f838:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
3418f83c:	b2da      	uxtb	r2, r3
3418f83e:	683b      	ldr	r3, [r7, #0]
3418f840:	739a      	strb	r2, [r3, #14]

    pStatus->EraseOffset = (uint8_t)((sd_status[3] & 0x0300U) >> 8U);
3418f842:	697b      	ldr	r3, [r7, #20]
3418f844:	0a1b      	lsrs	r3, r3, #8
3418f846:	b2db      	uxtb	r3, r3
3418f848:	f003 0303 	and.w	r3, r3, #3
3418f84c:	b2da      	uxtb	r2, r3
3418f84e:	683b      	ldr	r3, [r7, #0]
3418f850:	73da      	strb	r2, [r3, #15]

    pStatus->UhsSpeedGrade = (uint8_t)((sd_status[3] & 0x00F0U) >> 4U);
3418f852:	697b      	ldr	r3, [r7, #20]
3418f854:	091b      	lsrs	r3, r3, #4
3418f856:	b2db      	uxtb	r3, r3
3418f858:	f003 030f 	and.w	r3, r3, #15
3418f85c:	b2da      	uxtb	r2, r3
3418f85e:	683b      	ldr	r3, [r7, #0]
3418f860:	741a      	strb	r2, [r3, #16]
    pStatus->UhsAllocationUnitSize = (uint8_t)(sd_status[3] & 0x000FU) ;
3418f862:	697b      	ldr	r3, [r7, #20]
3418f864:	b2db      	uxtb	r3, r3
3418f866:	f003 030f 	and.w	r3, r3, #15
3418f86a:	b2da      	uxtb	r2, r3
3418f86c:	683b      	ldr	r3, [r7, #0]
3418f86e:	745a      	strb	r2, [r3, #17]
    pStatus->VideoSpeedClass = (uint8_t)((sd_status[4] & 0xFF000000U) >> 24U);
3418f870:	69bb      	ldr	r3, [r7, #24]
3418f872:	0e1b      	lsrs	r3, r3, #24
3418f874:	b2da      	uxtb	r2, r3
3418f876:	683b      	ldr	r3, [r7, #0]
3418f878:	749a      	strb	r2, [r3, #18]
  }

  /* Set Block Size for Card */
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
3418f87a:	687b      	ldr	r3, [r7, #4]
3418f87c:	681b      	ldr	r3, [r3, #0]
3418f87e:	f44f 7100 	mov.w	r1, #512	@ 0x200
3418f882:	4618      	mov	r0, r3
3418f884:	f001 ff10 	bl	341916a8 <SDMMC_CmdBlockLength>
3418f888:	64b8      	str	r0, [r7, #72]	@ 0x48
  if (errorstate != HAL_SD_ERROR_NONE)
3418f88a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3418f88c:	2b00      	cmp	r3, #0
3418f88e:	d00d      	beq.n	3418f8ac <HAL_SD_GetCardStatus+0x16c>
  {
    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
3418f890:	687b      	ldr	r3, [r7, #4]
3418f892:	681b      	ldr	r3, [r3, #0]
3418f894:	4a08      	ldr	r2, [pc, #32]	@ (3418f8b8 <HAL_SD_GetCardStatus+0x178>)
3418f896:	639a      	str	r2, [r3, #56]	@ 0x38
    hsd->ErrorCode = errorstate;
3418f898:	687b      	ldr	r3, [r7, #4]
3418f89a:	6cba      	ldr	r2, [r7, #72]	@ 0x48
3418f89c:	635a      	str	r2, [r3, #52]	@ 0x34
    hsd->State = HAL_SD_STATE_READY;
3418f89e:	687b      	ldr	r3, [r7, #4]
3418f8a0:	2201      	movs	r2, #1
3418f8a2:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
    status = HAL_ERROR;
3418f8a6:	2301      	movs	r3, #1
3418f8a8:	f887 304f 	strb.w	r3, [r7, #79]	@ 0x4f
  }

  return status;
3418f8ac:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
}
3418f8b0:	4618      	mov	r0, r3
3418f8b2:	3750      	adds	r7, #80	@ 0x50
3418f8b4:	46bd      	mov	sp, r7
3418f8b6:	bd80      	pop	{r7, pc}
3418f8b8:	1fe00fff 	.word	0x1fe00fff

3418f8bc <HAL_SD_GetCardInfo>:
  * @param  pCardInfo: Pointer to the HAL_SD_CardInfoTypeDef structure that
  *         will contain the SD card status information
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_GetCardInfo(const SD_HandleTypeDef *hsd, HAL_SD_CardInfoTypeDef *pCardInfo)
{
3418f8bc:	b480      	push	{r7}
3418f8be:	b083      	sub	sp, #12
3418f8c0:	af00      	add	r7, sp, #0
3418f8c2:	6078      	str	r0, [r7, #4]
3418f8c4:	6039      	str	r1, [r7, #0]
  pCardInfo->CardType     = (uint32_t)(hsd->SdCard.CardType);
3418f8c6:	687b      	ldr	r3, [r7, #4]
3418f8c8:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
3418f8ca:	683b      	ldr	r3, [r7, #0]
3418f8cc:	601a      	str	r2, [r3, #0]
  pCardInfo->CardVersion  = (uint32_t)(hsd->SdCard.CardVersion);
3418f8ce:	687b      	ldr	r3, [r7, #4]
3418f8d0:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
3418f8d2:	683b      	ldr	r3, [r7, #0]
3418f8d4:	605a      	str	r2, [r3, #4]
  pCardInfo->Class        = (uint32_t)(hsd->SdCard.Class);
3418f8d6:	687b      	ldr	r3, [r7, #4]
3418f8d8:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
3418f8da:	683b      	ldr	r3, [r7, #0]
3418f8dc:	609a      	str	r2, [r3, #8]
  pCardInfo->RelCardAdd   = (uint32_t)(hsd->SdCard.RelCardAdd);
3418f8de:	687b      	ldr	r3, [r7, #4]
3418f8e0:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
3418f8e2:	683b      	ldr	r3, [r7, #0]
3418f8e4:	60da      	str	r2, [r3, #12]
  pCardInfo->BlockNbr     = (uint32_t)(hsd->SdCard.BlockNbr);
3418f8e6:	687b      	ldr	r3, [r7, #4]
3418f8e8:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3418f8ea:	683b      	ldr	r3, [r7, #0]
3418f8ec:	611a      	str	r2, [r3, #16]
  pCardInfo->BlockSize    = (uint32_t)(hsd->SdCard.BlockSize);
3418f8ee:	687b      	ldr	r3, [r7, #4]
3418f8f0:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
3418f8f2:	683b      	ldr	r3, [r7, #0]
3418f8f4:	615a      	str	r2, [r3, #20]
  pCardInfo->LogBlockNbr  = (uint32_t)(hsd->SdCard.LogBlockNbr);
3418f8f6:	687b      	ldr	r3, [r7, #4]
3418f8f8:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
3418f8fa:	683b      	ldr	r3, [r7, #0]
3418f8fc:	619a      	str	r2, [r3, #24]
  pCardInfo->LogBlockSize = (uint32_t)(hsd->SdCard.LogBlockSize);
3418f8fe:	687b      	ldr	r3, [r7, #4]
3418f900:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
3418f902:	683b      	ldr	r3, [r7, #0]
3418f904:	61da      	str	r2, [r3, #28]

  return HAL_OK;
3418f906:	2300      	movs	r3, #0
}
3418f908:	4618      	mov	r0, r3
3418f90a:	370c      	adds	r7, #12
3418f90c:	46bd      	mov	sp, r7
3418f90e:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f912:	4770      	bx	lr

3418f914 <HAL_SD_ConfigWideBusOperation>:
  *            @arg SDMMC_BUS_WIDE_4B: 4-bit data transfer
  *            @arg SDMMC_BUS_WIDE_1B: 1-bit data transfer
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_ConfigWideBusOperation(SD_HandleTypeDef *hsd, uint32_t WideMode)
{
3418f914:	b590      	push	{r4, r7, lr}
3418f916:	b08d      	sub	sp, #52	@ 0x34
3418f918:	af02      	add	r7, sp, #8
3418f91a:	6078      	str	r0, [r7, #4]
3418f91c:	6039      	str	r1, [r7, #0]
  SDMMC_InitTypeDef Init;
  uint32_t errorstate;
  uint32_t sdmmc_clk;

  HAL_StatusTypeDef status = HAL_OK;
3418f91e:	2300      	movs	r3, #0
3418f920:	f887 3023 	strb.w	r3, [r7, #35]	@ 0x23

  /* Check the parameters */
  assert_param(IS_SDMMC_BUS_WIDE(WideMode));

  /* Change State */
  hsd->State = HAL_SD_STATE_BUSY;
3418f924:	687b      	ldr	r3, [r7, #4]
3418f926:	2203      	movs	r2, #3
3418f928:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30

  if (hsd->SdCard.CardType != CARD_SECURED)
3418f92c:	687b      	ldr	r3, [r7, #4]
3418f92e:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3418f930:	2b03      	cmp	r3, #3
3418f932:	d02e      	beq.n	3418f992 <HAL_SD_ConfigWideBusOperation+0x7e>
  {
    if (WideMode == SDMMC_BUS_WIDE_8B)
3418f934:	683b      	ldr	r3, [r7, #0]
3418f936:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
3418f93a:	d106      	bne.n	3418f94a <HAL_SD_ConfigWideBusOperation+0x36>
    {
      hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
3418f93c:	687b      	ldr	r3, [r7, #4]
3418f93e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3418f940:	f043 5280 	orr.w	r2, r3, #268435456	@ 0x10000000
3418f944:	687b      	ldr	r3, [r7, #4]
3418f946:	635a      	str	r2, [r3, #52]	@ 0x34
3418f948:	e029      	b.n	3418f99e <HAL_SD_ConfigWideBusOperation+0x8a>
    }
    else if (WideMode == SDMMC_BUS_WIDE_4B)
3418f94a:	683b      	ldr	r3, [r7, #0]
3418f94c:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
3418f950:	d10a      	bne.n	3418f968 <HAL_SD_ConfigWideBusOperation+0x54>
    {
      errorstate = SD_WideBus_Enable(hsd);
3418f952:	6878      	ldr	r0, [r7, #4]
3418f954:	f000 fb74 	bl	34190040 <SD_WideBus_Enable>
3418f958:	61f8      	str	r0, [r7, #28]

      hsd->ErrorCode |= errorstate;
3418f95a:	687b      	ldr	r3, [r7, #4]
3418f95c:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
3418f95e:	69fb      	ldr	r3, [r7, #28]
3418f960:	431a      	orrs	r2, r3
3418f962:	687b      	ldr	r3, [r7, #4]
3418f964:	635a      	str	r2, [r3, #52]	@ 0x34
3418f966:	e01a      	b.n	3418f99e <HAL_SD_ConfigWideBusOperation+0x8a>
    }
    else if (WideMode == SDMMC_BUS_WIDE_1B)
3418f968:	683b      	ldr	r3, [r7, #0]
3418f96a:	2b00      	cmp	r3, #0
3418f96c:	d10a      	bne.n	3418f984 <HAL_SD_ConfigWideBusOperation+0x70>
    {
      errorstate = SD_WideBus_Disable(hsd);
3418f96e:	6878      	ldr	r0, [r7, #4]
3418f970:	f000 fbb1 	bl	341900d6 <SD_WideBus_Disable>
3418f974:	61f8      	str	r0, [r7, #28]

      hsd->ErrorCode |= errorstate;
3418f976:	687b      	ldr	r3, [r7, #4]
3418f978:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
3418f97a:	69fb      	ldr	r3, [r7, #28]
3418f97c:	431a      	orrs	r2, r3
3418f97e:	687b      	ldr	r3, [r7, #4]
3418f980:	635a      	str	r2, [r3, #52]	@ 0x34
3418f982:	e00c      	b.n	3418f99e <HAL_SD_ConfigWideBusOperation+0x8a>
    }
    else
    {
      /* WideMode is not a valid argument*/
      hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
3418f984:	687b      	ldr	r3, [r7, #4]
3418f986:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3418f988:	f043 6200 	orr.w	r2, r3, #134217728	@ 0x8000000
3418f98c:	687b      	ldr	r3, [r7, #4]
3418f98e:	635a      	str	r2, [r3, #52]	@ 0x34
3418f990:	e005      	b.n	3418f99e <HAL_SD_ConfigWideBusOperation+0x8a>
    }
  }
  else
  {
    /* SD Card does not support this feature */
    hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
3418f992:	687b      	ldr	r3, [r7, #4]
3418f994:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3418f996:	f043 5280 	orr.w	r2, r3, #268435456	@ 0x10000000
3418f99a:	687b      	ldr	r3, [r7, #4]
3418f99c:	635a      	str	r2, [r3, #52]	@ 0x34
  }

  if (hsd->ErrorCode != HAL_SD_ERROR_NONE)
3418f99e:	687b      	ldr	r3, [r7, #4]
3418f9a0:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3418f9a2:	2b00      	cmp	r3, #0
3418f9a4:	d007      	beq.n	3418f9b6 <HAL_SD_ConfigWideBusOperation+0xa2>
  {
    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
3418f9a6:	687b      	ldr	r3, [r7, #4]
3418f9a8:	681b      	ldr	r3, [r3, #0]
3418f9aa:	4a66      	ldr	r2, [pc, #408]	@ (3418fb44 <HAL_SD_ConfigWideBusOperation+0x230>)
3418f9ac:	639a      	str	r2, [r3, #56]	@ 0x38
    status = HAL_ERROR;
3418f9ae:	2301      	movs	r3, #1
3418f9b0:	f887 3023 	strb.w	r3, [r7, #35]	@ 0x23
3418f9b4:	e0a3      	b.n	3418fafe <HAL_SD_ConfigWideBusOperation+0x1ea>
  }
  else
  {
    if (hsd->Instance == SDMMC1)
3418f9b6:	687b      	ldr	r3, [r7, #4]
3418f9b8:	681b      	ldr	r3, [r3, #0]
3418f9ba:	4a63      	ldr	r2, [pc, #396]	@ (3418fb48 <HAL_SD_ConfigWideBusOperation+0x234>)
3418f9bc:	4293      	cmp	r3, r2
3418f9be:	d107      	bne.n	3418f9d0 <HAL_SD_ConfigWideBusOperation+0xbc>
    {
      sdmmc_clk = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SDMMC1);
3418f9c0:	f04f 4080 	mov.w	r0, #1073741824	@ 0x40000000
3418f9c4:	f04f 0100 	mov.w	r1, #0
3418f9c8:	f7fe fb94 	bl	3418e0f4 <HAL_RCCEx_GetPeriphCLKFreq>
3418f9cc:	6278      	str	r0, [r7, #36]	@ 0x24
3418f9ce:	e006      	b.n	3418f9de <HAL_SD_ConfigWideBusOperation+0xca>
    }
    else
    {
      sdmmc_clk = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SDMMC2);
3418f9d0:	f04f 4000 	mov.w	r0, #2147483648	@ 0x80000000
3418f9d4:	f04f 0100 	mov.w	r1, #0
3418f9d8:	f7fe fb8c 	bl	3418e0f4 <HAL_RCCEx_GetPeriphCLKFreq>
3418f9dc:	6278      	str	r0, [r7, #36]	@ 0x24
    }
    if (sdmmc_clk != 0U)
3418f9de:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3418f9e0:	2b00      	cmp	r3, #0
3418f9e2:	f000 8083 	beq.w	3418faec <HAL_SD_ConfigWideBusOperation+0x1d8>
    {
      /* Configure the SDMMC peripheral */
      Init.ClockEdge           = hsd->Init.ClockEdge;
3418f9e6:	687b      	ldr	r3, [r7, #4]
3418f9e8:	685b      	ldr	r3, [r3, #4]
3418f9ea:	60bb      	str	r3, [r7, #8]
      Init.ClockPowerSave      = hsd->Init.ClockPowerSave;
3418f9ec:	687b      	ldr	r3, [r7, #4]
3418f9ee:	689b      	ldr	r3, [r3, #8]
3418f9f0:	60fb      	str	r3, [r7, #12]
      Init.BusWide             = WideMode;
3418f9f2:	683b      	ldr	r3, [r7, #0]
3418f9f4:	613b      	str	r3, [r7, #16]
      Init.HardwareFlowControl = hsd->Init.HardwareFlowControl;
3418f9f6:	687b      	ldr	r3, [r7, #4]
3418f9f8:	691b      	ldr	r3, [r3, #16]
3418f9fa:	617b      	str	r3, [r7, #20]

      /* Check if user Clock div < Normal speed 25Mhz, no change in Clockdiv */
      if (hsd->Init.ClockDiv >= (sdmmc_clk / (2U * SD_NORMAL_SPEED_FREQ)))
3418f9fc:	687b      	ldr	r3, [r7, #4]
3418f9fe:	695a      	ldr	r2, [r3, #20]
3418fa00:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3418fa02:	4952      	ldr	r1, [pc, #328]	@ (3418fb4c <HAL_SD_ConfigWideBusOperation+0x238>)
3418fa04:	fba1 1303 	umull	r1, r3, r1, r3
3418fa08:	0e1b      	lsrs	r3, r3, #24
3418fa0a:	429a      	cmp	r2, r3
3418fa0c:	d303      	bcc.n	3418fa16 <HAL_SD_ConfigWideBusOperation+0x102>
      {
        Init.ClockDiv = hsd->Init.ClockDiv;
3418fa0e:	687b      	ldr	r3, [r7, #4]
3418fa10:	695b      	ldr	r3, [r3, #20]
3418fa12:	61bb      	str	r3, [r7, #24]
3418fa14:	e05a      	b.n	3418facc <HAL_SD_ConfigWideBusOperation+0x1b8>
      }
      else if (hsd->SdCard.CardSpeed == CARD_ULTRA_HIGH_SPEED)
3418fa16:	687b      	ldr	r3, [r7, #4]
3418fa18:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
3418fa1a:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3418fa1e:	d103      	bne.n	3418fa28 <HAL_SD_ConfigWideBusOperation+0x114>
      {
        /* UltraHigh speed SD card,user Clock div */
        Init.ClockDiv = hsd->Init.ClockDiv;
3418fa20:	687b      	ldr	r3, [r7, #4]
3418fa22:	695b      	ldr	r3, [r3, #20]
3418fa24:	61bb      	str	r3, [r7, #24]
3418fa26:	e051      	b.n	3418facc <HAL_SD_ConfigWideBusOperation+0x1b8>
      }
      else if (hsd->SdCard.CardSpeed == CARD_HIGH_SPEED)
3418fa28:	687b      	ldr	r3, [r7, #4]
3418fa2a:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
3418fa2c:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3418fa30:	d126      	bne.n	3418fa80 <HAL_SD_ConfigWideBusOperation+0x16c>
      {
        /* High speed SD card, Max Frequency = 50Mhz */
        if (hsd->Init.ClockDiv == 0U)
3418fa32:	687b      	ldr	r3, [r7, #4]
3418fa34:	695b      	ldr	r3, [r3, #20]
3418fa36:	2b00      	cmp	r3, #0
3418fa38:	d10e      	bne.n	3418fa58 <HAL_SD_ConfigWideBusOperation+0x144>
        {
          if (sdmmc_clk > SD_HIGH_SPEED_FREQ)
3418fa3a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3418fa3c:	4a44      	ldr	r2, [pc, #272]	@ (3418fb50 <HAL_SD_ConfigWideBusOperation+0x23c>)
3418fa3e:	4293      	cmp	r3, r2
3418fa40:	d906      	bls.n	3418fa50 <HAL_SD_ConfigWideBusOperation+0x13c>
          {
            Init.ClockDiv = sdmmc_clk / (2U * SD_HIGH_SPEED_FREQ);
3418fa42:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3418fa44:	4a41      	ldr	r2, [pc, #260]	@ (3418fb4c <HAL_SD_ConfigWideBusOperation+0x238>)
3418fa46:	fba2 2303 	umull	r2, r3, r2, r3
3418fa4a:	0e5b      	lsrs	r3, r3, #25
3418fa4c:	61bb      	str	r3, [r7, #24]
3418fa4e:	e03d      	b.n	3418facc <HAL_SD_ConfigWideBusOperation+0x1b8>
          }
          else
          {
            Init.ClockDiv = hsd->Init.ClockDiv;
3418fa50:	687b      	ldr	r3, [r7, #4]
3418fa52:	695b      	ldr	r3, [r3, #20]
3418fa54:	61bb      	str	r3, [r7, #24]
3418fa56:	e039      	b.n	3418facc <HAL_SD_ConfigWideBusOperation+0x1b8>
          }
        }
        else
        {
          if ((sdmmc_clk / (2U * hsd->Init.ClockDiv)) > SD_HIGH_SPEED_FREQ)
3418fa58:	687b      	ldr	r3, [r7, #4]
3418fa5a:	695b      	ldr	r3, [r3, #20]
3418fa5c:	005b      	lsls	r3, r3, #1
3418fa5e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
3418fa60:	fbb2 f3f3 	udiv	r3, r2, r3
3418fa64:	4a3a      	ldr	r2, [pc, #232]	@ (3418fb50 <HAL_SD_ConfigWideBusOperation+0x23c>)
3418fa66:	4293      	cmp	r3, r2
3418fa68:	d906      	bls.n	3418fa78 <HAL_SD_ConfigWideBusOperation+0x164>
          {
            Init.ClockDiv = sdmmc_clk / (2U * SD_HIGH_SPEED_FREQ);
3418fa6a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3418fa6c:	4a37      	ldr	r2, [pc, #220]	@ (3418fb4c <HAL_SD_ConfigWideBusOperation+0x238>)
3418fa6e:	fba2 2303 	umull	r2, r3, r2, r3
3418fa72:	0e5b      	lsrs	r3, r3, #25
3418fa74:	61bb      	str	r3, [r7, #24]
3418fa76:	e029      	b.n	3418facc <HAL_SD_ConfigWideBusOperation+0x1b8>
          }
          else
          {
            Init.ClockDiv = hsd->Init.ClockDiv;
3418fa78:	687b      	ldr	r3, [r7, #4]
3418fa7a:	695b      	ldr	r3, [r3, #20]
3418fa7c:	61bb      	str	r3, [r7, #24]
3418fa7e:	e025      	b.n	3418facc <HAL_SD_ConfigWideBusOperation+0x1b8>
        }
      }
      else
      {
        /* No High speed SD card, Max Frequency = 25Mhz */
        if (hsd->Init.ClockDiv == 0U)
3418fa80:	687b      	ldr	r3, [r7, #4]
3418fa82:	695b      	ldr	r3, [r3, #20]
3418fa84:	2b00      	cmp	r3, #0
3418fa86:	d10e      	bne.n	3418faa6 <HAL_SD_ConfigWideBusOperation+0x192>
        {
          if (sdmmc_clk > SD_NORMAL_SPEED_FREQ)
3418fa88:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3418fa8a:	4a32      	ldr	r2, [pc, #200]	@ (3418fb54 <HAL_SD_ConfigWideBusOperation+0x240>)
3418fa8c:	4293      	cmp	r3, r2
3418fa8e:	d906      	bls.n	3418fa9e <HAL_SD_ConfigWideBusOperation+0x18a>
          {
            Init.ClockDiv = sdmmc_clk / (2U * SD_NORMAL_SPEED_FREQ);
3418fa90:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3418fa92:	4a2e      	ldr	r2, [pc, #184]	@ (3418fb4c <HAL_SD_ConfigWideBusOperation+0x238>)
3418fa94:	fba2 2303 	umull	r2, r3, r2, r3
3418fa98:	0e1b      	lsrs	r3, r3, #24
3418fa9a:	61bb      	str	r3, [r7, #24]
3418fa9c:	e016      	b.n	3418facc <HAL_SD_ConfigWideBusOperation+0x1b8>
          }
          else
          {
            Init.ClockDiv = hsd->Init.ClockDiv;
3418fa9e:	687b      	ldr	r3, [r7, #4]
3418faa0:	695b      	ldr	r3, [r3, #20]
3418faa2:	61bb      	str	r3, [r7, #24]
3418faa4:	e012      	b.n	3418facc <HAL_SD_ConfigWideBusOperation+0x1b8>
          }
        }
        else
        {
          if ((sdmmc_clk / (2U * hsd->Init.ClockDiv)) > SD_NORMAL_SPEED_FREQ)
3418faa6:	687b      	ldr	r3, [r7, #4]
3418faa8:	695b      	ldr	r3, [r3, #20]
3418faaa:	005b      	lsls	r3, r3, #1
3418faac:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
3418faae:	fbb2 f3f3 	udiv	r3, r2, r3
3418fab2:	4a28      	ldr	r2, [pc, #160]	@ (3418fb54 <HAL_SD_ConfigWideBusOperation+0x240>)
3418fab4:	4293      	cmp	r3, r2
3418fab6:	d906      	bls.n	3418fac6 <HAL_SD_ConfigWideBusOperation+0x1b2>
          {
            Init.ClockDiv = sdmmc_clk / (2U * SD_NORMAL_SPEED_FREQ);
3418fab8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3418faba:	4a24      	ldr	r2, [pc, #144]	@ (3418fb4c <HAL_SD_ConfigWideBusOperation+0x238>)
3418fabc:	fba2 2303 	umull	r2, r3, r2, r3
3418fac0:	0e1b      	lsrs	r3, r3, #24
3418fac2:	61bb      	str	r3, [r7, #24]
3418fac4:	e002      	b.n	3418facc <HAL_SD_ConfigWideBusOperation+0x1b8>
          }
          else
          {
            Init.ClockDiv = hsd->Init.ClockDiv;
3418fac6:	687b      	ldr	r3, [r7, #4]
3418fac8:	695b      	ldr	r3, [r3, #20]
3418faca:	61bb      	str	r3, [r7, #24]

#if (USE_SD_TRANSCEIVER != 0U)
      Init.TranceiverPresent = hsd->Init.TranceiverPresent;
#endif /* USE_SD_TRANSCEIVER */

      (void)SDMMC_Init(hsd->Instance, Init);
3418facc:	687b      	ldr	r3, [r7, #4]
3418face:	681c      	ldr	r4, [r3, #0]
3418fad0:	466a      	mov	r2, sp
3418fad2:	f107 0314 	add.w	r3, r7, #20
3418fad6:	e893 0003 	ldmia.w	r3, {r0, r1}
3418fada:	e882 0003 	stmia.w	r2, {r0, r1}
3418fade:	f107 0308 	add.w	r3, r7, #8
3418fae2:	cb0e      	ldmia	r3, {r1, r2, r3}
3418fae4:	4620      	mov	r0, r4
3418fae6:	f001 fd01 	bl	341914ec <SDMMC_Init>
3418faea:	e008      	b.n	3418fafe <HAL_SD_ConfigWideBusOperation+0x1ea>
    }
    else
    {
      hsd->ErrorCode |= SDMMC_ERROR_INVALID_PARAMETER;
3418faec:	687b      	ldr	r3, [r7, #4]
3418faee:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3418faf0:	f043 6200 	orr.w	r2, r3, #134217728	@ 0x8000000
3418faf4:	687b      	ldr	r3, [r7, #4]
3418faf6:	635a      	str	r2, [r3, #52]	@ 0x34
      status = HAL_ERROR;
3418faf8:	2301      	movs	r3, #1
3418fafa:	f887 3023 	strb.w	r3, [r7, #35]	@ 0x23
    }
  }

  /* Set Block Size for Card */
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
3418fafe:	687b      	ldr	r3, [r7, #4]
3418fb00:	681b      	ldr	r3, [r3, #0]
3418fb02:	f44f 7100 	mov.w	r1, #512	@ 0x200
3418fb06:	4618      	mov	r0, r3
3418fb08:	f001 fdce 	bl	341916a8 <SDMMC_CmdBlockLength>
3418fb0c:	61f8      	str	r0, [r7, #28]
  if (errorstate != HAL_SD_ERROR_NONE)
3418fb0e:	69fb      	ldr	r3, [r7, #28]
3418fb10:	2b00      	cmp	r3, #0
3418fb12:	d00c      	beq.n	3418fb2e <HAL_SD_ConfigWideBusOperation+0x21a>
  {
    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
3418fb14:	687b      	ldr	r3, [r7, #4]
3418fb16:	681b      	ldr	r3, [r3, #0]
3418fb18:	4a0a      	ldr	r2, [pc, #40]	@ (3418fb44 <HAL_SD_ConfigWideBusOperation+0x230>)
3418fb1a:	639a      	str	r2, [r3, #56]	@ 0x38
    hsd->ErrorCode |= errorstate;
3418fb1c:	687b      	ldr	r3, [r7, #4]
3418fb1e:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
3418fb20:	69fb      	ldr	r3, [r7, #28]
3418fb22:	431a      	orrs	r2, r3
3418fb24:	687b      	ldr	r3, [r7, #4]
3418fb26:	635a      	str	r2, [r3, #52]	@ 0x34
    status = HAL_ERROR;
3418fb28:	2301      	movs	r3, #1
3418fb2a:	f887 3023 	strb.w	r3, [r7, #35]	@ 0x23
  }

  /* Change State */
  hsd->State = HAL_SD_STATE_READY;
3418fb2e:	687b      	ldr	r3, [r7, #4]
3418fb30:	2201      	movs	r2, #1
3418fb32:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30

  return status;
3418fb36:	f897 3023 	ldrb.w	r3, [r7, #35]	@ 0x23
}
3418fb3a:	4618      	mov	r0, r3
3418fb3c:	372c      	adds	r7, #44	@ 0x2c
3418fb3e:	46bd      	mov	sp, r7
3418fb40:	bd90      	pop	{r4, r7, pc}
3418fb42:	bf00      	nop
3418fb44:	1fe00fff 	.word	0x1fe00fff
3418fb48:	58027000 	.word	0x58027000
3418fb4c:	55e63b89 	.word	0x55e63b89
3418fb50:	02faf080 	.word	0x02faf080
3418fb54:	017d7840 	.word	0x017d7840

3418fb58 <HAL_SD_GetCardState>:
  * @brief  Gets the current sd card data state.
  * @param  hsd: pointer to SD handle
  * @retval Card state
  */
HAL_SD_CardStateTypeDef HAL_SD_GetCardState(SD_HandleTypeDef *hsd)
{
3418fb58:	b580      	push	{r7, lr}
3418fb5a:	b086      	sub	sp, #24
3418fb5c:	af00      	add	r7, sp, #0
3418fb5e:	6078      	str	r0, [r7, #4]
  uint32_t cardstate;
  uint32_t errorstate;
  uint32_t resp1 = 0;
3418fb60:	2300      	movs	r3, #0
3418fb62:	60fb      	str	r3, [r7, #12]

  errorstate = SD_SendStatus(hsd, &resp1);
3418fb64:	f107 030c 	add.w	r3, r7, #12
3418fb68:	4619      	mov	r1, r3
3418fb6a:	6878      	ldr	r0, [r7, #4]
3418fb6c:	f000 fa40 	bl	3418fff0 <SD_SendStatus>
3418fb70:	6178      	str	r0, [r7, #20]
  if (errorstate != HAL_SD_ERROR_NONE)
3418fb72:	697b      	ldr	r3, [r7, #20]
3418fb74:	2b00      	cmp	r3, #0
3418fb76:	d005      	beq.n	3418fb84 <HAL_SD_GetCardState+0x2c>
  {
    hsd->ErrorCode |= errorstate;
3418fb78:	687b      	ldr	r3, [r7, #4]
3418fb7a:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
3418fb7c:	697b      	ldr	r3, [r7, #20]
3418fb7e:	431a      	orrs	r2, r3
3418fb80:	687b      	ldr	r3, [r7, #4]
3418fb82:	635a      	str	r2, [r3, #52]	@ 0x34
  }

  cardstate = ((resp1 >> 9U) & 0x0FU);
3418fb84:	68fb      	ldr	r3, [r7, #12]
3418fb86:	0a5b      	lsrs	r3, r3, #9
3418fb88:	f003 030f 	and.w	r3, r3, #15
3418fb8c:	613b      	str	r3, [r7, #16]

  return (HAL_SD_CardStateTypeDef)cardstate;
3418fb8e:	693b      	ldr	r3, [r7, #16]
}
3418fb90:	4618      	mov	r0, r3
3418fb92:	3718      	adds	r7, #24
3418fb94:	46bd      	mov	sp, r7
3418fb96:	bd80      	pop	{r7, pc}

3418fb98 <SD_InitCard>:
  * @brief  Initializes the sd card.
  * @param  hsd: Pointer to SD handle
  * @retval SD Card error state
  */
static uint32_t SD_InitCard(SD_HandleTypeDef *hsd)
{
3418fb98:	b580      	push	{r7, lr}
3418fb9a:	b090      	sub	sp, #64	@ 0x40
3418fb9c:	af00      	add	r7, sp, #0
3418fb9e:	6078      	str	r0, [r7, #4]
  HAL_SD_CardCSDTypeDef CSD;
  uint32_t errorstate;
  uint16_t sd_rca = 0U;
3418fba0:	2300      	movs	r3, #0
3418fba2:	817b      	strh	r3, [r7, #10]
  uint32_t tickstart = HAL_GetTick();
3418fba4:	f7f5 fd08 	bl	341855b8 <HAL_GetTick>
3418fba8:	63f8      	str	r0, [r7, #60]	@ 0x3c

  /* Check the power State */
  if (SDMMC_GetPowerState(hsd->Instance) == 0U)
3418fbaa:	687b      	ldr	r3, [r7, #4]
3418fbac:	681b      	ldr	r3, [r3, #0]
3418fbae:	4618      	mov	r0, r3
3418fbb0:	f001 fcf5 	bl	3419159e <SDMMC_GetPowerState>
3418fbb4:	4603      	mov	r3, r0
3418fbb6:	2b00      	cmp	r3, #0
3418fbb8:	d102      	bne.n	3418fbc0 <SD_InitCard+0x28>
  {
    /* Power off */
    return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
3418fbba:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
3418fbbe:	e0b5      	b.n	3418fd2c <SD_InitCard+0x194>
  }

  if (hsd->SdCard.CardType != CARD_SECURED)
3418fbc0:	687b      	ldr	r3, [r7, #4]
3418fbc2:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3418fbc4:	2b03      	cmp	r3, #3
3418fbc6:	d02e      	beq.n	3418fc26 <SD_InitCard+0x8e>
  {
    /* Send CMD2 ALL_SEND_CID */
    errorstate = SDMMC_CmdSendCID(hsd->Instance);
3418fbc8:	687b      	ldr	r3, [r7, #4]
3418fbca:	681b      	ldr	r3, [r3, #0]
3418fbcc:	4618      	mov	r0, r3
3418fbce:	f001 ff40 	bl	34191a52 <SDMMC_CmdSendCID>
3418fbd2:	63b8      	str	r0, [r7, #56]	@ 0x38
    if (errorstate != HAL_SD_ERROR_NONE)
3418fbd4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3418fbd6:	2b00      	cmp	r3, #0
3418fbd8:	d001      	beq.n	3418fbde <SD_InitCard+0x46>
    {
      return errorstate;
3418fbda:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3418fbdc:	e0a6      	b.n	3418fd2c <SD_InitCard+0x194>
    }
    else
    {
      /* Get Card identification number data */
      hsd->CID[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
3418fbde:	687b      	ldr	r3, [r7, #4]
3418fbe0:	681b      	ldr	r3, [r3, #0]
3418fbe2:	2100      	movs	r1, #0
3418fbe4:	4618      	mov	r0, r3
3418fbe6:	f001 fd20 	bl	3419162a <SDMMC_GetResponse>
3418fbea:	4602      	mov	r2, r0
3418fbec:	687b      	ldr	r3, [r7, #4]
3418fbee:	66da      	str	r2, [r3, #108]	@ 0x6c
      hsd->CID[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
3418fbf0:	687b      	ldr	r3, [r7, #4]
3418fbf2:	681b      	ldr	r3, [r3, #0]
3418fbf4:	2104      	movs	r1, #4
3418fbf6:	4618      	mov	r0, r3
3418fbf8:	f001 fd17 	bl	3419162a <SDMMC_GetResponse>
3418fbfc:	4602      	mov	r2, r0
3418fbfe:	687b      	ldr	r3, [r7, #4]
3418fc00:	671a      	str	r2, [r3, #112]	@ 0x70
      hsd->CID[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
3418fc02:	687b      	ldr	r3, [r7, #4]
3418fc04:	681b      	ldr	r3, [r3, #0]
3418fc06:	2108      	movs	r1, #8
3418fc08:	4618      	mov	r0, r3
3418fc0a:	f001 fd0e 	bl	3419162a <SDMMC_GetResponse>
3418fc0e:	4602      	mov	r2, r0
3418fc10:	687b      	ldr	r3, [r7, #4]
3418fc12:	675a      	str	r2, [r3, #116]	@ 0x74
      hsd->CID[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
3418fc14:	687b      	ldr	r3, [r7, #4]
3418fc16:	681b      	ldr	r3, [r3, #0]
3418fc18:	210c      	movs	r1, #12
3418fc1a:	4618      	mov	r0, r3
3418fc1c:	f001 fd05 	bl	3419162a <SDMMC_GetResponse>
3418fc20:	4602      	mov	r2, r0
3418fc22:	687b      	ldr	r3, [r7, #4]
3418fc24:	679a      	str	r2, [r3, #120]	@ 0x78
    }
  }

  if (hsd->SdCard.CardType != CARD_SECURED)
3418fc26:	687b      	ldr	r3, [r7, #4]
3418fc28:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3418fc2a:	2b03      	cmp	r3, #3
3418fc2c:	d01d      	beq.n	3418fc6a <SD_InitCard+0xd2>
  {
    /* Send CMD3 SET_REL_ADDR with argument 0 */
    /* SD Card publishes its RCA. */
    while (sd_rca == 0U)
3418fc2e:	e019      	b.n	3418fc64 <SD_InitCard+0xcc>
    {
      errorstate = SDMMC_CmdSetRelAdd(hsd->Instance, &sd_rca);
3418fc30:	687b      	ldr	r3, [r7, #4]
3418fc32:	681b      	ldr	r3, [r3, #0]
3418fc34:	f107 020a 	add.w	r2, r7, #10
3418fc38:	4611      	mov	r1, r2
3418fc3a:	4618      	mov	r0, r3
3418fc3c:	f001 ff48 	bl	34191ad0 <SDMMC_CmdSetRelAdd>
3418fc40:	63b8      	str	r0, [r7, #56]	@ 0x38
      if (errorstate != HAL_SD_ERROR_NONE)
3418fc42:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3418fc44:	2b00      	cmp	r3, #0
3418fc46:	d001      	beq.n	3418fc4c <SD_InitCard+0xb4>
      {
        return errorstate;
3418fc48:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3418fc4a:	e06f      	b.n	3418fd2c <SD_InitCard+0x194>
      }
      if ((HAL_GetTick() - tickstart) >=  SDMMC_CMDTIMEOUT)
3418fc4c:	f7f5 fcb4 	bl	341855b8 <HAL_GetTick>
3418fc50:	4602      	mov	r2, r0
3418fc52:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3418fc54:	1ad3      	subs	r3, r2, r3
3418fc56:	f241 3287 	movw	r2, #4999	@ 0x1387
3418fc5a:	4293      	cmp	r3, r2
3418fc5c:	d902      	bls.n	3418fc64 <SD_InitCard+0xcc>
      {
        return HAL_SD_ERROR_TIMEOUT;
3418fc5e:	f04f 4300 	mov.w	r3, #2147483648	@ 0x80000000
3418fc62:	e063      	b.n	3418fd2c <SD_InitCard+0x194>
    while (sd_rca == 0U)
3418fc64:	897b      	ldrh	r3, [r7, #10]
3418fc66:	2b00      	cmp	r3, #0
3418fc68:	d0e2      	beq.n	3418fc30 <SD_InitCard+0x98>
      }
    }
  }
  if (hsd->SdCard.CardType != CARD_SECURED)
3418fc6a:	687b      	ldr	r3, [r7, #4]
3418fc6c:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3418fc6e:	2b03      	cmp	r3, #3
3418fc70:	d036      	beq.n	3418fce0 <SD_InitCard+0x148>
  {
    /* Get the SD card RCA */
    hsd->SdCard.RelCardAdd = sd_rca;
3418fc72:	897b      	ldrh	r3, [r7, #10]
3418fc74:	461a      	mov	r2, r3
3418fc76:	687b      	ldr	r3, [r7, #4]
3418fc78:	645a      	str	r2, [r3, #68]	@ 0x44

    /* Send CMD9 SEND_CSD with argument as card's RCA */
    errorstate = SDMMC_CmdSendCSD(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
3418fc7a:	687b      	ldr	r3, [r7, #4]
3418fc7c:	681a      	ldr	r2, [r3, #0]
3418fc7e:	687b      	ldr	r3, [r7, #4]
3418fc80:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3418fc82:	041b      	lsls	r3, r3, #16
3418fc84:	4619      	mov	r1, r3
3418fc86:	4610      	mov	r0, r2
3418fc88:	f001 ff02 	bl	34191a90 <SDMMC_CmdSendCSD>
3418fc8c:	63b8      	str	r0, [r7, #56]	@ 0x38
    if (errorstate != HAL_SD_ERROR_NONE)
3418fc8e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3418fc90:	2b00      	cmp	r3, #0
3418fc92:	d001      	beq.n	3418fc98 <SD_InitCard+0x100>
    {
      return errorstate;
3418fc94:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3418fc96:	e049      	b.n	3418fd2c <SD_InitCard+0x194>
    }
    else
    {
      /* Get Card Specific Data */
      hsd->CSD[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
3418fc98:	687b      	ldr	r3, [r7, #4]
3418fc9a:	681b      	ldr	r3, [r3, #0]
3418fc9c:	2100      	movs	r1, #0
3418fc9e:	4618      	mov	r0, r3
3418fca0:	f001 fcc3 	bl	3419162a <SDMMC_GetResponse>
3418fca4:	4602      	mov	r2, r0
3418fca6:	687b      	ldr	r3, [r7, #4]
3418fca8:	65da      	str	r2, [r3, #92]	@ 0x5c
      hsd->CSD[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
3418fcaa:	687b      	ldr	r3, [r7, #4]
3418fcac:	681b      	ldr	r3, [r3, #0]
3418fcae:	2104      	movs	r1, #4
3418fcb0:	4618      	mov	r0, r3
3418fcb2:	f001 fcba 	bl	3419162a <SDMMC_GetResponse>
3418fcb6:	4602      	mov	r2, r0
3418fcb8:	687b      	ldr	r3, [r7, #4]
3418fcba:	661a      	str	r2, [r3, #96]	@ 0x60
      hsd->CSD[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
3418fcbc:	687b      	ldr	r3, [r7, #4]
3418fcbe:	681b      	ldr	r3, [r3, #0]
3418fcc0:	2108      	movs	r1, #8
3418fcc2:	4618      	mov	r0, r3
3418fcc4:	f001 fcb1 	bl	3419162a <SDMMC_GetResponse>
3418fcc8:	4602      	mov	r2, r0
3418fcca:	687b      	ldr	r3, [r7, #4]
3418fccc:	665a      	str	r2, [r3, #100]	@ 0x64
      hsd->CSD[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
3418fcce:	687b      	ldr	r3, [r7, #4]
3418fcd0:	681b      	ldr	r3, [r3, #0]
3418fcd2:	210c      	movs	r1, #12
3418fcd4:	4618      	mov	r0, r3
3418fcd6:	f001 fca8 	bl	3419162a <SDMMC_GetResponse>
3418fcda:	4602      	mov	r2, r0
3418fcdc:	687b      	ldr	r3, [r7, #4]
3418fcde:	669a      	str	r2, [r3, #104]	@ 0x68
    }
  }

  /* Get the Card Class */
  hsd->SdCard.Class = (SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2) >> 20U);
3418fce0:	687b      	ldr	r3, [r7, #4]
3418fce2:	681b      	ldr	r3, [r3, #0]
3418fce4:	2104      	movs	r1, #4
3418fce6:	4618      	mov	r0, r3
3418fce8:	f001 fc9f 	bl	3419162a <SDMMC_GetResponse>
3418fcec:	4603      	mov	r3, r0
3418fcee:	0d1a      	lsrs	r2, r3, #20
3418fcf0:	687b      	ldr	r3, [r7, #4]
3418fcf2:	641a      	str	r2, [r3, #64]	@ 0x40

  /* Get CSD parameters */
  if (HAL_SD_GetCardCSD(hsd, &CSD) != HAL_OK)
3418fcf4:	f107 030c 	add.w	r3, r7, #12
3418fcf8:	4619      	mov	r1, r3
3418fcfa:	6878      	ldr	r0, [r7, #4]
3418fcfc:	f7ff fb7c 	bl	3418f3f8 <HAL_SD_GetCardCSD>
3418fd00:	4603      	mov	r3, r0
3418fd02:	2b00      	cmp	r3, #0
3418fd04:	d002      	beq.n	3418fd0c <SD_InitCard+0x174>
  {
    return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
3418fd06:	f04f 5380 	mov.w	r3, #268435456	@ 0x10000000
3418fd0a:	e00f      	b.n	3418fd2c <SD_InitCard+0x194>
  }

  /* Select the Card */
  errorstate = SDMMC_CmdSelDesel(hsd->Instance, (uint32_t)(((uint32_t)hsd->SdCard.RelCardAdd) << 16U));
3418fd0c:	687b      	ldr	r3, [r7, #4]
3418fd0e:	681a      	ldr	r2, [r3, #0]
3418fd10:	687b      	ldr	r3, [r7, #4]
3418fd12:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3418fd14:	041b      	lsls	r3, r3, #16
3418fd16:	4619      	mov	r1, r3
3418fd18:	4610      	mov	r0, r2
3418fd1a:	f001 fdb1 	bl	34191880 <SDMMC_CmdSelDesel>
3418fd1e:	63b8      	str	r0, [r7, #56]	@ 0x38
  if (errorstate != HAL_SD_ERROR_NONE)
3418fd20:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3418fd22:	2b00      	cmp	r3, #0
3418fd24:	d001      	beq.n	3418fd2a <SD_InitCard+0x192>
  {
    return errorstate;
3418fd26:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3418fd28:	e000      	b.n	3418fd2c <SD_InitCard+0x194>
  }

  /* All cards are initialized */
  return HAL_SD_ERROR_NONE;
3418fd2a:	2300      	movs	r3, #0
}
3418fd2c:	4618      	mov	r0, r3
3418fd2e:	3740      	adds	r7, #64	@ 0x40
3418fd30:	46bd      	mov	sp, r7
3418fd32:	bd80      	pop	{r7, pc}

3418fd34 <SD_PowerON>:
  *         in the SD handle.
  * @param  hsd: Pointer to SD handle
  * @retval error state
  */
static uint32_t SD_PowerON(SD_HandleTypeDef *hsd)
{
3418fd34:	b580      	push	{r7, lr}
3418fd36:	b086      	sub	sp, #24
3418fd38:	af00      	add	r7, sp, #0
3418fd3a:	6078      	str	r0, [r7, #4]
  __IO uint32_t count = 0U;
3418fd3c:	2300      	movs	r3, #0
3418fd3e:	60bb      	str	r3, [r7, #8]
  uint32_t response = 0U;
3418fd40:	2300      	movs	r3, #0
3418fd42:	617b      	str	r3, [r7, #20]
  uint32_t validvoltage = 0U;
3418fd44:	2300      	movs	r3, #0
3418fd46:	613b      	str	r3, [r7, #16]
#if (USE_SD_TRANSCEIVER != 0U)
  uint32_t tickstart = HAL_GetTick();
#endif /* USE_SD_TRANSCEIVER  */

  /* CMD0: GO_IDLE_STATE */
  errorstate = SDMMC_CmdGoIdleState(hsd->Instance);
3418fd48:	687b      	ldr	r3, [r7, #4]
3418fd4a:	681b      	ldr	r3, [r3, #0]
3418fd4c:	4618      	mov	r0, r3
3418fd4e:	f001 fdba 	bl	341918c6 <SDMMC_CmdGoIdleState>
3418fd52:	60f8      	str	r0, [r7, #12]
  if (errorstate != HAL_SD_ERROR_NONE)
3418fd54:	68fb      	ldr	r3, [r7, #12]
3418fd56:	2b00      	cmp	r3, #0
3418fd58:	d001      	beq.n	3418fd5e <SD_PowerON+0x2a>
  {
    return errorstate;
3418fd5a:	68fb      	ldr	r3, [r7, #12]
3418fd5c:	e072      	b.n	3418fe44 <SD_PowerON+0x110>
  }

  /* CMD8: SEND_IF_COND: Command available only on V2.0 cards */
  errorstate = SDMMC_CmdOperCond(hsd->Instance);
3418fd5e:	687b      	ldr	r3, [r7, #4]
3418fd60:	681b      	ldr	r3, [r3, #0]
3418fd62:	4618      	mov	r0, r3
3418fd64:	f001 fdcd 	bl	34191902 <SDMMC_CmdOperCond>
3418fd68:	60f8      	str	r0, [r7, #12]
  if (errorstate == SDMMC_ERROR_TIMEOUT) /* No response to CMD8 */
3418fd6a:	68fb      	ldr	r3, [r7, #12]
3418fd6c:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
3418fd70:	d10d      	bne.n	3418fd8e <SD_PowerON+0x5a>
  {
    hsd->SdCard.CardVersion = CARD_V1_X;
3418fd72:	687b      	ldr	r3, [r7, #4]
3418fd74:	2200      	movs	r2, #0
3418fd76:	63da      	str	r2, [r3, #60]	@ 0x3c
    /* CMD0: GO_IDLE_STATE */
    errorstate = SDMMC_CmdGoIdleState(hsd->Instance);
3418fd78:	687b      	ldr	r3, [r7, #4]
3418fd7a:	681b      	ldr	r3, [r3, #0]
3418fd7c:	4618      	mov	r0, r3
3418fd7e:	f001 fda2 	bl	341918c6 <SDMMC_CmdGoIdleState>
3418fd82:	60f8      	str	r0, [r7, #12]
    if (errorstate != HAL_SD_ERROR_NONE)
3418fd84:	68fb      	ldr	r3, [r7, #12]
3418fd86:	2b00      	cmp	r3, #0
3418fd88:	d004      	beq.n	3418fd94 <SD_PowerON+0x60>
    {
      return errorstate;
3418fd8a:	68fb      	ldr	r3, [r7, #12]
3418fd8c:	e05a      	b.n	3418fe44 <SD_PowerON+0x110>
    }

  }
  else
  {
    hsd->SdCard.CardVersion = CARD_V2_X;
3418fd8e:	687b      	ldr	r3, [r7, #4]
3418fd90:	2201      	movs	r2, #1
3418fd92:	63da      	str	r2, [r3, #60]	@ 0x3c
  }

  if (hsd->SdCard.CardVersion == CARD_V2_X)
3418fd94:	687b      	ldr	r3, [r7, #4]
3418fd96:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3418fd98:	2b01      	cmp	r3, #1
3418fd9a:	d137      	bne.n	3418fe0c <SD_PowerON+0xd8>
  {
    /* SEND CMD55 APP_CMD with RCA as 0 */
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, 0);
3418fd9c:	687b      	ldr	r3, [r7, #4]
3418fd9e:	681b      	ldr	r3, [r3, #0]
3418fda0:	2100      	movs	r1, #0
3418fda2:	4618      	mov	r0, r3
3418fda4:	f001 fdcd 	bl	34191942 <SDMMC_CmdAppCommand>
3418fda8:	60f8      	str	r0, [r7, #12]
    if (errorstate != HAL_SD_ERROR_NONE)
3418fdaa:	68fb      	ldr	r3, [r7, #12]
3418fdac:	2b00      	cmp	r3, #0
3418fdae:	d02d      	beq.n	3418fe0c <SD_PowerON+0xd8>
    {
      return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
3418fdb0:	f04f 5380 	mov.w	r3, #268435456	@ 0x10000000
3418fdb4:	e046      	b.n	3418fe44 <SD_PowerON+0x110>
  /* SD CARD */
  /* Send ACMD41 SD_APP_OP_COND with Argument 0x80100000 */
  while ((count < SDMMC_MAX_VOLT_TRIAL) && (validvoltage == 0U))
  {
    /* SEND CMD55 APP_CMD with RCA as 0 */
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, 0);
3418fdb6:	687b      	ldr	r3, [r7, #4]
3418fdb8:	681b      	ldr	r3, [r3, #0]
3418fdba:	2100      	movs	r1, #0
3418fdbc:	4618      	mov	r0, r3
3418fdbe:	f001 fdc0 	bl	34191942 <SDMMC_CmdAppCommand>
3418fdc2:	60f8      	str	r0, [r7, #12]
    if (errorstate != HAL_SD_ERROR_NONE)
3418fdc4:	68fb      	ldr	r3, [r7, #12]
3418fdc6:	2b00      	cmp	r3, #0
3418fdc8:	d001      	beq.n	3418fdce <SD_PowerON+0x9a>
    {
      return errorstate;
3418fdca:	68fb      	ldr	r3, [r7, #12]
3418fdcc:	e03a      	b.n	3418fe44 <SD_PowerON+0x110>
    }

    /* Send CMD41 */
    errorstate = SDMMC_CmdAppOperCommand(hsd->Instance, SDMMC_VOLTAGE_WINDOW_SD | SDMMC_HIGH_CAPACITY |
3418fdce:	687b      	ldr	r3, [r7, #4]
3418fdd0:	681b      	ldr	r3, [r3, #0]
3418fdd2:	491e      	ldr	r1, [pc, #120]	@ (3418fe4c <SD_PowerON+0x118>)
3418fdd4:	4618      	mov	r0, r3
3418fdd6:	f001 fdd7 	bl	34191988 <SDMMC_CmdAppOperCommand>
3418fdda:	60f8      	str	r0, [r7, #12]
                                         SD_SWITCH_1_8V_CAPACITY);
    if (errorstate != HAL_SD_ERROR_NONE)
3418fddc:	68fb      	ldr	r3, [r7, #12]
3418fdde:	2b00      	cmp	r3, #0
3418fde0:	d002      	beq.n	3418fde8 <SD_PowerON+0xb4>
    {
      return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
3418fde2:	f04f 5380 	mov.w	r3, #268435456	@ 0x10000000
3418fde6:	e02d      	b.n	3418fe44 <SD_PowerON+0x110>
    }

    /* Get command response */
    response = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
3418fde8:	687b      	ldr	r3, [r7, #4]
3418fdea:	681b      	ldr	r3, [r3, #0]
3418fdec:	2100      	movs	r1, #0
3418fdee:	4618      	mov	r0, r3
3418fdf0:	f001 fc1b 	bl	3419162a <SDMMC_GetResponse>
3418fdf4:	6178      	str	r0, [r7, #20]

    /* Get operating voltage*/
    validvoltage = (((response >> 31U) == 1U) ? 1U : 0U);
3418fdf6:	697b      	ldr	r3, [r7, #20]
3418fdf8:	0fdb      	lsrs	r3, r3, #31
3418fdfa:	2b01      	cmp	r3, #1
3418fdfc:	d101      	bne.n	3418fe02 <SD_PowerON+0xce>
3418fdfe:	2301      	movs	r3, #1
3418fe00:	e000      	b.n	3418fe04 <SD_PowerON+0xd0>
3418fe02:	2300      	movs	r3, #0
3418fe04:	613b      	str	r3, [r7, #16]

    count++;
3418fe06:	68bb      	ldr	r3, [r7, #8]
3418fe08:	3301      	adds	r3, #1
3418fe0a:	60bb      	str	r3, [r7, #8]
  while ((count < SDMMC_MAX_VOLT_TRIAL) && (validvoltage == 0U))
3418fe0c:	68bb      	ldr	r3, [r7, #8]
3418fe0e:	f64f 72fe 	movw	r2, #65534	@ 0xfffe
3418fe12:	4293      	cmp	r3, r2
3418fe14:	d802      	bhi.n	3418fe1c <SD_PowerON+0xe8>
3418fe16:	693b      	ldr	r3, [r7, #16]
3418fe18:	2b00      	cmp	r3, #0
3418fe1a:	d0cc      	beq.n	3418fdb6 <SD_PowerON+0x82>
  }

  if (count >= SDMMC_MAX_VOLT_TRIAL)
3418fe1c:	68bb      	ldr	r3, [r7, #8]
3418fe1e:	f64f 72fe 	movw	r2, #65534	@ 0xfffe
3418fe22:	4293      	cmp	r3, r2
3418fe24:	d902      	bls.n	3418fe2c <SD_PowerON+0xf8>
  {
    return HAL_SD_ERROR_INVALID_VOLTRANGE;
3418fe26:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
3418fe2a:	e00b      	b.n	3418fe44 <SD_PowerON+0x110>
  }

  /* Set default card type */
  hsd->SdCard.CardType = CARD_SDSC;
3418fe2c:	687b      	ldr	r3, [r7, #4]
3418fe2e:	2200      	movs	r2, #0
3418fe30:	639a      	str	r2, [r3, #56]	@ 0x38

  if ((response & SDMMC_HIGH_CAPACITY) == SDMMC_HIGH_CAPACITY)
3418fe32:	697b      	ldr	r3, [r7, #20]
3418fe34:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
3418fe38:	2b00      	cmp	r3, #0
3418fe3a:	d002      	beq.n	3418fe42 <SD_PowerON+0x10e>
  {
    hsd->SdCard.CardType = CARD_SDHC_SDXC;
3418fe3c:	687b      	ldr	r3, [r7, #4]
3418fe3e:	2201      	movs	r2, #1
3418fe40:	639a      	str	r2, [r3, #56]	@ 0x38
      }
    }
#endif /* USE_SD_TRANSCEIVER  */
  }

  return HAL_SD_ERROR_NONE;
3418fe42:	2300      	movs	r3, #0
}
3418fe44:	4618      	mov	r0, r3
3418fe46:	3718      	adds	r7, #24
3418fe48:	46bd      	mov	sp, r7
3418fe4a:	bd80      	pop	{r7, pc}
3418fe4c:	c1100000 	.word	0xc1100000

3418fe50 <SD_SendSDStatus>:
  * @param  pSDstatus: Pointer to the buffer that will contain the SD card status
  *         SD Status register)
  * @retval error state
  */
static uint32_t SD_SendSDStatus(SD_HandleTypeDef *hsd, uint32_t *pSDstatus)
{
3418fe50:	b580      	push	{r7, lr}
3418fe52:	b08c      	sub	sp, #48	@ 0x30
3418fe54:	af00      	add	r7, sp, #0
3418fe56:	6078      	str	r0, [r7, #4]
3418fe58:	6039      	str	r1, [r7, #0]
  SDMMC_DataInitTypeDef config;
  uint32_t errorstate;
  uint32_t tickstart = HAL_GetTick();
3418fe5a:	f7f5 fbad 	bl	341855b8 <HAL_GetTick>
3418fe5e:	6278      	str	r0, [r7, #36]	@ 0x24
  uint32_t count = 0;
3418fe60:	2300      	movs	r3, #0
3418fe62:	62fb      	str	r3, [r7, #44]	@ 0x2c
  uint32_t *pData = pSDstatus;
3418fe64:	683b      	ldr	r3, [r7, #0]
3418fe66:	62bb      	str	r3, [r7, #40]	@ 0x28

  /* Check SD response */
  if ((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
3418fe68:	687b      	ldr	r3, [r7, #4]
3418fe6a:	681b      	ldr	r3, [r3, #0]
3418fe6c:	2100      	movs	r1, #0
3418fe6e:	4618      	mov	r0, r3
3418fe70:	f001 fbdb 	bl	3419162a <SDMMC_GetResponse>
3418fe74:	4603      	mov	r3, r0
3418fe76:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
3418fe7a:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
3418fe7e:	d102      	bne.n	3418fe86 <SD_SendSDStatus+0x36>
  {
    return HAL_SD_ERROR_LOCK_UNLOCK_FAILED;
3418fe80:	f44f 6300 	mov.w	r3, #2048	@ 0x800
3418fe84:	e0ad      	b.n	3418ffe2 <SD_SendSDStatus+0x192>
  }

  /* Set block size for card if it is not equal to current block size for card */
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, 64U);
3418fe86:	687b      	ldr	r3, [r7, #4]
3418fe88:	681b      	ldr	r3, [r3, #0]
3418fe8a:	2140      	movs	r1, #64	@ 0x40
3418fe8c:	4618      	mov	r0, r3
3418fe8e:	f001 fc0b 	bl	341916a8 <SDMMC_CmdBlockLength>
3418fe92:	6238      	str	r0, [r7, #32]
  if (errorstate != HAL_SD_ERROR_NONE)
3418fe94:	6a3b      	ldr	r3, [r7, #32]
3418fe96:	2b00      	cmp	r3, #0
3418fe98:	d005      	beq.n	3418fea6 <SD_SendSDStatus+0x56>
  {
    hsd->ErrorCode |= HAL_SD_ERROR_NONE;
3418fe9a:	687b      	ldr	r3, [r7, #4]
3418fe9c:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
3418fe9e:	687b      	ldr	r3, [r7, #4]
3418fea0:	635a      	str	r2, [r3, #52]	@ 0x34
    return errorstate;
3418fea2:	6a3b      	ldr	r3, [r7, #32]
3418fea4:	e09d      	b.n	3418ffe2 <SD_SendSDStatus+0x192>
  }

  /* Send CMD55 */
  errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
3418fea6:	687b      	ldr	r3, [r7, #4]
3418fea8:	681a      	ldr	r2, [r3, #0]
3418feaa:	687b      	ldr	r3, [r7, #4]
3418feac:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3418feae:	041b      	lsls	r3, r3, #16
3418feb0:	4619      	mov	r1, r3
3418feb2:	4610      	mov	r0, r2
3418feb4:	f001 fd45 	bl	34191942 <SDMMC_CmdAppCommand>
3418feb8:	6238      	str	r0, [r7, #32]
  if (errorstate != HAL_SD_ERROR_NONE)
3418feba:	6a3b      	ldr	r3, [r7, #32]
3418febc:	2b00      	cmp	r3, #0
3418febe:	d005      	beq.n	3418fecc <SD_SendSDStatus+0x7c>
  {
    hsd->ErrorCode |= HAL_SD_ERROR_NONE;
3418fec0:	687b      	ldr	r3, [r7, #4]
3418fec2:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
3418fec4:	687b      	ldr	r3, [r7, #4]
3418fec6:	635a      	str	r2, [r3, #52]	@ 0x34
    return errorstate;
3418fec8:	6a3b      	ldr	r3, [r7, #32]
3418feca:	e08a      	b.n	3418ffe2 <SD_SendSDStatus+0x192>
  }

  /* Configure the SD DPSM (Data Path State Machine) */
  config.DataTimeOut   = SDMMC_DATATIMEOUT;
3418fecc:	f04f 33ff 	mov.w	r3, #4294967295
3418fed0:	60bb      	str	r3, [r7, #8]
  config.DataLength    = 64U;
3418fed2:	2340      	movs	r3, #64	@ 0x40
3418fed4:	60fb      	str	r3, [r7, #12]
  config.DataBlockSize = SDMMC_DATABLOCK_SIZE_64B;
3418fed6:	2360      	movs	r3, #96	@ 0x60
3418fed8:	613b      	str	r3, [r7, #16]
  config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
3418feda:	2302      	movs	r3, #2
3418fedc:	617b      	str	r3, [r7, #20]
  config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
3418fede:	2300      	movs	r3, #0
3418fee0:	61bb      	str	r3, [r7, #24]
  config.DPSM          = SDMMC_DPSM_ENABLE;
3418fee2:	2301      	movs	r3, #1
3418fee4:	61fb      	str	r3, [r7, #28]
  (void)SDMMC_ConfigData(hsd->Instance, &config);
3418fee6:	687b      	ldr	r3, [r7, #4]
3418fee8:	681b      	ldr	r3, [r3, #0]
3418feea:	f107 0208 	add.w	r2, r7, #8
3418feee:	4611      	mov	r1, r2
3418fef0:	4618      	mov	r0, r3
3418fef2:	f001 fbad 	bl	34191650 <SDMMC_ConfigData>

  /* Send ACMD13 (SD_APP_STAUS)  with argument as card's RCA */
  errorstate = SDMMC_CmdStatusRegister(hsd->Instance);
3418fef6:	687b      	ldr	r3, [r7, #4]
3418fef8:	681b      	ldr	r3, [r3, #0]
3418fefa:	4618      	mov	r0, r3
3418fefc:	f001 fe2d 	bl	34191b5a <SDMMC_CmdStatusRegister>
3418ff00:	6238      	str	r0, [r7, #32]
  if (errorstate != HAL_SD_ERROR_NONE)
3418ff02:	6a3b      	ldr	r3, [r7, #32]
3418ff04:	2b00      	cmp	r3, #0
3418ff06:	d028      	beq.n	3418ff5a <SD_SendSDStatus+0x10a>
  {
    hsd->ErrorCode |= HAL_SD_ERROR_NONE;
3418ff08:	687b      	ldr	r3, [r7, #4]
3418ff0a:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
3418ff0c:	687b      	ldr	r3, [r7, #4]
3418ff0e:	635a      	str	r2, [r3, #52]	@ 0x34
    return errorstate;
3418ff10:	6a3b      	ldr	r3, [r7, #32]
3418ff12:	e066      	b.n	3418ffe2 <SD_SendSDStatus+0x192>
  }

  /* Get status data */
  while (!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
  {
    if ((!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOE)) && (count < 16U))
3418ff14:	687b      	ldr	r3, [r7, #4]
3418ff16:	681b      	ldr	r3, [r3, #0]
3418ff18:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3418ff1a:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
3418ff1e:	2b00      	cmp	r3, #0
3418ff20:	d110      	bne.n	3418ff44 <SD_SendSDStatus+0xf4>
3418ff22:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3418ff24:	2b0f      	cmp	r3, #15
3418ff26:	d80d      	bhi.n	3418ff44 <SD_SendSDStatus+0xf4>
    {
      *pData = SDMMC_ReadFIFO(hsd->Instance);
3418ff28:	687b      	ldr	r3, [r7, #4]
3418ff2a:	681b      	ldr	r3, [r3, #0]
3418ff2c:	4618      	mov	r0, r3
3418ff2e:	f001 fb07 	bl	34191540 <SDMMC_ReadFIFO>
3418ff32:	4602      	mov	r2, r0
3418ff34:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418ff36:	601a      	str	r2, [r3, #0]
      pData++;
3418ff38:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418ff3a:	3304      	adds	r3, #4
3418ff3c:	62bb      	str	r3, [r7, #40]	@ 0x28
      count++;
3418ff3e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3418ff40:	3301      	adds	r3, #1
3418ff42:	62fb      	str	r3, [r7, #44]	@ 0x2c
    }

    if ((HAL_GetTick() - tickstart) >=  SDMMC_SWDATATIMEOUT)
3418ff44:	f7f5 fb38 	bl	341855b8 <HAL_GetTick>
3418ff48:	4602      	mov	r2, r0
3418ff4a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3418ff4c:	1ad3      	subs	r3, r2, r3
3418ff4e:	f1b3 3fff 	cmp.w	r3, #4294967295
3418ff52:	d102      	bne.n	3418ff5a <SD_SendSDStatus+0x10a>
    {
      return HAL_SD_ERROR_TIMEOUT;
3418ff54:	f04f 4300 	mov.w	r3, #2147483648	@ 0x80000000
3418ff58:	e043      	b.n	3418ffe2 <SD_SendSDStatus+0x192>
  while (!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
3418ff5a:	687b      	ldr	r3, [r7, #4]
3418ff5c:	681b      	ldr	r3, [r3, #0]
3418ff5e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3418ff60:	f403 7395 	and.w	r3, r3, #298	@ 0x12a
3418ff64:	2b00      	cmp	r3, #0
3418ff66:	d0d5      	beq.n	3418ff14 <SD_SendSDStatus+0xc4>
    }
  }

  if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
3418ff68:	687b      	ldr	r3, [r7, #4]
3418ff6a:	681b      	ldr	r3, [r3, #0]
3418ff6c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3418ff6e:	f003 0308 	and.w	r3, r3, #8
3418ff72:	2b00      	cmp	r3, #0
3418ff74:	d001      	beq.n	3418ff7a <SD_SendSDStatus+0x12a>
  {
    return HAL_SD_ERROR_DATA_TIMEOUT;
3418ff76:	2308      	movs	r3, #8
3418ff78:	e033      	b.n	3418ffe2 <SD_SendSDStatus+0x192>
  }
  else if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
3418ff7a:	687b      	ldr	r3, [r7, #4]
3418ff7c:	681b      	ldr	r3, [r3, #0]
3418ff7e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3418ff80:	f003 0302 	and.w	r3, r3, #2
3418ff84:	2b00      	cmp	r3, #0
3418ff86:	d001      	beq.n	3418ff8c <SD_SendSDStatus+0x13c>
  {
    return HAL_SD_ERROR_DATA_CRC_FAIL;
3418ff88:	2302      	movs	r3, #2
3418ff8a:	e02a      	b.n	3418ffe2 <SD_SendSDStatus+0x192>
  }
  else if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR))
3418ff8c:	687b      	ldr	r3, [r7, #4]
3418ff8e:	681b      	ldr	r3, [r3, #0]
3418ff90:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3418ff92:	f003 0320 	and.w	r3, r3, #32
3418ff96:	2b00      	cmp	r3, #0
3418ff98:	d017      	beq.n	3418ffca <SD_SendSDStatus+0x17a>
  {
    return HAL_SD_ERROR_RX_OVERRUN;
3418ff9a:	2320      	movs	r3, #32
3418ff9c:	e021      	b.n	3418ffe2 <SD_SendSDStatus+0x192>
    /* Nothing to do */
  }

  while ((__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DPSMACT)))
  {
    *pData = SDMMC_ReadFIFO(hsd->Instance);
3418ff9e:	687b      	ldr	r3, [r7, #4]
3418ffa0:	681b      	ldr	r3, [r3, #0]
3418ffa2:	4618      	mov	r0, r3
3418ffa4:	f001 facc 	bl	34191540 <SDMMC_ReadFIFO>
3418ffa8:	4602      	mov	r2, r0
3418ffaa:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418ffac:	601a      	str	r2, [r3, #0]
    pData++;
3418ffae:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418ffb0:	3304      	adds	r3, #4
3418ffb2:	62bb      	str	r3, [r7, #40]	@ 0x28

    if ((HAL_GetTick() - tickstart) >=  SDMMC_SWDATATIMEOUT)
3418ffb4:	f7f5 fb00 	bl	341855b8 <HAL_GetTick>
3418ffb8:	4602      	mov	r2, r0
3418ffba:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3418ffbc:	1ad3      	subs	r3, r2, r3
3418ffbe:	f1b3 3fff 	cmp.w	r3, #4294967295
3418ffc2:	d102      	bne.n	3418ffca <SD_SendSDStatus+0x17a>
    {
      return HAL_SD_ERROR_TIMEOUT;
3418ffc4:	f04f 4300 	mov.w	r3, #2147483648	@ 0x80000000
3418ffc8:	e00b      	b.n	3418ffe2 <SD_SendSDStatus+0x192>
  while ((__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DPSMACT)))
3418ffca:	687b      	ldr	r3, [r7, #4]
3418ffcc:	681b      	ldr	r3, [r3, #0]
3418ffce:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3418ffd0:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
3418ffd4:	2b00      	cmp	r3, #0
3418ffd6:	d1e2      	bne.n	3418ff9e <SD_SendSDStatus+0x14e>
    }
  }

  /* Clear all the static status flags*/
  __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
3418ffd8:	687b      	ldr	r3, [r7, #4]
3418ffda:	681b      	ldr	r3, [r3, #0]
3418ffdc:	4a03      	ldr	r2, [pc, #12]	@ (3418ffec <SD_SendSDStatus+0x19c>)
3418ffde:	639a      	str	r2, [r3, #56]	@ 0x38

  return HAL_SD_ERROR_NONE;
3418ffe0:	2300      	movs	r3, #0
}
3418ffe2:	4618      	mov	r0, r3
3418ffe4:	3730      	adds	r7, #48	@ 0x30
3418ffe6:	46bd      	mov	sp, r7
3418ffe8:	bd80      	pop	{r7, pc}
3418ffea:	bf00      	nop
3418ffec:	18000f3a 	.word	0x18000f3a

3418fff0 <SD_SendStatus>:
  * @param  pCardStatus: pointer to the buffer that will contain the SD card
  *         status (Card Status register)
  * @retval error state
  */
static uint32_t SD_SendStatus(SD_HandleTypeDef *hsd, uint32_t *pCardStatus)
{
3418fff0:	b580      	push	{r7, lr}
3418fff2:	b084      	sub	sp, #16
3418fff4:	af00      	add	r7, sp, #0
3418fff6:	6078      	str	r0, [r7, #4]
3418fff8:	6039      	str	r1, [r7, #0]
  uint32_t errorstate;

  if (pCardStatus == NULL)
3418fffa:	683b      	ldr	r3, [r7, #0]
3418fffc:	2b00      	cmp	r3, #0
3418fffe:	d102      	bne.n	34190006 <SD_SendStatus+0x16>
  {
    return HAL_SD_ERROR_PARAM;
34190000:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
34190004:	e018      	b.n	34190038 <SD_SendStatus+0x48>
  }

  /* Send Status command */
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
34190006:	687b      	ldr	r3, [r7, #4]
34190008:	681a      	ldr	r2, [r3, #0]
3419000a:	687b      	ldr	r3, [r7, #4]
3419000c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3419000e:	041b      	lsls	r3, r3, #16
34190010:	4619      	mov	r1, r3
34190012:	4610      	mov	r0, r2
34190014:	f001 fd7e 	bl	34191b14 <SDMMC_CmdSendStatus>
34190018:	60f8      	str	r0, [r7, #12]
  if (errorstate != HAL_SD_ERROR_NONE)
3419001a:	68fb      	ldr	r3, [r7, #12]
3419001c:	2b00      	cmp	r3, #0
3419001e:	d001      	beq.n	34190024 <SD_SendStatus+0x34>
  {
    return errorstate;
34190020:	68fb      	ldr	r3, [r7, #12]
34190022:	e009      	b.n	34190038 <SD_SendStatus+0x48>
  }

  /* Get SD card status */
  *pCardStatus = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
34190024:	687b      	ldr	r3, [r7, #4]
34190026:	681b      	ldr	r3, [r3, #0]
34190028:	2100      	movs	r1, #0
3419002a:	4618      	mov	r0, r3
3419002c:	f001 fafd 	bl	3419162a <SDMMC_GetResponse>
34190030:	4602      	mov	r2, r0
34190032:	683b      	ldr	r3, [r7, #0]
34190034:	601a      	str	r2, [r3, #0]

  return HAL_SD_ERROR_NONE;
34190036:	2300      	movs	r3, #0
}
34190038:	4618      	mov	r0, r3
3419003a:	3710      	adds	r7, #16
3419003c:	46bd      	mov	sp, r7
3419003e:	bd80      	pop	{r7, pc}

34190040 <SD_WideBus_Enable>:
  * @brief  Enables the SDMMC wide bus mode.
  * @param  hsd: pointer to SD handle
  * @retval error state
  */
static uint32_t SD_WideBus_Enable(SD_HandleTypeDef *hsd)
{
34190040:	b580      	push	{r7, lr}
34190042:	b086      	sub	sp, #24
34190044:	af00      	add	r7, sp, #0
34190046:	6078      	str	r0, [r7, #4]
  uint32_t scr[2U] = {0UL, 0UL};
34190048:	2300      	movs	r3, #0
3419004a:	60fb      	str	r3, [r7, #12]
3419004c:	2300      	movs	r3, #0
3419004e:	613b      	str	r3, [r7, #16]
  uint32_t errorstate;

  if ((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
34190050:	687b      	ldr	r3, [r7, #4]
34190052:	681b      	ldr	r3, [r3, #0]
34190054:	2100      	movs	r1, #0
34190056:	4618      	mov	r0, r3
34190058:	f001 fae7 	bl	3419162a <SDMMC_GetResponse>
3419005c:	4603      	mov	r3, r0
3419005e:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
34190062:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
34190066:	d102      	bne.n	3419006e <SD_WideBus_Enable+0x2e>
  {
    return HAL_SD_ERROR_LOCK_UNLOCK_FAILED;
34190068:	f44f 6300 	mov.w	r3, #2048	@ 0x800
3419006c:	e02f      	b.n	341900ce <SD_WideBus_Enable+0x8e>
  }

  /* Get SCR Register */
  errorstate = SD_FindSCR(hsd, scr);
3419006e:	f107 030c 	add.w	r3, r7, #12
34190072:	4619      	mov	r1, r3
34190074:	6878      	ldr	r0, [r7, #4]
34190076:	f000 f879 	bl	3419016c <SD_FindSCR>
3419007a:	6178      	str	r0, [r7, #20]
  if (errorstate != HAL_SD_ERROR_NONE)
3419007c:	697b      	ldr	r3, [r7, #20]
3419007e:	2b00      	cmp	r3, #0
34190080:	d001      	beq.n	34190086 <SD_WideBus_Enable+0x46>
  {
    return errorstate;
34190082:	697b      	ldr	r3, [r7, #20]
34190084:	e023      	b.n	341900ce <SD_WideBus_Enable+0x8e>
  }

  /* If requested card supports wide bus operation */
  if ((scr[1U] & SDMMC_WIDE_BUS_SUPPORT) != SDMMC_ALLZERO)
34190086:	693b      	ldr	r3, [r7, #16]
34190088:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
3419008c:	2b00      	cmp	r3, #0
3419008e:	d01c      	beq.n	341900ca <SD_WideBus_Enable+0x8a>
  {
    /* Send CMD55 APP_CMD with argument as card's RCA.*/
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
34190090:	687b      	ldr	r3, [r7, #4]
34190092:	681a      	ldr	r2, [r3, #0]
34190094:	687b      	ldr	r3, [r7, #4]
34190096:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34190098:	041b      	lsls	r3, r3, #16
3419009a:	4619      	mov	r1, r3
3419009c:	4610      	mov	r0, r2
3419009e:	f001 fc50 	bl	34191942 <SDMMC_CmdAppCommand>
341900a2:	6178      	str	r0, [r7, #20]
    if (errorstate != HAL_SD_ERROR_NONE)
341900a4:	697b      	ldr	r3, [r7, #20]
341900a6:	2b00      	cmp	r3, #0
341900a8:	d001      	beq.n	341900ae <SD_WideBus_Enable+0x6e>
    {
      return errorstate;
341900aa:	697b      	ldr	r3, [r7, #20]
341900ac:	e00f      	b.n	341900ce <SD_WideBus_Enable+0x8e>
    }

    /* Send ACMD6 APP_CMD with argument as 2 for wide bus mode */
    errorstate = SDMMC_CmdBusWidth(hsd->Instance, 2U);
341900ae:	687b      	ldr	r3, [r7, #4]
341900b0:	681b      	ldr	r3, [r3, #0]
341900b2:	2102      	movs	r1, #2
341900b4:	4618      	mov	r0, r3
341900b6:	f001 fc87 	bl	341919c8 <SDMMC_CmdBusWidth>
341900ba:	6178      	str	r0, [r7, #20]
    if (errorstate != HAL_SD_ERROR_NONE)
341900bc:	697b      	ldr	r3, [r7, #20]
341900be:	2b00      	cmp	r3, #0
341900c0:	d001      	beq.n	341900c6 <SD_WideBus_Enable+0x86>
    {
      return errorstate;
341900c2:	697b      	ldr	r3, [r7, #20]
341900c4:	e003      	b.n	341900ce <SD_WideBus_Enable+0x8e>
    }

    return HAL_SD_ERROR_NONE;
341900c6:	2300      	movs	r3, #0
341900c8:	e001      	b.n	341900ce <SD_WideBus_Enable+0x8e>
  }
  else
  {
    return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
341900ca:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
  }
}
341900ce:	4618      	mov	r0, r3
341900d0:	3718      	adds	r7, #24
341900d2:	46bd      	mov	sp, r7
341900d4:	bd80      	pop	{r7, pc}

341900d6 <SD_WideBus_Disable>:
  * @brief  Disables the SDMMC wide bus mode.
  * @param  hsd: Pointer to SD handle
  * @retval error state
  */
static uint32_t SD_WideBus_Disable(SD_HandleTypeDef *hsd)
{
341900d6:	b580      	push	{r7, lr}
341900d8:	b086      	sub	sp, #24
341900da:	af00      	add	r7, sp, #0
341900dc:	6078      	str	r0, [r7, #4]
  uint32_t scr[2U] = {0UL, 0UL};
341900de:	2300      	movs	r3, #0
341900e0:	60fb      	str	r3, [r7, #12]
341900e2:	2300      	movs	r3, #0
341900e4:	613b      	str	r3, [r7, #16]
  uint32_t errorstate;

  if ((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
341900e6:	687b      	ldr	r3, [r7, #4]
341900e8:	681b      	ldr	r3, [r3, #0]
341900ea:	2100      	movs	r1, #0
341900ec:	4618      	mov	r0, r3
341900ee:	f001 fa9c 	bl	3419162a <SDMMC_GetResponse>
341900f2:	4603      	mov	r3, r0
341900f4:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
341900f8:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
341900fc:	d102      	bne.n	34190104 <SD_WideBus_Disable+0x2e>
  {
    return HAL_SD_ERROR_LOCK_UNLOCK_FAILED;
341900fe:	f44f 6300 	mov.w	r3, #2048	@ 0x800
34190102:	e02f      	b.n	34190164 <SD_WideBus_Disable+0x8e>
  }

  /* Get SCR Register */
  errorstate = SD_FindSCR(hsd, scr);
34190104:	f107 030c 	add.w	r3, r7, #12
34190108:	4619      	mov	r1, r3
3419010a:	6878      	ldr	r0, [r7, #4]
3419010c:	f000 f82e 	bl	3419016c <SD_FindSCR>
34190110:	6178      	str	r0, [r7, #20]
  if (errorstate != HAL_SD_ERROR_NONE)
34190112:	697b      	ldr	r3, [r7, #20]
34190114:	2b00      	cmp	r3, #0
34190116:	d001      	beq.n	3419011c <SD_WideBus_Disable+0x46>
  {
    return errorstate;
34190118:	697b      	ldr	r3, [r7, #20]
3419011a:	e023      	b.n	34190164 <SD_WideBus_Disable+0x8e>
  }

  /* If requested card supports 1 bit mode operation */
  if ((scr[1U] & SDMMC_SINGLE_BUS_SUPPORT) != SDMMC_ALLZERO)
3419011c:	693b      	ldr	r3, [r7, #16]
3419011e:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
34190122:	2b00      	cmp	r3, #0
34190124:	d01c      	beq.n	34190160 <SD_WideBus_Disable+0x8a>
  {
    /* Send CMD55 APP_CMD with argument as card's RCA */
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
34190126:	687b      	ldr	r3, [r7, #4]
34190128:	681a      	ldr	r2, [r3, #0]
3419012a:	687b      	ldr	r3, [r7, #4]
3419012c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3419012e:	041b      	lsls	r3, r3, #16
34190130:	4619      	mov	r1, r3
34190132:	4610      	mov	r0, r2
34190134:	f001 fc05 	bl	34191942 <SDMMC_CmdAppCommand>
34190138:	6178      	str	r0, [r7, #20]
    if (errorstate != HAL_SD_ERROR_NONE)
3419013a:	697b      	ldr	r3, [r7, #20]
3419013c:	2b00      	cmp	r3, #0
3419013e:	d001      	beq.n	34190144 <SD_WideBus_Disable+0x6e>
    {
      return errorstate;
34190140:	697b      	ldr	r3, [r7, #20]
34190142:	e00f      	b.n	34190164 <SD_WideBus_Disable+0x8e>
    }

    /* Send ACMD6 APP_CMD with argument as 0 for single bus mode */
    errorstate = SDMMC_CmdBusWidth(hsd->Instance, 0U);
34190144:	687b      	ldr	r3, [r7, #4]
34190146:	681b      	ldr	r3, [r3, #0]
34190148:	2100      	movs	r1, #0
3419014a:	4618      	mov	r0, r3
3419014c:	f001 fc3c 	bl	341919c8 <SDMMC_CmdBusWidth>
34190150:	6178      	str	r0, [r7, #20]
    if (errorstate != HAL_SD_ERROR_NONE)
34190152:	697b      	ldr	r3, [r7, #20]
34190154:	2b00      	cmp	r3, #0
34190156:	d001      	beq.n	3419015c <SD_WideBus_Disable+0x86>
    {
      return errorstate;
34190158:	697b      	ldr	r3, [r7, #20]
3419015a:	e003      	b.n	34190164 <SD_WideBus_Disable+0x8e>
    }

    return HAL_SD_ERROR_NONE;
3419015c:	2300      	movs	r3, #0
3419015e:	e001      	b.n	34190164 <SD_WideBus_Disable+0x8e>
  }
  else
  {
    return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
34190160:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
  }
}
34190164:	4618      	mov	r0, r3
34190166:	3718      	adds	r7, #24
34190168:	46bd      	mov	sp, r7
3419016a:	bd80      	pop	{r7, pc}

3419016c <SD_FindSCR>:
  * @param  hsd: Pointer to SD handle
  * @param  pSCR: pointer to the buffer that will contain the SCR value
  * @retval error state
  */
static uint32_t SD_FindSCR(SD_HandleTypeDef *hsd, uint32_t *pSCR)
{
3419016c:	b580      	push	{r7, lr}
3419016e:	b08e      	sub	sp, #56	@ 0x38
34190170:	af00      	add	r7, sp, #0
34190172:	6078      	str	r0, [r7, #4]
34190174:	6039      	str	r1, [r7, #0]
  SDMMC_DataInitTypeDef config;
  uint32_t errorstate;
  uint32_t tickstart = HAL_GetTick();
34190176:	f7f5 fa1f 	bl	341855b8 <HAL_GetTick>
3419017a:	6338      	str	r0, [r7, #48]	@ 0x30
  uint32_t index = 0U;
3419017c:	2300      	movs	r3, #0
3419017e:	637b      	str	r3, [r7, #52]	@ 0x34
  uint32_t tempscr[2U] = {0UL, 0UL};
34190180:	2300      	movs	r3, #0
34190182:	60bb      	str	r3, [r7, #8]
34190184:	2300      	movs	r3, #0
34190186:	60fb      	str	r3, [r7, #12]
  uint32_t *scr = pSCR;
34190188:	683b      	ldr	r3, [r7, #0]
3419018a:	62fb      	str	r3, [r7, #44]	@ 0x2c

  /* Set Block Size To 8 Bytes */
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, 8U);
3419018c:	687b      	ldr	r3, [r7, #4]
3419018e:	681b      	ldr	r3, [r3, #0]
34190190:	2108      	movs	r1, #8
34190192:	4618      	mov	r0, r3
34190194:	f001 fa88 	bl	341916a8 <SDMMC_CmdBlockLength>
34190198:	62b8      	str	r0, [r7, #40]	@ 0x28
  if (errorstate != HAL_SD_ERROR_NONE)
3419019a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419019c:	2b00      	cmp	r3, #0
3419019e:	d001      	beq.n	341901a4 <SD_FindSCR+0x38>
  {
    return errorstate;
341901a0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
341901a2:	e0ad      	b.n	34190300 <SD_FindSCR+0x194>
  }

  /* Send CMD55 APP_CMD with argument as card's RCA */
  errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)((hsd->SdCard.RelCardAdd) << 16U));
341901a4:	687b      	ldr	r3, [r7, #4]
341901a6:	681a      	ldr	r2, [r3, #0]
341901a8:	687b      	ldr	r3, [r7, #4]
341901aa:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
341901ac:	041b      	lsls	r3, r3, #16
341901ae:	4619      	mov	r1, r3
341901b0:	4610      	mov	r0, r2
341901b2:	f001 fbc6 	bl	34191942 <SDMMC_CmdAppCommand>
341901b6:	62b8      	str	r0, [r7, #40]	@ 0x28
  if (errorstate != HAL_SD_ERROR_NONE)
341901b8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
341901ba:	2b00      	cmp	r3, #0
341901bc:	d001      	beq.n	341901c2 <SD_FindSCR+0x56>
  {
    return errorstate;
341901be:	6abb      	ldr	r3, [r7, #40]	@ 0x28
341901c0:	e09e      	b.n	34190300 <SD_FindSCR+0x194>
  }

  config.DataTimeOut   = SDMMC_DATATIMEOUT;
341901c2:	f04f 33ff 	mov.w	r3, #4294967295
341901c6:	613b      	str	r3, [r7, #16]
  config.DataLength    = 8U;
341901c8:	2308      	movs	r3, #8
341901ca:	617b      	str	r3, [r7, #20]
  config.DataBlockSize = SDMMC_DATABLOCK_SIZE_8B;
341901cc:	2330      	movs	r3, #48	@ 0x30
341901ce:	61bb      	str	r3, [r7, #24]
  config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
341901d0:	2302      	movs	r3, #2
341901d2:	61fb      	str	r3, [r7, #28]
  config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
341901d4:	2300      	movs	r3, #0
341901d6:	623b      	str	r3, [r7, #32]
  config.DPSM          = SDMMC_DPSM_ENABLE;
341901d8:	2301      	movs	r3, #1
341901da:	627b      	str	r3, [r7, #36]	@ 0x24
  (void)SDMMC_ConfigData(hsd->Instance, &config);
341901dc:	687b      	ldr	r3, [r7, #4]
341901de:	681b      	ldr	r3, [r3, #0]
341901e0:	f107 0210 	add.w	r2, r7, #16
341901e4:	4611      	mov	r1, r2
341901e6:	4618      	mov	r0, r3
341901e8:	f001 fa32 	bl	34191650 <SDMMC_ConfigData>

  /* Send ACMD51 SD_APP_SEND_SCR with argument as 0 */
  errorstate = SDMMC_CmdSendSCR(hsd->Instance);
341901ec:	687b      	ldr	r3, [r7, #4]
341901ee:	681b      	ldr	r3, [r3, #0]
341901f0:	4618      	mov	r0, r3
341901f2:	f001 fc0c 	bl	34191a0e <SDMMC_CmdSendSCR>
341901f6:	62b8      	str	r0, [r7, #40]	@ 0x28
  if (errorstate != HAL_SD_ERROR_NONE)
341901f8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
341901fa:	2b00      	cmp	r3, #0
341901fc:	d027      	beq.n	3419024e <SD_FindSCR+0xe2>
  {
    return errorstate;
341901fe:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34190200:	e07e      	b.n	34190300 <SD_FindSCR+0x194>
  }

  while (!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DBCKEND |
                            SDMMC_FLAG_DATAEND))
  {
    if ((!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOE)) && (index == 0U))
34190202:	687b      	ldr	r3, [r7, #4]
34190204:	681b      	ldr	r3, [r3, #0]
34190206:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
34190208:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
3419020c:	2b00      	cmp	r3, #0
3419020e:	d113      	bne.n	34190238 <SD_FindSCR+0xcc>
34190210:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34190212:	2b00      	cmp	r3, #0
34190214:	d110      	bne.n	34190238 <SD_FindSCR+0xcc>
    {
      tempscr[0] = SDMMC_ReadFIFO(hsd->Instance);
34190216:	687b      	ldr	r3, [r7, #4]
34190218:	681b      	ldr	r3, [r3, #0]
3419021a:	4618      	mov	r0, r3
3419021c:	f001 f990 	bl	34191540 <SDMMC_ReadFIFO>
34190220:	4603      	mov	r3, r0
34190222:	60bb      	str	r3, [r7, #8]
      tempscr[1] = SDMMC_ReadFIFO(hsd->Instance);
34190224:	687b      	ldr	r3, [r7, #4]
34190226:	681b      	ldr	r3, [r3, #0]
34190228:	4618      	mov	r0, r3
3419022a:	f001 f989 	bl	34191540 <SDMMC_ReadFIFO>
3419022e:	4603      	mov	r3, r0
34190230:	60fb      	str	r3, [r7, #12]
      index++;
34190232:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34190234:	3301      	adds	r3, #1
34190236:	637b      	str	r3, [r7, #52]	@ 0x34
    }

    if ((HAL_GetTick() - tickstart) >=  SDMMC_SWDATATIMEOUT)
34190238:	f7f5 f9be 	bl	341855b8 <HAL_GetTick>
3419023c:	4602      	mov	r2, r0
3419023e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34190240:	1ad3      	subs	r3, r2, r3
34190242:	f1b3 3fff 	cmp.w	r3, #4294967295
34190246:	d102      	bne.n	3419024e <SD_FindSCR+0xe2>
    {
      return HAL_SD_ERROR_TIMEOUT;
34190248:	f04f 4300 	mov.w	r3, #2147483648	@ 0x80000000
3419024c:	e058      	b.n	34190300 <SD_FindSCR+0x194>
  while (!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DBCKEND |
3419024e:	687b      	ldr	r3, [r7, #4]
34190250:	681b      	ldr	r3, [r3, #0]
34190252:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
34190254:	f240 532a 	movw	r3, #1322	@ 0x52a
34190258:	4013      	ands	r3, r2
3419025a:	2b00      	cmp	r3, #0
3419025c:	d0d1      	beq.n	34190202 <SD_FindSCR+0x96>
    }
  }

  if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
3419025e:	687b      	ldr	r3, [r7, #4]
34190260:	681b      	ldr	r3, [r3, #0]
34190262:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
34190264:	f003 0308 	and.w	r3, r3, #8
34190268:	2b00      	cmp	r3, #0
3419026a:	d005      	beq.n	34190278 <SD_FindSCR+0x10c>
  {
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DTIMEOUT);
3419026c:	687b      	ldr	r3, [r7, #4]
3419026e:	681b      	ldr	r3, [r3, #0]
34190270:	2208      	movs	r2, #8
34190272:	639a      	str	r2, [r3, #56]	@ 0x38

    return HAL_SD_ERROR_DATA_TIMEOUT;
34190274:	2308      	movs	r3, #8
34190276:	e043      	b.n	34190300 <SD_FindSCR+0x194>
  }
  else if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
34190278:	687b      	ldr	r3, [r7, #4]
3419027a:	681b      	ldr	r3, [r3, #0]
3419027c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3419027e:	f003 0302 	and.w	r3, r3, #2
34190282:	2b00      	cmp	r3, #0
34190284:	d005      	beq.n	34190292 <SD_FindSCR+0x126>
  {
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DCRCFAIL);
34190286:	687b      	ldr	r3, [r7, #4]
34190288:	681b      	ldr	r3, [r3, #0]
3419028a:	2202      	movs	r2, #2
3419028c:	639a      	str	r2, [r3, #56]	@ 0x38

    return HAL_SD_ERROR_DATA_CRC_FAIL;
3419028e:	2302      	movs	r3, #2
34190290:	e036      	b.n	34190300 <SD_FindSCR+0x194>
  }
  else if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR))
34190292:	687b      	ldr	r3, [r7, #4]
34190294:	681b      	ldr	r3, [r3, #0]
34190296:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
34190298:	f003 0320 	and.w	r3, r3, #32
3419029c:	2b00      	cmp	r3, #0
3419029e:	d005      	beq.n	341902ac <SD_FindSCR+0x140>
  {
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_RXOVERR);
341902a0:	687b      	ldr	r3, [r7, #4]
341902a2:	681b      	ldr	r3, [r3, #0]
341902a4:	2220      	movs	r2, #32
341902a6:	639a      	str	r2, [r3, #56]	@ 0x38

    return HAL_SD_ERROR_RX_OVERRUN;
341902a8:	2320      	movs	r3, #32
341902aa:	e029      	b.n	34190300 <SD_FindSCR+0x194>
  }
  else
  {
    /* No error flag set */
    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
341902ac:	687b      	ldr	r3, [r7, #4]
341902ae:	681b      	ldr	r3, [r3, #0]
341902b0:	4a15      	ldr	r2, [pc, #84]	@ (34190308 <SD_FindSCR+0x19c>)
341902b2:	639a      	str	r2, [r3, #56]	@ 0x38

    *scr = (((tempscr[1] & SDMMC_0TO7BITS) << 24U)  | ((tempscr[1] & SDMMC_8TO15BITS) << 8U) | \
341902b4:	68fb      	ldr	r3, [r7, #12]
341902b6:	061a      	lsls	r2, r3, #24
341902b8:	68fb      	ldr	r3, [r7, #12]
341902ba:	021b      	lsls	r3, r3, #8
341902bc:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
341902c0:	431a      	orrs	r2, r3
            ((tempscr[1] & SDMMC_16TO23BITS) >> 8U) | ((tempscr[1] & SDMMC_24TO31BITS) >> 24U));
341902c2:	68fb      	ldr	r3, [r7, #12]
341902c4:	0a1b      	lsrs	r3, r3, #8
341902c6:	f403 437f 	and.w	r3, r3, #65280	@ 0xff00
    *scr = (((tempscr[1] & SDMMC_0TO7BITS) << 24U)  | ((tempscr[1] & SDMMC_8TO15BITS) << 8U) | \
341902ca:	431a      	orrs	r2, r3
            ((tempscr[1] & SDMMC_16TO23BITS) >> 8U) | ((tempscr[1] & SDMMC_24TO31BITS) >> 24U));
341902cc:	68fb      	ldr	r3, [r7, #12]
341902ce:	0e1b      	lsrs	r3, r3, #24
341902d0:	431a      	orrs	r2, r3
    *scr = (((tempscr[1] & SDMMC_0TO7BITS) << 24U)  | ((tempscr[1] & SDMMC_8TO15BITS) << 8U) | \
341902d2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
341902d4:	601a      	str	r2, [r3, #0]
    scr++;
341902d6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
341902d8:	3304      	adds	r3, #4
341902da:	62fb      	str	r3, [r7, #44]	@ 0x2c
    *scr = (((tempscr[0] & SDMMC_0TO7BITS) << 24U)  | ((tempscr[0] & SDMMC_8TO15BITS) << 8U) | \
341902dc:	68bb      	ldr	r3, [r7, #8]
341902de:	061a      	lsls	r2, r3, #24
341902e0:	68bb      	ldr	r3, [r7, #8]
341902e2:	021b      	lsls	r3, r3, #8
341902e4:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
341902e8:	431a      	orrs	r2, r3
            ((tempscr[0] & SDMMC_16TO23BITS) >> 8U) | ((tempscr[0] & SDMMC_24TO31BITS) >> 24U));
341902ea:	68bb      	ldr	r3, [r7, #8]
341902ec:	0a1b      	lsrs	r3, r3, #8
341902ee:	f403 437f 	and.w	r3, r3, #65280	@ 0xff00
    *scr = (((tempscr[0] & SDMMC_0TO7BITS) << 24U)  | ((tempscr[0] & SDMMC_8TO15BITS) << 8U) | \
341902f2:	431a      	orrs	r2, r3
            ((tempscr[0] & SDMMC_16TO23BITS) >> 8U) | ((tempscr[0] & SDMMC_24TO31BITS) >> 24U));
341902f4:	68bb      	ldr	r3, [r7, #8]
341902f6:	0e1b      	lsrs	r3, r3, #24
341902f8:	431a      	orrs	r2, r3
    *scr = (((tempscr[0] & SDMMC_0TO7BITS) << 24U)  | ((tempscr[0] & SDMMC_8TO15BITS) << 8U) | \
341902fa:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
341902fc:	601a      	str	r2, [r3, #0]

  }

  return HAL_SD_ERROR_NONE;
341902fe:	2300      	movs	r3, #0
}
34190300:	4618      	mov	r0, r3
34190302:	3738      	adds	r7, #56	@ 0x38
34190304:	46bd      	mov	sp, r7
34190306:	bd80      	pop	{r7, pc}
34190308:	18000f3a 	.word	0x18000f3a

3419030c <SD_Read_IT>:
  * @param  hsd: pointer to a SD_HandleTypeDef structure that contains
  *              the configuration information.
  * @retval None
  */
static void SD_Read_IT(SD_HandleTypeDef *hsd)
{
3419030c:	b580      	push	{r7, lr}
3419030e:	b086      	sub	sp, #24
34190310:	af00      	add	r7, sp, #0
34190312:	6078      	str	r0, [r7, #4]
  uint32_t count;
  uint32_t data;
  uint8_t *tmp;

  tmp = hsd->pRxBuffPtr;
34190314:	687b      	ldr	r3, [r7, #4]
34190316:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34190318:	613b      	str	r3, [r7, #16]

  if (hsd->RxXferSize >= SDMMC_FIFO_SIZE)
3419031a:	687b      	ldr	r3, [r7, #4]
3419031c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3419031e:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
34190322:	d336      	bcc.n	34190392 <SD_Read_IT+0x86>
  {
    /* Read data from SDMMC Rx FIFO */
    for (count = 0U; count < (SDMMC_FIFO_SIZE / 4U); count++)
34190324:	2300      	movs	r3, #0
34190326:	617b      	str	r3, [r7, #20]
34190328:	e027      	b.n	3419037a <SD_Read_IT+0x6e>
    {
      data = SDMMC_ReadFIFO(hsd->Instance);
3419032a:	687b      	ldr	r3, [r7, #4]
3419032c:	681b      	ldr	r3, [r3, #0]
3419032e:	4618      	mov	r0, r3
34190330:	f001 f906 	bl	34191540 <SDMMC_ReadFIFO>
34190334:	60f8      	str	r0, [r7, #12]
      *tmp = (uint8_t)(data & 0xFFU);
34190336:	68fb      	ldr	r3, [r7, #12]
34190338:	b2da      	uxtb	r2, r3
3419033a:	693b      	ldr	r3, [r7, #16]
3419033c:	701a      	strb	r2, [r3, #0]
      tmp++;
3419033e:	693b      	ldr	r3, [r7, #16]
34190340:	3301      	adds	r3, #1
34190342:	613b      	str	r3, [r7, #16]
      *tmp = (uint8_t)((data >> 8U) & 0xFFU);
34190344:	68fb      	ldr	r3, [r7, #12]
34190346:	0a1b      	lsrs	r3, r3, #8
34190348:	b2da      	uxtb	r2, r3
3419034a:	693b      	ldr	r3, [r7, #16]
3419034c:	701a      	strb	r2, [r3, #0]
      tmp++;
3419034e:	693b      	ldr	r3, [r7, #16]
34190350:	3301      	adds	r3, #1
34190352:	613b      	str	r3, [r7, #16]
      *tmp = (uint8_t)((data >> 16U) & 0xFFU);
34190354:	68fb      	ldr	r3, [r7, #12]
34190356:	0c1b      	lsrs	r3, r3, #16
34190358:	b2da      	uxtb	r2, r3
3419035a:	693b      	ldr	r3, [r7, #16]
3419035c:	701a      	strb	r2, [r3, #0]
      tmp++;
3419035e:	693b      	ldr	r3, [r7, #16]
34190360:	3301      	adds	r3, #1
34190362:	613b      	str	r3, [r7, #16]
      *tmp = (uint8_t)((data >> 24U) & 0xFFU);
34190364:	68fb      	ldr	r3, [r7, #12]
34190366:	0e1b      	lsrs	r3, r3, #24
34190368:	b2da      	uxtb	r2, r3
3419036a:	693b      	ldr	r3, [r7, #16]
3419036c:	701a      	strb	r2, [r3, #0]
      tmp++;
3419036e:	693b      	ldr	r3, [r7, #16]
34190370:	3301      	adds	r3, #1
34190372:	613b      	str	r3, [r7, #16]
    for (count = 0U; count < (SDMMC_FIFO_SIZE / 4U); count++)
34190374:	697b      	ldr	r3, [r7, #20]
34190376:	3301      	adds	r3, #1
34190378:	617b      	str	r3, [r7, #20]
3419037a:	697b      	ldr	r3, [r7, #20]
3419037c:	2b7f      	cmp	r3, #127	@ 0x7f
3419037e:	d9d4      	bls.n	3419032a <SD_Read_IT+0x1e>
    }

    hsd->pRxBuffPtr = tmp;
34190380:	687b      	ldr	r3, [r7, #4]
34190382:	693a      	ldr	r2, [r7, #16]
34190384:	625a      	str	r2, [r3, #36]	@ 0x24
    hsd->RxXferSize -= SDMMC_FIFO_SIZE;
34190386:	687b      	ldr	r3, [r7, #4]
34190388:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3419038a:	f5a3 7200 	sub.w	r2, r3, #512	@ 0x200
3419038e:	687b      	ldr	r3, [r7, #4]
34190390:	629a      	str	r2, [r3, #40]	@ 0x28
  }
}
34190392:	bf00      	nop
34190394:	3718      	adds	r7, #24
34190396:	46bd      	mov	sp, r7
34190398:	bd80      	pop	{r7, pc}

3419039a <SD_Write_IT>:
  * @param  hsd: pointer to a SD_HandleTypeDef structure that contains
  *              the configuration information.
  * @retval None
  */
static void SD_Write_IT(SD_HandleTypeDef *hsd)
{
3419039a:	b580      	push	{r7, lr}
3419039c:	b086      	sub	sp, #24
3419039e:	af00      	add	r7, sp, #0
341903a0:	6078      	str	r0, [r7, #4]
  uint32_t count;
  uint32_t data;
  const uint8_t *tmp;

  tmp = hsd->pTxBuffPtr;
341903a2:	687b      	ldr	r3, [r7, #4]
341903a4:	69db      	ldr	r3, [r3, #28]
341903a6:	613b      	str	r3, [r7, #16]

  if (hsd->TxXferSize >= SDMMC_FIFO_SIZE)
341903a8:	687b      	ldr	r3, [r7, #4]
341903aa:	6a1b      	ldr	r3, [r3, #32]
341903ac:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
341903b0:	d33a      	bcc.n	34190428 <SD_Write_IT+0x8e>
  {
    /* Write data to SDMMC Tx FIFO */
    for (count = 0U; count < (SDMMC_FIFO_SIZE / 4U); count++)
341903b2:	2300      	movs	r3, #0
341903b4:	617b      	str	r3, [r7, #20]
341903b6:	e02b      	b.n	34190410 <SD_Write_IT+0x76>
    {
      data = (uint32_t)(*tmp);
341903b8:	693b      	ldr	r3, [r7, #16]
341903ba:	781b      	ldrb	r3, [r3, #0]
341903bc:	60fb      	str	r3, [r7, #12]
      tmp++;
341903be:	693b      	ldr	r3, [r7, #16]
341903c0:	3301      	adds	r3, #1
341903c2:	613b      	str	r3, [r7, #16]
      data |= ((uint32_t)(*tmp) << 8U);
341903c4:	693b      	ldr	r3, [r7, #16]
341903c6:	781b      	ldrb	r3, [r3, #0]
341903c8:	021a      	lsls	r2, r3, #8
341903ca:	68fb      	ldr	r3, [r7, #12]
341903cc:	4313      	orrs	r3, r2
341903ce:	60fb      	str	r3, [r7, #12]
      tmp++;
341903d0:	693b      	ldr	r3, [r7, #16]
341903d2:	3301      	adds	r3, #1
341903d4:	613b      	str	r3, [r7, #16]
      data |= ((uint32_t)(*tmp) << 16U);
341903d6:	693b      	ldr	r3, [r7, #16]
341903d8:	781b      	ldrb	r3, [r3, #0]
341903da:	041a      	lsls	r2, r3, #16
341903dc:	68fb      	ldr	r3, [r7, #12]
341903de:	4313      	orrs	r3, r2
341903e0:	60fb      	str	r3, [r7, #12]
      tmp++;
341903e2:	693b      	ldr	r3, [r7, #16]
341903e4:	3301      	adds	r3, #1
341903e6:	613b      	str	r3, [r7, #16]
      data |= ((uint32_t)(*tmp) << 24U);
341903e8:	693b      	ldr	r3, [r7, #16]
341903ea:	781b      	ldrb	r3, [r3, #0]
341903ec:	061a      	lsls	r2, r3, #24
341903ee:	68fb      	ldr	r3, [r7, #12]
341903f0:	4313      	orrs	r3, r2
341903f2:	60fb      	str	r3, [r7, #12]
      tmp++;
341903f4:	693b      	ldr	r3, [r7, #16]
341903f6:	3301      	adds	r3, #1
341903f8:	613b      	str	r3, [r7, #16]
      (void)SDMMC_WriteFIFO(hsd->Instance, &data);
341903fa:	687b      	ldr	r3, [r7, #4]
341903fc:	681b      	ldr	r3, [r3, #0]
341903fe:	f107 020c 	add.w	r2, r7, #12
34190402:	4611      	mov	r1, r2
34190404:	4618      	mov	r0, r3
34190406:	f001 f8a8 	bl	3419155a <SDMMC_WriteFIFO>
    for (count = 0U; count < (SDMMC_FIFO_SIZE / 4U); count++)
3419040a:	697b      	ldr	r3, [r7, #20]
3419040c:	3301      	adds	r3, #1
3419040e:	617b      	str	r3, [r7, #20]
34190410:	697b      	ldr	r3, [r7, #20]
34190412:	2b7f      	cmp	r3, #127	@ 0x7f
34190414:	d9d0      	bls.n	341903b8 <SD_Write_IT+0x1e>
    }

    hsd->pTxBuffPtr = tmp;
34190416:	687b      	ldr	r3, [r7, #4]
34190418:	693a      	ldr	r2, [r7, #16]
3419041a:	61da      	str	r2, [r3, #28]
    hsd->TxXferSize -= SDMMC_FIFO_SIZE;
3419041c:	687b      	ldr	r3, [r7, #4]
3419041e:	6a1b      	ldr	r3, [r3, #32]
34190420:	f5a3 7200 	sub.w	r2, r3, #512	@ 0x200
34190424:	687b      	ldr	r3, [r7, #4]
34190426:	621a      	str	r2, [r3, #32]
  }
}
34190428:	bf00      	nop
3419042a:	3718      	adds	r7, #24
3419042c:	46bd      	mov	sp, r7
3419042e:	bd80      	pop	{r7, pc}

34190430 <HAL_SDEx_Read_DMALnkLstBufCpltCallback>:
  * @brief Read DMA Linked list node Transfer completed callbacks
  * @param hsd: SD handle
  * @retval None
  */
__weak void HAL_SDEx_Read_DMALnkLstBufCpltCallback(SD_HandleTypeDef *hsd)
{
34190430:	b480      	push	{r7}
34190432:	b083      	sub	sp, #12
34190434:	af00      	add	r7, sp, #0
34190436:	6078      	str	r0, [r7, #4]
  UNUSED(hsd);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SDEx_Read_DMALnkLstBufCpltCallback can be implemented in the user file
   */
}
34190438:	bf00      	nop
3419043a:	370c      	adds	r7, #12
3419043c:	46bd      	mov	sp, r7
3419043e:	f85d 7b04 	ldr.w	r7, [sp], #4
34190442:	4770      	bx	lr

34190444 <HAL_SDEx_Write_DMALnkLstBufCpltCallback>:
  * @brief Read DMA Linked list node Transfer completed callbacks
  * @param hsd: SD handle
  * @retval None
  */
__weak void HAL_SDEx_Write_DMALnkLstBufCpltCallback(SD_HandleTypeDef *hsd)
{
34190444:	b480      	push	{r7}
34190446:	b083      	sub	sp, #12
34190448:	af00      	add	r7, sp, #0
3419044a:	6078      	str	r0, [r7, #4]
  UNUSED(hsd);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SDEx_Write_DMALnkLstBufCpltCallback can be implemented in the user file
   */
}
3419044c:	bf00      	nop
3419044e:	370c      	adds	r7, #12
34190450:	46bd      	mov	sp, r7
34190452:	f85d 7b04 	ldr.w	r7, [sp], #4
34190456:	4770      	bx	lr

34190458 <HAL_TIM_Base_Init>:
  *         Ex: call @ref HAL_TIM_Base_DeInit() before HAL_TIM_Base_Init()
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
{
34190458:	b580      	push	{r7, lr}
3419045a:	b082      	sub	sp, #8
3419045c:	af00      	add	r7, sp, #0
3419045e:	6078      	str	r0, [r7, #4]
  /* Check the TIM handle allocation */
  if (htim == NULL)
34190460:	687b      	ldr	r3, [r7, #4]
34190462:	2b00      	cmp	r3, #0
34190464:	d101      	bne.n	3419046a <HAL_TIM_Base_Init+0x12>
  {
    return HAL_ERROR;
34190466:	2301      	movs	r3, #1
34190468:	e049      	b.n	341904fe <HAL_TIM_Base_Init+0xa6>
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_PERIOD(htim, htim->Init.Period));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if (htim->State == HAL_TIM_STATE_RESET)
3419046a:	687b      	ldr	r3, [r7, #4]
3419046c:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
34190470:	b2db      	uxtb	r3, r3
34190472:	2b00      	cmp	r3, #0
34190474:	d106      	bne.n	34190484 <HAL_TIM_Base_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
34190476:	687b      	ldr	r3, [r7, #4]
34190478:	2200      	movs	r2, #0
3419047a:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c
    }
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    htim->Base_MspInitCallback(htim);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    HAL_TIM_Base_MspInit(htim);
3419047e:	6878      	ldr	r0, [r7, #4]
34190480:	f000 f841 	bl	34190506 <HAL_TIM_Base_MspInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
34190484:	687b      	ldr	r3, [r7, #4]
34190486:	2202      	movs	r2, #2
34190488:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

  /* Set the Time Base configuration */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
3419048c:	687b      	ldr	r3, [r7, #4]
3419048e:	681a      	ldr	r2, [r3, #0]
34190490:	687b      	ldr	r3, [r7, #4]
34190492:	3304      	adds	r3, #4
34190494:	4619      	mov	r1, r3
34190496:	4610      	mov	r0, r2
34190498:	f000 fa70 	bl	3419097c <TIM_Base_SetConfig>

  /* Initialize the DMA burst operation state */
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
3419049c:	687b      	ldr	r3, [r7, #4]
3419049e:	2201      	movs	r2, #1
341904a0:	f883 2048 	strb.w	r2, [r3, #72]	@ 0x48

  /* Initialize the TIM channels state */
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
341904a4:	687b      	ldr	r3, [r7, #4]
341904a6:	2201      	movs	r2, #1
341904a8:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
341904ac:	687b      	ldr	r3, [r7, #4]
341904ae:	2201      	movs	r2, #1
341904b0:	f883 203f 	strb.w	r2, [r3, #63]	@ 0x3f
341904b4:	687b      	ldr	r3, [r7, #4]
341904b6:	2201      	movs	r2, #1
341904b8:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
341904bc:	687b      	ldr	r3, [r7, #4]
341904be:	2201      	movs	r2, #1
341904c0:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
341904c4:	687b      	ldr	r3, [r7, #4]
341904c6:	2201      	movs	r2, #1
341904c8:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
341904cc:	687b      	ldr	r3, [r7, #4]
341904ce:	2201      	movs	r2, #1
341904d0:	f883 2043 	strb.w	r2, [r3, #67]	@ 0x43
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
341904d4:	687b      	ldr	r3, [r7, #4]
341904d6:	2201      	movs	r2, #1
341904d8:	f883 2044 	strb.w	r2, [r3, #68]	@ 0x44
341904dc:	687b      	ldr	r3, [r7, #4]
341904de:	2201      	movs	r2, #1
341904e0:	f883 2045 	strb.w	r2, [r3, #69]	@ 0x45
341904e4:	687b      	ldr	r3, [r7, #4]
341904e6:	2201      	movs	r2, #1
341904e8:	f883 2046 	strb.w	r2, [r3, #70]	@ 0x46
341904ec:	687b      	ldr	r3, [r7, #4]
341904ee:	2201      	movs	r2, #1
341904f0:	f883 2047 	strb.w	r2, [r3, #71]	@ 0x47

  /* Initialize the TIM state*/
  htim->State = HAL_TIM_STATE_READY;
341904f4:	687b      	ldr	r3, [r7, #4]
341904f6:	2201      	movs	r2, #1
341904f8:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

  return HAL_OK;
341904fc:	2300      	movs	r3, #0
}
341904fe:	4618      	mov	r0, r3
34190500:	3708      	adds	r7, #8
34190502:	46bd      	mov	sp, r7
34190504:	bd80      	pop	{r7, pc}

34190506 <HAL_TIM_Base_MspInit>:
  * @brief  Initializes the TIM Base MSP.
  * @param  htim TIM Base handle
  * @retval None
  */
__weak void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)
{
34190506:	b480      	push	{r7}
34190508:	b083      	sub	sp, #12
3419050a:	af00      	add	r7, sp, #0
3419050c:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_Base_MspInit could be implemented in the user file
   */
}
3419050e:	bf00      	nop
34190510:	370c      	adds	r7, #12
34190512:	46bd      	mov	sp, r7
34190514:	f85d 7b04 	ldr.w	r7, [sp], #4
34190518:	4770      	bx	lr
	...

3419051c <HAL_TIM_Base_Start_IT>:
  * @brief  Starts the TIM Base generation in interrupt mode.
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
{
3419051c:	b480      	push	{r7}
3419051e:	b085      	sub	sp, #20
34190520:	af00      	add	r7, sp, #0
34190522:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  /* Check the TIM state */
  if (htim->State != HAL_TIM_STATE_READY)
34190524:	687b      	ldr	r3, [r7, #4]
34190526:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
3419052a:	b2db      	uxtb	r3, r3
3419052c:	2b01      	cmp	r3, #1
3419052e:	d001      	beq.n	34190534 <HAL_TIM_Base_Start_IT+0x18>
  {
    return HAL_ERROR;
34190530:	2301      	movs	r3, #1
34190532:	e086      	b.n	34190642 <HAL_TIM_Base_Start_IT+0x126>
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
34190534:	687b      	ldr	r3, [r7, #4]
34190536:	2202      	movs	r2, #2
34190538:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

  /* Enable the TIM Update interrupt */
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
3419053c:	687b      	ldr	r3, [r7, #4]
3419053e:	681b      	ldr	r3, [r3, #0]
34190540:	68da      	ldr	r2, [r3, #12]
34190542:	687b      	ldr	r3, [r7, #4]
34190544:	681b      	ldr	r3, [r3, #0]
34190546:	f042 0201 	orr.w	r2, r2, #1
3419054a:	60da      	str	r2, [r3, #12]

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
3419054c:	687b      	ldr	r3, [r7, #4]
3419054e:	681b      	ldr	r3, [r3, #0]
34190550:	f1b3 4fa4 	cmp.w	r3, #1375731712	@ 0x52000000
34190554:	d054      	beq.n	34190600 <HAL_TIM_Base_Start_IT+0xe4>
34190556:	687b      	ldr	r3, [r7, #4]
34190558:	681b      	ldr	r3, [r3, #0]
3419055a:	f1b3 4f84 	cmp.w	r3, #1107296256	@ 0x42000000
3419055e:	d04f      	beq.n	34190600 <HAL_TIM_Base_Start_IT+0xe4>
34190560:	687b      	ldr	r3, [r7, #4]
34190562:	681b      	ldr	r3, [r3, #0]
34190564:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
34190568:	d04a      	beq.n	34190600 <HAL_TIM_Base_Start_IT+0xe4>
3419056a:	687b      	ldr	r3, [r7, #4]
3419056c:	681b      	ldr	r3, [r3, #0]
3419056e:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
34190572:	d045      	beq.n	34190600 <HAL_TIM_Base_Start_IT+0xe4>
34190574:	687b      	ldr	r3, [r7, #4]
34190576:	681b      	ldr	r3, [r3, #0]
34190578:	4a35      	ldr	r2, [pc, #212]	@ (34190650 <HAL_TIM_Base_Start_IT+0x134>)
3419057a:	4293      	cmp	r3, r2
3419057c:	d040      	beq.n	34190600 <HAL_TIM_Base_Start_IT+0xe4>
3419057e:	687b      	ldr	r3, [r7, #4]
34190580:	681b      	ldr	r3, [r3, #0]
34190582:	4a34      	ldr	r2, [pc, #208]	@ (34190654 <HAL_TIM_Base_Start_IT+0x138>)
34190584:	4293      	cmp	r3, r2
34190586:	d03b      	beq.n	34190600 <HAL_TIM_Base_Start_IT+0xe4>
34190588:	687b      	ldr	r3, [r7, #4]
3419058a:	681b      	ldr	r3, [r3, #0]
3419058c:	4a32      	ldr	r2, [pc, #200]	@ (34190658 <HAL_TIM_Base_Start_IT+0x13c>)
3419058e:	4293      	cmp	r3, r2
34190590:	d036      	beq.n	34190600 <HAL_TIM_Base_Start_IT+0xe4>
34190592:	687b      	ldr	r3, [r7, #4]
34190594:	681b      	ldr	r3, [r3, #0]
34190596:	4a31      	ldr	r2, [pc, #196]	@ (3419065c <HAL_TIM_Base_Start_IT+0x140>)
34190598:	4293      	cmp	r3, r2
3419059a:	d031      	beq.n	34190600 <HAL_TIM_Base_Start_IT+0xe4>
3419059c:	687b      	ldr	r3, [r7, #4]
3419059e:	681b      	ldr	r3, [r3, #0]
341905a0:	4a2f      	ldr	r2, [pc, #188]	@ (34190660 <HAL_TIM_Base_Start_IT+0x144>)
341905a2:	4293      	cmp	r3, r2
341905a4:	d02c      	beq.n	34190600 <HAL_TIM_Base_Start_IT+0xe4>
341905a6:	687b      	ldr	r3, [r7, #4]
341905a8:	681b      	ldr	r3, [r3, #0]
341905aa:	4a2e      	ldr	r2, [pc, #184]	@ (34190664 <HAL_TIM_Base_Start_IT+0x148>)
341905ac:	4293      	cmp	r3, r2
341905ae:	d027      	beq.n	34190600 <HAL_TIM_Base_Start_IT+0xe4>
341905b0:	687b      	ldr	r3, [r7, #4]
341905b2:	681b      	ldr	r3, [r3, #0]
341905b4:	4a2c      	ldr	r2, [pc, #176]	@ (34190668 <HAL_TIM_Base_Start_IT+0x14c>)
341905b6:	4293      	cmp	r3, r2
341905b8:	d022      	beq.n	34190600 <HAL_TIM_Base_Start_IT+0xe4>
341905ba:	687b      	ldr	r3, [r7, #4]
341905bc:	681b      	ldr	r3, [r3, #0]
341905be:	4a2b      	ldr	r2, [pc, #172]	@ (3419066c <HAL_TIM_Base_Start_IT+0x150>)
341905c0:	4293      	cmp	r3, r2
341905c2:	d01d      	beq.n	34190600 <HAL_TIM_Base_Start_IT+0xe4>
341905c4:	687b      	ldr	r3, [r7, #4]
341905c6:	681b      	ldr	r3, [r3, #0]
341905c8:	4a29      	ldr	r2, [pc, #164]	@ (34190670 <HAL_TIM_Base_Start_IT+0x154>)
341905ca:	4293      	cmp	r3, r2
341905cc:	d018      	beq.n	34190600 <HAL_TIM_Base_Start_IT+0xe4>
341905ce:	687b      	ldr	r3, [r7, #4]
341905d0:	681b      	ldr	r3, [r3, #0]
341905d2:	4a28      	ldr	r2, [pc, #160]	@ (34190674 <HAL_TIM_Base_Start_IT+0x158>)
341905d4:	4293      	cmp	r3, r2
341905d6:	d013      	beq.n	34190600 <HAL_TIM_Base_Start_IT+0xe4>
341905d8:	687b      	ldr	r3, [r7, #4]
341905da:	681b      	ldr	r3, [r3, #0]
341905dc:	4a26      	ldr	r2, [pc, #152]	@ (34190678 <HAL_TIM_Base_Start_IT+0x15c>)
341905de:	4293      	cmp	r3, r2
341905e0:	d00e      	beq.n	34190600 <HAL_TIM_Base_Start_IT+0xe4>
341905e2:	687b      	ldr	r3, [r7, #4]
341905e4:	681b      	ldr	r3, [r3, #0]
341905e6:	4a25      	ldr	r2, [pc, #148]	@ (3419067c <HAL_TIM_Base_Start_IT+0x160>)
341905e8:	4293      	cmp	r3, r2
341905ea:	d009      	beq.n	34190600 <HAL_TIM_Base_Start_IT+0xe4>
341905ec:	687b      	ldr	r3, [r7, #4]
341905ee:	681b      	ldr	r3, [r3, #0]
341905f0:	4a23      	ldr	r2, [pc, #140]	@ (34190680 <HAL_TIM_Base_Start_IT+0x164>)
341905f2:	4293      	cmp	r3, r2
341905f4:	d004      	beq.n	34190600 <HAL_TIM_Base_Start_IT+0xe4>
341905f6:	687b      	ldr	r3, [r7, #4]
341905f8:	681b      	ldr	r3, [r3, #0]
341905fa:	4a22      	ldr	r2, [pc, #136]	@ (34190684 <HAL_TIM_Base_Start_IT+0x168>)
341905fc:	4293      	cmp	r3, r2
341905fe:	d115      	bne.n	3419062c <HAL_TIM_Base_Start_IT+0x110>
  {
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
34190600:	687b      	ldr	r3, [r7, #4]
34190602:	681b      	ldr	r3, [r3, #0]
34190604:	689a      	ldr	r2, [r3, #8]
34190606:	4b20      	ldr	r3, [pc, #128]	@ (34190688 <HAL_TIM_Base_Start_IT+0x16c>)
34190608:	4013      	ands	r3, r2
3419060a:	60fb      	str	r3, [r7, #12]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
3419060c:	68fb      	ldr	r3, [r7, #12]
3419060e:	2b06      	cmp	r3, #6
34190610:	d015      	beq.n	3419063e <HAL_TIM_Base_Start_IT+0x122>
34190612:	68fb      	ldr	r3, [r7, #12]
34190614:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
34190618:	d011      	beq.n	3419063e <HAL_TIM_Base_Start_IT+0x122>
    {
      __HAL_TIM_ENABLE(htim);
3419061a:	687b      	ldr	r3, [r7, #4]
3419061c:	681b      	ldr	r3, [r3, #0]
3419061e:	681a      	ldr	r2, [r3, #0]
34190620:	687b      	ldr	r3, [r7, #4]
34190622:	681b      	ldr	r3, [r3, #0]
34190624:	f042 0201 	orr.w	r2, r2, #1
34190628:	601a      	str	r2, [r3, #0]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
3419062a:	e008      	b.n	3419063e <HAL_TIM_Base_Start_IT+0x122>
    }
  }
  else
  {
    __HAL_TIM_ENABLE(htim);
3419062c:	687b      	ldr	r3, [r7, #4]
3419062e:	681b      	ldr	r3, [r3, #0]
34190630:	681a      	ldr	r2, [r3, #0]
34190632:	687b      	ldr	r3, [r7, #4]
34190634:	681b      	ldr	r3, [r3, #0]
34190636:	f042 0201 	orr.w	r2, r2, #1
3419063a:	601a      	str	r2, [r3, #0]
3419063c:	e000      	b.n	34190640 <HAL_TIM_Base_Start_IT+0x124>
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
3419063e:	bf00      	nop
  }

  /* Return function status */
  return HAL_OK;
34190640:	2300      	movs	r3, #0
}
34190642:	4618      	mov	r0, r3
34190644:	3714      	adds	r7, #20
34190646:	46bd      	mov	sp, r7
34190648:	f85d 7b04 	ldr.w	r7, [sp], #4
3419064c:	4770      	bx	lr
3419064e:	bf00      	nop
34190650:	50000400 	.word	0x50000400
34190654:	40000400 	.word	0x40000400
34190658:	50000800 	.word	0x50000800
3419065c:	40000800 	.word	0x40000800
34190660:	50000c00 	.word	0x50000c00
34190664:	40000c00 	.word	0x40000c00
34190668:	52000400 	.word	0x52000400
3419066c:	42000400 	.word	0x42000400
34190670:	52004c00 	.word	0x52004c00
34190674:	42004c00 	.word	0x42004c00
34190678:	50001800 	.word	0x50001800
3419067c:	40001800 	.word	0x40001800
34190680:	52004000 	.word	0x52004000
34190684:	42004000 	.word	0x42004000
34190688:	00010007 	.word	0x00010007

3419068c <HAL_TIM_IRQHandler>:
  * @brief  This function handles TIM interrupts requests.
  * @param  htim TIM  handle
  * @retval None
  */
void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
{
3419068c:	b580      	push	{r7, lr}
3419068e:	b084      	sub	sp, #16
34190690:	af00      	add	r7, sp, #0
34190692:	6078      	str	r0, [r7, #4]
  uint32_t itsource = htim->Instance->DIER;
34190694:	687b      	ldr	r3, [r7, #4]
34190696:	681b      	ldr	r3, [r3, #0]
34190698:	68db      	ldr	r3, [r3, #12]
3419069a:	60fb      	str	r3, [r7, #12]
  uint32_t itflag   = htim->Instance->SR;
3419069c:	687b      	ldr	r3, [r7, #4]
3419069e:	681b      	ldr	r3, [r3, #0]
341906a0:	691b      	ldr	r3, [r3, #16]
341906a2:	60bb      	str	r3, [r7, #8]

  /* Capture compare 1 event */
  if ((itflag & (TIM_FLAG_CC1)) == (TIM_FLAG_CC1))
341906a4:	68bb      	ldr	r3, [r7, #8]
341906a6:	f003 0302 	and.w	r3, r3, #2
341906aa:	2b00      	cmp	r3, #0
341906ac:	d020      	beq.n	341906f0 <HAL_TIM_IRQHandler+0x64>
  {
    if ((itsource & (TIM_IT_CC1)) == (TIM_IT_CC1))
341906ae:	68fb      	ldr	r3, [r7, #12]
341906b0:	f003 0302 	and.w	r3, r3, #2
341906b4:	2b00      	cmp	r3, #0
341906b6:	d01b      	beq.n	341906f0 <HAL_TIM_IRQHandler+0x64>
    {
      {
        __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC1);
341906b8:	687b      	ldr	r3, [r7, #4]
341906ba:	681b      	ldr	r3, [r3, #0]
341906bc:	f06f 0202 	mvn.w	r2, #2
341906c0:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
341906c2:	687b      	ldr	r3, [r7, #4]
341906c4:	2201      	movs	r2, #1
341906c6:	771a      	strb	r2, [r3, #28]

        /* Input capture event */
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
341906c8:	687b      	ldr	r3, [r7, #4]
341906ca:	681b      	ldr	r3, [r3, #0]
341906cc:	699b      	ldr	r3, [r3, #24]
341906ce:	f003 0303 	and.w	r3, r3, #3
341906d2:	2b00      	cmp	r3, #0
341906d4:	d003      	beq.n	341906de <HAL_TIM_IRQHandler+0x52>
        {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
          htim->IC_CaptureCallback(htim);
#else
          HAL_TIM_IC_CaptureCallback(htim);
341906d6:	6878      	ldr	r0, [r7, #4]
341906d8:	f000 f931 	bl	3419093e <HAL_TIM_IC_CaptureCallback>
341906dc:	e005      	b.n	341906ea <HAL_TIM_IRQHandler+0x5e>
        {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
          htim->OC_DelayElapsedCallback(htim);
          htim->PWM_PulseFinishedCallback(htim);
#else
          HAL_TIM_OC_DelayElapsedCallback(htim);
341906de:	6878      	ldr	r0, [r7, #4]
341906e0:	f000 f923 	bl	3419092a <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
341906e4:	6878      	ldr	r0, [r7, #4]
341906e6:	f000 f934 	bl	34190952 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
        }
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
341906ea:	687b      	ldr	r3, [r7, #4]
341906ec:	2200      	movs	r2, #0
341906ee:	771a      	strb	r2, [r3, #28]
      }
    }
  }
  /* Capture compare 2 event */
  if ((itflag & (TIM_FLAG_CC2)) == (TIM_FLAG_CC2))
341906f0:	68bb      	ldr	r3, [r7, #8]
341906f2:	f003 0304 	and.w	r3, r3, #4
341906f6:	2b00      	cmp	r3, #0
341906f8:	d020      	beq.n	3419073c <HAL_TIM_IRQHandler+0xb0>
  {
    if ((itsource & (TIM_IT_CC2)) == (TIM_IT_CC2))
341906fa:	68fb      	ldr	r3, [r7, #12]
341906fc:	f003 0304 	and.w	r3, r3, #4
34190700:	2b00      	cmp	r3, #0
34190702:	d01b      	beq.n	3419073c <HAL_TIM_IRQHandler+0xb0>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC2);
34190704:	687b      	ldr	r3, [r7, #4]
34190706:	681b      	ldr	r3, [r3, #0]
34190708:	f06f 0204 	mvn.w	r2, #4
3419070c:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
3419070e:	687b      	ldr	r3, [r7, #4]
34190710:	2202      	movs	r2, #2
34190712:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
34190714:	687b      	ldr	r3, [r7, #4]
34190716:	681b      	ldr	r3, [r3, #0]
34190718:	699b      	ldr	r3, [r3, #24]
3419071a:	f403 7340 	and.w	r3, r3, #768	@ 0x300
3419071e:	2b00      	cmp	r3, #0
34190720:	d003      	beq.n	3419072a <HAL_TIM_IRQHandler+0x9e>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
34190722:	6878      	ldr	r0, [r7, #4]
34190724:	f000 f90b 	bl	3419093e <HAL_TIM_IC_CaptureCallback>
34190728:	e005      	b.n	34190736 <HAL_TIM_IRQHandler+0xaa>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
3419072a:	6878      	ldr	r0, [r7, #4]
3419072c:	f000 f8fd 	bl	3419092a <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
34190730:	6878      	ldr	r0, [r7, #4]
34190732:	f000 f90e 	bl	34190952 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
34190736:	687b      	ldr	r3, [r7, #4]
34190738:	2200      	movs	r2, #0
3419073a:	771a      	strb	r2, [r3, #28]
    }
  }
  /* Capture compare 3 event */
  if ((itflag & (TIM_FLAG_CC3)) == (TIM_FLAG_CC3))
3419073c:	68bb      	ldr	r3, [r7, #8]
3419073e:	f003 0308 	and.w	r3, r3, #8
34190742:	2b00      	cmp	r3, #0
34190744:	d020      	beq.n	34190788 <HAL_TIM_IRQHandler+0xfc>
  {
    if ((itsource & (TIM_IT_CC3)) == (TIM_IT_CC3))
34190746:	68fb      	ldr	r3, [r7, #12]
34190748:	f003 0308 	and.w	r3, r3, #8
3419074c:	2b00      	cmp	r3, #0
3419074e:	d01b      	beq.n	34190788 <HAL_TIM_IRQHandler+0xfc>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC3);
34190750:	687b      	ldr	r3, [r7, #4]
34190752:	681b      	ldr	r3, [r3, #0]
34190754:	f06f 0208 	mvn.w	r2, #8
34190758:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
3419075a:	687b      	ldr	r3, [r7, #4]
3419075c:	2204      	movs	r2, #4
3419075e:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
34190760:	687b      	ldr	r3, [r7, #4]
34190762:	681b      	ldr	r3, [r3, #0]
34190764:	69db      	ldr	r3, [r3, #28]
34190766:	f003 0303 	and.w	r3, r3, #3
3419076a:	2b00      	cmp	r3, #0
3419076c:	d003      	beq.n	34190776 <HAL_TIM_IRQHandler+0xea>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
3419076e:	6878      	ldr	r0, [r7, #4]
34190770:	f000 f8e5 	bl	3419093e <HAL_TIM_IC_CaptureCallback>
34190774:	e005      	b.n	34190782 <HAL_TIM_IRQHandler+0xf6>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
34190776:	6878      	ldr	r0, [r7, #4]
34190778:	f000 f8d7 	bl	3419092a <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
3419077c:	6878      	ldr	r0, [r7, #4]
3419077e:	f000 f8e8 	bl	34190952 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
34190782:	687b      	ldr	r3, [r7, #4]
34190784:	2200      	movs	r2, #0
34190786:	771a      	strb	r2, [r3, #28]
    }
  }
  /* Capture compare 4 event */
  if ((itflag & (TIM_FLAG_CC4)) == (TIM_FLAG_CC4))
34190788:	68bb      	ldr	r3, [r7, #8]
3419078a:	f003 0310 	and.w	r3, r3, #16
3419078e:	2b00      	cmp	r3, #0
34190790:	d020      	beq.n	341907d4 <HAL_TIM_IRQHandler+0x148>
  {
    if ((itsource & (TIM_IT_CC4)) == (TIM_IT_CC4))
34190792:	68fb      	ldr	r3, [r7, #12]
34190794:	f003 0310 	and.w	r3, r3, #16
34190798:	2b00      	cmp	r3, #0
3419079a:	d01b      	beq.n	341907d4 <HAL_TIM_IRQHandler+0x148>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC4);
3419079c:	687b      	ldr	r3, [r7, #4]
3419079e:	681b      	ldr	r3, [r3, #0]
341907a0:	f06f 0210 	mvn.w	r2, #16
341907a4:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
341907a6:	687b      	ldr	r3, [r7, #4]
341907a8:	2208      	movs	r2, #8
341907aa:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
341907ac:	687b      	ldr	r3, [r7, #4]
341907ae:	681b      	ldr	r3, [r3, #0]
341907b0:	69db      	ldr	r3, [r3, #28]
341907b2:	f403 7340 	and.w	r3, r3, #768	@ 0x300
341907b6:	2b00      	cmp	r3, #0
341907b8:	d003      	beq.n	341907c2 <HAL_TIM_IRQHandler+0x136>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
341907ba:	6878      	ldr	r0, [r7, #4]
341907bc:	f000 f8bf 	bl	3419093e <HAL_TIM_IC_CaptureCallback>
341907c0:	e005      	b.n	341907ce <HAL_TIM_IRQHandler+0x142>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
341907c2:	6878      	ldr	r0, [r7, #4]
341907c4:	f000 f8b1 	bl	3419092a <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
341907c8:	6878      	ldr	r0, [r7, #4]
341907ca:	f000 f8c2 	bl	34190952 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
341907ce:	687b      	ldr	r3, [r7, #4]
341907d0:	2200      	movs	r2, #0
341907d2:	771a      	strb	r2, [r3, #28]
    }
  }
  /* TIM Update event */
  if ((itflag & (TIM_FLAG_UPDATE)) == (TIM_FLAG_UPDATE))
341907d4:	68bb      	ldr	r3, [r7, #8]
341907d6:	f003 0301 	and.w	r3, r3, #1
341907da:	2b00      	cmp	r3, #0
341907dc:	d00c      	beq.n	341907f8 <HAL_TIM_IRQHandler+0x16c>
  {
    if ((itsource & (TIM_IT_UPDATE)) == (TIM_IT_UPDATE))
341907de:	68fb      	ldr	r3, [r7, #12]
341907e0:	f003 0301 	and.w	r3, r3, #1
341907e4:	2b00      	cmp	r3, #0
341907e6:	d007      	beq.n	341907f8 <HAL_TIM_IRQHandler+0x16c>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_UPDATE);
341907e8:	687b      	ldr	r3, [r7, #4]
341907ea:	681b      	ldr	r3, [r3, #0]
341907ec:	f06f 0201 	mvn.w	r2, #1
341907f0:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->PeriodElapsedCallback(htim);
#else
      HAL_TIM_PeriodElapsedCallback(htim);
341907f2:	6878      	ldr	r0, [r7, #4]
341907f4:	f7f0 fed2 	bl	3418159c <HAL_TIM_PeriodElapsedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Break input event */
  if (((itflag & (TIM_FLAG_BREAK)) == (TIM_FLAG_BREAK)) || \
341907f8:	68bb      	ldr	r3, [r7, #8]
341907fa:	f003 0380 	and.w	r3, r3, #128	@ 0x80
341907fe:	2b00      	cmp	r3, #0
34190800:	d104      	bne.n	3419080c <HAL_TIM_IRQHandler+0x180>
      ((itflag & (TIM_FLAG_SYSTEM_BREAK)) == (TIM_FLAG_SYSTEM_BREAK)))
34190802:	68bb      	ldr	r3, [r7, #8]
34190804:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
  if (((itflag & (TIM_FLAG_BREAK)) == (TIM_FLAG_BREAK)) || \
34190808:	2b00      	cmp	r3, #0
3419080a:	d00c      	beq.n	34190826 <HAL_TIM_IRQHandler+0x19a>
  {
    if ((itsource & (TIM_IT_BREAK)) == (TIM_IT_BREAK))
3419080c:	68fb      	ldr	r3, [r7, #12]
3419080e:	f003 0380 	and.w	r3, r3, #128	@ 0x80
34190812:	2b00      	cmp	r3, #0
34190814:	d007      	beq.n	34190826 <HAL_TIM_IRQHandler+0x19a>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK | TIM_FLAG_SYSTEM_BREAK);
34190816:	687b      	ldr	r3, [r7, #4]
34190818:	681b      	ldr	r3, [r3, #0]
3419081a:	f46f 5202 	mvn.w	r2, #8320	@ 0x2080
3419081e:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->BreakCallback(htim);
#else
      HAL_TIMEx_BreakCallback(htim);
34190820:	6878      	ldr	r0, [r7, #4]
34190822:	f000 f9c9 	bl	34190bb8 <HAL_TIMEx_BreakCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Break2 input event */
  if ((itflag & (TIM_FLAG_BREAK2)) == (TIM_FLAG_BREAK2))
34190826:	68bb      	ldr	r3, [r7, #8]
34190828:	f403 7380 	and.w	r3, r3, #256	@ 0x100
3419082c:	2b00      	cmp	r3, #0
3419082e:	d00c      	beq.n	3419084a <HAL_TIM_IRQHandler+0x1be>
  {
    if ((itsource & (TIM_IT_BREAK)) == (TIM_IT_BREAK))
34190830:	68fb      	ldr	r3, [r7, #12]
34190832:	f003 0380 	and.w	r3, r3, #128	@ 0x80
34190836:	2b00      	cmp	r3, #0
34190838:	d007      	beq.n	3419084a <HAL_TIM_IRQHandler+0x1be>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
3419083a:	687b      	ldr	r3, [r7, #4]
3419083c:	681b      	ldr	r3, [r3, #0]
3419083e:	f46f 7280 	mvn.w	r2, #256	@ 0x100
34190842:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->Break2Callback(htim);
#else
      HAL_TIMEx_Break2Callback(htim);
34190844:	6878      	ldr	r0, [r7, #4]
34190846:	f000 f9c1 	bl	34190bcc <HAL_TIMEx_Break2Callback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Trigger detection event */
  if ((itflag & (TIM_FLAG_TRIGGER)) == (TIM_FLAG_TRIGGER))
3419084a:	68bb      	ldr	r3, [r7, #8]
3419084c:	f003 0340 	and.w	r3, r3, #64	@ 0x40
34190850:	2b00      	cmp	r3, #0
34190852:	d00c      	beq.n	3419086e <HAL_TIM_IRQHandler+0x1e2>
  {
    if ((itsource & (TIM_IT_TRIGGER)) == (TIM_IT_TRIGGER))
34190854:	68fb      	ldr	r3, [r7, #12]
34190856:	f003 0340 	and.w	r3, r3, #64	@ 0x40
3419085a:	2b00      	cmp	r3, #0
3419085c:	d007      	beq.n	3419086e <HAL_TIM_IRQHandler+0x1e2>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_TRIGGER);
3419085e:	687b      	ldr	r3, [r7, #4]
34190860:	681b      	ldr	r3, [r3, #0]
34190862:	f06f 0240 	mvn.w	r2, #64	@ 0x40
34190866:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->TriggerCallback(htim);
#else
      HAL_TIM_TriggerCallback(htim);
34190868:	6878      	ldr	r0, [r7, #4]
3419086a:	f000 f87c 	bl	34190966 <HAL_TIM_TriggerCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM commutation event */
  if ((itflag & (TIM_FLAG_COM)) == (TIM_FLAG_COM))
3419086e:	68bb      	ldr	r3, [r7, #8]
34190870:	f003 0320 	and.w	r3, r3, #32
34190874:	2b00      	cmp	r3, #0
34190876:	d00c      	beq.n	34190892 <HAL_TIM_IRQHandler+0x206>
  {
    if ((itsource & (TIM_IT_COM)) == (TIM_IT_COM))
34190878:	68fb      	ldr	r3, [r7, #12]
3419087a:	f003 0320 	and.w	r3, r3, #32
3419087e:	2b00      	cmp	r3, #0
34190880:	d007      	beq.n	34190892 <HAL_TIM_IRQHandler+0x206>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_COM);
34190882:	687b      	ldr	r3, [r7, #4]
34190884:	681b      	ldr	r3, [r3, #0]
34190886:	f06f 0220 	mvn.w	r2, #32
3419088a:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->CommutationCallback(htim);
#else
      HAL_TIMEx_CommutCallback(htim);
3419088c:	6878      	ldr	r0, [r7, #4]
3419088e:	f000 f989 	bl	34190ba4 <HAL_TIMEx_CommutCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Encoder index event */
  if ((itflag & (TIM_FLAG_IDX)) == (TIM_FLAG_IDX))
34190892:	68bb      	ldr	r3, [r7, #8]
34190894:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
34190898:	2b00      	cmp	r3, #0
3419089a:	d00c      	beq.n	341908b6 <HAL_TIM_IRQHandler+0x22a>
  {
    if ((itsource & (TIM_IT_IDX)) == (TIM_IT_IDX))
3419089c:	68fb      	ldr	r3, [r7, #12]
3419089e:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
341908a2:	2b00      	cmp	r3, #0
341908a4:	d007      	beq.n	341908b6 <HAL_TIM_IRQHandler+0x22a>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_IDX);
341908a6:	687b      	ldr	r3, [r7, #4]
341908a8:	681b      	ldr	r3, [r3, #0]
341908aa:	f46f 1280 	mvn.w	r2, #1048576	@ 0x100000
341908ae:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->EncoderIndexCallback(htim);
#else
      HAL_TIMEx_EncoderIndexCallback(htim);
341908b0:	6878      	ldr	r0, [r7, #4]
341908b2:	f000 f995 	bl	34190be0 <HAL_TIMEx_EncoderIndexCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Direction change event */
  if ((itflag & (TIM_FLAG_DIR)) == (TIM_FLAG_DIR))
341908b6:	68bb      	ldr	r3, [r7, #8]
341908b8:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
341908bc:	2b00      	cmp	r3, #0
341908be:	d00c      	beq.n	341908da <HAL_TIM_IRQHandler+0x24e>
  {
    if ((itsource & (TIM_IT_DIR)) == (TIM_IT_DIR))
341908c0:	68fb      	ldr	r3, [r7, #12]
341908c2:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
341908c6:	2b00      	cmp	r3, #0
341908c8:	d007      	beq.n	341908da <HAL_TIM_IRQHandler+0x24e>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_DIR);
341908ca:	687b      	ldr	r3, [r7, #4]
341908cc:	681b      	ldr	r3, [r3, #0]
341908ce:	f46f 1200 	mvn.w	r2, #2097152	@ 0x200000
341908d2:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->DirectionChangeCallback(htim);
#else
      HAL_TIMEx_DirectionChangeCallback(htim);
341908d4:	6878      	ldr	r0, [r7, #4]
341908d6:	f000 f98d 	bl	34190bf4 <HAL_TIMEx_DirectionChangeCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Index error event */
  if ((itflag & (TIM_FLAG_IERR)) == (TIM_FLAG_IERR))
341908da:	68bb      	ldr	r3, [r7, #8]
341908dc:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
341908e0:	2b00      	cmp	r3, #0
341908e2:	d00c      	beq.n	341908fe <HAL_TIM_IRQHandler+0x272>
  {
    if ((itsource & (TIM_IT_IERR)) == (TIM_IT_IERR))
341908e4:	68fb      	ldr	r3, [r7, #12]
341908e6:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
341908ea:	2b00      	cmp	r3, #0
341908ec:	d007      	beq.n	341908fe <HAL_TIM_IRQHandler+0x272>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_IERR);
341908ee:	687b      	ldr	r3, [r7, #4]
341908f0:	681b      	ldr	r3, [r3, #0]
341908f2:	f46f 0280 	mvn.w	r2, #4194304	@ 0x400000
341908f6:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->IndexErrorCallback(htim);
#else
      HAL_TIMEx_IndexErrorCallback(htim);
341908f8:	6878      	ldr	r0, [r7, #4]
341908fa:	f000 f985 	bl	34190c08 <HAL_TIMEx_IndexErrorCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Transition error event */
  if ((itflag & (TIM_FLAG_TERR)) == (TIM_FLAG_TERR))
341908fe:	68bb      	ldr	r3, [r7, #8]
34190900:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
34190904:	2b00      	cmp	r3, #0
34190906:	d00c      	beq.n	34190922 <HAL_TIM_IRQHandler+0x296>
  {
    if ((itsource & (TIM_IT_TERR)) == (TIM_IT_TERR))
34190908:	68fb      	ldr	r3, [r7, #12]
3419090a:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
3419090e:	2b00      	cmp	r3, #0
34190910:	d007      	beq.n	34190922 <HAL_TIM_IRQHandler+0x296>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_TERR);
34190912:	687b      	ldr	r3, [r7, #4]
34190914:	681b      	ldr	r3, [r3, #0]
34190916:	f46f 0200 	mvn.w	r2, #8388608	@ 0x800000
3419091a:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->TransitionErrorCallback(htim);
#else
      HAL_TIMEx_TransitionErrorCallback(htim);
3419091c:	6878      	ldr	r0, [r7, #4]
3419091e:	f000 f97d 	bl	34190c1c <HAL_TIMEx_TransitionErrorCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
}
34190922:	bf00      	nop
34190924:	3710      	adds	r7, #16
34190926:	46bd      	mov	sp, r7
34190928:	bd80      	pop	{r7, pc}

3419092a <HAL_TIM_OC_DelayElapsedCallback>:
  * @brief  Output Compare callback in non-blocking mode
  * @param  htim TIM OC handle
  * @retval None
  */
__weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
{
3419092a:	b480      	push	{r7}
3419092c:	b083      	sub	sp, #12
3419092e:	af00      	add	r7, sp, #0
34190930:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
   */
}
34190932:	bf00      	nop
34190934:	370c      	adds	r7, #12
34190936:	46bd      	mov	sp, r7
34190938:	f85d 7b04 	ldr.w	r7, [sp], #4
3419093c:	4770      	bx	lr

3419093e <HAL_TIM_IC_CaptureCallback>:
  * @brief  Input Capture callback in non-blocking mode
  * @param  htim TIM IC handle
  * @retval None
  */
__weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
3419093e:	b480      	push	{r7}
34190940:	b083      	sub	sp, #12
34190942:	af00      	add	r7, sp, #0
34190944:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_IC_CaptureCallback could be implemented in the user file
   */
}
34190946:	bf00      	nop
34190948:	370c      	adds	r7, #12
3419094a:	46bd      	mov	sp, r7
3419094c:	f85d 7b04 	ldr.w	r7, [sp], #4
34190950:	4770      	bx	lr

34190952 <HAL_TIM_PWM_PulseFinishedCallback>:
  * @brief  PWM Pulse finished callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
{
34190952:	b480      	push	{r7}
34190954:	b083      	sub	sp, #12
34190956:	af00      	add	r7, sp, #0
34190958:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
   */
}
3419095a:	bf00      	nop
3419095c:	370c      	adds	r7, #12
3419095e:	46bd      	mov	sp, r7
34190960:	f85d 7b04 	ldr.w	r7, [sp], #4
34190964:	4770      	bx	lr

34190966 <HAL_TIM_TriggerCallback>:
  * @brief  Hall Trigger detection callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
{
34190966:	b480      	push	{r7}
34190968:	b083      	sub	sp, #12
3419096a:	af00      	add	r7, sp, #0
3419096c:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_TriggerCallback could be implemented in the user file
   */
}
3419096e:	bf00      	nop
34190970:	370c      	adds	r7, #12
34190972:	46bd      	mov	sp, r7
34190974:	f85d 7b04 	ldr.w	r7, [sp], #4
34190978:	4770      	bx	lr
	...

3419097c <TIM_Base_SetConfig>:
  * @param  TIMx TIM peripheral
  * @param  Structure TIM Base configuration structure
  * @retval None
  */
void TIM_Base_SetConfig(TIM_TypeDef *TIMx, const TIM_Base_InitTypeDef *Structure)
{
3419097c:	b480      	push	{r7}
3419097e:	b085      	sub	sp, #20
34190980:	af00      	add	r7, sp, #0
34190982:	6078      	str	r0, [r7, #4]
34190984:	6039      	str	r1, [r7, #0]
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;
34190986:	687b      	ldr	r3, [r7, #4]
34190988:	681b      	ldr	r3, [r3, #0]
3419098a:	60fb      	str	r3, [r7, #12]

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
3419098c:	687b      	ldr	r3, [r7, #4]
3419098e:	f1b3 4fa4 	cmp.w	r3, #1375731712	@ 0x52000000
34190992:	d02b      	beq.n	341909ec <TIM_Base_SetConfig+0x70>
34190994:	687b      	ldr	r3, [r7, #4]
34190996:	f1b3 4f84 	cmp.w	r3, #1107296256	@ 0x42000000
3419099a:	d027      	beq.n	341909ec <TIM_Base_SetConfig+0x70>
3419099c:	687b      	ldr	r3, [r7, #4]
3419099e:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
341909a2:	d023      	beq.n	341909ec <TIM_Base_SetConfig+0x70>
341909a4:	687b      	ldr	r3, [r7, #4]
341909a6:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
341909aa:	d01f      	beq.n	341909ec <TIM_Base_SetConfig+0x70>
341909ac:	687b      	ldr	r3, [r7, #4]
341909ae:	4a6b      	ldr	r2, [pc, #428]	@ (34190b5c <TIM_Base_SetConfig+0x1e0>)
341909b0:	4293      	cmp	r3, r2
341909b2:	d01b      	beq.n	341909ec <TIM_Base_SetConfig+0x70>
341909b4:	687b      	ldr	r3, [r7, #4]
341909b6:	4a6a      	ldr	r2, [pc, #424]	@ (34190b60 <TIM_Base_SetConfig+0x1e4>)
341909b8:	4293      	cmp	r3, r2
341909ba:	d017      	beq.n	341909ec <TIM_Base_SetConfig+0x70>
341909bc:	687b      	ldr	r3, [r7, #4]
341909be:	4a69      	ldr	r2, [pc, #420]	@ (34190b64 <TIM_Base_SetConfig+0x1e8>)
341909c0:	4293      	cmp	r3, r2
341909c2:	d013      	beq.n	341909ec <TIM_Base_SetConfig+0x70>
341909c4:	687b      	ldr	r3, [r7, #4]
341909c6:	4a68      	ldr	r2, [pc, #416]	@ (34190b68 <TIM_Base_SetConfig+0x1ec>)
341909c8:	4293      	cmp	r3, r2
341909ca:	d00f      	beq.n	341909ec <TIM_Base_SetConfig+0x70>
341909cc:	687b      	ldr	r3, [r7, #4]
341909ce:	4a67      	ldr	r2, [pc, #412]	@ (34190b6c <TIM_Base_SetConfig+0x1f0>)
341909d0:	4293      	cmp	r3, r2
341909d2:	d00b      	beq.n	341909ec <TIM_Base_SetConfig+0x70>
341909d4:	687b      	ldr	r3, [r7, #4]
341909d6:	4a66      	ldr	r2, [pc, #408]	@ (34190b70 <TIM_Base_SetConfig+0x1f4>)
341909d8:	4293      	cmp	r3, r2
341909da:	d007      	beq.n	341909ec <TIM_Base_SetConfig+0x70>
341909dc:	687b      	ldr	r3, [r7, #4]
341909de:	4a65      	ldr	r2, [pc, #404]	@ (34190b74 <TIM_Base_SetConfig+0x1f8>)
341909e0:	4293      	cmp	r3, r2
341909e2:	d003      	beq.n	341909ec <TIM_Base_SetConfig+0x70>
341909e4:	687b      	ldr	r3, [r7, #4]
341909e6:	4a64      	ldr	r2, [pc, #400]	@ (34190b78 <TIM_Base_SetConfig+0x1fc>)
341909e8:	4293      	cmp	r3, r2
341909ea:	d108      	bne.n	341909fe <TIM_Base_SetConfig+0x82>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
341909ec:	68fb      	ldr	r3, [r7, #12]
341909ee:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
341909f2:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= Structure->CounterMode;
341909f4:	683b      	ldr	r3, [r7, #0]
341909f6:	685b      	ldr	r3, [r3, #4]
341909f8:	68fa      	ldr	r2, [r7, #12]
341909fa:	4313      	orrs	r3, r2
341909fc:	60fb      	str	r3, [r7, #12]
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
341909fe:	687b      	ldr	r3, [r7, #4]
34190a00:	f1b3 4fa4 	cmp.w	r3, #1375731712	@ 0x52000000
34190a04:	d053      	beq.n	34190aae <TIM_Base_SetConfig+0x132>
34190a06:	687b      	ldr	r3, [r7, #4]
34190a08:	f1b3 4f84 	cmp.w	r3, #1107296256	@ 0x42000000
34190a0c:	d04f      	beq.n	34190aae <TIM_Base_SetConfig+0x132>
34190a0e:	687b      	ldr	r3, [r7, #4]
34190a10:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
34190a14:	d04b      	beq.n	34190aae <TIM_Base_SetConfig+0x132>
34190a16:	687b      	ldr	r3, [r7, #4]
34190a18:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
34190a1c:	d047      	beq.n	34190aae <TIM_Base_SetConfig+0x132>
34190a1e:	687b      	ldr	r3, [r7, #4]
34190a20:	4a4e      	ldr	r2, [pc, #312]	@ (34190b5c <TIM_Base_SetConfig+0x1e0>)
34190a22:	4293      	cmp	r3, r2
34190a24:	d043      	beq.n	34190aae <TIM_Base_SetConfig+0x132>
34190a26:	687b      	ldr	r3, [r7, #4]
34190a28:	4a4d      	ldr	r2, [pc, #308]	@ (34190b60 <TIM_Base_SetConfig+0x1e4>)
34190a2a:	4293      	cmp	r3, r2
34190a2c:	d03f      	beq.n	34190aae <TIM_Base_SetConfig+0x132>
34190a2e:	687b      	ldr	r3, [r7, #4]
34190a30:	4a4c      	ldr	r2, [pc, #304]	@ (34190b64 <TIM_Base_SetConfig+0x1e8>)
34190a32:	4293      	cmp	r3, r2
34190a34:	d03b      	beq.n	34190aae <TIM_Base_SetConfig+0x132>
34190a36:	687b      	ldr	r3, [r7, #4]
34190a38:	4a4b      	ldr	r2, [pc, #300]	@ (34190b68 <TIM_Base_SetConfig+0x1ec>)
34190a3a:	4293      	cmp	r3, r2
34190a3c:	d037      	beq.n	34190aae <TIM_Base_SetConfig+0x132>
34190a3e:	687b      	ldr	r3, [r7, #4]
34190a40:	4a4a      	ldr	r2, [pc, #296]	@ (34190b6c <TIM_Base_SetConfig+0x1f0>)
34190a42:	4293      	cmp	r3, r2
34190a44:	d033      	beq.n	34190aae <TIM_Base_SetConfig+0x132>
34190a46:	687b      	ldr	r3, [r7, #4]
34190a48:	4a49      	ldr	r2, [pc, #292]	@ (34190b70 <TIM_Base_SetConfig+0x1f4>)
34190a4a:	4293      	cmp	r3, r2
34190a4c:	d02f      	beq.n	34190aae <TIM_Base_SetConfig+0x132>
34190a4e:	687b      	ldr	r3, [r7, #4]
34190a50:	4a48      	ldr	r2, [pc, #288]	@ (34190b74 <TIM_Base_SetConfig+0x1f8>)
34190a52:	4293      	cmp	r3, r2
34190a54:	d02b      	beq.n	34190aae <TIM_Base_SetConfig+0x132>
34190a56:	687b      	ldr	r3, [r7, #4]
34190a58:	4a47      	ldr	r2, [pc, #284]	@ (34190b78 <TIM_Base_SetConfig+0x1fc>)
34190a5a:	4293      	cmp	r3, r2
34190a5c:	d027      	beq.n	34190aae <TIM_Base_SetConfig+0x132>
34190a5e:	687b      	ldr	r3, [r7, #4]
34190a60:	4a46      	ldr	r2, [pc, #280]	@ (34190b7c <TIM_Base_SetConfig+0x200>)
34190a62:	4293      	cmp	r3, r2
34190a64:	d023      	beq.n	34190aae <TIM_Base_SetConfig+0x132>
34190a66:	687b      	ldr	r3, [r7, #4]
34190a68:	4a45      	ldr	r2, [pc, #276]	@ (34190b80 <TIM_Base_SetConfig+0x204>)
34190a6a:	4293      	cmp	r3, r2
34190a6c:	d01f      	beq.n	34190aae <TIM_Base_SetConfig+0x132>
34190a6e:	687b      	ldr	r3, [r7, #4]
34190a70:	4a44      	ldr	r2, [pc, #272]	@ (34190b84 <TIM_Base_SetConfig+0x208>)
34190a72:	4293      	cmp	r3, r2
34190a74:	d01b      	beq.n	34190aae <TIM_Base_SetConfig+0x132>
34190a76:	687b      	ldr	r3, [r7, #4]
34190a78:	4a43      	ldr	r2, [pc, #268]	@ (34190b88 <TIM_Base_SetConfig+0x20c>)
34190a7a:	4293      	cmp	r3, r2
34190a7c:	d017      	beq.n	34190aae <TIM_Base_SetConfig+0x132>
34190a7e:	687b      	ldr	r3, [r7, #4]
34190a80:	4a42      	ldr	r2, [pc, #264]	@ (34190b8c <TIM_Base_SetConfig+0x210>)
34190a82:	4293      	cmp	r3, r2
34190a84:	d013      	beq.n	34190aae <TIM_Base_SetConfig+0x132>
34190a86:	687b      	ldr	r3, [r7, #4]
34190a88:	4a41      	ldr	r2, [pc, #260]	@ (34190b90 <TIM_Base_SetConfig+0x214>)
34190a8a:	4293      	cmp	r3, r2
34190a8c:	d00f      	beq.n	34190aae <TIM_Base_SetConfig+0x132>
34190a8e:	687b      	ldr	r3, [r7, #4]
34190a90:	4a40      	ldr	r2, [pc, #256]	@ (34190b94 <TIM_Base_SetConfig+0x218>)
34190a92:	4293      	cmp	r3, r2
34190a94:	d00b      	beq.n	34190aae <TIM_Base_SetConfig+0x132>
34190a96:	687b      	ldr	r3, [r7, #4]
34190a98:	4a3f      	ldr	r2, [pc, #252]	@ (34190b98 <TIM_Base_SetConfig+0x21c>)
34190a9a:	4293      	cmp	r3, r2
34190a9c:	d007      	beq.n	34190aae <TIM_Base_SetConfig+0x132>
34190a9e:	687b      	ldr	r3, [r7, #4]
34190aa0:	4a3e      	ldr	r2, [pc, #248]	@ (34190b9c <TIM_Base_SetConfig+0x220>)
34190aa2:	4293      	cmp	r3, r2
34190aa4:	d003      	beq.n	34190aae <TIM_Base_SetConfig+0x132>
34190aa6:	687b      	ldr	r3, [r7, #4]
34190aa8:	4a3d      	ldr	r2, [pc, #244]	@ (34190ba0 <TIM_Base_SetConfig+0x224>)
34190aaa:	4293      	cmp	r3, r2
34190aac:	d108      	bne.n	34190ac0 <TIM_Base_SetConfig+0x144>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
34190aae:	68fb      	ldr	r3, [r7, #12]
34190ab0:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
34190ab4:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
34190ab6:	683b      	ldr	r3, [r7, #0]
34190ab8:	68db      	ldr	r3, [r3, #12]
34190aba:	68fa      	ldr	r2, [r7, #12]
34190abc:	4313      	orrs	r3, r2
34190abe:	60fb      	str	r3, [r7, #12]
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
34190ac0:	68fb      	ldr	r3, [r7, #12]
34190ac2:	f023 0280 	bic.w	r2, r3, #128	@ 0x80
34190ac6:	683b      	ldr	r3, [r7, #0]
34190ac8:	695b      	ldr	r3, [r3, #20]
34190aca:	4313      	orrs	r3, r2
34190acc:	60fb      	str	r3, [r7, #12]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
34190ace:	683b      	ldr	r3, [r7, #0]
34190ad0:	689a      	ldr	r2, [r3, #8]
34190ad2:	687b      	ldr	r3, [r7, #4]
34190ad4:	62da      	str	r2, [r3, #44]	@ 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
34190ad6:	683b      	ldr	r3, [r7, #0]
34190ad8:	681a      	ldr	r2, [r3, #0]
34190ada:	687b      	ldr	r3, [r7, #4]
34190adc:	629a      	str	r2, [r3, #40]	@ 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
34190ade:	687b      	ldr	r3, [r7, #4]
34190ae0:	f1b3 4fa4 	cmp.w	r3, #1375731712	@ 0x52000000
34190ae4:	d023      	beq.n	34190b2e <TIM_Base_SetConfig+0x1b2>
34190ae6:	687b      	ldr	r3, [r7, #4]
34190ae8:	f1b3 4f84 	cmp.w	r3, #1107296256	@ 0x42000000
34190aec:	d01f      	beq.n	34190b2e <TIM_Base_SetConfig+0x1b2>
34190aee:	687b      	ldr	r3, [r7, #4]
34190af0:	4a20      	ldr	r2, [pc, #128]	@ (34190b74 <TIM_Base_SetConfig+0x1f8>)
34190af2:	4293      	cmp	r3, r2
34190af4:	d01b      	beq.n	34190b2e <TIM_Base_SetConfig+0x1b2>
34190af6:	687b      	ldr	r3, [r7, #4]
34190af8:	4a1f      	ldr	r2, [pc, #124]	@ (34190b78 <TIM_Base_SetConfig+0x1fc>)
34190afa:	4293      	cmp	r3, r2
34190afc:	d017      	beq.n	34190b2e <TIM_Base_SetConfig+0x1b2>
34190afe:	687b      	ldr	r3, [r7, #4]
34190b00:	4a22      	ldr	r2, [pc, #136]	@ (34190b8c <TIM_Base_SetConfig+0x210>)
34190b02:	4293      	cmp	r3, r2
34190b04:	d013      	beq.n	34190b2e <TIM_Base_SetConfig+0x1b2>
34190b06:	687b      	ldr	r3, [r7, #4]
34190b08:	4a21      	ldr	r2, [pc, #132]	@ (34190b90 <TIM_Base_SetConfig+0x214>)
34190b0a:	4293      	cmp	r3, r2
34190b0c:	d00f      	beq.n	34190b2e <TIM_Base_SetConfig+0x1b2>
34190b0e:	687b      	ldr	r3, [r7, #4]
34190b10:	4a20      	ldr	r2, [pc, #128]	@ (34190b94 <TIM_Base_SetConfig+0x218>)
34190b12:	4293      	cmp	r3, r2
34190b14:	d00b      	beq.n	34190b2e <TIM_Base_SetConfig+0x1b2>
34190b16:	687b      	ldr	r3, [r7, #4]
34190b18:	4a1f      	ldr	r2, [pc, #124]	@ (34190b98 <TIM_Base_SetConfig+0x21c>)
34190b1a:	4293      	cmp	r3, r2
34190b1c:	d007      	beq.n	34190b2e <TIM_Base_SetConfig+0x1b2>
34190b1e:	687b      	ldr	r3, [r7, #4]
34190b20:	4a1e      	ldr	r2, [pc, #120]	@ (34190b9c <TIM_Base_SetConfig+0x220>)
34190b22:	4293      	cmp	r3, r2
34190b24:	d003      	beq.n	34190b2e <TIM_Base_SetConfig+0x1b2>
34190b26:	687b      	ldr	r3, [r7, #4]
34190b28:	4a1d      	ldr	r2, [pc, #116]	@ (34190ba0 <TIM_Base_SetConfig+0x224>)
34190b2a:	4293      	cmp	r3, r2
34190b2c:	d103      	bne.n	34190b36 <TIM_Base_SetConfig+0x1ba>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
34190b2e:	683b      	ldr	r3, [r7, #0]
34190b30:	691a      	ldr	r2, [r3, #16]
34190b32:	687b      	ldr	r3, [r7, #4]
34190b34:	631a      	str	r2, [r3, #48]	@ 0x30
  }

  /* Disable Update Event (UEV) with Update Generation (UG)
     by changing Update Request Source (URS) to avoid Update flag (UIF) */
  SET_BIT(TIMx->CR1, TIM_CR1_URS);
34190b36:	687b      	ldr	r3, [r7, #4]
34190b38:	681b      	ldr	r3, [r3, #0]
34190b3a:	f043 0204 	orr.w	r2, r3, #4
34190b3e:	687b      	ldr	r3, [r7, #4]
34190b40:	601a      	str	r2, [r3, #0]

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
34190b42:	687b      	ldr	r3, [r7, #4]
34190b44:	2201      	movs	r2, #1
34190b46:	615a      	str	r2, [r3, #20]

  TIMx->CR1 = tmpcr1;
34190b48:	687b      	ldr	r3, [r7, #4]
34190b4a:	68fa      	ldr	r2, [r7, #12]
34190b4c:	601a      	str	r2, [r3, #0]
}
34190b4e:	bf00      	nop
34190b50:	3714      	adds	r7, #20
34190b52:	46bd      	mov	sp, r7
34190b54:	f85d 7b04 	ldr.w	r7, [sp], #4
34190b58:	4770      	bx	lr
34190b5a:	bf00      	nop
34190b5c:	50000400 	.word	0x50000400
34190b60:	40000400 	.word	0x40000400
34190b64:	50000800 	.word	0x50000800
34190b68:	40000800 	.word	0x40000800
34190b6c:	50000c00 	.word	0x50000c00
34190b70:	40000c00 	.word	0x40000c00
34190b74:	52000400 	.word	0x52000400
34190b78:	42000400 	.word	0x42000400
34190b7c:	52004c00 	.word	0x52004c00
34190b80:	42004c00 	.word	0x42004c00
34190b84:	50001800 	.word	0x50001800
34190b88:	40001800 	.word	0x40001800
34190b8c:	52004000 	.word	0x52004000
34190b90:	42004000 	.word	0x42004000
34190b94:	52004400 	.word	0x52004400
34190b98:	42004400 	.word	0x42004400
34190b9c:	52004800 	.word	0x52004800
34190ba0:	42004800 	.word	0x42004800

34190ba4 <HAL_TIMEx_CommutCallback>:
  * @brief  Commutation callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_CommutCallback(TIM_HandleTypeDef *htim)
{
34190ba4:	b480      	push	{r7}
34190ba6:	b083      	sub	sp, #12
34190ba8:	af00      	add	r7, sp, #0
34190baa:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_CommutCallback could be implemented in the user file
   */
}
34190bac:	bf00      	nop
34190bae:	370c      	adds	r7, #12
34190bb0:	46bd      	mov	sp, r7
34190bb2:	f85d 7b04 	ldr.w	r7, [sp], #4
34190bb6:	4770      	bx	lr

34190bb8 <HAL_TIMEx_BreakCallback>:
  * @brief  Break detection callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)
{
34190bb8:	b480      	push	{r7}
34190bba:	b083      	sub	sp, #12
34190bbc:	af00      	add	r7, sp, #0
34190bbe:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_BreakCallback could be implemented in the user file
   */
}
34190bc0:	bf00      	nop
34190bc2:	370c      	adds	r7, #12
34190bc4:	46bd      	mov	sp, r7
34190bc6:	f85d 7b04 	ldr.w	r7, [sp], #4
34190bca:	4770      	bx	lr

34190bcc <HAL_TIMEx_Break2Callback>:
  * @brief  Break2 detection callback in non blocking mode
  * @param  htim: TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_Break2Callback(TIM_HandleTypeDef *htim)
{
34190bcc:	b480      	push	{r7}
34190bce:	b083      	sub	sp, #12
34190bd0:	af00      	add	r7, sp, #0
34190bd2:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_TIMEx_Break2Callback could be implemented in the user file
   */
}
34190bd4:	bf00      	nop
34190bd6:	370c      	adds	r7, #12
34190bd8:	46bd      	mov	sp, r7
34190bda:	f85d 7b04 	ldr.w	r7, [sp], #4
34190bde:	4770      	bx	lr

34190be0 <HAL_TIMEx_EncoderIndexCallback>:
  * @brief  Encoder index callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_EncoderIndexCallback(TIM_HandleTypeDef *htim)
{
34190be0:	b480      	push	{r7}
34190be2:	b083      	sub	sp, #12
34190be4:	af00      	add	r7, sp, #0
34190be6:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_EncoderIndexCallback could be implemented in the user file
   */
}
34190be8:	bf00      	nop
34190bea:	370c      	adds	r7, #12
34190bec:	46bd      	mov	sp, r7
34190bee:	f85d 7b04 	ldr.w	r7, [sp], #4
34190bf2:	4770      	bx	lr

34190bf4 <HAL_TIMEx_DirectionChangeCallback>:
  * @brief  Direction change callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_DirectionChangeCallback(TIM_HandleTypeDef *htim)
{
34190bf4:	b480      	push	{r7}
34190bf6:	b083      	sub	sp, #12
34190bf8:	af00      	add	r7, sp, #0
34190bfa:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_DirectionChangeCallback could be implemented in the user file
   */
}
34190bfc:	bf00      	nop
34190bfe:	370c      	adds	r7, #12
34190c00:	46bd      	mov	sp, r7
34190c02:	f85d 7b04 	ldr.w	r7, [sp], #4
34190c06:	4770      	bx	lr

34190c08 <HAL_TIMEx_IndexErrorCallback>:
  * @brief  Index error callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_IndexErrorCallback(TIM_HandleTypeDef *htim)
{
34190c08:	b480      	push	{r7}
34190c0a:	b083      	sub	sp, #12
34190c0c:	af00      	add	r7, sp, #0
34190c0e:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_IndexErrorCallback could be implemented in the user file
   */
}
34190c10:	bf00      	nop
34190c12:	370c      	adds	r7, #12
34190c14:	46bd      	mov	sp, r7
34190c16:	f85d 7b04 	ldr.w	r7, [sp], #4
34190c1a:	4770      	bx	lr

34190c1c <HAL_TIMEx_TransitionErrorCallback>:
  * @brief  Transition error callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_TransitionErrorCallback(TIM_HandleTypeDef *htim)
{
34190c1c:	b480      	push	{r7}
34190c1e:	b083      	sub	sp, #12
34190c20:	af00      	add	r7, sp, #0
34190c22:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_TransitionErrorCallback could be implemented in the user file
   */
}
34190c24:	bf00      	nop
34190c26:	370c      	adds	r7, #12
34190c28:	46bd      	mov	sp, r7
34190c2a:	f85d 7b04 	ldr.w	r7, [sp], #4
34190c2e:	4770      	bx	lr

34190c30 <LL_DMA_SetLinkedListBaseAddr>:
  *         are always 0)
  * @retval None.
  */
__STATIC_INLINE void LL_DMA_SetLinkedListBaseAddr(const DMA_TypeDef *DMAx, uint32_t Channel,
                                                  uint32_t LinkedListBaseAddr)
{
34190c30:	b480      	push	{r7}
34190c32:	b087      	sub	sp, #28
34190c34:	af00      	add	r7, sp, #0
34190c36:	60f8      	str	r0, [r7, #12]
34190c38:	60b9      	str	r1, [r7, #8]
34190c3a:	607a      	str	r2, [r7, #4]
  uint32_t dma_base_addr = (uint32_t)DMAx;
34190c3c:	68fb      	ldr	r3, [r7, #12]
34190c3e:	617b      	str	r3, [r7, #20]
  MODIFY_REG(((DMA_Channel_TypeDef *)(dma_base_addr + LL_DMA_CH_OFFSET_TAB[Channel]))->CLBAR, DMA_CLBAR_LBA,
34190c40:	4a0c      	ldr	r2, [pc, #48]	@ (34190c74 <LL_DMA_SetLinkedListBaseAddr+0x44>)
34190c42:	68bb      	ldr	r3, [r7, #8]
34190c44:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
34190c48:	697b      	ldr	r3, [r7, #20]
34190c4a:	4413      	add	r3, r2
34190c4c:	681b      	ldr	r3, [r3, #0]
34190c4e:	b29a      	uxth	r2, r3
34190c50:	687b      	ldr	r3, [r7, #4]
34190c52:	0c1b      	lsrs	r3, r3, #16
34190c54:	041b      	lsls	r3, r3, #16
34190c56:	4807      	ldr	r0, [pc, #28]	@ (34190c74 <LL_DMA_SetLinkedListBaseAddr+0x44>)
34190c58:	68b9      	ldr	r1, [r7, #8]
34190c5a:	f850 0021 	ldr.w	r0, [r0, r1, lsl #2]
34190c5e:	6979      	ldr	r1, [r7, #20]
34190c60:	4401      	add	r1, r0
34190c62:	4313      	orrs	r3, r2
34190c64:	600b      	str	r3, [r1, #0]
             (LinkedListBaseAddr & DMA_CLBAR_LBA));
}
34190c66:	bf00      	nop
34190c68:	371c      	adds	r7, #28
34190c6a:	46bd      	mov	sp, r7
34190c6c:	f85d 7b04 	ldr.w	r7, [sp], #4
34190c70:	4770      	bx	lr
34190c72:	bf00      	nop
34190c74:	3419e450 	.word	0x3419e450

34190c78 <LL_DMA_ConfigControl>:
  *         @arg @ref LL_DMA_LINK_ALLOCATED_PORT0     or @ref LL_DMA_LINK_ALLOCATED_PORT1
  *         @arg @ref LL_DMA_LSM_FULL_EXECUTION       or @ref LL_DMA_LSM_1LINK_EXECUTION
  *@retval None.
  */
__STATIC_INLINE void LL_DMA_ConfigControl(const DMA_TypeDef *DMAx, uint32_t Channel, uint32_t Configuration)
{
34190c78:	b480      	push	{r7}
34190c7a:	b087      	sub	sp, #28
34190c7c:	af00      	add	r7, sp, #0
34190c7e:	60f8      	str	r0, [r7, #12]
34190c80:	60b9      	str	r1, [r7, #8]
34190c82:	607a      	str	r2, [r7, #4]
  uint32_t dma_base_addr = (uint32_t)DMAx;
34190c84:	68fb      	ldr	r3, [r7, #12]
34190c86:	617b      	str	r3, [r7, #20]
  MODIFY_REG(((DMA_Channel_TypeDef *)(dma_base_addr + LL_DMA_CH_OFFSET_TAB[Channel]))->CCR,
34190c88:	4a0c      	ldr	r2, [pc, #48]	@ (34190cbc <LL_DMA_ConfigControl+0x44>)
34190c8a:	68bb      	ldr	r3, [r7, #8]
34190c8c:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
34190c90:	697b      	ldr	r3, [r7, #20]
34190c92:	4413      	add	r3, r2
34190c94:	695b      	ldr	r3, [r3, #20]
34190c96:	f423 0243 	bic.w	r2, r3, #12779520	@ 0xc30000
34190c9a:	4908      	ldr	r1, [pc, #32]	@ (34190cbc <LL_DMA_ConfigControl+0x44>)
34190c9c:	68bb      	ldr	r3, [r7, #8]
34190c9e:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
34190ca2:	697b      	ldr	r3, [r7, #20]
34190ca4:	440b      	add	r3, r1
34190ca6:	4619      	mov	r1, r3
34190ca8:	687b      	ldr	r3, [r7, #4]
34190caa:	4313      	orrs	r3, r2
34190cac:	614b      	str	r3, [r1, #20]
             (DMA_CCR_PRIO | DMA_CCR_LAP | DMA_CCR_LSM), Configuration);
}
34190cae:	bf00      	nop
34190cb0:	371c      	adds	r7, #28
34190cb2:	46bd      	mov	sp, r7
34190cb4:	f85d 7b04 	ldr.w	r7, [sp], #4
34190cb8:	4770      	bx	lr
34190cba:	bf00      	nop
34190cbc:	3419e450 	.word	0x3419e450

34190cc0 <LL_DMA_ConfigTransfer>:
  *         @arg @ref LL_DMA_SRC_DATAWIDTH_BYTE       or @ref LL_DMA_SRC_DATAWIDTH_HALFWORD  or
  *              @ref LL_DMA_SRC_DATAWIDTH_WORD       or @ref LL_DMA_SRC_DATAWIDTH_DOUBLEWORD
  *@retval None.
  */
__STATIC_INLINE void LL_DMA_ConfigTransfer(const DMA_TypeDef *DMAx, uint32_t Channel, uint32_t Configuration)
{
34190cc0:	b480      	push	{r7}
34190cc2:	b087      	sub	sp, #28
34190cc4:	af00      	add	r7, sp, #0
34190cc6:	60f8      	str	r0, [r7, #12]
34190cc8:	60b9      	str	r1, [r7, #8]
34190cca:	607a      	str	r2, [r7, #4]
  uint32_t dma_base_addr = (uint32_t)DMAx;
34190ccc:	68fb      	ldr	r3, [r7, #12]
34190cce:	617b      	str	r3, [r7, #20]
  MODIFY_REG(((DMA_Channel_TypeDef *)(dma_base_addr + LL_DMA_CH_OFFSET_TAB[Channel]))->CTR1,
34190cd0:	4a0c      	ldr	r2, [pc, #48]	@ (34190d04 <LL_DMA_ConfigTransfer+0x44>)
34190cd2:	68bb      	ldr	r3, [r7, #8]
34190cd4:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
34190cd8:	697b      	ldr	r3, [r7, #20]
34190cda:	4413      	add	r3, r2
34190cdc:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34190cde:	4b0a      	ldr	r3, [pc, #40]	@ (34190d08 <LL_DMA_ConfigTransfer+0x48>)
34190ce0:	4013      	ands	r3, r2
34190ce2:	4908      	ldr	r1, [pc, #32]	@ (34190d04 <LL_DMA_ConfigTransfer+0x44>)
34190ce4:	68ba      	ldr	r2, [r7, #8]
34190ce6:	f851 1022 	ldr.w	r1, [r1, r2, lsl #2]
34190cea:	697a      	ldr	r2, [r7, #20]
34190cec:	440a      	add	r2, r1
34190cee:	4611      	mov	r1, r2
34190cf0:	687a      	ldr	r2, [r7, #4]
34190cf2:	4313      	orrs	r3, r2
34190cf4:	640b      	str	r3, [r1, #64]	@ 0x40
             DMA_CTR1_DAP | DMA_CTR1_DWX | DMA_CTR1_DHX | DMA_CTR1_DBX | DMA_CTR1_SBX | DMA_CTR1_DINC | \
             DMA_CTR1_SINC | DMA_CTR1_SAP | DMA_CTR1_PAM | DMA_CTR1_DDW_LOG2 | DMA_CTR1_SDW_LOG2, Configuration);
}
34190cf6:	bf00      	nop
34190cf8:	371c      	adds	r7, #28
34190cfa:	46bd      	mov	sp, r7
34190cfc:	f85d 7b04 	ldr.w	r7, [sp], #4
34190d00:	4770      	bx	lr
34190d02:	bf00      	nop
34190d04:	3419e450 	.word	0x3419e450
34190d08:	a3f487f4 	.word	0xa3f487f4

34190d0c <LL_DMA_ConfigBurstLength>:
  * @param  DestBurstLength Between 1 to 64
  * @retval None.
  */
__STATIC_INLINE void LL_DMA_ConfigBurstLength(const DMA_TypeDef *DMAx, uint32_t Channel, uint32_t SrcBurstLength,
                                              uint32_t DestBurstLength)
{
34190d0c:	b480      	push	{r7}
34190d0e:	b087      	sub	sp, #28
34190d10:	af00      	add	r7, sp, #0
34190d12:	60f8      	str	r0, [r7, #12]
34190d14:	60b9      	str	r1, [r7, #8]
34190d16:	607a      	str	r2, [r7, #4]
34190d18:	603b      	str	r3, [r7, #0]
  uint32_t dma_base_addr = (uint32_t)DMAx;
34190d1a:	68fb      	ldr	r3, [r7, #12]
34190d1c:	617b      	str	r3, [r7, #20]
  MODIFY_REG(((DMA_Channel_TypeDef *)(dma_base_addr + LL_DMA_CH_OFFSET_TAB[Channel]))->CTR1,
34190d1e:	4a12      	ldr	r2, [pc, #72]	@ (34190d68 <LL_DMA_ConfigBurstLength+0x5c>)
34190d20:	68bb      	ldr	r3, [r7, #8]
34190d22:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
34190d26:	697b      	ldr	r3, [r7, #20]
34190d28:	4413      	add	r3, r2
34190d2a:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34190d2c:	f023 737c 	bic.w	r3, r3, #66060288	@ 0x3f00000
34190d30:	f423 737c 	bic.w	r3, r3, #1008	@ 0x3f0
34190d34:	687a      	ldr	r2, [r7, #4]
34190d36:	3a01      	subs	r2, #1
34190d38:	0112      	lsls	r2, r2, #4
34190d3a:	f402 717c 	and.w	r1, r2, #1008	@ 0x3f0
34190d3e:	683a      	ldr	r2, [r7, #0]
34190d40:	3a01      	subs	r2, #1
34190d42:	0512      	lsls	r2, r2, #20
34190d44:	f002 727c 	and.w	r2, r2, #66060288	@ 0x3f00000
34190d48:	430a      	orrs	r2, r1
34190d4a:	4807      	ldr	r0, [pc, #28]	@ (34190d68 <LL_DMA_ConfigBurstLength+0x5c>)
34190d4c:	68b9      	ldr	r1, [r7, #8]
34190d4e:	f850 0021 	ldr.w	r0, [r0, r1, lsl #2]
34190d52:	6979      	ldr	r1, [r7, #20]
34190d54:	4401      	add	r1, r0
34190d56:	4313      	orrs	r3, r2
34190d58:	640b      	str	r3, [r1, #64]	@ 0x40
             (DMA_CTR1_SBL_1 | DMA_CTR1_DBL_1), (((SrcBurstLength - 1U) << DMA_CTR1_SBL_1_Pos) & DMA_CTR1_SBL_1) | \
             (((DestBurstLength - 1U) << DMA_CTR1_DBL_1_Pos) & DMA_CTR1_DBL_1));
}
34190d5a:	bf00      	nop
34190d5c:	371c      	adds	r7, #28
34190d5e:	46bd      	mov	sp, r7
34190d60:	f85d 7b04 	ldr.w	r7, [sp], #4
34190d64:	4770      	bx	lr
34190d66:	bf00      	nop
34190d68:	3419e450 	.word	0x3419e450

34190d6c <LL_DMA_ConfigChannelTransfer>:
  *              @ref LL_DMA_DIRECTION_MEMORY_TO_MEMORY
  *         @arg @ref LL_DMA_NORMAL                     or @ref LL_DMA_PFCTRL
  *@retval None.
  */
__STATIC_INLINE void LL_DMA_ConfigChannelTransfer(const DMA_TypeDef *DMAx, uint32_t Channel, uint32_t Configuration)
{
34190d6c:	b480      	push	{r7}
34190d6e:	b087      	sub	sp, #28
34190d70:	af00      	add	r7, sp, #0
34190d72:	60f8      	str	r0, [r7, #12]
34190d74:	60b9      	str	r1, [r7, #8]
34190d76:	607a      	str	r2, [r7, #4]
  uint32_t dma_base_addr = (uint32_t)DMAx;
34190d78:	68fb      	ldr	r3, [r7, #12]
34190d7a:	617b      	str	r3, [r7, #20]
  MODIFY_REG(((DMA_Channel_TypeDef *)(dma_base_addr + LL_DMA_CH_OFFSET_TAB[Channel]))->CTR2,
34190d7c:	4a0d      	ldr	r2, [pc, #52]	@ (34190db4 <LL_DMA_ConfigChannelTransfer+0x48>)
34190d7e:	68bb      	ldr	r3, [r7, #8]
34190d80:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
34190d84:	697b      	ldr	r3, [r7, #20]
34190d86:	4413      	add	r3, r2
34190d88:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34190d8a:	f023 4343 	bic.w	r3, r3, #3271557120	@ 0xc3000000
34190d8e:	f423 435e 	bic.w	r3, r3, #56832	@ 0xde00
34190d92:	4908      	ldr	r1, [pc, #32]	@ (34190db4 <LL_DMA_ConfigChannelTransfer+0x48>)
34190d94:	68ba      	ldr	r2, [r7, #8]
34190d96:	f851 1022 	ldr.w	r1, [r1, r2, lsl #2]
34190d9a:	697a      	ldr	r2, [r7, #20]
34190d9c:	440a      	add	r2, r1
34190d9e:	4611      	mov	r1, r2
34190da0:	687a      	ldr	r2, [r7, #4]
34190da2:	4313      	orrs	r3, r2
34190da4:	644b      	str	r3, [r1, #68]	@ 0x44
             (DMA_CTR2_TCEM | DMA_CTR2_TRIGPOL | DMA_CTR2_TRIGM | DMA_CTR2_DREQ | DMA_CTR2_SWREQ | DMA_CTR2_BREQ |
              DMA_CTR2_PFREQ), Configuration);
}
34190da6:	bf00      	nop
34190da8:	371c      	adds	r7, #28
34190daa:	46bd      	mov	sp, r7
34190dac:	f85d 7b04 	ldr.w	r7, [sp], #4
34190db0:	4770      	bx	lr
34190db2:	bf00      	nop
34190db4:	3419e450 	.word	0x3419e450

34190db8 <LL_DMA_SetTriggerMode>:
  *         @arg @ref LL_DMA_TRIGM_LLI_LINK_TRANSFER
  *         @arg @ref LL_DMA_TRIGM_SINGLBURST_TRANSFER
  * @retval None.
  */
__STATIC_INLINE void LL_DMA_SetTriggerMode(const DMA_TypeDef *DMAx, uint32_t Channel, uint32_t TriggerMode)
{
34190db8:	b480      	push	{r7}
34190dba:	b087      	sub	sp, #28
34190dbc:	af00      	add	r7, sp, #0
34190dbe:	60f8      	str	r0, [r7, #12]
34190dc0:	60b9      	str	r1, [r7, #8]
34190dc2:	607a      	str	r2, [r7, #4]
  uint32_t dma_base_addr = (uint32_t)DMAx;
34190dc4:	68fb      	ldr	r3, [r7, #12]
34190dc6:	617b      	str	r3, [r7, #20]
  MODIFY_REG(((DMA_Channel_TypeDef *)(dma_base_addr + LL_DMA_CH_OFFSET_TAB[Channel]))->CTR2, DMA_CTR2_TRIGM,
34190dc8:	4a0c      	ldr	r2, [pc, #48]	@ (34190dfc <LL_DMA_SetTriggerMode+0x44>)
34190dca:	68bb      	ldr	r3, [r7, #8]
34190dcc:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
34190dd0:	697b      	ldr	r3, [r7, #20]
34190dd2:	4413      	add	r3, r2
34190dd4:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34190dd6:	f423 4240 	bic.w	r2, r3, #49152	@ 0xc000
34190dda:	4908      	ldr	r1, [pc, #32]	@ (34190dfc <LL_DMA_SetTriggerMode+0x44>)
34190ddc:	68bb      	ldr	r3, [r7, #8]
34190dde:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
34190de2:	697b      	ldr	r3, [r7, #20]
34190de4:	440b      	add	r3, r1
34190de6:	4619      	mov	r1, r3
34190de8:	687b      	ldr	r3, [r7, #4]
34190dea:	4313      	orrs	r3, r2
34190dec:	644b      	str	r3, [r1, #68]	@ 0x44
             TriggerMode);
}
34190dee:	bf00      	nop
34190df0:	371c      	adds	r7, #28
34190df2:	46bd      	mov	sp, r7
34190df4:	f85d 7b04 	ldr.w	r7, [sp], #4
34190df8:	4770      	bx	lr
34190dfa:	bf00      	nop
34190dfc:	3419e450 	.word	0x3419e450

34190e00 <LL_DMA_SetPeriphRequest>:
  *         @arg @ref LL_GPDMA1_REQUEST_I3C2_TC
  *         @arg @ref LL_GPDMA1_REQUEST_I3C2_RS
  * @retval None.
  */
__STATIC_INLINE void LL_DMA_SetPeriphRequest(const DMA_TypeDef *DMAx, uint32_t Channel, uint32_t Request)
{
34190e00:	b480      	push	{r7}
34190e02:	b087      	sub	sp, #28
34190e04:	af00      	add	r7, sp, #0
34190e06:	60f8      	str	r0, [r7, #12]
34190e08:	60b9      	str	r1, [r7, #8]
34190e0a:	607a      	str	r2, [r7, #4]
  uint32_t dma_base_addr = (uint32_t)DMAx;
34190e0c:	68fb      	ldr	r3, [r7, #12]
34190e0e:	617b      	str	r3, [r7, #20]
  MODIFY_REG(((DMA_Channel_TypeDef *)(dma_base_addr + LL_DMA_CH_OFFSET_TAB[Channel]))->CTR2, DMA_CTR2_REQSEL, Request);
34190e10:	4a0c      	ldr	r2, [pc, #48]	@ (34190e44 <LL_DMA_SetPeriphRequest+0x44>)
34190e12:	68bb      	ldr	r3, [r7, #8]
34190e14:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
34190e18:	697b      	ldr	r3, [r7, #20]
34190e1a:	4413      	add	r3, r2
34190e1c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34190e1e:	f023 02ff 	bic.w	r2, r3, #255	@ 0xff
34190e22:	4908      	ldr	r1, [pc, #32]	@ (34190e44 <LL_DMA_SetPeriphRequest+0x44>)
34190e24:	68bb      	ldr	r3, [r7, #8]
34190e26:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
34190e2a:	697b      	ldr	r3, [r7, #20]
34190e2c:	440b      	add	r3, r1
34190e2e:	4619      	mov	r1, r3
34190e30:	687b      	ldr	r3, [r7, #4]
34190e32:	4313      	orrs	r3, r2
34190e34:	644b      	str	r3, [r1, #68]	@ 0x44
}
34190e36:	bf00      	nop
34190e38:	371c      	adds	r7, #28
34190e3a:	46bd      	mov	sp, r7
34190e3c:	f85d 7b04 	ldr.w	r7, [sp], #4
34190e40:	4770      	bx	lr
34190e42:	bf00      	nop
34190e44:	3419e450 	.word	0x3419e450

34190e48 <LL_DMA_SetHWTrigger>:
  *         @arg @ref LL_GPDMA1_TRIGGER_EXTIT14_SYNC
  *         @arg @ref LL_GPDMA1_TRIGGER_EXTIT15_SYNC
  * @retval None.
  */
__STATIC_INLINE void LL_DMA_SetHWTrigger(const DMA_TypeDef *DMAx, uint32_t Channel, uint32_t Trigger)
{
34190e48:	b480      	push	{r7}
34190e4a:	b087      	sub	sp, #28
34190e4c:	af00      	add	r7, sp, #0
34190e4e:	60f8      	str	r0, [r7, #12]
34190e50:	60b9      	str	r1, [r7, #8]
34190e52:	607a      	str	r2, [r7, #4]
  uint32_t dma_base_addr = (uint32_t)DMAx;
34190e54:	68fb      	ldr	r3, [r7, #12]
34190e56:	617b      	str	r3, [r7, #20]
  MODIFY_REG(((DMA_Channel_TypeDef *)(dma_base_addr + LL_DMA_CH_OFFSET_TAB[Channel]))->CTR2, DMA_CTR2_TRIGSEL,
34190e58:	4a0d      	ldr	r2, [pc, #52]	@ (34190e90 <LL_DMA_SetHWTrigger+0x48>)
34190e5a:	68bb      	ldr	r3, [r7, #8]
34190e5c:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
34190e60:	697b      	ldr	r3, [r7, #20]
34190e62:	4413      	add	r3, r2
34190e64:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34190e66:	f423 02fe 	bic.w	r2, r3, #8323072	@ 0x7f0000
34190e6a:	687b      	ldr	r3, [r7, #4]
34190e6c:	041b      	lsls	r3, r3, #16
34190e6e:	f403 03fe 	and.w	r3, r3, #8323072	@ 0x7f0000
34190e72:	4807      	ldr	r0, [pc, #28]	@ (34190e90 <LL_DMA_SetHWTrigger+0x48>)
34190e74:	68b9      	ldr	r1, [r7, #8]
34190e76:	f850 0021 	ldr.w	r0, [r0, r1, lsl #2]
34190e7a:	6979      	ldr	r1, [r7, #20]
34190e7c:	4401      	add	r1, r0
34190e7e:	4313      	orrs	r3, r2
34190e80:	644b      	str	r3, [r1, #68]	@ 0x44
             (Trigger << DMA_CTR2_TRIGSEL_Pos) & DMA_CTR2_TRIGSEL);
}
34190e82:	bf00      	nop
34190e84:	371c      	adds	r7, #28
34190e86:	46bd      	mov	sp, r7
34190e88:	f85d 7b04 	ldr.w	r7, [sp], #4
34190e8c:	4770      	bx	lr
34190e8e:	bf00      	nop
34190e90:	3419e450 	.word	0x3419e450

34190e94 <LL_DMA_ConfigBlkRptAddrUpdate>:
  *         @arg @ref LL_DMA_BURST_DEST_ADDR_INCREMENT  or @ref LL_DMA_BURST_DEST_ADDR_DECREMENT
  *         @arg @ref LL_DMA_BURST_SRC_ADDR_INCREMENT   or @ref LL_DMA_BURST_SRC_ADDR_DECREMENT
  *@retval None.
  */
__STATIC_INLINE void LL_DMA_ConfigBlkRptAddrUpdate(const DMA_TypeDef *DMAx, uint32_t Channel, uint32_t Configuration)
{
34190e94:	b480      	push	{r7}
34190e96:	b087      	sub	sp, #28
34190e98:	af00      	add	r7, sp, #0
34190e9a:	60f8      	str	r0, [r7, #12]
34190e9c:	60b9      	str	r1, [r7, #8]
34190e9e:	607a      	str	r2, [r7, #4]
  uint32_t dma_base_addr = (uint32_t)DMAx;
34190ea0:	68fb      	ldr	r3, [r7, #12]
34190ea2:	617b      	str	r3, [r7, #20]
  MODIFY_REG(((DMA_Channel_TypeDef *)(dma_base_addr + LL_DMA_CH_OFFSET_TAB[Channel]))->CBR1,
34190ea4:	4a0c      	ldr	r2, [pc, #48]	@ (34190ed8 <LL_DMA_ConfigBlkRptAddrUpdate+0x44>)
34190ea6:	68bb      	ldr	r3, [r7, #8]
34190ea8:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
34190eac:	697b      	ldr	r3, [r7, #20]
34190eae:	4413      	add	r3, r2
34190eb0:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34190eb2:	f023 4270 	bic.w	r2, r3, #4026531840	@ 0xf0000000
34190eb6:	4908      	ldr	r1, [pc, #32]	@ (34190ed8 <LL_DMA_ConfigBlkRptAddrUpdate+0x44>)
34190eb8:	68bb      	ldr	r3, [r7, #8]
34190eba:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
34190ebe:	697b      	ldr	r3, [r7, #20]
34190ec0:	440b      	add	r3, r1
34190ec2:	4619      	mov	r1, r3
34190ec4:	687b      	ldr	r3, [r7, #4]
34190ec6:	4313      	orrs	r3, r2
34190ec8:	648b      	str	r3, [r1, #72]	@ 0x48
             DMA_CBR1_BRDDEC | DMA_CBR1_BRSDEC | DMA_CBR1_DDEC | DMA_CBR1_SDEC, Configuration);
}
34190eca:	bf00      	nop
34190ecc:	371c      	adds	r7, #28
34190ece:	46bd      	mov	sp, r7
34190ed0:	f85d 7b04 	ldr.w	r7, [sp], #4
34190ed4:	4770      	bx	lr
34190ed6:	bf00      	nop
34190ed8:	3419e450 	.word	0x3419e450

34190edc <LL_DMA_SetBlkRptCount>:
  * @param  BlkRptCount Block repeat counter
  *                     Value between 0 to 0x000007FF
  * @retval None.
  */
__STATIC_INLINE void LL_DMA_SetBlkRptCount(const DMA_TypeDef *DMAx, uint32_t Channel, uint32_t BlkRptCount)
{
34190edc:	b480      	push	{r7}
34190ede:	b087      	sub	sp, #28
34190ee0:	af00      	add	r7, sp, #0
34190ee2:	60f8      	str	r0, [r7, #12]
34190ee4:	60b9      	str	r1, [r7, #8]
34190ee6:	607a      	str	r2, [r7, #4]
  uint32_t dma_base_addr = (uint32_t)DMAx;
34190ee8:	68fb      	ldr	r3, [r7, #12]
34190eea:	617b      	str	r3, [r7, #20]
  MODIFY_REG(((DMA_Channel_TypeDef *)(dma_base_addr + LL_DMA_CH_OFFSET_TAB[Channel]))->CBR1, DMA_CBR1_BRC,
34190eec:	4a0e      	ldr	r2, [pc, #56]	@ (34190f28 <LL_DMA_SetBlkRptCount+0x4c>)
34190eee:	68bb      	ldr	r3, [r7, #8]
34190ef0:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
34190ef4:	697b      	ldr	r3, [r7, #20]
34190ef6:	4413      	add	r3, r2
34190ef8:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34190efa:	f023 63ff 	bic.w	r3, r3, #133693440	@ 0x7f80000
34190efe:	f423 23e0 	bic.w	r3, r3, #458752	@ 0x70000
34190f02:	687a      	ldr	r2, [r7, #4]
34190f04:	0411      	lsls	r1, r2, #16
34190f06:	4a09      	ldr	r2, [pc, #36]	@ (34190f2c <LL_DMA_SetBlkRptCount+0x50>)
34190f08:	400a      	ands	r2, r1
34190f0a:	4807      	ldr	r0, [pc, #28]	@ (34190f28 <LL_DMA_SetBlkRptCount+0x4c>)
34190f0c:	68b9      	ldr	r1, [r7, #8]
34190f0e:	f850 0021 	ldr.w	r0, [r0, r1, lsl #2]
34190f12:	6979      	ldr	r1, [r7, #20]
34190f14:	4401      	add	r1, r0
34190f16:	4313      	orrs	r3, r2
34190f18:	648b      	str	r3, [r1, #72]	@ 0x48
             (BlkRptCount << DMA_CBR1_BRC_Pos) & DMA_CBR1_BRC);
}
34190f1a:	bf00      	nop
34190f1c:	371c      	adds	r7, #28
34190f1e:	46bd      	mov	sp, r7
34190f20:	f85d 7b04 	ldr.w	r7, [sp], #4
34190f24:	4770      	bx	lr
34190f26:	bf00      	nop
34190f28:	3419e450 	.word	0x3419e450
34190f2c:	07ff0000 	.word	0x07ff0000

34190f30 <LL_DMA_SetBlkDataLength>:
  *         @arg @ref LL_DMA_CHANNEL_15
  * @param  BlkDataLength Between 0 to 0x0000FFFF
  * @retval None.
  */
__STATIC_INLINE void LL_DMA_SetBlkDataLength(const DMA_TypeDef *DMAx, uint32_t Channel, uint32_t BlkDataLength)
{
34190f30:	b480      	push	{r7}
34190f32:	b087      	sub	sp, #28
34190f34:	af00      	add	r7, sp, #0
34190f36:	60f8      	str	r0, [r7, #12]
34190f38:	60b9      	str	r1, [r7, #8]
34190f3a:	607a      	str	r2, [r7, #4]
  uint32_t dma_base_addr = (uint32_t)DMAx;
34190f3c:	68fb      	ldr	r3, [r7, #12]
34190f3e:	617b      	str	r3, [r7, #20]
  MODIFY_REG(((DMA_Channel_TypeDef *)(dma_base_addr + LL_DMA_CH_OFFSET_TAB[Channel]))->CBR1, DMA_CBR1_BNDT,
34190f40:	4a0c      	ldr	r2, [pc, #48]	@ (34190f74 <LL_DMA_SetBlkDataLength+0x44>)
34190f42:	68bb      	ldr	r3, [r7, #8]
34190f44:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
34190f48:	697b      	ldr	r3, [r7, #20]
34190f4a:	4413      	add	r3, r2
34190f4c:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34190f4e:	0c1b      	lsrs	r3, r3, #16
34190f50:	041b      	lsls	r3, r3, #16
34190f52:	4908      	ldr	r1, [pc, #32]	@ (34190f74 <LL_DMA_SetBlkDataLength+0x44>)
34190f54:	68ba      	ldr	r2, [r7, #8]
34190f56:	f851 1022 	ldr.w	r1, [r1, r2, lsl #2]
34190f5a:	697a      	ldr	r2, [r7, #20]
34190f5c:	440a      	add	r2, r1
34190f5e:	4611      	mov	r1, r2
34190f60:	687a      	ldr	r2, [r7, #4]
34190f62:	4313      	orrs	r3, r2
34190f64:	648b      	str	r3, [r1, #72]	@ 0x48
             BlkDataLength);
}
34190f66:	bf00      	nop
34190f68:	371c      	adds	r7, #28
34190f6a:	46bd      	mov	sp, r7
34190f6c:	f85d 7b04 	ldr.w	r7, [sp], #4
34190f70:	4770      	bx	lr
34190f72:	bf00      	nop
34190f74:	3419e450 	.word	0x3419e450

34190f78 <LL_DMA_ConfigAddresses>:
  * @param  DestAddress Between 0 to 0xFFFFFFFF
  * @retval None.
  */
__STATIC_INLINE void LL_DMA_ConfigAddresses(const DMA_TypeDef *DMAx, uint32_t Channel, uint32_t SrcAddress, uint32_t
                                            DestAddress)
{
34190f78:	b480      	push	{r7}
34190f7a:	b087      	sub	sp, #28
34190f7c:	af00      	add	r7, sp, #0
34190f7e:	60f8      	str	r0, [r7, #12]
34190f80:	60b9      	str	r1, [r7, #8]
34190f82:	607a      	str	r2, [r7, #4]
34190f84:	603b      	str	r3, [r7, #0]
  uint32_t dma_base_addr = (uint32_t)DMAx;
34190f86:	68fb      	ldr	r3, [r7, #12]
34190f88:	617b      	str	r3, [r7, #20]
  WRITE_REG(((DMA_Channel_TypeDef *)(dma_base_addr + LL_DMA_CH_OFFSET_TAB[Channel]))->CSAR, SrcAddress);
34190f8a:	4a0c      	ldr	r2, [pc, #48]	@ (34190fbc <LL_DMA_ConfigAddresses+0x44>)
34190f8c:	68bb      	ldr	r3, [r7, #8]
34190f8e:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
34190f92:	697b      	ldr	r3, [r7, #20]
34190f94:	4413      	add	r3, r2
34190f96:	461a      	mov	r2, r3
34190f98:	687b      	ldr	r3, [r7, #4]
34190f9a:	64d3      	str	r3, [r2, #76]	@ 0x4c
  WRITE_REG(((DMA_Channel_TypeDef *)(dma_base_addr + LL_DMA_CH_OFFSET_TAB[Channel]))->CDAR, DestAddress);
34190f9c:	4a07      	ldr	r2, [pc, #28]	@ (34190fbc <LL_DMA_ConfigAddresses+0x44>)
34190f9e:	68bb      	ldr	r3, [r7, #8]
34190fa0:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
34190fa4:	697b      	ldr	r3, [r7, #20]
34190fa6:	4413      	add	r3, r2
34190fa8:	461a      	mov	r2, r3
34190faa:	683b      	ldr	r3, [r7, #0]
34190fac:	6513      	str	r3, [r2, #80]	@ 0x50
}
34190fae:	bf00      	nop
34190fb0:	371c      	adds	r7, #28
34190fb2:	46bd      	mov	sp, r7
34190fb4:	f85d 7b04 	ldr.w	r7, [sp], #4
34190fb8:	4770      	bx	lr
34190fba:	bf00      	nop
34190fbc:	3419e450 	.word	0x3419e450

34190fc0 <LL_DMA_ConfigAddrUpdateValue>:
  * @param  SrcAddrOffset Between 0 to 0x00001FFF
  * @retval None.
  */
__STATIC_INLINE void LL_DMA_ConfigAddrUpdateValue(const DMA_TypeDef *DMAx, uint32_t Channel, uint32_t SrcAddrOffset,
                                                  uint32_t DestAddrOffset)
{
34190fc0:	b480      	push	{r7}
34190fc2:	b087      	sub	sp, #28
34190fc4:	af00      	add	r7, sp, #0
34190fc6:	60f8      	str	r0, [r7, #12]
34190fc8:	60b9      	str	r1, [r7, #8]
34190fca:	607a      	str	r2, [r7, #4]
34190fcc:	603b      	str	r3, [r7, #0]
  uint32_t dma_base_addr = (uint32_t)DMAx;
34190fce:	68fb      	ldr	r3, [r7, #12]
34190fd0:	617b      	str	r3, [r7, #20]
  WRITE_REG(((DMA_Channel_TypeDef *)(dma_base_addr + LL_DMA_CH_OFFSET_TAB[Channel]))->CTR3,
34190fd2:	687b      	ldr	r3, [r7, #4]
34190fd4:	f3c3 020c 	ubfx	r2, r3, #0, #13
34190fd8:	683b      	ldr	r3, [r7, #0]
34190fda:	0419      	lsls	r1, r3, #16
34190fdc:	4b07      	ldr	r3, [pc, #28]	@ (34190ffc <LL_DMA_ConfigAddrUpdateValue+0x3c>)
34190fde:	400b      	ands	r3, r1
34190fe0:	4807      	ldr	r0, [pc, #28]	@ (34191000 <LL_DMA_ConfigAddrUpdateValue+0x40>)
34190fe2:	68b9      	ldr	r1, [r7, #8]
34190fe4:	f850 0021 	ldr.w	r0, [r0, r1, lsl #2]
34190fe8:	6979      	ldr	r1, [r7, #20]
34190fea:	4401      	add	r1, r0
34190fec:	4313      	orrs	r3, r2
34190fee:	654b      	str	r3, [r1, #84]	@ 0x54
            (SrcAddrOffset  & DMA_CTR3_SAO) | ((DestAddrOffset << DMA_CTR3_DAO_Pos) & DMA_CTR3_DAO));
}
34190ff0:	bf00      	nop
34190ff2:	371c      	adds	r7, #28
34190ff4:	46bd      	mov	sp, r7
34190ff6:	f85d 7b04 	ldr.w	r7, [sp], #4
34190ffa:	4770      	bx	lr
34190ffc:	1fff0000 	.word	0x1fff0000
34191000:	3419e450 	.word	0x3419e450

34191004 <LL_DMA_ConfigBlkRptAddrUpdateValue>:
  * @param  BlkRptSrcAddrOffset Between 0 to 0x0000FFFF
  * @retval None.
  */
__STATIC_INLINE void LL_DMA_ConfigBlkRptAddrUpdateValue(const DMA_TypeDef *DMAx, uint32_t Channel,
                                                        uint32_t BlkRptSrcAddrOffset, uint32_t BlkRptDestAddrOffset)
{
34191004:	b480      	push	{r7}
34191006:	b087      	sub	sp, #28
34191008:	af00      	add	r7, sp, #0
3419100a:	60f8      	str	r0, [r7, #12]
3419100c:	60b9      	str	r1, [r7, #8]
3419100e:	607a      	str	r2, [r7, #4]
34191010:	603b      	str	r3, [r7, #0]
  uint32_t dma_base_addr = (uint32_t)DMAx;
34191012:	68fb      	ldr	r3, [r7, #12]
34191014:	617b      	str	r3, [r7, #20]
  WRITE_REG(((DMA_Channel_TypeDef *)(dma_base_addr + LL_DMA_CH_OFFSET_TAB[Channel]))->CBR2,
34191016:	683b      	ldr	r3, [r7, #0]
34191018:	041a      	lsls	r2, r3, #16
3419101a:	687b      	ldr	r3, [r7, #4]
3419101c:	b29b      	uxth	r3, r3
3419101e:	4807      	ldr	r0, [pc, #28]	@ (3419103c <LL_DMA_ConfigBlkRptAddrUpdateValue+0x38>)
34191020:	68b9      	ldr	r1, [r7, #8]
34191022:	f850 0021 	ldr.w	r0, [r0, r1, lsl #2]
34191026:	6979      	ldr	r1, [r7, #20]
34191028:	4401      	add	r1, r0
3419102a:	4313      	orrs	r3, r2
3419102c:	658b      	str	r3, [r1, #88]	@ 0x58
            ((BlkRptDestAddrOffset << DMA_CBR2_BRDAO_Pos) & DMA_CBR2_BRDAO) | (BlkRptSrcAddrOffset  & DMA_CBR2_BRSAO));
}
3419102e:	bf00      	nop
34191030:	371c      	adds	r7, #28
34191032:	46bd      	mov	sp, r7
34191034:	f85d 7b04 	ldr.w	r7, [sp], #4
34191038:	4770      	bx	lr
3419103a:	bf00      	nop
3419103c:	3419e450 	.word	0x3419e450

34191040 <LL_DMA_SetLinkedListAddrOffset>:
  * @param  LinkedListAddrOffset Between 0 to 0x0000FFFC by increment of 4 Bytes.
  * @retval None.
  */
__STATIC_INLINE void LL_DMA_SetLinkedListAddrOffset(const DMA_TypeDef *DMAx, uint32_t Channel,
                                                    uint32_t  LinkedListAddrOffset)
{
34191040:	b480      	push	{r7}
34191042:	b087      	sub	sp, #28
34191044:	af00      	add	r7, sp, #0
34191046:	60f8      	str	r0, [r7, #12]
34191048:	60b9      	str	r1, [r7, #8]
3419104a:	607a      	str	r2, [r7, #4]
  uint32_t dma_base_addr = (uint32_t)DMAx;
3419104c:	68fb      	ldr	r3, [r7, #12]
3419104e:	617b      	str	r3, [r7, #20]
  MODIFY_REG(((DMA_Channel_TypeDef *)(dma_base_addr + LL_DMA_CH_OFFSET_TAB[Channel]))->CLLR, DMA_CLLR_LA,
34191050:	4a0e      	ldr	r2, [pc, #56]	@ (3419108c <LL_DMA_SetLinkedListAddrOffset+0x4c>)
34191052:	68bb      	ldr	r3, [r7, #8]
34191054:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
34191058:	697b      	ldr	r3, [r7, #20]
3419105a:	4413      	add	r3, r2
3419105c:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3419105e:	f423 437f 	bic.w	r3, r3, #65280	@ 0xff00
34191062:	f023 03fc 	bic.w	r3, r3, #252	@ 0xfc
34191066:	6879      	ldr	r1, [r7, #4]
34191068:	f64f 72fc 	movw	r2, #65532	@ 0xfffc
3419106c:	400a      	ands	r2, r1
3419106e:	4807      	ldr	r0, [pc, #28]	@ (3419108c <LL_DMA_SetLinkedListAddrOffset+0x4c>)
34191070:	68b9      	ldr	r1, [r7, #8]
34191072:	f850 0021 	ldr.w	r0, [r0, r1, lsl #2]
34191076:	6979      	ldr	r1, [r7, #20]
34191078:	4401      	add	r1, r0
3419107a:	4313      	orrs	r3, r2
3419107c:	67cb      	str	r3, [r1, #124]	@ 0x7c
             (LinkedListAddrOffset & DMA_CLLR_LA));
}
3419107e:	bf00      	nop
34191080:	371c      	adds	r7, #28
34191082:	46bd      	mov	sp, r7
34191084:	f85d 7b04 	ldr.w	r7, [sp], #4
34191088:	4770      	bx	lr
3419108a:	bf00      	nop
3419108c:	3419e450 	.word	0x3419e450

34191090 <LL_DMA_Init>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS : DMA registers are initialized.
  *          - ERROR   : Not applicable.
  */
uint32_t LL_DMA_Init(DMA_TypeDef *DMAx, uint32_t Channel, LL_DMA_InitTypeDef *DMA_InitStruct)
{
34191090:	b580      	push	{r7, lr}
34191092:	b084      	sub	sp, #16
34191094:	af00      	add	r7, sp, #0
34191096:	60f8      	str	r0, [r7, #12]
34191098:	60b9      	str	r1, [r7, #8]
3419109a:	607a      	str	r2, [r7, #4]
  {
    assert_param(IS_LL_DMA_PFREQ_INSTANCE(DMAx, Channel));
  }

  /* Check DMA instance */
  if ((IS_LL_HPDMA_CHANNEL_INSTANCE(DMAx, Channel) != 0U) || (IS_LL_GPDMA_CHANNEL_INSTANCE(DMAx, Channel) != 0U))
3419109c:	68fb      	ldr	r3, [r7, #12]
3419109e:	4a51      	ldr	r2, [pc, #324]	@ (341911e4 <LL_DMA_Init+0x154>)
341910a0:	4293      	cmp	r3, r2
341910a2:	d131      	bne.n	34191108 <LL_DMA_Init+0x78>
341910a4:	68bb      	ldr	r3, [r7, #8]
341910a6:	2b00      	cmp	r3, #0
341910a8:	d02c      	beq.n	34191104 <LL_DMA_Init+0x74>
341910aa:	68bb      	ldr	r3, [r7, #8]
341910ac:	2b01      	cmp	r3, #1
341910ae:	d029      	beq.n	34191104 <LL_DMA_Init+0x74>
341910b0:	68bb      	ldr	r3, [r7, #8]
341910b2:	2b02      	cmp	r3, #2
341910b4:	d026      	beq.n	34191104 <LL_DMA_Init+0x74>
341910b6:	68bb      	ldr	r3, [r7, #8]
341910b8:	2b03      	cmp	r3, #3
341910ba:	d023      	beq.n	34191104 <LL_DMA_Init+0x74>
341910bc:	68bb      	ldr	r3, [r7, #8]
341910be:	2b04      	cmp	r3, #4
341910c0:	d020      	beq.n	34191104 <LL_DMA_Init+0x74>
341910c2:	68bb      	ldr	r3, [r7, #8]
341910c4:	2b05      	cmp	r3, #5
341910c6:	d01d      	beq.n	34191104 <LL_DMA_Init+0x74>
341910c8:	68bb      	ldr	r3, [r7, #8]
341910ca:	2b06      	cmp	r3, #6
341910cc:	d01a      	beq.n	34191104 <LL_DMA_Init+0x74>
341910ce:	68bb      	ldr	r3, [r7, #8]
341910d0:	2b07      	cmp	r3, #7
341910d2:	d017      	beq.n	34191104 <LL_DMA_Init+0x74>
341910d4:	68bb      	ldr	r3, [r7, #8]
341910d6:	2b08      	cmp	r3, #8
341910d8:	d014      	beq.n	34191104 <LL_DMA_Init+0x74>
341910da:	68bb      	ldr	r3, [r7, #8]
341910dc:	2b09      	cmp	r3, #9
341910de:	d011      	beq.n	34191104 <LL_DMA_Init+0x74>
341910e0:	68bb      	ldr	r3, [r7, #8]
341910e2:	2b0a      	cmp	r3, #10
341910e4:	d00e      	beq.n	34191104 <LL_DMA_Init+0x74>
341910e6:	68bb      	ldr	r3, [r7, #8]
341910e8:	2b0b      	cmp	r3, #11
341910ea:	d00b      	beq.n	34191104 <LL_DMA_Init+0x74>
341910ec:	68bb      	ldr	r3, [r7, #8]
341910ee:	2b0c      	cmp	r3, #12
341910f0:	d008      	beq.n	34191104 <LL_DMA_Init+0x74>
341910f2:	68bb      	ldr	r3, [r7, #8]
341910f4:	2b0d      	cmp	r3, #13
341910f6:	d005      	beq.n	34191104 <LL_DMA_Init+0x74>
341910f8:	68bb      	ldr	r3, [r7, #8]
341910fa:	2b0e      	cmp	r3, #14
341910fc:	d002      	beq.n	34191104 <LL_DMA_Init+0x74>
341910fe:	68bb      	ldr	r3, [r7, #8]
34191100:	2b0f      	cmp	r3, #15
34191102:	d101      	bne.n	34191108 <LL_DMA_Init+0x78>
34191104:	2301      	movs	r3, #1
34191106:	e000      	b.n	3419110a <LL_DMA_Init+0x7a>
34191108:	2300      	movs	r3, #0
3419110a:	2b00      	cmp	r3, #0
3419110c:	d132      	bne.n	34191174 <LL_DMA_Init+0xe4>
3419110e:	68fb      	ldr	r3, [r7, #12]
34191110:	4a35      	ldr	r2, [pc, #212]	@ (341911e8 <LL_DMA_Init+0x158>)
34191112:	4293      	cmp	r3, r2
34191114:	d12e      	bne.n	34191174 <LL_DMA_Init+0xe4>
34191116:	68bb      	ldr	r3, [r7, #8]
34191118:	2b00      	cmp	r3, #0
3419111a:	d02b      	beq.n	34191174 <LL_DMA_Init+0xe4>
3419111c:	68bb      	ldr	r3, [r7, #8]
3419111e:	2b01      	cmp	r3, #1
34191120:	d028      	beq.n	34191174 <LL_DMA_Init+0xe4>
34191122:	68bb      	ldr	r3, [r7, #8]
34191124:	2b02      	cmp	r3, #2
34191126:	d025      	beq.n	34191174 <LL_DMA_Init+0xe4>
34191128:	68bb      	ldr	r3, [r7, #8]
3419112a:	2b03      	cmp	r3, #3
3419112c:	d022      	beq.n	34191174 <LL_DMA_Init+0xe4>
3419112e:	68bb      	ldr	r3, [r7, #8]
34191130:	2b04      	cmp	r3, #4
34191132:	d01f      	beq.n	34191174 <LL_DMA_Init+0xe4>
34191134:	68bb      	ldr	r3, [r7, #8]
34191136:	2b05      	cmp	r3, #5
34191138:	d01c      	beq.n	34191174 <LL_DMA_Init+0xe4>
3419113a:	68bb      	ldr	r3, [r7, #8]
3419113c:	2b06      	cmp	r3, #6
3419113e:	d019      	beq.n	34191174 <LL_DMA_Init+0xe4>
34191140:	68bb      	ldr	r3, [r7, #8]
34191142:	2b07      	cmp	r3, #7
34191144:	d016      	beq.n	34191174 <LL_DMA_Init+0xe4>
34191146:	68bb      	ldr	r3, [r7, #8]
34191148:	2b08      	cmp	r3, #8
3419114a:	d013      	beq.n	34191174 <LL_DMA_Init+0xe4>
3419114c:	68bb      	ldr	r3, [r7, #8]
3419114e:	2b09      	cmp	r3, #9
34191150:	d010      	beq.n	34191174 <LL_DMA_Init+0xe4>
34191152:	68bb      	ldr	r3, [r7, #8]
34191154:	2b0a      	cmp	r3, #10
34191156:	d00d      	beq.n	34191174 <LL_DMA_Init+0xe4>
34191158:	68bb      	ldr	r3, [r7, #8]
3419115a:	2b0b      	cmp	r3, #11
3419115c:	d00a      	beq.n	34191174 <LL_DMA_Init+0xe4>
3419115e:	68bb      	ldr	r3, [r7, #8]
34191160:	2b0c      	cmp	r3, #12
34191162:	d007      	beq.n	34191174 <LL_DMA_Init+0xe4>
34191164:	68bb      	ldr	r3, [r7, #8]
34191166:	2b0d      	cmp	r3, #13
34191168:	d004      	beq.n	34191174 <LL_DMA_Init+0xe4>
3419116a:	68bb      	ldr	r3, [r7, #8]
3419116c:	2b0e      	cmp	r3, #14
3419116e:	d001      	beq.n	34191174 <LL_DMA_Init+0xe4>
34191170:	68bb      	ldr	r3, [r7, #8]
34191172:	2b0f      	cmp	r3, #15
    assert_param(IS_LL_DMA_TRIGGER_MODE(DMA_InitStruct->TriggerMode));
    assert_param(IS_LL_DMA_TRIGGER_SELECTION(DMA_InitStruct->TriggerSelection));
  }

  /* Check DMA channel */
  if (IS_LL_DMA_2D_CHANNEL_INSTANCE(DMAx, Channel) != 0U)
34191174:	68fb      	ldr	r3, [r7, #12]
34191176:	4a1b      	ldr	r2, [pc, #108]	@ (341911e4 <LL_DMA_Init+0x154>)
34191178:	4293      	cmp	r3, r2
3419117a:	d10b      	bne.n	34191194 <LL_DMA_Init+0x104>
3419117c:	68bb      	ldr	r3, [r7, #8]
3419117e:	2b0c      	cmp	r3, #12
34191180:	d017      	beq.n	341911b2 <LL_DMA_Init+0x122>
34191182:	68bb      	ldr	r3, [r7, #8]
34191184:	2b0d      	cmp	r3, #13
34191186:	d014      	beq.n	341911b2 <LL_DMA_Init+0x122>
34191188:	68bb      	ldr	r3, [r7, #8]
3419118a:	2b0e      	cmp	r3, #14
3419118c:	d011      	beq.n	341911b2 <LL_DMA_Init+0x122>
3419118e:	68bb      	ldr	r3, [r7, #8]
34191190:	2b0f      	cmp	r3, #15
34191192:	d00e      	beq.n	341911b2 <LL_DMA_Init+0x122>
34191194:	68fb      	ldr	r3, [r7, #12]
34191196:	4a14      	ldr	r2, [pc, #80]	@ (341911e8 <LL_DMA_Init+0x158>)
34191198:	4293      	cmp	r3, r2
3419119a:	d10a      	bne.n	341911b2 <LL_DMA_Init+0x122>
3419119c:	68bb      	ldr	r3, [r7, #8]
3419119e:	2b0c      	cmp	r3, #12
341911a0:	d007      	beq.n	341911b2 <LL_DMA_Init+0x122>
341911a2:	68bb      	ldr	r3, [r7, #8]
341911a4:	2b0d      	cmp	r3, #13
341911a6:	d004      	beq.n	341911b2 <LL_DMA_Init+0x122>
341911a8:	68bb      	ldr	r3, [r7, #8]
341911aa:	2b0e      	cmp	r3, #14
341911ac:	d001      	beq.n	341911b2 <LL_DMA_Init+0x122>
341911ae:	68bb      	ldr	r3, [r7, #8]
341911b0:	2b0f      	cmp	r3, #15
    assert_param(IS_LL_DMA_BLKRPT_DEST_ADDR_UPDATE(DMA_InitStruct->BlkRptDestAddrUpdateMode));
    assert_param(IS_LL_DMA_BLKRPT_ADDR_UPDATE_VALUE(DMA_InitStruct->BlkRptSrcAddrOffset));
    assert_param(IS_LL_DMA_BLKRPT_ADDR_UPDATE_VALUE(DMA_InitStruct->BlkRptDestAddrOffset));
  }

  if (DMAx == HPDMA1)
341911b2:	68fb      	ldr	r3, [r7, #12]
341911b4:	4a0b      	ldr	r2, [pc, #44]	@ (341911e4 <LL_DMA_Init+0x154>)
341911b6:	4293      	cmp	r3, r2
341911b8:	d118      	bne.n	341911ec <LL_DMA_Init+0x15c>
  {
    if ((DMA_InitStruct->SrcAllocatedPort == LL_DMA_SRC_ALLOCATED_PORT0) &&
341911ba:	687b      	ldr	r3, [r7, #4]
341911bc:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
341911be:	2b00      	cmp	r3, #0
341911c0:	d105      	bne.n	341911ce <LL_DMA_Init+0x13e>
        (DMA_InitStruct->SrcBurstLength > 16U))
341911c2:	687b      	ldr	r3, [r7, #4]
341911c4:	695b      	ldr	r3, [r3, #20]
    if ((DMA_InitStruct->SrcAllocatedPort == LL_DMA_SRC_ALLOCATED_PORT0) &&
341911c6:	2b10      	cmp	r3, #16
341911c8:	d901      	bls.n	341911ce <LL_DMA_Init+0x13e>
    {
      return (uint32_t)ERROR;
341911ca:	2301      	movs	r3, #1
341911cc:	e185      	b.n	341914da <LL_DMA_Init+0x44a>
    }
    if ((DMA_InitStruct->DestAllocatedPort == LL_DMA_DEST_ALLOCATED_PORT0) &&
341911ce:	687b      	ldr	r3, [r7, #4]
341911d0:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
341911d2:	2b00      	cmp	r3, #0
341911d4:	d10a      	bne.n	341911ec <LL_DMA_Init+0x15c>
        (DMA_InitStruct->DestBurstLength > 16U))
341911d6:	687b      	ldr	r3, [r7, #4]
341911d8:	699b      	ldr	r3, [r3, #24]
    if ((DMA_InitStruct->DestAllocatedPort == LL_DMA_DEST_ALLOCATED_PORT0) &&
341911da:	2b10      	cmp	r3, #16
341911dc:	d906      	bls.n	341911ec <LL_DMA_Init+0x15c>
    {
      return (uint32_t)ERROR;
341911de:	2301      	movs	r3, #1
341911e0:	e17b      	b.n	341914da <LL_DMA_Init+0x44a>
341911e2:	bf00      	nop
341911e4:	58020000 	.word	0x58020000
341911e8:	50021000 	.word	0x50021000

  /*-------------------------- DMAx CLBAR Configuration ------------------------
   * Configure the Transfer linked list address with parameter :
   * - LinkedListBaseAdd:                              DMA_CLBAR_LBA[31:16] bits
   */
  LL_DMA_SetLinkedListBaseAddr(DMAx, Channel, DMA_InitStruct->LinkedListBaseAddr);
341911ec:	687b      	ldr	r3, [r7, #4]
341911ee:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
341911f2:	461a      	mov	r2, r3
341911f4:	68b9      	ldr	r1, [r7, #8]
341911f6:	68f8      	ldr	r0, [r7, #12]
341911f8:	f7ff fd1a 	bl	34190c30 <LL_DMA_SetLinkedListBaseAddr>
   * Configure the control parameter :
   * - LinkAllocatedPort:                              DMA_CCR_LAP bit
   * - LinkStepMode:                                   DMA_CCR_LSM bit
   * - Priority:                                       DMA_CCR_PRIO [23:22] bits
   */
  LL_DMA_ConfigControl(DMAx, Channel, DMA_InitStruct->Priority | \
341911fc:	687b      	ldr	r3, [r7, #4]
341911fe:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
                       DMA_InitStruct->LinkAllocatedPort       | \
34191200:	687b      	ldr	r3, [r7, #4]
34191202:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
  LL_DMA_ConfigControl(DMAx, Channel, DMA_InitStruct->Priority | \
34191204:	431a      	orrs	r2, r3
                       DMA_InitStruct->LinkStepMode);
34191206:	687b      	ldr	r3, [r7, #4]
34191208:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
  LL_DMA_ConfigControl(DMAx, Channel, DMA_InitStruct->Priority | \
3419120a:	4313      	orrs	r3, r2
3419120c:	461a      	mov	r2, r3
3419120e:	68b9      	ldr	r1, [r7, #8]
34191210:	68f8      	ldr	r0, [r7, #12]
34191212:	f7ff fd31 	bl	34190c78 <LL_DMA_ConfigControl>
   * - SrcIncMode:                                DMA_CTR1_SINC bit
   * - SrcDataWidth:                              DMA_CTR1_SDW_LOG2 [1:0] bits
   * - SrcBurstLength:                            DMA_CTR1_SBL_1 [9:4] bits
   * - DestBurstLength:                           DMA_CTR1_DBL_1 [25:20] bits
   */
  LL_DMA_ConfigTransfer(DMAx, Channel, DMA_InitStruct->DestAllocatedPort | \
34191216:	687b      	ldr	r3, [r7, #4]
34191218:	6e1a      	ldr	r2, [r3, #96]	@ 0x60
                        DMA_InitStruct->DestWordExchange                 | \
3419121a:	687b      	ldr	r3, [r7, #4]
3419121c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
  LL_DMA_ConfigTransfer(DMAx, Channel, DMA_InitStruct->DestAllocatedPort | \
3419121e:	431a      	orrs	r2, r3
                        DMA_InitStruct->DestHWordExchange                | \
34191220:	687b      	ldr	r3, [r7, #4]
34191222:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
                        DMA_InitStruct->DestWordExchange                 | \
34191224:	431a      	orrs	r2, r3
                        DMA_InitStruct->DestByteExchange                 | \
34191226:	687b      	ldr	r3, [r7, #4]
34191228:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
                        DMA_InitStruct->DestHWordExchange                | \
3419122a:	431a      	orrs	r2, r3
                        DMA_InitStruct->DestIncMode                      | \
3419122c:	687b      	ldr	r3, [r7, #4]
3419122e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
                        DMA_InitStruct->DestByteExchange                 | \
34191230:	431a      	orrs	r2, r3
                        DMA_InitStruct->DestDataWidth                    | \
34191232:	687b      	ldr	r3, [r7, #4]
34191234:	6a1b      	ldr	r3, [r3, #32]
                        DMA_InitStruct->DestIncMode                      | \
34191236:	431a      	orrs	r2, r3
                        DMA_InitStruct->SrcAllocatedPort                 | \
34191238:	687b      	ldr	r3, [r7, #4]
3419123a:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
                        DMA_InitStruct->DestDataWidth                    | \
3419123c:	431a      	orrs	r2, r3
                        DMA_InitStruct->SrcByteExchange                  | \
3419123e:	687b      	ldr	r3, [r7, #4]
34191240:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
                        DMA_InitStruct->SrcAllocatedPort                 | \
34191242:	431a      	orrs	r2, r3
                        DMA_InitStruct->DataAlignment                    | \
34191244:	687b      	ldr	r3, [r7, #4]
34191246:	691b      	ldr	r3, [r3, #16]
                        DMA_InitStruct->SrcByteExchange                  | \
34191248:	431a      	orrs	r2, r3
                        DMA_InitStruct->SrcIncMode                       | \
3419124a:	687b      	ldr	r3, [r7, #4]
3419124c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
                        DMA_InitStruct->DataAlignment                    | \
3419124e:	431a      	orrs	r2, r3
                        DMA_InitStruct->SrcDataWidth);
34191250:	687b      	ldr	r3, [r7, #4]
34191252:	69db      	ldr	r3, [r3, #28]
  LL_DMA_ConfigTransfer(DMAx, Channel, DMA_InitStruct->DestAllocatedPort | \
34191254:	4313      	orrs	r3, r2
34191256:	461a      	mov	r2, r3
34191258:	68b9      	ldr	r1, [r7, #8]
3419125a:	68f8      	ldr	r0, [r7, #12]
3419125c:	f7ff fd30 	bl	34190cc0 <LL_DMA_ConfigTransfer>
  /* Check DMA instance */
  if ((IS_LL_HPDMA_CHANNEL_INSTANCE(DMAx, Channel) != 0U) || (IS_LL_GPDMA_CHANNEL_INSTANCE(DMAx, Channel) != 0U))
34191260:	68fb      	ldr	r3, [r7, #12]
34191262:	4a6a      	ldr	r2, [pc, #424]	@ (3419140c <LL_DMA_Init+0x37c>)
34191264:	4293      	cmp	r3, r2
34191266:	d131      	bne.n	341912cc <LL_DMA_Init+0x23c>
34191268:	68bb      	ldr	r3, [r7, #8]
3419126a:	2b00      	cmp	r3, #0
3419126c:	d02c      	beq.n	341912c8 <LL_DMA_Init+0x238>
3419126e:	68bb      	ldr	r3, [r7, #8]
34191270:	2b01      	cmp	r3, #1
34191272:	d029      	beq.n	341912c8 <LL_DMA_Init+0x238>
34191274:	68bb      	ldr	r3, [r7, #8]
34191276:	2b02      	cmp	r3, #2
34191278:	d026      	beq.n	341912c8 <LL_DMA_Init+0x238>
3419127a:	68bb      	ldr	r3, [r7, #8]
3419127c:	2b03      	cmp	r3, #3
3419127e:	d023      	beq.n	341912c8 <LL_DMA_Init+0x238>
34191280:	68bb      	ldr	r3, [r7, #8]
34191282:	2b04      	cmp	r3, #4
34191284:	d020      	beq.n	341912c8 <LL_DMA_Init+0x238>
34191286:	68bb      	ldr	r3, [r7, #8]
34191288:	2b05      	cmp	r3, #5
3419128a:	d01d      	beq.n	341912c8 <LL_DMA_Init+0x238>
3419128c:	68bb      	ldr	r3, [r7, #8]
3419128e:	2b06      	cmp	r3, #6
34191290:	d01a      	beq.n	341912c8 <LL_DMA_Init+0x238>
34191292:	68bb      	ldr	r3, [r7, #8]
34191294:	2b07      	cmp	r3, #7
34191296:	d017      	beq.n	341912c8 <LL_DMA_Init+0x238>
34191298:	68bb      	ldr	r3, [r7, #8]
3419129a:	2b08      	cmp	r3, #8
3419129c:	d014      	beq.n	341912c8 <LL_DMA_Init+0x238>
3419129e:	68bb      	ldr	r3, [r7, #8]
341912a0:	2b09      	cmp	r3, #9
341912a2:	d011      	beq.n	341912c8 <LL_DMA_Init+0x238>
341912a4:	68bb      	ldr	r3, [r7, #8]
341912a6:	2b0a      	cmp	r3, #10
341912a8:	d00e      	beq.n	341912c8 <LL_DMA_Init+0x238>
341912aa:	68bb      	ldr	r3, [r7, #8]
341912ac:	2b0b      	cmp	r3, #11
341912ae:	d00b      	beq.n	341912c8 <LL_DMA_Init+0x238>
341912b0:	68bb      	ldr	r3, [r7, #8]
341912b2:	2b0c      	cmp	r3, #12
341912b4:	d008      	beq.n	341912c8 <LL_DMA_Init+0x238>
341912b6:	68bb      	ldr	r3, [r7, #8]
341912b8:	2b0d      	cmp	r3, #13
341912ba:	d005      	beq.n	341912c8 <LL_DMA_Init+0x238>
341912bc:	68bb      	ldr	r3, [r7, #8]
341912be:	2b0e      	cmp	r3, #14
341912c0:	d002      	beq.n	341912c8 <LL_DMA_Init+0x238>
341912c2:	68bb      	ldr	r3, [r7, #8]
341912c4:	2b0f      	cmp	r3, #15
341912c6:	d101      	bne.n	341912cc <LL_DMA_Init+0x23c>
341912c8:	2301      	movs	r3, #1
341912ca:	e000      	b.n	341912ce <LL_DMA_Init+0x23e>
341912cc:	2300      	movs	r3, #0
341912ce:	2b00      	cmp	r3, #0
341912d0:	d138      	bne.n	34191344 <LL_DMA_Init+0x2b4>
341912d2:	68fb      	ldr	r3, [r7, #12]
341912d4:	4a4e      	ldr	r2, [pc, #312]	@ (34191410 <LL_DMA_Init+0x380>)
341912d6:	4293      	cmp	r3, r2
341912d8:	d131      	bne.n	3419133e <LL_DMA_Init+0x2ae>
341912da:	68bb      	ldr	r3, [r7, #8]
341912dc:	2b00      	cmp	r3, #0
341912de:	d02c      	beq.n	3419133a <LL_DMA_Init+0x2aa>
341912e0:	68bb      	ldr	r3, [r7, #8]
341912e2:	2b01      	cmp	r3, #1
341912e4:	d029      	beq.n	3419133a <LL_DMA_Init+0x2aa>
341912e6:	68bb      	ldr	r3, [r7, #8]
341912e8:	2b02      	cmp	r3, #2
341912ea:	d026      	beq.n	3419133a <LL_DMA_Init+0x2aa>
341912ec:	68bb      	ldr	r3, [r7, #8]
341912ee:	2b03      	cmp	r3, #3
341912f0:	d023      	beq.n	3419133a <LL_DMA_Init+0x2aa>
341912f2:	68bb      	ldr	r3, [r7, #8]
341912f4:	2b04      	cmp	r3, #4
341912f6:	d020      	beq.n	3419133a <LL_DMA_Init+0x2aa>
341912f8:	68bb      	ldr	r3, [r7, #8]
341912fa:	2b05      	cmp	r3, #5
341912fc:	d01d      	beq.n	3419133a <LL_DMA_Init+0x2aa>
341912fe:	68bb      	ldr	r3, [r7, #8]
34191300:	2b06      	cmp	r3, #6
34191302:	d01a      	beq.n	3419133a <LL_DMA_Init+0x2aa>
34191304:	68bb      	ldr	r3, [r7, #8]
34191306:	2b07      	cmp	r3, #7
34191308:	d017      	beq.n	3419133a <LL_DMA_Init+0x2aa>
3419130a:	68bb      	ldr	r3, [r7, #8]
3419130c:	2b08      	cmp	r3, #8
3419130e:	d014      	beq.n	3419133a <LL_DMA_Init+0x2aa>
34191310:	68bb      	ldr	r3, [r7, #8]
34191312:	2b09      	cmp	r3, #9
34191314:	d011      	beq.n	3419133a <LL_DMA_Init+0x2aa>
34191316:	68bb      	ldr	r3, [r7, #8]
34191318:	2b0a      	cmp	r3, #10
3419131a:	d00e      	beq.n	3419133a <LL_DMA_Init+0x2aa>
3419131c:	68bb      	ldr	r3, [r7, #8]
3419131e:	2b0b      	cmp	r3, #11
34191320:	d00b      	beq.n	3419133a <LL_DMA_Init+0x2aa>
34191322:	68bb      	ldr	r3, [r7, #8]
34191324:	2b0c      	cmp	r3, #12
34191326:	d008      	beq.n	3419133a <LL_DMA_Init+0x2aa>
34191328:	68bb      	ldr	r3, [r7, #8]
3419132a:	2b0d      	cmp	r3, #13
3419132c:	d005      	beq.n	3419133a <LL_DMA_Init+0x2aa>
3419132e:	68bb      	ldr	r3, [r7, #8]
34191330:	2b0e      	cmp	r3, #14
34191332:	d002      	beq.n	3419133a <LL_DMA_Init+0x2aa>
34191334:	68bb      	ldr	r3, [r7, #8]
34191336:	2b0f      	cmp	r3, #15
34191338:	d101      	bne.n	3419133e <LL_DMA_Init+0x2ae>
3419133a:	2301      	movs	r3, #1
3419133c:	e000      	b.n	34191340 <LL_DMA_Init+0x2b0>
3419133e:	2300      	movs	r3, #0
34191340:	2b00      	cmp	r3, #0
34191342:	d007      	beq.n	34191354 <LL_DMA_Init+0x2c4>
  {
    LL_DMA_ConfigBurstLength(DMAx, Channel,  DMA_InitStruct->SrcBurstLength,
34191344:	687b      	ldr	r3, [r7, #4]
34191346:	695a      	ldr	r2, [r3, #20]
34191348:	687b      	ldr	r3, [r7, #4]
3419134a:	699b      	ldr	r3, [r3, #24]
3419134c:	68b9      	ldr	r1, [r7, #8]
3419134e:	68f8      	ldr	r0, [r7, #12]
34191350:	f7ff fcdc 	bl	34190d0c <LL_DMA_ConfigBurstLength>
   * - Direction:                                  DMA_CTR2_DREQ bit
   * - Direction:                                  DMA_CTR2_SWREQ bit
   * - TriggerSelection:                           DMA_CTR2_TRIGSEL [21:16] bits
   * - Request:                                    DMA_CTR2_REQSEL [6:0] bits
   */
  LL_DMA_ConfigChannelTransfer(DMAx, Channel, DMA_InitStruct->TransferEventMode | \
34191354:	687b      	ldr	r3, [r7, #4]
34191356:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
                               DMA_InitStruct->TriggerPolarity                  | \
34191358:	687b      	ldr	r3, [r7, #4]
3419135a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
  LL_DMA_ConfigChannelTransfer(DMAx, Channel, DMA_InitStruct->TransferEventMode | \
3419135c:	431a      	orrs	r2, r3
                               DMA_InitStruct->BlkHWRequest                     | \
3419135e:	687b      	ldr	r3, [r7, #4]
34191360:	68db      	ldr	r3, [r3, #12]
                               DMA_InitStruct->TriggerPolarity                  | \
34191362:	431a      	orrs	r2, r3
                               DMA_InitStruct->Mode                             | \
34191364:	687b      	ldr	r3, [r7, #4]
34191366:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
                               DMA_InitStruct->BlkHWRequest                     | \
3419136a:	431a      	orrs	r2, r3
                               DMA_InitStruct->Direction);
3419136c:	687b      	ldr	r3, [r7, #4]
3419136e:	689b      	ldr	r3, [r3, #8]
  LL_DMA_ConfigChannelTransfer(DMAx, Channel, DMA_InitStruct->TransferEventMode | \
34191370:	4313      	orrs	r3, r2
34191372:	461a      	mov	r2, r3
34191374:	68b9      	ldr	r1, [r7, #8]
34191376:	68f8      	ldr	r0, [r7, #12]
34191378:	f7ff fcf8 	bl	34190d6c <LL_DMA_ConfigChannelTransfer>

  /* Check direction */
  if (DMA_InitStruct->Direction != LL_DMA_DIRECTION_MEMORY_TO_MEMORY)
3419137c:	687b      	ldr	r3, [r7, #4]
3419137e:	689b      	ldr	r3, [r3, #8]
34191380:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
34191384:	d006      	beq.n	34191394 <LL_DMA_Init+0x304>
  {
    LL_DMA_SetPeriphRequest(DMAx, Channel, DMA_InitStruct->Request);
34191386:	687b      	ldr	r3, [r7, #4]
34191388:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3419138a:	461a      	mov	r2, r3
3419138c:	68b9      	ldr	r1, [r7, #8]
3419138e:	68f8      	ldr	r0, [r7, #12]
34191390:	f7ff fd36 	bl	34190e00 <LL_DMA_SetPeriphRequest>
  }

  /* Check trigger polarity */
  if (DMA_InitStruct->TriggerPolarity != LL_DMA_TRIG_POLARITY_MASKED)
34191394:	687b      	ldr	r3, [r7, #4]
34191396:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34191398:	2b00      	cmp	r3, #0
3419139a:	d00d      	beq.n	341913b8 <LL_DMA_Init+0x328>
  {
    LL_DMA_SetHWTrigger(DMAx, Channel, DMA_InitStruct->TriggerSelection);
3419139c:	687b      	ldr	r3, [r7, #4]
3419139e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
341913a0:	461a      	mov	r2, r3
341913a2:	68b9      	ldr	r1, [r7, #8]
341913a4:	68f8      	ldr	r0, [r7, #12]
341913a6:	f7ff fd4f 	bl	34190e48 <LL_DMA_SetHWTrigger>
    LL_DMA_SetTriggerMode(DMAx, Channel, DMA_InitStruct->TriggerMode);
341913aa:	687b      	ldr	r3, [r7, #4]
341913ac:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
341913ae:	461a      	mov	r2, r3
341913b0:	68b9      	ldr	r1, [r7, #8]
341913b2:	68f8      	ldr	r0, [r7, #12]
341913b4:	f7ff fd00 	bl	34190db8 <LL_DMA_SetTriggerMode>
   * - SrcAddrUpdateMode:                                      DMA_CBR1_SDEC bit
   *   SrcAddrUpdateMode field is supported only by 2D addressing channels.
   * - DestAddrUpdateMode:                                     DMA_CBR1_DDEC bit
   *   DestAddrUpdateMode field is supported only by 2D addressing channels.
   */
  LL_DMA_SetBlkDataLength(DMAx, Channel, DMA_InitStruct->BlkDataLength);
341913b8:	687b      	ldr	r3, [r7, #4]
341913ba:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
341913bc:	461a      	mov	r2, r3
341913be:	68b9      	ldr	r1, [r7, #8]
341913c0:	68f8      	ldr	r0, [r7, #12]
341913c2:	f7ff fdb5 	bl	34190f30 <LL_DMA_SetBlkDataLength>

  /* Check DMA channel */
  if (IS_LL_DMA_2D_CHANNEL_INSTANCE(DMAx, Channel) != 0U)
341913c6:	68fb      	ldr	r3, [r7, #12]
341913c8:	4a10      	ldr	r2, [pc, #64]	@ (3419140c <LL_DMA_Init+0x37c>)
341913ca:	4293      	cmp	r3, r2
341913cc:	d10b      	bne.n	341913e6 <LL_DMA_Init+0x356>
341913ce:	68bb      	ldr	r3, [r7, #8]
341913d0:	2b0c      	cmp	r3, #12
341913d2:	d018      	beq.n	34191406 <LL_DMA_Init+0x376>
341913d4:	68bb      	ldr	r3, [r7, #8]
341913d6:	2b0d      	cmp	r3, #13
341913d8:	d015      	beq.n	34191406 <LL_DMA_Init+0x376>
341913da:	68bb      	ldr	r3, [r7, #8]
341913dc:	2b0e      	cmp	r3, #14
341913de:	d012      	beq.n	34191406 <LL_DMA_Init+0x376>
341913e0:	68bb      	ldr	r3, [r7, #8]
341913e2:	2b0f      	cmp	r3, #15
341913e4:	d00f      	beq.n	34191406 <LL_DMA_Init+0x376>
341913e6:	68fb      	ldr	r3, [r7, #12]
341913e8:	4a09      	ldr	r2, [pc, #36]	@ (34191410 <LL_DMA_Init+0x380>)
341913ea:	4293      	cmp	r3, r2
341913ec:	d112      	bne.n	34191414 <LL_DMA_Init+0x384>
341913ee:	68bb      	ldr	r3, [r7, #8]
341913f0:	2b0c      	cmp	r3, #12
341913f2:	d008      	beq.n	34191406 <LL_DMA_Init+0x376>
341913f4:	68bb      	ldr	r3, [r7, #8]
341913f6:	2b0d      	cmp	r3, #13
341913f8:	d005      	beq.n	34191406 <LL_DMA_Init+0x376>
341913fa:	68bb      	ldr	r3, [r7, #8]
341913fc:	2b0e      	cmp	r3, #14
341913fe:	d002      	beq.n	34191406 <LL_DMA_Init+0x376>
34191400:	68bb      	ldr	r3, [r7, #8]
34191402:	2b0f      	cmp	r3, #15
34191404:	d106      	bne.n	34191414 <LL_DMA_Init+0x384>
34191406:	2301      	movs	r3, #1
34191408:	e005      	b.n	34191416 <LL_DMA_Init+0x386>
3419140a:	bf00      	nop
3419140c:	58020000 	.word	0x58020000
34191410:	50021000 	.word	0x50021000
34191414:	2300      	movs	r3, #0
34191416:	2b00      	cmp	r3, #0
34191418:	d017      	beq.n	3419144a <LL_DMA_Init+0x3ba>
  {
    LL_DMA_SetBlkRptCount(DMAx, Channel, DMA_InitStruct->BlkRptCount);
3419141a:	687b      	ldr	r3, [r7, #4]
3419141c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3419141e:	461a      	mov	r2, r3
34191420:	68b9      	ldr	r1, [r7, #8]
34191422:	68f8      	ldr	r0, [r7, #12]
34191424:	f7ff fd5a 	bl	34190edc <LL_DMA_SetBlkRptCount>
    LL_DMA_ConfigBlkRptAddrUpdate(DMAx, Channel, DMA_InitStruct->BlkRptSrcAddrUpdateMode  | \
34191428:	687b      	ldr	r3, [r7, #4]
3419142a:	6fda      	ldr	r2, [r3, #124]	@ 0x7c
                                  DMA_InitStruct->BlkRptDestAddrUpdateMode                | \
3419142c:	687b      	ldr	r3, [r7, #4]
3419142e:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
    LL_DMA_ConfigBlkRptAddrUpdate(DMAx, Channel, DMA_InitStruct->BlkRptSrcAddrUpdateMode  | \
34191432:	431a      	orrs	r2, r3
                                  DMA_InitStruct->SrcAddrUpdateMode                       | \
34191434:	687b      	ldr	r3, [r7, #4]
34191436:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
                                  DMA_InitStruct->BlkRptDestAddrUpdateMode                | \
34191438:	431a      	orrs	r2, r3
                                  DMA_InitStruct->DestAddrUpdateMode);
3419143a:	687b      	ldr	r3, [r7, #4]
3419143c:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
    LL_DMA_ConfigBlkRptAddrUpdate(DMAx, Channel, DMA_InitStruct->BlkRptSrcAddrUpdateMode  | \
3419143e:	4313      	orrs	r3, r2
34191440:	461a      	mov	r2, r3
34191442:	68b9      	ldr	r1, [r7, #8]
34191444:	68f8      	ldr	r0, [r7, #12]
34191446:	f7ff fd25 	bl	34190e94 <LL_DMA_ConfigBlkRptAddrUpdate>
  /*-------------------------- DMAx CSAR and CDAR Configuration ----------------
   * Configure the Transfer source address with parameter :
   * - SrcAddress:                                        DMA_CSAR_SA[31:0] bits
   * - DestAddress:                                       DMA_CDAR_DA[31:0] bits
   */
  LL_DMA_ConfigAddresses(DMAx, Channel, DMA_InitStruct->SrcAddress, DMA_InitStruct->DestAddress);
3419144a:	687b      	ldr	r3, [r7, #4]
3419144c:	681a      	ldr	r2, [r3, #0]
3419144e:	687b      	ldr	r3, [r7, #4]
34191450:	685b      	ldr	r3, [r3, #4]
34191452:	68b9      	ldr	r1, [r7, #8]
34191454:	68f8      	ldr	r0, [r7, #12]
34191456:	f7ff fd8f 	bl	34190f78 <LL_DMA_ConfigAddresses>

  /* Check DMA channel */
  if (IS_LL_DMA_2D_CHANNEL_INSTANCE(DMAx, Channel) != 0U)
3419145a:	68fb      	ldr	r3, [r7, #12]
3419145c:	4a21      	ldr	r2, [pc, #132]	@ (341914e4 <LL_DMA_Init+0x454>)
3419145e:	4293      	cmp	r3, r2
34191460:	d10b      	bne.n	3419147a <LL_DMA_Init+0x3ea>
34191462:	68bb      	ldr	r3, [r7, #8]
34191464:	2b0c      	cmp	r3, #12
34191466:	d018      	beq.n	3419149a <LL_DMA_Init+0x40a>
34191468:	68bb      	ldr	r3, [r7, #8]
3419146a:	2b0d      	cmp	r3, #13
3419146c:	d015      	beq.n	3419149a <LL_DMA_Init+0x40a>
3419146e:	68bb      	ldr	r3, [r7, #8]
34191470:	2b0e      	cmp	r3, #14
34191472:	d012      	beq.n	3419149a <LL_DMA_Init+0x40a>
34191474:	68bb      	ldr	r3, [r7, #8]
34191476:	2b0f      	cmp	r3, #15
34191478:	d00f      	beq.n	3419149a <LL_DMA_Init+0x40a>
3419147a:	68fb      	ldr	r3, [r7, #12]
3419147c:	4a1a      	ldr	r2, [pc, #104]	@ (341914e8 <LL_DMA_Init+0x458>)
3419147e:	4293      	cmp	r3, r2
34191480:	d10d      	bne.n	3419149e <LL_DMA_Init+0x40e>
34191482:	68bb      	ldr	r3, [r7, #8]
34191484:	2b0c      	cmp	r3, #12
34191486:	d008      	beq.n	3419149a <LL_DMA_Init+0x40a>
34191488:	68bb      	ldr	r3, [r7, #8]
3419148a:	2b0d      	cmp	r3, #13
3419148c:	d005      	beq.n	3419149a <LL_DMA_Init+0x40a>
3419148e:	68bb      	ldr	r3, [r7, #8]
34191490:	2b0e      	cmp	r3, #14
34191492:	d002      	beq.n	3419149a <LL_DMA_Init+0x40a>
34191494:	68bb      	ldr	r3, [r7, #8]
34191496:	2b0f      	cmp	r3, #15
34191498:	d101      	bne.n	3419149e <LL_DMA_Init+0x40e>
3419149a:	2301      	movs	r3, #1
3419149c:	e000      	b.n	341914a0 <LL_DMA_Init+0x410>
3419149e:	2300      	movs	r3, #0
341914a0:	2b00      	cmp	r3, #0
341914a2:	d011      	beq.n	341914c8 <LL_DMA_Init+0x438>
     * - SrcAddrOffset:                                 DMA_CTR3_SAO[28:16] bits
     *   SrcAddrOffset field is supported only by 2D addressing channels.
     * - DestAddrOffset:                                DMA_CTR3_DAO[12:0] bits
     *   DestAddrOffset field is supported only by 2D addressing channels.
     */
    LL_DMA_ConfigAddrUpdateValue(DMAx, Channel, DMA_InitStruct->SrcAddrOffset, DMA_InitStruct->DestAddrOffset);
341914a4:	687b      	ldr	r3, [r7, #4]
341914a6:	6f5a      	ldr	r2, [r3, #116]	@ 0x74
341914a8:	687b      	ldr	r3, [r7, #4]
341914aa:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
341914ac:	68b9      	ldr	r1, [r7, #8]
341914ae:	68f8      	ldr	r0, [r7, #12]
341914b0:	f7ff fd86 	bl	34190fc0 <LL_DMA_ConfigAddrUpdateValue>
     * - BlkRptSrcAddrOffset:                         DMA_CBR2_BRSAO[15:0] bits
     *   BlkRptSrcAddrOffset field is supported only by 2D addressing channels.
     * - BlkRptDestAddrOffset:                        DMA_CBR2_BRDAO[31:16] bits
     *   BlkRptDestAddrOffset field is supported only by 2D addressing channels.
     */
    LL_DMA_ConfigBlkRptAddrUpdateValue(DMAx, Channel, DMA_InitStruct->BlkRptSrcAddrOffset,
341914b4:	687b      	ldr	r3, [r7, #4]
341914b6:	f8d3 2084 	ldr.w	r2, [r3, #132]	@ 0x84
341914ba:	687b      	ldr	r3, [r7, #4]
341914bc:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
341914c0:	68b9      	ldr	r1, [r7, #8]
341914c2:	68f8      	ldr	r0, [r7, #12]
341914c4:	f7ff fd9e 	bl	34191004 <LL_DMA_ConfigBlkRptAddrUpdateValue>

  /*-------------------------- DMAx CLLR Configuration -------------------------
   * Configure the Transfer linked list address with parameter :
   * - DestAddrOffset:                                    DMA_CLLR_LA[15:2] bits
   */
  LL_DMA_SetLinkedListAddrOffset(DMAx, Channel, DMA_InitStruct->LinkedListAddrOffset);
341914c8:	687b      	ldr	r3, [r7, #4]
341914ca:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
341914ce:	461a      	mov	r2, r3
341914d0:	68b9      	ldr	r1, [r7, #8]
341914d2:	68f8      	ldr	r0, [r7, #12]
341914d4:	f7ff fdb4 	bl	34191040 <LL_DMA_SetLinkedListAddrOffset>

  return (uint32_t)SUCCESS;
341914d8:	2300      	movs	r3, #0
}
341914da:	4618      	mov	r0, r3
341914dc:	3710      	adds	r7, #16
341914de:	46bd      	mov	sp, r7
341914e0:	bd80      	pop	{r7, pc}
341914e2:	bf00      	nop
341914e4:	58020000 	.word	0x58020000
341914e8:	50021000 	.word	0x50021000

341914ec <SDMMC_Init>:
  * @param  SDMMCx: Pointer to SDMMC register base
  * @param  Init: SDMMC initialization structure
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_Init(SDMMC_TypeDef *SDMMCx, SDMMC_InitTypeDef Init)
{
341914ec:	b084      	sub	sp, #16
341914ee:	b480      	push	{r7}
341914f0:	b085      	sub	sp, #20
341914f2:	af00      	add	r7, sp, #0
341914f4:	6078      	str	r0, [r7, #4]
341914f6:	f107 001c 	add.w	r0, r7, #28
341914fa:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  uint32_t tmpreg = 0;
341914fe:	2300      	movs	r3, #0
34191500:	60fb      	str	r3, [r7, #12]
  assert_param(IS_SDMMC_BUS_WIDE(Init.BusWide));
  assert_param(IS_SDMMC_HARDWARE_FLOW_CONTROL(Init.HardwareFlowControl));
  assert_param(IS_SDMMC_CLKDIV(Init.ClockDiv));

  /* Set SDMMC configuration parameters */
  tmpreg |= (Init.ClockEdge           | \
34191502:	69fa      	ldr	r2, [r7, #28]
             Init.ClockPowerSave      | \
34191504:	6a3b      	ldr	r3, [r7, #32]
  tmpreg |= (Init.ClockEdge           | \
34191506:	431a      	orrs	r2, r3
             Init.BusWide             | \
34191508:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
             Init.ClockPowerSave      | \
3419150a:	431a      	orrs	r2, r3
             Init.HardwareFlowControl | \
3419150c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
             Init.BusWide             | \
3419150e:	431a      	orrs	r2, r3
             Init.ClockDiv
34191510:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
             Init.HardwareFlowControl | \
34191512:	4313      	orrs	r3, r2
  tmpreg |= (Init.ClockEdge           | \
34191514:	68fa      	ldr	r2, [r7, #12]
34191516:	4313      	orrs	r3, r2
34191518:	60fb      	str	r3, [r7, #12]
            );

  /* Write to SDMMC CLKCR */
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);
3419151a:	687b      	ldr	r3, [r7, #4]
3419151c:	685a      	ldr	r2, [r3, #4]
3419151e:	4b07      	ldr	r3, [pc, #28]	@ (3419153c <SDMMC_Init+0x50>)
34191520:	4013      	ands	r3, r2
34191522:	68fa      	ldr	r2, [r7, #12]
34191524:	431a      	orrs	r2, r3
34191526:	687b      	ldr	r3, [r7, #4]
34191528:	605a      	str	r2, [r3, #4]

  return HAL_OK;
3419152a:	2300      	movs	r3, #0
}
3419152c:	4618      	mov	r0, r3
3419152e:	3714      	adds	r7, #20
34191530:	46bd      	mov	sp, r7
34191532:	f85d 7b04 	ldr.w	r7, [sp], #4
34191536:	b004      	add	sp, #16
34191538:	4770      	bx	lr
3419153a:	bf00      	nop
3419153c:	ffc02c00 	.word	0xffc02c00

34191540 <SDMMC_ReadFIFO>:
  * @brief  Read data (word) from Rx FIFO in blocking mode (polling)
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_ReadFIFO(const SDMMC_TypeDef *SDMMCx)
{
34191540:	b480      	push	{r7}
34191542:	b083      	sub	sp, #12
34191544:	af00      	add	r7, sp, #0
34191546:	6078      	str	r0, [r7, #4]
  /* Read data from Rx FIFO */
  return (SDMMCx->FIFO);
34191548:	687b      	ldr	r3, [r7, #4]
3419154a:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
}
3419154e:	4618      	mov	r0, r3
34191550:	370c      	adds	r7, #12
34191552:	46bd      	mov	sp, r7
34191554:	f85d 7b04 	ldr.w	r7, [sp], #4
34191558:	4770      	bx	lr

3419155a <SDMMC_WriteFIFO>:
  * @param  SDMMCx: Pointer to SDMMC register base
  * @param  pWriteData: pointer to data to write
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_WriteFIFO(SDMMC_TypeDef *SDMMCx, uint32_t *pWriteData)
{
3419155a:	b480      	push	{r7}
3419155c:	b083      	sub	sp, #12
3419155e:	af00      	add	r7, sp, #0
34191560:	6078      	str	r0, [r7, #4]
34191562:	6039      	str	r1, [r7, #0]
  /* Write data to FIFO */
  SDMMCx->FIFO = *pWriteData;
34191564:	683b      	ldr	r3, [r7, #0]
34191566:	681a      	ldr	r2, [r3, #0]
34191568:	687b      	ldr	r3, [r7, #4]
3419156a:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

  return HAL_OK;
3419156e:	2300      	movs	r3, #0
}
34191570:	4618      	mov	r0, r3
34191572:	370c      	adds	r7, #12
34191574:	46bd      	mov	sp, r7
34191576:	f85d 7b04 	ldr.w	r7, [sp], #4
3419157a:	4770      	bx	lr

3419157c <SDMMC_PowerState_ON>:
  * @brief  Set SDMMC Power state to ON.
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_PowerState_ON(SDMMC_TypeDef *SDMMCx)
{
3419157c:	b480      	push	{r7}
3419157e:	b083      	sub	sp, #12
34191580:	af00      	add	r7, sp, #0
34191582:	6078      	str	r0, [r7, #4]
  /* Set power state to ON */
  SDMMCx->POWER |= SDMMC_POWER_PWRCTRL;
34191584:	687b      	ldr	r3, [r7, #4]
34191586:	681b      	ldr	r3, [r3, #0]
34191588:	f043 0203 	orr.w	r2, r3, #3
3419158c:	687b      	ldr	r3, [r7, #4]
3419158e:	601a      	str	r2, [r3, #0]

  return HAL_OK;
34191590:	2300      	movs	r3, #0
}
34191592:	4618      	mov	r0, r3
34191594:	370c      	adds	r7, #12
34191596:	46bd      	mov	sp, r7
34191598:	f85d 7b04 	ldr.w	r7, [sp], #4
3419159c:	4770      	bx	lr

3419159e <SDMMC_GetPowerState>:
  *            - 0x00: Power OFF
  *            - 0x02: Power UP
  *            - 0x03: Power ON
  */
uint32_t SDMMC_GetPowerState(const SDMMC_TypeDef *SDMMCx)
{
3419159e:	b480      	push	{r7}
341915a0:	b083      	sub	sp, #12
341915a2:	af00      	add	r7, sp, #0
341915a4:	6078      	str	r0, [r7, #4]
  return (SDMMCx->POWER & SDMMC_POWER_PWRCTRL);
341915a6:	687b      	ldr	r3, [r7, #4]
341915a8:	681b      	ldr	r3, [r3, #0]
341915aa:	f003 0303 	and.w	r3, r3, #3
}
341915ae:	4618      	mov	r0, r3
341915b0:	370c      	adds	r7, #12
341915b2:	46bd      	mov	sp, r7
341915b4:	f85d 7b04 	ldr.w	r7, [sp], #4
341915b8:	4770      	bx	lr
	...

341915bc <SDMMC_SendCommand>:
  * @param  Command: pointer to a SDMMC_CmdInitTypeDef structure that contains
  *         the configuration information for the SDMMC command
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_SendCommand(SDMMC_TypeDef *SDMMCx, const SDMMC_CmdInitTypeDef *Command)
{
341915bc:	b480      	push	{r7}
341915be:	b085      	sub	sp, #20
341915c0:	af00      	add	r7, sp, #0
341915c2:	6078      	str	r0, [r7, #4]
341915c4:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
341915c6:	2300      	movs	r3, #0
341915c8:	60fb      	str	r3, [r7, #12]
  assert_param(IS_SDMMC_RESPONSE(Command->Response));
  assert_param(IS_SDMMC_WAIT(Command->WaitForInterrupt));
  assert_param(IS_SDMMC_CPSM(Command->CPSM));

  /* Set the SDMMC Argument value */
  SDMMCx->ARG = Command->Argument;
341915ca:	683b      	ldr	r3, [r7, #0]
341915cc:	681a      	ldr	r2, [r3, #0]
341915ce:	687b      	ldr	r3, [r7, #4]
341915d0:	609a      	str	r2, [r3, #8]

  /* Set SDMMC command parameters */
  tmpreg |= (uint32_t)(Command->CmdIndex         | \
341915d2:	683b      	ldr	r3, [r7, #0]
341915d4:	685a      	ldr	r2, [r3, #4]
                       Command->Response         | \
341915d6:	683b      	ldr	r3, [r7, #0]
341915d8:	689b      	ldr	r3, [r3, #8]
  tmpreg |= (uint32_t)(Command->CmdIndex         | \
341915da:	431a      	orrs	r2, r3
                       Command->WaitForInterrupt | \
341915dc:	683b      	ldr	r3, [r7, #0]
341915de:	68db      	ldr	r3, [r3, #12]
                       Command->Response         | \
341915e0:	431a      	orrs	r2, r3
                       Command->CPSM);
341915e2:	683b      	ldr	r3, [r7, #0]
341915e4:	691b      	ldr	r3, [r3, #16]
                       Command->WaitForInterrupt | \
341915e6:	4313      	orrs	r3, r2
  tmpreg |= (uint32_t)(Command->CmdIndex         | \
341915e8:	68fa      	ldr	r2, [r7, #12]
341915ea:	4313      	orrs	r3, r2
341915ec:	60fb      	str	r3, [r7, #12]

  /* Write to SDMMC CMD register */
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
341915ee:	687b      	ldr	r3, [r7, #4]
341915f0:	68da      	ldr	r2, [r3, #12]
341915f2:	4b06      	ldr	r3, [pc, #24]	@ (3419160c <SDMMC_SendCommand+0x50>)
341915f4:	4013      	ands	r3, r2
341915f6:	68fa      	ldr	r2, [r7, #12]
341915f8:	431a      	orrs	r2, r3
341915fa:	687b      	ldr	r3, [r7, #4]
341915fc:	60da      	str	r2, [r3, #12]

  return HAL_OK;
341915fe:	2300      	movs	r3, #0
}
34191600:	4618      	mov	r0, r3
34191602:	3714      	adds	r7, #20
34191604:	46bd      	mov	sp, r7
34191606:	f85d 7b04 	ldr.w	r7, [sp], #4
3419160a:	4770      	bx	lr
3419160c:	fffee0c0 	.word	0xfffee0c0

34191610 <SDMMC_GetCommandResponse>:
  * @brief  Return the command index of last command for which response received
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval Command index of the last command response received
  */
uint8_t SDMMC_GetCommandResponse(const SDMMC_TypeDef *SDMMCx)
{
34191610:	b480      	push	{r7}
34191612:	b083      	sub	sp, #12
34191614:	af00      	add	r7, sp, #0
34191616:	6078      	str	r0, [r7, #4]
  return (uint8_t)(SDMMCx->RESPCMD);
34191618:	687b      	ldr	r3, [r7, #4]
3419161a:	691b      	ldr	r3, [r3, #16]
3419161c:	b2db      	uxtb	r3, r3
}
3419161e:	4618      	mov	r0, r3
34191620:	370c      	adds	r7, #12
34191622:	46bd      	mov	sp, r7
34191624:	f85d 7b04 	ldr.w	r7, [sp], #4
34191628:	4770      	bx	lr

3419162a <SDMMC_GetResponse>:
  *            @arg SDMMC_RESP3: Response Register 3
  *            @arg SDMMC_RESP4: Response Register 4
  * @retval The Corresponding response register value
  */
uint32_t SDMMC_GetResponse(const SDMMC_TypeDef *SDMMCx, uint32_t Response)
{
3419162a:	b480      	push	{r7}
3419162c:	b085      	sub	sp, #20
3419162e:	af00      	add	r7, sp, #0
34191630:	6078      	str	r0, [r7, #4]
34191632:	6039      	str	r1, [r7, #0]

  /* Check the parameters */
  assert_param(IS_SDMMC_RESP(Response));

  /* Get the response */
  tmp = (uint32_t)(&(SDMMCx->RESP1)) + Response;
34191634:	687b      	ldr	r3, [r7, #4]
34191636:	3314      	adds	r3, #20
34191638:	461a      	mov	r2, r3
3419163a:	683b      	ldr	r3, [r7, #0]
3419163c:	4413      	add	r3, r2
3419163e:	60fb      	str	r3, [r7, #12]

  return (*(__IO uint32_t *) tmp);
34191640:	68fb      	ldr	r3, [r7, #12]
34191642:	681b      	ldr	r3, [r3, #0]
}
34191644:	4618      	mov	r0, r3
34191646:	3714      	adds	r7, #20
34191648:	46bd      	mov	sp, r7
3419164a:	f85d 7b04 	ldr.w	r7, [sp], #4
3419164e:	4770      	bx	lr

34191650 <SDMMC_ConfigData>:
  * @param  Data : pointer to a SDMMC_DataInitTypeDef structure
  *         that contains the configuration information for the SDMMC data.
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_ConfigData(SDMMC_TypeDef *SDMMCx, const SDMMC_DataInitTypeDef *Data)
{
34191650:	b480      	push	{r7}
34191652:	b085      	sub	sp, #20
34191654:	af00      	add	r7, sp, #0
34191656:	6078      	str	r0, [r7, #4]
34191658:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
3419165a:	2300      	movs	r3, #0
3419165c:	60fb      	str	r3, [r7, #12]
  assert_param(IS_SDMMC_TRANSFER_DIR(Data->TransferDir));
  assert_param(IS_SDMMC_TRANSFER_MODE(Data->TransferMode));
  assert_param(IS_SDMMC_DPSM(Data->DPSM));

  /* Set the SDMMC Data TimeOut value */
  SDMMCx->DTIMER = Data->DataTimeOut;
3419165e:	683b      	ldr	r3, [r7, #0]
34191660:	681a      	ldr	r2, [r3, #0]
34191662:	687b      	ldr	r3, [r7, #4]
34191664:	625a      	str	r2, [r3, #36]	@ 0x24

  /* Set the SDMMC DataLength value */
  SDMMCx->DLEN = Data->DataLength;
34191666:	683b      	ldr	r3, [r7, #0]
34191668:	685a      	ldr	r2, [r3, #4]
3419166a:	687b      	ldr	r3, [r7, #4]
3419166c:	629a      	str	r2, [r3, #40]	@ 0x28

  /* Set the SDMMC data configuration parameters */
  tmpreg |= (uint32_t)(Data->DataBlockSize | \
3419166e:	683b      	ldr	r3, [r7, #0]
34191670:	689a      	ldr	r2, [r3, #8]
                       Data->TransferDir   | \
34191672:	683b      	ldr	r3, [r7, #0]
34191674:	68db      	ldr	r3, [r3, #12]
  tmpreg |= (uint32_t)(Data->DataBlockSize | \
34191676:	431a      	orrs	r2, r3
                       Data->TransferMode  | \
34191678:	683b      	ldr	r3, [r7, #0]
3419167a:	691b      	ldr	r3, [r3, #16]
                       Data->TransferDir   | \
3419167c:	431a      	orrs	r2, r3
                       Data->DPSM);
3419167e:	683b      	ldr	r3, [r7, #0]
34191680:	695b      	ldr	r3, [r3, #20]
                       Data->TransferMode  | \
34191682:	4313      	orrs	r3, r2
  tmpreg |= (uint32_t)(Data->DataBlockSize | \
34191684:	68fa      	ldr	r2, [r7, #12]
34191686:	4313      	orrs	r3, r2
34191688:	60fb      	str	r3, [r7, #12]

  /* Write to SDMMC DCTRL */
  MODIFY_REG(SDMMCx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
3419168a:	687b      	ldr	r3, [r7, #4]
3419168c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3419168e:	f023 02ff 	bic.w	r2, r3, #255	@ 0xff
34191692:	68fb      	ldr	r3, [r7, #12]
34191694:	431a      	orrs	r2, r3
34191696:	687b      	ldr	r3, [r7, #4]
34191698:	62da      	str	r2, [r3, #44]	@ 0x2c

  return HAL_OK;
3419169a:	2300      	movs	r3, #0

}
3419169c:	4618      	mov	r0, r3
3419169e:	3714      	adds	r7, #20
341916a0:	46bd      	mov	sp, r7
341916a2:	f85d 7b04 	ldr.w	r7, [sp], #4
341916a6:	4770      	bx	lr

341916a8 <SDMMC_CmdBlockLength>:
  * @brief  Send the Data Block Length command and check the response
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdBlockLength(SDMMC_TypeDef *SDMMCx, uint32_t BlockSize)
{
341916a8:	b580      	push	{r7, lr}
341916aa:	b088      	sub	sp, #32
341916ac:	af00      	add	r7, sp, #0
341916ae:	6078      	str	r0, [r7, #4]
341916b0:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)BlockSize;
341916b2:	683b      	ldr	r3, [r7, #0]
341916b4:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_BLOCKLEN;
341916b6:	2310      	movs	r3, #16
341916b8:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
341916ba:	f44f 7380 	mov.w	r3, #256	@ 0x100
341916be:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
341916c0:	2300      	movs	r3, #0
341916c2:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
341916c4:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
341916c8:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
341916ca:	f107 0308 	add.w	r3, r7, #8
341916ce:	4619      	mov	r1, r3
341916d0:	6878      	ldr	r0, [r7, #4]
341916d2:	f7ff ff73 	bl	341915bc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SET_BLOCKLEN, SDMMC_CMDTIMEOUT);
341916d6:	f241 3288 	movw	r2, #5000	@ 0x1388
341916da:	2110      	movs	r1, #16
341916dc:	6878      	ldr	r0, [r7, #4]
341916de:	f000 fa5f 	bl	34191ba0 <SDMMC_GetCmdResp1>
341916e2:	61f8      	str	r0, [r7, #28]

  return errorstate;
341916e4:	69fb      	ldr	r3, [r7, #28]
}
341916e6:	4618      	mov	r0, r3
341916e8:	3720      	adds	r7, #32
341916ea:	46bd      	mov	sp, r7
341916ec:	bd80      	pop	{r7, pc}

341916ee <SDMMC_CmdReadSingleBlock>:
  * @brief  Send the Read Single Block command and check the response
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdReadSingleBlock(SDMMC_TypeDef *SDMMCx, uint32_t ReadAdd)
{
341916ee:	b580      	push	{r7, lr}
341916f0:	b088      	sub	sp, #32
341916f2:	af00      	add	r7, sp, #0
341916f4:	6078      	str	r0, [r7, #4]
341916f6:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)ReadAdd;
341916f8:	683b      	ldr	r3, [r7, #0]
341916fa:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_READ_SINGLE_BLOCK;
341916fc:	2311      	movs	r3, #17
341916fe:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
34191700:	f44f 7380 	mov.w	r3, #256	@ 0x100
34191704:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
34191706:	2300      	movs	r3, #0
34191708:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
3419170a:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
3419170e:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
34191710:	f107 0308 	add.w	r3, r7, #8
34191714:	4619      	mov	r1, r3
34191716:	6878      	ldr	r0, [r7, #4]
34191718:	f7ff ff50 	bl	341915bc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_READ_SINGLE_BLOCK, SDMMC_CMDTIMEOUT);
3419171c:	f241 3288 	movw	r2, #5000	@ 0x1388
34191720:	2111      	movs	r1, #17
34191722:	6878      	ldr	r0, [r7, #4]
34191724:	f000 fa3c 	bl	34191ba0 <SDMMC_GetCmdResp1>
34191728:	61f8      	str	r0, [r7, #28]

  return errorstate;
3419172a:	69fb      	ldr	r3, [r7, #28]
}
3419172c:	4618      	mov	r0, r3
3419172e:	3720      	adds	r7, #32
34191730:	46bd      	mov	sp, r7
34191732:	bd80      	pop	{r7, pc}

34191734 <SDMMC_CmdReadMultiBlock>:
  * @brief  Send the Read Multi Block command and check the response
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdReadMultiBlock(SDMMC_TypeDef *SDMMCx, uint32_t ReadAdd)
{
34191734:	b580      	push	{r7, lr}
34191736:	b088      	sub	sp, #32
34191738:	af00      	add	r7, sp, #0
3419173a:	6078      	str	r0, [r7, #4]
3419173c:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)ReadAdd;
3419173e:	683b      	ldr	r3, [r7, #0]
34191740:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_READ_MULT_BLOCK;
34191742:	2312      	movs	r3, #18
34191744:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
34191746:	f44f 7380 	mov.w	r3, #256	@ 0x100
3419174a:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
3419174c:	2300      	movs	r3, #0
3419174e:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
34191750:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
34191754:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
34191756:	f107 0308 	add.w	r3, r7, #8
3419175a:	4619      	mov	r1, r3
3419175c:	6878      	ldr	r0, [r7, #4]
3419175e:	f7ff ff2d 	bl	341915bc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_READ_MULT_BLOCK, SDMMC_CMDTIMEOUT);
34191762:	f241 3288 	movw	r2, #5000	@ 0x1388
34191766:	2112      	movs	r1, #18
34191768:	6878      	ldr	r0, [r7, #4]
3419176a:	f000 fa19 	bl	34191ba0 <SDMMC_GetCmdResp1>
3419176e:	61f8      	str	r0, [r7, #28]

  return errorstate;
34191770:	69fb      	ldr	r3, [r7, #28]
}
34191772:	4618      	mov	r0, r3
34191774:	3720      	adds	r7, #32
34191776:	46bd      	mov	sp, r7
34191778:	bd80      	pop	{r7, pc}

3419177a <SDMMC_CmdWriteSingleBlock>:
  * @brief  Send the Write Single Block command and check the response
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdWriteSingleBlock(SDMMC_TypeDef *SDMMCx, uint32_t WriteAdd)
{
3419177a:	b580      	push	{r7, lr}
3419177c:	b088      	sub	sp, #32
3419177e:	af00      	add	r7, sp, #0
34191780:	6078      	str	r0, [r7, #4]
34191782:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)WriteAdd;
34191784:	683b      	ldr	r3, [r7, #0]
34191786:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_WRITE_SINGLE_BLOCK;
34191788:	2318      	movs	r3, #24
3419178a:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
3419178c:	f44f 7380 	mov.w	r3, #256	@ 0x100
34191790:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
34191792:	2300      	movs	r3, #0
34191794:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
34191796:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
3419179a:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
3419179c:	f107 0308 	add.w	r3, r7, #8
341917a0:	4619      	mov	r1, r3
341917a2:	6878      	ldr	r0, [r7, #4]
341917a4:	f7ff ff0a 	bl	341915bc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_WRITE_SINGLE_BLOCK, SDMMC_CMDTIMEOUT);
341917a8:	f241 3288 	movw	r2, #5000	@ 0x1388
341917ac:	2118      	movs	r1, #24
341917ae:	6878      	ldr	r0, [r7, #4]
341917b0:	f000 f9f6 	bl	34191ba0 <SDMMC_GetCmdResp1>
341917b4:	61f8      	str	r0, [r7, #28]

  return errorstate;
341917b6:	69fb      	ldr	r3, [r7, #28]
}
341917b8:	4618      	mov	r0, r3
341917ba:	3720      	adds	r7, #32
341917bc:	46bd      	mov	sp, r7
341917be:	bd80      	pop	{r7, pc}

341917c0 <SDMMC_CmdWriteMultiBlock>:
  * @brief  Send the Write Multi Block command and check the response
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdWriteMultiBlock(SDMMC_TypeDef *SDMMCx, uint32_t WriteAdd)
{
341917c0:	b580      	push	{r7, lr}
341917c2:	b088      	sub	sp, #32
341917c4:	af00      	add	r7, sp, #0
341917c6:	6078      	str	r0, [r7, #4]
341917c8:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)WriteAdd;
341917ca:	683b      	ldr	r3, [r7, #0]
341917cc:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_WRITE_MULT_BLOCK;
341917ce:	2319      	movs	r3, #25
341917d0:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
341917d2:	f44f 7380 	mov.w	r3, #256	@ 0x100
341917d6:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
341917d8:	2300      	movs	r3, #0
341917da:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
341917dc:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
341917e0:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
341917e2:	f107 0308 	add.w	r3, r7, #8
341917e6:	4619      	mov	r1, r3
341917e8:	6878      	ldr	r0, [r7, #4]
341917ea:	f7ff fee7 	bl	341915bc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_WRITE_MULT_BLOCK, SDMMC_CMDTIMEOUT);
341917ee:	f241 3288 	movw	r2, #5000	@ 0x1388
341917f2:	2119      	movs	r1, #25
341917f4:	6878      	ldr	r0, [r7, #4]
341917f6:	f000 f9d3 	bl	34191ba0 <SDMMC_GetCmdResp1>
341917fa:	61f8      	str	r0, [r7, #28]

  return errorstate;
341917fc:	69fb      	ldr	r3, [r7, #28]
}
341917fe:	4618      	mov	r0, r3
34191800:	3720      	adds	r7, #32
34191802:	46bd      	mov	sp, r7
34191804:	bd80      	pop	{r7, pc}
	...

34191808 <SDMMC_CmdStopTransfer>:
  * @brief  Send the Stop Transfer command and check the response.
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdStopTransfer(SDMMC_TypeDef *SDMMCx)
{
34191808:	b580      	push	{r7, lr}
3419180a:	b088      	sub	sp, #32
3419180c:	af00      	add	r7, sp, #0
3419180e:	6078      	str	r0, [r7, #4]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD12 STOP_TRANSMISSION  */
  sdmmc_cmdinit.Argument         = 0U;
34191810:	2300      	movs	r3, #0
34191812:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_STOP_TRANSMISSION;
34191814:	230c      	movs	r3, #12
34191816:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
34191818:	f44f 7380 	mov.w	r3, #256	@ 0x100
3419181c:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
3419181e:	2300      	movs	r3, #0
34191820:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
34191822:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
34191826:	61bb      	str	r3, [r7, #24]

  __SDMMC_CMDSTOP_ENABLE(SDMMCx);
34191828:	687b      	ldr	r3, [r7, #4]
3419182a:	68db      	ldr	r3, [r3, #12]
3419182c:	f043 0280 	orr.w	r2, r3, #128	@ 0x80
34191830:	687b      	ldr	r3, [r7, #4]
34191832:	60da      	str	r2, [r3, #12]
  __SDMMC_CMDTRANS_DISABLE(SDMMCx);
34191834:	687b      	ldr	r3, [r7, #4]
34191836:	68db      	ldr	r3, [r3, #12]
34191838:	f023 0240 	bic.w	r2, r3, #64	@ 0x40
3419183c:	687b      	ldr	r3, [r7, #4]
3419183e:	60da      	str	r2, [r3, #12]

  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
34191840:	f107 0308 	add.w	r3, r7, #8
34191844:	4619      	mov	r1, r3
34191846:	6878      	ldr	r0, [r7, #4]
34191848:	f7ff feb8 	bl	341915bc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_STOP_TRANSMISSION, SDMMC_STOPTRANSFERTIMEOUT);
3419184c:	4a0b      	ldr	r2, [pc, #44]	@ (3419187c <SDMMC_CmdStopTransfer+0x74>)
3419184e:	210c      	movs	r1, #12
34191850:	6878      	ldr	r0, [r7, #4]
34191852:	f000 f9a5 	bl	34191ba0 <SDMMC_GetCmdResp1>
34191856:	61f8      	str	r0, [r7, #28]

  __SDMMC_CMDSTOP_DISABLE(SDMMCx);
34191858:	687b      	ldr	r3, [r7, #4]
3419185a:	68db      	ldr	r3, [r3, #12]
3419185c:	f023 0280 	bic.w	r2, r3, #128	@ 0x80
34191860:	687b      	ldr	r3, [r7, #4]
34191862:	60da      	str	r2, [r3, #12]

  /* Ignore Address Out Of Range Error, Not relevant at end of memory */
  if (errorstate == SDMMC_ERROR_ADDR_OUT_OF_RANGE)
34191864:	69fb      	ldr	r3, [r7, #28]
34191866:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
3419186a:	d101      	bne.n	34191870 <SDMMC_CmdStopTransfer+0x68>
  {
    errorstate = SDMMC_ERROR_NONE;
3419186c:	2300      	movs	r3, #0
3419186e:	61fb      	str	r3, [r7, #28]
  }

  return errorstate;
34191870:	69fb      	ldr	r3, [r7, #28]
}
34191872:	4618      	mov	r0, r3
34191874:	3720      	adds	r7, #32
34191876:	46bd      	mov	sp, r7
34191878:	bd80      	pop	{r7, pc}
3419187a:	bf00      	nop
3419187c:	05f5e100 	.word	0x05f5e100

34191880 <SDMMC_CmdSelDesel>:
  * @param  SDMMCx: Pointer to SDMMC register base
  * @param  addr: Address of the card to be selected
  * @retval HAL status
  */
uint32_t SDMMC_CmdSelDesel(SDMMC_TypeDef *SDMMCx, uint32_t Addr)
{
34191880:	b580      	push	{r7, lr}
34191882:	b088      	sub	sp, #32
34191884:	af00      	add	r7, sp, #0
34191886:	6078      	str	r0, [r7, #4]
34191888:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD7 SDMMC_SEL_DESEL_CARD */
  sdmmc_cmdinit.Argument         = (uint32_t)Addr;
3419188a:	683b      	ldr	r3, [r7, #0]
3419188c:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEL_DESEL_CARD;
3419188e:	2307      	movs	r3, #7
34191890:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
34191892:	f44f 7380 	mov.w	r3, #256	@ 0x100
34191896:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
34191898:	2300      	movs	r3, #0
3419189a:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
3419189c:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
341918a0:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
341918a2:	f107 0308 	add.w	r3, r7, #8
341918a6:	4619      	mov	r1, r3
341918a8:	6878      	ldr	r0, [r7, #4]
341918aa:	f7ff fe87 	bl	341915bc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SEL_DESEL_CARD, SDMMC_CMDTIMEOUT);
341918ae:	f241 3288 	movw	r2, #5000	@ 0x1388
341918b2:	2107      	movs	r1, #7
341918b4:	6878      	ldr	r0, [r7, #4]
341918b6:	f000 f973 	bl	34191ba0 <SDMMC_GetCmdResp1>
341918ba:	61f8      	str	r0, [r7, #28]

  return errorstate;
341918bc:	69fb      	ldr	r3, [r7, #28]
}
341918be:	4618      	mov	r0, r3
341918c0:	3720      	adds	r7, #32
341918c2:	46bd      	mov	sp, r7
341918c4:	bd80      	pop	{r7, pc}

341918c6 <SDMMC_CmdGoIdleState>:
  * @brief  Send the Go Idle State command and check the response.
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdGoIdleState(SDMMC_TypeDef *SDMMCx)
{
341918c6:	b580      	push	{r7, lr}
341918c8:	b088      	sub	sp, #32
341918ca:	af00      	add	r7, sp, #0
341918cc:	6078      	str	r0, [r7, #4]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = 0U;
341918ce:	2300      	movs	r3, #0
341918d0:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_GO_IDLE_STATE;
341918d2:	2300      	movs	r3, #0
341918d4:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_NO;
341918d6:	2300      	movs	r3, #0
341918d8:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
341918da:	2300      	movs	r3, #0
341918dc:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
341918de:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
341918e2:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
341918e4:	f107 0308 	add.w	r3, r7, #8
341918e8:	4619      	mov	r1, r3
341918ea:	6878      	ldr	r0, [r7, #4]
341918ec:	f7ff fe66 	bl	341915bc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdError(SDMMCx);
341918f0:	6878      	ldr	r0, [r7, #4]
341918f2:	f000 fb97 	bl	34192024 <SDMMC_GetCmdError>
341918f6:	61f8      	str	r0, [r7, #28]

  return errorstate;
341918f8:	69fb      	ldr	r3, [r7, #28]
}
341918fa:	4618      	mov	r0, r3
341918fc:	3720      	adds	r7, #32
341918fe:	46bd      	mov	sp, r7
34191900:	bd80      	pop	{r7, pc}

34191902 <SDMMC_CmdOperCond>:
  * @brief  Send the Operating Condition command and check the response.
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdOperCond(SDMMC_TypeDef *SDMMCx)
{
34191902:	b580      	push	{r7, lr}
34191904:	b088      	sub	sp, #32
34191906:	af00      	add	r7, sp, #0
34191908:	6078      	str	r0, [r7, #4]
  /* Send CMD8 to verify SD card interface operating condition */
  /* Argument: - [31:12]: Reserved (shall be set to '0')
  - [11:8]: Supply Voltage (VHS) 0x1 (Range: 2.7-3.6 V)
  - [7:0]: Check Pattern (recommended 0xAA) */
  /* CMD Response: R7 */
  sdmmc_cmdinit.Argument         = SDMMC_CHECK_PATTERN;
3419190a:	f44f 73d5 	mov.w	r3, #426	@ 0x1aa
3419190e:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_HS_SEND_EXT_CSD;
34191910:	2308      	movs	r3, #8
34191912:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
34191914:	f44f 7380 	mov.w	r3, #256	@ 0x100
34191918:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
3419191a:	2300      	movs	r3, #0
3419191c:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
3419191e:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
34191922:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
34191924:	f107 0308 	add.w	r3, r7, #8
34191928:	4619      	mov	r1, r3
3419192a:	6878      	ldr	r0, [r7, #4]
3419192c:	f7ff fe46 	bl	341915bc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp7(SDMMCx);
34191930:	6878      	ldr	r0, [r7, #4]
34191932:	f000 fb29 	bl	34191f88 <SDMMC_GetCmdResp7>
34191936:	61f8      	str	r0, [r7, #28]

  return errorstate;
34191938:	69fb      	ldr	r3, [r7, #28]
}
3419193a:	4618      	mov	r0, r3
3419193c:	3720      	adds	r7, #32
3419193e:	46bd      	mov	sp, r7
34191940:	bd80      	pop	{r7, pc}

34191942 <SDMMC_CmdAppCommand>:
  * @param  SDMMCx: Pointer to SDMMC register base
  * @param  Argument: Command Argument
  * @retval HAL status
  */
uint32_t SDMMC_CmdAppCommand(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
34191942:	b580      	push	{r7, lr}
34191944:	b088      	sub	sp, #32
34191946:	af00      	add	r7, sp, #0
34191948:	6078      	str	r0, [r7, #4]
3419194a:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = (uint32_t)Argument;
3419194c:	683b      	ldr	r3, [r7, #0]
3419194e:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_APP_CMD;
34191950:	2337      	movs	r3, #55	@ 0x37
34191952:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
34191954:	f44f 7380 	mov.w	r3, #256	@ 0x100
34191958:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
3419195a:	2300      	movs	r3, #0
3419195c:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
3419195e:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
34191962:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
34191964:	f107 0308 	add.w	r3, r7, #8
34191968:	4619      	mov	r1, r3
3419196a:	6878      	ldr	r0, [r7, #4]
3419196c:	f7ff fe26 	bl	341915bc <SDMMC_SendCommand>

  /* Check for error conditions */
  /* If there is a HAL_ERROR, it is a MMC card, else
  it is a SD card: SD card 2.0 (voltage range mismatch)
     or SD card 1.x */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_APP_CMD, SDMMC_CMDTIMEOUT);
34191970:	f241 3288 	movw	r2, #5000	@ 0x1388
34191974:	2137      	movs	r1, #55	@ 0x37
34191976:	6878      	ldr	r0, [r7, #4]
34191978:	f000 f912 	bl	34191ba0 <SDMMC_GetCmdResp1>
3419197c:	61f8      	str	r0, [r7, #28]

  return errorstate;
3419197e:	69fb      	ldr	r3, [r7, #28]
}
34191980:	4618      	mov	r0, r3
34191982:	3720      	adds	r7, #32
34191984:	46bd      	mov	sp, r7
34191986:	bd80      	pop	{r7, pc}

34191988 <SDMMC_CmdAppOperCommand>:
  * @param  SDMMCx: Pointer to SDMMC register base
  * @param  Argument: Command Argument
  * @retval HAL status
  */
uint32_t SDMMC_CmdAppOperCommand(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
34191988:	b580      	push	{r7, lr}
3419198a:	b088      	sub	sp, #32
3419198c:	af00      	add	r7, sp, #0
3419198e:	6078      	str	r0, [r7, #4]
34191990:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = Argument;
34191992:	683b      	ldr	r3, [r7, #0]
34191994:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_OP_COND;
34191996:	2329      	movs	r3, #41	@ 0x29
34191998:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
3419199a:	f44f 7380 	mov.w	r3, #256	@ 0x100
3419199e:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
341919a0:	2300      	movs	r3, #0
341919a2:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
341919a4:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
341919a8:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
341919aa:	f107 0308 	add.w	r3, r7, #8
341919ae:	4619      	mov	r1, r3
341919b0:	6878      	ldr	r0, [r7, #4]
341919b2:	f7ff fe03 	bl	341915bc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp3(SDMMCx);
341919b6:	6878      	ldr	r0, [r7, #4]
341919b8:	f000 fa2e 	bl	34191e18 <SDMMC_GetCmdResp3>
341919bc:	61f8      	str	r0, [r7, #28]

  return errorstate;
341919be:	69fb      	ldr	r3, [r7, #28]
}
341919c0:	4618      	mov	r0, r3
341919c2:	3720      	adds	r7, #32
341919c4:	46bd      	mov	sp, r7
341919c6:	bd80      	pop	{r7, pc}

341919c8 <SDMMC_CmdBusWidth>:
  * @param  SDMMCx: Pointer to SDMMC register base
  * @param  BusWidth: BusWidth
  * @retval HAL status
  */
uint32_t SDMMC_CmdBusWidth(SDMMC_TypeDef *SDMMCx, uint32_t BusWidth)
{
341919c8:	b580      	push	{r7, lr}
341919ca:	b088      	sub	sp, #32
341919cc:	af00      	add	r7, sp, #0
341919ce:	6078      	str	r0, [r7, #4]
341919d0:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = (uint32_t)BusWidth;
341919d2:	683b      	ldr	r3, [r7, #0]
341919d4:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_APP_SD_SET_BUSWIDTH;
341919d6:	2306      	movs	r3, #6
341919d8:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
341919da:	f44f 7380 	mov.w	r3, #256	@ 0x100
341919de:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
341919e0:	2300      	movs	r3, #0
341919e2:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
341919e4:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
341919e8:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
341919ea:	f107 0308 	add.w	r3, r7, #8
341919ee:	4619      	mov	r1, r3
341919f0:	6878      	ldr	r0, [r7, #4]
341919f2:	f7ff fde3 	bl	341915bc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_APP_SD_SET_BUSWIDTH, SDMMC_CMDTIMEOUT);
341919f6:	f241 3288 	movw	r2, #5000	@ 0x1388
341919fa:	2106      	movs	r1, #6
341919fc:	6878      	ldr	r0, [r7, #4]
341919fe:	f000 f8cf 	bl	34191ba0 <SDMMC_GetCmdResp1>
34191a02:	61f8      	str	r0, [r7, #28]

  return errorstate;
34191a04:	69fb      	ldr	r3, [r7, #28]
}
34191a06:	4618      	mov	r0, r3
34191a08:	3720      	adds	r7, #32
34191a0a:	46bd      	mov	sp, r7
34191a0c:	bd80      	pop	{r7, pc}

34191a0e <SDMMC_CmdSendSCR>:
  * @brief  Send the Send SCR command and check the response.
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdSendSCR(SDMMC_TypeDef *SDMMCx)
{
34191a0e:	b580      	push	{r7, lr}
34191a10:	b088      	sub	sp, #32
34191a12:	af00      	add	r7, sp, #0
34191a14:	6078      	str	r0, [r7, #4]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD51 SD_APP_SEND_SCR */
  sdmmc_cmdinit.Argument         = 0U;
34191a16:	2300      	movs	r3, #0
34191a18:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_SEND_SCR;
34191a1a:	2333      	movs	r3, #51	@ 0x33
34191a1c:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
34191a1e:	f44f 7380 	mov.w	r3, #256	@ 0x100
34191a22:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
34191a24:	2300      	movs	r3, #0
34191a26:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
34191a28:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
34191a2c:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
34191a2e:	f107 0308 	add.w	r3, r7, #8
34191a32:	4619      	mov	r1, r3
34191a34:	6878      	ldr	r0, [r7, #4]
34191a36:	f7ff fdc1 	bl	341915bc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SD_APP_SEND_SCR, SDMMC_CMDTIMEOUT);
34191a3a:	f241 3288 	movw	r2, #5000	@ 0x1388
34191a3e:	2133      	movs	r1, #51	@ 0x33
34191a40:	6878      	ldr	r0, [r7, #4]
34191a42:	f000 f8ad 	bl	34191ba0 <SDMMC_GetCmdResp1>
34191a46:	61f8      	str	r0, [r7, #28]

  return errorstate;
34191a48:	69fb      	ldr	r3, [r7, #28]
}
34191a4a:	4618      	mov	r0, r3
34191a4c:	3720      	adds	r7, #32
34191a4e:	46bd      	mov	sp, r7
34191a50:	bd80      	pop	{r7, pc}

34191a52 <SDMMC_CmdSendCID>:
  * @brief  Send the Send CID command and check the response.
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdSendCID(SDMMC_TypeDef *SDMMCx)
{
34191a52:	b580      	push	{r7, lr}
34191a54:	b088      	sub	sp, #32
34191a56:	af00      	add	r7, sp, #0
34191a58:	6078      	str	r0, [r7, #4]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD2 ALL_SEND_CID */
  sdmmc_cmdinit.Argument         = 0U;
34191a5a:	2300      	movs	r3, #0
34191a5c:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ALL_SEND_CID;
34191a5e:	2302      	movs	r3, #2
34191a60:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_LONG;
34191a62:	f44f 7340 	mov.w	r3, #768	@ 0x300
34191a66:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
34191a68:	2300      	movs	r3, #0
34191a6a:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
34191a6c:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
34191a70:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
34191a72:	f107 0308 	add.w	r3, r7, #8
34191a76:	4619      	mov	r1, r3
34191a78:	6878      	ldr	r0, [r7, #4]
34191a7a:	f7ff fd9f 	bl	341915bc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp2(SDMMCx);
34191a7e:	6878      	ldr	r0, [r7, #4]
34191a80:	f000 f980 	bl	34191d84 <SDMMC_GetCmdResp2>
34191a84:	61f8      	str	r0, [r7, #28]

  return errorstate;
34191a86:	69fb      	ldr	r3, [r7, #28]
}
34191a88:	4618      	mov	r0, r3
34191a8a:	3720      	adds	r7, #32
34191a8c:	46bd      	mov	sp, r7
34191a8e:	bd80      	pop	{r7, pc}

34191a90 <SDMMC_CmdSendCSD>:
  * @param  SDMMCx: Pointer to SDMMC register base
  * @param  Argument: Command Argument
  * @retval HAL status
  */
uint32_t SDMMC_CmdSendCSD(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
34191a90:	b580      	push	{r7, lr}
34191a92:	b088      	sub	sp, #32
34191a94:	af00      	add	r7, sp, #0
34191a96:	6078      	str	r0, [r7, #4]
34191a98:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD9 SEND_CSD */
  sdmmc_cmdinit.Argument         = Argument;
34191a9a:	683b      	ldr	r3, [r7, #0]
34191a9c:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEND_CSD;
34191a9e:	2309      	movs	r3, #9
34191aa0:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_LONG;
34191aa2:	f44f 7340 	mov.w	r3, #768	@ 0x300
34191aa6:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
34191aa8:	2300      	movs	r3, #0
34191aaa:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
34191aac:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
34191ab0:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
34191ab2:	f107 0308 	add.w	r3, r7, #8
34191ab6:	4619      	mov	r1, r3
34191ab8:	6878      	ldr	r0, [r7, #4]
34191aba:	f7ff fd7f 	bl	341915bc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp2(SDMMCx);
34191abe:	6878      	ldr	r0, [r7, #4]
34191ac0:	f000 f960 	bl	34191d84 <SDMMC_GetCmdResp2>
34191ac4:	61f8      	str	r0, [r7, #28]

  return errorstate;
34191ac6:	69fb      	ldr	r3, [r7, #28]
}
34191ac8:	4618      	mov	r0, r3
34191aca:	3720      	adds	r7, #32
34191acc:	46bd      	mov	sp, r7
34191ace:	bd80      	pop	{r7, pc}

34191ad0 <SDMMC_CmdSetRelAdd>:
  * @param  SDMMCx: Pointer to SDMMC register base
  * @param  pRCA: Card RCA
  * @retval HAL status
  */
uint32_t SDMMC_CmdSetRelAdd(SDMMC_TypeDef *SDMMCx, uint16_t *pRCA)
{
34191ad0:	b580      	push	{r7, lr}
34191ad2:	b088      	sub	sp, #32
34191ad4:	af00      	add	r7, sp, #0
34191ad6:	6078      	str	r0, [r7, #4]
34191ad8:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD3 SD_CMD_SET_REL_ADDR */
  sdmmc_cmdinit.Argument         = 0U;
34191ada:	2300      	movs	r3, #0
34191adc:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_REL_ADDR;
34191ade:	2303      	movs	r3, #3
34191ae0:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
34191ae2:	f44f 7380 	mov.w	r3, #256	@ 0x100
34191ae6:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
34191ae8:	2300      	movs	r3, #0
34191aea:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
34191aec:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
34191af0:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
34191af2:	f107 0308 	add.w	r3, r7, #8
34191af6:	4619      	mov	r1, r3
34191af8:	6878      	ldr	r0, [r7, #4]
34191afa:	f7ff fd5f 	bl	341915bc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp6(SDMMCx, SDMMC_CMD_SET_REL_ADDR, pRCA);
34191afe:	683a      	ldr	r2, [r7, #0]
34191b00:	2103      	movs	r1, #3
34191b02:	6878      	ldr	r0, [r7, #4]
34191b04:	f000 f9c8 	bl	34191e98 <SDMMC_GetCmdResp6>
34191b08:	61f8      	str	r0, [r7, #28]

  return errorstate;
34191b0a:	69fb      	ldr	r3, [r7, #28]
}
34191b0c:	4618      	mov	r0, r3
34191b0e:	3720      	adds	r7, #32
34191b10:	46bd      	mov	sp, r7
34191b12:	bd80      	pop	{r7, pc}

34191b14 <SDMMC_CmdSendStatus>:
  * @param  SDMMCx: Pointer to SDMMC register base
  * @param  Argument: Command Argument
  * @retval HAL status
  */
uint32_t SDMMC_CmdSendStatus(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
34191b14:	b580      	push	{r7, lr}
34191b16:	b088      	sub	sp, #32
34191b18:	af00      	add	r7, sp, #0
34191b1a:	6078      	str	r0, [r7, #4]
34191b1c:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = Argument;
34191b1e:	683b      	ldr	r3, [r7, #0]
34191b20:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEND_STATUS;
34191b22:	230d      	movs	r3, #13
34191b24:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
34191b26:	f44f 7380 	mov.w	r3, #256	@ 0x100
34191b2a:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
34191b2c:	2300      	movs	r3, #0
34191b2e:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
34191b30:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
34191b34:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
34191b36:	f107 0308 	add.w	r3, r7, #8
34191b3a:	4619      	mov	r1, r3
34191b3c:	6878      	ldr	r0, [r7, #4]
34191b3e:	f7ff fd3d 	bl	341915bc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SEND_STATUS, SDMMC_CMDTIMEOUT);
34191b42:	f241 3288 	movw	r2, #5000	@ 0x1388
34191b46:	210d      	movs	r1, #13
34191b48:	6878      	ldr	r0, [r7, #4]
34191b4a:	f000 f829 	bl	34191ba0 <SDMMC_GetCmdResp1>
34191b4e:	61f8      	str	r0, [r7, #28]

  return errorstate;
34191b50:	69fb      	ldr	r3, [r7, #28]
}
34191b52:	4618      	mov	r0, r3
34191b54:	3720      	adds	r7, #32
34191b56:	46bd      	mov	sp, r7
34191b58:	bd80      	pop	{r7, pc}

34191b5a <SDMMC_CmdStatusRegister>:
  * @brief  Send the Status register command and check the response.
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdStatusRegister(SDMMC_TypeDef *SDMMCx)
{
34191b5a:	b580      	push	{r7, lr}
34191b5c:	b088      	sub	sp, #32
34191b5e:	af00      	add	r7, sp, #0
34191b60:	6078      	str	r0, [r7, #4]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = 0U;
34191b62:	2300      	movs	r3, #0
34191b64:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_STATUS;
34191b66:	230d      	movs	r3, #13
34191b68:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
34191b6a:	f44f 7380 	mov.w	r3, #256	@ 0x100
34191b6e:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
34191b70:	2300      	movs	r3, #0
34191b72:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
34191b74:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
34191b78:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
34191b7a:	f107 0308 	add.w	r3, r7, #8
34191b7e:	4619      	mov	r1, r3
34191b80:	6878      	ldr	r0, [r7, #4]
34191b82:	f7ff fd1b 	bl	341915bc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SD_APP_STATUS, SDMMC_CMDTIMEOUT);
34191b86:	f241 3288 	movw	r2, #5000	@ 0x1388
34191b8a:	210d      	movs	r1, #13
34191b8c:	6878      	ldr	r0, [r7, #4]
34191b8e:	f000 f807 	bl	34191ba0 <SDMMC_GetCmdResp1>
34191b92:	61f8      	str	r0, [r7, #28]

  return errorstate;
34191b94:	69fb      	ldr	r3, [r7, #28]
}
34191b96:	4618      	mov	r0, r3
34191b98:	3720      	adds	r7, #32
34191b9a:	46bd      	mov	sp, r7
34191b9c:	bd80      	pop	{r7, pc}
	...

34191ba0 <SDMMC_GetCmdResp1>:
  * @param  hsd: SD handle
  * @param  SD_CMD: The sent command index
  * @retval SD Card error state
  */
uint32_t SDMMC_GetCmdResp1(SDMMC_TypeDef *SDMMCx, uint8_t SD_CMD, uint32_t Timeout)
{
34191ba0:	b580      	push	{r7, lr}
34191ba2:	b088      	sub	sp, #32
34191ba4:	af00      	add	r7, sp, #0
34191ba6:	60f8      	str	r0, [r7, #12]
34191ba8:	460b      	mov	r3, r1
34191baa:	607a      	str	r2, [r7, #4]
34191bac:	72fb      	strb	r3, [r7, #11]
  uint32_t response_r1;
  uint32_t sta_reg;

  /* 8 is the number of required instructions cycles for the below loop statement.
  The Timeout is expressed in ms */
  uint32_t count = Timeout * (SystemCoreClock / 8U / 1000U);
34191bae:	4b70      	ldr	r3, [pc, #448]	@ (34191d70 <SDMMC_GetCmdResp1+0x1d0>)
34191bb0:	681b      	ldr	r3, [r3, #0]
34191bb2:	4a70      	ldr	r2, [pc, #448]	@ (34191d74 <SDMMC_GetCmdResp1+0x1d4>)
34191bb4:	fba2 2303 	umull	r2, r3, r2, r3
34191bb8:	0a5a      	lsrs	r2, r3, #9
34191bba:	687b      	ldr	r3, [r7, #4]
34191bbc:	fb02 f303 	mul.w	r3, r2, r3
34191bc0:	61fb      	str	r3, [r7, #28]

  do
  {
    if (count-- == 0U)
34191bc2:	69fb      	ldr	r3, [r7, #28]
34191bc4:	1e5a      	subs	r2, r3, #1
34191bc6:	61fa      	str	r2, [r7, #28]
34191bc8:	2b00      	cmp	r3, #0
34191bca:	d102      	bne.n	34191bd2 <SDMMC_GetCmdResp1+0x32>
    {
      return SDMMC_ERROR_TIMEOUT;
34191bcc:	f04f 4300 	mov.w	r3, #2147483648	@ 0x80000000
34191bd0:	e0c9      	b.n	34191d66 <SDMMC_GetCmdResp1+0x1c6>
    }
    sta_reg = SDMMCx->STA;
34191bd2:	68fb      	ldr	r3, [r7, #12]
34191bd4:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
34191bd6:	61bb      	str	r3, [r7, #24]
  } while (((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT |
34191bd8:	69ba      	ldr	r2, [r7, #24]
34191bda:	4b67      	ldr	r3, [pc, #412]	@ (34191d78 <SDMMC_GetCmdResp1+0x1d8>)
34191bdc:	4013      	ands	r3, r2
                        SDMMC_FLAG_BUSYD0END)) == 0U) || ((sta_reg & SDMMC_FLAG_CMDACT) != 0U));
34191bde:	2b00      	cmp	r3, #0
34191be0:	d0ef      	beq.n	34191bc2 <SDMMC_GetCmdResp1+0x22>
34191be2:	69bb      	ldr	r3, [r7, #24]
34191be4:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
34191be8:	2b00      	cmp	r3, #0
34191bea:	d1ea      	bne.n	34191bc2 <SDMMC_GetCmdResp1+0x22>

  if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
34191bec:	68fb      	ldr	r3, [r7, #12]
34191bee:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
34191bf0:	f003 0304 	and.w	r3, r3, #4
34191bf4:	2b00      	cmp	r3, #0
34191bf6:	d004      	beq.n	34191c02 <SDMMC_GetCmdResp1+0x62>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
34191bf8:	68fb      	ldr	r3, [r7, #12]
34191bfa:	2204      	movs	r2, #4
34191bfc:	639a      	str	r2, [r3, #56]	@ 0x38

    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
34191bfe:	2304      	movs	r3, #4
34191c00:	e0b1      	b.n	34191d66 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
34191c02:	68fb      	ldr	r3, [r7, #12]
34191c04:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
34191c06:	f003 0301 	and.w	r3, r3, #1
34191c0a:	2b00      	cmp	r3, #0
34191c0c:	d004      	beq.n	34191c18 <SDMMC_GetCmdResp1+0x78>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
34191c0e:	68fb      	ldr	r3, [r7, #12]
34191c10:	2201      	movs	r2, #1
34191c12:	639a      	str	r2, [r3, #56]	@ 0x38

    return SDMMC_ERROR_CMD_CRC_FAIL;
34191c14:	2301      	movs	r3, #1
34191c16:	e0a6      	b.n	34191d66 <SDMMC_GetCmdResp1+0x1c6>
  {
    /* Nothing to do */
  }

  /* Clear all the static flags */
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
34191c18:	68fb      	ldr	r3, [r7, #12]
34191c1a:	4a58      	ldr	r2, [pc, #352]	@ (34191d7c <SDMMC_GetCmdResp1+0x1dc>)
34191c1c:	639a      	str	r2, [r3, #56]	@ 0x38

  /* Check response received is of desired command */
  if (SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
34191c1e:	68f8      	ldr	r0, [r7, #12]
34191c20:	f7ff fcf6 	bl	34191610 <SDMMC_GetCommandResponse>
34191c24:	4603      	mov	r3, r0
34191c26:	461a      	mov	r2, r3
34191c28:	7afb      	ldrb	r3, [r7, #11]
34191c2a:	4293      	cmp	r3, r2
34191c2c:	d001      	beq.n	34191c32 <SDMMC_GetCmdResp1+0x92>
  {
    return SDMMC_ERROR_CMD_CRC_FAIL;
34191c2e:	2301      	movs	r3, #1
34191c30:	e099      	b.n	34191d66 <SDMMC_GetCmdResp1+0x1c6>
  }

  /* We have received response, retrieve it for analysis  */
  response_r1 = SDMMC_GetResponse(SDMMCx, SDMMC_RESP1);
34191c32:	2100      	movs	r1, #0
34191c34:	68f8      	ldr	r0, [r7, #12]
34191c36:	f7ff fcf8 	bl	3419162a <SDMMC_GetResponse>
34191c3a:	6178      	str	r0, [r7, #20]

  if ((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
34191c3c:	697a      	ldr	r2, [r7, #20]
34191c3e:	4b50      	ldr	r3, [pc, #320]	@ (34191d80 <SDMMC_GetCmdResp1+0x1e0>)
34191c40:	4013      	ands	r3, r2
34191c42:	2b00      	cmp	r3, #0
34191c44:	d101      	bne.n	34191c4a <SDMMC_GetCmdResp1+0xaa>
  {
    return SDMMC_ERROR_NONE;
34191c46:	2300      	movs	r3, #0
34191c48:	e08d      	b.n	34191d66 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
34191c4a:	697b      	ldr	r3, [r7, #20]
34191c4c:	2b00      	cmp	r3, #0
34191c4e:	da02      	bge.n	34191c56 <SDMMC_GetCmdResp1+0xb6>
  {
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
34191c50:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
34191c54:	e087      	b.n	34191d66 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
34191c56:	697b      	ldr	r3, [r7, #20]
34191c58:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
34191c5c:	2b00      	cmp	r3, #0
34191c5e:	d001      	beq.n	34191c64 <SDMMC_GetCmdResp1+0xc4>
  {
    return SDMMC_ERROR_ADDR_MISALIGNED;
34191c60:	2340      	movs	r3, #64	@ 0x40
34191c62:	e080      	b.n	34191d66 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
34191c64:	697b      	ldr	r3, [r7, #20]
34191c66:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
34191c6a:	2b00      	cmp	r3, #0
34191c6c:	d001      	beq.n	34191c72 <SDMMC_GetCmdResp1+0xd2>
  {
    return SDMMC_ERROR_BLOCK_LEN_ERR;
34191c6e:	2380      	movs	r3, #128	@ 0x80
34191c70:	e079      	b.n	34191d66 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
34191c72:	697b      	ldr	r3, [r7, #20]
34191c74:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
34191c78:	2b00      	cmp	r3, #0
34191c7a:	d002      	beq.n	34191c82 <SDMMC_GetCmdResp1+0xe2>
  {
    return SDMMC_ERROR_ERASE_SEQ_ERR;
34191c7c:	f44f 7380 	mov.w	r3, #256	@ 0x100
34191c80:	e071      	b.n	34191d66 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
34191c82:	697b      	ldr	r3, [r7, #20]
34191c84:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34191c88:	2b00      	cmp	r3, #0
34191c8a:	d002      	beq.n	34191c92 <SDMMC_GetCmdResp1+0xf2>
  {
    return SDMMC_ERROR_BAD_ERASE_PARAM;
34191c8c:	f44f 7300 	mov.w	r3, #512	@ 0x200
34191c90:	e069      	b.n	34191d66 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
34191c92:	697b      	ldr	r3, [r7, #20]
34191c94:	f003 6380 	and.w	r3, r3, #67108864	@ 0x4000000
34191c98:	2b00      	cmp	r3, #0
34191c9a:	d002      	beq.n	34191ca2 <SDMMC_GetCmdResp1+0x102>
  {
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
34191c9c:	f44f 6380 	mov.w	r3, #1024	@ 0x400
34191ca0:	e061      	b.n	34191d66 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
34191ca2:	697b      	ldr	r3, [r7, #20]
34191ca4:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
34191ca8:	2b00      	cmp	r3, #0
34191caa:	d002      	beq.n	34191cb2 <SDMMC_GetCmdResp1+0x112>
  {
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
34191cac:	f44f 6300 	mov.w	r3, #2048	@ 0x800
34191cb0:	e059      	b.n	34191d66 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
34191cb2:	697b      	ldr	r3, [r7, #20]
34191cb4:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
34191cb8:	2b00      	cmp	r3, #0
34191cba:	d002      	beq.n	34191cc2 <SDMMC_GetCmdResp1+0x122>
  {
    return SDMMC_ERROR_COM_CRC_FAILED;
34191cbc:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
34191cc0:	e051      	b.n	34191d66 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
34191cc2:	697b      	ldr	r3, [r7, #20]
34191cc4:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
34191cc8:	2b00      	cmp	r3, #0
34191cca:	d002      	beq.n	34191cd2 <SDMMC_GetCmdResp1+0x132>
  {
    return SDMMC_ERROR_ILLEGAL_CMD;
34191ccc:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
34191cd0:	e049      	b.n	34191d66 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
34191cd2:	697b      	ldr	r3, [r7, #20]
34191cd4:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
34191cd8:	2b00      	cmp	r3, #0
34191cda:	d002      	beq.n	34191ce2 <SDMMC_GetCmdResp1+0x142>
  {
    return SDMMC_ERROR_CARD_ECC_FAILED;
34191cdc:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
34191ce0:	e041      	b.n	34191d66 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
34191ce2:	697b      	ldr	r3, [r7, #20]
34191ce4:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
34191ce8:	2b00      	cmp	r3, #0
34191cea:	d002      	beq.n	34191cf2 <SDMMC_GetCmdResp1+0x152>
  {
    return SDMMC_ERROR_CC_ERR;
34191cec:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
34191cf0:	e039      	b.n	34191d66 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
34191cf2:	697b      	ldr	r3, [r7, #20]
34191cf4:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
34191cf8:	2b00      	cmp	r3, #0
34191cfa:	d002      	beq.n	34191d02 <SDMMC_GetCmdResp1+0x162>
  {
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
34191cfc:	f44f 3300 	mov.w	r3, #131072	@ 0x20000
34191d00:	e031      	b.n	34191d66 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
34191d02:	697b      	ldr	r3, [r7, #20]
34191d04:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
34191d08:	2b00      	cmp	r3, #0
34191d0a:	d002      	beq.n	34191d12 <SDMMC_GetCmdResp1+0x172>
  {
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
34191d0c:	f44f 2380 	mov.w	r3, #262144	@ 0x40000
34191d10:	e029      	b.n	34191d66 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
34191d12:	697b      	ldr	r3, [r7, #20]
34191d14:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
34191d18:	2b00      	cmp	r3, #0
34191d1a:	d002      	beq.n	34191d22 <SDMMC_GetCmdResp1+0x182>
  {
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
34191d1c:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
34191d20:	e021      	b.n	34191d66 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
34191d22:	697b      	ldr	r3, [r7, #20]
34191d24:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
34191d28:	2b00      	cmp	r3, #0
34191d2a:	d002      	beq.n	34191d32 <SDMMC_GetCmdResp1+0x192>
  {
    return SDMMC_ERROR_WP_ERASE_SKIP;
34191d2c:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
34191d30:	e019      	b.n	34191d66 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
34191d32:	697b      	ldr	r3, [r7, #20]
34191d34:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
34191d38:	2b00      	cmp	r3, #0
34191d3a:	d002      	beq.n	34191d42 <SDMMC_GetCmdResp1+0x1a2>
  {
    return SDMMC_ERROR_CARD_ECC_DISABLED;
34191d3c:	f44f 1300 	mov.w	r3, #2097152	@ 0x200000
34191d40:	e011      	b.n	34191d66 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
34191d42:	697b      	ldr	r3, [r7, #20]
34191d44:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
34191d48:	2b00      	cmp	r3, #0
34191d4a:	d002      	beq.n	34191d52 <SDMMC_GetCmdResp1+0x1b2>
  {
    return SDMMC_ERROR_ERASE_RESET;
34191d4c:	f44f 0380 	mov.w	r3, #4194304	@ 0x400000
34191d50:	e009      	b.n	34191d66 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_AKE_SEQ_ERROR) == SDMMC_OCR_AKE_SEQ_ERROR)
34191d52:	697b      	ldr	r3, [r7, #20]
34191d54:	f003 0308 	and.w	r3, r3, #8
34191d58:	2b00      	cmp	r3, #0
34191d5a:	d002      	beq.n	34191d62 <SDMMC_GetCmdResp1+0x1c2>
  {
    return SDMMC_ERROR_AKE_SEQ_ERR;
34191d5c:	f44f 0300 	mov.w	r3, #8388608	@ 0x800000
34191d60:	e001      	b.n	34191d66 <SDMMC_GetCmdResp1+0x1c6>
  }
  else
  {
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
34191d62:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
  }
}
34191d66:	4618      	mov	r0, r3
34191d68:	3720      	adds	r7, #32
34191d6a:	46bd      	mov	sp, r7
34191d6c:	bd80      	pop	{r7, pc}
34191d6e:	bf00      	nop
34191d70:	341c0090 	.word	0x341c0090
34191d74:	10624dd3 	.word	0x10624dd3
34191d78:	00200045 	.word	0x00200045
34191d7c:	002000c5 	.word	0x002000c5
34191d80:	fdffe008 	.word	0xfdffe008

34191d84 <SDMMC_GetCmdResp2>:
  * @brief  Checks for error conditions for R2 (CID or CSD) response.
  * @param  hsd: SD handle
  * @retval SD Card error state
  */
uint32_t SDMMC_GetCmdResp2(SDMMC_TypeDef *SDMMCx)
{
34191d84:	b480      	push	{r7}
34191d86:	b085      	sub	sp, #20
34191d88:	af00      	add	r7, sp, #0
34191d8a:	6078      	str	r0, [r7, #4]
  uint32_t sta_reg;
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U / 1000U);
34191d8c:	4b1f      	ldr	r3, [pc, #124]	@ (34191e0c <SDMMC_GetCmdResp2+0x88>)
34191d8e:	681b      	ldr	r3, [r3, #0]
34191d90:	4a1f      	ldr	r2, [pc, #124]	@ (34191e10 <SDMMC_GetCmdResp2+0x8c>)
34191d92:	fba2 2303 	umull	r2, r3, r2, r3
34191d96:	0a5b      	lsrs	r3, r3, #9
34191d98:	f241 3288 	movw	r2, #5000	@ 0x1388
34191d9c:	fb02 f303 	mul.w	r3, r2, r3
34191da0:	60fb      	str	r3, [r7, #12]

  do
  {
    if (count-- == 0U)
34191da2:	68fb      	ldr	r3, [r7, #12]
34191da4:	1e5a      	subs	r2, r3, #1
34191da6:	60fa      	str	r2, [r7, #12]
34191da8:	2b00      	cmp	r3, #0
34191daa:	d102      	bne.n	34191db2 <SDMMC_GetCmdResp2+0x2e>
    {
      return SDMMC_ERROR_TIMEOUT;
34191dac:	f04f 4300 	mov.w	r3, #2147483648	@ 0x80000000
34191db0:	e026      	b.n	34191e00 <SDMMC_GetCmdResp2+0x7c>
    }
    sta_reg = SDMMCx->STA;
34191db2:	687b      	ldr	r3, [r7, #4]
34191db4:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
34191db6:	60bb      	str	r3, [r7, #8]
  } while (((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
34191db8:	68bb      	ldr	r3, [r7, #8]
34191dba:	f003 0345 	and.w	r3, r3, #69	@ 0x45
34191dbe:	2b00      	cmp	r3, #0
34191dc0:	d0ef      	beq.n	34191da2 <SDMMC_GetCmdResp2+0x1e>
           ((sta_reg & SDMMC_FLAG_CMDACT) != 0U));
34191dc2:	68bb      	ldr	r3, [r7, #8]
34191dc4:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
  } while (((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
34191dc8:	2b00      	cmp	r3, #0
34191dca:	d1ea      	bne.n	34191da2 <SDMMC_GetCmdResp2+0x1e>

  if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
34191dcc:	687b      	ldr	r3, [r7, #4]
34191dce:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
34191dd0:	f003 0304 	and.w	r3, r3, #4
34191dd4:	2b00      	cmp	r3, #0
34191dd6:	d004      	beq.n	34191de2 <SDMMC_GetCmdResp2+0x5e>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
34191dd8:	687b      	ldr	r3, [r7, #4]
34191dda:	2204      	movs	r2, #4
34191ddc:	639a      	str	r2, [r3, #56]	@ 0x38

    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
34191dde:	2304      	movs	r3, #4
34191de0:	e00e      	b.n	34191e00 <SDMMC_GetCmdResp2+0x7c>
  }
  else if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
34191de2:	687b      	ldr	r3, [r7, #4]
34191de4:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
34191de6:	f003 0301 	and.w	r3, r3, #1
34191dea:	2b00      	cmp	r3, #0
34191dec:	d004      	beq.n	34191df8 <SDMMC_GetCmdResp2+0x74>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
34191dee:	687b      	ldr	r3, [r7, #4]
34191df0:	2201      	movs	r2, #1
34191df2:	639a      	str	r2, [r3, #56]	@ 0x38

    return SDMMC_ERROR_CMD_CRC_FAIL;
34191df4:	2301      	movs	r3, #1
34191df6:	e003      	b.n	34191e00 <SDMMC_GetCmdResp2+0x7c>
  }
  else
  {
    /* No error flag set */
    /* Clear all the static flags */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
34191df8:	687b      	ldr	r3, [r7, #4]
34191dfa:	4a06      	ldr	r2, [pc, #24]	@ (34191e14 <SDMMC_GetCmdResp2+0x90>)
34191dfc:	639a      	str	r2, [r3, #56]	@ 0x38
  }

  return SDMMC_ERROR_NONE;
34191dfe:	2300      	movs	r3, #0
}
34191e00:	4618      	mov	r0, r3
34191e02:	3714      	adds	r7, #20
34191e04:	46bd      	mov	sp, r7
34191e06:	f85d 7b04 	ldr.w	r7, [sp], #4
34191e0a:	4770      	bx	lr
34191e0c:	341c0090 	.word	0x341c0090
34191e10:	10624dd3 	.word	0x10624dd3
34191e14:	002000c5 	.word	0x002000c5

34191e18 <SDMMC_GetCmdResp3>:
  * @brief  Checks for error conditions for R3 (OCR) response.
  * @param  hsd: SD handle
  * @retval SD Card error state
  */
uint32_t SDMMC_GetCmdResp3(SDMMC_TypeDef *SDMMCx)
{
34191e18:	b480      	push	{r7}
34191e1a:	b085      	sub	sp, #20
34191e1c:	af00      	add	r7, sp, #0
34191e1e:	6078      	str	r0, [r7, #4]
  uint32_t sta_reg;
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U / 1000U);
34191e20:	4b1a      	ldr	r3, [pc, #104]	@ (34191e8c <SDMMC_GetCmdResp3+0x74>)
34191e22:	681b      	ldr	r3, [r3, #0]
34191e24:	4a1a      	ldr	r2, [pc, #104]	@ (34191e90 <SDMMC_GetCmdResp3+0x78>)
34191e26:	fba2 2303 	umull	r2, r3, r2, r3
34191e2a:	0a5b      	lsrs	r3, r3, #9
34191e2c:	f241 3288 	movw	r2, #5000	@ 0x1388
34191e30:	fb02 f303 	mul.w	r3, r2, r3
34191e34:	60fb      	str	r3, [r7, #12]

  do
  {
    if (count-- == 0U)
34191e36:	68fb      	ldr	r3, [r7, #12]
34191e38:	1e5a      	subs	r2, r3, #1
34191e3a:	60fa      	str	r2, [r7, #12]
34191e3c:	2b00      	cmp	r3, #0
34191e3e:	d102      	bne.n	34191e46 <SDMMC_GetCmdResp3+0x2e>
    {
      return SDMMC_ERROR_TIMEOUT;
34191e40:	f04f 4300 	mov.w	r3, #2147483648	@ 0x80000000
34191e44:	e01b      	b.n	34191e7e <SDMMC_GetCmdResp3+0x66>
    }
    sta_reg = SDMMCx->STA;
34191e46:	687b      	ldr	r3, [r7, #4]
34191e48:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
34191e4a:	60bb      	str	r3, [r7, #8]
  } while (((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
34191e4c:	68bb      	ldr	r3, [r7, #8]
34191e4e:	f003 0345 	and.w	r3, r3, #69	@ 0x45
34191e52:	2b00      	cmp	r3, #0
34191e54:	d0ef      	beq.n	34191e36 <SDMMC_GetCmdResp3+0x1e>
           ((sta_reg & SDMMC_FLAG_CMDACT) != 0U));
34191e56:	68bb      	ldr	r3, [r7, #8]
34191e58:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
  } while (((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
34191e5c:	2b00      	cmp	r3, #0
34191e5e:	d1ea      	bne.n	34191e36 <SDMMC_GetCmdResp3+0x1e>

  if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
34191e60:	687b      	ldr	r3, [r7, #4]
34191e62:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
34191e64:	f003 0304 	and.w	r3, r3, #4
34191e68:	2b00      	cmp	r3, #0
34191e6a:	d004      	beq.n	34191e76 <SDMMC_GetCmdResp3+0x5e>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
34191e6c:	687b      	ldr	r3, [r7, #4]
34191e6e:	2204      	movs	r2, #4
34191e70:	639a      	str	r2, [r3, #56]	@ 0x38

    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
34191e72:	2304      	movs	r3, #4
34191e74:	e003      	b.n	34191e7e <SDMMC_GetCmdResp3+0x66>
  }
  else
  {
    /* Clear all the static flags */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
34191e76:	687b      	ldr	r3, [r7, #4]
34191e78:	4a06      	ldr	r2, [pc, #24]	@ (34191e94 <SDMMC_GetCmdResp3+0x7c>)
34191e7a:	639a      	str	r2, [r3, #56]	@ 0x38
  }

  return SDMMC_ERROR_NONE;
34191e7c:	2300      	movs	r3, #0
}
34191e7e:	4618      	mov	r0, r3
34191e80:	3714      	adds	r7, #20
34191e82:	46bd      	mov	sp, r7
34191e84:	f85d 7b04 	ldr.w	r7, [sp], #4
34191e88:	4770      	bx	lr
34191e8a:	bf00      	nop
34191e8c:	341c0090 	.word	0x341c0090
34191e90:	10624dd3 	.word	0x10624dd3
34191e94:	002000c5 	.word	0x002000c5

34191e98 <SDMMC_GetCmdResp6>:
  * @param  pRCA: Pointer to the variable that will contain the SD card relative
  *         address RCA
  * @retval SD Card error state
  */
uint32_t SDMMC_GetCmdResp6(SDMMC_TypeDef *SDMMCx, uint8_t SD_CMD, uint16_t *pRCA)
{
34191e98:	b580      	push	{r7, lr}
34191e9a:	b088      	sub	sp, #32
34191e9c:	af00      	add	r7, sp, #0
34191e9e:	60f8      	str	r0, [r7, #12]
34191ea0:	460b      	mov	r3, r1
34191ea2:	607a      	str	r2, [r7, #4]
34191ea4:	72fb      	strb	r3, [r7, #11]
  uint32_t response_r1;
  uint32_t sta_reg;

  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U / 1000U);
34191ea6:	4b35      	ldr	r3, [pc, #212]	@ (34191f7c <SDMMC_GetCmdResp6+0xe4>)
34191ea8:	681b      	ldr	r3, [r3, #0]
34191eaa:	4a35      	ldr	r2, [pc, #212]	@ (34191f80 <SDMMC_GetCmdResp6+0xe8>)
34191eac:	fba2 2303 	umull	r2, r3, r2, r3
34191eb0:	0a5b      	lsrs	r3, r3, #9
34191eb2:	f241 3288 	movw	r2, #5000	@ 0x1388
34191eb6:	fb02 f303 	mul.w	r3, r2, r3
34191eba:	61fb      	str	r3, [r7, #28]

  do
  {
    if (count-- == 0U)
34191ebc:	69fb      	ldr	r3, [r7, #28]
34191ebe:	1e5a      	subs	r2, r3, #1
34191ec0:	61fa      	str	r2, [r7, #28]
34191ec2:	2b00      	cmp	r3, #0
34191ec4:	d102      	bne.n	34191ecc <SDMMC_GetCmdResp6+0x34>
    {
      return SDMMC_ERROR_TIMEOUT;
34191ec6:	f04f 4300 	mov.w	r3, #2147483648	@ 0x80000000
34191eca:	e052      	b.n	34191f72 <SDMMC_GetCmdResp6+0xda>
    }
    sta_reg = SDMMCx->STA;
34191ecc:	68fb      	ldr	r3, [r7, #12]
34191ece:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
34191ed0:	61bb      	str	r3, [r7, #24]
  } while (((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
34191ed2:	69bb      	ldr	r3, [r7, #24]
34191ed4:	f003 0345 	and.w	r3, r3, #69	@ 0x45
34191ed8:	2b00      	cmp	r3, #0
34191eda:	d0ef      	beq.n	34191ebc <SDMMC_GetCmdResp6+0x24>
           ((sta_reg & SDMMC_FLAG_CMDACT) != 0U));
34191edc:	69bb      	ldr	r3, [r7, #24]
34191ede:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
  } while (((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
34191ee2:	2b00      	cmp	r3, #0
34191ee4:	d1ea      	bne.n	34191ebc <SDMMC_GetCmdResp6+0x24>

  if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
34191ee6:	68fb      	ldr	r3, [r7, #12]
34191ee8:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
34191eea:	f003 0304 	and.w	r3, r3, #4
34191eee:	2b00      	cmp	r3, #0
34191ef0:	d004      	beq.n	34191efc <SDMMC_GetCmdResp6+0x64>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
34191ef2:	68fb      	ldr	r3, [r7, #12]
34191ef4:	2204      	movs	r2, #4
34191ef6:	639a      	str	r2, [r3, #56]	@ 0x38

    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
34191ef8:	2304      	movs	r3, #4
34191efa:	e03a      	b.n	34191f72 <SDMMC_GetCmdResp6+0xda>
  }
  else if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
34191efc:	68fb      	ldr	r3, [r7, #12]
34191efe:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
34191f00:	f003 0301 	and.w	r3, r3, #1
34191f04:	2b00      	cmp	r3, #0
34191f06:	d004      	beq.n	34191f12 <SDMMC_GetCmdResp6+0x7a>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
34191f08:	68fb      	ldr	r3, [r7, #12]
34191f0a:	2201      	movs	r2, #1
34191f0c:	639a      	str	r2, [r3, #56]	@ 0x38

    return SDMMC_ERROR_CMD_CRC_FAIL;
34191f0e:	2301      	movs	r3, #1
34191f10:	e02f      	b.n	34191f72 <SDMMC_GetCmdResp6+0xda>
  {
    /* Nothing to do */
  }

  /* Check response received is of desired command */
  if (SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
34191f12:	68f8      	ldr	r0, [r7, #12]
34191f14:	f7ff fb7c 	bl	34191610 <SDMMC_GetCommandResponse>
34191f18:	4603      	mov	r3, r0
34191f1a:	461a      	mov	r2, r3
34191f1c:	7afb      	ldrb	r3, [r7, #11]
34191f1e:	4293      	cmp	r3, r2
34191f20:	d001      	beq.n	34191f26 <SDMMC_GetCmdResp6+0x8e>
  {
    return SDMMC_ERROR_CMD_CRC_FAIL;
34191f22:	2301      	movs	r3, #1
34191f24:	e025      	b.n	34191f72 <SDMMC_GetCmdResp6+0xda>
  }

  /* Clear all the static flags */
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
34191f26:	68fb      	ldr	r3, [r7, #12]
34191f28:	4a16      	ldr	r2, [pc, #88]	@ (34191f84 <SDMMC_GetCmdResp6+0xec>)
34191f2a:	639a      	str	r2, [r3, #56]	@ 0x38

  /* We have received response, retrieve it.  */
  response_r1 = SDMMC_GetResponse(SDMMCx, SDMMC_RESP1);
34191f2c:	2100      	movs	r1, #0
34191f2e:	68f8      	ldr	r0, [r7, #12]
34191f30:	f7ff fb7b 	bl	3419162a <SDMMC_GetResponse>
34191f34:	6178      	str	r0, [r7, #20]

  if ((response_r1 & (SDMMC_R6_GENERAL_UNKNOWN_ERROR | SDMMC_R6_ILLEGAL_CMD |
34191f36:	697b      	ldr	r3, [r7, #20]
34191f38:	f403 4360 	and.w	r3, r3, #57344	@ 0xe000
34191f3c:	2b00      	cmp	r3, #0
34191f3e:	d106      	bne.n	34191f4e <SDMMC_GetCmdResp6+0xb6>
                      SDMMC_R6_COM_CRC_FAILED)) == SDMMC_ALLZERO)
  {
    *pRCA = (uint16_t)(response_r1 >> 16);
34191f40:	697b      	ldr	r3, [r7, #20]
34191f42:	0c1b      	lsrs	r3, r3, #16
34191f44:	b29a      	uxth	r2, r3
34191f46:	687b      	ldr	r3, [r7, #4]
34191f48:	801a      	strh	r2, [r3, #0]

    return SDMMC_ERROR_NONE;
34191f4a:	2300      	movs	r3, #0
34191f4c:	e011      	b.n	34191f72 <SDMMC_GetCmdResp6+0xda>
  }
  else if ((response_r1 & SDMMC_R6_ILLEGAL_CMD) == SDMMC_R6_ILLEGAL_CMD)
34191f4e:	697b      	ldr	r3, [r7, #20]
34191f50:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
34191f54:	2b00      	cmp	r3, #0
34191f56:	d002      	beq.n	34191f5e <SDMMC_GetCmdResp6+0xc6>
  {
    return SDMMC_ERROR_ILLEGAL_CMD;
34191f58:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
34191f5c:	e009      	b.n	34191f72 <SDMMC_GetCmdResp6+0xda>
  }
  else if ((response_r1 & SDMMC_R6_COM_CRC_FAILED) == SDMMC_R6_COM_CRC_FAILED)
34191f5e:	697b      	ldr	r3, [r7, #20]
34191f60:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
34191f64:	2b00      	cmp	r3, #0
34191f66:	d002      	beq.n	34191f6e <SDMMC_GetCmdResp6+0xd6>
  {
    return SDMMC_ERROR_COM_CRC_FAILED;
34191f68:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
34191f6c:	e001      	b.n	34191f72 <SDMMC_GetCmdResp6+0xda>
  }
  else
  {
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
34191f6e:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
  }
}
34191f72:	4618      	mov	r0, r3
34191f74:	3720      	adds	r7, #32
34191f76:	46bd      	mov	sp, r7
34191f78:	bd80      	pop	{r7, pc}
34191f7a:	bf00      	nop
34191f7c:	341c0090 	.word	0x341c0090
34191f80:	10624dd3 	.word	0x10624dd3
34191f84:	002000c5 	.word	0x002000c5

34191f88 <SDMMC_GetCmdResp7>:
  * @brief  Checks for error conditions for R7 response.
  * @param  hsd: SD handle
  * @retval SD Card error state
  */
uint32_t SDMMC_GetCmdResp7(SDMMC_TypeDef *SDMMCx)
{
34191f88:	b480      	push	{r7}
34191f8a:	b085      	sub	sp, #20
34191f8c:	af00      	add	r7, sp, #0
34191f8e:	6078      	str	r0, [r7, #4]
  uint32_t sta_reg;
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U / 1000U);
34191f90:	4b22      	ldr	r3, [pc, #136]	@ (3419201c <SDMMC_GetCmdResp7+0x94>)
34191f92:	681b      	ldr	r3, [r3, #0]
34191f94:	4a22      	ldr	r2, [pc, #136]	@ (34192020 <SDMMC_GetCmdResp7+0x98>)
34191f96:	fba2 2303 	umull	r2, r3, r2, r3
34191f9a:	0a5b      	lsrs	r3, r3, #9
34191f9c:	f241 3288 	movw	r2, #5000	@ 0x1388
34191fa0:	fb02 f303 	mul.w	r3, r2, r3
34191fa4:	60fb      	str	r3, [r7, #12]

  do
  {
    if (count-- == 0U)
34191fa6:	68fb      	ldr	r3, [r7, #12]
34191fa8:	1e5a      	subs	r2, r3, #1
34191faa:	60fa      	str	r2, [r7, #12]
34191fac:	2b00      	cmp	r3, #0
34191fae:	d102      	bne.n	34191fb6 <SDMMC_GetCmdResp7+0x2e>
    {
      return SDMMC_ERROR_TIMEOUT;
34191fb0:	f04f 4300 	mov.w	r3, #2147483648	@ 0x80000000
34191fb4:	e02c      	b.n	34192010 <SDMMC_GetCmdResp7+0x88>
    }
    sta_reg = SDMMCx->STA;
34191fb6:	687b      	ldr	r3, [r7, #4]
34191fb8:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
34191fba:	60bb      	str	r3, [r7, #8]
  } while (((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
34191fbc:	68bb      	ldr	r3, [r7, #8]
34191fbe:	f003 0345 	and.w	r3, r3, #69	@ 0x45
34191fc2:	2b00      	cmp	r3, #0
34191fc4:	d0ef      	beq.n	34191fa6 <SDMMC_GetCmdResp7+0x1e>
           ((sta_reg & SDMMC_FLAG_CMDACT) != 0U));
34191fc6:	68bb      	ldr	r3, [r7, #8]
34191fc8:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
  } while (((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
34191fcc:	2b00      	cmp	r3, #0
34191fce:	d1ea      	bne.n	34191fa6 <SDMMC_GetCmdResp7+0x1e>

  if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
34191fd0:	687b      	ldr	r3, [r7, #4]
34191fd2:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
34191fd4:	f003 0304 	and.w	r3, r3, #4
34191fd8:	2b00      	cmp	r3, #0
34191fda:	d004      	beq.n	34191fe6 <SDMMC_GetCmdResp7+0x5e>
  {
    /* Card is not SD V2.0 compliant */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
34191fdc:	687b      	ldr	r3, [r7, #4]
34191fde:	2204      	movs	r2, #4
34191fe0:	639a      	str	r2, [r3, #56]	@ 0x38

    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
34191fe2:	2304      	movs	r3, #4
34191fe4:	e014      	b.n	34192010 <SDMMC_GetCmdResp7+0x88>
  }

  else if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
34191fe6:	687b      	ldr	r3, [r7, #4]
34191fe8:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
34191fea:	f003 0301 	and.w	r3, r3, #1
34191fee:	2b00      	cmp	r3, #0
34191ff0:	d004      	beq.n	34191ffc <SDMMC_GetCmdResp7+0x74>
  {
    /* Card is not SD V2.0 compliant */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
34191ff2:	687b      	ldr	r3, [r7, #4]
34191ff4:	2201      	movs	r2, #1
34191ff6:	639a      	str	r2, [r3, #56]	@ 0x38

    return SDMMC_ERROR_CMD_CRC_FAIL;
34191ff8:	2301      	movs	r3, #1
34191ffa:	e009      	b.n	34192010 <SDMMC_GetCmdResp7+0x88>
  else
  {
    /* Nothing to do */
  }

  if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CMDREND))
34191ffc:	687b      	ldr	r3, [r7, #4]
34191ffe:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
34192000:	f003 0340 	and.w	r3, r3, #64	@ 0x40
34192004:	2b00      	cmp	r3, #0
34192006:	d002      	beq.n	3419200e <SDMMC_GetCmdResp7+0x86>
  {
    /* Card is SD V2.0 compliant */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CMDREND);
34192008:	687b      	ldr	r3, [r7, #4]
3419200a:	2240      	movs	r2, #64	@ 0x40
3419200c:	639a      	str	r2, [r3, #56]	@ 0x38
  }

  return SDMMC_ERROR_NONE;
3419200e:	2300      	movs	r3, #0

}
34192010:	4618      	mov	r0, r3
34192012:	3714      	adds	r7, #20
34192014:	46bd      	mov	sp, r7
34192016:	f85d 7b04 	ldr.w	r7, [sp], #4
3419201a:	4770      	bx	lr
3419201c:	341c0090 	.word	0x341c0090
34192020:	10624dd3 	.word	0x10624dd3

34192024 <SDMMC_GetCmdError>:
  * @brief  Checks for error conditions for CMD0.
  * @param  hsd: SD handle
  * @retval SD Card error state
  */
static uint32_t SDMMC_GetCmdError(SDMMC_TypeDef *SDMMCx)
{
34192024:	b480      	push	{r7}
34192026:	b085      	sub	sp, #20
34192028:	af00      	add	r7, sp, #0
3419202a:	6078      	str	r0, [r7, #4]
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U / 1000U);
3419202c:	4b11      	ldr	r3, [pc, #68]	@ (34192074 <SDMMC_GetCmdError+0x50>)
3419202e:	681b      	ldr	r3, [r3, #0]
34192030:	4a11      	ldr	r2, [pc, #68]	@ (34192078 <SDMMC_GetCmdError+0x54>)
34192032:	fba2 2303 	umull	r2, r3, r2, r3
34192036:	0a5b      	lsrs	r3, r3, #9
34192038:	f241 3288 	movw	r2, #5000	@ 0x1388
3419203c:	fb02 f303 	mul.w	r3, r2, r3
34192040:	60fb      	str	r3, [r7, #12]

  do
  {
    if (count-- == 0U)
34192042:	68fb      	ldr	r3, [r7, #12]
34192044:	1e5a      	subs	r2, r3, #1
34192046:	60fa      	str	r2, [r7, #12]
34192048:	2b00      	cmp	r3, #0
3419204a:	d102      	bne.n	34192052 <SDMMC_GetCmdError+0x2e>
    {
      return SDMMC_ERROR_TIMEOUT;
3419204c:	f04f 4300 	mov.w	r3, #2147483648	@ 0x80000000
34192050:	e009      	b.n	34192066 <SDMMC_GetCmdError+0x42>
    }

  } while (!__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CMDSENT));
34192052:	687b      	ldr	r3, [r7, #4]
34192054:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
34192056:	f003 0380 	and.w	r3, r3, #128	@ 0x80
3419205a:	2b00      	cmp	r3, #0
3419205c:	d0f1      	beq.n	34192042 <SDMMC_GetCmdError+0x1e>

  /* Clear all the static flags */
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
3419205e:	687b      	ldr	r3, [r7, #4]
34192060:	4a06      	ldr	r2, [pc, #24]	@ (3419207c <SDMMC_GetCmdError+0x58>)
34192062:	639a      	str	r2, [r3, #56]	@ 0x38

  return SDMMC_ERROR_NONE;
34192064:	2300      	movs	r3, #0
}
34192066:	4618      	mov	r0, r3
34192068:	3714      	adds	r7, #20
3419206a:	46bd      	mov	sp, r7
3419206c:	f85d 7b04 	ldr.w	r7, [sp], #4
34192070:	4770      	bx	lr
34192072:	bf00      	nop
34192074:	341c0090 	.word	0x341c0090
34192078:	10624dd3 	.word	0x10624dd3
3419207c:	002000c5 	.word	0x002000c5

34192080 <LL_APB1_GRP2_EnableClock>:
{
34192080:	b480      	push	{r7}
34192082:	b085      	sub	sp, #20
34192084:	af00      	add	r7, sp, #0
34192086:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->APB1ENSR2, Periphs);
34192088:	4a07      	ldr	r2, [pc, #28]	@ (341920a8 <LL_APB1_GRP2_EnableClock+0x28>)
3419208a:	687b      	ldr	r3, [r7, #4]
3419208c:	f8c2 3a68 	str.w	r3, [r2, #2664]	@ 0xa68
  tmpreg = READ_REG(RCC->APB1ENR2);
34192090:	4b05      	ldr	r3, [pc, #20]	@ (341920a8 <LL_APB1_GRP2_EnableClock+0x28>)
34192092:	f8d3 3268 	ldr.w	r3, [r3, #616]	@ 0x268
34192096:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34192098:	68fb      	ldr	r3, [r7, #12]
}
3419209a:	bf00      	nop
3419209c:	3714      	adds	r7, #20
3419209e:	46bd      	mov	sp, r7
341920a0:	f85d 7b04 	ldr.w	r7, [sp], #4
341920a4:	4770      	bx	lr
341920a6:	bf00      	nop
341920a8:	56028000 	.word	0x56028000

341920ac <LL_UCPD_Disable>:
  * @rmtoll CFG1          UCPDEN           LL_UCPD_Disable
  * @param  UCPDx UCPD Instance
  * @retval None
  */
__STATIC_INLINE void LL_UCPD_Disable(UCPD_TypeDef *UCPDx)
{
341920ac:	b480      	push	{r7}
341920ae:	b083      	sub	sp, #12
341920b0:	af00      	add	r7, sp, #0
341920b2:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(UCPDx->CFG1, UCPD_CFG1_UCPDEN);
341920b4:	687b      	ldr	r3, [r7, #4]
341920b6:	681b      	ldr	r3, [r3, #0]
341920b8:	f023 4200 	bic.w	r2, r3, #2147483648	@ 0x80000000
341920bc:	687b      	ldr	r3, [r7, #4]
341920be:	601a      	str	r2, [r3, #0]
}
341920c0:	bf00      	nop
341920c2:	370c      	adds	r7, #12
341920c4:	46bd      	mov	sp, r7
341920c6:	f85d 7b04 	ldr.w	r7, [sp], #4
341920ca:	4770      	bx	lr

341920cc <LL_UCPD_Init>:
  * @param  UCPD_InitStruct pointer to a @ref LL_UCPD_InitTypeDef structure that contains
  *         the configuration information for the UCPD peripheral.
  * @retval An ErrorStatus enumeration value. (Return always SUCCESS)
  */
ErrorStatus LL_UCPD_Init(UCPD_TypeDef *UCPDx, const LL_UCPD_InitTypeDef *UCPD_InitStruct)
{
341920cc:	b580      	push	{r7, lr}
341920ce:	b082      	sub	sp, #8
341920d0:	af00      	add	r7, sp, #0
341920d2:	6078      	str	r0, [r7, #4]
341920d4:	6039      	str	r1, [r7, #0]
  /* Check the ucpd Instance UCPDx*/
  assert_param(IS_UCPD_ALL_INSTANCE(UCPDx));

  if (UCPD1 == UCPDx)
341920d6:	687b      	ldr	r3, [r7, #4]
341920d8:	4a11      	ldr	r2, [pc, #68]	@ (34192120 <LL_UCPD_Init+0x54>)
341920da:	4293      	cmp	r3, r2
341920dc:	d103      	bne.n	341920e6 <LL_UCPD_Init+0x1a>
  {
    LL_APB1_GRP2_EnableClock(LL_APB1_GRP2_PERIPH_UCPD1);
341920de:	f44f 2080 	mov.w	r0, #262144	@ 0x40000
341920e2:	f7ff ffcd 	bl	34192080 <LL_APB1_GRP2_EnableClock>
  }


  LL_UCPD_Disable(UCPDx);
341920e6:	6878      	ldr	r0, [r7, #4]
341920e8:	f7ff ffe0 	bl	341920ac <LL_UCPD_Disable>

  /*---------------------------- UCPDx CFG1 Configuration ------------------------*/
  MODIFY_REG(UCPDx->CFG1,
341920ec:	687b      	ldr	r3, [r7, #4]
341920ee:	681a      	ldr	r2, [r3, #0]
341920f0:	4b0c      	ldr	r3, [pc, #48]	@ (34192124 <LL_UCPD_Init+0x58>)
341920f2:	4013      	ands	r3, r2
341920f4:	683a      	ldr	r2, [r7, #0]
341920f6:	6811      	ldr	r1, [r2, #0]
341920f8:	683a      	ldr	r2, [r7, #0]
341920fa:	6852      	ldr	r2, [r2, #4]
341920fc:	02d2      	lsls	r2, r2, #11
341920fe:	4311      	orrs	r1, r2
34192100:	683a      	ldr	r2, [r7, #0]
34192102:	6892      	ldr	r2, [r2, #8]
34192104:	0192      	lsls	r2, r2, #6
34192106:	4311      	orrs	r1, r2
34192108:	683a      	ldr	r2, [r7, #0]
3419210a:	68d2      	ldr	r2, [r2, #12]
3419210c:	430a      	orrs	r2, r1
3419210e:	431a      	orrs	r2, r3
34192110:	687b      	ldr	r3, [r7, #4]
34192112:	601a      	str	r2, [r3, #0]
             UCPD_CFG1_PSC_UCPDCLK | UCPD_CFG1_TRANSWIN | UCPD_CFG1_IFRGAP | UCPD_CFG1_HBITCLKDIV,
             UCPD_InitStruct->psc_ucpdclk | (UCPD_InitStruct->transwin  << UCPD_CFG1_TRANSWIN_Pos) |
             (UCPD_InitStruct->IfrGap << UCPD_CFG1_IFRGAP_Pos) | UCPD_InitStruct->HbitClockDiv);

  return SUCCESS;
34192114:	2300      	movs	r3, #0
}
34192116:	4618      	mov	r0, r3
34192118:	3708      	adds	r7, #8
3419211a:	46bd      	mov	sp, r7
3419211c:	bd80      	pop	{r7, pc}
3419211e:	bf00      	nop
34192120:	5000fc00 	.word	0x5000fc00
34192124:	fff10000 	.word	0xfff10000

34192128 <LL_UCPD_StructInit>:
  * @param  UCPD_InitStruct pointer to a @ref LL_UCPD_InitTypeDef structure
  *         whose fields will be set to default values.
  * @retval None
  */
void LL_UCPD_StructInit(LL_UCPD_InitTypeDef *UCPD_InitStruct)
{
34192128:	b480      	push	{r7}
3419212a:	b083      	sub	sp, #12
3419212c:	af00      	add	r7, sp, #0
3419212e:	6078      	str	r0, [r7, #4]
  /* Set UCPD_InitStruct fields to default values */
  UCPD_InitStruct->psc_ucpdclk  = LL_UCPD_PSC_DIV2;
34192130:	687b      	ldr	r3, [r7, #4]
34192132:	f44f 3200 	mov.w	r2, #131072	@ 0x20000
34192136:	601a      	str	r2, [r3, #0]
  UCPD_InitStruct->transwin     = 0x7;   /* Divide by 8                     */
34192138:	687b      	ldr	r3, [r7, #4]
3419213a:	2207      	movs	r2, #7
3419213c:	605a      	str	r2, [r3, #4]
  UCPD_InitStruct->IfrGap       = 0x10;  /* Divide by 17                    */
3419213e:	687b      	ldr	r3, [r7, #4]
34192140:	2210      	movs	r2, #16
34192142:	609a      	str	r2, [r3, #8]
  UCPD_InitStruct->HbitClockDiv = 0x0D;  /* Divide by 14 to produce HBITCLK */
34192144:	687b      	ldr	r3, [r7, #4]
34192146:	220d      	movs	r2, #13
34192148:	60da      	str	r2, [r3, #12]
}
3419214a:	bf00      	nop
3419214c:	370c      	adds	r7, #12
3419214e:	46bd      	mov	sp, r7
34192150:	f85d 7b04 	ldr.w	r7, [sp], #4
34192154:	4770      	bx	lr

34192156 <USB_CoreInit>:
  * @param  cfg pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
34192156:	b084      	sub	sp, #16
34192158:	b580      	push	{r7, lr}
3419215a:	b084      	sub	sp, #16
3419215c:	af00      	add	r7, sp, #0
3419215e:	6078      	str	r0, [r7, #4]
34192160:	f107 001c 	add.w	r0, r7, #28
34192164:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  HAL_StatusTypeDef ret;

  if (cfg.phy_itface == USB_OTG_HS_EMBEDDED_PHY)
34192168:	f897 3021 	ldrb.w	r3, [r7, #33]	@ 0x21
3419216c:	2b03      	cmp	r3, #3
3419216e:	d10e      	bne.n	3419218e <USB_CoreInit+0x38>
  {
    /* Select Data line pulsing using utmi_txvalid */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS);
34192170:	687b      	ldr	r3, [r7, #4]
34192172:	68db      	ldr	r3, [r3, #12]
34192174:	f423 0280 	bic.w	r2, r3, #4194304	@ 0x400000
34192178:	687b      	ldr	r3, [r7, #4]
3419217a:	60da      	str	r2, [r3, #12]


    /* Reset after a PHY select */
    ret = USB_CoreReset(USBx);
3419217c:	6878      	ldr	r0, [r7, #4]
3419217e:	f001 facf 	bl	34193720 <USB_CoreReset>
34192182:	4603      	mov	r3, r0
34192184:	73fb      	strb	r3, [r7, #15]
  else
  {
    return HAL_ERROR;
  }

  if (cfg.dma_enable == 1U)
34192186:	7fbb      	ldrb	r3, [r7, #30]
34192188:	2b01      	cmp	r3, #1
3419218a:	d10e      	bne.n	341921aa <USB_CoreInit+0x54>
3419218c:	e001      	b.n	34192192 <USB_CoreInit+0x3c>
    return HAL_ERROR;
3419218e:	2301      	movs	r3, #1
34192190:	e00c      	b.n	341921ac <USB_CoreInit+0x56>
  {
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_HBSTLEN_2;
34192192:	687b      	ldr	r3, [r7, #4]
34192194:	689b      	ldr	r3, [r3, #8]
34192196:	f043 0206 	orr.w	r2, r3, #6
3419219a:	687b      	ldr	r3, [r7, #4]
3419219c:	609a      	str	r2, [r3, #8]
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
3419219e:	687b      	ldr	r3, [r7, #4]
341921a0:	689b      	ldr	r3, [r3, #8]
341921a2:	f043 0220 	orr.w	r2, r3, #32
341921a6:	687b      	ldr	r3, [r7, #4]
341921a8:	609a      	str	r2, [r3, #8]
  }

  return ret;
341921aa:	7bfb      	ldrb	r3, [r7, #15]
}
341921ac:	4618      	mov	r0, r3
341921ae:	3710      	adds	r7, #16
341921b0:	46bd      	mov	sp, r7
341921b2:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
341921b6:	b004      	add	sp, #16
341921b8:	4770      	bx	lr
	...

341921bc <USB_SetTurnaroundTime>:
  * @param  hclk: AHB clock frequency
  * @retval USB turnaround time In PHY Clocks number
  */
HAL_StatusTypeDef USB_SetTurnaroundTime(USB_OTG_GlobalTypeDef *USBx,
                                        uint32_t hclk, uint8_t speed)
{
341921bc:	b480      	push	{r7}
341921be:	b087      	sub	sp, #28
341921c0:	af00      	add	r7, sp, #0
341921c2:	60f8      	str	r0, [r7, #12]
341921c4:	60b9      	str	r1, [r7, #8]
341921c6:	4613      	mov	r3, r2
341921c8:	71fb      	strb	r3, [r7, #7]

  /* The USBTRD is configured according to the tables below, depending on AHB frequency
  used by application. In the low AHB frequency range it is used to stretch enough the USB response
  time to IN tokens, the USB turnaround time, so to compensate for the longer AHB read access
  latency to the Data FIFO */
  if (speed == USBD_FS_SPEED)
341921ca:	79fb      	ldrb	r3, [r7, #7]
341921cc:	2b02      	cmp	r3, #2
341921ce:	d165      	bne.n	3419229c <USB_SetTurnaroundTime+0xe0>
  {
    if ((hclk >= 14200000U) && (hclk < 15000000U))
341921d0:	68bb      	ldr	r3, [r7, #8]
341921d2:	4a41      	ldr	r2, [pc, #260]	@ (341922d8 <USB_SetTurnaroundTime+0x11c>)
341921d4:	4293      	cmp	r3, r2
341921d6:	d906      	bls.n	341921e6 <USB_SetTurnaroundTime+0x2a>
341921d8:	68bb      	ldr	r3, [r7, #8]
341921da:	4a40      	ldr	r2, [pc, #256]	@ (341922dc <USB_SetTurnaroundTime+0x120>)
341921dc:	4293      	cmp	r3, r2
341921de:	d202      	bcs.n	341921e6 <USB_SetTurnaroundTime+0x2a>
    {
      /* hclk Clock Range between 14.2-15 MHz */
      UsbTrd = 0xFU;
341921e0:	230f      	movs	r3, #15
341921e2:	617b      	str	r3, [r7, #20]
341921e4:	e062      	b.n	341922ac <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 15000000U) && (hclk < 16000000U))
341921e6:	68bb      	ldr	r3, [r7, #8]
341921e8:	4a3c      	ldr	r2, [pc, #240]	@ (341922dc <USB_SetTurnaroundTime+0x120>)
341921ea:	4293      	cmp	r3, r2
341921ec:	d306      	bcc.n	341921fc <USB_SetTurnaroundTime+0x40>
341921ee:	68bb      	ldr	r3, [r7, #8]
341921f0:	4a3b      	ldr	r2, [pc, #236]	@ (341922e0 <USB_SetTurnaroundTime+0x124>)
341921f2:	4293      	cmp	r3, r2
341921f4:	d202      	bcs.n	341921fc <USB_SetTurnaroundTime+0x40>
    {
      /* hclk Clock Range between 15-16 MHz */
      UsbTrd = 0xEU;
341921f6:	230e      	movs	r3, #14
341921f8:	617b      	str	r3, [r7, #20]
341921fa:	e057      	b.n	341922ac <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 16000000U) && (hclk < 17200000U))
341921fc:	68bb      	ldr	r3, [r7, #8]
341921fe:	4a38      	ldr	r2, [pc, #224]	@ (341922e0 <USB_SetTurnaroundTime+0x124>)
34192200:	4293      	cmp	r3, r2
34192202:	d306      	bcc.n	34192212 <USB_SetTurnaroundTime+0x56>
34192204:	68bb      	ldr	r3, [r7, #8]
34192206:	4a37      	ldr	r2, [pc, #220]	@ (341922e4 <USB_SetTurnaroundTime+0x128>)
34192208:	4293      	cmp	r3, r2
3419220a:	d202      	bcs.n	34192212 <USB_SetTurnaroundTime+0x56>
    {
      /* hclk Clock Range between 16-17.2 MHz */
      UsbTrd = 0xDU;
3419220c:	230d      	movs	r3, #13
3419220e:	617b      	str	r3, [r7, #20]
34192210:	e04c      	b.n	341922ac <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 17200000U) && (hclk < 18500000U))
34192212:	68bb      	ldr	r3, [r7, #8]
34192214:	4a33      	ldr	r2, [pc, #204]	@ (341922e4 <USB_SetTurnaroundTime+0x128>)
34192216:	4293      	cmp	r3, r2
34192218:	d306      	bcc.n	34192228 <USB_SetTurnaroundTime+0x6c>
3419221a:	68bb      	ldr	r3, [r7, #8]
3419221c:	4a32      	ldr	r2, [pc, #200]	@ (341922e8 <USB_SetTurnaroundTime+0x12c>)
3419221e:	4293      	cmp	r3, r2
34192220:	d802      	bhi.n	34192228 <USB_SetTurnaroundTime+0x6c>
    {
      /* hclk Clock Range between 17.2-18.5 MHz */
      UsbTrd = 0xCU;
34192222:	230c      	movs	r3, #12
34192224:	617b      	str	r3, [r7, #20]
34192226:	e041      	b.n	341922ac <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 18500000U) && (hclk < 20000000U))
34192228:	68bb      	ldr	r3, [r7, #8]
3419222a:	4a2f      	ldr	r2, [pc, #188]	@ (341922e8 <USB_SetTurnaroundTime+0x12c>)
3419222c:	4293      	cmp	r3, r2
3419222e:	d906      	bls.n	3419223e <USB_SetTurnaroundTime+0x82>
34192230:	68bb      	ldr	r3, [r7, #8]
34192232:	4a2e      	ldr	r2, [pc, #184]	@ (341922ec <USB_SetTurnaroundTime+0x130>)
34192234:	4293      	cmp	r3, r2
34192236:	d802      	bhi.n	3419223e <USB_SetTurnaroundTime+0x82>
    {
      /* hclk Clock Range between 18.5-20 MHz */
      UsbTrd = 0xBU;
34192238:	230b      	movs	r3, #11
3419223a:	617b      	str	r3, [r7, #20]
3419223c:	e036      	b.n	341922ac <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 20000000U) && (hclk < 21800000U))
3419223e:	68bb      	ldr	r3, [r7, #8]
34192240:	4a2a      	ldr	r2, [pc, #168]	@ (341922ec <USB_SetTurnaroundTime+0x130>)
34192242:	4293      	cmp	r3, r2
34192244:	d906      	bls.n	34192254 <USB_SetTurnaroundTime+0x98>
34192246:	68bb      	ldr	r3, [r7, #8]
34192248:	4a29      	ldr	r2, [pc, #164]	@ (341922f0 <USB_SetTurnaroundTime+0x134>)
3419224a:	4293      	cmp	r3, r2
3419224c:	d802      	bhi.n	34192254 <USB_SetTurnaroundTime+0x98>
    {
      /* hclk Clock Range between 20-21.8 MHz */
      UsbTrd = 0xAU;
3419224e:	230a      	movs	r3, #10
34192250:	617b      	str	r3, [r7, #20]
34192252:	e02b      	b.n	341922ac <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 21800000U) && (hclk < 24000000U))
34192254:	68bb      	ldr	r3, [r7, #8]
34192256:	4a26      	ldr	r2, [pc, #152]	@ (341922f0 <USB_SetTurnaroundTime+0x134>)
34192258:	4293      	cmp	r3, r2
3419225a:	d906      	bls.n	3419226a <USB_SetTurnaroundTime+0xae>
3419225c:	68bb      	ldr	r3, [r7, #8]
3419225e:	4a25      	ldr	r2, [pc, #148]	@ (341922f4 <USB_SetTurnaroundTime+0x138>)
34192260:	4293      	cmp	r3, r2
34192262:	d202      	bcs.n	3419226a <USB_SetTurnaroundTime+0xae>
    {
      /* hclk Clock Range between 21.8-24 MHz */
      UsbTrd = 0x9U;
34192264:	2309      	movs	r3, #9
34192266:	617b      	str	r3, [r7, #20]
34192268:	e020      	b.n	341922ac <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 24000000U) && (hclk < 27700000U))
3419226a:	68bb      	ldr	r3, [r7, #8]
3419226c:	4a21      	ldr	r2, [pc, #132]	@ (341922f4 <USB_SetTurnaroundTime+0x138>)
3419226e:	4293      	cmp	r3, r2
34192270:	d306      	bcc.n	34192280 <USB_SetTurnaroundTime+0xc4>
34192272:	68bb      	ldr	r3, [r7, #8]
34192274:	4a20      	ldr	r2, [pc, #128]	@ (341922f8 <USB_SetTurnaroundTime+0x13c>)
34192276:	4293      	cmp	r3, r2
34192278:	d802      	bhi.n	34192280 <USB_SetTurnaroundTime+0xc4>
    {
      /* hclk Clock Range between 24-27.7 MHz */
      UsbTrd = 0x8U;
3419227a:	2308      	movs	r3, #8
3419227c:	617b      	str	r3, [r7, #20]
3419227e:	e015      	b.n	341922ac <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 27700000U) && (hclk < 32000000U))
34192280:	68bb      	ldr	r3, [r7, #8]
34192282:	4a1d      	ldr	r2, [pc, #116]	@ (341922f8 <USB_SetTurnaroundTime+0x13c>)
34192284:	4293      	cmp	r3, r2
34192286:	d906      	bls.n	34192296 <USB_SetTurnaroundTime+0xda>
34192288:	68bb      	ldr	r3, [r7, #8]
3419228a:	4a1c      	ldr	r2, [pc, #112]	@ (341922fc <USB_SetTurnaroundTime+0x140>)
3419228c:	4293      	cmp	r3, r2
3419228e:	d202      	bcs.n	34192296 <USB_SetTurnaroundTime+0xda>
    {
      /* hclk Clock Range between 27.7-32 MHz */
      UsbTrd = 0x7U;
34192290:	2307      	movs	r3, #7
34192292:	617b      	str	r3, [r7, #20]
34192294:	e00a      	b.n	341922ac <USB_SetTurnaroundTime+0xf0>
    }
    else /* if(hclk >= 32000000) */
    {
      /* hclk Clock Range between 32-200 MHz */
      UsbTrd = 0x6U;
34192296:	2306      	movs	r3, #6
34192298:	617b      	str	r3, [r7, #20]
3419229a:	e007      	b.n	341922ac <USB_SetTurnaroundTime+0xf0>
    }
  }
  else if (speed == USBD_HS_SPEED)
3419229c:	79fb      	ldrb	r3, [r7, #7]
3419229e:	2b00      	cmp	r3, #0
341922a0:	d102      	bne.n	341922a8 <USB_SetTurnaroundTime+0xec>
  {
    UsbTrd = USBD_HS_TRDT_VALUE;
341922a2:	2309      	movs	r3, #9
341922a4:	617b      	str	r3, [r7, #20]
341922a6:	e001      	b.n	341922ac <USB_SetTurnaroundTime+0xf0>
  }
  else
  {
    UsbTrd = USBD_DEFAULT_TRDT_VALUE;
341922a8:	2309      	movs	r3, #9
341922aa:	617b      	str	r3, [r7, #20]
  }

  USBx->GUSBCFG &= ~USB_OTG_GUSBCFG_TRDT;
341922ac:	68fb      	ldr	r3, [r7, #12]
341922ae:	68db      	ldr	r3, [r3, #12]
341922b0:	f423 5270 	bic.w	r2, r3, #15360	@ 0x3c00
341922b4:	68fb      	ldr	r3, [r7, #12]
341922b6:	60da      	str	r2, [r3, #12]
  USBx->GUSBCFG |= (uint32_t)((UsbTrd << 10) & USB_OTG_GUSBCFG_TRDT);
341922b8:	68fb      	ldr	r3, [r7, #12]
341922ba:	68da      	ldr	r2, [r3, #12]
341922bc:	697b      	ldr	r3, [r7, #20]
341922be:	029b      	lsls	r3, r3, #10
341922c0:	f403 5370 	and.w	r3, r3, #15360	@ 0x3c00
341922c4:	431a      	orrs	r2, r3
341922c6:	68fb      	ldr	r3, [r7, #12]
341922c8:	60da      	str	r2, [r3, #12]

  return HAL_OK;
341922ca:	2300      	movs	r3, #0
}
341922cc:	4618      	mov	r0, r3
341922ce:	371c      	adds	r7, #28
341922d0:	46bd      	mov	sp, r7
341922d2:	f85d 7b04 	ldr.w	r7, [sp], #4
341922d6:	4770      	bx	lr
341922d8:	00d8acbf 	.word	0x00d8acbf
341922dc:	00e4e1c0 	.word	0x00e4e1c0
341922e0:	00f42400 	.word	0x00f42400
341922e4:	01067380 	.word	0x01067380
341922e8:	011a499f 	.word	0x011a499f
341922ec:	01312cff 	.word	0x01312cff
341922f0:	014ca43f 	.word	0x014ca43f
341922f4:	016e3600 	.word	0x016e3600
341922f8:	01a6ab1f 	.word	0x01a6ab1f
341922fc:	01e84800 	.word	0x01e84800

34192300 <USB_EnableGlobalInt>:
  *         Enables the controller's Global Int in the AHB Config reg
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EnableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
34192300:	b480      	push	{r7}
34192302:	b083      	sub	sp, #12
34192304:	af00      	add	r7, sp, #0
34192306:	6078      	str	r0, [r7, #4]
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
34192308:	687b      	ldr	r3, [r7, #4]
3419230a:	689b      	ldr	r3, [r3, #8]
3419230c:	f043 0201 	orr.w	r2, r3, #1
34192310:	687b      	ldr	r3, [r7, #4]
34192312:	609a      	str	r2, [r3, #8]
  return HAL_OK;
34192314:	2300      	movs	r3, #0
}
34192316:	4618      	mov	r0, r3
34192318:	370c      	adds	r7, #12
3419231a:	46bd      	mov	sp, r7
3419231c:	f85d 7b04 	ldr.w	r7, [sp], #4
34192320:	4770      	bx	lr

34192322 <USB_DisableGlobalInt>:
  *         Disable the controller's Global Int in the AHB Config reg
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DisableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
34192322:	b480      	push	{r7}
34192324:	b083      	sub	sp, #12
34192326:	af00      	add	r7, sp, #0
34192328:	6078      	str	r0, [r7, #4]
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
3419232a:	687b      	ldr	r3, [r7, #4]
3419232c:	689b      	ldr	r3, [r3, #8]
3419232e:	f023 0201 	bic.w	r2, r3, #1
34192332:	687b      	ldr	r3, [r7, #4]
34192334:	609a      	str	r2, [r3, #8]
  return HAL_OK;
34192336:	2300      	movs	r3, #0
}
34192338:	4618      	mov	r0, r3
3419233a:	370c      	adds	r7, #12
3419233c:	46bd      	mov	sp, r7
3419233e:	f85d 7b04 	ldr.w	r7, [sp], #4
34192342:	4770      	bx	lr

34192344 <USB_SetCurrentMode>:
  *            @arg USB_DEVICE_MODE Peripheral mode
  *            @arg USB_HOST_MODE Host mode
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx, USB_OTG_ModeTypeDef mode)
{
34192344:	b580      	push	{r7, lr}
34192346:	b084      	sub	sp, #16
34192348:	af00      	add	r7, sp, #0
3419234a:	6078      	str	r0, [r7, #4]
3419234c:	460b      	mov	r3, r1
3419234e:	70fb      	strb	r3, [r7, #3]
  uint32_t ms = 0U;
34192350:	2300      	movs	r3, #0
34192352:	60fb      	str	r3, [r7, #12]

  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD);
34192354:	687b      	ldr	r3, [r7, #4]
34192356:	68db      	ldr	r3, [r3, #12]
34192358:	f023 42c0 	bic.w	r2, r3, #1610612736	@ 0x60000000
3419235c:	687b      	ldr	r3, [r7, #4]
3419235e:	60da      	str	r2, [r3, #12]

  if (mode == USB_HOST_MODE)
34192360:	78fb      	ldrb	r3, [r7, #3]
34192362:	2b01      	cmp	r3, #1
34192364:	d115      	bne.n	34192392 <USB_SetCurrentMode+0x4e>
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD;
34192366:	687b      	ldr	r3, [r7, #4]
34192368:	68db      	ldr	r3, [r3, #12]
3419236a:	f043 5200 	orr.w	r2, r3, #536870912	@ 0x20000000
3419236e:	687b      	ldr	r3, [r7, #4]
34192370:	60da      	str	r2, [r3, #12]

    do
    {
      HAL_Delay(10U);
34192372:	200a      	movs	r0, #10
34192374:	f7f3 f92c 	bl	341855d0 <HAL_Delay>
      ms += 10U;
34192378:	68fb      	ldr	r3, [r7, #12]
3419237a:	330a      	adds	r3, #10
3419237c:	60fb      	str	r3, [r7, #12]
    } while ((USB_GetMode(USBx) != (uint32_t)USB_HOST_MODE) && (ms < HAL_USB_CURRENT_MODE_MAX_DELAY_MS));
3419237e:	6878      	ldr	r0, [r7, #4]
34192380:	f001 f93f 	bl	34193602 <USB_GetMode>
34192384:	4603      	mov	r3, r0
34192386:	2b01      	cmp	r3, #1
34192388:	d01e      	beq.n	341923c8 <USB_SetCurrentMode+0x84>
3419238a:	68fb      	ldr	r3, [r7, #12]
3419238c:	2bc7      	cmp	r3, #199	@ 0xc7
3419238e:	d9f0      	bls.n	34192372 <USB_SetCurrentMode+0x2e>
34192390:	e01a      	b.n	341923c8 <USB_SetCurrentMode+0x84>
  }
  else if (mode == USB_DEVICE_MODE)
34192392:	78fb      	ldrb	r3, [r7, #3]
34192394:	2b00      	cmp	r3, #0
34192396:	d115      	bne.n	341923c4 <USB_SetCurrentMode+0x80>
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD;
34192398:	687b      	ldr	r3, [r7, #4]
3419239a:	68db      	ldr	r3, [r3, #12]
3419239c:	f043 4280 	orr.w	r2, r3, #1073741824	@ 0x40000000
341923a0:	687b      	ldr	r3, [r7, #4]
341923a2:	60da      	str	r2, [r3, #12]

    do
    {
      HAL_Delay(10U);
341923a4:	200a      	movs	r0, #10
341923a6:	f7f3 f913 	bl	341855d0 <HAL_Delay>
      ms += 10U;
341923aa:	68fb      	ldr	r3, [r7, #12]
341923ac:	330a      	adds	r3, #10
341923ae:	60fb      	str	r3, [r7, #12]
    } while ((USB_GetMode(USBx) != (uint32_t)USB_DEVICE_MODE) && (ms < HAL_USB_CURRENT_MODE_MAX_DELAY_MS));
341923b0:	6878      	ldr	r0, [r7, #4]
341923b2:	f001 f926 	bl	34193602 <USB_GetMode>
341923b6:	4603      	mov	r3, r0
341923b8:	2b00      	cmp	r3, #0
341923ba:	d005      	beq.n	341923c8 <USB_SetCurrentMode+0x84>
341923bc:	68fb      	ldr	r3, [r7, #12]
341923be:	2bc7      	cmp	r3, #199	@ 0xc7
341923c0:	d9f0      	bls.n	341923a4 <USB_SetCurrentMode+0x60>
341923c2:	e001      	b.n	341923c8 <USB_SetCurrentMode+0x84>
  }
  else
  {
    return HAL_ERROR;
341923c4:	2301      	movs	r3, #1
341923c6:	e005      	b.n	341923d4 <USB_SetCurrentMode+0x90>
  }

  if (ms == HAL_USB_CURRENT_MODE_MAX_DELAY_MS)
341923c8:	68fb      	ldr	r3, [r7, #12]
341923ca:	2bc8      	cmp	r3, #200	@ 0xc8
341923cc:	d101      	bne.n	341923d2 <USB_SetCurrentMode+0x8e>
  {
    return HAL_ERROR;
341923ce:	2301      	movs	r3, #1
341923d0:	e000      	b.n	341923d4 <USB_SetCurrentMode+0x90>
  }

  return HAL_OK;
341923d2:	2300      	movs	r3, #0
}
341923d4:	4618      	mov	r0, r3
341923d6:	3710      	adds	r7, #16
341923d8:	46bd      	mov	sp, r7
341923da:	bd80      	pop	{r7, pc}

341923dc <USB_DevInit>:
  * @param  cfg   pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
341923dc:	b084      	sub	sp, #16
341923de:	b580      	push	{r7, lr}
341923e0:	b086      	sub	sp, #24
341923e2:	af00      	add	r7, sp, #0
341923e4:	6078      	str	r0, [r7, #4]
341923e6:	f107 0024 	add.w	r0, r7, #36	@ 0x24
341923ea:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  HAL_StatusTypeDef ret = HAL_OK;
341923ee:	2300      	movs	r3, #0
341923f0:	75fb      	strb	r3, [r7, #23]
  uint32_t USBx_BASE = (uint32_t)USBx;
341923f2:	687b      	ldr	r3, [r7, #4]
341923f4:	60fb      	str	r3, [r7, #12]
  uint32_t i;

  for (i = 0U; i < 15U; i++)
341923f6:	2300      	movs	r3, #0
341923f8:	613b      	str	r3, [r7, #16]
341923fa:	e009      	b.n	34192410 <USB_DevInit+0x34>
  {
    USBx->DIEPTXF[i] = 0U;
341923fc:	687a      	ldr	r2, [r7, #4]
341923fe:	693b      	ldr	r3, [r7, #16]
34192400:	3340      	adds	r3, #64	@ 0x40
34192402:	009b      	lsls	r3, r3, #2
34192404:	4413      	add	r3, r2
34192406:	2200      	movs	r2, #0
34192408:	605a      	str	r2, [r3, #4]
  for (i = 0U; i < 15U; i++)
3419240a:	693b      	ldr	r3, [r7, #16]
3419240c:	3301      	adds	r3, #1
3419240e:	613b      	str	r3, [r7, #16]
34192410:	693b      	ldr	r3, [r7, #16]
34192412:	2b0e      	cmp	r3, #14
34192414:	d9f2      	bls.n	341923fc <USB_DevInit+0x20>
  }

  /* Disable USB PHY pulldown resistors */
  USBx->GCCFG &= ~USB_OTG_GCCFG_PULLDOWNEN;
34192416:	687b      	ldr	r3, [r7, #4]
34192418:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3419241a:	f023 7200 	bic.w	r2, r3, #33554432	@ 0x2000000
3419241e:	687b      	ldr	r3, [r7, #4]
34192420:	639a      	str	r2, [r3, #56]	@ 0x38

  /* VBUS Sensing setup */
  if (cfg.vbus_sensing_enable == 0U)
34192422:	f897 302e 	ldrb.w	r3, [r7, #46]	@ 0x2e
34192426:	2b00      	cmp	r3, #0
34192428:	d116      	bne.n	34192458 <USB_DevInit+0x7c>
  {
    USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;
3419242a:	68fb      	ldr	r3, [r7, #12]
3419242c:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
34192430:	685b      	ldr	r3, [r3, #4]
34192432:	68fa      	ldr	r2, [r7, #12]
34192434:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
34192438:	f043 0302 	orr.w	r3, r3, #2
3419243c:	6053      	str	r3, [r2, #4]

    /* B-peripheral session valid override enable */
    USBx->GCCFG |= USB_OTG_GCCFG_VBVALEXTOEN;
3419243e:	687b      	ldr	r3, [r7, #4]
34192440:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34192442:	f043 7280 	orr.w	r2, r3, #16777216	@ 0x1000000
34192446:	687b      	ldr	r3, [r7, #4]
34192448:	639a      	str	r2, [r3, #56]	@ 0x38
    USBx->GCCFG |= USB_OTG_GCCFG_VBVALOVAL;
3419244a:	687b      	ldr	r3, [r7, #4]
3419244c:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3419244e:	f443 0200 	orr.w	r2, r3, #8388608	@ 0x800000
34192452:	687b      	ldr	r3, [r7, #4]
34192454:	639a      	str	r2, [r3, #56]	@ 0x38
34192456:	e00b      	b.n	34192470 <USB_DevInit+0x94>
  }
  else
  {
    /* B-peripheral session valid override disable */
    USBx->GCCFG &= ~USB_OTG_GCCFG_VBVALEXTOEN;
34192458:	687b      	ldr	r3, [r7, #4]
3419245a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3419245c:	f023 7280 	bic.w	r2, r3, #16777216	@ 0x1000000
34192460:	687b      	ldr	r3, [r7, #4]
34192462:	639a      	str	r2, [r3, #56]	@ 0x38
    USBx->GCCFG &= ~USB_OTG_GCCFG_VBVALOVAL;
34192464:	687b      	ldr	r3, [r7, #4]
34192466:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34192468:	f423 0200 	bic.w	r2, r3, #8388608	@ 0x800000
3419246c:	687b      	ldr	r3, [r7, #4]
3419246e:	639a      	str	r2, [r3, #56]	@ 0x38
  }

  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0U;
34192470:	68fb      	ldr	r3, [r7, #12]
34192472:	f503 6360 	add.w	r3, r3, #3584	@ 0xe00
34192476:	461a      	mov	r2, r3
34192478:	2300      	movs	r3, #0
3419247a:	6013      	str	r3, [r2, #0]


  if (cfg.phy_itface == USB_OTG_HS_EMBEDDED_PHY)
3419247c:	f897 3029 	ldrb.w	r3, [r7, #41]	@ 0x29
34192480:	2b03      	cmp	r3, #3
34192482:	d10d      	bne.n	341924a0 <USB_DevInit+0xc4>
  {
    if (cfg.speed == USBD_HS_SPEED)
34192484:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
34192488:	2b00      	cmp	r3, #0
3419248a:	d104      	bne.n	34192496 <USB_DevInit+0xba>
    {
      /* Set Core speed to High speed mode */
      (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_HIGH);
3419248c:	2100      	movs	r1, #0
3419248e:	6878      	ldr	r0, [r7, #4]
34192490:	f000 f968 	bl	34192764 <USB_SetDevSpeed>
34192494:	e008      	b.n	341924a8 <USB_DevInit+0xcc>
    }
    else
    {
      /* Set Core speed to Full speed mode */
      (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_HIGH_IN_FULL);
34192496:	2101      	movs	r1, #1
34192498:	6878      	ldr	r0, [r7, #4]
3419249a:	f000 f963 	bl	34192764 <USB_SetDevSpeed>
3419249e:	e003      	b.n	341924a8 <USB_DevInit+0xcc>
  }
  else

  {
    /* Set Core speed to Full speed mode */
    (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_FULL);
341924a0:	2103      	movs	r1, #3
341924a2:	6878      	ldr	r0, [r7, #4]
341924a4:	f000 f95e 	bl	34192764 <USB_SetDevSpeed>
  }

  /* Flush the FIFOs */
  if (USB_FlushTxFifo(USBx, 0x10U) != HAL_OK) /* all Tx FIFOs */
341924a8:	2110      	movs	r1, #16
341924aa:	6878      	ldr	r0, [r7, #4]
341924ac:	f000 f8fa 	bl	341926a4 <USB_FlushTxFifo>
341924b0:	4603      	mov	r3, r0
341924b2:	2b00      	cmp	r3, #0
341924b4:	d001      	beq.n	341924ba <USB_DevInit+0xde>
  {
    ret = HAL_ERROR;
341924b6:	2301      	movs	r3, #1
341924b8:	75fb      	strb	r3, [r7, #23]
  }

  if (USB_FlushRxFifo(USBx) != HAL_OK)
341924ba:	6878      	ldr	r0, [r7, #4]
341924bc:	f000 f924 	bl	34192708 <USB_FlushRxFifo>
341924c0:	4603      	mov	r3, r0
341924c2:	2b00      	cmp	r3, #0
341924c4:	d001      	beq.n	341924ca <USB_DevInit+0xee>
  {
    ret = HAL_ERROR;
341924c6:	2301      	movs	r3, #1
341924c8:	75fb      	strb	r3, [r7, #23]
  }

  /* Clear all pending Device Interrupts */
  USBx_DEVICE->DIEPMSK = 0U;
341924ca:	68fb      	ldr	r3, [r7, #12]
341924cc:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
341924d0:	461a      	mov	r2, r3
341924d2:	2300      	movs	r3, #0
341924d4:	6113      	str	r3, [r2, #16]
  USBx_DEVICE->DOEPMSK = 0U;
341924d6:	68fb      	ldr	r3, [r7, #12]
341924d8:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
341924dc:	461a      	mov	r2, r3
341924de:	2300      	movs	r3, #0
341924e0:	6153      	str	r3, [r2, #20]
  USBx_DEVICE->DAINTMSK = 0U;
341924e2:	68fb      	ldr	r3, [r7, #12]
341924e4:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
341924e8:	461a      	mov	r2, r3
341924ea:	2300      	movs	r3, #0
341924ec:	61d3      	str	r3, [r2, #28]

  for (i = 0U; i < cfg.dev_endpoints; i++)
341924ee:	2300      	movs	r3, #0
341924f0:	613b      	str	r3, [r7, #16]
341924f2:	e043      	b.n	3419257c <USB_DevInit+0x1a0>
  {
    if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
341924f4:	693b      	ldr	r3, [r7, #16]
341924f6:	015a      	lsls	r2, r3, #5
341924f8:	68fb      	ldr	r3, [r7, #12]
341924fa:	4413      	add	r3, r2
341924fc:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
34192500:	681b      	ldr	r3, [r3, #0]
34192502:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
34192506:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
3419250a:	d118      	bne.n	3419253e <USB_DevInit+0x162>
    {
      if (i == 0U)
3419250c:	693b      	ldr	r3, [r7, #16]
3419250e:	2b00      	cmp	r3, #0
34192510:	d10a      	bne.n	34192528 <USB_DevInit+0x14c>
      {
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_SNAK;
34192512:	693b      	ldr	r3, [r7, #16]
34192514:	015a      	lsls	r2, r3, #5
34192516:	68fb      	ldr	r3, [r7, #12]
34192518:	4413      	add	r3, r2
3419251a:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
3419251e:	461a      	mov	r2, r3
34192520:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
34192524:	6013      	str	r3, [r2, #0]
34192526:	e013      	b.n	34192550 <USB_DevInit+0x174>
      }
      else
      {
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK;
34192528:	693b      	ldr	r3, [r7, #16]
3419252a:	015a      	lsls	r2, r3, #5
3419252c:	68fb      	ldr	r3, [r7, #12]
3419252e:	4413      	add	r3, r2
34192530:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
34192534:	461a      	mov	r2, r3
34192536:	f04f 4390 	mov.w	r3, #1207959552	@ 0x48000000
3419253a:	6013      	str	r3, [r2, #0]
3419253c:	e008      	b.n	34192550 <USB_DevInit+0x174>
      }
    }
    else
    {
      USBx_INEP(i)->DIEPCTL = 0U;
3419253e:	693b      	ldr	r3, [r7, #16]
34192540:	015a      	lsls	r2, r3, #5
34192542:	68fb      	ldr	r3, [r7, #12]
34192544:	4413      	add	r3, r2
34192546:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
3419254a:	461a      	mov	r2, r3
3419254c:	2300      	movs	r3, #0
3419254e:	6013      	str	r3, [r2, #0]
    }

    USBx_INEP(i)->DIEPTSIZ = 0U;
34192550:	693b      	ldr	r3, [r7, #16]
34192552:	015a      	lsls	r2, r3, #5
34192554:	68fb      	ldr	r3, [r7, #12]
34192556:	4413      	add	r3, r2
34192558:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
3419255c:	461a      	mov	r2, r3
3419255e:	2300      	movs	r3, #0
34192560:	6113      	str	r3, [r2, #16]
    USBx_INEP(i)->DIEPINT  = 0xFB7FU;
34192562:	693b      	ldr	r3, [r7, #16]
34192564:	015a      	lsls	r2, r3, #5
34192566:	68fb      	ldr	r3, [r7, #12]
34192568:	4413      	add	r3, r2
3419256a:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
3419256e:	461a      	mov	r2, r3
34192570:	f64f 337f 	movw	r3, #64383	@ 0xfb7f
34192574:	6093      	str	r3, [r2, #8]
  for (i = 0U; i < cfg.dev_endpoints; i++)
34192576:	693b      	ldr	r3, [r7, #16]
34192578:	3301      	adds	r3, #1
3419257a:	613b      	str	r3, [r7, #16]
3419257c:	f897 3024 	ldrb.w	r3, [r7, #36]	@ 0x24
34192580:	461a      	mov	r2, r3
34192582:	693b      	ldr	r3, [r7, #16]
34192584:	4293      	cmp	r3, r2
34192586:	d3b5      	bcc.n	341924f4 <USB_DevInit+0x118>
  }

  for (i = 0U; i < cfg.dev_endpoints; i++)
34192588:	2300      	movs	r3, #0
3419258a:	613b      	str	r3, [r7, #16]
3419258c:	e043      	b.n	34192616 <USB_DevInit+0x23a>
  {
    if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
3419258e:	693b      	ldr	r3, [r7, #16]
34192590:	015a      	lsls	r2, r3, #5
34192592:	68fb      	ldr	r3, [r7, #12]
34192594:	4413      	add	r3, r2
34192596:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
3419259a:	681b      	ldr	r3, [r3, #0]
3419259c:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
341925a0:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
341925a4:	d118      	bne.n	341925d8 <USB_DevInit+0x1fc>
    {
      if (i == 0U)
341925a6:	693b      	ldr	r3, [r7, #16]
341925a8:	2b00      	cmp	r3, #0
341925aa:	d10a      	bne.n	341925c2 <USB_DevInit+0x1e6>
      {
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_SNAK;
341925ac:	693b      	ldr	r3, [r7, #16]
341925ae:	015a      	lsls	r2, r3, #5
341925b0:	68fb      	ldr	r3, [r7, #12]
341925b2:	4413      	add	r3, r2
341925b4:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
341925b8:	461a      	mov	r2, r3
341925ba:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
341925be:	6013      	str	r3, [r2, #0]
341925c0:	e013      	b.n	341925ea <USB_DevInit+0x20e>
      }
      else
      {
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK;
341925c2:	693b      	ldr	r3, [r7, #16]
341925c4:	015a      	lsls	r2, r3, #5
341925c6:	68fb      	ldr	r3, [r7, #12]
341925c8:	4413      	add	r3, r2
341925ca:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
341925ce:	461a      	mov	r2, r3
341925d0:	f04f 4390 	mov.w	r3, #1207959552	@ 0x48000000
341925d4:	6013      	str	r3, [r2, #0]
341925d6:	e008      	b.n	341925ea <USB_DevInit+0x20e>
      }
    }
    else
    {
      USBx_OUTEP(i)->DOEPCTL = 0U;
341925d8:	693b      	ldr	r3, [r7, #16]
341925da:	015a      	lsls	r2, r3, #5
341925dc:	68fb      	ldr	r3, [r7, #12]
341925de:	4413      	add	r3, r2
341925e0:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
341925e4:	461a      	mov	r2, r3
341925e6:	2300      	movs	r3, #0
341925e8:	6013      	str	r3, [r2, #0]
    }

    USBx_OUTEP(i)->DOEPTSIZ = 0U;
341925ea:	693b      	ldr	r3, [r7, #16]
341925ec:	015a      	lsls	r2, r3, #5
341925ee:	68fb      	ldr	r3, [r7, #12]
341925f0:	4413      	add	r3, r2
341925f2:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
341925f6:	461a      	mov	r2, r3
341925f8:	2300      	movs	r3, #0
341925fa:	6113      	str	r3, [r2, #16]
    USBx_OUTEP(i)->DOEPINT  = 0xFB7FU;
341925fc:	693b      	ldr	r3, [r7, #16]
341925fe:	015a      	lsls	r2, r3, #5
34192600:	68fb      	ldr	r3, [r7, #12]
34192602:	4413      	add	r3, r2
34192604:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
34192608:	461a      	mov	r2, r3
3419260a:	f64f 337f 	movw	r3, #64383	@ 0xfb7f
3419260e:	6093      	str	r3, [r2, #8]
  for (i = 0U; i < cfg.dev_endpoints; i++)
34192610:	693b      	ldr	r3, [r7, #16]
34192612:	3301      	adds	r3, #1
34192614:	613b      	str	r3, [r7, #16]
34192616:	f897 3024 	ldrb.w	r3, [r7, #36]	@ 0x24
3419261a:	461a      	mov	r2, r3
3419261c:	693b      	ldr	r3, [r7, #16]
3419261e:	4293      	cmp	r3, r2
34192620:	d3b5      	bcc.n	3419258e <USB_DevInit+0x1b2>
  }

  USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
34192622:	68fb      	ldr	r3, [r7, #12]
34192624:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
34192628:	691b      	ldr	r3, [r3, #16]
3419262a:	68fa      	ldr	r2, [r7, #12]
3419262c:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
34192630:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
34192634:	6113      	str	r3, [r2, #16]

  /* Disable all interrupts. */
  USBx->GINTMSK = 0U;
34192636:	687b      	ldr	r3, [r7, #4]
34192638:	2200      	movs	r2, #0
3419263a:	619a      	str	r2, [r3, #24]

  /* Clear any pending interrupts */
  USBx->GINTSTS = 0xBFFFFFFFU;
3419263c:	687b      	ldr	r3, [r7, #4]
3419263e:	f06f 4280 	mvn.w	r2, #1073741824	@ 0x40000000
34192642:	615a      	str	r2, [r3, #20]

  /* Enable the common interrupts */
  if (cfg.dma_enable == 0U)
34192644:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
34192648:	2b00      	cmp	r3, #0
3419264a:	d105      	bne.n	34192658 <USB_DevInit+0x27c>
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM;
3419264c:	687b      	ldr	r3, [r7, #4]
3419264e:	699b      	ldr	r3, [r3, #24]
34192650:	f043 0210 	orr.w	r2, r3, #16
34192654:	687b      	ldr	r3, [r7, #4]
34192656:	619a      	str	r2, [r3, #24]
  }

  /* Enable interrupts matching to the Device mode ONLY */
  USBx->GINTMSK |= USB_OTG_GINTMSK_USBSUSPM | USB_OTG_GINTMSK_USBRST |
34192658:	687b      	ldr	r3, [r7, #4]
3419265a:	699a      	ldr	r2, [r3, #24]
3419265c:	4b10      	ldr	r3, [pc, #64]	@ (341926a0 <USB_DevInit+0x2c4>)
3419265e:	4313      	orrs	r3, r2
34192660:	687a      	ldr	r2, [r7, #4]
34192662:	6193      	str	r3, [r2, #24]
                   USB_OTG_GINTMSK_ENUMDNEM | USB_OTG_GINTMSK_IEPINT |
                   USB_OTG_GINTMSK_OEPINT   | USB_OTG_GINTMSK_IISOIXFRM |
                   USB_OTG_GINTMSK_PXFRM_IISOOXFRM | USB_OTG_GINTMSK_WUIM;

  if (cfg.Sof_enable != 0U)
34192664:	f897 302a 	ldrb.w	r3, [r7, #42]	@ 0x2a
34192668:	2b00      	cmp	r3, #0
3419266a:	d005      	beq.n	34192678 <USB_DevInit+0x29c>
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_SOFM;
3419266c:	687b      	ldr	r3, [r7, #4]
3419266e:	699b      	ldr	r3, [r3, #24]
34192670:	f043 0208 	orr.w	r2, r3, #8
34192674:	687b      	ldr	r3, [r7, #4]
34192676:	619a      	str	r2, [r3, #24]
  }

  if (cfg.vbus_sensing_enable == 1U)
34192678:	f897 302e 	ldrb.w	r3, [r7, #46]	@ 0x2e
3419267c:	2b01      	cmp	r3, #1
3419267e:	d107      	bne.n	34192690 <USB_DevInit+0x2b4>
  {
    USBx->GINTMSK |= (USB_OTG_GINTMSK_SRQIM | USB_OTG_GINTMSK_OTGINT);
34192680:	687b      	ldr	r3, [r7, #4]
34192682:	699b      	ldr	r3, [r3, #24]
34192684:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
34192688:	f043 0304 	orr.w	r3, r3, #4
3419268c:	687a      	ldr	r2, [r7, #4]
3419268e:	6193      	str	r3, [r2, #24]
  }

  return ret;
34192690:	7dfb      	ldrb	r3, [r7, #23]
}
34192692:	4618      	mov	r0, r3
34192694:	3718      	adds	r7, #24
34192696:	46bd      	mov	sp, r7
34192698:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
3419269c:	b004      	add	sp, #16
3419269e:	4770      	bx	lr
341926a0:	803c3800 	.word	0x803c3800

341926a4 <USB_FlushTxFifo>:
  *         This parameter can be a value from 1 to 15
            15 means Flush all Tx FIFOs
  * @retval HAL status
  */
HAL_StatusTypeDef USB_FlushTxFifo(USB_OTG_GlobalTypeDef *USBx, uint32_t num)
{
341926a4:	b480      	push	{r7}
341926a6:	b085      	sub	sp, #20
341926a8:	af00      	add	r7, sp, #0
341926aa:	6078      	str	r0, [r7, #4]
341926ac:	6039      	str	r1, [r7, #0]
  __IO uint32_t count = 0U;
341926ae:	2300      	movs	r3, #0
341926b0:	60fb      	str	r3, [r7, #12]

  /* Wait for AHB master IDLE state. */
  do
  {
    count++;
341926b2:	68fb      	ldr	r3, [r7, #12]
341926b4:	3301      	adds	r3, #1
341926b6:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
341926b8:	68fb      	ldr	r3, [r7, #12]
341926ba:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
341926be:	d901      	bls.n	341926c4 <USB_FlushTxFifo+0x20>
    {
      return HAL_TIMEOUT;
341926c0:	2303      	movs	r3, #3
341926c2:	e01b      	b.n	341926fc <USB_FlushTxFifo+0x58>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
341926c4:	687b      	ldr	r3, [r7, #4]
341926c6:	691b      	ldr	r3, [r3, #16]
341926c8:	2b00      	cmp	r3, #0
341926ca:	daf2      	bge.n	341926b2 <USB_FlushTxFifo+0xe>

  /* Flush TX Fifo */
  count = 0U;
341926cc:	2300      	movs	r3, #0
341926ce:	60fb      	str	r3, [r7, #12]
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
341926d0:	683b      	ldr	r3, [r7, #0]
341926d2:	019b      	lsls	r3, r3, #6
341926d4:	f043 0220 	orr.w	r2, r3, #32
341926d8:	687b      	ldr	r3, [r7, #4]
341926da:	611a      	str	r2, [r3, #16]

  do
  {
    count++;
341926dc:	68fb      	ldr	r3, [r7, #12]
341926de:	3301      	adds	r3, #1
341926e0:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
341926e2:	68fb      	ldr	r3, [r7, #12]
341926e4:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
341926e8:	d901      	bls.n	341926ee <USB_FlushTxFifo+0x4a>
    {
      return HAL_TIMEOUT;
341926ea:	2303      	movs	r3, #3
341926ec:	e006      	b.n	341926fc <USB_FlushTxFifo+0x58>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
341926ee:	687b      	ldr	r3, [r7, #4]
341926f0:	691b      	ldr	r3, [r3, #16]
341926f2:	f003 0320 	and.w	r3, r3, #32
341926f6:	2b20      	cmp	r3, #32
341926f8:	d0f0      	beq.n	341926dc <USB_FlushTxFifo+0x38>

  return HAL_OK;
341926fa:	2300      	movs	r3, #0
}
341926fc:	4618      	mov	r0, r3
341926fe:	3714      	adds	r7, #20
34192700:	46bd      	mov	sp, r7
34192702:	f85d 7b04 	ldr.w	r7, [sp], #4
34192706:	4770      	bx	lr

34192708 <USB_FlushRxFifo>:
  * @brief  USB_FlushRxFifo  Flush Rx FIFO
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_FlushRxFifo(USB_OTG_GlobalTypeDef *USBx)
{
34192708:	b480      	push	{r7}
3419270a:	b085      	sub	sp, #20
3419270c:	af00      	add	r7, sp, #0
3419270e:	6078      	str	r0, [r7, #4]
  __IO uint32_t count = 0U;
34192710:	2300      	movs	r3, #0
34192712:	60fb      	str	r3, [r7, #12]

  /* Wait for AHB master IDLE state. */
  do
  {
    count++;
34192714:	68fb      	ldr	r3, [r7, #12]
34192716:	3301      	adds	r3, #1
34192718:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
3419271a:	68fb      	ldr	r3, [r7, #12]
3419271c:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
34192720:	d901      	bls.n	34192726 <USB_FlushRxFifo+0x1e>
    {
      return HAL_TIMEOUT;
34192722:	2303      	movs	r3, #3
34192724:	e018      	b.n	34192758 <USB_FlushRxFifo+0x50>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
34192726:	687b      	ldr	r3, [r7, #4]
34192728:	691b      	ldr	r3, [r3, #16]
3419272a:	2b00      	cmp	r3, #0
3419272c:	daf2      	bge.n	34192714 <USB_FlushRxFifo+0xc>

  /* Flush RX Fifo */
  count = 0U;
3419272e:	2300      	movs	r3, #0
34192730:	60fb      	str	r3, [r7, #12]
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
34192732:	687b      	ldr	r3, [r7, #4]
34192734:	2210      	movs	r2, #16
34192736:	611a      	str	r2, [r3, #16]

  do
  {
    count++;
34192738:	68fb      	ldr	r3, [r7, #12]
3419273a:	3301      	adds	r3, #1
3419273c:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
3419273e:	68fb      	ldr	r3, [r7, #12]
34192740:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
34192744:	d901      	bls.n	3419274a <USB_FlushRxFifo+0x42>
    {
      return HAL_TIMEOUT;
34192746:	2303      	movs	r3, #3
34192748:	e006      	b.n	34192758 <USB_FlushRxFifo+0x50>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
3419274a:	687b      	ldr	r3, [r7, #4]
3419274c:	691b      	ldr	r3, [r3, #16]
3419274e:	f003 0310 	and.w	r3, r3, #16
34192752:	2b10      	cmp	r3, #16
34192754:	d0f0      	beq.n	34192738 <USB_FlushRxFifo+0x30>

  return HAL_OK;
34192756:	2300      	movs	r3, #0
}
34192758:	4618      	mov	r0, r3
3419275a:	3714      	adds	r7, #20
3419275c:	46bd      	mov	sp, r7
3419275e:	f85d 7b04 	ldr.w	r7, [sp], #4
34192762:	4770      	bx	lr

34192764 <USB_SetDevSpeed>:
  *            @arg USB_OTG_SPEED_HIGH_IN_FULL: High speed core in Full Speed mode
  *            @arg USB_OTG_SPEED_FULL: Full speed mode
  * @retval  Hal status
  */
HAL_StatusTypeDef USB_SetDevSpeed(const USB_OTG_GlobalTypeDef *USBx, uint8_t speed)
{
34192764:	b480      	push	{r7}
34192766:	b085      	sub	sp, #20
34192768:	af00      	add	r7, sp, #0
3419276a:	6078      	str	r0, [r7, #4]
3419276c:	460b      	mov	r3, r1
3419276e:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
34192770:	687b      	ldr	r3, [r7, #4]
34192772:	60fb      	str	r3, [r7, #12]

  USBx_DEVICE->DCFG |= speed;
34192774:	68fb      	ldr	r3, [r7, #12]
34192776:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
3419277a:	681a      	ldr	r2, [r3, #0]
3419277c:	78fb      	ldrb	r3, [r7, #3]
3419277e:	68f9      	ldr	r1, [r7, #12]
34192780:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
34192784:	4313      	orrs	r3, r2
34192786:	600b      	str	r3, [r1, #0]
  return HAL_OK;
34192788:	2300      	movs	r3, #0
}
3419278a:	4618      	mov	r0, r3
3419278c:	3714      	adds	r7, #20
3419278e:	46bd      	mov	sp, r7
34192790:	f85d 7b04 	ldr.w	r7, [sp], #4
34192794:	4770      	bx	lr

34192796 <USB_GetDevSpeed>:
  *          This parameter can be one of these values:
  *            @arg USBD_HS_SPEED: High speed mode
  *            @arg USBD_FS_SPEED: Full speed mode
  */
uint8_t USB_GetDevSpeed(const USB_OTG_GlobalTypeDef *USBx)
{
34192796:	b480      	push	{r7}
34192798:	b087      	sub	sp, #28
3419279a:	af00      	add	r7, sp, #0
3419279c:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
3419279e:	687b      	ldr	r3, [r7, #4]
341927a0:	613b      	str	r3, [r7, #16]
  uint8_t speed;
  uint32_t DevEnumSpeed = USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD;
341927a2:	693b      	ldr	r3, [r7, #16]
341927a4:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
341927a8:	689b      	ldr	r3, [r3, #8]
341927aa:	f003 0306 	and.w	r3, r3, #6
341927ae:	60fb      	str	r3, [r7, #12]

  if (DevEnumSpeed == DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ)
341927b0:	68fb      	ldr	r3, [r7, #12]
341927b2:	2b00      	cmp	r3, #0
341927b4:	d102      	bne.n	341927bc <USB_GetDevSpeed+0x26>
  {
    speed = USBD_HS_SPEED;
341927b6:	2300      	movs	r3, #0
341927b8:	75fb      	strb	r3, [r7, #23]
341927ba:	e00a      	b.n	341927d2 <USB_GetDevSpeed+0x3c>
  }
  else if ((DevEnumSpeed == DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ) ||
341927bc:	68fb      	ldr	r3, [r7, #12]
341927be:	2b02      	cmp	r3, #2
341927c0:	d002      	beq.n	341927c8 <USB_GetDevSpeed+0x32>
341927c2:	68fb      	ldr	r3, [r7, #12]
341927c4:	2b06      	cmp	r3, #6
341927c6:	d102      	bne.n	341927ce <USB_GetDevSpeed+0x38>
           (DevEnumSpeed == DSTS_ENUMSPD_FS_PHY_48MHZ))
  {
    speed = USBD_FS_SPEED;
341927c8:	2302      	movs	r3, #2
341927ca:	75fb      	strb	r3, [r7, #23]
341927cc:	e001      	b.n	341927d2 <USB_GetDevSpeed+0x3c>
  }
  else
  {
    speed = 0xFU;
341927ce:	230f      	movs	r3, #15
341927d0:	75fb      	strb	r3, [r7, #23]
  }

  return speed;
341927d2:	7dfb      	ldrb	r3, [r7, #23]
}
341927d4:	4618      	mov	r0, r3
341927d6:	371c      	adds	r7, #28
341927d8:	46bd      	mov	sp, r7
341927da:	f85d 7b04 	ldr.w	r7, [sp], #4
341927de:	4770      	bx	lr

341927e0 <USB_ActivateEndpoint>:
  * @param  USBx  Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_ActivateEndpoint(const USB_OTG_GlobalTypeDef *USBx, const USB_OTG_EPTypeDef *ep)
{
341927e0:	b480      	push	{r7}
341927e2:	b085      	sub	sp, #20
341927e4:	af00      	add	r7, sp, #0
341927e6:	6078      	str	r0, [r7, #4]
341927e8:	6039      	str	r1, [r7, #0]
  uint32_t USBx_BASE = (uint32_t)USBx;
341927ea:	687b      	ldr	r3, [r7, #4]
341927ec:	60fb      	str	r3, [r7, #12]
  uint32_t epnum = (uint32_t)ep->num;
341927ee:	683b      	ldr	r3, [r7, #0]
341927f0:	781b      	ldrb	r3, [r3, #0]
341927f2:	60bb      	str	r3, [r7, #8]

  if (ep->is_in == 1U)
341927f4:	683b      	ldr	r3, [r7, #0]
341927f6:	785b      	ldrb	r3, [r3, #1]
341927f8:	2b01      	cmp	r3, #1
341927fa:	d13a      	bne.n	34192872 <USB_ActivateEndpoint+0x92>
  {
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK));
341927fc:	68fb      	ldr	r3, [r7, #12]
341927fe:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
34192802:	69da      	ldr	r2, [r3, #28]
34192804:	683b      	ldr	r3, [r7, #0]
34192806:	781b      	ldrb	r3, [r3, #0]
34192808:	f003 030f 	and.w	r3, r3, #15
3419280c:	2101      	movs	r1, #1
3419280e:	fa01 f303 	lsl.w	r3, r1, r3
34192812:	b29b      	uxth	r3, r3
34192814:	68f9      	ldr	r1, [r7, #12]
34192816:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
3419281a:	4313      	orrs	r3, r2
3419281c:	61cb      	str	r3, [r1, #28]

    if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_USBAEP) == 0U)
3419281e:	68bb      	ldr	r3, [r7, #8]
34192820:	015a      	lsls	r2, r3, #5
34192822:	68fb      	ldr	r3, [r7, #12]
34192824:	4413      	add	r3, r2
34192826:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
3419282a:	681b      	ldr	r3, [r3, #0]
3419282c:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
34192830:	2b00      	cmp	r3, #0
34192832:	d155      	bne.n	341928e0 <USB_ActivateEndpoint+0x100>
    {
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
34192834:	68bb      	ldr	r3, [r7, #8]
34192836:	015a      	lsls	r2, r3, #5
34192838:	68fb      	ldr	r3, [r7, #12]
3419283a:	4413      	add	r3, r2
3419283c:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
34192840:	681a      	ldr	r2, [r3, #0]
34192842:	683b      	ldr	r3, [r7, #0]
34192844:	689b      	ldr	r3, [r3, #8]
34192846:	f3c3 010a 	ubfx	r1, r3, #0, #11
                                   ((uint32_t)ep->type << 18) | (epnum << 22) |
3419284a:	683b      	ldr	r3, [r7, #0]
3419284c:	791b      	ldrb	r3, [r3, #4]
3419284e:	049b      	lsls	r3, r3, #18
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
34192850:	4319      	orrs	r1, r3
                                   ((uint32_t)ep->type << 18) | (epnum << 22) |
34192852:	68bb      	ldr	r3, [r7, #8]
34192854:	059b      	lsls	r3, r3, #22
34192856:	430b      	orrs	r3, r1
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
34192858:	4313      	orrs	r3, r2
3419285a:	68ba      	ldr	r2, [r7, #8]
3419285c:	0151      	lsls	r1, r2, #5
3419285e:	68fa      	ldr	r2, [r7, #12]
34192860:	440a      	add	r2, r1
34192862:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
34192866:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
3419286a:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
3419286e:	6013      	str	r3, [r2, #0]
34192870:	e036      	b.n	341928e0 <USB_ActivateEndpoint+0x100>
                                   USB_OTG_DIEPCTL_USBAEP;
    }
  }
  else
  {
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16);
34192872:	68fb      	ldr	r3, [r7, #12]
34192874:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
34192878:	69da      	ldr	r2, [r3, #28]
3419287a:	683b      	ldr	r3, [r7, #0]
3419287c:	781b      	ldrb	r3, [r3, #0]
3419287e:	f003 030f 	and.w	r3, r3, #15
34192882:	2101      	movs	r1, #1
34192884:	fa01 f303 	lsl.w	r3, r1, r3
34192888:	041b      	lsls	r3, r3, #16
3419288a:	68f9      	ldr	r1, [r7, #12]
3419288c:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
34192890:	4313      	orrs	r3, r2
34192892:	61cb      	str	r3, [r1, #28]

    if (((USBx_OUTEP(epnum)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0U)
34192894:	68bb      	ldr	r3, [r7, #8]
34192896:	015a      	lsls	r2, r3, #5
34192898:	68fb      	ldr	r3, [r7, #12]
3419289a:	4413      	add	r3, r2
3419289c:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
341928a0:	681b      	ldr	r3, [r3, #0]
341928a2:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
341928a6:	2b00      	cmp	r3, #0
341928a8:	d11a      	bne.n	341928e0 <USB_ActivateEndpoint+0x100>
    {
      USBx_OUTEP(epnum)->DOEPCTL |= (ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ) |
341928aa:	68bb      	ldr	r3, [r7, #8]
341928ac:	015a      	lsls	r2, r3, #5
341928ae:	68fb      	ldr	r3, [r7, #12]
341928b0:	4413      	add	r3, r2
341928b2:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
341928b6:	681a      	ldr	r2, [r3, #0]
341928b8:	683b      	ldr	r3, [r7, #0]
341928ba:	689b      	ldr	r3, [r3, #8]
341928bc:	f3c3 010a 	ubfx	r1, r3, #0, #11
                                    ((uint32_t)ep->type << 18) |
341928c0:	683b      	ldr	r3, [r7, #0]
341928c2:	791b      	ldrb	r3, [r3, #4]
341928c4:	049b      	lsls	r3, r3, #18
      USBx_OUTEP(epnum)->DOEPCTL |= (ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ) |
341928c6:	430b      	orrs	r3, r1
341928c8:	4313      	orrs	r3, r2
341928ca:	68ba      	ldr	r2, [r7, #8]
341928cc:	0151      	lsls	r1, r2, #5
341928ce:	68fa      	ldr	r2, [r7, #12]
341928d0:	440a      	add	r2, r1
341928d2:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
341928d6:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
341928da:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
341928de:	6013      	str	r3, [r2, #0]
                                    USB_OTG_DIEPCTL_SD0PID_SEVNFRM |
                                    USB_OTG_DOEPCTL_USBAEP;
    }
  }
  return HAL_OK;
341928e0:	2300      	movs	r3, #0
}
341928e2:	4618      	mov	r0, r3
341928e4:	3714      	adds	r7, #20
341928e6:	46bd      	mov	sp, r7
341928e8:	f85d 7b04 	ldr.w	r7, [sp], #4
341928ec:	4770      	bx	lr
	...

341928f0 <USB_DeactivateEndpoint>:
  * @param  USBx  Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DeactivateEndpoint(const USB_OTG_GlobalTypeDef *USBx, const USB_OTG_EPTypeDef *ep)
{
341928f0:	b480      	push	{r7}
341928f2:	b085      	sub	sp, #20
341928f4:	af00      	add	r7, sp, #0
341928f6:	6078      	str	r0, [r7, #4]
341928f8:	6039      	str	r1, [r7, #0]
  uint32_t USBx_BASE = (uint32_t)USBx;
341928fa:	687b      	ldr	r3, [r7, #4]
341928fc:	60fb      	str	r3, [r7, #12]
  uint32_t epnum = (uint32_t)ep->num;
341928fe:	683b      	ldr	r3, [r7, #0]
34192900:	781b      	ldrb	r3, [r3, #0]
34192902:	60bb      	str	r3, [r7, #8]

  /* Read DEPCTLn register */
  if (ep->is_in == 1U)
34192904:	683b      	ldr	r3, [r7, #0]
34192906:	785b      	ldrb	r3, [r3, #1]
34192908:	2b01      	cmp	r3, #1
3419290a:	d161      	bne.n	341929d0 <USB_DeactivateEndpoint+0xe0>
  {
    if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
3419290c:	68bb      	ldr	r3, [r7, #8]
3419290e:	015a      	lsls	r2, r3, #5
34192910:	68fb      	ldr	r3, [r7, #12]
34192912:	4413      	add	r3, r2
34192914:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
34192918:	681b      	ldr	r3, [r3, #0]
3419291a:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
3419291e:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
34192922:	d11f      	bne.n	34192964 <USB_DeactivateEndpoint+0x74>
    {
      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SNAK;
34192924:	68bb      	ldr	r3, [r7, #8]
34192926:	015a      	lsls	r2, r3, #5
34192928:	68fb      	ldr	r3, [r7, #12]
3419292a:	4413      	add	r3, r2
3419292c:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
34192930:	681b      	ldr	r3, [r3, #0]
34192932:	68ba      	ldr	r2, [r7, #8]
34192934:	0151      	lsls	r1, r2, #5
34192936:	68fa      	ldr	r2, [r7, #12]
34192938:	440a      	add	r2, r1
3419293a:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
3419293e:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
34192942:	6013      	str	r3, [r2, #0]
      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_EPDIS;
34192944:	68bb      	ldr	r3, [r7, #8]
34192946:	015a      	lsls	r2, r3, #5
34192948:	68fb      	ldr	r3, [r7, #12]
3419294a:	4413      	add	r3, r2
3419294c:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
34192950:	681b      	ldr	r3, [r3, #0]
34192952:	68ba      	ldr	r2, [r7, #8]
34192954:	0151      	lsls	r1, r2, #5
34192956:	68fa      	ldr	r2, [r7, #12]
34192958:	440a      	add	r2, r1
3419295a:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
3419295e:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
34192962:	6013      	str	r3, [r2, #0]
    }

    USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK)));
34192964:	68fb      	ldr	r3, [r7, #12]
34192966:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
3419296a:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
3419296c:	683b      	ldr	r3, [r7, #0]
3419296e:	781b      	ldrb	r3, [r3, #0]
34192970:	f003 030f 	and.w	r3, r3, #15
34192974:	2101      	movs	r1, #1
34192976:	fa01 f303 	lsl.w	r3, r1, r3
3419297a:	b29b      	uxth	r3, r3
3419297c:	43db      	mvns	r3, r3
3419297e:	68f9      	ldr	r1, [r7, #12]
34192980:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
34192984:	4013      	ands	r3, r2
34192986:	63cb      	str	r3, [r1, #60]	@ 0x3c
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK)));
34192988:	68fb      	ldr	r3, [r7, #12]
3419298a:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
3419298e:	69da      	ldr	r2, [r3, #28]
34192990:	683b      	ldr	r3, [r7, #0]
34192992:	781b      	ldrb	r3, [r3, #0]
34192994:	f003 030f 	and.w	r3, r3, #15
34192998:	2101      	movs	r1, #1
3419299a:	fa01 f303 	lsl.w	r3, r1, r3
3419299e:	b29b      	uxth	r3, r3
341929a0:	43db      	mvns	r3, r3
341929a2:	68f9      	ldr	r1, [r7, #12]
341929a4:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
341929a8:	4013      	ands	r3, r2
341929aa:	61cb      	str	r3, [r1, #28]
    USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_USBAEP |
341929ac:	68bb      	ldr	r3, [r7, #8]
341929ae:	015a      	lsls	r2, r3, #5
341929b0:	68fb      	ldr	r3, [r7, #12]
341929b2:	4413      	add	r3, r2
341929b4:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
341929b8:	681a      	ldr	r2, [r3, #0]
341929ba:	68bb      	ldr	r3, [r7, #8]
341929bc:	0159      	lsls	r1, r3, #5
341929be:	68fb      	ldr	r3, [r7, #12]
341929c0:	440b      	add	r3, r1
341929c2:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
341929c6:	4619      	mov	r1, r3
341929c8:	4b35      	ldr	r3, [pc, #212]	@ (34192aa0 <USB_DeactivateEndpoint+0x1b0>)
341929ca:	4013      	ands	r3, r2
341929cc:	600b      	str	r3, [r1, #0]
341929ce:	e060      	b.n	34192a92 <USB_DeactivateEndpoint+0x1a2>
                                   USB_OTG_DIEPCTL_SD0PID_SEVNFRM |
                                   USB_OTG_DIEPCTL_EPTYP);
  }
  else
  {
    if ((USBx_OUTEP(epnum)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
341929d0:	68bb      	ldr	r3, [r7, #8]
341929d2:	015a      	lsls	r2, r3, #5
341929d4:	68fb      	ldr	r3, [r7, #12]
341929d6:	4413      	add	r3, r2
341929d8:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
341929dc:	681b      	ldr	r3, [r3, #0]
341929de:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
341929e2:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
341929e6:	d11f      	bne.n	34192a28 <USB_DeactivateEndpoint+0x138>
    {
      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SNAK;
341929e8:	68bb      	ldr	r3, [r7, #8]
341929ea:	015a      	lsls	r2, r3, #5
341929ec:	68fb      	ldr	r3, [r7, #12]
341929ee:	4413      	add	r3, r2
341929f0:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
341929f4:	681b      	ldr	r3, [r3, #0]
341929f6:	68ba      	ldr	r2, [r7, #8]
341929f8:	0151      	lsls	r1, r2, #5
341929fa:	68fa      	ldr	r2, [r7, #12]
341929fc:	440a      	add	r2, r1
341929fe:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
34192a02:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
34192a06:	6013      	str	r3, [r2, #0]
      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_EPDIS;
34192a08:	68bb      	ldr	r3, [r7, #8]
34192a0a:	015a      	lsls	r2, r3, #5
34192a0c:	68fb      	ldr	r3, [r7, #12]
34192a0e:	4413      	add	r3, r2
34192a10:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
34192a14:	681b      	ldr	r3, [r3, #0]
34192a16:	68ba      	ldr	r2, [r7, #8]
34192a18:	0151      	lsls	r1, r2, #5
34192a1a:	68fa      	ldr	r2, [r7, #12]
34192a1c:	440a      	add	r2, r1
34192a1e:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
34192a22:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
34192a26:	6013      	str	r3, [r2, #0]
    }

    USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16));
34192a28:	68fb      	ldr	r3, [r7, #12]
34192a2a:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
34192a2e:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
34192a30:	683b      	ldr	r3, [r7, #0]
34192a32:	781b      	ldrb	r3, [r3, #0]
34192a34:	f003 030f 	and.w	r3, r3, #15
34192a38:	2101      	movs	r1, #1
34192a3a:	fa01 f303 	lsl.w	r3, r1, r3
34192a3e:	041b      	lsls	r3, r3, #16
34192a40:	43db      	mvns	r3, r3
34192a42:	68f9      	ldr	r1, [r7, #12]
34192a44:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
34192a48:	4013      	ands	r3, r2
34192a4a:	63cb      	str	r3, [r1, #60]	@ 0x3c
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16));
34192a4c:	68fb      	ldr	r3, [r7, #12]
34192a4e:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
34192a52:	69da      	ldr	r2, [r3, #28]
34192a54:	683b      	ldr	r3, [r7, #0]
34192a56:	781b      	ldrb	r3, [r3, #0]
34192a58:	f003 030f 	and.w	r3, r3, #15
34192a5c:	2101      	movs	r1, #1
34192a5e:	fa01 f303 	lsl.w	r3, r1, r3
34192a62:	041b      	lsls	r3, r3, #16
34192a64:	43db      	mvns	r3, r3
34192a66:	68f9      	ldr	r1, [r7, #12]
34192a68:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
34192a6c:	4013      	ands	r3, r2
34192a6e:	61cb      	str	r3, [r1, #28]
    USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_USBAEP |
34192a70:	68bb      	ldr	r3, [r7, #8]
34192a72:	015a      	lsls	r2, r3, #5
34192a74:	68fb      	ldr	r3, [r7, #12]
34192a76:	4413      	add	r3, r2
34192a78:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
34192a7c:	681a      	ldr	r2, [r3, #0]
34192a7e:	68bb      	ldr	r3, [r7, #8]
34192a80:	0159      	lsls	r1, r3, #5
34192a82:	68fb      	ldr	r3, [r7, #12]
34192a84:	440b      	add	r3, r1
34192a86:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
34192a8a:	4619      	mov	r1, r3
34192a8c:	4b05      	ldr	r3, [pc, #20]	@ (34192aa4 <USB_DeactivateEndpoint+0x1b4>)
34192a8e:	4013      	ands	r3, r2
34192a90:	600b      	str	r3, [r1, #0]
                                    USB_OTG_DOEPCTL_MPSIZ |
                                    USB_OTG_DOEPCTL_SD0PID_SEVNFRM |
                                    USB_OTG_DOEPCTL_EPTYP);
  }

  return HAL_OK;
34192a92:	2300      	movs	r3, #0
}
34192a94:	4618      	mov	r0, r3
34192a96:	3714      	adds	r7, #20
34192a98:	46bd      	mov	sp, r7
34192a9a:	f85d 7b04 	ldr.w	r7, [sp], #4
34192a9e:	4770      	bx	lr
34192aa0:	ec337800 	.word	0xec337800
34192aa4:	eff37800 	.word	0xeff37800

34192aa8 <USB_EPStartXfer>:
  *           0 : DMA feature not used
  *           1 : DMA feature used
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPStartXfer(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep, uint8_t dma)
{
34192aa8:	b580      	push	{r7, lr}
34192aaa:	b08a      	sub	sp, #40	@ 0x28
34192aac:	af02      	add	r7, sp, #8
34192aae:	60f8      	str	r0, [r7, #12]
34192ab0:	60b9      	str	r1, [r7, #8]
34192ab2:	4613      	mov	r3, r2
34192ab4:	71fb      	strb	r3, [r7, #7]
  uint32_t USBx_BASE = (uint32_t)USBx;
34192ab6:	68fb      	ldr	r3, [r7, #12]
34192ab8:	61fb      	str	r3, [r7, #28]
  uint32_t epnum = (uint32_t)ep->num;
34192aba:	68bb      	ldr	r3, [r7, #8]
34192abc:	781b      	ldrb	r3, [r3, #0]
34192abe:	61bb      	str	r3, [r7, #24]
  uint16_t pktcnt;

  /* IN endpoint */
  if (ep->is_in == 1U)
34192ac0:	68bb      	ldr	r3, [r7, #8]
34192ac2:	785b      	ldrb	r3, [r3, #1]
34192ac4:	2b01      	cmp	r3, #1
34192ac6:	f040 817f 	bne.w	34192dc8 <USB_EPStartXfer+0x320>
  {
    /* Zero Length Packet? */
    if (ep->xfer_len == 0U)
34192aca:	68bb      	ldr	r3, [r7, #8]
34192acc:	691b      	ldr	r3, [r3, #16]
34192ace:	2b00      	cmp	r3, #0
34192ad0:	d132      	bne.n	34192b38 <USB_EPStartXfer+0x90>
    {
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
34192ad2:	69bb      	ldr	r3, [r7, #24]
34192ad4:	015a      	lsls	r2, r3, #5
34192ad6:	69fb      	ldr	r3, [r7, #28]
34192ad8:	4413      	add	r3, r2
34192ada:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
34192ade:	691b      	ldr	r3, [r3, #16]
34192ae0:	69ba      	ldr	r2, [r7, #24]
34192ae2:	0151      	lsls	r1, r2, #5
34192ae4:	69fa      	ldr	r2, [r7, #28]
34192ae6:	440a      	add	r2, r1
34192ae8:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
34192aec:	f023 53ff 	bic.w	r3, r3, #534773760	@ 0x1fe00000
34192af0:	f423 13c0 	bic.w	r3, r3, #1572864	@ 0x180000
34192af4:	6113      	str	r3, [r2, #16]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
34192af6:	69bb      	ldr	r3, [r7, #24]
34192af8:	015a      	lsls	r2, r3, #5
34192afa:	69fb      	ldr	r3, [r7, #28]
34192afc:	4413      	add	r3, r2
34192afe:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
34192b02:	691b      	ldr	r3, [r3, #16]
34192b04:	69ba      	ldr	r2, [r7, #24]
34192b06:	0151      	lsls	r1, r2, #5
34192b08:	69fa      	ldr	r2, [r7, #28]
34192b0a:	440a      	add	r2, r1
34192b0c:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
34192b10:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
34192b14:	6113      	str	r3, [r2, #16]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
34192b16:	69bb      	ldr	r3, [r7, #24]
34192b18:	015a      	lsls	r2, r3, #5
34192b1a:	69fb      	ldr	r3, [r7, #28]
34192b1c:	4413      	add	r3, r2
34192b1e:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
34192b22:	691b      	ldr	r3, [r3, #16]
34192b24:	69ba      	ldr	r2, [r7, #24]
34192b26:	0151      	lsls	r1, r2, #5
34192b28:	69fa      	ldr	r2, [r7, #28]
34192b2a:	440a      	add	r2, r1
34192b2c:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
34192b30:	0cdb      	lsrs	r3, r3, #19
34192b32:	04db      	lsls	r3, r3, #19
34192b34:	6113      	str	r3, [r2, #16]
34192b36:	e097      	b.n	34192c68 <USB_EPStartXfer+0x1c0>
      /* Program the transfer size and packet count
      * as follows: xfersize = N * maxpacket +
      * short_packet pktcnt = N + (short_packet
      * exist ? 1 : 0)
      */
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
34192b38:	69bb      	ldr	r3, [r7, #24]
34192b3a:	015a      	lsls	r2, r3, #5
34192b3c:	69fb      	ldr	r3, [r7, #28]
34192b3e:	4413      	add	r3, r2
34192b40:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
34192b44:	691b      	ldr	r3, [r3, #16]
34192b46:	69ba      	ldr	r2, [r7, #24]
34192b48:	0151      	lsls	r1, r2, #5
34192b4a:	69fa      	ldr	r2, [r7, #28]
34192b4c:	440a      	add	r2, r1
34192b4e:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
34192b52:	0cdb      	lsrs	r3, r3, #19
34192b54:	04db      	lsls	r3, r3, #19
34192b56:	6113      	str	r3, [r2, #16]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
34192b58:	69bb      	ldr	r3, [r7, #24]
34192b5a:	015a      	lsls	r2, r3, #5
34192b5c:	69fb      	ldr	r3, [r7, #28]
34192b5e:	4413      	add	r3, r2
34192b60:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
34192b64:	691b      	ldr	r3, [r3, #16]
34192b66:	69ba      	ldr	r2, [r7, #24]
34192b68:	0151      	lsls	r1, r2, #5
34192b6a:	69fa      	ldr	r2, [r7, #28]
34192b6c:	440a      	add	r2, r1
34192b6e:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
34192b72:	f023 53ff 	bic.w	r3, r3, #534773760	@ 0x1fe00000
34192b76:	f423 13c0 	bic.w	r3, r3, #1572864	@ 0x180000
34192b7a:	6113      	str	r3, [r2, #16]

      if (epnum == 0U)
34192b7c:	69bb      	ldr	r3, [r7, #24]
34192b7e:	2b00      	cmp	r3, #0
34192b80:	d11a      	bne.n	34192bb8 <USB_EPStartXfer+0x110>
      {
        if (ep->xfer_len > ep->maxpacket)
34192b82:	68bb      	ldr	r3, [r7, #8]
34192b84:	691a      	ldr	r2, [r3, #16]
34192b86:	68bb      	ldr	r3, [r7, #8]
34192b88:	689b      	ldr	r3, [r3, #8]
34192b8a:	429a      	cmp	r2, r3
34192b8c:	d903      	bls.n	34192b96 <USB_EPStartXfer+0xee>
        {
          ep->xfer_len = ep->maxpacket;
34192b8e:	68bb      	ldr	r3, [r7, #8]
34192b90:	689a      	ldr	r2, [r3, #8]
34192b92:	68bb      	ldr	r3, [r7, #8]
34192b94:	611a      	str	r2, [r3, #16]
        }

        USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
34192b96:	69bb      	ldr	r3, [r7, #24]
34192b98:	015a      	lsls	r2, r3, #5
34192b9a:	69fb      	ldr	r3, [r7, #28]
34192b9c:	4413      	add	r3, r2
34192b9e:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
34192ba2:	691b      	ldr	r3, [r3, #16]
34192ba4:	69ba      	ldr	r2, [r7, #24]
34192ba6:	0151      	lsls	r1, r2, #5
34192ba8:	69fa      	ldr	r2, [r7, #28]
34192baa:	440a      	add	r2, r1
34192bac:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
34192bb0:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
34192bb4:	6113      	str	r3, [r2, #16]
34192bb6:	e044      	b.n	34192c42 <USB_EPStartXfer+0x19a>
      }
      else
      {
        pktcnt = (uint16_t)((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket);
34192bb8:	68bb      	ldr	r3, [r7, #8]
34192bba:	691a      	ldr	r2, [r3, #16]
34192bbc:	68bb      	ldr	r3, [r7, #8]
34192bbe:	689b      	ldr	r3, [r3, #8]
34192bc0:	4413      	add	r3, r2
34192bc2:	1e5a      	subs	r2, r3, #1
34192bc4:	68bb      	ldr	r3, [r7, #8]
34192bc6:	689b      	ldr	r3, [r3, #8]
34192bc8:	fbb2 f3f3 	udiv	r3, r2, r3
34192bcc:	82fb      	strh	r3, [r7, #22]
        USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & ((uint32_t)pktcnt << 19));
34192bce:	69bb      	ldr	r3, [r7, #24]
34192bd0:	015a      	lsls	r2, r3, #5
34192bd2:	69fb      	ldr	r3, [r7, #28]
34192bd4:	4413      	add	r3, r2
34192bd6:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
34192bda:	691a      	ldr	r2, [r3, #16]
34192bdc:	8afb      	ldrh	r3, [r7, #22]
34192bde:	04d9      	lsls	r1, r3, #19
34192be0:	4ba4      	ldr	r3, [pc, #656]	@ (34192e74 <USB_EPStartXfer+0x3cc>)
34192be2:	400b      	ands	r3, r1
34192be4:	69b9      	ldr	r1, [r7, #24]
34192be6:	0148      	lsls	r0, r1, #5
34192be8:	69f9      	ldr	r1, [r7, #28]
34192bea:	4401      	add	r1, r0
34192bec:	f501 6110 	add.w	r1, r1, #2304	@ 0x900
34192bf0:	4313      	orrs	r3, r2
34192bf2:	610b      	str	r3, [r1, #16]

        if (ep->type == EP_TYPE_ISOC)
34192bf4:	68bb      	ldr	r3, [r7, #8]
34192bf6:	791b      	ldrb	r3, [r3, #4]
34192bf8:	2b01      	cmp	r3, #1
34192bfa:	d122      	bne.n	34192c42 <USB_EPStartXfer+0x19a>
        {
          USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_MULCNT);
34192bfc:	69bb      	ldr	r3, [r7, #24]
34192bfe:	015a      	lsls	r2, r3, #5
34192c00:	69fb      	ldr	r3, [r7, #28]
34192c02:	4413      	add	r3, r2
34192c04:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
34192c08:	691b      	ldr	r3, [r3, #16]
34192c0a:	69ba      	ldr	r2, [r7, #24]
34192c0c:	0151      	lsls	r1, r2, #5
34192c0e:	69fa      	ldr	r2, [r7, #28]
34192c10:	440a      	add	r2, r1
34192c12:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
34192c16:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
34192c1a:	6113      	str	r3, [r2, #16]
          USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_MULCNT & ((uint32_t)pktcnt << 29));
34192c1c:	69bb      	ldr	r3, [r7, #24]
34192c1e:	015a      	lsls	r2, r3, #5
34192c20:	69fb      	ldr	r3, [r7, #28]
34192c22:	4413      	add	r3, r2
34192c24:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
34192c28:	691a      	ldr	r2, [r3, #16]
34192c2a:	8afb      	ldrh	r3, [r7, #22]
34192c2c:	075b      	lsls	r3, r3, #29
34192c2e:	f003 43c0 	and.w	r3, r3, #1610612736	@ 0x60000000
34192c32:	69b9      	ldr	r1, [r7, #24]
34192c34:	0148      	lsls	r0, r1, #5
34192c36:	69f9      	ldr	r1, [r7, #28]
34192c38:	4401      	add	r1, r0
34192c3a:	f501 6110 	add.w	r1, r1, #2304	@ 0x900
34192c3e:	4313      	orrs	r3, r2
34192c40:	610b      	str	r3, [r1, #16]
        }
      }

      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);
34192c42:	69bb      	ldr	r3, [r7, #24]
34192c44:	015a      	lsls	r2, r3, #5
34192c46:	69fb      	ldr	r3, [r7, #28]
34192c48:	4413      	add	r3, r2
34192c4a:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
34192c4e:	691a      	ldr	r2, [r3, #16]
34192c50:	68bb      	ldr	r3, [r7, #8]
34192c52:	691b      	ldr	r3, [r3, #16]
34192c54:	f3c3 0312 	ubfx	r3, r3, #0, #19
34192c58:	69b9      	ldr	r1, [r7, #24]
34192c5a:	0148      	lsls	r0, r1, #5
34192c5c:	69f9      	ldr	r1, [r7, #28]
34192c5e:	4401      	add	r1, r0
34192c60:	f501 6110 	add.w	r1, r1, #2304	@ 0x900
34192c64:	4313      	orrs	r3, r2
34192c66:	610b      	str	r3, [r1, #16]
    }

    if (dma == 1U)
34192c68:	79fb      	ldrb	r3, [r7, #7]
34192c6a:	2b01      	cmp	r3, #1
34192c6c:	d14b      	bne.n	34192d06 <USB_EPStartXfer+0x25e>
    {
      if ((uint32_t)ep->dma_addr != 0U)
34192c6e:	68bb      	ldr	r3, [r7, #8]
34192c70:	69db      	ldr	r3, [r3, #28]
34192c72:	2b00      	cmp	r3, #0
34192c74:	d009      	beq.n	34192c8a <USB_EPStartXfer+0x1e2>
      {
        USBx_INEP(epnum)->DIEPDMA = (uint32_t)(ep->dma_addr);
34192c76:	69bb      	ldr	r3, [r7, #24]
34192c78:	015a      	lsls	r2, r3, #5
34192c7a:	69fb      	ldr	r3, [r7, #28]
34192c7c:	4413      	add	r3, r2
34192c7e:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
34192c82:	461a      	mov	r2, r3
34192c84:	68bb      	ldr	r3, [r7, #8]
34192c86:	69db      	ldr	r3, [r3, #28]
34192c88:	6153      	str	r3, [r2, #20]
      }

      if (ep->type == EP_TYPE_ISOC)
34192c8a:	68bb      	ldr	r3, [r7, #8]
34192c8c:	791b      	ldrb	r3, [r3, #4]
34192c8e:	2b01      	cmp	r3, #1
34192c90:	d128      	bne.n	34192ce4 <USB_EPStartXfer+0x23c>
      {
        if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
34192c92:	69fb      	ldr	r3, [r7, #28]
34192c94:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
34192c98:	689b      	ldr	r3, [r3, #8]
34192c9a:	f403 7380 	and.w	r3, r3, #256	@ 0x100
34192c9e:	2b00      	cmp	r3, #0
34192ca0:	d110      	bne.n	34192cc4 <USB_EPStartXfer+0x21c>
        {
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
34192ca2:	69bb      	ldr	r3, [r7, #24]
34192ca4:	015a      	lsls	r2, r3, #5
34192ca6:	69fb      	ldr	r3, [r7, #28]
34192ca8:	4413      	add	r3, r2
34192caa:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
34192cae:	681b      	ldr	r3, [r3, #0]
34192cb0:	69ba      	ldr	r2, [r7, #24]
34192cb2:	0151      	lsls	r1, r2, #5
34192cb4:	69fa      	ldr	r2, [r7, #28]
34192cb6:	440a      	add	r2, r1
34192cb8:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
34192cbc:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
34192cc0:	6013      	str	r3, [r2, #0]
34192cc2:	e00f      	b.n	34192ce4 <USB_EPStartXfer+0x23c>
        }
        else
        {
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
34192cc4:	69bb      	ldr	r3, [r7, #24]
34192cc6:	015a      	lsls	r2, r3, #5
34192cc8:	69fb      	ldr	r3, [r7, #28]
34192cca:	4413      	add	r3, r2
34192ccc:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
34192cd0:	681b      	ldr	r3, [r3, #0]
34192cd2:	69ba      	ldr	r2, [r7, #24]
34192cd4:	0151      	lsls	r1, r2, #5
34192cd6:	69fa      	ldr	r2, [r7, #28]
34192cd8:	440a      	add	r2, r1
34192cda:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
34192cde:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
34192ce2:	6013      	str	r3, [r2, #0]
        }
      }

      /* EP enable, IN data in FIFO */
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
34192ce4:	69bb      	ldr	r3, [r7, #24]
34192ce6:	015a      	lsls	r2, r3, #5
34192ce8:	69fb      	ldr	r3, [r7, #28]
34192cea:	4413      	add	r3, r2
34192cec:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
34192cf0:	681b      	ldr	r3, [r3, #0]
34192cf2:	69ba      	ldr	r2, [r7, #24]
34192cf4:	0151      	lsls	r1, r2, #5
34192cf6:	69fa      	ldr	r2, [r7, #28]
34192cf8:	440a      	add	r2, r1
34192cfa:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
34192cfe:	f043 4304 	orr.w	r3, r3, #2214592512	@ 0x84000000
34192d02:	6013      	str	r3, [r2, #0]
34192d04:	e166      	b.n	34192fd4 <USB_EPStartXfer+0x52c>
    }
    else
    {
      /* EP enable, IN data in FIFO */
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
34192d06:	69bb      	ldr	r3, [r7, #24]
34192d08:	015a      	lsls	r2, r3, #5
34192d0a:	69fb      	ldr	r3, [r7, #28]
34192d0c:	4413      	add	r3, r2
34192d0e:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
34192d12:	681b      	ldr	r3, [r3, #0]
34192d14:	69ba      	ldr	r2, [r7, #24]
34192d16:	0151      	lsls	r1, r2, #5
34192d18:	69fa      	ldr	r2, [r7, #28]
34192d1a:	440a      	add	r2, r1
34192d1c:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
34192d20:	f043 4304 	orr.w	r3, r3, #2214592512	@ 0x84000000
34192d24:	6013      	str	r3, [r2, #0]

      if (ep->type != EP_TYPE_ISOC)
34192d26:	68bb      	ldr	r3, [r7, #8]
34192d28:	791b      	ldrb	r3, [r3, #4]
34192d2a:	2b01      	cmp	r3, #1
34192d2c:	d015      	beq.n	34192d5a <USB_EPStartXfer+0x2b2>
      {
        /* Enable the Tx FIFO Empty Interrupt for this EP */
        if (ep->xfer_len > 0U)
34192d2e:	68bb      	ldr	r3, [r7, #8]
34192d30:	691b      	ldr	r3, [r3, #16]
34192d32:	2b00      	cmp	r3, #0
34192d34:	f000 814e 	beq.w	34192fd4 <USB_EPStartXfer+0x52c>
        {
          USBx_DEVICE->DIEPEMPMSK |= 1UL << (ep->num & EP_ADDR_MSK);
34192d38:	69fb      	ldr	r3, [r7, #28]
34192d3a:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
34192d3e:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
34192d40:	68bb      	ldr	r3, [r7, #8]
34192d42:	781b      	ldrb	r3, [r3, #0]
34192d44:	f003 030f 	and.w	r3, r3, #15
34192d48:	2101      	movs	r1, #1
34192d4a:	fa01 f303 	lsl.w	r3, r1, r3
34192d4e:	69f9      	ldr	r1, [r7, #28]
34192d50:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
34192d54:	4313      	orrs	r3, r2
34192d56:	634b      	str	r3, [r1, #52]	@ 0x34
34192d58:	e13c      	b.n	34192fd4 <USB_EPStartXfer+0x52c>
        }
      }
      else
      {
        if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
34192d5a:	69fb      	ldr	r3, [r7, #28]
34192d5c:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
34192d60:	689b      	ldr	r3, [r3, #8]
34192d62:	f403 7380 	and.w	r3, r3, #256	@ 0x100
34192d66:	2b00      	cmp	r3, #0
34192d68:	d110      	bne.n	34192d8c <USB_EPStartXfer+0x2e4>
        {
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
34192d6a:	69bb      	ldr	r3, [r7, #24]
34192d6c:	015a      	lsls	r2, r3, #5
34192d6e:	69fb      	ldr	r3, [r7, #28]
34192d70:	4413      	add	r3, r2
34192d72:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
34192d76:	681b      	ldr	r3, [r3, #0]
34192d78:	69ba      	ldr	r2, [r7, #24]
34192d7a:	0151      	lsls	r1, r2, #5
34192d7c:	69fa      	ldr	r2, [r7, #28]
34192d7e:	440a      	add	r2, r1
34192d80:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
34192d84:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
34192d88:	6013      	str	r3, [r2, #0]
34192d8a:	e00f      	b.n	34192dac <USB_EPStartXfer+0x304>
        }
        else
        {
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
34192d8c:	69bb      	ldr	r3, [r7, #24]
34192d8e:	015a      	lsls	r2, r3, #5
34192d90:	69fb      	ldr	r3, [r7, #28]
34192d92:	4413      	add	r3, r2
34192d94:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
34192d98:	681b      	ldr	r3, [r3, #0]
34192d9a:	69ba      	ldr	r2, [r7, #24]
34192d9c:	0151      	lsls	r1, r2, #5
34192d9e:	69fa      	ldr	r2, [r7, #28]
34192da0:	440a      	add	r2, r1
34192da2:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
34192da6:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
34192daa:	6013      	str	r3, [r2, #0]
        }

        (void)USB_WritePacket(USBx, ep->xfer_buff, ep->num, (uint16_t)ep->xfer_len, dma);
34192dac:	68bb      	ldr	r3, [r7, #8]
34192dae:	68d9      	ldr	r1, [r3, #12]
34192db0:	68bb      	ldr	r3, [r7, #8]
34192db2:	781a      	ldrb	r2, [r3, #0]
34192db4:	68bb      	ldr	r3, [r7, #8]
34192db6:	691b      	ldr	r3, [r3, #16]
34192db8:	b298      	uxth	r0, r3
34192dba:	79fb      	ldrb	r3, [r7, #7]
34192dbc:	9300      	str	r3, [sp, #0]
34192dbe:	4603      	mov	r3, r0
34192dc0:	68f8      	ldr	r0, [r7, #12]
34192dc2:	f000 f9b9 	bl	34193138 <USB_WritePacket>
34192dc6:	e105      	b.n	34192fd4 <USB_EPStartXfer+0x52c>
  {
    /* Program the transfer size and packet count as follows:
    * pktcnt = N
    * xfersize = N * maxpacket
    */
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ);
34192dc8:	69bb      	ldr	r3, [r7, #24]
34192dca:	015a      	lsls	r2, r3, #5
34192dcc:	69fb      	ldr	r3, [r7, #28]
34192dce:	4413      	add	r3, r2
34192dd0:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
34192dd4:	691b      	ldr	r3, [r3, #16]
34192dd6:	69ba      	ldr	r2, [r7, #24]
34192dd8:	0151      	lsls	r1, r2, #5
34192dda:	69fa      	ldr	r2, [r7, #28]
34192ddc:	440a      	add	r2, r1
34192dde:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
34192de2:	0cdb      	lsrs	r3, r3, #19
34192de4:	04db      	lsls	r3, r3, #19
34192de6:	6113      	str	r3, [r2, #16]
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT);
34192de8:	69bb      	ldr	r3, [r7, #24]
34192dea:	015a      	lsls	r2, r3, #5
34192dec:	69fb      	ldr	r3, [r7, #28]
34192dee:	4413      	add	r3, r2
34192df0:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
34192df4:	691b      	ldr	r3, [r3, #16]
34192df6:	69ba      	ldr	r2, [r7, #24]
34192df8:	0151      	lsls	r1, r2, #5
34192dfa:	69fa      	ldr	r2, [r7, #28]
34192dfc:	440a      	add	r2, r1
34192dfe:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
34192e02:	f023 53ff 	bic.w	r3, r3, #534773760	@ 0x1fe00000
34192e06:	f423 13c0 	bic.w	r3, r3, #1572864	@ 0x180000
34192e0a:	6113      	str	r3, [r2, #16]

    if (epnum == 0U)
34192e0c:	69bb      	ldr	r3, [r7, #24]
34192e0e:	2b00      	cmp	r3, #0
34192e10:	d132      	bne.n	34192e78 <USB_EPStartXfer+0x3d0>
    {
      if (ep->xfer_len > 0U)
34192e12:	68bb      	ldr	r3, [r7, #8]
34192e14:	691b      	ldr	r3, [r3, #16]
34192e16:	2b00      	cmp	r3, #0
34192e18:	d003      	beq.n	34192e22 <USB_EPStartXfer+0x37a>
      {
        ep->xfer_len = ep->maxpacket;
34192e1a:	68bb      	ldr	r3, [r7, #8]
34192e1c:	689a      	ldr	r2, [r3, #8]
34192e1e:	68bb      	ldr	r3, [r7, #8]
34192e20:	611a      	str	r2, [r3, #16]
      }

      /* Store transfer size, for EP0 this is equal to endpoint max packet size */
      ep->xfer_size = ep->maxpacket;
34192e22:	68bb      	ldr	r3, [r7, #8]
34192e24:	689a      	ldr	r2, [r3, #8]
34192e26:	68bb      	ldr	r3, [r7, #8]
34192e28:	621a      	str	r2, [r3, #32]

      USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->xfer_size);
34192e2a:	69bb      	ldr	r3, [r7, #24]
34192e2c:	015a      	lsls	r2, r3, #5
34192e2e:	69fb      	ldr	r3, [r7, #28]
34192e30:	4413      	add	r3, r2
34192e32:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
34192e36:	691a      	ldr	r2, [r3, #16]
34192e38:	68bb      	ldr	r3, [r7, #8]
34192e3a:	6a1b      	ldr	r3, [r3, #32]
34192e3c:	f3c3 0312 	ubfx	r3, r3, #0, #19
34192e40:	69b9      	ldr	r1, [r7, #24]
34192e42:	0148      	lsls	r0, r1, #5
34192e44:	69f9      	ldr	r1, [r7, #28]
34192e46:	4401      	add	r1, r0
34192e48:	f501 6130 	add.w	r1, r1, #2816	@ 0xb00
34192e4c:	4313      	orrs	r3, r2
34192e4e:	610b      	str	r3, [r1, #16]
      USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
34192e50:	69bb      	ldr	r3, [r7, #24]
34192e52:	015a      	lsls	r2, r3, #5
34192e54:	69fb      	ldr	r3, [r7, #28]
34192e56:	4413      	add	r3, r2
34192e58:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
34192e5c:	691b      	ldr	r3, [r3, #16]
34192e5e:	69ba      	ldr	r2, [r7, #24]
34192e60:	0151      	lsls	r1, r2, #5
34192e62:	69fa      	ldr	r2, [r7, #28]
34192e64:	440a      	add	r2, r1
34192e66:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
34192e6a:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
34192e6e:	6113      	str	r3, [r2, #16]
34192e70:	e062      	b.n	34192f38 <USB_EPStartXfer+0x490>
34192e72:	bf00      	nop
34192e74:	1ff80000 	.word	0x1ff80000
    }
    else
    {
      if (ep->xfer_len == 0U)
34192e78:	68bb      	ldr	r3, [r7, #8]
34192e7a:	691b      	ldr	r3, [r3, #16]
34192e7c:	2b00      	cmp	r3, #0
34192e7e:	d123      	bne.n	34192ec8 <USB_EPStartXfer+0x420>
      {
        USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
34192e80:	69bb      	ldr	r3, [r7, #24]
34192e82:	015a      	lsls	r2, r3, #5
34192e84:	69fb      	ldr	r3, [r7, #28]
34192e86:	4413      	add	r3, r2
34192e88:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
34192e8c:	691a      	ldr	r2, [r3, #16]
34192e8e:	68bb      	ldr	r3, [r7, #8]
34192e90:	689b      	ldr	r3, [r3, #8]
34192e92:	f3c3 0312 	ubfx	r3, r3, #0, #19
34192e96:	69b9      	ldr	r1, [r7, #24]
34192e98:	0148      	lsls	r0, r1, #5
34192e9a:	69f9      	ldr	r1, [r7, #28]
34192e9c:	4401      	add	r1, r0
34192e9e:	f501 6130 	add.w	r1, r1, #2816	@ 0xb00
34192ea2:	4313      	orrs	r3, r2
34192ea4:	610b      	str	r3, [r1, #16]
        USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
34192ea6:	69bb      	ldr	r3, [r7, #24]
34192ea8:	015a      	lsls	r2, r3, #5
34192eaa:	69fb      	ldr	r3, [r7, #28]
34192eac:	4413      	add	r3, r2
34192eae:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
34192eb2:	691b      	ldr	r3, [r3, #16]
34192eb4:	69ba      	ldr	r2, [r7, #24]
34192eb6:	0151      	lsls	r1, r2, #5
34192eb8:	69fa      	ldr	r2, [r7, #28]
34192eba:	440a      	add	r2, r1
34192ebc:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
34192ec0:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
34192ec4:	6113      	str	r3, [r2, #16]
34192ec6:	e037      	b.n	34192f38 <USB_EPStartXfer+0x490>
      }
      else
      {
        pktcnt = (uint16_t)((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket);
34192ec8:	68bb      	ldr	r3, [r7, #8]
34192eca:	691a      	ldr	r2, [r3, #16]
34192ecc:	68bb      	ldr	r3, [r7, #8]
34192ece:	689b      	ldr	r3, [r3, #8]
34192ed0:	4413      	add	r3, r2
34192ed2:	1e5a      	subs	r2, r3, #1
34192ed4:	68bb      	ldr	r3, [r7, #8]
34192ed6:	689b      	ldr	r3, [r3, #8]
34192ed8:	fbb2 f3f3 	udiv	r3, r2, r3
34192edc:	82fb      	strh	r3, [r7, #22]
        ep->xfer_size = ep->maxpacket * pktcnt;
34192ede:	68bb      	ldr	r3, [r7, #8]
34192ee0:	689b      	ldr	r3, [r3, #8]
34192ee2:	8afa      	ldrh	r2, [r7, #22]
34192ee4:	fb03 f202 	mul.w	r2, r3, r2
34192ee8:	68bb      	ldr	r3, [r7, #8]
34192eea:	621a      	str	r2, [r3, #32]

        USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_PKTCNT & ((uint32_t)pktcnt << 19);
34192eec:	69bb      	ldr	r3, [r7, #24]
34192eee:	015a      	lsls	r2, r3, #5
34192ef0:	69fb      	ldr	r3, [r7, #28]
34192ef2:	4413      	add	r3, r2
34192ef4:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
34192ef8:	691a      	ldr	r2, [r3, #16]
34192efa:	8afb      	ldrh	r3, [r7, #22]
34192efc:	04d9      	lsls	r1, r3, #19
34192efe:	4b38      	ldr	r3, [pc, #224]	@ (34192fe0 <USB_EPStartXfer+0x538>)
34192f00:	400b      	ands	r3, r1
34192f02:	69b9      	ldr	r1, [r7, #24]
34192f04:	0148      	lsls	r0, r1, #5
34192f06:	69f9      	ldr	r1, [r7, #28]
34192f08:	4401      	add	r1, r0
34192f0a:	f501 6130 	add.w	r1, r1, #2816	@ 0xb00
34192f0e:	4313      	orrs	r3, r2
34192f10:	610b      	str	r3, [r1, #16]
        USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_XFRSIZ & ep->xfer_size;
34192f12:	69bb      	ldr	r3, [r7, #24]
34192f14:	015a      	lsls	r2, r3, #5
34192f16:	69fb      	ldr	r3, [r7, #28]
34192f18:	4413      	add	r3, r2
34192f1a:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
34192f1e:	691a      	ldr	r2, [r3, #16]
34192f20:	68bb      	ldr	r3, [r7, #8]
34192f22:	6a1b      	ldr	r3, [r3, #32]
34192f24:	f3c3 0312 	ubfx	r3, r3, #0, #19
34192f28:	69b9      	ldr	r1, [r7, #24]
34192f2a:	0148      	lsls	r0, r1, #5
34192f2c:	69f9      	ldr	r1, [r7, #28]
34192f2e:	4401      	add	r1, r0
34192f30:	f501 6130 	add.w	r1, r1, #2816	@ 0xb00
34192f34:	4313      	orrs	r3, r2
34192f36:	610b      	str	r3, [r1, #16]
      }
    }

    if (dma == 1U)
34192f38:	79fb      	ldrb	r3, [r7, #7]
34192f3a:	2b01      	cmp	r3, #1
34192f3c:	d10d      	bne.n	34192f5a <USB_EPStartXfer+0x4b2>
    {
      if ((uint32_t)ep->xfer_buff != 0U)
34192f3e:	68bb      	ldr	r3, [r7, #8]
34192f40:	68db      	ldr	r3, [r3, #12]
34192f42:	2b00      	cmp	r3, #0
34192f44:	d009      	beq.n	34192f5a <USB_EPStartXfer+0x4b2>
      {
        USBx_OUTEP(epnum)->DOEPDMA = (uint32_t)(ep->xfer_buff);
34192f46:	68bb      	ldr	r3, [r7, #8]
34192f48:	68d9      	ldr	r1, [r3, #12]
34192f4a:	69bb      	ldr	r3, [r7, #24]
34192f4c:	015a      	lsls	r2, r3, #5
34192f4e:	69fb      	ldr	r3, [r7, #28]
34192f50:	4413      	add	r3, r2
34192f52:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
34192f56:	460a      	mov	r2, r1
34192f58:	615a      	str	r2, [r3, #20]
      }
    }

    if (ep->type == EP_TYPE_ISOC)
34192f5a:	68bb      	ldr	r3, [r7, #8]
34192f5c:	791b      	ldrb	r3, [r3, #4]
34192f5e:	2b01      	cmp	r3, #1
34192f60:	d128      	bne.n	34192fb4 <USB_EPStartXfer+0x50c>
    {
      if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
34192f62:	69fb      	ldr	r3, [r7, #28]
34192f64:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
34192f68:	689b      	ldr	r3, [r3, #8]
34192f6a:	f403 7380 	and.w	r3, r3, #256	@ 0x100
34192f6e:	2b00      	cmp	r3, #0
34192f70:	d110      	bne.n	34192f94 <USB_EPStartXfer+0x4ec>
      {
        USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SODDFRM;
34192f72:	69bb      	ldr	r3, [r7, #24]
34192f74:	015a      	lsls	r2, r3, #5
34192f76:	69fb      	ldr	r3, [r7, #28]
34192f78:	4413      	add	r3, r2
34192f7a:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
34192f7e:	681b      	ldr	r3, [r3, #0]
34192f80:	69ba      	ldr	r2, [r7, #24]
34192f82:	0151      	lsls	r1, r2, #5
34192f84:	69fa      	ldr	r2, [r7, #28]
34192f86:	440a      	add	r2, r1
34192f88:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
34192f8c:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
34192f90:	6013      	str	r3, [r2, #0]
34192f92:	e00f      	b.n	34192fb4 <USB_EPStartXfer+0x50c>
      }
      else
      {
        USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM;
34192f94:	69bb      	ldr	r3, [r7, #24]
34192f96:	015a      	lsls	r2, r3, #5
34192f98:	69fb      	ldr	r3, [r7, #28]
34192f9a:	4413      	add	r3, r2
34192f9c:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
34192fa0:	681b      	ldr	r3, [r3, #0]
34192fa2:	69ba      	ldr	r2, [r7, #24]
34192fa4:	0151      	lsls	r1, r2, #5
34192fa6:	69fa      	ldr	r2, [r7, #28]
34192fa8:	440a      	add	r2, r1
34192faa:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
34192fae:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
34192fb2:	6013      	str	r3, [r2, #0]
      }
    }
    /* EP enable */
    USBx_OUTEP(epnum)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
34192fb4:	69bb      	ldr	r3, [r7, #24]
34192fb6:	015a      	lsls	r2, r3, #5
34192fb8:	69fb      	ldr	r3, [r7, #28]
34192fba:	4413      	add	r3, r2
34192fbc:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
34192fc0:	681b      	ldr	r3, [r3, #0]
34192fc2:	69ba      	ldr	r2, [r7, #24]
34192fc4:	0151      	lsls	r1, r2, #5
34192fc6:	69fa      	ldr	r2, [r7, #28]
34192fc8:	440a      	add	r2, r1
34192fca:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
34192fce:	f043 4304 	orr.w	r3, r3, #2214592512	@ 0x84000000
34192fd2:	6013      	str	r3, [r2, #0]
  }

  return HAL_OK;
34192fd4:	2300      	movs	r3, #0
}
34192fd6:	4618      	mov	r0, r3
34192fd8:	3720      	adds	r7, #32
34192fda:	46bd      	mov	sp, r7
34192fdc:	bd80      	pop	{r7, pc}
34192fde:	bf00      	nop
34192fe0:	1ff80000 	.word	0x1ff80000

34192fe4 <USB_EPStopXfer>:
   * @param  USBx  usb device instance
   * @param  ep pointer to endpoint structure
   * @retval HAL status
   */
HAL_StatusTypeDef USB_EPStopXfer(const USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
34192fe4:	b480      	push	{r7}
34192fe6:	b087      	sub	sp, #28
34192fe8:	af00      	add	r7, sp, #0
34192fea:	6078      	str	r0, [r7, #4]
34192fec:	6039      	str	r1, [r7, #0]
  __IO uint32_t count = 0U;
34192fee:	2300      	movs	r3, #0
34192ff0:	60fb      	str	r3, [r7, #12]
  HAL_StatusTypeDef ret = HAL_OK;
34192ff2:	2300      	movs	r3, #0
34192ff4:	75fb      	strb	r3, [r7, #23]
  uint32_t USBx_BASE = (uint32_t)USBx;
34192ff6:	687b      	ldr	r3, [r7, #4]
34192ff8:	613b      	str	r3, [r7, #16]

  /* IN endpoint */
  if (ep->is_in == 1U)
34192ffa:	683b      	ldr	r3, [r7, #0]
34192ffc:	785b      	ldrb	r3, [r3, #1]
34192ffe:	2b01      	cmp	r3, #1
34193000:	d14a      	bne.n	34193098 <USB_EPStopXfer+0xb4>
  {
    /* EP enable, IN data in FIFO */
    if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
34193002:	683b      	ldr	r3, [r7, #0]
34193004:	781b      	ldrb	r3, [r3, #0]
34193006:	015a      	lsls	r2, r3, #5
34193008:	693b      	ldr	r3, [r7, #16]
3419300a:	4413      	add	r3, r2
3419300c:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
34193010:	681b      	ldr	r3, [r3, #0]
34193012:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
34193016:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
3419301a:	f040 8086 	bne.w	3419312a <USB_EPStopXfer+0x146>
    {
      USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_SNAK);
3419301e:	683b      	ldr	r3, [r7, #0]
34193020:	781b      	ldrb	r3, [r3, #0]
34193022:	015a      	lsls	r2, r3, #5
34193024:	693b      	ldr	r3, [r7, #16]
34193026:	4413      	add	r3, r2
34193028:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
3419302c:	681b      	ldr	r3, [r3, #0]
3419302e:	683a      	ldr	r2, [r7, #0]
34193030:	7812      	ldrb	r2, [r2, #0]
34193032:	0151      	lsls	r1, r2, #5
34193034:	693a      	ldr	r2, [r7, #16]
34193036:	440a      	add	r2, r1
34193038:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
3419303c:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
34193040:	6013      	str	r3, [r2, #0]
      USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_EPDIS);
34193042:	683b      	ldr	r3, [r7, #0]
34193044:	781b      	ldrb	r3, [r3, #0]
34193046:	015a      	lsls	r2, r3, #5
34193048:	693b      	ldr	r3, [r7, #16]
3419304a:	4413      	add	r3, r2
3419304c:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
34193050:	681b      	ldr	r3, [r3, #0]
34193052:	683a      	ldr	r2, [r7, #0]
34193054:	7812      	ldrb	r2, [r2, #0]
34193056:	0151      	lsls	r1, r2, #5
34193058:	693a      	ldr	r2, [r7, #16]
3419305a:	440a      	add	r2, r1
3419305c:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
34193060:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
34193064:	6013      	str	r3, [r2, #0]

      do
      {
        count++;
34193066:	68fb      	ldr	r3, [r7, #12]
34193068:	3301      	adds	r3, #1
3419306a:	60fb      	str	r3, [r7, #12]

        if (count > 10000U)
3419306c:	68fb      	ldr	r3, [r7, #12]
3419306e:	f242 7210 	movw	r2, #10000	@ 0x2710
34193072:	4293      	cmp	r3, r2
34193074:	d902      	bls.n	3419307c <USB_EPStopXfer+0x98>
        {
          ret = HAL_ERROR;
34193076:	2301      	movs	r3, #1
34193078:	75fb      	strb	r3, [r7, #23]
          break;
3419307a:	e056      	b.n	3419312a <USB_EPStopXfer+0x146>
        }
      } while (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_EPENA) ==  USB_OTG_DIEPCTL_EPENA);
3419307c:	683b      	ldr	r3, [r7, #0]
3419307e:	781b      	ldrb	r3, [r3, #0]
34193080:	015a      	lsls	r2, r3, #5
34193082:	693b      	ldr	r3, [r7, #16]
34193084:	4413      	add	r3, r2
34193086:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
3419308a:	681b      	ldr	r3, [r3, #0]
3419308c:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
34193090:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
34193094:	d0e7      	beq.n	34193066 <USB_EPStopXfer+0x82>
34193096:	e048      	b.n	3419312a <USB_EPStopXfer+0x146>
    }
  }
  else /* OUT endpoint */
  {
    if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
34193098:	683b      	ldr	r3, [r7, #0]
3419309a:	781b      	ldrb	r3, [r3, #0]
3419309c:	015a      	lsls	r2, r3, #5
3419309e:	693b      	ldr	r3, [r7, #16]
341930a0:	4413      	add	r3, r2
341930a2:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
341930a6:	681b      	ldr	r3, [r3, #0]
341930a8:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
341930ac:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
341930b0:	d13b      	bne.n	3419312a <USB_EPStopXfer+0x146>
    {
      USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_SNAK);
341930b2:	683b      	ldr	r3, [r7, #0]
341930b4:	781b      	ldrb	r3, [r3, #0]
341930b6:	015a      	lsls	r2, r3, #5
341930b8:	693b      	ldr	r3, [r7, #16]
341930ba:	4413      	add	r3, r2
341930bc:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
341930c0:	681b      	ldr	r3, [r3, #0]
341930c2:	683a      	ldr	r2, [r7, #0]
341930c4:	7812      	ldrb	r2, [r2, #0]
341930c6:	0151      	lsls	r1, r2, #5
341930c8:	693a      	ldr	r2, [r7, #16]
341930ca:	440a      	add	r2, r1
341930cc:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
341930d0:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
341930d4:	6013      	str	r3, [r2, #0]
      USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_EPDIS);
341930d6:	683b      	ldr	r3, [r7, #0]
341930d8:	781b      	ldrb	r3, [r3, #0]
341930da:	015a      	lsls	r2, r3, #5
341930dc:	693b      	ldr	r3, [r7, #16]
341930de:	4413      	add	r3, r2
341930e0:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
341930e4:	681b      	ldr	r3, [r3, #0]
341930e6:	683a      	ldr	r2, [r7, #0]
341930e8:	7812      	ldrb	r2, [r2, #0]
341930ea:	0151      	lsls	r1, r2, #5
341930ec:	693a      	ldr	r2, [r7, #16]
341930ee:	440a      	add	r2, r1
341930f0:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
341930f4:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
341930f8:	6013      	str	r3, [r2, #0]

      do
      {
        count++;
341930fa:	68fb      	ldr	r3, [r7, #12]
341930fc:	3301      	adds	r3, #1
341930fe:	60fb      	str	r3, [r7, #12]

        if (count > 10000U)
34193100:	68fb      	ldr	r3, [r7, #12]
34193102:	f242 7210 	movw	r2, #10000	@ 0x2710
34193106:	4293      	cmp	r3, r2
34193108:	d902      	bls.n	34193110 <USB_EPStopXfer+0x12c>
        {
          ret = HAL_ERROR;
3419310a:	2301      	movs	r3, #1
3419310c:	75fb      	strb	r3, [r7, #23]
          break;
3419310e:	e00c      	b.n	3419312a <USB_EPStopXfer+0x146>
        }
      } while (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_EPENA) ==  USB_OTG_DOEPCTL_EPENA);
34193110:	683b      	ldr	r3, [r7, #0]
34193112:	781b      	ldrb	r3, [r3, #0]
34193114:	015a      	lsls	r2, r3, #5
34193116:	693b      	ldr	r3, [r7, #16]
34193118:	4413      	add	r3, r2
3419311a:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
3419311e:	681b      	ldr	r3, [r3, #0]
34193120:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
34193124:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
34193128:	d0e7      	beq.n	341930fa <USB_EPStopXfer+0x116>
    }
  }

  return ret;
3419312a:	7dfb      	ldrb	r3, [r7, #23]
}
3419312c:	4618      	mov	r0, r3
3419312e:	371c      	adds	r7, #28
34193130:	46bd      	mov	sp, r7
34193132:	f85d 7b04 	ldr.w	r7, [sp], #4
34193136:	4770      	bx	lr

34193138 <USB_WritePacket>:
  *           1 : DMA feature used
  * @retval HAL status
  */
HAL_StatusTypeDef USB_WritePacket(const USB_OTG_GlobalTypeDef *USBx, uint8_t *src,
                                  uint8_t ch_ep_num, uint16_t len, uint8_t dma)
{
34193138:	b480      	push	{r7}
3419313a:	b089      	sub	sp, #36	@ 0x24
3419313c:	af00      	add	r7, sp, #0
3419313e:	60f8      	str	r0, [r7, #12]
34193140:	60b9      	str	r1, [r7, #8]
34193142:	4611      	mov	r1, r2
34193144:	461a      	mov	r2, r3
34193146:	460b      	mov	r3, r1
34193148:	71fb      	strb	r3, [r7, #7]
3419314a:	4613      	mov	r3, r2
3419314c:	80bb      	strh	r3, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
3419314e:	68fb      	ldr	r3, [r7, #12]
34193150:	617b      	str	r3, [r7, #20]
  uint8_t *pSrc = src;
34193152:	68bb      	ldr	r3, [r7, #8]
34193154:	61fb      	str	r3, [r7, #28]
  uint32_t count32b;
  uint32_t i;

  if (dma == 0U)
34193156:	f897 3028 	ldrb.w	r3, [r7, #40]	@ 0x28
3419315a:	2b00      	cmp	r3, #0
3419315c:	d123      	bne.n	341931a6 <USB_WritePacket+0x6e>
  {
    count32b = ((uint32_t)len + 3U) / 4U;
3419315e:	88bb      	ldrh	r3, [r7, #4]
34193160:	3303      	adds	r3, #3
34193162:	089b      	lsrs	r3, r3, #2
34193164:	613b      	str	r3, [r7, #16]
    for (i = 0U; i < count32b; i++)
34193166:	2300      	movs	r3, #0
34193168:	61bb      	str	r3, [r7, #24]
3419316a:	e018      	b.n	3419319e <USB_WritePacket+0x66>
    {
      USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
3419316c:	79fb      	ldrb	r3, [r7, #7]
3419316e:	031a      	lsls	r2, r3, #12
34193170:	697b      	ldr	r3, [r7, #20]
34193172:	4413      	add	r3, r2
34193174:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34193178:	461a      	mov	r2, r3
3419317a:	69fb      	ldr	r3, [r7, #28]
3419317c:	681b      	ldr	r3, [r3, #0]
3419317e:	6013      	str	r3, [r2, #0]
      pSrc++;
34193180:	69fb      	ldr	r3, [r7, #28]
34193182:	3301      	adds	r3, #1
34193184:	61fb      	str	r3, [r7, #28]
      pSrc++;
34193186:	69fb      	ldr	r3, [r7, #28]
34193188:	3301      	adds	r3, #1
3419318a:	61fb      	str	r3, [r7, #28]
      pSrc++;
3419318c:	69fb      	ldr	r3, [r7, #28]
3419318e:	3301      	adds	r3, #1
34193190:	61fb      	str	r3, [r7, #28]
      pSrc++;
34193192:	69fb      	ldr	r3, [r7, #28]
34193194:	3301      	adds	r3, #1
34193196:	61fb      	str	r3, [r7, #28]
    for (i = 0U; i < count32b; i++)
34193198:	69bb      	ldr	r3, [r7, #24]
3419319a:	3301      	adds	r3, #1
3419319c:	61bb      	str	r3, [r7, #24]
3419319e:	69ba      	ldr	r2, [r7, #24]
341931a0:	693b      	ldr	r3, [r7, #16]
341931a2:	429a      	cmp	r2, r3
341931a4:	d3e2      	bcc.n	3419316c <USB_WritePacket+0x34>
    }
  }

  return HAL_OK;
341931a6:	2300      	movs	r3, #0
}
341931a8:	4618      	mov	r0, r3
341931aa:	3724      	adds	r7, #36	@ 0x24
341931ac:	46bd      	mov	sp, r7
341931ae:	f85d 7b04 	ldr.w	r7, [sp], #4
341931b2:	4770      	bx	lr

341931b4 <USB_ReadPacket>:
  * @param  dest  source pointer
  * @param  len  Number of bytes to read
  * @retval pointer to destination buffer
  */
void *USB_ReadPacket(const USB_OTG_GlobalTypeDef *USBx, uint8_t *dest, uint16_t len)
{
341931b4:	b480      	push	{r7}
341931b6:	b08b      	sub	sp, #44	@ 0x2c
341931b8:	af00      	add	r7, sp, #0
341931ba:	60f8      	str	r0, [r7, #12]
341931bc:	60b9      	str	r1, [r7, #8]
341931be:	4613      	mov	r3, r2
341931c0:	80fb      	strh	r3, [r7, #6]
  uint32_t USBx_BASE = (uint32_t)USBx;
341931c2:	68fb      	ldr	r3, [r7, #12]
341931c4:	61bb      	str	r3, [r7, #24]
  uint8_t *pDest = dest;
341931c6:	68bb      	ldr	r3, [r7, #8]
341931c8:	627b      	str	r3, [r7, #36]	@ 0x24
  uint32_t pData;
  uint32_t i;
  uint32_t count32b = (uint32_t)len >> 2U;
341931ca:	88fb      	ldrh	r3, [r7, #6]
341931cc:	089b      	lsrs	r3, r3, #2
341931ce:	b29b      	uxth	r3, r3
341931d0:	617b      	str	r3, [r7, #20]
  uint16_t remaining_bytes = len % 4U;
341931d2:	88fb      	ldrh	r3, [r7, #6]
341931d4:	f003 0303 	and.w	r3, r3, #3
341931d8:	83fb      	strh	r3, [r7, #30]

  for (i = 0U; i < count32b; i++)
341931da:	2300      	movs	r3, #0
341931dc:	623b      	str	r3, [r7, #32]
341931de:	e014      	b.n	3419320a <USB_ReadPacket+0x56>
  {
    __UNALIGNED_UINT32_WRITE(pDest, USBx_DFIFO(0U));
341931e0:	69bb      	ldr	r3, [r7, #24]
341931e2:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
341931e6:	681a      	ldr	r2, [r3, #0]
341931e8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
341931ea:	601a      	str	r2, [r3, #0]
    pDest++;
341931ec:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
341931ee:	3301      	adds	r3, #1
341931f0:	627b      	str	r3, [r7, #36]	@ 0x24
    pDest++;
341931f2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
341931f4:	3301      	adds	r3, #1
341931f6:	627b      	str	r3, [r7, #36]	@ 0x24
    pDest++;
341931f8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
341931fa:	3301      	adds	r3, #1
341931fc:	627b      	str	r3, [r7, #36]	@ 0x24
    pDest++;
341931fe:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34193200:	3301      	adds	r3, #1
34193202:	627b      	str	r3, [r7, #36]	@ 0x24
  for (i = 0U; i < count32b; i++)
34193204:	6a3b      	ldr	r3, [r7, #32]
34193206:	3301      	adds	r3, #1
34193208:	623b      	str	r3, [r7, #32]
3419320a:	6a3a      	ldr	r2, [r7, #32]
3419320c:	697b      	ldr	r3, [r7, #20]
3419320e:	429a      	cmp	r2, r3
34193210:	d3e6      	bcc.n	341931e0 <USB_ReadPacket+0x2c>
  }

  /* When Number of data is not word aligned, read the remaining byte */
  if (remaining_bytes != 0U)
34193212:	8bfb      	ldrh	r3, [r7, #30]
34193214:	2b00      	cmp	r3, #0
34193216:	d01e      	beq.n	34193256 <USB_ReadPacket+0xa2>
  {
    i = 0U;
34193218:	2300      	movs	r3, #0
3419321a:	623b      	str	r3, [r7, #32]
    __UNALIGNED_UINT32_WRITE(&pData, USBx_DFIFO(0U));
3419321c:	69bb      	ldr	r3, [r7, #24]
3419321e:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34193222:	461a      	mov	r2, r3
34193224:	f107 0310 	add.w	r3, r7, #16
34193228:	6812      	ldr	r2, [r2, #0]
3419322a:	601a      	str	r2, [r3, #0]

    do
    {
      *(uint8_t *)pDest = (uint8_t)(pData >> (8U * (uint8_t)(i)));
3419322c:	693a      	ldr	r2, [r7, #16]
3419322e:	6a3b      	ldr	r3, [r7, #32]
34193230:	b2db      	uxtb	r3, r3
34193232:	00db      	lsls	r3, r3, #3
34193234:	fa22 f303 	lsr.w	r3, r2, r3
34193238:	b2da      	uxtb	r2, r3
3419323a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419323c:	701a      	strb	r2, [r3, #0]
      i++;
3419323e:	6a3b      	ldr	r3, [r7, #32]
34193240:	3301      	adds	r3, #1
34193242:	623b      	str	r3, [r7, #32]
      pDest++;
34193244:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34193246:	3301      	adds	r3, #1
34193248:	627b      	str	r3, [r7, #36]	@ 0x24
      remaining_bytes--;
3419324a:	8bfb      	ldrh	r3, [r7, #30]
3419324c:	3b01      	subs	r3, #1
3419324e:	83fb      	strh	r3, [r7, #30]
    } while (remaining_bytes != 0U);
34193250:	8bfb      	ldrh	r3, [r7, #30]
34193252:	2b00      	cmp	r3, #0
34193254:	d1ea      	bne.n	3419322c <USB_ReadPacket+0x78>
  }

  return ((void *)pDest);
34193256:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
34193258:	4618      	mov	r0, r3
3419325a:	372c      	adds	r7, #44	@ 0x2c
3419325c:	46bd      	mov	sp, r7
3419325e:	f85d 7b04 	ldr.w	r7, [sp], #4
34193262:	4770      	bx	lr

34193264 <USB_EPSetStall>:
  * @param  USBx  Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPSetStall(const USB_OTG_GlobalTypeDef *USBx, const USB_OTG_EPTypeDef *ep)
{
34193264:	b480      	push	{r7}
34193266:	b085      	sub	sp, #20
34193268:	af00      	add	r7, sp, #0
3419326a:	6078      	str	r0, [r7, #4]
3419326c:	6039      	str	r1, [r7, #0]
  uint32_t USBx_BASE = (uint32_t)USBx;
3419326e:	687b      	ldr	r3, [r7, #4]
34193270:	60fb      	str	r3, [r7, #12]
  uint32_t epnum = (uint32_t)ep->num;
34193272:	683b      	ldr	r3, [r7, #0]
34193274:	781b      	ldrb	r3, [r3, #0]
34193276:	60bb      	str	r3, [r7, #8]

  if (ep->is_in == 1U)
34193278:	683b      	ldr	r3, [r7, #0]
3419327a:	785b      	ldrb	r3, [r3, #1]
3419327c:	2b01      	cmp	r3, #1
3419327e:	d12c      	bne.n	341932da <USB_EPSetStall+0x76>
  {
    if (((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == 0U) && (epnum != 0U))
34193280:	68bb      	ldr	r3, [r7, #8]
34193282:	015a      	lsls	r2, r3, #5
34193284:	68fb      	ldr	r3, [r7, #12]
34193286:	4413      	add	r3, r2
34193288:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
3419328c:	681b      	ldr	r3, [r3, #0]
3419328e:	2b00      	cmp	r3, #0
34193290:	db12      	blt.n	341932b8 <USB_EPSetStall+0x54>
34193292:	68bb      	ldr	r3, [r7, #8]
34193294:	2b00      	cmp	r3, #0
34193296:	d00f      	beq.n	341932b8 <USB_EPSetStall+0x54>
    {
      USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_EPDIS);
34193298:	68bb      	ldr	r3, [r7, #8]
3419329a:	015a      	lsls	r2, r3, #5
3419329c:	68fb      	ldr	r3, [r7, #12]
3419329e:	4413      	add	r3, r2
341932a0:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
341932a4:	681b      	ldr	r3, [r3, #0]
341932a6:	68ba      	ldr	r2, [r7, #8]
341932a8:	0151      	lsls	r1, r2, #5
341932aa:	68fa      	ldr	r2, [r7, #12]
341932ac:	440a      	add	r2, r1
341932ae:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
341932b2:	f023 4380 	bic.w	r3, r3, #1073741824	@ 0x40000000
341932b6:	6013      	str	r3, [r2, #0]
    }
    USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_STALL;
341932b8:	68bb      	ldr	r3, [r7, #8]
341932ba:	015a      	lsls	r2, r3, #5
341932bc:	68fb      	ldr	r3, [r7, #12]
341932be:	4413      	add	r3, r2
341932c0:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
341932c4:	681b      	ldr	r3, [r3, #0]
341932c6:	68ba      	ldr	r2, [r7, #8]
341932c8:	0151      	lsls	r1, r2, #5
341932ca:	68fa      	ldr	r2, [r7, #12]
341932cc:	440a      	add	r2, r1
341932ce:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
341932d2:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
341932d6:	6013      	str	r3, [r2, #0]
341932d8:	e02b      	b.n	34193332 <USB_EPSetStall+0xce>
  }
  else
  {
    if (((USBx_OUTEP(epnum)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == 0U) && (epnum != 0U))
341932da:	68bb      	ldr	r3, [r7, #8]
341932dc:	015a      	lsls	r2, r3, #5
341932de:	68fb      	ldr	r3, [r7, #12]
341932e0:	4413      	add	r3, r2
341932e2:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
341932e6:	681b      	ldr	r3, [r3, #0]
341932e8:	2b00      	cmp	r3, #0
341932ea:	db12      	blt.n	34193312 <USB_EPSetStall+0xae>
341932ec:	68bb      	ldr	r3, [r7, #8]
341932ee:	2b00      	cmp	r3, #0
341932f0:	d00f      	beq.n	34193312 <USB_EPSetStall+0xae>
    {
      USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_EPDIS);
341932f2:	68bb      	ldr	r3, [r7, #8]
341932f4:	015a      	lsls	r2, r3, #5
341932f6:	68fb      	ldr	r3, [r7, #12]
341932f8:	4413      	add	r3, r2
341932fa:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
341932fe:	681b      	ldr	r3, [r3, #0]
34193300:	68ba      	ldr	r2, [r7, #8]
34193302:	0151      	lsls	r1, r2, #5
34193304:	68fa      	ldr	r2, [r7, #12]
34193306:	440a      	add	r2, r1
34193308:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
3419330c:	f023 4380 	bic.w	r3, r3, #1073741824	@ 0x40000000
34193310:	6013      	str	r3, [r2, #0]
    }
    USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_STALL;
34193312:	68bb      	ldr	r3, [r7, #8]
34193314:	015a      	lsls	r2, r3, #5
34193316:	68fb      	ldr	r3, [r7, #12]
34193318:	4413      	add	r3, r2
3419331a:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
3419331e:	681b      	ldr	r3, [r3, #0]
34193320:	68ba      	ldr	r2, [r7, #8]
34193322:	0151      	lsls	r1, r2, #5
34193324:	68fa      	ldr	r2, [r7, #12]
34193326:	440a      	add	r2, r1
34193328:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
3419332c:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
34193330:	6013      	str	r3, [r2, #0]
  }

  return HAL_OK;
34193332:	2300      	movs	r3, #0
}
34193334:	4618      	mov	r0, r3
34193336:	3714      	adds	r7, #20
34193338:	46bd      	mov	sp, r7
3419333a:	f85d 7b04 	ldr.w	r7, [sp], #4
3419333e:	4770      	bx	lr

34193340 <USB_EPClearStall>:
  * @param  USBx  Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPClearStall(const USB_OTG_GlobalTypeDef *USBx, const USB_OTG_EPTypeDef *ep)
{
34193340:	b480      	push	{r7}
34193342:	b085      	sub	sp, #20
34193344:	af00      	add	r7, sp, #0
34193346:	6078      	str	r0, [r7, #4]
34193348:	6039      	str	r1, [r7, #0]
  uint32_t USBx_BASE = (uint32_t)USBx;
3419334a:	687b      	ldr	r3, [r7, #4]
3419334c:	60fb      	str	r3, [r7, #12]
  uint32_t epnum = (uint32_t)ep->num;
3419334e:	683b      	ldr	r3, [r7, #0]
34193350:	781b      	ldrb	r3, [r3, #0]
34193352:	60bb      	str	r3, [r7, #8]

  if (ep->is_in == 1U)
34193354:	683b      	ldr	r3, [r7, #0]
34193356:	785b      	ldrb	r3, [r3, #1]
34193358:	2b01      	cmp	r3, #1
3419335a:	d128      	bne.n	341933ae <USB_EPClearStall+0x6e>
  {
    USBx_INEP(epnum)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
3419335c:	68bb      	ldr	r3, [r7, #8]
3419335e:	015a      	lsls	r2, r3, #5
34193360:	68fb      	ldr	r3, [r7, #12]
34193362:	4413      	add	r3, r2
34193364:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
34193368:	681b      	ldr	r3, [r3, #0]
3419336a:	68ba      	ldr	r2, [r7, #8]
3419336c:	0151      	lsls	r1, r2, #5
3419336e:	68fa      	ldr	r2, [r7, #12]
34193370:	440a      	add	r2, r1
34193372:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
34193376:	f423 1300 	bic.w	r3, r3, #2097152	@ 0x200000
3419337a:	6013      	str	r3, [r2, #0]
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
3419337c:	683b      	ldr	r3, [r7, #0]
3419337e:	791b      	ldrb	r3, [r3, #4]
34193380:	2b03      	cmp	r3, #3
34193382:	d003      	beq.n	3419338c <USB_EPClearStall+0x4c>
34193384:	683b      	ldr	r3, [r7, #0]
34193386:	791b      	ldrb	r3, [r3, #4]
34193388:	2b02      	cmp	r3, #2
3419338a:	d138      	bne.n	341933fe <USB_EPClearStall+0xbe>
    {
      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM; /* DATA0 */
3419338c:	68bb      	ldr	r3, [r7, #8]
3419338e:	015a      	lsls	r2, r3, #5
34193390:	68fb      	ldr	r3, [r7, #12]
34193392:	4413      	add	r3, r2
34193394:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
34193398:	681b      	ldr	r3, [r3, #0]
3419339a:	68ba      	ldr	r2, [r7, #8]
3419339c:	0151      	lsls	r1, r2, #5
3419339e:	68fa      	ldr	r2, [r7, #12]
341933a0:	440a      	add	r2, r1
341933a2:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
341933a6:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
341933aa:	6013      	str	r3, [r2, #0]
341933ac:	e027      	b.n	341933fe <USB_EPClearStall+0xbe>
    }
  }
  else
  {
    USBx_OUTEP(epnum)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
341933ae:	68bb      	ldr	r3, [r7, #8]
341933b0:	015a      	lsls	r2, r3, #5
341933b2:	68fb      	ldr	r3, [r7, #12]
341933b4:	4413      	add	r3, r2
341933b6:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
341933ba:	681b      	ldr	r3, [r3, #0]
341933bc:	68ba      	ldr	r2, [r7, #8]
341933be:	0151      	lsls	r1, r2, #5
341933c0:	68fa      	ldr	r2, [r7, #12]
341933c2:	440a      	add	r2, r1
341933c4:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
341933c8:	f423 1300 	bic.w	r3, r3, #2097152	@ 0x200000
341933cc:	6013      	str	r3, [r2, #0]
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
341933ce:	683b      	ldr	r3, [r7, #0]
341933d0:	791b      	ldrb	r3, [r3, #4]
341933d2:	2b03      	cmp	r3, #3
341933d4:	d003      	beq.n	341933de <USB_EPClearStall+0x9e>
341933d6:	683b      	ldr	r3, [r7, #0]
341933d8:	791b      	ldrb	r3, [r3, #4]
341933da:	2b02      	cmp	r3, #2
341933dc:	d10f      	bne.n	341933fe <USB_EPClearStall+0xbe>
    {
      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM; /* DATA0 */
341933de:	68bb      	ldr	r3, [r7, #8]
341933e0:	015a      	lsls	r2, r3, #5
341933e2:	68fb      	ldr	r3, [r7, #12]
341933e4:	4413      	add	r3, r2
341933e6:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
341933ea:	681b      	ldr	r3, [r3, #0]
341933ec:	68ba      	ldr	r2, [r7, #8]
341933ee:	0151      	lsls	r1, r2, #5
341933f0:	68fa      	ldr	r2, [r7, #12]
341933f2:	440a      	add	r2, r1
341933f4:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
341933f8:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
341933fc:	6013      	str	r3, [r2, #0]
    }
  }
  return HAL_OK;
341933fe:	2300      	movs	r3, #0
}
34193400:	4618      	mov	r0, r3
34193402:	3714      	adds	r7, #20
34193404:	46bd      	mov	sp, r7
34193406:	f85d 7b04 	ldr.w	r7, [sp], #4
3419340a:	4770      	bx	lr

3419340c <USB_SetDevAddress>:
  * @param  address  new device address to be assigned
  *          This parameter can be a value from 0 to 255
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetDevAddress(const USB_OTG_GlobalTypeDef *USBx, uint8_t address)
{
3419340c:	b480      	push	{r7}
3419340e:	b085      	sub	sp, #20
34193410:	af00      	add	r7, sp, #0
34193412:	6078      	str	r0, [r7, #4]
34193414:	460b      	mov	r3, r1
34193416:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
34193418:	687b      	ldr	r3, [r7, #4]
3419341a:	60fb      	str	r3, [r7, #12]

  USBx_DEVICE->DCFG &= ~(USB_OTG_DCFG_DAD);
3419341c:	68fb      	ldr	r3, [r7, #12]
3419341e:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
34193422:	681b      	ldr	r3, [r3, #0]
34193424:	68fa      	ldr	r2, [r7, #12]
34193426:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
3419342a:	f423 63fe 	bic.w	r3, r3, #2032	@ 0x7f0
3419342e:	6013      	str	r3, [r2, #0]
  USBx_DEVICE->DCFG |= ((uint32_t)address << 4) & USB_OTG_DCFG_DAD;
34193430:	68fb      	ldr	r3, [r7, #12]
34193432:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
34193436:	681a      	ldr	r2, [r3, #0]
34193438:	78fb      	ldrb	r3, [r7, #3]
3419343a:	011b      	lsls	r3, r3, #4
3419343c:	f403 63fe 	and.w	r3, r3, #2032	@ 0x7f0
34193440:	68f9      	ldr	r1, [r7, #12]
34193442:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
34193446:	4313      	orrs	r3, r2
34193448:	600b      	str	r3, [r1, #0]

  return HAL_OK;
3419344a:	2300      	movs	r3, #0
}
3419344c:	4618      	mov	r0, r3
3419344e:	3714      	adds	r7, #20
34193450:	46bd      	mov	sp, r7
34193452:	f85d 7b04 	ldr.w	r7, [sp], #4
34193456:	4770      	bx	lr

34193458 <USB_DevConnect>:
  * @brief  USB_DevConnect : Connect the USB device by enabling Rpu
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevConnect(const USB_OTG_GlobalTypeDef *USBx)
{
34193458:	b480      	push	{r7}
3419345a:	b085      	sub	sp, #20
3419345c:	af00      	add	r7, sp, #0
3419345e:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
34193460:	687b      	ldr	r3, [r7, #4]
34193462:	60fb      	str	r3, [r7, #12]

  /* In case phy is stopped, ensure to ungate and restore the phy CLK */
  USBx_PCGCCTL &= ~(USB_OTG_PCGCCTL_STOPCLK | USB_OTG_PCGCCTL_GATECLK);
34193464:	68fb      	ldr	r3, [r7, #12]
34193466:	f503 6360 	add.w	r3, r3, #3584	@ 0xe00
3419346a:	681b      	ldr	r3, [r3, #0]
3419346c:	68fa      	ldr	r2, [r7, #12]
3419346e:	f502 6260 	add.w	r2, r2, #3584	@ 0xe00
34193472:	f023 0303 	bic.w	r3, r3, #3
34193476:	6013      	str	r3, [r2, #0]

  USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_SDIS;
34193478:	68fb      	ldr	r3, [r7, #12]
3419347a:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
3419347e:	685b      	ldr	r3, [r3, #4]
34193480:	68fa      	ldr	r2, [r7, #12]
34193482:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
34193486:	f023 0302 	bic.w	r3, r3, #2
3419348a:	6053      	str	r3, [r2, #4]

  return HAL_OK;
3419348c:	2300      	movs	r3, #0
}
3419348e:	4618      	mov	r0, r3
34193490:	3714      	adds	r7, #20
34193492:	46bd      	mov	sp, r7
34193494:	f85d 7b04 	ldr.w	r7, [sp], #4
34193498:	4770      	bx	lr

3419349a <USB_DevDisconnect>:
  * @brief  USB_DevDisconnect : Disconnect the USB device by disabling Rpu
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevDisconnect(const USB_OTG_GlobalTypeDef *USBx)
{
3419349a:	b480      	push	{r7}
3419349c:	b085      	sub	sp, #20
3419349e:	af00      	add	r7, sp, #0
341934a0:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
341934a2:	687b      	ldr	r3, [r7, #4]
341934a4:	60fb      	str	r3, [r7, #12]

  /* In case phy is stopped, ensure to ungate and restore the phy CLK */
  USBx_PCGCCTL &= ~(USB_OTG_PCGCCTL_STOPCLK | USB_OTG_PCGCCTL_GATECLK);
341934a6:	68fb      	ldr	r3, [r7, #12]
341934a8:	f503 6360 	add.w	r3, r3, #3584	@ 0xe00
341934ac:	681b      	ldr	r3, [r3, #0]
341934ae:	68fa      	ldr	r2, [r7, #12]
341934b0:	f502 6260 	add.w	r2, r2, #3584	@ 0xe00
341934b4:	f023 0303 	bic.w	r3, r3, #3
341934b8:	6013      	str	r3, [r2, #0]

  USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;
341934ba:	68fb      	ldr	r3, [r7, #12]
341934bc:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
341934c0:	685b      	ldr	r3, [r3, #4]
341934c2:	68fa      	ldr	r2, [r7, #12]
341934c4:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
341934c8:	f043 0302 	orr.w	r3, r3, #2
341934cc:	6053      	str	r3, [r2, #4]

  return HAL_OK;
341934ce:	2300      	movs	r3, #0
}
341934d0:	4618      	mov	r0, r3
341934d2:	3714      	adds	r7, #20
341934d4:	46bd      	mov	sp, r7
341934d6:	f85d 7b04 	ldr.w	r7, [sp], #4
341934da:	4770      	bx	lr

341934dc <USB_ReadInterrupts>:
  * @brief  USB_ReadInterrupts: return the global USB interrupt status
  * @param  USBx  Selected device
  * @retval USB Global Interrupt status
  */
uint32_t USB_ReadInterrupts(USB_OTG_GlobalTypeDef const *USBx)
{
341934dc:	b480      	push	{r7}
341934de:	b085      	sub	sp, #20
341934e0:	af00      	add	r7, sp, #0
341934e2:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg;

  tmpreg = USBx->GINTSTS;
341934e4:	687b      	ldr	r3, [r7, #4]
341934e6:	695b      	ldr	r3, [r3, #20]
341934e8:	60fb      	str	r3, [r7, #12]
  tmpreg &= USBx->GINTMSK;
341934ea:	687b      	ldr	r3, [r7, #4]
341934ec:	699b      	ldr	r3, [r3, #24]
341934ee:	68fa      	ldr	r2, [r7, #12]
341934f0:	4013      	ands	r3, r2
341934f2:	60fb      	str	r3, [r7, #12]

  return tmpreg;
341934f4:	68fb      	ldr	r3, [r7, #12]
}
341934f6:	4618      	mov	r0, r3
341934f8:	3714      	adds	r7, #20
341934fa:	46bd      	mov	sp, r7
341934fc:	f85d 7b04 	ldr.w	r7, [sp], #4
34193500:	4770      	bx	lr

34193502 <USB_ReadDevAllOutEpInterrupt>:
  * @brief  USB_ReadDevAllOutEpInterrupt: return the USB device OUT endpoints interrupt status
  * @param  USBx  Selected device
  * @retval USB Device OUT EP interrupt status
  */
uint32_t USB_ReadDevAllOutEpInterrupt(const USB_OTG_GlobalTypeDef *USBx)
{
34193502:	b480      	push	{r7}
34193504:	b085      	sub	sp, #20
34193506:	af00      	add	r7, sp, #0
34193508:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
3419350a:	687b      	ldr	r3, [r7, #4]
3419350c:	60fb      	str	r3, [r7, #12]
  uint32_t tmpreg;

  tmpreg  = USBx_DEVICE->DAINT;
3419350e:	68fb      	ldr	r3, [r7, #12]
34193510:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
34193514:	699b      	ldr	r3, [r3, #24]
34193516:	60bb      	str	r3, [r7, #8]
  tmpreg &= USBx_DEVICE->DAINTMSK;
34193518:	68fb      	ldr	r3, [r7, #12]
3419351a:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
3419351e:	69db      	ldr	r3, [r3, #28]
34193520:	68ba      	ldr	r2, [r7, #8]
34193522:	4013      	ands	r3, r2
34193524:	60bb      	str	r3, [r7, #8]

  return ((tmpreg & 0xffff0000U) >> 16);
34193526:	68bb      	ldr	r3, [r7, #8]
34193528:	0c1b      	lsrs	r3, r3, #16
}
3419352a:	4618      	mov	r0, r3
3419352c:	3714      	adds	r7, #20
3419352e:	46bd      	mov	sp, r7
34193530:	f85d 7b04 	ldr.w	r7, [sp], #4
34193534:	4770      	bx	lr

34193536 <USB_ReadDevAllInEpInterrupt>:
  * @brief  USB_ReadDevAllInEpInterrupt: return the USB device IN endpoints interrupt status
  * @param  USBx  Selected device
  * @retval USB Device IN EP interrupt status
  */
uint32_t USB_ReadDevAllInEpInterrupt(const USB_OTG_GlobalTypeDef *USBx)
{
34193536:	b480      	push	{r7}
34193538:	b085      	sub	sp, #20
3419353a:	af00      	add	r7, sp, #0
3419353c:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
3419353e:	687b      	ldr	r3, [r7, #4]
34193540:	60fb      	str	r3, [r7, #12]
  uint32_t tmpreg;

  tmpreg  = USBx_DEVICE->DAINT;
34193542:	68fb      	ldr	r3, [r7, #12]
34193544:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
34193548:	699b      	ldr	r3, [r3, #24]
3419354a:	60bb      	str	r3, [r7, #8]
  tmpreg &= USBx_DEVICE->DAINTMSK;
3419354c:	68fb      	ldr	r3, [r7, #12]
3419354e:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
34193552:	69db      	ldr	r3, [r3, #28]
34193554:	68ba      	ldr	r2, [r7, #8]
34193556:	4013      	ands	r3, r2
34193558:	60bb      	str	r3, [r7, #8]

  return ((tmpreg & 0xFFFFU));
3419355a:	68bb      	ldr	r3, [r7, #8]
3419355c:	b29b      	uxth	r3, r3
}
3419355e:	4618      	mov	r0, r3
34193560:	3714      	adds	r7, #20
34193562:	46bd      	mov	sp, r7
34193564:	f85d 7b04 	ldr.w	r7, [sp], #4
34193568:	4770      	bx	lr

3419356a <USB_ReadDevOutEPInterrupt>:
  * @param  epnum  endpoint number
  *          This parameter can be a value from 0 to 15
  * @retval Device OUT EP Interrupt register
  */
uint32_t USB_ReadDevOutEPInterrupt(const USB_OTG_GlobalTypeDef *USBx, uint8_t epnum)
{
3419356a:	b480      	push	{r7}
3419356c:	b085      	sub	sp, #20
3419356e:	af00      	add	r7, sp, #0
34193570:	6078      	str	r0, [r7, #4]
34193572:	460b      	mov	r3, r1
34193574:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
34193576:	687b      	ldr	r3, [r7, #4]
34193578:	60fb      	str	r3, [r7, #12]
  uint32_t tmpreg;

  tmpreg  = USBx_OUTEP((uint32_t)epnum)->DOEPINT;
3419357a:	78fb      	ldrb	r3, [r7, #3]
3419357c:	015a      	lsls	r2, r3, #5
3419357e:	68fb      	ldr	r3, [r7, #12]
34193580:	4413      	add	r3, r2
34193582:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
34193586:	689b      	ldr	r3, [r3, #8]
34193588:	60bb      	str	r3, [r7, #8]
  tmpreg &= USBx_DEVICE->DOEPMSK;
3419358a:	68fb      	ldr	r3, [r7, #12]
3419358c:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
34193590:	695b      	ldr	r3, [r3, #20]
34193592:	68ba      	ldr	r2, [r7, #8]
34193594:	4013      	ands	r3, r2
34193596:	60bb      	str	r3, [r7, #8]

  return tmpreg;
34193598:	68bb      	ldr	r3, [r7, #8]
}
3419359a:	4618      	mov	r0, r3
3419359c:	3714      	adds	r7, #20
3419359e:	46bd      	mov	sp, r7
341935a0:	f85d 7b04 	ldr.w	r7, [sp], #4
341935a4:	4770      	bx	lr

341935a6 <USB_ReadDevInEPInterrupt>:
  * @param  epnum  endpoint number
  *          This parameter can be a value from 0 to 15
  * @retval Device IN EP Interrupt register
  */
uint32_t USB_ReadDevInEPInterrupt(const USB_OTG_GlobalTypeDef *USBx, uint8_t epnum)
{
341935a6:	b480      	push	{r7}
341935a8:	b087      	sub	sp, #28
341935aa:	af00      	add	r7, sp, #0
341935ac:	6078      	str	r0, [r7, #4]
341935ae:	460b      	mov	r3, r1
341935b0:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
341935b2:	687b      	ldr	r3, [r7, #4]
341935b4:	617b      	str	r3, [r7, #20]
  uint32_t tmpreg;
  uint32_t msk;
  uint32_t emp;

  msk = USBx_DEVICE->DIEPMSK;
341935b6:	697b      	ldr	r3, [r7, #20]
341935b8:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
341935bc:	691b      	ldr	r3, [r3, #16]
341935be:	613b      	str	r3, [r7, #16]
  emp = USBx_DEVICE->DIEPEMPMSK;
341935c0:	697b      	ldr	r3, [r7, #20]
341935c2:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
341935c6:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
341935c8:	60fb      	str	r3, [r7, #12]
  msk |= ((emp >> (epnum & EP_ADDR_MSK)) & 0x1U) << 7;
341935ca:	78fb      	ldrb	r3, [r7, #3]
341935cc:	f003 030f 	and.w	r3, r3, #15
341935d0:	68fa      	ldr	r2, [r7, #12]
341935d2:	fa22 f303 	lsr.w	r3, r2, r3
341935d6:	01db      	lsls	r3, r3, #7
341935d8:	b2db      	uxtb	r3, r3
341935da:	693a      	ldr	r2, [r7, #16]
341935dc:	4313      	orrs	r3, r2
341935de:	613b      	str	r3, [r7, #16]
  tmpreg = USBx_INEP((uint32_t)epnum)->DIEPINT & msk;
341935e0:	78fb      	ldrb	r3, [r7, #3]
341935e2:	015a      	lsls	r2, r3, #5
341935e4:	697b      	ldr	r3, [r7, #20]
341935e6:	4413      	add	r3, r2
341935e8:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
341935ec:	689b      	ldr	r3, [r3, #8]
341935ee:	693a      	ldr	r2, [r7, #16]
341935f0:	4013      	ands	r3, r2
341935f2:	60bb      	str	r3, [r7, #8]

  return tmpreg;
341935f4:	68bb      	ldr	r3, [r7, #8]
}
341935f6:	4618      	mov	r0, r3
341935f8:	371c      	adds	r7, #28
341935fa:	46bd      	mov	sp, r7
341935fc:	f85d 7b04 	ldr.w	r7, [sp], #4
34193600:	4770      	bx	lr

34193602 <USB_GetMode>:
  *          This parameter can be one of these values:
  *           0 : Host
  *           1 : Device
  */
uint32_t USB_GetMode(const USB_OTG_GlobalTypeDef *USBx)
{
34193602:	b480      	push	{r7}
34193604:	b083      	sub	sp, #12
34193606:	af00      	add	r7, sp, #0
34193608:	6078      	str	r0, [r7, #4]
  return ((USBx->GINTSTS) & 0x1U);
3419360a:	687b      	ldr	r3, [r7, #4]
3419360c:	695b      	ldr	r3, [r3, #20]
3419360e:	f003 0301 	and.w	r3, r3, #1
}
34193612:	4618      	mov	r0, r3
34193614:	370c      	adds	r7, #12
34193616:	46bd      	mov	sp, r7
34193618:	f85d 7b04 	ldr.w	r7, [sp], #4
3419361c:	4770      	bx	lr

3419361e <USB_ActivateSetup>:
  * @brief  Activate EP0 for Setup transactions
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_ActivateSetup(const USB_OTG_GlobalTypeDef *USBx)
{
3419361e:	b480      	push	{r7}
34193620:	b085      	sub	sp, #20
34193622:	af00      	add	r7, sp, #0
34193624:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
34193626:	687b      	ldr	r3, [r7, #4]
34193628:	60fb      	str	r3, [r7, #12]

  /* Set the MPS of the IN EP0 to 64 bytes */
  USBx_INEP(0U)->DIEPCTL &= ~USB_OTG_DIEPCTL_MPSIZ;
3419362a:	68fb      	ldr	r3, [r7, #12]
3419362c:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
34193630:	681b      	ldr	r3, [r3, #0]
34193632:	68fa      	ldr	r2, [r7, #12]
34193634:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
34193638:	f423 63ff 	bic.w	r3, r3, #2040	@ 0x7f8
3419363c:	f023 0307 	bic.w	r3, r3, #7
34193640:	6013      	str	r3, [r2, #0]

  USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGINAK;
34193642:	68fb      	ldr	r3, [r7, #12]
34193644:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
34193648:	685b      	ldr	r3, [r3, #4]
3419364a:	68fa      	ldr	r2, [r7, #12]
3419364c:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
34193650:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
34193654:	6053      	str	r3, [r2, #4]

  return HAL_OK;
34193656:	2300      	movs	r3, #0
}
34193658:	4618      	mov	r0, r3
3419365a:	3714      	adds	r7, #20
3419365c:	46bd      	mov	sp, r7
3419365e:	f85d 7b04 	ldr.w	r7, [sp], #4
34193662:	4770      	bx	lr

34193664 <USB_EP0_OutStart>:
  *           1 : DMA feature used
  * @param  psetup  pointer to setup packet
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EP0_OutStart(const USB_OTG_GlobalTypeDef *USBx, uint8_t dma, const uint8_t *psetup)
{
34193664:	b480      	push	{r7}
34193666:	b087      	sub	sp, #28
34193668:	af00      	add	r7, sp, #0
3419366a:	60f8      	str	r0, [r7, #12]
3419366c:	460b      	mov	r3, r1
3419366e:	607a      	str	r2, [r7, #4]
34193670:	72fb      	strb	r3, [r7, #11]
  uint32_t USBx_BASE = (uint32_t)USBx;
34193672:	68fb      	ldr	r3, [r7, #12]
34193674:	617b      	str	r3, [r7, #20]
  uint32_t gSNPSiD = *(__IO const uint32_t *)(&USBx->CID + 0x1U);
34193676:	68fb      	ldr	r3, [r7, #12]
34193678:	333c      	adds	r3, #60	@ 0x3c
3419367a:	3304      	adds	r3, #4
3419367c:	681b      	ldr	r3, [r3, #0]
3419367e:	613b      	str	r3, [r7, #16]

  if (gSNPSiD > USB_OTG_CORE_ID_300A)
34193680:	693b      	ldr	r3, [r7, #16]
34193682:	4a26      	ldr	r2, [pc, #152]	@ (3419371c <USB_EP0_OutStart+0xb8>)
34193684:	4293      	cmp	r3, r2
34193686:	d90a      	bls.n	3419369e <USB_EP0_OutStart+0x3a>
  {
    if ((USBx_OUTEP(0U)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
34193688:	697b      	ldr	r3, [r7, #20]
3419368a:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
3419368e:	681b      	ldr	r3, [r3, #0]
34193690:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
34193694:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
34193698:	d101      	bne.n	3419369e <USB_EP0_OutStart+0x3a>
    {
      return HAL_OK;
3419369a:	2300      	movs	r3, #0
3419369c:	e037      	b.n	3419370e <USB_EP0_OutStart+0xaa>
    }
  }

  USBx_OUTEP(0U)->DOEPTSIZ = 0U;
3419369e:	697b      	ldr	r3, [r7, #20]
341936a0:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
341936a4:	461a      	mov	r2, r3
341936a6:	2300      	movs	r3, #0
341936a8:	6113      	str	r3, [r2, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
341936aa:	697b      	ldr	r3, [r7, #20]
341936ac:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
341936b0:	691b      	ldr	r3, [r3, #16]
341936b2:	697a      	ldr	r2, [r7, #20]
341936b4:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
341936b8:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
341936bc:	6113      	str	r3, [r2, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |= (3U * 8U);
341936be:	697b      	ldr	r3, [r7, #20]
341936c0:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
341936c4:	691b      	ldr	r3, [r3, #16]
341936c6:	697a      	ldr	r2, [r7, #20]
341936c8:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
341936cc:	f043 0318 	orr.w	r3, r3, #24
341936d0:	6113      	str	r3, [r2, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;
341936d2:	697b      	ldr	r3, [r7, #20]
341936d4:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
341936d8:	691b      	ldr	r3, [r3, #16]
341936da:	697a      	ldr	r2, [r7, #20]
341936dc:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
341936e0:	f043 43c0 	orr.w	r3, r3, #1610612736	@ 0x60000000
341936e4:	6113      	str	r3, [r2, #16]

  if (dma == 1U)
341936e6:	7afb      	ldrb	r3, [r7, #11]
341936e8:	2b01      	cmp	r3, #1
341936ea:	d10f      	bne.n	3419370c <USB_EP0_OutStart+0xa8>
  {
    USBx_OUTEP(0U)->DOEPDMA = (uint32_t)psetup;
341936ec:	697b      	ldr	r3, [r7, #20]
341936ee:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
341936f2:	461a      	mov	r2, r3
341936f4:	687b      	ldr	r3, [r7, #4]
341936f6:	6153      	str	r3, [r2, #20]
    /* EP enable */
    USBx_OUTEP(0U)->DOEPCTL |= USB_OTG_DOEPCTL_EPENA | USB_OTG_DOEPCTL_USBAEP;
341936f8:	697b      	ldr	r3, [r7, #20]
341936fa:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
341936fe:	681b      	ldr	r3, [r3, #0]
34193700:	697a      	ldr	r2, [r7, #20]
34193702:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
34193706:	f043 2380 	orr.w	r3, r3, #2147516416	@ 0x80008000
3419370a:	6013      	str	r3, [r2, #0]
  }

  return HAL_OK;
3419370c:	2300      	movs	r3, #0
}
3419370e:	4618      	mov	r0, r3
34193710:	371c      	adds	r7, #28
34193712:	46bd      	mov	sp, r7
34193714:	f85d 7b04 	ldr.w	r7, [sp], #4
34193718:	4770      	bx	lr
3419371a:	bf00      	nop
3419371c:	4f54300a 	.word	0x4f54300a

34193720 <USB_CoreReset>:
  * @brief  Reset the USB Core (needed after USB clock settings change)
  * @param  USBx  Selected device
  * @retval HAL status
  */
static HAL_StatusTypeDef USB_CoreReset(USB_OTG_GlobalTypeDef *USBx)
{
34193720:	b480      	push	{r7}
34193722:	b085      	sub	sp, #20
34193724:	af00      	add	r7, sp, #0
34193726:	6078      	str	r0, [r7, #4]
  __IO uint32_t count = 0U;
34193728:	2300      	movs	r3, #0
3419372a:	60fb      	str	r3, [r7, #12]

  /* Wait for AHB master IDLE state. */
  do
  {
    count++;
3419372c:	68fb      	ldr	r3, [r7, #12]
3419372e:	3301      	adds	r3, #1
34193730:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
34193732:	68fb      	ldr	r3, [r7, #12]
34193734:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
34193738:	d901      	bls.n	3419373e <USB_CoreReset+0x1e>
    {
      return HAL_TIMEOUT;
3419373a:	2303      	movs	r3, #3
3419373c:	e01b      	b.n	34193776 <USB_CoreReset+0x56>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
3419373e:	687b      	ldr	r3, [r7, #4]
34193740:	691b      	ldr	r3, [r3, #16]
34193742:	2b00      	cmp	r3, #0
34193744:	daf2      	bge.n	3419372c <USB_CoreReset+0xc>

  /* Core Soft Reset */
  count = 0U;
34193746:	2300      	movs	r3, #0
34193748:	60fb      	str	r3, [r7, #12]
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
3419374a:	687b      	ldr	r3, [r7, #4]
3419374c:	691b      	ldr	r3, [r3, #16]
3419374e:	f043 0201 	orr.w	r2, r3, #1
34193752:	687b      	ldr	r3, [r7, #4]
34193754:	611a      	str	r2, [r3, #16]

  do
  {
    count++;
34193756:	68fb      	ldr	r3, [r7, #12]
34193758:	3301      	adds	r3, #1
3419375a:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
3419375c:	68fb      	ldr	r3, [r7, #12]
3419375e:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
34193762:	d901      	bls.n	34193768 <USB_CoreReset+0x48>
    {
      return HAL_TIMEOUT;
34193764:	2303      	movs	r3, #3
34193766:	e006      	b.n	34193776 <USB_CoreReset+0x56>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
34193768:	687b      	ldr	r3, [r7, #4]
3419376a:	691b      	ldr	r3, [r3, #16]
3419376c:	f003 0301 	and.w	r3, r3, #1
34193770:	2b01      	cmp	r3, #1
34193772:	d0f0      	beq.n	34193756 <USB_CoreReset+0x36>

  return HAL_OK;
34193774:	2300      	movs	r3, #0
}
34193776:	4618      	mov	r0, r3
34193778:	3714      	adds	r7, #20
3419377a:	46bd      	mov	sp, r7
3419377c:	f85d 7b04 	ldr.w	r7, [sp], #4
34193780:	4770      	bx	lr
	...

34193784 <__NVIC_EnableIRQ>:
{
34193784:	b480      	push	{r7}
34193786:	b083      	sub	sp, #12
34193788:	af00      	add	r7, sp, #0
3419378a:	4603      	mov	r3, r0
3419378c:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
3419378e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
34193792:	2b00      	cmp	r3, #0
34193794:	db0b      	blt.n	341937ae <__NVIC_EnableIRQ+0x2a>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
34193796:	88fb      	ldrh	r3, [r7, #6]
34193798:	f003 021f 	and.w	r2, r3, #31
3419379c:	4907      	ldr	r1, [pc, #28]	@ (341937bc <__NVIC_EnableIRQ+0x38>)
3419379e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
341937a2:	095b      	lsrs	r3, r3, #5
341937a4:	2001      	movs	r0, #1
341937a6:	fa00 f202 	lsl.w	r2, r0, r2
341937aa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
341937ae:	bf00      	nop
341937b0:	370c      	adds	r7, #12
341937b2:	46bd      	mov	sp, r7
341937b4:	f85d 7b04 	ldr.w	r7, [sp], #4
341937b8:	4770      	bx	lr
341937ba:	bf00      	nop
341937bc:	e000e100 	.word	0xe000e100

341937c0 <__NVIC_SetPriority>:
{
341937c0:	b480      	push	{r7}
341937c2:	b083      	sub	sp, #12
341937c4:	af00      	add	r7, sp, #0
341937c6:	4603      	mov	r3, r0
341937c8:	6039      	str	r1, [r7, #0]
341937ca:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
341937cc:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
341937d0:	2b00      	cmp	r3, #0
341937d2:	db0a      	blt.n	341937ea <__NVIC_SetPriority+0x2a>
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
341937d4:	683b      	ldr	r3, [r7, #0]
341937d6:	b2da      	uxtb	r2, r3
341937d8:	490c      	ldr	r1, [pc, #48]	@ (3419380c <__NVIC_SetPriority+0x4c>)
341937da:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
341937de:	0112      	lsls	r2, r2, #4
341937e0:	b2d2      	uxtb	r2, r2
341937e2:	440b      	add	r3, r1
341937e4:	f883 2300 	strb.w	r2, [r3, #768]	@ 0x300
}
341937e8:	e00a      	b.n	34193800 <__NVIC_SetPriority+0x40>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
341937ea:	683b      	ldr	r3, [r7, #0]
341937ec:	b2da      	uxtb	r2, r3
341937ee:	4908      	ldr	r1, [pc, #32]	@ (34193810 <__NVIC_SetPriority+0x50>)
341937f0:	88fb      	ldrh	r3, [r7, #6]
341937f2:	f003 030f 	and.w	r3, r3, #15
341937f6:	3b04      	subs	r3, #4
341937f8:	0112      	lsls	r2, r2, #4
341937fa:	b2d2      	uxtb	r2, r2
341937fc:	440b      	add	r3, r1
341937fe:	761a      	strb	r2, [r3, #24]
}
34193800:	bf00      	nop
34193802:	370c      	adds	r7, #12
34193804:	46bd      	mov	sp, r7
34193806:	f85d 7b04 	ldr.w	r7, [sp], #4
3419380a:	4770      	bx	lr
3419380c:	e000e100 	.word	0xe000e100
34193810:	e000ed00 	.word	0xe000ed00

34193814 <LL_UCPD_Enable>:
{
34193814:	b480      	push	{r7}
34193816:	b083      	sub	sp, #12
34193818:	af00      	add	r7, sp, #0
3419381a:	6078      	str	r0, [r7, #4]
  SET_BIT(UCPDx->CFG1, UCPD_CFG1_UCPDEN);
3419381c:	687b      	ldr	r3, [r7, #4]
3419381e:	681b      	ldr	r3, [r3, #0]
34193820:	f043 4200 	orr.w	r2, r3, #2147483648	@ 0x80000000
34193824:	687b      	ldr	r3, [r7, #4]
34193826:	601a      	str	r2, [r3, #0]
}
34193828:	bf00      	nop
3419382a:	370c      	adds	r7, #12
3419382c:	46bd      	mov	sp, r7
3419382e:	f85d 7b04 	ldr.w	r7, [sp], #4
34193832:	4770      	bx	lr

34193834 <LL_UCPD_SetRxOrderSet>:
  *         @arg @ref LL_UCPD_ORDERSET_SOP_EXT1
  *         @arg @ref LL_UCPD_ORDERSET_SOP_EXT2
  * @retval None
  */
__STATIC_INLINE void LL_UCPD_SetRxOrderSet(UCPD_TypeDef *UCPDx, uint32_t OrderSet)
{
34193834:	b480      	push	{r7}
34193836:	b083      	sub	sp, #12
34193838:	af00      	add	r7, sp, #0
3419383a:	6078      	str	r0, [r7, #4]
3419383c:	6039      	str	r1, [r7, #0]
  MODIFY_REG(UCPDx->CFG1, UCPD_CFG1_RXORDSETEN, OrderSet);
3419383e:	687b      	ldr	r3, [r7, #4]
34193840:	681b      	ldr	r3, [r3, #0]
34193842:	f023 53ff 	bic.w	r3, r3, #534773760	@ 0x1fe00000
34193846:	f423 1380 	bic.w	r3, r3, #1048576	@ 0x100000
3419384a:	683a      	ldr	r2, [r7, #0]
3419384c:	431a      	orrs	r2, r3
3419384e:	687b      	ldr	r3, [r7, #4]
34193850:	601a      	str	r2, [r3, #0]
}
34193852:	bf00      	nop
34193854:	370c      	adds	r7, #12
34193856:	46bd      	mov	sp, r7
34193858:	f85d 7b04 	ldr.w	r7, [sp], #4
3419385c:	4770      	bx	lr

3419385e <LL_UCPD_SetccEnable>:
  *         @arg @ref LL_UCPD_CCENABLE_CC2
  *         @arg @ref LL_UCPD_CCENABLE_CC1CC2
  * @retval None
  */
__STATIC_INLINE void LL_UCPD_SetccEnable(UCPD_TypeDef *UCPDx, uint32_t CCEnable)
{
3419385e:	b480      	push	{r7}
34193860:	b083      	sub	sp, #12
34193862:	af00      	add	r7, sp, #0
34193864:	6078      	str	r0, [r7, #4]
34193866:	6039      	str	r1, [r7, #0]
  MODIFY_REG(UCPDx->CR, UCPD_CR_CCENABLE, CCEnable);
34193868:	687b      	ldr	r3, [r7, #4]
3419386a:	68db      	ldr	r3, [r3, #12]
3419386c:	f423 6240 	bic.w	r2, r3, #3072	@ 0xc00
34193870:	683b      	ldr	r3, [r7, #0]
34193872:	431a      	orrs	r2, r3
34193874:	687b      	ldr	r3, [r7, #4]
34193876:	60da      	str	r2, [r3, #12]
}
34193878:	bf00      	nop
3419387a:	370c      	adds	r7, #12
3419387c:	46bd      	mov	sp, r7
3419387e:	f85d 7b04 	ldr.w	r7, [sp], #4
34193882:	4770      	bx	lr

34193884 <LL_UCPD_EnableIT_TypeCEventCC2>:
  * @rmtoll IMR          TYPECEVT2IE        LL_UCPD_EnableIT_TypeCEventCC2
  * @param  UCPDx UCPD Instance
  * @retval None
  */
__STATIC_INLINE void LL_UCPD_EnableIT_TypeCEventCC2(UCPD_TypeDef *UCPDx)
{
34193884:	b480      	push	{r7}
34193886:	b083      	sub	sp, #12
34193888:	af00      	add	r7, sp, #0
3419388a:	6078      	str	r0, [r7, #4]
  SET_BIT(UCPDx->IMR, UCPD_IMR_TYPECEVT2IE);
3419388c:	687b      	ldr	r3, [r7, #4]
3419388e:	691b      	ldr	r3, [r3, #16]
34193890:	f443 4200 	orr.w	r2, r3, #32768	@ 0x8000
34193894:	687b      	ldr	r3, [r7, #4]
34193896:	611a      	str	r2, [r3, #16]
}
34193898:	bf00      	nop
3419389a:	370c      	adds	r7, #12
3419389c:	46bd      	mov	sp, r7
3419389e:	f85d 7b04 	ldr.w	r7, [sp], #4
341938a2:	4770      	bx	lr

341938a4 <LL_UCPD_EnableIT_TypeCEventCC1>:
  * @rmtoll IMR          TYPECEVT1IE        LL_UCPD_EnableIT_TypeCEventCC1
  * @param  UCPDx UCPD Instance
  * @retval None
  */
__STATIC_INLINE void LL_UCPD_EnableIT_TypeCEventCC1(UCPD_TypeDef *UCPDx)
{
341938a4:	b480      	push	{r7}
341938a6:	b083      	sub	sp, #12
341938a8:	af00      	add	r7, sp, #0
341938aa:	6078      	str	r0, [r7, #4]
  SET_BIT(UCPDx->IMR, UCPD_IMR_TYPECEVT1IE);
341938ac:	687b      	ldr	r3, [r7, #4]
341938ae:	691b      	ldr	r3, [r3, #16]
341938b0:	f443 4280 	orr.w	r2, r3, #16384	@ 0x4000
341938b4:	687b      	ldr	r3, [r7, #4]
341938b6:	611a      	str	r2, [r3, #16]
}
341938b8:	bf00      	nop
341938ba:	370c      	adds	r7, #12
341938bc:	46bd      	mov	sp, r7
341938be:	f85d 7b04 	ldr.w	r7, [sp], #4
341938c2:	4770      	bx	lr

341938c4 <CAD_Init>:
  * @param  pParams       Pointer on PD parameters based on @ref USBPD_ParamsTypeDef
  * @param  WakeUp        Wake-up callback function used for waking up CAD
  * @retval None
  */
void CAD_Init(uint8_t PortNum, USBPD_SettingsTypeDef *pSettings, USBPD_ParamsTypeDef *pParams,  void (*WakeUp)(void))
{
341938c4:	b590      	push	{r4, r7, lr}
341938c6:	b08b      	sub	sp, #44	@ 0x2c
341938c8:	af00      	add	r7, sp, #0
341938ca:	60b9      	str	r1, [r7, #8]
341938cc:	607a      	str	r2, [r7, #4]
341938ce:	603b      	str	r3, [r7, #0]
341938d0:	4603      	mov	r3, r0
341938d2:	73fb      	strb	r3, [r7, #15]
  CAD_HW_HandleTypeDef *_handle = &CAD_HW_Handles[PortNum];
341938d4:	7bfa      	ldrb	r2, [r7, #15]
341938d6:	4613      	mov	r3, r2
341938d8:	005b      	lsls	r3, r3, #1
341938da:	4413      	add	r3, r2
341938dc:	009b      	lsls	r3, r3, #2
341938de:	4a55      	ldr	r2, [pc, #340]	@ (34193a34 <CAD_Init+0x170>)
341938e0:	4413      	add	r3, r2
341938e2:	627b      	str	r3, [r7, #36]	@ 0x24
  LL_UCPD_InitTypeDef settings;

  Ports[PortNum].params = pParams;
341938e4:	7bfa      	ldrb	r2, [r7, #15]
341938e6:	4954      	ldr	r1, [pc, #336]	@ (34193a38 <CAD_Init+0x174>)
341938e8:	4613      	mov	r3, r2
341938ea:	00db      	lsls	r3, r3, #3
341938ec:	1a9b      	subs	r3, r3, r2
341938ee:	00db      	lsls	r3, r3, #3
341938f0:	440b      	add	r3, r1
341938f2:	3310      	adds	r3, #16
341938f4:	687a      	ldr	r2, [r7, #4]
341938f6:	601a      	str	r2, [r3, #0]
  Ports[PortNum].settings = pSettings;
341938f8:	7bfa      	ldrb	r2, [r7, #15]
341938fa:	494f      	ldr	r1, [pc, #316]	@ (34193a38 <CAD_Init+0x174>)
341938fc:	4613      	mov	r3, r2
341938fe:	00db      	lsls	r3, r3, #3
34193900:	1a9b      	subs	r3, r3, r2
34193902:	00db      	lsls	r3, r3, #3
34193904:	440b      	add	r3, r1
34193906:	330c      	adds	r3, #12
34193908:	68ba      	ldr	r2, [r7, #8]
3419390a:	601a      	str	r2, [r3, #0]
  Ports[PortNum].params->RpResistor = Ports[PortNum].settings->CAD_DefaultResistor;
3419390c:	7bfa      	ldrb	r2, [r7, #15]
3419390e:	494a      	ldr	r1, [pc, #296]	@ (34193a38 <CAD_Init+0x174>)
34193910:	4613      	mov	r3, r2
34193912:	00db      	lsls	r3, r3, #3
34193914:	1a9b      	subs	r3, r3, r2
34193916:	00db      	lsls	r3, r3, #3
34193918:	440b      	add	r3, r1
3419391a:	330c      	adds	r3, #12
3419391c:	6819      	ldr	r1, [r3, #0]
3419391e:	7bfa      	ldrb	r2, [r7, #15]
34193920:	4845      	ldr	r0, [pc, #276]	@ (34193a38 <CAD_Init+0x174>)
34193922:	4613      	mov	r3, r2
34193924:	00db      	lsls	r3, r3, #3
34193926:	1a9b      	subs	r3, r3, r2
34193928:	00db      	lsls	r3, r3, #3
3419392a:	4403      	add	r3, r0
3419392c:	3310      	adds	r3, #16
3419392e:	681a      	ldr	r2, [r3, #0]
34193930:	780b      	ldrb	r3, [r1, #0]
34193932:	f3c3 0341 	ubfx	r3, r3, #1, #2
34193936:	b2d9      	uxtb	r1, r3
34193938:	7893      	ldrb	r3, [r2, #2]
3419393a:	f361 0301 	bfi	r3, r1, #0, #2
3419393e:	7093      	strb	r3, [r2, #2]
  Ports[PortNum].params->SNKExposedRP_AtAttach = vRd_Undefined;
34193940:	7bfa      	ldrb	r2, [r7, #15]
34193942:	493d      	ldr	r1, [pc, #244]	@ (34193a38 <CAD_Init+0x174>)
34193944:	4613      	mov	r3, r2
34193946:	00db      	lsls	r3, r3, #3
34193948:	1a9b      	subs	r3, r3, r2
3419394a:	00db      	lsls	r3, r3, #3
3419394c:	440b      	add	r3, r1
3419394e:	3310      	adds	r3, #16
34193950:	681a      	ldr	r2, [r3, #0]
34193952:	7893      	ldrb	r3, [r2, #2]
34193954:	f023 030c 	bic.w	r3, r3, #12
34193958:	7093      	strb	r3, [r2, #2]

  /* Reset handle */
  memset(_handle, 0, sizeof(CAD_HW_HandleTypeDef));
3419395a:	220c      	movs	r2, #12
3419395c:	2100      	movs	r1, #0
3419395e:	6a78      	ldr	r0, [r7, #36]	@ 0x24
34193960:	f00a fbae 	bl	3419e0c0 <memset>

  /* Register CAD wake up callback */
  Ports[PortNum].USBPD_CAD_WakeUp = WakeUp;
34193964:	7bfa      	ldrb	r2, [r7, #15]
34193966:	4934      	ldr	r1, [pc, #208]	@ (34193a38 <CAD_Init+0x174>)
34193968:	4613      	mov	r3, r2
3419396a:	00db      	lsls	r3, r3, #3
3419396c:	1a9b      	subs	r3, r3, r2
3419396e:	00db      	lsls	r3, r3, #3
34193970:	440b      	add	r3, r1
34193972:	3328      	adds	r3, #40	@ 0x28
34193974:	683a      	ldr	r2, [r7, #0]
34193976:	601a      	str	r2, [r3, #0]

  /* Initialize the USBPD_IP */
  Ports[PortNum].husbpd = USBPD_HW_GetUSPDInstance(PortNum);
34193978:	7bfc      	ldrb	r4, [r7, #15]
3419397a:	7bfb      	ldrb	r3, [r7, #15]
3419397c:	4618      	mov	r0, r3
3419397e:	f000 fb15 	bl	34193fac <USBPD_HW_GetUSPDInstance>
34193982:	4602      	mov	r2, r0
34193984:	492c      	ldr	r1, [pc, #176]	@ (34193a38 <CAD_Init+0x174>)
34193986:	4623      	mov	r3, r4
34193988:	00db      	lsls	r3, r3, #3
3419398a:	1b1b      	subs	r3, r3, r4
3419398c:	00db      	lsls	r3, r3, #3
3419398e:	440b      	add	r3, r1
34193990:	601a      	str	r2, [r3, #0]

  /* Initialize UCPD */
  LL_UCPD_StructInit(&settings);
34193992:	f107 0314 	add.w	r3, r7, #20
34193996:	4618      	mov	r0, r3
34193998:	f7fe fbc6 	bl	34192128 <LL_UCPD_StructInit>
  (void)LL_UCPD_Init(Ports[PortNum].husbpd, &settings);
3419399c:	7bfa      	ldrb	r2, [r7, #15]
3419399e:	4926      	ldr	r1, [pc, #152]	@ (34193a38 <CAD_Init+0x174>)
341939a0:	4613      	mov	r3, r2
341939a2:	00db      	lsls	r3, r3, #3
341939a4:	1a9b      	subs	r3, r3, r2
341939a6:	00db      	lsls	r3, r3, #3
341939a8:	440b      	add	r3, r1
341939aa:	681b      	ldr	r3, [r3, #0]
341939ac:	f107 0214 	add.w	r2, r7, #20
341939b0:	4611      	mov	r1, r2
341939b2:	4618      	mov	r0, r3
341939b4:	f7fe fb8a 	bl	341920cc <LL_UCPD_Init>
  LL_UCPD_SetRxOrderSet(Ports[PortNum].husbpd,
341939b8:	7bfa      	ldrb	r2, [r7, #15]
341939ba:	491f      	ldr	r1, [pc, #124]	@ (34193a38 <CAD_Init+0x174>)
341939bc:	4613      	mov	r3, r2
341939be:	00db      	lsls	r3, r3, #3
341939c0:	1a9b      	subs	r3, r3, r2
341939c2:	00db      	lsls	r3, r3, #3
341939c4:	440b      	add	r3, r1
341939c6:	681b      	ldr	r3, [r3, #0]
341939c8:	f04f 71f8 	mov.w	r1, #32505856	@ 0x1f00000
341939cc:	4618      	mov	r0, r3
341939ce:	f7ff ff31 	bl	34193834 <LL_UCPD_SetRxOrderSet>
                        LL_UCPD_ORDERSET_SOP | LL_UCPD_ORDERSET_SOP1 | LL_UCPD_ORDERSET_SOP2 |
                        LL_UCPD_ORDERSET_CABLERST | LL_UCPD_ORDERSET_HARDRST);
  /* Controls whether pull-ups and pull-downs controls related to ANAMODE and ANASUBMODE
     should be applied to CC1 and CC2 analog PHYs */
  /* Should be done when UCPDEN is 1 */
  LL_UCPD_SetccEnable(Ports[PortNum].husbpd, LL_UCPD_CCENABLE_CC1CC2);
341939d2:	7bfa      	ldrb	r2, [r7, #15]
341939d4:	4918      	ldr	r1, [pc, #96]	@ (34193a38 <CAD_Init+0x174>)
341939d6:	4613      	mov	r3, r2
341939d8:	00db      	lsls	r3, r3, #3
341939da:	1a9b      	subs	r3, r3, r2
341939dc:	00db      	lsls	r3, r3, #3
341939de:	440b      	add	r3, r1
341939e0:	681b      	ldr	r3, [r3, #0]
341939e2:	f44f 6140 	mov.w	r1, #3072	@ 0xc00
341939e6:	4618      	mov	r0, r3
341939e8:	f7ff ff39 	bl	3419385e <LL_UCPD_SetccEnable>
#ifdef _LOW_POWER
  LL_UCPD_WakeUpEnable(Ports[PortNum].husbpd);
#endif /* _LOW_POWER */

  /* Init power */
  BSP_USBPD_PWR_Init(PortNum);
341939ec:	7bfb      	ldrb	r3, [r7, #15]
341939ee:	4618      	mov	r0, r3
341939f0:	f7f0 fd6a 	bl	341844c8 <BSP_USBPD_PWR_Init>

#if defined(TCPP0203_SUPPORT)
  /* Register VBUS detect callback */
  BSP_USBPD_PWR_RegisterVBUSDetectCallback(PortNum, CAD_HW_IF_VBUSDetectCallback);
341939f4:	7bfb      	ldrb	r3, [r7, #15]
341939f6:	4911      	ldr	r1, [pc, #68]	@ (34193a3c <CAD_Init+0x178>)
341939f8:	4618      	mov	r0, r3
341939fa:	f7f0 ffa9 	bl	34184950 <BSP_USBPD_PWR_RegisterVBUSDetectCallback>
#endif /* TCPP0203_SUPPORT */

  /* Enable USBPD IP */
  LL_UCPD_Enable(Ports[PortNum].husbpd);
341939fe:	7bfa      	ldrb	r2, [r7, #15]
34193a00:	490d      	ldr	r1, [pc, #52]	@ (34193a38 <CAD_Init+0x174>)
34193a02:	4613      	mov	r3, r2
34193a04:	00db      	lsls	r3, r3, #3
34193a06:	1a9b      	subs	r3, r3, r2
34193a08:	00db      	lsls	r3, r3, #3
34193a0a:	440b      	add	r3, r1
34193a0c:	681b      	ldr	r3, [r3, #0]
34193a0e:	4618      	mov	r0, r3
34193a10:	f7ff ff00 	bl	34193814 <LL_UCPD_Enable>
#if defined(_DRP)
  else
#endif /* _DRP */
#if defined(_SNK) || defined(_DRP)
  {
    USBPDM1_AssertRd(PortNum);
34193a14:	7bfb      	ldrb	r3, [r7, #15]
34193a16:	4618      	mov	r0, r3
34193a18:	f000 fed2 	bl	341947c0 <USBPDM1_AssertRd>
#if defined(TCPP0203_SUPPORT)
    /* Switch to Low Power mode */
    BSP_USBPD_PWR_SetPowerMode(PortNum, USBPD_PWR_MODE_LOWPOWER);
34193a1c:	7bfb      	ldrb	r3, [r7, #15]
34193a1e:	2102      	movs	r1, #2
34193a20:	4618      	mov	r0, r3
34193a22:	f7f0 fe2d 	bl	34184680 <BSP_USBPD_PWR_SetPowerMode>
  else
#endif /* _SRC */
  {
#if defined(_SNK)
    /* Set current state machine to SNK state machine */
    _handle->CAD_PtrStateMachine = CAD_StateMachine_SNK;
34193a26:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34193a28:	4a05      	ldr	r2, [pc, #20]	@ (34193a40 <CAD_Init+0x17c>)
34193a2a:	609a      	str	r2, [r3, #8]
    _handle->CAD_VPD_SNK = Ports[PortNum].settings->CAD_VPDSupport;
#endif /* USBPDCORE_VPD */
#endif /* _SNK */
  }
#endif  /* USBPDCORE_LIB_NO_PD */
}
34193a2c:	bf00      	nop
34193a2e:	372c      	adds	r7, #44	@ 0x2c
34193a30:	46bd      	mov	sp, r7
34193a32:	bd90      	pop	{r4, r7, pc}
34193a34:	341c2d6c 	.word	0x341c2d6c
34193a38:	341c2d7c 	.word	0x341c2d7c
34193a3c:	34193f19 	.word	0x34193f19
34193a40:	34193a91 	.word	0x34193a91

34193a44 <CAD_Enter_ErrorRecovery>:
  * @brief  Function to force CAD state machine into error recovery state
  * @param  PortNum Index of current used port
  * @retval None
  */
void CAD_Enter_ErrorRecovery(uint8_t PortNum)
{
34193a44:	b580      	push	{r7, lr}
34193a46:	b082      	sub	sp, #8
34193a48:	af00      	add	r7, sp, #0
34193a4a:	4603      	mov	r3, r0
34193a4c:	71fb      	strb	r3, [r7, #7]
  /* Remove the ucpd resistor */
  USBPDM1_EnterErrorRecovery(PortNum);
34193a4e:	79fb      	ldrb	r3, [r7, #7]
34193a50:	4618      	mov	r0, r3
34193a52:	f000 ff4b 	bl	341948ec <USBPDM1_EnterErrorRecovery>
  /* Set the error recovery flag to allow the stack to switch into errorRecovery Flag */
  CAD_HW_Handles[PortNum].CAD_ErrorRecoveryflag = USBPD_TRUE;
34193a56:	79fa      	ldrb	r2, [r7, #7]
34193a58:	490b      	ldr	r1, [pc, #44]	@ (34193a88 <CAD_Enter_ErrorRecovery+0x44>)
34193a5a:	4613      	mov	r3, r2
34193a5c:	005b      	lsls	r3, r3, #1
34193a5e:	4413      	add	r3, r2
34193a60:	009b      	lsls	r3, r3, #2
34193a62:	18ca      	adds	r2, r1, r3
34193a64:	7813      	ldrb	r3, [r2, #0]
34193a66:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
34193a6a:	7013      	strb	r3, [r2, #0]
  /* Wake up CAD task */
  Ports[PortNum].USBPD_CAD_WakeUp();
34193a6c:	79fa      	ldrb	r2, [r7, #7]
34193a6e:	4907      	ldr	r1, [pc, #28]	@ (34193a8c <CAD_Enter_ErrorRecovery+0x48>)
34193a70:	4613      	mov	r3, r2
34193a72:	00db      	lsls	r3, r3, #3
34193a74:	1a9b      	subs	r3, r3, r2
34193a76:	00db      	lsls	r3, r3, #3
34193a78:	440b      	add	r3, r1
34193a7a:	3328      	adds	r3, #40	@ 0x28
34193a7c:	681b      	ldr	r3, [r3, #0]
34193a7e:	4798      	blx	r3
}
34193a80:	bf00      	nop
34193a82:	3708      	adds	r7, #8
34193a84:	46bd      	mov	sp, r7
34193a86:	bd80      	pop	{r7, pc}
34193a88:	341c2d6c 	.word	0x341c2d6c
34193a8c:	341c2d7c 	.word	0x341c2d7c

34193a90 <CAD_StateMachine_SNK>:
  * @retval Timeout value
  */
#if defined(_SNK)
/* Function to handle SNK and SNK  + ACCESSORY OPTION */
uint32_t CAD_StateMachine_SNK(uint8_t PortNum, USBPD_CAD_EVENT *pEvent, CCxPin_TypeDef *pCCXX)
{
34193a90:	b580      	push	{r7, lr}
34193a92:	b086      	sub	sp, #24
34193a94:	af00      	add	r7, sp, #0
34193a96:	4603      	mov	r3, r0
34193a98:	60b9      	str	r1, [r7, #8]
34193a9a:	607a      	str	r2, [r7, #4]
34193a9c:	73fb      	strb	r3, [r7, #15]
  CAD_HW_HandleTypeDef *_handle = &CAD_HW_Handles[PortNum];
34193a9e:	7bfa      	ldrb	r2, [r7, #15]
34193aa0:	4613      	mov	r3, r2
34193aa2:	005b      	lsls	r3, r3, #1
34193aa4:	4413      	add	r3, r2
34193aa6:	009b      	lsls	r3, r3, #2
34193aa8:	4a17      	ldr	r2, [pc, #92]	@ (34193b08 <CAD_StateMachine_SNK+0x78>)
34193aaa:	4413      	add	r3, r2
34193aac:	613b      	str	r3, [r7, #16]
  uint32_t _timing = CAD_DEFAULT_TIME;
34193aae:	2302      	movs	r3, #2
34193ab0:	617b      	str	r3, [r7, #20]
#if defined(USBPDM1_VCC_FEATURE_ENABLED)
  BSP_USBPD_PWR_VCCSetState(PortNum, 1);
#endif /* USBPDM1_VCC_FEATURE_ENABLED */

  /* Check CAD STATE */
  switch (_handle->cstate)
34193ab2:	693b      	ldr	r3, [r7, #16]
34193ab4:	785b      	ldrb	r3, [r3, #1]
34193ab6:	f3c3 0344 	ubfx	r3, r3, #1, #5
34193aba:	b2db      	uxtb	r3, r3
34193abc:	2b03      	cmp	r3, #3
34193abe:	d014      	beq.n	34193aea <CAD_StateMachine_SNK+0x5a>
34193ac0:	2b03      	cmp	r3, #3
34193ac2:	dc1a      	bgt.n	34193afa <CAD_StateMachine_SNK+0x6a>
34193ac4:	2b01      	cmp	r3, #1
34193ac6:	d002      	beq.n	34193ace <CAD_StateMachine_SNK+0x3e>
34193ac8:	2b02      	cmp	r3, #2
34193aca:	d006      	beq.n	34193ada <CAD_StateMachine_SNK+0x4a>
#endif /* USBPDCORE_VPD */
#endif /* _ACCESSORY_SNK */

    default:
    {
      break;
34193acc:	e015      	b.n	34193afa <CAD_StateMachine_SNK+0x6a>
      _timing = ManageStateDetached_SNK(PortNum);
34193ace:	7bfb      	ldrb	r3, [r7, #15]
34193ad0:	4618      	mov	r0, r3
34193ad2:	f000 f8ef 	bl	34193cb4 <ManageStateDetached_SNK>
34193ad6:	6178      	str	r0, [r7, #20]
      break;
34193ad8:	e010      	b.n	34193afc <CAD_StateMachine_SNK+0x6c>
      _timing = ManageStateAttachedWait_SNK(PortNum, pEvent, pCCXX);
34193ada:	7bfb      	ldrb	r3, [r7, #15]
34193adc:	687a      	ldr	r2, [r7, #4]
34193ade:	68b9      	ldr	r1, [r7, #8]
34193ae0:	4618      	mov	r0, r3
34193ae2:	f000 f931 	bl	34193d48 <ManageStateAttachedWait_SNK>
34193ae6:	6178      	str	r0, [r7, #20]
      break;
34193ae8:	e008      	b.n	34193afc <CAD_StateMachine_SNK+0x6c>
      _timing = ManageStateAttached_SNK(PortNum, pEvent, pCCXX);
34193aea:	7bfb      	ldrb	r3, [r7, #15]
34193aec:	687a      	ldr	r2, [r7, #4]
34193aee:	68b9      	ldr	r1, [r7, #8]
34193af0:	4618      	mov	r0, r3
34193af2:	f000 f9ab 	bl	34193e4c <ManageStateAttached_SNK>
34193af6:	6178      	str	r0, [r7, #20]
      break;
34193af8:	e000      	b.n	34193afc <CAD_StateMachine_SNK+0x6c>
      break;
34193afa:	bf00      	nop
      BSP_USBPD_PWR_VCCSetState(PortNum, 0);
      break;
  }
#endif /* USBPDM1_VCC_FEATURE_ENABLED */

  return _timing;
34193afc:	697b      	ldr	r3, [r7, #20]
}
34193afe:	4618      	mov	r0, r3
34193b00:	3718      	adds	r7, #24
34193b02:	46bd      	mov	sp, r7
34193b04:	bd80      	pop	{r7, pc}
34193b06:	bf00      	nop
34193b08:	341c2d6c 	.word	0x341c2d6c

34193b0c <CAD_StateMachine>:
  * @param  pEvent  Pointer on CAD event based on @ref USBPD_CAD_EVENT
  * @param  pCCXX   Pointer on CC Pin based on @ref CCxPin_TypeDef
  * @retval Timeout value
  */
uint32_t CAD_StateMachine(uint8_t PortNum, USBPD_CAD_EVENT *pEvent, CCxPin_TypeDef *pCCXX)
{
34193b0c:	b580      	push	{r7, lr}
34193b0e:	b086      	sub	sp, #24
34193b10:	af00      	add	r7, sp, #0
34193b12:	4603      	mov	r3, r0
34193b14:	60b9      	str	r1, [r7, #8]
34193b16:	607a      	str	r2, [r7, #4]
34193b18:	73fb      	strb	r3, [r7, #15]
  CAD_HW_HandleTypeDef *_handle = &CAD_HW_Handles[PortNum];
34193b1a:	7bfa      	ldrb	r2, [r7, #15]
34193b1c:	4613      	mov	r3, r2
34193b1e:	005b      	lsls	r3, r3, #1
34193b20:	4413      	add	r3, r2
34193b22:	009b      	lsls	r3, r3, #2
34193b24:	4a1f      	ldr	r2, [pc, #124]	@ (34193ba4 <CAD_StateMachine+0x98>)
34193b26:	4413      	add	r3, r2
34193b28:	613b      	str	r3, [r7, #16]
  uint32_t _timing = CAD_DEFAULT_TIME;
34193b2a:	2302      	movs	r3, #2
34193b2c:	617b      	str	r3, [r7, #20]

  /* Set by default event to none */
  *pEvent = USBPD_CAD_EVENT_NONE;
34193b2e:	68bb      	ldr	r3, [r7, #8]
34193b30:	2200      	movs	r2, #0
34193b32:	701a      	strb	r2, [r3, #0]

  switch (_handle->cstate)
34193b34:	693b      	ldr	r3, [r7, #16]
34193b36:	785b      	ldrb	r3, [r3, #1]
34193b38:	f3c3 0344 	ubfx	r3, r3, #1, #5
34193b3c:	b2db      	uxtb	r3, r3
34193b3e:	2b00      	cmp	r3, #0
34193b40:	d123      	bne.n	34193b8a <CAD_StateMachine+0x7e>
  {
    case USBPD_CAD_STATE_RESET:
    {
#ifndef _LOW_POWER
      /* Enable TypeCEvents Interrupts */
      LL_UCPD_EnableIT_TypeCEventCC2(Ports[PortNum].husbpd);
34193b42:	7bfa      	ldrb	r2, [r7, #15]
34193b44:	4918      	ldr	r1, [pc, #96]	@ (34193ba8 <CAD_StateMachine+0x9c>)
34193b46:	4613      	mov	r3, r2
34193b48:	00db      	lsls	r3, r3, #3
34193b4a:	1a9b      	subs	r3, r3, r2
34193b4c:	00db      	lsls	r3, r3, #3
34193b4e:	440b      	add	r3, r1
34193b50:	681b      	ldr	r3, [r3, #0]
34193b52:	4618      	mov	r0, r3
34193b54:	f7ff fe96 	bl	34193884 <LL_UCPD_EnableIT_TypeCEventCC2>
      LL_UCPD_EnableIT_TypeCEventCC1(Ports[PortNum].husbpd);
34193b58:	7bfa      	ldrb	r2, [r7, #15]
34193b5a:	4913      	ldr	r1, [pc, #76]	@ (34193ba8 <CAD_StateMachine+0x9c>)
34193b5c:	4613      	mov	r3, r2
34193b5e:	00db      	lsls	r3, r3, #3
34193b60:	1a9b      	subs	r3, r3, r2
34193b62:	00db      	lsls	r3, r3, #3
34193b64:	440b      	add	r3, r1
34193b66:	681b      	ldr	r3, [r3, #0]
34193b68:	4618      	mov	r0, r3
34193b6a:	f7ff fe9b 	bl	341938a4 <LL_UCPD_EnableIT_TypeCEventCC1>
        LL_UCPD_EnableIT_TypeCEventCC1(Ports[PortNum].husbpd);
      }
#endif /* !_LOW_POWER */

      /* Enable IRQ */
      UCPD_INSTANCE0_ENABLEIRQ;
34193b6e:	2102      	movs	r1, #2
34193b70:	20b0      	movs	r0, #176	@ 0xb0
34193b72:	f7ff fe25 	bl	341937c0 <__NVIC_SetPriority>
34193b76:	20b0      	movs	r0, #176	@ 0xb0
34193b78:	f7ff fe04 	bl	34193784 <__NVIC_EnableIRQ>
#if defined(_DRP) || defined(_ACCESSORY_SNK)
      _handle->CAD_tToggle_start = HAL_GetTick();
#endif /* _DRP || _ACCESSORY_SNK */
      _handle->cstate = USBPD_CAD_STATE_DETACHED;
34193b7c:	693a      	ldr	r2, [r7, #16]
34193b7e:	7853      	ldrb	r3, [r2, #1]
34193b80:	2101      	movs	r1, #1
34193b82:	f361 0345 	bfi	r3, r1, #1, #5
34193b86:	7053      	strb	r3, [r2, #1]
      break;
34193b88:	e007      	b.n	34193b9a <CAD_StateMachine+0x8e>
    }

    default:
    {
      /* Call the state machine corresponding to the port SNK or SRC or DRP */
      _timing = _handle->CAD_PtrStateMachine(PortNum, pEvent, pCCXX);
34193b8a:	693b      	ldr	r3, [r7, #16]
34193b8c:	689b      	ldr	r3, [r3, #8]
34193b8e:	7bf8      	ldrb	r0, [r7, #15]
34193b90:	687a      	ldr	r2, [r7, #4]
34193b92:	68b9      	ldr	r1, [r7, #8]
34193b94:	4798      	blx	r3
34193b96:	6178      	str	r0, [r7, #20]
      break;
34193b98:	bf00      	nop
    }
#endif /* CAD_DEBUG_TRACE */
  }
#endif /* _TRACE */

  return _timing;
34193b9a:	697b      	ldr	r3, [r7, #20]
}
34193b9c:	4618      	mov	r0, r3
34193b9e:	3718      	adds	r7, #24
34193ba0:	46bd      	mov	sp, r7
34193ba2:	bd80      	pop	{r7, pc}
34193ba4:	341c2d6c 	.word	0x341c2d6c
34193ba8:	341c2d7c 	.word	0x341c2d7c

34193bac <CAD_Check_HW_SNK>:
  * @brief  Check CCx HW condition
  * @param  PortNum Port
  * @retval none
  */
void CAD_Check_HW_SNK(uint8_t PortNum)
{
34193bac:	b480      	push	{r7}
34193bae:	b087      	sub	sp, #28
34193bb0:	af00      	add	r7, sp, #0
34193bb2:	4603      	mov	r3, r0
34193bb4:	71fb      	strb	r3, [r7, #7]
  CAD_HW_HandleTypeDef *_handle = &CAD_HW_Handles[PortNum];
34193bb6:	79fa      	ldrb	r2, [r7, #7]
34193bb8:	4613      	mov	r3, r2
34193bba:	005b      	lsls	r3, r3, #1
34193bbc:	4413      	add	r3, r2
34193bbe:	009b      	lsls	r3, r3, #2
34193bc0:	4a3a      	ldr	r2, [pc, #232]	@ (34193cac <CAD_Check_HW_SNK+0x100>)
34193bc2:	4413      	add	r3, r2
34193bc4:	617b      	str	r3, [r7, #20]
  CC2_value = Ports[PortNum].husbpd->SR & UCPD_SR_TYPEC_VSTATE_CC2;

  /* Disable the C state machine */
  SET_BIT(Ports[PortNum].husbpd->CR, UCPD_CR_CC1TCDIS | UCPD_CR_CC2TCDIS);
#else
  CC1_value = Ports[PortNum].husbpd->SR & UCPD_SR_TYPEC_VSTATE_CC1;
34193bc6:	79fa      	ldrb	r2, [r7, #7]
34193bc8:	4939      	ldr	r1, [pc, #228]	@ (34193cb0 <CAD_Check_HW_SNK+0x104>)
34193bca:	4613      	mov	r3, r2
34193bcc:	00db      	lsls	r3, r3, #3
34193bce:	1a9b      	subs	r3, r3, r2
34193bd0:	00db      	lsls	r3, r3, #3
34193bd2:	440b      	add	r3, r1
34193bd4:	681b      	ldr	r3, [r3, #0]
34193bd6:	695b      	ldr	r3, [r3, #20]
34193bd8:	f403 3340 	and.w	r3, r3, #196608	@ 0x30000
34193bdc:	613b      	str	r3, [r7, #16]
  CC2_value = Ports[PortNum].husbpd->SR & UCPD_SR_TYPEC_VSTATE_CC2;
34193bde:	79fa      	ldrb	r2, [r7, #7]
34193be0:	4933      	ldr	r1, [pc, #204]	@ (34193cb0 <CAD_Check_HW_SNK+0x104>)
34193be2:	4613      	mov	r3, r2
34193be4:	00db      	lsls	r3, r3, #3
34193be6:	1a9b      	subs	r3, r3, r2
34193be8:	00db      	lsls	r3, r3, #3
34193bea:	440b      	add	r3, r1
34193bec:	681b      	ldr	r3, [r3, #0]
34193bee:	695b      	ldr	r3, [r3, #20]
34193bf0:	f403 2340 	and.w	r3, r3, #786432	@ 0xc0000
34193bf4:	60fb      	str	r3, [r7, #12]
#endif /* _LOW_POWER || USBPDM1_VCC_FEATURE_ENABLED */

  _handle->cc  = CCNONE;
34193bf6:	697a      	ldr	r2, [r7, #20]
34193bf8:	7813      	ldrb	r3, [r2, #0]
34193bfa:	f023 0303 	bic.w	r3, r3, #3
34193bfe:	7013      	strb	r3, [r2, #0]
  _handle->CurrentHWcondition     = HW_Detachment;
34193c00:	697a      	ldr	r2, [r7, #20]
34193c02:	7813      	ldrb	r3, [r2, #0]
34193c04:	f023 031c 	bic.w	r3, r3, #28
34193c08:	7013      	strb	r3, [r2, #0]

  if ((CC1_value != LL_UCPD_SNK_CC1_VOPEN) && (CC2_value == LL_UCPD_SNK_CC2_VOPEN))
34193c0a:	693b      	ldr	r3, [r7, #16]
34193c0c:	2b00      	cmp	r3, #0
34193c0e:	d021      	beq.n	34193c54 <CAD_Check_HW_SNK+0xa8>
34193c10:	68fb      	ldr	r3, [r7, #12]
34193c12:	2b00      	cmp	r3, #0
34193c14:	d11e      	bne.n	34193c54 <CAD_Check_HW_SNK+0xa8>
  {
    _handle->CurrentHWcondition = HW_Attachment;
34193c16:	697a      	ldr	r2, [r7, #20]
34193c18:	7813      	ldrb	r3, [r2, #0]
34193c1a:	2101      	movs	r1, #1
34193c1c:	f361 0384 	bfi	r3, r1, #2, #3
34193c20:	7013      	strb	r3, [r2, #0]
    _handle->cc = CC1;
34193c22:	697a      	ldr	r2, [r7, #20]
34193c24:	7813      	ldrb	r3, [r2, #0]
34193c26:	2101      	movs	r1, #1
34193c28:	f361 0301 	bfi	r3, r1, #0, #2
34193c2c:	7013      	strb	r3, [r2, #0]
    Ports[PortNum].params->SNKExposedRP_AtAttach = CC1_value >> UCPD_SR_TYPEC_VSTATE_CC1_Pos;
34193c2e:	693b      	ldr	r3, [r7, #16]
34193c30:	0c18      	lsrs	r0, r3, #16
34193c32:	79fa      	ldrb	r2, [r7, #7]
34193c34:	491e      	ldr	r1, [pc, #120]	@ (34193cb0 <CAD_Check_HW_SNK+0x104>)
34193c36:	4613      	mov	r3, r2
34193c38:	00db      	lsls	r3, r3, #3
34193c3a:	1a9b      	subs	r3, r3, r2
34193c3c:	00db      	lsls	r3, r3, #3
34193c3e:	440b      	add	r3, r1
34193c40:	3310      	adds	r3, #16
34193c42:	681a      	ldr	r2, [r3, #0]
34193c44:	4603      	mov	r3, r0
34193c46:	f003 0303 	and.w	r3, r3, #3
34193c4a:	b2d9      	uxtb	r1, r3
34193c4c:	7893      	ldrb	r3, [r2, #2]
34193c4e:	f361 0383 	bfi	r3, r1, #2, #2
34193c52:	7093      	strb	r3, [r2, #2]
  }

  if ((CC1_value == LL_UCPD_SNK_CC1_VOPEN) && (CC2_value != LL_UCPD_SNK_CC2_VOPEN))
34193c54:	693b      	ldr	r3, [r7, #16]
34193c56:	2b00      	cmp	r3, #0
34193c58:	d121      	bne.n	34193c9e <CAD_Check_HW_SNK+0xf2>
34193c5a:	68fb      	ldr	r3, [r7, #12]
34193c5c:	2b00      	cmp	r3, #0
34193c5e:	d01e      	beq.n	34193c9e <CAD_Check_HW_SNK+0xf2>
  {
    _handle->CurrentHWcondition = HW_Attachment;
34193c60:	697a      	ldr	r2, [r7, #20]
34193c62:	7813      	ldrb	r3, [r2, #0]
34193c64:	2101      	movs	r1, #1
34193c66:	f361 0384 	bfi	r3, r1, #2, #3
34193c6a:	7013      	strb	r3, [r2, #0]
    _handle->cc = CC2;
34193c6c:	697a      	ldr	r2, [r7, #20]
34193c6e:	7813      	ldrb	r3, [r2, #0]
34193c70:	2102      	movs	r1, #2
34193c72:	f361 0301 	bfi	r3, r1, #0, #2
34193c76:	7013      	strb	r3, [r2, #0]
    Ports[PortNum].params->SNKExposedRP_AtAttach = CC2_value >> UCPD_SR_TYPEC_VSTATE_CC2_Pos;;
34193c78:	68fb      	ldr	r3, [r7, #12]
34193c7a:	0c98      	lsrs	r0, r3, #18
34193c7c:	79fa      	ldrb	r2, [r7, #7]
34193c7e:	490c      	ldr	r1, [pc, #48]	@ (34193cb0 <CAD_Check_HW_SNK+0x104>)
34193c80:	4613      	mov	r3, r2
34193c82:	00db      	lsls	r3, r3, #3
34193c84:	1a9b      	subs	r3, r3, r2
34193c86:	00db      	lsls	r3, r3, #3
34193c88:	440b      	add	r3, r1
34193c8a:	3310      	adds	r3, #16
34193c8c:	681a      	ldr	r2, [r3, #0]
34193c8e:	4603      	mov	r3, r0
34193c90:	f003 0303 	and.w	r3, r3, #3
34193c94:	b2d9      	uxtb	r1, r3
34193c96:	7893      	ldrb	r3, [r2, #2]
34193c98:	f361 0383 	bfi	r3, r1, #2, #2
34193c9c:	7093      	strb	r3, [r2, #2]
  }
}
34193c9e:	bf00      	nop
34193ca0:	371c      	adds	r7, #28
34193ca2:	46bd      	mov	sp, r7
34193ca4:	f85d 7b04 	ldr.w	r7, [sp], #4
34193ca8:	4770      	bx	lr
34193caa:	bf00      	nop
34193cac:	341c2d6c 	.word	0x341c2d6c
34193cb0:	341c2d7c 	.word	0x341c2d7c

34193cb4 <ManageStateDetached_SNK>:
  * @brief  Manage the detached state for sink role
  * @param  PortNum Port
  * @retval Timeout value
  */
static uint32_t ManageStateDetached_SNK(uint8_t PortNum)
{
34193cb4:	b580      	push	{r7, lr}
34193cb6:	b084      	sub	sp, #16
34193cb8:	af00      	add	r7, sp, #0
34193cba:	4603      	mov	r3, r0
34193cbc:	71fb      	strb	r3, [r7, #7]
  CAD_HW_HandleTypeDef *_handle = &CAD_HW_Handles[PortNum];
34193cbe:	79fa      	ldrb	r2, [r7, #7]
34193cc0:	4613      	mov	r3, r2
34193cc2:	005b      	lsls	r3, r3, #1
34193cc4:	4413      	add	r3, r2
34193cc6:	009b      	lsls	r3, r3, #2
34193cc8:	4a1e      	ldr	r2, [pc, #120]	@ (34193d44 <ManageStateDetached_SNK+0x90>)
34193cca:	4413      	add	r3, r2
34193ccc:	60bb      	str	r3, [r7, #8]
  uint32_t _timing = CAD_DEFAULT_TIME;
34193cce:	2302      	movs	r3, #2
34193cd0:	60fb      	str	r3, [r7, #12]

  CAD_Check_HW_SNK(PortNum);
34193cd2:	79fb      	ldrb	r3, [r7, #7]
34193cd4:	4618      	mov	r0, r3
34193cd6:	f7ff ff69 	bl	34193bac <CAD_Check_HW_SNK>
  /* Change the status on the basis of the HW event given by CAD_Check_HW() */
  if (_handle->CurrentHWcondition == HW_Detachment)
34193cda:	68bb      	ldr	r3, [r7, #8]
34193cdc:	781b      	ldrb	r3, [r3, #0]
34193cde:	f003 031c 	and.w	r3, r3, #28
34193ce2:	b2db      	uxtb	r3, r3
34193ce4:	2b00      	cmp	r3, #0
34193ce6:	d103      	bne.n	34193cf0 <ManageStateDetached_SNK+0x3c>
    /* Value returned by a SRC or a SINK */
    _timing = CAD_DETACH_POLLING; /* 100ms in the sink cases */
#elif defined(USBPDM1_VCC_FEATURE_ENABLED)
    _timing = CAD_DEFAULT_TIME;
#else
    _timing = CAD_INFINITE_TIME;
34193ce8:	f04f 33ff 	mov.w	r3, #4294967295
34193cec:	60fb      	str	r3, [r7, #12]
34193cee:	e023      	b.n	34193d38 <ManageStateDetached_SNK+0x84>
#endif /* _ACCESSORY_SNK */
  }
  else
  {
    /* Get the time of this event */
    _handle->CAD_tDebounce_start = HAL_GetTick();
34193cf0:	f7f1 fc62 	bl	341855b8 <HAL_GetTick>
34193cf4:	4602      	mov	r2, r0
34193cf6:	68bb      	ldr	r3, [r7, #8]
34193cf8:	605a      	str	r2, [r3, #4]
    _handle->cstate = USBPD_CAD_STATE_ATTACHED_WAIT;
34193cfa:	68ba      	ldr	r2, [r7, #8]
34193cfc:	7853      	ldrb	r3, [r2, #1]
34193cfe:	2102      	movs	r1, #2
34193d00:	f361 0345 	bfi	r3, r1, #1, #5
34193d04:	7053      	strb	r3, [r2, #1]

    /* Temporary patch for test TD.PD 4.5.2 + rework for Patch TP.PD.C.E5 */
    HAL_Delay(1);
34193d06:	2001      	movs	r0, #1
34193d08:	f7f1 fc62 	bl	341855d0 <HAL_Delay>
    CAD_Check_HW_SNK(PortNum);
34193d0c:	79fb      	ldrb	r3, [r7, #7]
34193d0e:	4618      	mov	r0, r3
34193d10:	f7ff ff4c 	bl	34193bac <CAD_Check_HW_SNK>

    if (_handle->CurrentHWcondition == HW_Detachment)
34193d14:	68bb      	ldr	r3, [r7, #8]
34193d16:	781b      	ldrb	r3, [r3, #0]
34193d18:	f003 031c 	and.w	r3, r3, #28
34193d1c:	b2db      	uxtb	r3, r3
34193d1e:	2b00      	cmp	r3, #0
34193d20:	d106      	bne.n	34193d30 <ManageStateDetached_SNK+0x7c>
    {
      _handle->cstate = USBPD_CAD_STATE_DETACHED;
34193d22:	68ba      	ldr	r2, [r7, #8]
34193d24:	7853      	ldrb	r3, [r2, #1]
34193d26:	2101      	movs	r1, #1
34193d28:	f361 0345 	bfi	r3, r1, #1, #5
34193d2c:	7053      	strb	r3, [r2, #1]
34193d2e:	e003      	b.n	34193d38 <ManageStateDetached_SNK+0x84>
    }
    else
    {
      BSP_USBPD_PWR_VBUSInit(PortNum);
34193d30:	79fb      	ldrb	r3, [r7, #7]
34193d32:	4618      	mov	r0, r3
34193d34:	f7f0 fd80 	bl	34184838 <BSP_USBPD_PWR_VBUSInit>
    }
  }
  return _timing;
34193d38:	68fb      	ldr	r3, [r7, #12]
}
34193d3a:	4618      	mov	r0, r3
34193d3c:	3710      	adds	r7, #16
34193d3e:	46bd      	mov	sp, r7
34193d40:	bd80      	pop	{r7, pc}
34193d42:	bf00      	nop
34193d44:	341c2d6c 	.word	0x341c2d6c

34193d48 <ManageStateAttachedWait_SNK>:
  * @param  pEvent  Pointer on CAD event based on @ref USBPD_CAD_EVENT
  * @param  pCCXX   Pointer on CC Pin based on @ref CCxPin_TypeDef
  * @retval Timeout value
  */
static uint32_t ManageStateAttachedWait_SNK(uint8_t PortNum, USBPD_CAD_EVENT *pEvent, CCxPin_TypeDef *pCCXX)
{
34193d48:	b580      	push	{r7, lr}
34193d4a:	b088      	sub	sp, #32
34193d4c:	af00      	add	r7, sp, #0
34193d4e:	4603      	mov	r3, r0
34193d50:	60b9      	str	r1, [r7, #8]
34193d52:	607a      	str	r2, [r7, #4]
34193d54:	73fb      	strb	r3, [r7, #15]
  CAD_HW_HandleTypeDef *_handle = &CAD_HW_Handles[PortNum];
34193d56:	7bfa      	ldrb	r2, [r7, #15]
34193d58:	4613      	mov	r3, r2
34193d5a:	005b      	lsls	r3, r3, #1
34193d5c:	4413      	add	r3, r2
34193d5e:	009b      	lsls	r3, r3, #2
34193d60:	4a39      	ldr	r2, [pc, #228]	@ (34193e48 <ManageStateAttachedWait_SNK+0x100>)
34193d62:	4413      	add	r3, r2
34193d64:	61bb      	str	r3, [r7, #24]
  uint32_t _timing = CAD_DEFAULT_TIME;
34193d66:	2302      	movs	r3, #2
34193d68:	61fb      	str	r3, [r7, #28]

  uint32_t CAD_tDebounce = HAL_GetTick() - _handle->CAD_tDebounce_start;
34193d6a:	f7f1 fc25 	bl	341855b8 <HAL_GetTick>
34193d6e:	4602      	mov	r2, r0
34193d70:	69bb      	ldr	r3, [r7, #24]
34193d72:	685b      	ldr	r3, [r3, #4]
34193d74:	1ad3      	subs	r3, r2, r3
34193d76:	617b      	str	r3, [r7, #20]
  CAD_Check_HW_SNK(PortNum);
34193d78:	7bfb      	ldrb	r3, [r7, #15]
34193d7a:	4618      	mov	r0, r3
34193d7c:	f7ff ff16 	bl	34193bac <CAD_Check_HW_SNK>
  if (_handle->CurrentHWcondition == HW_Attachment)
34193d80:	69bb      	ldr	r3, [r7, #24]
34193d82:	781b      	ldrb	r3, [r3, #0]
34193d84:	f003 031c 	and.w	r3, r3, #28
34193d88:	b2db      	uxtb	r3, r3
34193d8a:	2b04      	cmp	r3, #4
34193d8c:	d12c      	bne.n	34193de8 <ManageStateAttachedWait_SNK+0xa0>
  {
    if (CAD_tDebounce > CAD_TCCDEBOUCE_THRESHOLD)
34193d8e:	697b      	ldr	r3, [r7, #20]
34193d90:	2b78      	cmp	r3, #120	@ 0x78
34193d92:	d923      	bls.n	34193ddc <ManageStateAttachedWait_SNK+0x94>
    {
      if (USBPD_TRUE == USBPD_PWR_IF_GetVBUSStatus(PortNum, USBPD_PWR_VSAFE5V)) /* Check if Vbus is on */
34193d94:	7bfb      	ldrb	r3, [r7, #15]
34193d96:	2101      	movs	r1, #1
34193d98:	4618      	mov	r0, r3
34193d9a:	f7ed fff1 	bl	34181d80 <USBPD_PWR_IF_GetVBUSStatus>
34193d9e:	4603      	mov	r3, r0
34193da0:	2b01      	cmp	r3, #1
34193da2:	d11b      	bne.n	34193ddc <ManageStateAttachedWait_SNK+0x94>
      {
        HW_SignalAttachement(PortNum, _handle->cc);
34193da4:	69bb      	ldr	r3, [r7, #24]
34193da6:	781b      	ldrb	r3, [r3, #0]
34193da8:	f3c3 0301 	ubfx	r3, r3, #0, #2
34193dac:	b2db      	uxtb	r3, r3
34193dae:	461a      	mov	r2, r3
34193db0:	7bfb      	ldrb	r3, [r7, #15]
34193db2:	4611      	mov	r1, r2
34193db4:	4618      	mov	r0, r3
34193db6:	f000 fdc7 	bl	34194948 <HW_SignalAttachement>
        /* Go to attached state */
        _handle->cstate = USBPD_CAD_STATE_ATTACHED;
34193dba:	69ba      	ldr	r2, [r7, #24]
34193dbc:	7853      	ldrb	r3, [r2, #1]
34193dbe:	2103      	movs	r1, #3
34193dc0:	f361 0345 	bfi	r3, r1, #1, #5
34193dc4:	7053      	strb	r3, [r2, #1]
        *pEvent = USBPD_CAD_EVENT_ATTACHED;
34193dc6:	68bb      	ldr	r3, [r7, #8]
34193dc8:	2202      	movs	r2, #2
34193dca:	701a      	strb	r2, [r3, #0]
        *pCCXX = _handle->cc;
34193dcc:	69bb      	ldr	r3, [r7, #24]
34193dce:	781b      	ldrb	r3, [r3, #0]
34193dd0:	f3c3 0301 	ubfx	r3, r3, #0, #2
34193dd4:	b2db      	uxtb	r3, r3
34193dd6:	461a      	mov	r2, r3
34193dd8:	687b      	ldr	r3, [r7, #4]
34193dda:	601a      	str	r2, [r3, #0]
      }
    }
    _handle->CAD_tDebounce_flag = USBPD_FALSE;
34193ddc:	69ba      	ldr	r2, [r7, #24]
34193dde:	7813      	ldrb	r3, [r2, #0]
34193de0:	f023 0320 	bic.w	r3, r3, #32
34193de4:	7013      	strb	r3, [r2, #0]
34193de6:	e02a      	b.n	34193e3e <ManageStateAttachedWait_SNK+0xf6>
  }
  else
  {
    /* Start counting of CAD_tDebounce */
    if (USBPD_FALSE == _handle->CAD_tDebounce_flag)
34193de8:	69bb      	ldr	r3, [r7, #24]
34193dea:	781b      	ldrb	r3, [r3, #0]
34193dec:	f003 0320 	and.w	r3, r3, #32
34193df0:	b2db      	uxtb	r3, r3
34193df2:	2b00      	cmp	r3, #0
34193df4:	d10c      	bne.n	34193e10 <ManageStateAttachedWait_SNK+0xc8>
    {
      _handle->CAD_tDebounce_start = HAL_GetTick();
34193df6:	f7f1 fbdf 	bl	341855b8 <HAL_GetTick>
34193dfa:	4602      	mov	r2, r0
34193dfc:	69bb      	ldr	r3, [r7, #24]
34193dfe:	605a      	str	r2, [r3, #4]
      _handle->CAD_tDebounce_flag = USBPD_TRUE;
34193e00:	69ba      	ldr	r2, [r7, #24]
34193e02:	7813      	ldrb	r3, [r2, #0]
34193e04:	f043 0320 	orr.w	r3, r3, #32
34193e08:	7013      	strb	r3, [r2, #0]
      _timing = CAD_TPDDEBOUCE_THRESHOLD;
34193e0a:	230c      	movs	r3, #12
34193e0c:	61fb      	str	r3, [r7, #28]
34193e0e:	e016      	b.n	34193e3e <ManageStateAttachedWait_SNK+0xf6>
    }
    else /* CAD_tDebounce already running */
    {
      /* Evaluate CAD_tDebounce */
      if ((HAL_GetTick() - _handle->CAD_tDebounce_start > CAD_TPDDEBOUCE_THRESHOLD))
34193e10:	f7f1 fbd2 	bl	341855b8 <HAL_GetTick>
34193e14:	4602      	mov	r2, r0
34193e16:	69bb      	ldr	r3, [r7, #24]
34193e18:	685b      	ldr	r3, [r3, #4]
34193e1a:	1ad3      	subs	r3, r2, r3
34193e1c:	2b0c      	cmp	r3, #12
34193e1e:	d90e      	bls.n	34193e3e <ManageStateAttachedWait_SNK+0xf6>
      {
        _handle->CAD_tDebounce_flag = USBPD_FALSE;
34193e20:	69ba      	ldr	r2, [r7, #24]
34193e22:	7813      	ldrb	r3, [r2, #0]
34193e24:	f023 0320 	bic.w	r3, r3, #32
34193e28:	7013      	strb	r3, [r2, #0]
        _handle->cstate             = USBPD_CAD_STATE_DETACHED;
34193e2a:	69ba      	ldr	r2, [r7, #24]
34193e2c:	7853      	ldrb	r3, [r2, #1]
34193e2e:	2101      	movs	r1, #1
34193e30:	f361 0345 	bfi	r3, r1, #1, #5
34193e34:	7053      	strb	r3, [r2, #1]
        BSP_USBPD_PWR_VBUSDeInit(PortNum);
34193e36:	7bfb      	ldrb	r3, [r7, #15]
34193e38:	4618      	mov	r0, r3
34193e3a:	f7f0 fd2d 	bl	34184898 <BSP_USBPD_PWR_VBUSDeInit>
        }
#endif /* _ACCESSORY_SNK */
      }
    }
  }
  return _timing;
34193e3e:	69fb      	ldr	r3, [r7, #28]
}
34193e40:	4618      	mov	r0, r3
34193e42:	3720      	adds	r7, #32
34193e44:	46bd      	mov	sp, r7
34193e46:	bd80      	pop	{r7, pc}
34193e48:	341c2d6c 	.word	0x341c2d6c

34193e4c <ManageStateAttached_SNK>:
  * @param  pEvent  Pointer on CAD event based on @ref USBPD_CAD_EVENT
  * @param  pCCXX   Pointer on CC Pin based on @ref CCxPin_TypeDef
  * @retval Timeout value
  */
static uint32_t ManageStateAttached_SNK(uint8_t PortNum, USBPD_CAD_EVENT *pEvent, CCxPin_TypeDef *pCCXX)
{
34193e4c:	b580      	push	{r7, lr}
34193e4e:	b088      	sub	sp, #32
34193e50:	af00      	add	r7, sp, #0
34193e52:	4603      	mov	r3, r0
34193e54:	60b9      	str	r1, [r7, #8]
34193e56:	607a      	str	r2, [r7, #4]
34193e58:	73fb      	strb	r3, [r7, #15]
  CAD_HW_HandleTypeDef *_handle = &CAD_HW_Handles[PortNum];
34193e5a:	7bfa      	ldrb	r2, [r7, #15]
34193e5c:	4613      	mov	r3, r2
34193e5e:	005b      	lsls	r3, r3, #1
34193e60:	4413      	add	r3, r2
34193e62:	009b      	lsls	r3, r3, #2
34193e64:	4a2a      	ldr	r2, [pc, #168]	@ (34193f10 <ManageStateAttached_SNK+0xc4>)
34193e66:	4413      	add	r3, r2
34193e68:	61bb      	str	r3, [r7, #24]
  uint32_t _timing = CAD_DEFAULT_TIME;
34193e6a:	2302      	movs	r3, #2
34193e6c:	61fb      	str	r3, [r7, #28]

  uint32_t ccx;
  uint32_t comp = (Ports[PortNum].CCx == CC1) ? LL_UCPD_SNK_CC1_VOPEN : LL_UCPD_SNK_CC2_VOPEN;
34193e6e:	2300      	movs	r3, #0
34193e70:	617b      	str	r3, [r7, #20]
  {
    __DSB();
  };
#endif /* _LOW_POWER || USBPDM1_VCC_FEATURE_ENABLED */

  ccx  = (Ports[PortNum].CCx == CC1) ? (Ports[PortNum].husbpd->SR & UCPD_SR_TYPEC_VSTATE_CC1)
34193e72:	7bfa      	ldrb	r2, [r7, #15]
34193e74:	4927      	ldr	r1, [pc, #156]	@ (34193f14 <ManageStateAttached_SNK+0xc8>)
34193e76:	4613      	mov	r3, r2
34193e78:	00db      	lsls	r3, r3, #3
34193e7a:	1a9b      	subs	r3, r3, r2
34193e7c:	00db      	lsls	r3, r3, #3
34193e7e:	440b      	add	r3, r1
34193e80:	3330      	adds	r3, #48	@ 0x30
34193e82:	681b      	ldr	r3, [r3, #0]
         : (Ports[PortNum].husbpd->SR & UCPD_SR_TYPEC_VSTATE_CC2);
34193e84:	2b01      	cmp	r3, #1
34193e86:	d10b      	bne.n	34193ea0 <ManageStateAttached_SNK+0x54>
  ccx  = (Ports[PortNum].CCx == CC1) ? (Ports[PortNum].husbpd->SR & UCPD_SR_TYPEC_VSTATE_CC1)
34193e88:	7bfa      	ldrb	r2, [r7, #15]
34193e8a:	4922      	ldr	r1, [pc, #136]	@ (34193f14 <ManageStateAttached_SNK+0xc8>)
34193e8c:	4613      	mov	r3, r2
34193e8e:	00db      	lsls	r3, r3, #3
34193e90:	1a9b      	subs	r3, r3, r2
34193e92:	00db      	lsls	r3, r3, #3
34193e94:	440b      	add	r3, r1
34193e96:	681b      	ldr	r3, [r3, #0]
34193e98:	695b      	ldr	r3, [r3, #20]
         : (Ports[PortNum].husbpd->SR & UCPD_SR_TYPEC_VSTATE_CC2);
34193e9a:	f403 3340 	and.w	r3, r3, #196608	@ 0x30000
34193e9e:	e00a      	b.n	34193eb6 <ManageStateAttached_SNK+0x6a>
34193ea0:	7bfa      	ldrb	r2, [r7, #15]
34193ea2:	491c      	ldr	r1, [pc, #112]	@ (34193f14 <ManageStateAttached_SNK+0xc8>)
34193ea4:	4613      	mov	r3, r2
34193ea6:	00db      	lsls	r3, r3, #3
34193ea8:	1a9b      	subs	r3, r3, r2
34193eaa:	00db      	lsls	r3, r3, #3
34193eac:	440b      	add	r3, r1
34193eae:	681b      	ldr	r3, [r3, #0]
34193eb0:	695b      	ldr	r3, [r3, #20]
34193eb2:	f403 2340 	and.w	r3, r3, #786432	@ 0xc0000
  ccx  = (Ports[PortNum].CCx == CC1) ? (Ports[PortNum].husbpd->SR & UCPD_SR_TYPEC_VSTATE_CC1)
34193eb6:	613b      	str	r3, [r7, #16]
  if ((USBPD_TRUE == USBPD_PWR_IF_GetVBUSStatus(PortNum,
34193eb8:	7bfb      	ldrb	r3, [r7, #15]
34193eba:	2102      	movs	r1, #2
34193ebc:	4618      	mov	r0, r3
34193ebe:	f7ed ff5f 	bl	34181d80 <USBPD_PWR_IF_GetVBUSStatus>
34193ec2:	4603      	mov	r3, r0
34193ec4:	2b01      	cmp	r3, #1
34193ec6:	d11b      	bne.n	34193f00 <ManageStateAttached_SNK+0xb4>
                                                USBPD_PWR_SNKDETACH)) /* Check if Vbus is below disconnect threshold */
      &&
34193ec8:	697a      	ldr	r2, [r7, #20]
34193eca:	693b      	ldr	r3, [r7, #16]
34193ecc:	429a      	cmp	r2, r3
34193ece:	d117      	bne.n	34193f00 <ManageStateAttached_SNK+0xb4>
      (comp == ccx)                                                   /* Confirm that there is no RP */
     )
  {
    HW_SignalDetachment(PortNum);
34193ed0:	7bfb      	ldrb	r3, [r7, #15]
34193ed2:	4618      	mov	r0, r3
34193ed4:	f000 fd50 	bl	34194978 <HW_SignalDetachment>
    /* Restart the toggle time */
    _handle->CurrentHWcondition = HW_Detachment;
34193ed8:	69ba      	ldr	r2, [r7, #24]
34193eda:	7813      	ldrb	r3, [r2, #0]
34193edc:	f023 031c 	bic.w	r3, r3, #28
34193ee0:	7013      	strb	r3, [r2, #0]
    _handle->cstate             = USBPD_CAD_STATE_DETACHED;
34193ee2:	69ba      	ldr	r2, [r7, #24]
34193ee4:	7853      	ldrb	r3, [r2, #1]
34193ee6:	2101      	movs	r1, #1
34193ee8:	f361 0345 	bfi	r3, r1, #1, #5
34193eec:	7053      	strb	r3, [r2, #1]
    if (USBPD_TRUE ==  _handle->CAD_Accessory_SNK)
    {
      _handle->CAD_tToggle_start = HAL_GetTick();
    }
#endif /* _ACCESSORY_SNK */
    *pEvent = USBPD_CAD_EVENT_DETACHED;
34193eee:	68bb      	ldr	r3, [r7, #8]
34193ef0:	2201      	movs	r2, #1
34193ef2:	701a      	strb	r2, [r3, #0]
    *pCCXX = CCNONE;
34193ef4:	687b      	ldr	r3, [r7, #4]
34193ef6:	2200      	movs	r2, #0
34193ef8:	601a      	str	r2, [r3, #0]
    _timing = 0;
34193efa:	2300      	movs	r3, #0
34193efc:	61fb      	str	r3, [r7, #28]
34193efe:	e001      	b.n	34193f04 <ManageStateAttached_SNK+0xb8>
  }
  else
  {
    _timing = CAD_VBUS_POLLING_TIME;
34193f00:	230a      	movs	r3, #10
34193f02:	61fb      	str	r3, [r7, #28]
#if defined(_LOW_POWER) || defined(USBPDM1_VCC_FEATURE_ENABLED)
  /* Disable type C state machine */
  SET_BIT(Ports[PortNum].husbpd->CR, UCPD_CR_CC1TCDIS | UCPD_CR_CC2TCDIS);
#endif /* _LOW_POWER || USBPDM1_VCC_FEATURE_ENABLED */

  return _timing;
34193f04:	69fb      	ldr	r3, [r7, #28]
}
34193f06:	4618      	mov	r0, r3
34193f08:	3720      	adds	r7, #32
34193f0a:	46bd      	mov	sp, r7
34193f0c:	bd80      	pop	{r7, pc}
34193f0e:	bf00      	nop
34193f10:	341c2d6c 	.word	0x341c2d6c
34193f14:	341c2d7c 	.word	0x341c2d7c

34193f18 <CAD_HW_IF_VBUSDetectCallback>:
  * @param  VBUSConnectionStatus   VBUS connection status, based on @ref USBPD_PWR_VBUSConnectionStatusTypeDef
  * @retval None
  */
void CAD_HW_IF_VBUSDetectCallback(uint32_t PortNum,
                                  USBPD_PWR_VBUSConnectionStatusTypeDef VBUSConnectionStatus)
{
34193f18:	b580      	push	{r7, lr}
34193f1a:	b084      	sub	sp, #16
34193f1c:	af00      	add	r7, sp, #0
34193f1e:	6078      	str	r0, [r7, #4]
34193f20:	460b      	mov	r3, r1
34193f22:	70fb      	strb	r3, [r7, #3]
  /* If VBUS is connected */
  if (VBUSConnectionStatus == VBUS_CONNECTED)
34193f24:	78fb      	ldrb	r3, [r7, #3]
34193f26:	2b00      	cmp	r3, #0
34193f28:	d037      	beq.n	34193f9a <CAD_HW_IF_VBUSDetectCallback+0x82>
    /* VBUS_NOT_CONNECTED indications could be caused by false OCP/OVP errors detected at BSP level.
       If reported here, it is assumed that it might be possible to recover from error.
       If error could not be recovered, or is assumed to be related to a true safety issue, it will not be notified
       by BSP */
#if defined(USBPDCORE_LIB_NO_PD)
    CAD_HW_HandleTypeDef *_handle = &CAD_HW_Handles[PortNum];
34193f2a:	687a      	ldr	r2, [r7, #4]
34193f2c:	4613      	mov	r3, r2
34193f2e:	005b      	lsls	r3, r3, #1
34193f30:	4413      	add	r3, r2
34193f32:	009b      	lsls	r3, r3, #2
34193f34:	4a1b      	ldr	r2, [pc, #108]	@ (34193fa4 <CAD_HW_IF_VBUSDetectCallback+0x8c>)
34193f36:	4413      	add	r3, r2
34193f38:	60fb      	str	r3, [r7, #12]

    /* VBUS_NOT_CONNECTED indication management in case of NO_PD configuration */
    if (Ports[PortNum].params->PE_PowerRole == USBPD_PORTPOWERROLE_SRC)
34193f3a:	491b      	ldr	r1, [pc, #108]	@ (34193fa8 <CAD_HW_IF_VBUSDetectCallback+0x90>)
34193f3c:	687a      	ldr	r2, [r7, #4]
34193f3e:	4613      	mov	r3, r2
34193f40:	00db      	lsls	r3, r3, #3
34193f42:	1a9b      	subs	r3, r3, r2
34193f44:	00db      	lsls	r3, r3, #3
34193f46:	440b      	add	r3, r1
34193f48:	3310      	adds	r3, #16
34193f4a:	681b      	ldr	r3, [r3, #0]
34193f4c:	781b      	ldrb	r3, [r3, #0]
34193f4e:	f003 0304 	and.w	r3, r3, #4
34193f52:	b2db      	uxtb	r3, r3
34193f54:	2b00      	cmp	r3, #0
34193f56:	d010      	beq.n	34193f7a <CAD_HW_IF_VBUSDetectCallback+0x62>
    {
      /* Current role is SRC when VBUS_NOT_CONNECTED signal is received */
      HW_SignalDetachment(PortNum);
34193f58:	687b      	ldr	r3, [r7, #4]
34193f5a:	b2db      	uxtb	r3, r3
34193f5c:	4618      	mov	r0, r3
34193f5e:	f000 fd0b 	bl	34194978 <HW_SignalDetachment>
      _handle->CAD_tDebounce_flag = USBPD_FALSE;
34193f62:	68fa      	ldr	r2, [r7, #12]
34193f64:	7813      	ldrb	r3, [r2, #0]
34193f66:	f023 0320 	bic.w	r3, r3, #32
34193f6a:	7013      	strb	r3, [r2, #0]
      _handle->cstate             = USBPD_CAD_STATE_DETACH_SRC;
34193f6c:	68fa      	ldr	r2, [r7, #12]
34193f6e:	7853      	ldrb	r3, [r2, #1]
34193f70:	210b      	movs	r1, #11
34193f72:	f361 0345 	bfi	r3, r1, #1, #5
34193f76:	7053      	strb	r3, [r2, #1]
    /* VBUS_NOT_CONNECTED indication management : Error has to be handled through a Detach/Attach procedure.
       Handled using ErrorRecovery mechanism */
    CAD_Enter_ErrorRecovery(PortNum);
#endif /* USBPDCORE_LIB_NO_PD */
  }
}
34193f78:	e00f      	b.n	34193f9a <CAD_HW_IF_VBUSDetectCallback+0x82>
      HW_SignalDetachment(PortNum);
34193f7a:	687b      	ldr	r3, [r7, #4]
34193f7c:	b2db      	uxtb	r3, r3
34193f7e:	4618      	mov	r0, r3
34193f80:	f000 fcfa 	bl	34194978 <HW_SignalDetachment>
      _handle->CurrentHWcondition = HW_Detachment;
34193f84:	68fa      	ldr	r2, [r7, #12]
34193f86:	7813      	ldrb	r3, [r2, #0]
34193f88:	f023 031c 	bic.w	r3, r3, #28
34193f8c:	7013      	strb	r3, [r2, #0]
      _handle->cstate             = USBPD_CAD_STATE_DETACHED;
34193f8e:	68fa      	ldr	r2, [r7, #12]
34193f90:	7853      	ldrb	r3, [r2, #1]
34193f92:	2101      	movs	r1, #1
34193f94:	f361 0345 	bfi	r3, r1, #1, #5
34193f98:	7053      	strb	r3, [r2, #1]
}
34193f9a:	bf00      	nop
34193f9c:	3710      	adds	r7, #16
34193f9e:	46bd      	mov	sp, r7
34193fa0:	bd80      	pop	{r7, pc}
34193fa2:	bf00      	nop
34193fa4:	341c2d6c 	.word	0x341c2d6c
34193fa8:	341c2d7c 	.word	0x341c2d7c

34193fac <USBPD_HW_GetUSPDInstance>:
/* Variable containing ADC conversions results */
/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/

UCPD_TypeDef *USBPD_HW_GetUSPDInstance(uint8_t PortNum)
{
34193fac:	b480      	push	{r7}
34193fae:	b083      	sub	sp, #12
34193fb0:	af00      	add	r7, sp, #0
34193fb2:	4603      	mov	r3, r0
34193fb4:	71fb      	strb	r3, [r7, #7]
  return UCPD_INSTANCE0;
34193fb6:	4b03      	ldr	r3, [pc, #12]	@ (34193fc4 <USBPD_HW_GetUSPDInstance+0x18>)
}
34193fb8:	4618      	mov	r0, r3
34193fba:	370c      	adds	r7, #12
34193fbc:	46bd      	mov	sp, r7
34193fbe:	f85d 7b04 	ldr.w	r7, [sp], #4
34193fc2:	4770      	bx	lr
34193fc4:	5000fc00 	.word	0x5000fc00

34193fc8 <LL_UCPD_ClearFlag_TypeCEventCC2>:
  * @rmtoll IIMR          TYPECEVT2IE        LL_UCPD_ClearFlag_TypeCEventCC2
  * @param  UCPDx UCPD Instance
  * @retval None
  */
__STATIC_INLINE void LL_UCPD_ClearFlag_TypeCEventCC2(UCPD_TypeDef *UCPDx)
{
34193fc8:	b480      	push	{r7}
34193fca:	b083      	sub	sp, #12
34193fcc:	af00      	add	r7, sp, #0
34193fce:	6078      	str	r0, [r7, #4]
  SET_BIT(UCPDx->ICR, UCPD_ICR_TYPECEVT2CF);
34193fd0:	687b      	ldr	r3, [r7, #4]
34193fd2:	699b      	ldr	r3, [r3, #24]
34193fd4:	f443 4200 	orr.w	r2, r3, #32768	@ 0x8000
34193fd8:	687b      	ldr	r3, [r7, #4]
34193fda:	619a      	str	r2, [r3, #24]
}
34193fdc:	bf00      	nop
34193fde:	370c      	adds	r7, #12
34193fe0:	46bd      	mov	sp, r7
34193fe2:	f85d 7b04 	ldr.w	r7, [sp], #4
34193fe6:	4770      	bx	lr

34193fe8 <LL_UCPD_ClearFlag_TypeCEventCC1>:
  * @rmtoll IIMR          TYPECEVT1IE        LL_UCPD_ClearFlag_TypeCEventCC1
  * @param  UCPDx UCPD Instance
  * @retval None
  */
__STATIC_INLINE void LL_UCPD_ClearFlag_TypeCEventCC1(UCPD_TypeDef *UCPDx)
{
34193fe8:	b480      	push	{r7}
34193fea:	b083      	sub	sp, #12
34193fec:	af00      	add	r7, sp, #0
34193fee:	6078      	str	r0, [r7, #4]
  SET_BIT(UCPDx->ICR, UCPD_ICR_TYPECEVT1CF);
34193ff0:	687b      	ldr	r3, [r7, #4]
34193ff2:	699b      	ldr	r3, [r3, #24]
34193ff4:	f443 4280 	orr.w	r2, r3, #16384	@ 0x4000
34193ff8:	687b      	ldr	r3, [r7, #4]
34193ffa:	619a      	str	r2, [r3, #24]
}
34193ffc:	bf00      	nop
34193ffe:	370c      	adds	r7, #12
34194000:	46bd      	mov	sp, r7
34194002:	f85d 7b04 	ldr.w	r7, [sp], #4
34194006:	4770      	bx	lr

34194008 <LL_UCPD_ClearFlag_RxMsgEnd>:
  * @rmtoll ICR          RXMSGENDIE         LL_UCPD_ClearFlag_RxMsgEnd
  * @param  UCPDx UCPD Instance
  * @retval None
  */
__STATIC_INLINE void LL_UCPD_ClearFlag_RxMsgEnd(UCPD_TypeDef *UCPDx)
{
34194008:	b480      	push	{r7}
3419400a:	b083      	sub	sp, #12
3419400c:	af00      	add	r7, sp, #0
3419400e:	6078      	str	r0, [r7, #4]
  SET_BIT(UCPDx->ICR, UCPD_ICR_RXMSGENDCF);
34194010:	687b      	ldr	r3, [r7, #4]
34194012:	699b      	ldr	r3, [r3, #24]
34194014:	f443 5280 	orr.w	r2, r3, #4096	@ 0x1000
34194018:	687b      	ldr	r3, [r7, #4]
3419401a:	619a      	str	r2, [r3, #24]
}
3419401c:	bf00      	nop
3419401e:	370c      	adds	r7, #12
34194020:	46bd      	mov	sp, r7
34194022:	f85d 7b04 	ldr.w	r7, [sp], #4
34194026:	4770      	bx	lr

34194028 <LL_UCPD_ClearFlag_RxOvr>:
  * @rmtoll ICR          RXOVRIE         LL_UCPD_ClearFlag_RxOvr
  * @param  UCPDx UCPD Instance
  * @retval None
  */
__STATIC_INLINE void LL_UCPD_ClearFlag_RxOvr(UCPD_TypeDef *UCPDx)
{
34194028:	b480      	push	{r7}
3419402a:	b083      	sub	sp, #12
3419402c:	af00      	add	r7, sp, #0
3419402e:	6078      	str	r0, [r7, #4]
  SET_BIT(UCPDx->ICR, UCPD_ICR_RXOVRCF);
34194030:	687b      	ldr	r3, [r7, #4]
34194032:	699b      	ldr	r3, [r3, #24]
34194034:	f443 6200 	orr.w	r2, r3, #2048	@ 0x800
34194038:	687b      	ldr	r3, [r7, #4]
3419403a:	619a      	str	r2, [r3, #24]
}
3419403c:	bf00      	nop
3419403e:	370c      	adds	r7, #12
34194040:	46bd      	mov	sp, r7
34194042:	f85d 7b04 	ldr.w	r7, [sp], #4
34194046:	4770      	bx	lr

34194048 <LL_UCPD_ClearFlag_RxHRST>:
  * @rmtoll ICR          RXHRSTDETIE         LL_UCPD_ClearFlag_RxHRST
  * @param  UCPDx UCPD Instance
  * @retval None
  */
__STATIC_INLINE void LL_UCPD_ClearFlag_RxHRST(UCPD_TypeDef *UCPDx)
{
34194048:	b480      	push	{r7}
3419404a:	b083      	sub	sp, #12
3419404c:	af00      	add	r7, sp, #0
3419404e:	6078      	str	r0, [r7, #4]
  SET_BIT(UCPDx->ICR, UCPD_ICR_RXHRSTDETCF);
34194050:	687b      	ldr	r3, [r7, #4]
34194052:	699b      	ldr	r3, [r3, #24]
34194054:	f443 6280 	orr.w	r2, r3, #1024	@ 0x400
34194058:	687b      	ldr	r3, [r7, #4]
3419405a:	619a      	str	r2, [r3, #24]
}
3419405c:	bf00      	nop
3419405e:	370c      	adds	r7, #12
34194060:	46bd      	mov	sp, r7
34194062:	f85d 7b04 	ldr.w	r7, [sp], #4
34194066:	4770      	bx	lr

34194068 <LL_UCPD_ClearFlag_RxOrderSet>:
  * @rmtoll ICR          RXORDDETIE         LL_UCPD_ClearFlag_RxOrderSet
  * @param  UCPDx UCPD Instance
  * @retval None
  */
__STATIC_INLINE void LL_UCPD_ClearFlag_RxOrderSet(UCPD_TypeDef *UCPDx)
{
34194068:	b480      	push	{r7}
3419406a:	b083      	sub	sp, #12
3419406c:	af00      	add	r7, sp, #0
3419406e:	6078      	str	r0, [r7, #4]
  SET_BIT(UCPDx->ICR, UCPD_ICR_RXORDDETCF);
34194070:	687b      	ldr	r3, [r7, #4]
34194072:	699b      	ldr	r3, [r3, #24]
34194074:	f443 7200 	orr.w	r2, r3, #512	@ 0x200
34194078:	687b      	ldr	r3, [r7, #4]
3419407a:	619a      	str	r2, [r3, #24]
}
3419407c:	bf00      	nop
3419407e:	370c      	adds	r7, #12
34194080:	46bd      	mov	sp, r7
34194082:	f85d 7b04 	ldr.w	r7, [sp], #4
34194086:	4770      	bx	lr

34194088 <LL_UCPD_ClearFlag_TxUND>:
  * @rmtoll ICR          TXUNDIE         LL_UCPD_ClearFlag_TxUND
  * @param  UCPDx UCPD Instance
  * @retval None
  */
__STATIC_INLINE void LL_UCPD_ClearFlag_TxUND(UCPD_TypeDef *UCPDx)
{
34194088:	b480      	push	{r7}
3419408a:	b083      	sub	sp, #12
3419408c:	af00      	add	r7, sp, #0
3419408e:	6078      	str	r0, [r7, #4]
  SET_BIT(UCPDx->ICR, UCPD_ICR_TXUNDCF);
34194090:	687b      	ldr	r3, [r7, #4]
34194092:	699b      	ldr	r3, [r3, #24]
34194094:	f043 0240 	orr.w	r2, r3, #64	@ 0x40
34194098:	687b      	ldr	r3, [r7, #4]
3419409a:	619a      	str	r2, [r3, #24]
}
3419409c:	bf00      	nop
3419409e:	370c      	adds	r7, #12
341940a0:	46bd      	mov	sp, r7
341940a2:	f85d 7b04 	ldr.w	r7, [sp], #4
341940a6:	4770      	bx	lr

341940a8 <LL_UCPD_ClearFlag_TxHRSTSENT>:
  * @rmtoll ICR          HRSTSENTIE         LL_UCPD_ClearFlag_TxHRSTSENT
  * @param  UCPDx UCPD Instance
  * @retval None
  */
__STATIC_INLINE void LL_UCPD_ClearFlag_TxHRSTSENT(UCPD_TypeDef *UCPDx)
{
341940a8:	b480      	push	{r7}
341940aa:	b083      	sub	sp, #12
341940ac:	af00      	add	r7, sp, #0
341940ae:	6078      	str	r0, [r7, #4]
  SET_BIT(UCPDx->ICR, UCPD_ICR_HRSTSENTCF);
341940b0:	687b      	ldr	r3, [r7, #4]
341940b2:	699b      	ldr	r3, [r3, #24]
341940b4:	f043 0220 	orr.w	r2, r3, #32
341940b8:	687b      	ldr	r3, [r7, #4]
341940ba:	619a      	str	r2, [r3, #24]
}
341940bc:	bf00      	nop
341940be:	370c      	adds	r7, #12
341940c0:	46bd      	mov	sp, r7
341940c2:	f85d 7b04 	ldr.w	r7, [sp], #4
341940c6:	4770      	bx	lr

341940c8 <LL_UCPD_ClearFlag_TxHRSTDISC>:
  * @rmtoll ICR          HRSTDISCIE         LL_UCPD_ClearFlag_TxHRSTDISC
  * @param  UCPDx UCPD Instance
  * @retval None
  */
__STATIC_INLINE void LL_UCPD_ClearFlag_TxHRSTDISC(UCPD_TypeDef *UCPDx)
{
341940c8:	b480      	push	{r7}
341940ca:	b083      	sub	sp, #12
341940cc:	af00      	add	r7, sp, #0
341940ce:	6078      	str	r0, [r7, #4]
  SET_BIT(UCPDx->ICR, UCPD_ICR_HRSTDISCCF);
341940d0:	687b      	ldr	r3, [r7, #4]
341940d2:	699b      	ldr	r3, [r3, #24]
341940d4:	f043 0210 	orr.w	r2, r3, #16
341940d8:	687b      	ldr	r3, [r7, #4]
341940da:	619a      	str	r2, [r3, #24]
}
341940dc:	bf00      	nop
341940de:	370c      	adds	r7, #12
341940e0:	46bd      	mov	sp, r7
341940e2:	f85d 7b04 	ldr.w	r7, [sp], #4
341940e6:	4770      	bx	lr

341940e8 <LL_UCPD_ClearFlag_TxMSGABT>:
  * @rmtoll ICR          TXMSGABTIE         LL_UCPD_ClearFlag_TxMSGABT
  * @param  UCPDx UCPD Instance
  * @retval None
  */
__STATIC_INLINE void LL_UCPD_ClearFlag_TxMSGABT(UCPD_TypeDef *UCPDx)
{
341940e8:	b480      	push	{r7}
341940ea:	b083      	sub	sp, #12
341940ec:	af00      	add	r7, sp, #0
341940ee:	6078      	str	r0, [r7, #4]
  SET_BIT(UCPDx->ICR, UCPD_ICR_TXMSGABTCF);
341940f0:	687b      	ldr	r3, [r7, #4]
341940f2:	699b      	ldr	r3, [r3, #24]
341940f4:	f043 0208 	orr.w	r2, r3, #8
341940f8:	687b      	ldr	r3, [r7, #4]
341940fa:	619a      	str	r2, [r3, #24]
}
341940fc:	bf00      	nop
341940fe:	370c      	adds	r7, #12
34194100:	46bd      	mov	sp, r7
34194102:	f85d 7b04 	ldr.w	r7, [sp], #4
34194106:	4770      	bx	lr

34194108 <LL_UCPD_ClearFlag_TxMSGSENT>:
  * @rmtoll ICR          TXMSGSENTIE         LL_UCPD_ClearFlag_TxMSGSENT
  * @param  UCPDx UCPD Instance
  * @retval None
  */
__STATIC_INLINE void LL_UCPD_ClearFlag_TxMSGSENT(UCPD_TypeDef *UCPDx)
{
34194108:	b480      	push	{r7}
3419410a:	b083      	sub	sp, #12
3419410c:	af00      	add	r7, sp, #0
3419410e:	6078      	str	r0, [r7, #4]
  SET_BIT(UCPDx->ICR, UCPD_ICR_TXMSGSENTCF);
34194110:	687b      	ldr	r3, [r7, #4]
34194112:	699b      	ldr	r3, [r3, #24]
34194114:	f043 0204 	orr.w	r2, r3, #4
34194118:	687b      	ldr	r3, [r7, #4]
3419411a:	619a      	str	r2, [r3, #24]
}
3419411c:	bf00      	nop
3419411e:	370c      	adds	r7, #12
34194120:	46bd      	mov	sp, r7
34194122:	f85d 7b04 	ldr.w	r7, [sp], #4
34194126:	4770      	bx	lr

34194128 <LL_UCPD_ClearFlag_TxMSGDISC>:
  * @rmtoll ICR          TXMSGDISCIE         LL_UCPD_ClearFlag_TxMSGDISC
  * @param  UCPDx UCPD Instance
  * @retval None
  */
__STATIC_INLINE void LL_UCPD_ClearFlag_TxMSGDISC(UCPD_TypeDef *UCPDx)
{
34194128:	b480      	push	{r7}
3419412a:	b083      	sub	sp, #12
3419412c:	af00      	add	r7, sp, #0
3419412e:	6078      	str	r0, [r7, #4]
  SET_BIT(UCPDx->ICR, UCPD_ICR_TXMSGDISCCF);
34194130:	687b      	ldr	r3, [r7, #4]
34194132:	699b      	ldr	r3, [r3, #24]
34194134:	f043 0202 	orr.w	r2, r3, #2
34194138:	687b      	ldr	r3, [r7, #4]
3419413a:	619a      	str	r2, [r3, #24]
}
3419413c:	bf00      	nop
3419413e:	370c      	adds	r7, #12
34194140:	46bd      	mov	sp, r7
34194142:	f85d 7b04 	ldr.w	r7, [sp], #4
34194146:	4770      	bx	lr

34194148 <USBPD_PORT0_IRQHandler>:
/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/
void PORTx_IRQHandler(uint8_t PortNum);

void USBPD_PORT0_IRQHandler(void)
{
34194148:	b580      	push	{r7, lr}
3419414a:	af00      	add	r7, sp, #0
  PORTx_IRQHandler(USBPD_PORT_0);
3419414c:	2000      	movs	r0, #0
3419414e:	f000 f803 	bl	34194158 <PORTx_IRQHandler>
}
34194152:	bf00      	nop
34194154:	bd80      	pop	{r7, pc}
	...

34194158 <PORTx_IRQHandler>:

void PORTx_IRQHandler(uint8_t PortNum)
{
34194158:	b580      	push	{r7, lr}
3419415a:	b084      	sub	sp, #16
3419415c:	af00      	add	r7, sp, #0
3419415e:	4603      	mov	r3, r0
34194160:	71fb      	strb	r3, [r7, #7]
  UCPD_TypeDef *hucpd = Ports[PortNum].husbpd;
34194162:	79fa      	ldrb	r2, [r7, #7]
34194164:	4998      	ldr	r1, [pc, #608]	@ (341943c8 <PORTx_IRQHandler+0x270>)
34194166:	4613      	mov	r3, r2
34194168:	00db      	lsls	r3, r3, #3
3419416a:	1a9b      	subs	r3, r3, r2
3419416c:	00db      	lsls	r3, r3, #3
3419416e:	440b      	add	r3, r1
34194170:	681b      	ldr	r3, [r3, #0]
34194172:	60fb      	str	r3, [r7, #12]
  uint32_t _interrupt = LL_UCPD_ReadReg(hucpd, SR);
34194174:	68fb      	ldr	r3, [r7, #12]
34194176:	695b      	ldr	r3, [r3, #20]
34194178:	60bb      	str	r3, [r7, #8]
  static uint8_t ovrflag = 0;

  if ((hucpd->IMR & _interrupt) != 0u)
3419417a:	68fb      	ldr	r3, [r7, #12]
3419417c:	691a      	ldr	r2, [r3, #16]
3419417e:	68bb      	ldr	r3, [r7, #8]
34194180:	4013      	ands	r3, r2
34194182:	2b00      	cmp	r3, #0
34194184:	f000 81d6 	beq.w	34194534 <PORTx_IRQHandler+0x3dc>
  {
    /* TXIS no need to enable it all the transfer are done by DMA */
    if (UCPD_SR_TXMSGDISC == (_interrupt & UCPD_SR_TXMSGDISC))
34194188:	68bb      	ldr	r3, [r7, #8]
3419418a:	f003 0302 	and.w	r3, r3, #2
3419418e:	2b00      	cmp	r3, #0
34194190:	d035      	beq.n	341941fe <PORTx_IRQHandler+0xa6>
    {
      /* Message has been discarded */
      LL_UCPD_ClearFlag_TxMSGDISC(hucpd);
34194192:	68f8      	ldr	r0, [r7, #12]
34194194:	f7ff ffc8 	bl	34194128 <LL_UCPD_ClearFlag_TxMSGDISC>
      SET_BIT(Ports[PortNum].hdmatx->CCR, DMA_CCR_SUSP | DMA_CCR_RESET);
34194198:	79fa      	ldrb	r2, [r7, #7]
3419419a:	498b      	ldr	r1, [pc, #556]	@ (341943c8 <PORTx_IRQHandler+0x270>)
3419419c:	4613      	mov	r3, r2
3419419e:	00db      	lsls	r3, r3, #3
341941a0:	1a9b      	subs	r3, r3, r2
341941a2:	00db      	lsls	r3, r3, #3
341941a4:	440b      	add	r3, r1
341941a6:	3304      	adds	r3, #4
341941a8:	681b      	ldr	r3, [r3, #0]
341941aa:	6959      	ldr	r1, [r3, #20]
341941ac:	79fa      	ldrb	r2, [r7, #7]
341941ae:	4886      	ldr	r0, [pc, #536]	@ (341943c8 <PORTx_IRQHandler+0x270>)
341941b0:	4613      	mov	r3, r2
341941b2:	00db      	lsls	r3, r3, #3
341941b4:	1a9b      	subs	r3, r3, r2
341941b6:	00db      	lsls	r3, r3, #3
341941b8:	4403      	add	r3, r0
341941ba:	3304      	adds	r3, #4
341941bc:	681b      	ldr	r3, [r3, #0]
341941be:	f041 0206 	orr.w	r2, r1, #6
341941c2:	615a      	str	r2, [r3, #20]
      while ((Ports[PortNum].hdmatx->CCR & DMA_CCR_EN) == DMA_CCR_EN);
341941c4:	bf00      	nop
341941c6:	79fa      	ldrb	r2, [r7, #7]
341941c8:	497f      	ldr	r1, [pc, #508]	@ (341943c8 <PORTx_IRQHandler+0x270>)
341941ca:	4613      	mov	r3, r2
341941cc:	00db      	lsls	r3, r3, #3
341941ce:	1a9b      	subs	r3, r3, r2
341941d0:	00db      	lsls	r3, r3, #3
341941d2:	440b      	add	r3, r1
341941d4:	3304      	adds	r3, #4
341941d6:	681b      	ldr	r3, [r3, #0]
341941d8:	695b      	ldr	r3, [r3, #20]
341941da:	f003 0301 	and.w	r3, r3, #1
341941de:	2b01      	cmp	r3, #1
341941e0:	d0f1      	beq.n	341941c6 <PORTx_IRQHandler+0x6e>
      Ports[PortNum].cbs.USBPD_HW_IF_TxCompleted(PortNum, 1);
341941e2:	79fa      	ldrb	r2, [r7, #7]
341941e4:	4978      	ldr	r1, [pc, #480]	@ (341943c8 <PORTx_IRQHandler+0x270>)
341941e6:	4613      	mov	r3, r2
341941e8:	00db      	lsls	r3, r3, #3
341941ea:	1a9b      	subs	r3, r3, r2
341941ec:	00db      	lsls	r3, r3, #3
341941ee:	440b      	add	r3, r1
341941f0:	3314      	adds	r3, #20
341941f2:	681b      	ldr	r3, [r3, #0]
341941f4:	79fa      	ldrb	r2, [r7, #7]
341941f6:	2101      	movs	r1, #1
341941f8:	4610      	mov	r0, r2
341941fa:	4798      	blx	r3
      return;
341941fc:	e19a      	b.n	34194534 <PORTx_IRQHandler+0x3dc>
    }

    if (UCPD_SR_TXMSGSENT == (_interrupt & UCPD_SR_TXMSGSENT))
341941fe:	68bb      	ldr	r3, [r7, #8]
34194200:	f003 0304 	and.w	r3, r3, #4
34194204:	2b00      	cmp	r3, #0
34194206:	d035      	beq.n	34194274 <PORTx_IRQHandler+0x11c>
    {
      /* Message has been fully transferred */
      LL_UCPD_ClearFlag_TxMSGSENT(hucpd);
34194208:	68f8      	ldr	r0, [r7, #12]
3419420a:	f7ff ff7d 	bl	34194108 <LL_UCPD_ClearFlag_TxMSGSENT>
      SET_BIT(Ports[PortNum].hdmatx->CCR, DMA_CCR_SUSP | DMA_CCR_RESET);
3419420e:	79fa      	ldrb	r2, [r7, #7]
34194210:	496d      	ldr	r1, [pc, #436]	@ (341943c8 <PORTx_IRQHandler+0x270>)
34194212:	4613      	mov	r3, r2
34194214:	00db      	lsls	r3, r3, #3
34194216:	1a9b      	subs	r3, r3, r2
34194218:	00db      	lsls	r3, r3, #3
3419421a:	440b      	add	r3, r1
3419421c:	3304      	adds	r3, #4
3419421e:	681b      	ldr	r3, [r3, #0]
34194220:	6959      	ldr	r1, [r3, #20]
34194222:	79fa      	ldrb	r2, [r7, #7]
34194224:	4868      	ldr	r0, [pc, #416]	@ (341943c8 <PORTx_IRQHandler+0x270>)
34194226:	4613      	mov	r3, r2
34194228:	00db      	lsls	r3, r3, #3
3419422a:	1a9b      	subs	r3, r3, r2
3419422c:	00db      	lsls	r3, r3, #3
3419422e:	4403      	add	r3, r0
34194230:	3304      	adds	r3, #4
34194232:	681b      	ldr	r3, [r3, #0]
34194234:	f041 0206 	orr.w	r2, r1, #6
34194238:	615a      	str	r2, [r3, #20]
      while ((Ports[PortNum].hdmatx->CCR & DMA_CCR_EN) == DMA_CCR_EN);
3419423a:	bf00      	nop
3419423c:	79fa      	ldrb	r2, [r7, #7]
3419423e:	4962      	ldr	r1, [pc, #392]	@ (341943c8 <PORTx_IRQHandler+0x270>)
34194240:	4613      	mov	r3, r2
34194242:	00db      	lsls	r3, r3, #3
34194244:	1a9b      	subs	r3, r3, r2
34194246:	00db      	lsls	r3, r3, #3
34194248:	440b      	add	r3, r1
3419424a:	3304      	adds	r3, #4
3419424c:	681b      	ldr	r3, [r3, #0]
3419424e:	695b      	ldr	r3, [r3, #20]
34194250:	f003 0301 	and.w	r3, r3, #1
34194254:	2b01      	cmp	r3, #1
34194256:	d0f1      	beq.n	3419423c <PORTx_IRQHandler+0xe4>
      Ports[PortNum].cbs.USBPD_HW_IF_TxCompleted(PortNum, 0);
34194258:	79fa      	ldrb	r2, [r7, #7]
3419425a:	495b      	ldr	r1, [pc, #364]	@ (341943c8 <PORTx_IRQHandler+0x270>)
3419425c:	4613      	mov	r3, r2
3419425e:	00db      	lsls	r3, r3, #3
34194260:	1a9b      	subs	r3, r3, r2
34194262:	00db      	lsls	r3, r3, #3
34194264:	440b      	add	r3, r1
34194266:	3314      	adds	r3, #20
34194268:	681b      	ldr	r3, [r3, #0]
3419426a:	79fa      	ldrb	r2, [r7, #7]
3419426c:	2100      	movs	r1, #0
3419426e:	4610      	mov	r0, r2
34194270:	4798      	blx	r3

#if defined(_LOW_POWER)
      UTIL_LPM_SetStopMode(0 == PortNum ? LPM_PE_0 : LPM_PE_1, UTIL_LPM_ENABLE);
#endif /* _LOW_POWER */
      return;
34194272:	e15f      	b.n	34194534 <PORTx_IRQHandler+0x3dc>
    }

    if (UCPD_SR_TXMSGABT == (_interrupt & UCPD_SR_TXMSGABT))
34194274:	68bb      	ldr	r3, [r7, #8]
34194276:	f003 0308 	and.w	r3, r3, #8
3419427a:	2b00      	cmp	r3, #0
3419427c:	d035      	beq.n	341942ea <PORTx_IRQHandler+0x192>
    {
      LL_UCPD_ClearFlag_TxMSGABT(hucpd);
3419427e:	68f8      	ldr	r0, [r7, #12]
34194280:	f7ff ff32 	bl	341940e8 <LL_UCPD_ClearFlag_TxMSGABT>
      SET_BIT(Ports[PortNum].hdmatx->CCR, DMA_CCR_SUSP | DMA_CCR_RESET);
34194284:	79fa      	ldrb	r2, [r7, #7]
34194286:	4950      	ldr	r1, [pc, #320]	@ (341943c8 <PORTx_IRQHandler+0x270>)
34194288:	4613      	mov	r3, r2
3419428a:	00db      	lsls	r3, r3, #3
3419428c:	1a9b      	subs	r3, r3, r2
3419428e:	00db      	lsls	r3, r3, #3
34194290:	440b      	add	r3, r1
34194292:	3304      	adds	r3, #4
34194294:	681b      	ldr	r3, [r3, #0]
34194296:	6959      	ldr	r1, [r3, #20]
34194298:	79fa      	ldrb	r2, [r7, #7]
3419429a:	484b      	ldr	r0, [pc, #300]	@ (341943c8 <PORTx_IRQHandler+0x270>)
3419429c:	4613      	mov	r3, r2
3419429e:	00db      	lsls	r3, r3, #3
341942a0:	1a9b      	subs	r3, r3, r2
341942a2:	00db      	lsls	r3, r3, #3
341942a4:	4403      	add	r3, r0
341942a6:	3304      	adds	r3, #4
341942a8:	681b      	ldr	r3, [r3, #0]
341942aa:	f041 0206 	orr.w	r2, r1, #6
341942ae:	615a      	str	r2, [r3, #20]
      while ((Ports[PortNum].hdmatx->CCR &  DMA_CCR_EN) == DMA_CCR_EN);
341942b0:	bf00      	nop
341942b2:	79fa      	ldrb	r2, [r7, #7]
341942b4:	4944      	ldr	r1, [pc, #272]	@ (341943c8 <PORTx_IRQHandler+0x270>)
341942b6:	4613      	mov	r3, r2
341942b8:	00db      	lsls	r3, r3, #3
341942ba:	1a9b      	subs	r3, r3, r2
341942bc:	00db      	lsls	r3, r3, #3
341942be:	440b      	add	r3, r1
341942c0:	3304      	adds	r3, #4
341942c2:	681b      	ldr	r3, [r3, #0]
341942c4:	695b      	ldr	r3, [r3, #20]
341942c6:	f003 0301 	and.w	r3, r3, #1
341942ca:	2b01      	cmp	r3, #1
341942cc:	d0f1      	beq.n	341942b2 <PORTx_IRQHandler+0x15a>
      Ports[PortNum].cbs.USBPD_HW_IF_TxCompleted(PortNum, 2);
341942ce:	79fa      	ldrb	r2, [r7, #7]
341942d0:	493d      	ldr	r1, [pc, #244]	@ (341943c8 <PORTx_IRQHandler+0x270>)
341942d2:	4613      	mov	r3, r2
341942d4:	00db      	lsls	r3, r3, #3
341942d6:	1a9b      	subs	r3, r3, r2
341942d8:	00db      	lsls	r3, r3, #3
341942da:	440b      	add	r3, r1
341942dc:	3314      	adds	r3, #20
341942de:	681b      	ldr	r3, [r3, #0]
341942e0:	79fa      	ldrb	r2, [r7, #7]
341942e2:	2102      	movs	r1, #2
341942e4:	4610      	mov	r0, r2
341942e6:	4798      	blx	r3
      return;
341942e8:	e124      	b.n	34194534 <PORTx_IRQHandler+0x3dc>
    }

    /* HRSTDISC : hard reset sending has been discarded */
    if (UCPD_SR_HRSTDISC == (_interrupt & UCPD_SR_HRSTDISC))
341942ea:	68bb      	ldr	r3, [r7, #8]
341942ec:	f003 0310 	and.w	r3, r3, #16
341942f0:	2b00      	cmp	r3, #0
341942f2:	d003      	beq.n	341942fc <PORTx_IRQHandler+0x1a4>
    {
      LL_UCPD_ClearFlag_TxHRSTDISC(hucpd);
341942f4:	68f8      	ldr	r0, [r7, #12]
341942f6:	f7ff fee7 	bl	341940c8 <LL_UCPD_ClearFlag_TxHRSTDISC>
      return;
341942fa:	e11b      	b.n	34194534 <PORTx_IRQHandler+0x3dc>
    }

    /* TXUND : tx underrun detected */
    if (UCPD_SR_HRSTSENT == (_interrupt & UCPD_SR_HRSTSENT))
341942fc:	68bb      	ldr	r3, [r7, #8]
341942fe:	f003 0320 	and.w	r3, r3, #32
34194302:	2b00      	cmp	r3, #0
34194304:	d010      	beq.n	34194328 <PORTx_IRQHandler+0x1d0>
    {
      /* Answer not expected by the stack */
      LL_UCPD_ClearFlag_TxHRSTSENT(hucpd);
34194306:	68f8      	ldr	r0, [r7, #12]
34194308:	f7ff fece 	bl	341940a8 <LL_UCPD_ClearFlag_TxHRSTSENT>
      Ports[PortNum].cbs.USBPD_HW_IF_TX_HardResetCompleted(PortNum, USBPD_SOPTYPE_HARD_RESET);
3419430c:	79fa      	ldrb	r2, [r7, #7]
3419430e:	492e      	ldr	r1, [pc, #184]	@ (341943c8 <PORTx_IRQHandler+0x270>)
34194310:	4613      	mov	r3, r2
34194312:	00db      	lsls	r3, r3, #3
34194314:	1a9b      	subs	r3, r3, r2
34194316:	00db      	lsls	r3, r3, #3
34194318:	440b      	add	r3, r1
3419431a:	3324      	adds	r3, #36	@ 0x24
3419431c:	681b      	ldr	r3, [r3, #0]
3419431e:	79fa      	ldrb	r2, [r7, #7]
34194320:	2105      	movs	r1, #5
34194322:	4610      	mov	r0, r2
34194324:	4798      	blx	r3
      return;
34194326:	e105      	b.n	34194534 <PORTx_IRQHandler+0x3dc>
    }

    /* TXUND : tx underrun detected */
    if (UCPD_SR_TXUND == (_interrupt & UCPD_SR_TXUND))
34194328:	68bb      	ldr	r3, [r7, #8]
3419432a:	f003 0340 	and.w	r3, r3, #64	@ 0x40
3419432e:	2b00      	cmp	r3, #0
34194330:	d003      	beq.n	3419433a <PORTx_IRQHandler+0x1e2>
    {
      /* Nothing to do.
         The port partner checks the message integrity with CRC, so PRL will repeat the sending.
         Can be used for debugging purpose */
      LL_UCPD_ClearFlag_TxUND(hucpd);
34194332:	68f8      	ldr	r0, [r7, #12]
34194334:	f7ff fea8 	bl	34194088 <LL_UCPD_ClearFlag_TxUND>
      return;
34194338:	e0fc      	b.n	34194534 <PORTx_IRQHandler+0x3dc>
    }

    /* RXNE : not needed the stack only perform transfer by DMA */
    /* RXORDDET: not needed so stack will not enabled this interrupt */
    if (UCPD_SR_RXORDDET == (_interrupt & UCPD_SR_RXORDDET))
3419433a:	68bb      	ldr	r3, [r7, #8]
3419433c:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34194340:	2b00      	cmp	r3, #0
34194342:	d01e      	beq.n	34194382 <PORTx_IRQHandler+0x22a>
    {
      if (LL_UCPD_RXORDSET_CABLE_RESET == hucpd->RX_ORDSET)
34194344:	68fb      	ldr	r3, [r7, #12]
34194346:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34194348:	2b05      	cmp	r3, #5
3419434a:	d10c      	bne.n	34194366 <PORTx_IRQHandler+0x20e>
      {
        /* Cable reset detected */
        Ports[PortNum].cbs.USBPD_HW_IF_RX_ResetIndication(PortNum, USBPD_SOPTYPE_CABLE_RESET);
3419434c:	79fa      	ldrb	r2, [r7, #7]
3419434e:	491e      	ldr	r1, [pc, #120]	@ (341943c8 <PORTx_IRQHandler+0x270>)
34194350:	4613      	mov	r3, r2
34194352:	00db      	lsls	r3, r3, #3
34194354:	1a9b      	subs	r3, r3, r2
34194356:	00db      	lsls	r3, r3, #3
34194358:	440b      	add	r3, r1
3419435a:	331c      	adds	r3, #28
3419435c:	681b      	ldr	r3, [r3, #0]
3419435e:	79fa      	ldrb	r2, [r7, #7]
34194360:	2106      	movs	r1, #6
34194362:	4610      	mov	r0, r2
34194364:	4798      	blx	r3
      }
      LL_UCPD_ClearFlag_RxOrderSet(hucpd);
34194366:	68f8      	ldr	r0, [r7, #12]
34194368:	f7ff fe7e 	bl	34194068 <LL_UCPD_ClearFlag_RxOrderSet>
#if defined(_LOW_POWER)
      UTIL_LPM_SetStopMode(0 == PortNum ? LPM_PE_0 : LPM_PE_1, UTIL_LPM_DISABLE);
#endif /* _LOW_POWER */

      /* Forbid message sending */
      Ports[PortNum].RXStatus = USBPD_TRUE;
3419436c:	79fa      	ldrb	r2, [r7, #7]
3419436e:	4916      	ldr	r1, [pc, #88]	@ (341943c8 <PORTx_IRQHandler+0x270>)
34194370:	4613      	mov	r3, r2
34194372:	00db      	lsls	r3, r3, #3
34194374:	1a9b      	subs	r3, r3, r2
34194376:	00db      	lsls	r3, r3, #3
34194378:	440b      	add	r3, r1
3419437a:	3334      	adds	r3, #52	@ 0x34
3419437c:	2201      	movs	r2, #1
3419437e:	701a      	strb	r2, [r3, #0]
      return;
34194380:	e0d8      	b.n	34194534 <PORTx_IRQHandler+0x3dc>
    }

    /* Check RXHRSTDET */
    if (UCPD_SR_RXHRSTDET == (_interrupt & UCPD_SR_RXHRSTDET))
34194382:	68bb      	ldr	r3, [r7, #8]
34194384:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34194388:	2b00      	cmp	r3, #0
3419438a:	d010      	beq.n	341943ae <PORTx_IRQHandler+0x256>
    {
      Ports[PortNum].cbs.USBPD_HW_IF_RX_ResetIndication(PortNum, USBPD_SOPTYPE_HARD_RESET);
3419438c:	79fa      	ldrb	r2, [r7, #7]
3419438e:	490e      	ldr	r1, [pc, #56]	@ (341943c8 <PORTx_IRQHandler+0x270>)
34194390:	4613      	mov	r3, r2
34194392:	00db      	lsls	r3, r3, #3
34194394:	1a9b      	subs	r3, r3, r2
34194396:	00db      	lsls	r3, r3, #3
34194398:	440b      	add	r3, r1
3419439a:	331c      	adds	r3, #28
3419439c:	681b      	ldr	r3, [r3, #0]
3419439e:	79fa      	ldrb	r2, [r7, #7]
341943a0:	2105      	movs	r1, #5
341943a2:	4610      	mov	r0, r2
341943a4:	4798      	blx	r3
      LL_UCPD_ClearFlag_RxHRST(hucpd);
341943a6:	68f8      	ldr	r0, [r7, #12]
341943a8:	f7ff fe4e 	bl	34194048 <LL_UCPD_ClearFlag_RxHRST>
      return;
341943ac:	e0c2      	b.n	34194534 <PORTx_IRQHandler+0x3dc>
    }

    /* Check RXOVR */
    if (UCPD_SR_RXOVR == (_interrupt & UCPD_SR_RXOVR))
341943ae:	68bb      	ldr	r3, [r7, #8]
341943b0:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
341943b4:	2b00      	cmp	r3, #0
341943b6:	d00b      	beq.n	341943d0 <PORTx_IRQHandler+0x278>
    {
      /* Nothing to do, the message will be discarded and port Partner will try sending again. */
      ovrflag = 1;
341943b8:	4b04      	ldr	r3, [pc, #16]	@ (341943cc <PORTx_IRQHandler+0x274>)
341943ba:	2201      	movs	r2, #1
341943bc:	701a      	strb	r2, [r3, #0]
      LL_UCPD_ClearFlag_RxOvr(hucpd);
341943be:	68f8      	ldr	r0, [r7, #12]
341943c0:	f7ff fe32 	bl	34194028 <LL_UCPD_ClearFlag_RxOvr>
      return;
341943c4:	e0b6      	b.n	34194534 <PORTx_IRQHandler+0x3dc>
341943c6:	bf00      	nop
341943c8:	341c2d7c 	.word	0x341c2d7c
341943cc:	341c2d78 	.word	0x341c2d78
    }

    /* Check RXMSGEND an Rx message has been received */
    if (UCPD_SR_RXMSGEND == (_interrupt & UCPD_SR_RXMSGEND))
341943d0:	68bb      	ldr	r3, [r7, #8]
341943d2:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
341943d6:	2b00      	cmp	r3, #0
341943d8:	f000 8091 	beq.w	341944fe <PORTx_IRQHandler+0x3a6>
    {
      Ports[PortNum].RXStatus = USBPD_FALSE;
341943dc:	79fa      	ldrb	r2, [r7, #7]
341943de:	4957      	ldr	r1, [pc, #348]	@ (3419453c <PORTx_IRQHandler+0x3e4>)
341943e0:	4613      	mov	r3, r2
341943e2:	00db      	lsls	r3, r3, #3
341943e4:	1a9b      	subs	r3, r3, r2
341943e6:	00db      	lsls	r3, r3, #3
341943e8:	440b      	add	r3, r1
341943ea:	3334      	adds	r3, #52	@ 0x34
341943ec:	2200      	movs	r2, #0
341943ee:	701a      	strb	r2, [r3, #0]

      /* For DMA mode, add a check to ensure the number of data received matches
         the number of data received by UCPD */
      LL_UCPD_ClearFlag_RxMsgEnd(hucpd);
341943f0:	68f8      	ldr	r0, [r7, #12]
341943f2:	f7ff fe09 	bl	34194008 <LL_UCPD_ClearFlag_RxMsgEnd>

      /* Disable DMA */
      SET_BIT(Ports[PortNum].hdmarx->CCR, DMA_CCR_SUSP | DMA_CCR_RESET);
341943f6:	79fa      	ldrb	r2, [r7, #7]
341943f8:	4950      	ldr	r1, [pc, #320]	@ (3419453c <PORTx_IRQHandler+0x3e4>)
341943fa:	4613      	mov	r3, r2
341943fc:	00db      	lsls	r3, r3, #3
341943fe:	1a9b      	subs	r3, r3, r2
34194400:	00db      	lsls	r3, r3, #3
34194402:	440b      	add	r3, r1
34194404:	3308      	adds	r3, #8
34194406:	681b      	ldr	r3, [r3, #0]
34194408:	6959      	ldr	r1, [r3, #20]
3419440a:	79fa      	ldrb	r2, [r7, #7]
3419440c:	484b      	ldr	r0, [pc, #300]	@ (3419453c <PORTx_IRQHandler+0x3e4>)
3419440e:	4613      	mov	r3, r2
34194410:	00db      	lsls	r3, r3, #3
34194412:	1a9b      	subs	r3, r3, r2
34194414:	00db      	lsls	r3, r3, #3
34194416:	4403      	add	r3, r0
34194418:	3308      	adds	r3, #8
3419441a:	681b      	ldr	r3, [r3, #0]
3419441c:	f041 0206 	orr.w	r2, r1, #6
34194420:	615a      	str	r2, [r3, #20]
      while ((Ports[PortNum].hdmarx->CCR & DMA_CCR_EN) == DMA_CCR_EN);
34194422:	bf00      	nop
34194424:	79fa      	ldrb	r2, [r7, #7]
34194426:	4945      	ldr	r1, [pc, #276]	@ (3419453c <PORTx_IRQHandler+0x3e4>)
34194428:	4613      	mov	r3, r2
3419442a:	00db      	lsls	r3, r3, #3
3419442c:	1a9b      	subs	r3, r3, r2
3419442e:	00db      	lsls	r3, r3, #3
34194430:	440b      	add	r3, r1
34194432:	3308      	adds	r3, #8
34194434:	681b      	ldr	r3, [r3, #0]
34194436:	695b      	ldr	r3, [r3, #20]
34194438:	f003 0301 	and.w	r3, r3, #1
3419443c:	2b01      	cmp	r3, #1
3419443e:	d0f1      	beq.n	34194424 <PORTx_IRQHandler+0x2cc>

      /* Ready for next transaction */
      WRITE_REG(Ports[PortNum].hdmarx->CDAR, (uint32_t)Ports[PortNum].ptr_RxBuff);
34194440:	79fa      	ldrb	r2, [r7, #7]
34194442:	493e      	ldr	r1, [pc, #248]	@ (3419453c <PORTx_IRQHandler+0x3e4>)
34194444:	4613      	mov	r3, r2
34194446:	00db      	lsls	r3, r3, #3
34194448:	1a9b      	subs	r3, r3, r2
3419444a:	00db      	lsls	r3, r3, #3
3419444c:	440b      	add	r3, r1
3419444e:	332c      	adds	r3, #44	@ 0x2c
34194450:	6818      	ldr	r0, [r3, #0]
34194452:	79fa      	ldrb	r2, [r7, #7]
34194454:	4939      	ldr	r1, [pc, #228]	@ (3419453c <PORTx_IRQHandler+0x3e4>)
34194456:	4613      	mov	r3, r2
34194458:	00db      	lsls	r3, r3, #3
3419445a:	1a9b      	subs	r3, r3, r2
3419445c:	00db      	lsls	r3, r3, #3
3419445e:	440b      	add	r3, r1
34194460:	3308      	adds	r3, #8
34194462:	681b      	ldr	r3, [r3, #0]
34194464:	4602      	mov	r2, r0
34194466:	651a      	str	r2, [r3, #80]	@ 0x50
      MODIFY_REG(Ports[PortNum].hdmarx->CBR1, DMA_CBR1_BNDT, (SIZE_MAX_PD_TRANSACTION_UNCHUNK & DMA_CBR1_BNDT));
34194468:	79fa      	ldrb	r2, [r7, #7]
3419446a:	4934      	ldr	r1, [pc, #208]	@ (3419453c <PORTx_IRQHandler+0x3e4>)
3419446c:	4613      	mov	r3, r2
3419446e:	00db      	lsls	r3, r3, #3
34194470:	1a9b      	subs	r3, r3, r2
34194472:	00db      	lsls	r3, r3, #3
34194474:	440b      	add	r3, r1
34194476:	3308      	adds	r3, #8
34194478:	681b      	ldr	r3, [r3, #0]
3419447a:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3419447c:	0c1a      	lsrs	r2, r3, #16
3419447e:	0412      	lsls	r2, r2, #16
34194480:	79f9      	ldrb	r1, [r7, #7]
34194482:	482e      	ldr	r0, [pc, #184]	@ (3419453c <PORTx_IRQHandler+0x3e4>)
34194484:	460b      	mov	r3, r1
34194486:	00db      	lsls	r3, r3, #3
34194488:	1a5b      	subs	r3, r3, r1
3419448a:	00db      	lsls	r3, r3, #3
3419448c:	4403      	add	r3, r0
3419448e:	3308      	adds	r3, #8
34194490:	681b      	ldr	r3, [r3, #0]
34194492:	f442 7284 	orr.w	r2, r2, #264	@ 0x108
34194496:	649a      	str	r2, [r3, #72]	@ 0x48

      /* Enable the DMA */
      SET_BIT(Ports[PortNum].hdmarx->CCR, DMA_CCR_EN);
34194498:	79fa      	ldrb	r2, [r7, #7]
3419449a:	4928      	ldr	r1, [pc, #160]	@ (3419453c <PORTx_IRQHandler+0x3e4>)
3419449c:	4613      	mov	r3, r2
3419449e:	00db      	lsls	r3, r3, #3
341944a0:	1a9b      	subs	r3, r3, r2
341944a2:	00db      	lsls	r3, r3, #3
341944a4:	440b      	add	r3, r1
341944a6:	3308      	adds	r3, #8
341944a8:	681b      	ldr	r3, [r3, #0]
341944aa:	6959      	ldr	r1, [r3, #20]
341944ac:	79fa      	ldrb	r2, [r7, #7]
341944ae:	4823      	ldr	r0, [pc, #140]	@ (3419453c <PORTx_IRQHandler+0x3e4>)
341944b0:	4613      	mov	r3, r2
341944b2:	00db      	lsls	r3, r3, #3
341944b4:	1a9b      	subs	r3, r3, r2
341944b6:	00db      	lsls	r3, r3, #3
341944b8:	4403      	add	r3, r0
341944ba:	3308      	adds	r3, #8
341944bc:	681b      	ldr	r3, [r3, #0]
341944be:	f041 0201 	orr.w	r2, r1, #1
341944c2:	615a      	str	r2, [r3, #20]
#if defined(_LOW_POWER)
      UTIL_LPM_SetStopMode(0 == PortNum ? LPM_PE_0 : LPM_PE_1, UTIL_LPM_ENABLE);
#endif /* _LOW_POWER */

      if (((_interrupt & UCPD_SR_RXERR) == 0u) && (ovrflag == 0u))
341944c4:	68bb      	ldr	r3, [r7, #8]
341944c6:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
341944ca:	2b00      	cmp	r3, #0
341944cc:	d113      	bne.n	341944f6 <PORTx_IRQHandler+0x39e>
341944ce:	4b1c      	ldr	r3, [pc, #112]	@ (34194540 <PORTx_IRQHandler+0x3e8>)
341944d0:	781b      	ldrb	r3, [r3, #0]
341944d2:	2b00      	cmp	r3, #0
341944d4:	d10f      	bne.n	341944f6 <PORTx_IRQHandler+0x39e>
      {
        /* Rx message has been received without error */
        Ports[PortNum].cbs.USBPD_HW_IF_RX_Completed(PortNum, hucpd->RX_ORDSET & UCPD_RX_ORDSET_RXORDSET);
341944d6:	79fa      	ldrb	r2, [r7, #7]
341944d8:	4918      	ldr	r1, [pc, #96]	@ (3419453c <PORTx_IRQHandler+0x3e4>)
341944da:	4613      	mov	r3, r2
341944dc:	00db      	lsls	r3, r3, #3
341944de:	1a9b      	subs	r3, r3, r2
341944e0:	00db      	lsls	r3, r3, #3
341944e2:	440b      	add	r3, r1
341944e4:	3320      	adds	r3, #32
341944e6:	681b      	ldr	r3, [r3, #0]
341944e8:	68fa      	ldr	r2, [r7, #12]
341944ea:	6a92      	ldr	r2, [r2, #40]	@ 0x28
341944ec:	f002 0107 	and.w	r1, r2, #7
341944f0:	79fa      	ldrb	r2, [r7, #7]
341944f2:	4610      	mov	r0, r2
341944f4:	4798      	blx	r3
      }
      ovrflag = 0;
341944f6:	4b12      	ldr	r3, [pc, #72]	@ (34194540 <PORTx_IRQHandler+0x3e8>)
341944f8:	2200      	movs	r2, #0
341944fa:	701a      	strb	r2, [r3, #0]
      return;
341944fc:	e01a      	b.n	34194534 <PORTx_IRQHandler+0x3dc>
    }

    /* Check TYPECEVT1IE/TYPECEVT1IE || check TYPECEVT2IE/TYPECEVT2IE */
    if ((UCPD_SR_TYPECEVT1 == (_interrupt & UCPD_SR_TYPECEVT1))
341944fe:	68bb      	ldr	r3, [r7, #8]
34194500:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
34194504:	2b00      	cmp	r3, #0
34194506:	d104      	bne.n	34194512 <PORTx_IRQHandler+0x3ba>
        || (UCPD_SR_TYPECEVT2 == (_interrupt & UCPD_SR_TYPECEVT2)))
34194508:	68bb      	ldr	r3, [r7, #8]
3419450a:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
3419450e:	2b00      	cmp	r3, #0
34194510:	d010      	beq.n	34194534 <PORTx_IRQHandler+0x3dc>
    {
      /* Clear both interrupt */
      LL_UCPD_ClearFlag_TypeCEventCC1(hucpd);
34194512:	68f8      	ldr	r0, [r7, #12]
34194514:	f7ff fd68 	bl	34193fe8 <LL_UCPD_ClearFlag_TypeCEventCC1>
      LL_UCPD_ClearFlag_TypeCEventCC2(hucpd);
34194518:	68f8      	ldr	r0, [r7, #12]
3419451a:	f7ff fd55 	bl	34193fc8 <LL_UCPD_ClearFlag_TypeCEventCC2>
      Ports[PortNum].USBPD_CAD_WakeUp();
3419451e:	79fa      	ldrb	r2, [r7, #7]
34194520:	4906      	ldr	r1, [pc, #24]	@ (3419453c <PORTx_IRQHandler+0x3e4>)
34194522:	4613      	mov	r3, r2
34194524:	00db      	lsls	r3, r3, #3
34194526:	1a9b      	subs	r3, r3, r2
34194528:	00db      	lsls	r3, r3, #3
3419452a:	440b      	add	r3, r1
3419452c:	3328      	adds	r3, #40	@ 0x28
3419452e:	681b      	ldr	r3, [r3, #0]
34194530:	4798      	blx	r3
      /* Wakeup CAD to check the detection event */
      return;
34194532:	bf00      	nop
    }

  }
}
34194534:	3710      	adds	r7, #16
34194536:	46bd      	mov	sp, r7
34194538:	bd80      	pop	{r7, pc}
3419453a:	bf00      	nop
3419453c:	341c2d7c 	.word	0x341c2d7c
34194540:	341c2d78 	.word	0x341c2d78

34194544 <LL_UCPD_TypeCDetectionCC2Enable>:
{
34194544:	b480      	push	{r7}
34194546:	b083      	sub	sp, #12
34194548:	af00      	add	r7, sp, #0
3419454a:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(UCPDx->CR, UCPD_CR_CC2TCDIS);
3419454c:	687b      	ldr	r3, [r7, #4]
3419454e:	68db      	ldr	r3, [r3, #12]
34194550:	f423 1200 	bic.w	r2, r3, #2097152	@ 0x200000
34194554:	687b      	ldr	r3, [r7, #4]
34194556:	60da      	str	r2, [r3, #12]
}
34194558:	bf00      	nop
3419455a:	370c      	adds	r7, #12
3419455c:	46bd      	mov	sp, r7
3419455e:	f85d 7b04 	ldr.w	r7, [sp], #4
34194562:	4770      	bx	lr

34194564 <LL_UCPD_TypeCDetectionCC2Disable>:
{
34194564:	b480      	push	{r7}
34194566:	b083      	sub	sp, #12
34194568:	af00      	add	r7, sp, #0
3419456a:	6078      	str	r0, [r7, #4]
  SET_BIT(UCPDx->CR, UCPD_CR_CC2TCDIS);
3419456c:	687b      	ldr	r3, [r7, #4]
3419456e:	68db      	ldr	r3, [r3, #12]
34194570:	f443 1200 	orr.w	r2, r3, #2097152	@ 0x200000
34194574:	687b      	ldr	r3, [r7, #4]
34194576:	60da      	str	r2, [r3, #12]
}
34194578:	bf00      	nop
3419457a:	370c      	adds	r7, #12
3419457c:	46bd      	mov	sp, r7
3419457e:	f85d 7b04 	ldr.w	r7, [sp], #4
34194582:	4770      	bx	lr

34194584 <LL_UCPD_TypeCDetectionCC1Enable>:
{
34194584:	b480      	push	{r7}
34194586:	b083      	sub	sp, #12
34194588:	af00      	add	r7, sp, #0
3419458a:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(UCPDx->CR, UCPD_CR_CC1TCDIS);
3419458c:	687b      	ldr	r3, [r7, #4]
3419458e:	68db      	ldr	r3, [r3, #12]
34194590:	f423 1280 	bic.w	r2, r3, #1048576	@ 0x100000
34194594:	687b      	ldr	r3, [r7, #4]
34194596:	60da      	str	r2, [r3, #12]
}
34194598:	bf00      	nop
3419459a:	370c      	adds	r7, #12
3419459c:	46bd      	mov	sp, r7
3419459e:	f85d 7b04 	ldr.w	r7, [sp], #4
341945a2:	4770      	bx	lr

341945a4 <LL_UCPD_TypeCDetectionCC1Disable>:
{
341945a4:	b480      	push	{r7}
341945a6:	b083      	sub	sp, #12
341945a8:	af00      	add	r7, sp, #0
341945aa:	6078      	str	r0, [r7, #4]
  SET_BIT(UCPDx->CR, UCPD_CR_CC1TCDIS);
341945ac:	687b      	ldr	r3, [r7, #4]
341945ae:	68db      	ldr	r3, [r3, #12]
341945b0:	f443 1280 	orr.w	r2, r3, #1048576	@ 0x100000
341945b4:	687b      	ldr	r3, [r7, #4]
341945b6:	60da      	str	r2, [r3, #12]
}
341945b8:	bf00      	nop
341945ba:	370c      	adds	r7, #12
341945bc:	46bd      	mov	sp, r7
341945be:	f85d 7b04 	ldr.w	r7, [sp], #4
341945c2:	4770      	bx	lr

341945c4 <LL_UCPD_SetccEnable>:
{
341945c4:	b480      	push	{r7}
341945c6:	b083      	sub	sp, #12
341945c8:	af00      	add	r7, sp, #0
341945ca:	6078      	str	r0, [r7, #4]
341945cc:	6039      	str	r1, [r7, #0]
  MODIFY_REG(UCPDx->CR, UCPD_CR_CCENABLE, CCEnable);
341945ce:	687b      	ldr	r3, [r7, #4]
341945d0:	68db      	ldr	r3, [r3, #12]
341945d2:	f423 6240 	bic.w	r2, r3, #3072	@ 0xc00
341945d6:	683b      	ldr	r3, [r7, #0]
341945d8:	431a      	orrs	r2, r3
341945da:	687b      	ldr	r3, [r7, #4]
341945dc:	60da      	str	r2, [r3, #12]
}
341945de:	bf00      	nop
341945e0:	370c      	adds	r7, #12
341945e2:	46bd      	mov	sp, r7
341945e4:	f85d 7b04 	ldr.w	r7, [sp], #4
341945e8:	4770      	bx	lr

341945ea <LL_UCPD_SetSNKRole>:
{
341945ea:	b480      	push	{r7}
341945ec:	b083      	sub	sp, #12
341945ee:	af00      	add	r7, sp, #0
341945f0:	6078      	str	r0, [r7, #4]
  SET_BIT(UCPDx->CR, UCPD_CR_ANAMODE);
341945f2:	687b      	ldr	r3, [r7, #4]
341945f4:	68db      	ldr	r3, [r3, #12]
341945f6:	f443 7200 	orr.w	r2, r3, #512	@ 0x200
341945fa:	687b      	ldr	r3, [r7, #4]
341945fc:	60da      	str	r2, [r3, #12]
}
341945fe:	bf00      	nop
34194600:	370c      	adds	r7, #12
34194602:	46bd      	mov	sp, r7
34194604:	f85d 7b04 	ldr.w	r7, [sp], #4
34194608:	4770      	bx	lr

3419460a <LL_UCPD_SetSRCRole>:
{
3419460a:	b480      	push	{r7}
3419460c:	b083      	sub	sp, #12
3419460e:	af00      	add	r7, sp, #0
34194610:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(UCPDx->CR, UCPD_CR_ANAMODE);
34194612:	687b      	ldr	r3, [r7, #4]
34194614:	68db      	ldr	r3, [r3, #12]
34194616:	f423 7200 	bic.w	r2, r3, #512	@ 0x200
3419461a:	687b      	ldr	r3, [r7, #4]
3419461c:	60da      	str	r2, [r3, #12]
}
3419461e:	bf00      	nop
34194620:	370c      	adds	r7, #12
34194622:	46bd      	mov	sp, r7
34194624:	f85d 7b04 	ldr.w	r7, [sp], #4
34194628:	4770      	bx	lr

3419462a <LL_UCPD_SetRpResistor>:
{
3419462a:	b480      	push	{r7}
3419462c:	b083      	sub	sp, #12
3419462e:	af00      	add	r7, sp, #0
34194630:	6078      	str	r0, [r7, #4]
34194632:	6039      	str	r1, [r7, #0]
  MODIFY_REG(UCPDx->CR, UCPD_CR_ANASUBMODE,  Resistor);
34194634:	687b      	ldr	r3, [r7, #4]
34194636:	68db      	ldr	r3, [r3, #12]
34194638:	f423 72c0 	bic.w	r2, r3, #384	@ 0x180
3419463c:	683b      	ldr	r3, [r7, #0]
3419463e:	431a      	orrs	r2, r3
34194640:	687b      	ldr	r3, [r7, #4]
34194642:	60da      	str	r2, [r3, #12]
}
34194644:	bf00      	nop
34194646:	370c      	adds	r7, #12
34194648:	46bd      	mov	sp, r7
3419464a:	f85d 7b04 	ldr.w	r7, [sp], #4
3419464e:	4770      	bx	lr

34194650 <LL_UCPD_RxDisable>:
{
34194650:	b480      	push	{r7}
34194652:	b083      	sub	sp, #12
34194654:	af00      	add	r7, sp, #0
34194656:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(UCPDx->CR, UCPD_CR_PHYRXEN);
34194658:	687b      	ldr	r3, [r7, #4]
3419465a:	68db      	ldr	r3, [r3, #12]
3419465c:	f023 0220 	bic.w	r2, r3, #32
34194660:	687b      	ldr	r3, [r7, #4]
34194662:	60da      	str	r2, [r3, #12]
}
34194664:	bf00      	nop
34194666:	370c      	adds	r7, #12
34194668:	46bd      	mov	sp, r7
3419466a:	f85d 7b04 	ldr.w	r7, [sp], #4
3419466e:	4770      	bx	lr

34194670 <USBPDM1_AssertRp>:
  * @brief  Assert Rp resistors
  * @param  PortNum Port
  * @retval None
  */
void USBPDM1_AssertRp(uint8_t PortNum)
{
34194670:	b580      	push	{r7, lr}
34194672:	b082      	sub	sp, #8
34194674:	af00      	add	r7, sp, #0
34194676:	4603      	mov	r3, r0
34194678:	71fb      	strb	r3, [r7, #7]
  switch (Ports[PortNum].params->RpResistor)
3419467a:	79fa      	ldrb	r2, [r7, #7]
3419467c:	4949      	ldr	r1, [pc, #292]	@ (341947a4 <USBPDM1_AssertRp+0x134>)
3419467e:	4613      	mov	r3, r2
34194680:	00db      	lsls	r3, r3, #3
34194682:	1a9b      	subs	r3, r3, r2
34194684:	00db      	lsls	r3, r3, #3
34194686:	440b      	add	r3, r1
34194688:	3310      	adds	r3, #16
3419468a:	681b      	ldr	r3, [r3, #0]
3419468c:	789b      	ldrb	r3, [r3, #2]
3419468e:	f3c3 0301 	ubfx	r3, r3, #0, #2
34194692:	b2db      	uxtb	r3, r3
34194694:	2b02      	cmp	r3, #2
34194696:	d021      	beq.n	341946dc <USBPDM1_AssertRp+0x6c>
34194698:	2b02      	cmp	r3, #2
3419469a:	dc2d      	bgt.n	341946f8 <USBPDM1_AssertRp+0x88>
3419469c:	2b00      	cmp	r3, #0
3419469e:	d002      	beq.n	341946a6 <USBPDM1_AssertRp+0x36>
341946a0:	2b01      	cmp	r3, #1
341946a2:	d00d      	beq.n	341946c0 <USBPDM1_AssertRp+0x50>
      break;
    case vRp_3_0A:
      LL_UCPD_SetRpResistor(Ports[PortNum].husbpd, LL_UCPD_RESISTOR_3_0A);
      break;
    default:
      break;
341946a4:	e028      	b.n	341946f8 <USBPDM1_AssertRp+0x88>
      LL_UCPD_SetRpResistor(Ports[PortNum].husbpd, LL_UCPD_RESISTOR_DEFAULT);
341946a6:	79fa      	ldrb	r2, [r7, #7]
341946a8:	493e      	ldr	r1, [pc, #248]	@ (341947a4 <USBPDM1_AssertRp+0x134>)
341946aa:	4613      	mov	r3, r2
341946ac:	00db      	lsls	r3, r3, #3
341946ae:	1a9b      	subs	r3, r3, r2
341946b0:	00db      	lsls	r3, r3, #3
341946b2:	440b      	add	r3, r1
341946b4:	681b      	ldr	r3, [r3, #0]
341946b6:	2180      	movs	r1, #128	@ 0x80
341946b8:	4618      	mov	r0, r3
341946ba:	f7ff ffb6 	bl	3419462a <LL_UCPD_SetRpResistor>
      break;
341946be:	e01c      	b.n	341946fa <USBPDM1_AssertRp+0x8a>
      LL_UCPD_SetRpResistor(Ports[PortNum].husbpd, LL_UCPD_RESISTOR_1_5A);
341946c0:	79fa      	ldrb	r2, [r7, #7]
341946c2:	4938      	ldr	r1, [pc, #224]	@ (341947a4 <USBPDM1_AssertRp+0x134>)
341946c4:	4613      	mov	r3, r2
341946c6:	00db      	lsls	r3, r3, #3
341946c8:	1a9b      	subs	r3, r3, r2
341946ca:	00db      	lsls	r3, r3, #3
341946cc:	440b      	add	r3, r1
341946ce:	681b      	ldr	r3, [r3, #0]
341946d0:	f44f 7180 	mov.w	r1, #256	@ 0x100
341946d4:	4618      	mov	r0, r3
341946d6:	f7ff ffa8 	bl	3419462a <LL_UCPD_SetRpResistor>
      break;
341946da:	e00e      	b.n	341946fa <USBPDM1_AssertRp+0x8a>
      LL_UCPD_SetRpResistor(Ports[PortNum].husbpd, LL_UCPD_RESISTOR_3_0A);
341946dc:	79fa      	ldrb	r2, [r7, #7]
341946de:	4931      	ldr	r1, [pc, #196]	@ (341947a4 <USBPDM1_AssertRp+0x134>)
341946e0:	4613      	mov	r3, r2
341946e2:	00db      	lsls	r3, r3, #3
341946e4:	1a9b      	subs	r3, r3, r2
341946e6:	00db      	lsls	r3, r3, #3
341946e8:	440b      	add	r3, r1
341946ea:	681b      	ldr	r3, [r3, #0]
341946ec:	f44f 71c0 	mov.w	r1, #384	@ 0x180
341946f0:	4618      	mov	r0, r3
341946f2:	f7ff ff9a 	bl	3419462a <LL_UCPD_SetRpResistor>
      break;
341946f6:	e000      	b.n	341946fa <USBPDM1_AssertRp+0x8a>
      break;
341946f8:	bf00      	nop
  }
  LL_UCPD_SetccEnable(Ports[PortNum].husbpd, LL_UCPD_CCENABLE_NONE);
341946fa:	79fa      	ldrb	r2, [r7, #7]
341946fc:	4929      	ldr	r1, [pc, #164]	@ (341947a4 <USBPDM1_AssertRp+0x134>)
341946fe:	4613      	mov	r3, r2
34194700:	00db      	lsls	r3, r3, #3
34194702:	1a9b      	subs	r3, r3, r2
34194704:	00db      	lsls	r3, r3, #3
34194706:	440b      	add	r3, r1
34194708:	681b      	ldr	r3, [r3, #0]
3419470a:	2100      	movs	r1, #0
3419470c:	4618      	mov	r0, r3
3419470e:	f7ff ff59 	bl	341945c4 <LL_UCPD_SetccEnable>
  LL_UCPD_SetSRCRole(Ports[PortNum].husbpd);
34194712:	79fa      	ldrb	r2, [r7, #7]
34194714:	4923      	ldr	r1, [pc, #140]	@ (341947a4 <USBPDM1_AssertRp+0x134>)
34194716:	4613      	mov	r3, r2
34194718:	00db      	lsls	r3, r3, #3
3419471a:	1a9b      	subs	r3, r3, r2
3419471c:	00db      	lsls	r3, r3, #3
3419471e:	440b      	add	r3, r1
34194720:	681b      	ldr	r3, [r3, #0]
34194722:	4618      	mov	r0, r3
34194724:	f7ff ff71 	bl	3419460a <LL_UCPD_SetSRCRole>
  if (CCNONE == Ports[PortNum].CCx)
34194728:	79fa      	ldrb	r2, [r7, #7]
3419472a:	491e      	ldr	r1, [pc, #120]	@ (341947a4 <USBPDM1_AssertRp+0x134>)
3419472c:	4613      	mov	r3, r2
3419472e:	00db      	lsls	r3, r3, #3
34194730:	1a9b      	subs	r3, r3, r2
34194732:	00db      	lsls	r3, r3, #3
34194734:	440b      	add	r3, r1
34194736:	3330      	adds	r3, #48	@ 0x30
34194738:	681b      	ldr	r3, [r3, #0]
3419473a:	2b00      	cmp	r3, #0
3419473c:	d10d      	bne.n	3419475a <USBPDM1_AssertRp+0xea>
  {
    LL_UCPD_SetccEnable(Ports[PortNum].husbpd, LL_UCPD_CCENABLE_CC1CC2);
3419473e:	79fa      	ldrb	r2, [r7, #7]
34194740:	4918      	ldr	r1, [pc, #96]	@ (341947a4 <USBPDM1_AssertRp+0x134>)
34194742:	4613      	mov	r3, r2
34194744:	00db      	lsls	r3, r3, #3
34194746:	1a9b      	subs	r3, r3, r2
34194748:	00db      	lsls	r3, r3, #3
3419474a:	440b      	add	r3, r1
3419474c:	681b      	ldr	r3, [r3, #0]
3419474e:	f44f 6140 	mov.w	r1, #3072	@ 0xc00
34194752:	4618      	mov	r0, r3
34194754:	f7ff ff36 	bl	341945c4 <LL_UCPD_SetccEnable>
34194758:	e01a      	b.n	34194790 <USBPDM1_AssertRp+0x120>
  }
  else
  {
    LL_UCPD_SetccEnable(Ports[PortNum].husbpd,
3419475a:	79fa      	ldrb	r2, [r7, #7]
3419475c:	4911      	ldr	r1, [pc, #68]	@ (341947a4 <USBPDM1_AssertRp+0x134>)
3419475e:	4613      	mov	r3, r2
34194760:	00db      	lsls	r3, r3, #3
34194762:	1a9b      	subs	r3, r3, r2
34194764:	00db      	lsls	r3, r3, #3
34194766:	440b      	add	r3, r1
34194768:	6818      	ldr	r0, [r3, #0]
                        (Ports[PortNum].CCx == CC1) ? LL_UCPD_CCENABLE_CC1 : LL_UCPD_CCENABLE_CC2);
3419476a:	79fa      	ldrb	r2, [r7, #7]
3419476c:	490d      	ldr	r1, [pc, #52]	@ (341947a4 <USBPDM1_AssertRp+0x134>)
3419476e:	4613      	mov	r3, r2
34194770:	00db      	lsls	r3, r3, #3
34194772:	1a9b      	subs	r3, r3, r2
34194774:	00db      	lsls	r3, r3, #3
34194776:	440b      	add	r3, r1
34194778:	3330      	adds	r3, #48	@ 0x30
3419477a:	681b      	ldr	r3, [r3, #0]
    LL_UCPD_SetccEnable(Ports[PortNum].husbpd,
3419477c:	2b01      	cmp	r3, #1
3419477e:	d102      	bne.n	34194786 <USBPDM1_AssertRp+0x116>
34194780:	f44f 6380 	mov.w	r3, #1024	@ 0x400
34194784:	e001      	b.n	3419478a <USBPDM1_AssertRp+0x11a>
34194786:	f44f 6300 	mov.w	r3, #2048	@ 0x800
3419478a:	4619      	mov	r1, r3
3419478c:	f7ff ff1a 	bl	341945c4 <LL_UCPD_SetccEnable>
  }

#if defined(TCPP0203_SUPPORT)
  BSP_USBPD_PWR_SetRole(PortNum, POWER_ROLE_SOURCE);
34194790:	79fb      	ldrb	r3, [r7, #7]
34194792:	2100      	movs	r1, #0
34194794:	4618      	mov	r0, r3
34194796:	f7ef ff0d 	bl	341845b4 <BSP_USBPD_PWR_SetRole>
#endif /* TCPP0203_SUPPORT */
}
3419479a:	bf00      	nop
3419479c:	3708      	adds	r7, #8
3419479e:	46bd      	mov	sp, r7
341947a0:	bd80      	pop	{r7, pc}
341947a2:	bf00      	nop
341947a4:	341c2d7c 	.word	0x341c2d7c

341947a8 <USBPDM1_DeAssertRp>:
  * @brief  De-assert Rp resistors
  * @param  PortNum Port
  * @retval None
  */
void USBPDM1_DeAssertRp(uint8_t PortNum)
{
341947a8:	b480      	push	{r7}
341947aa:	b083      	sub	sp, #12
341947ac:	af00      	add	r7, sp, #0
341947ae:	4603      	mov	r3, r0
341947b0:	71fb      	strb	r3, [r7, #7]
  /* Not needed on STM32N6xx, so nothing to do, keep only for compatibility */
  UNUSED(PortNum);
}
341947b2:	bf00      	nop
341947b4:	370c      	adds	r7, #12
341947b6:	46bd      	mov	sp, r7
341947b8:	f85d 7b04 	ldr.w	r7, [sp], #4
341947bc:	4770      	bx	lr
	...

341947c0 <USBPDM1_AssertRd>:
  * @brief  Assert Rd resistors
  * @param  PortNum Port
  * @retval None
  */
void USBPDM1_AssertRd(uint8_t PortNum)
{
341947c0:	b580      	push	{r7, lr}
341947c2:	b082      	sub	sp, #8
341947c4:	af00      	add	r7, sp, #0
341947c6:	4603      	mov	r3, r0
341947c8:	71fb      	strb	r3, [r7, #7]
  LL_UCPD_TypeCDetectionCC2Disable(Ports[PortNum].husbpd);
341947ca:	79fa      	ldrb	r2, [r7, #7]
341947cc:	4940      	ldr	r1, [pc, #256]	@ (341948d0 <USBPDM1_AssertRd+0x110>)
341947ce:	4613      	mov	r3, r2
341947d0:	00db      	lsls	r3, r3, #3
341947d2:	1a9b      	subs	r3, r3, r2
341947d4:	00db      	lsls	r3, r3, #3
341947d6:	440b      	add	r3, r1
341947d8:	681b      	ldr	r3, [r3, #0]
341947da:	4618      	mov	r0, r3
341947dc:	f7ff fec2 	bl	34194564 <LL_UCPD_TypeCDetectionCC2Disable>
  LL_UCPD_TypeCDetectionCC1Disable(Ports[PortNum].husbpd);
341947e0:	79fa      	ldrb	r2, [r7, #7]
341947e2:	493b      	ldr	r1, [pc, #236]	@ (341948d0 <USBPDM1_AssertRd+0x110>)
341947e4:	4613      	mov	r3, r2
341947e6:	00db      	lsls	r3, r3, #3
341947e8:	1a9b      	subs	r3, r3, r2
341947ea:	00db      	lsls	r3, r3, #3
341947ec:	440b      	add	r3, r1
341947ee:	681b      	ldr	r3, [r3, #0]
341947f0:	4618      	mov	r0, r3
341947f2:	f7ff fed7 	bl	341945a4 <LL_UCPD_TypeCDetectionCC1Disable>

  LL_UCPD_SetccEnable(Ports[PortNum].husbpd, LL_UCPD_CCENABLE_NONE);
341947f6:	79fa      	ldrb	r2, [r7, #7]
341947f8:	4935      	ldr	r1, [pc, #212]	@ (341948d0 <USBPDM1_AssertRd+0x110>)
341947fa:	4613      	mov	r3, r2
341947fc:	00db      	lsls	r3, r3, #3
341947fe:	1a9b      	subs	r3, r3, r2
34194800:	00db      	lsls	r3, r3, #3
34194802:	440b      	add	r3, r1
34194804:	681b      	ldr	r3, [r3, #0]
34194806:	2100      	movs	r1, #0
34194808:	4618      	mov	r0, r3
3419480a:	f7ff fedb 	bl	341945c4 <LL_UCPD_SetccEnable>
  LL_UCPD_SetSNKRole(Ports[PortNum].husbpd);
3419480e:	79fa      	ldrb	r2, [r7, #7]
34194810:	492f      	ldr	r1, [pc, #188]	@ (341948d0 <USBPDM1_AssertRd+0x110>)
34194812:	4613      	mov	r3, r2
34194814:	00db      	lsls	r3, r3, #3
34194816:	1a9b      	subs	r3, r3, r2
34194818:	00db      	lsls	r3, r3, #3
3419481a:	440b      	add	r3, r1
3419481c:	681b      	ldr	r3, [r3, #0]
3419481e:	4618      	mov	r0, r3
34194820:	f7ff fee3 	bl	341945ea <LL_UCPD_SetSNKRole>
  if (CCNONE == Ports[PortNum].CCx)
34194824:	79fa      	ldrb	r2, [r7, #7]
34194826:	492a      	ldr	r1, [pc, #168]	@ (341948d0 <USBPDM1_AssertRd+0x110>)
34194828:	4613      	mov	r3, r2
3419482a:	00db      	lsls	r3, r3, #3
3419482c:	1a9b      	subs	r3, r3, r2
3419482e:	00db      	lsls	r3, r3, #3
34194830:	440b      	add	r3, r1
34194832:	3330      	adds	r3, #48	@ 0x30
34194834:	681b      	ldr	r3, [r3, #0]
34194836:	2b00      	cmp	r3, #0
34194838:	d10d      	bne.n	34194856 <USBPDM1_AssertRd+0x96>
  {
    LL_UCPD_SetccEnable(Ports[PortNum].husbpd, LL_UCPD_CCENABLE_CC1CC2);
3419483a:	79fa      	ldrb	r2, [r7, #7]
3419483c:	4924      	ldr	r1, [pc, #144]	@ (341948d0 <USBPDM1_AssertRd+0x110>)
3419483e:	4613      	mov	r3, r2
34194840:	00db      	lsls	r3, r3, #3
34194842:	1a9b      	subs	r3, r3, r2
34194844:	00db      	lsls	r3, r3, #3
34194846:	440b      	add	r3, r1
34194848:	681b      	ldr	r3, [r3, #0]
3419484a:	f44f 6140 	mov.w	r1, #3072	@ 0xc00
3419484e:	4618      	mov	r0, r3
34194850:	f7ff feb8 	bl	341945c4 <LL_UCPD_SetccEnable>
34194854:	e01a      	b.n	3419488c <USBPDM1_AssertRd+0xcc>
  }
  else
  {
    LL_UCPD_SetccEnable(Ports[PortNum].husbpd,
34194856:	79fa      	ldrb	r2, [r7, #7]
34194858:	491d      	ldr	r1, [pc, #116]	@ (341948d0 <USBPDM1_AssertRd+0x110>)
3419485a:	4613      	mov	r3, r2
3419485c:	00db      	lsls	r3, r3, #3
3419485e:	1a9b      	subs	r3, r3, r2
34194860:	00db      	lsls	r3, r3, #3
34194862:	440b      	add	r3, r1
34194864:	6818      	ldr	r0, [r3, #0]
                        (Ports[PortNum].CCx == CC1) ? LL_UCPD_CCENABLE_CC1 : LL_UCPD_CCENABLE_CC2);
34194866:	79fa      	ldrb	r2, [r7, #7]
34194868:	4919      	ldr	r1, [pc, #100]	@ (341948d0 <USBPDM1_AssertRd+0x110>)
3419486a:	4613      	mov	r3, r2
3419486c:	00db      	lsls	r3, r3, #3
3419486e:	1a9b      	subs	r3, r3, r2
34194870:	00db      	lsls	r3, r3, #3
34194872:	440b      	add	r3, r1
34194874:	3330      	adds	r3, #48	@ 0x30
34194876:	681b      	ldr	r3, [r3, #0]
    LL_UCPD_SetccEnable(Ports[PortNum].husbpd,
34194878:	2b01      	cmp	r3, #1
3419487a:	d102      	bne.n	34194882 <USBPDM1_AssertRd+0xc2>
3419487c:	f44f 6380 	mov.w	r3, #1024	@ 0x400
34194880:	e001      	b.n	34194886 <USBPDM1_AssertRd+0xc6>
34194882:	f44f 6300 	mov.w	r3, #2048	@ 0x800
34194886:	4619      	mov	r1, r3
34194888:	f7ff fe9c 	bl	341945c4 <LL_UCPD_SetccEnable>
  }

  HAL_Delay(1);
3419488c:	2001      	movs	r0, #1
3419488e:	f7f0 fe9f 	bl	341855d0 <HAL_Delay>

#ifndef _LOW_POWER
  LL_UCPD_TypeCDetectionCC2Enable(Ports[PortNum].husbpd);
34194892:	79fa      	ldrb	r2, [r7, #7]
34194894:	490e      	ldr	r1, [pc, #56]	@ (341948d0 <USBPDM1_AssertRd+0x110>)
34194896:	4613      	mov	r3, r2
34194898:	00db      	lsls	r3, r3, #3
3419489a:	1a9b      	subs	r3, r3, r2
3419489c:	00db      	lsls	r3, r3, #3
3419489e:	440b      	add	r3, r1
341948a0:	681b      	ldr	r3, [r3, #0]
341948a2:	4618      	mov	r0, r3
341948a4:	f7ff fe4e 	bl	34194544 <LL_UCPD_TypeCDetectionCC2Enable>
  LL_UCPD_TypeCDetectionCC1Enable(Ports[PortNum].husbpd);
341948a8:	79fa      	ldrb	r2, [r7, #7]
341948aa:	4909      	ldr	r1, [pc, #36]	@ (341948d0 <USBPDM1_AssertRd+0x110>)
341948ac:	4613      	mov	r3, r2
341948ae:	00db      	lsls	r3, r3, #3
341948b0:	1a9b      	subs	r3, r3, r2
341948b2:	00db      	lsls	r3, r3, #3
341948b4:	440b      	add	r3, r1
341948b6:	681b      	ldr	r3, [r3, #0]
341948b8:	4618      	mov	r0, r3
341948ba:	f7ff fe63 	bl	34194584 <LL_UCPD_TypeCDetectionCC1Enable>
#endif /* _LOW_POWER */

#if defined(TCPP0203_SUPPORT)
  BSP_USBPD_PWR_SetRole(PortNum, POWER_ROLE_SINK);
341948be:	79fb      	ldrb	r3, [r7, #7]
341948c0:	2101      	movs	r1, #1
341948c2:	4618      	mov	r0, r3
341948c4:	f7ef fe76 	bl	341845b4 <BSP_USBPD_PWR_SetRole>
#endif /* TCPP0203_SUPPORT */
}
341948c8:	bf00      	nop
341948ca:	3708      	adds	r7, #8
341948cc:	46bd      	mov	sp, r7
341948ce:	bd80      	pop	{r7, pc}
341948d0:	341c2d7c 	.word	0x341c2d7c

341948d4 <USBPDM1_DeAssertRd>:
  * @brief  Assert Rd resistors
  * @param  PortNum Port
  * @retval none
  */
void USBPDM1_DeAssertRd(uint8_t PortNum)
{
341948d4:	b480      	push	{r7}
341948d6:	b083      	sub	sp, #12
341948d8:	af00      	add	r7, sp, #0
341948da:	4603      	mov	r3, r0
341948dc:	71fb      	strb	r3, [r7, #7]
  /* Not needed on STM32N6xx, so nothing to do, keep only for compatibility */
  UNUSED(PortNum);
}
341948de:	bf00      	nop
341948e0:	370c      	adds	r7, #12
341948e2:	46bd      	mov	sp, r7
341948e4:	f85d 7b04 	ldr.w	r7, [sp], #4
341948e8:	4770      	bx	lr
	...

341948ec <USBPDM1_EnterErrorRecovery>:
  * @brief  Enter error recovery
  * @param  PortNum Port
  * @retval None
  */
void USBPDM1_EnterErrorRecovery(uint8_t PortNum)
{
341948ec:	b580      	push	{r7, lr}
341948ee:	b082      	sub	sp, #8
341948f0:	af00      	add	r7, sp, #0
341948f2:	4603      	mov	r3, r0
341948f4:	71fb      	strb	r3, [r7, #7]
  LL_UCPD_SetSRCRole(Ports[PortNum].husbpd);
341948f6:	79fa      	ldrb	r2, [r7, #7]
341948f8:	4912      	ldr	r1, [pc, #72]	@ (34194944 <USBPDM1_EnterErrorRecovery+0x58>)
341948fa:	4613      	mov	r3, r2
341948fc:	00db      	lsls	r3, r3, #3
341948fe:	1a9b      	subs	r3, r3, r2
34194900:	00db      	lsls	r3, r3, #3
34194902:	440b      	add	r3, r1
34194904:	681b      	ldr	r3, [r3, #0]
34194906:	4618      	mov	r0, r3
34194908:	f7ff fe7f 	bl	3419460a <LL_UCPD_SetSRCRole>
  LL_UCPD_SetRpResistor(Ports[PortNum].husbpd, LL_UCPD_RESISTOR_NONE);
3419490c:	79fa      	ldrb	r2, [r7, #7]
3419490e:	490d      	ldr	r1, [pc, #52]	@ (34194944 <USBPDM1_EnterErrorRecovery+0x58>)
34194910:	4613      	mov	r3, r2
34194912:	00db      	lsls	r3, r3, #3
34194914:	1a9b      	subs	r3, r3, r2
34194916:	00db      	lsls	r3, r3, #3
34194918:	440b      	add	r3, r1
3419491a:	681b      	ldr	r3, [r3, #0]
3419491c:	2100      	movs	r1, #0
3419491e:	4618      	mov	r0, r3
34194920:	f7ff fe83 	bl	3419462a <LL_UCPD_SetRpResistor>
  LL_UCPD_RxDisable(Ports[PortNum].husbpd);
34194924:	79fa      	ldrb	r2, [r7, #7]
34194926:	4907      	ldr	r1, [pc, #28]	@ (34194944 <USBPDM1_EnterErrorRecovery+0x58>)
34194928:	4613      	mov	r3, r2
3419492a:	00db      	lsls	r3, r3, #3
3419492c:	1a9b      	subs	r3, r3, r2
3419492e:	00db      	lsls	r3, r3, #3
34194930:	440b      	add	r3, r1
34194932:	681b      	ldr	r3, [r3, #0]
34194934:	4618      	mov	r0, r3
34194936:	f7ff fe8b 	bl	34194650 <LL_UCPD_RxDisable>

}
3419493a:	bf00      	nop
3419493c:	3708      	adds	r7, #8
3419493e:	46bd      	mov	sp, r7
34194940:	bd80      	pop	{r7, pc}
34194942:	bf00      	nop
34194944:	341c2d7c 	.word	0x341c2d7c

34194948 <HW_SignalAttachement>:
{
  LL_UCPD_RxDisable(Ports[PortNum].husbpd);
}

void HW_SignalAttachement(uint8_t PortNum, CCxPin_TypeDef cc)
{
34194948:	b480      	push	{r7}
3419494a:	b083      	sub	sp, #12
3419494c:	af00      	add	r7, sp, #0
3419494e:	4603      	mov	r3, r0
34194950:	6039      	str	r1, [r7, #0]
34194952:	71fb      	strb	r3, [r7, #7]

  MODIFY_REG(Ports[PortNum].husbpd->IMR, INTERRUPT_MASK, INTERRUPT_MASK);
#endif /* !USBPDCORE_LIB_NO_PD */

  /* Handle CC enable */
  Ports[PortNum].CCx = cc;
34194954:	79fa      	ldrb	r2, [r7, #7]
34194956:	4907      	ldr	r1, [pc, #28]	@ (34194974 <HW_SignalAttachement+0x2c>)
34194958:	4613      	mov	r3, r2
3419495a:	00db      	lsls	r3, r3, #3
3419495c:	1a9b      	subs	r3, r3, r2
3419495e:	00db      	lsls	r3, r3, #3
34194960:	440b      	add	r3, r1
34194962:	3330      	adds	r3, #48	@ 0x30
34194964:	683a      	ldr	r2, [r7, #0]
34194966:	601a      	str	r2, [r3, #0]
  /* Prepare the rx processing */
  LL_UCPD_SetRxMode(Ports[PortNum].husbpd, LL_UCPD_RXMODE_NORMAL);
  LL_UCPD_RxDMAEnable(Ports[PortNum].husbpd);
  LL_UCPD_TxDMAEnable(Ports[PortNum].husbpd);
#endif /* !USBPDCORE_LIB_NO_PD */
}
34194968:	bf00      	nop
3419496a:	370c      	adds	r7, #12
3419496c:	46bd      	mov	sp, r7
3419496e:	f85d 7b04 	ldr.w	r7, [sp], #4
34194972:	4770      	bx	lr
34194974:	341c2d7c 	.word	0x341c2d7c

34194978 <HW_SignalDetachment>:


void HW_SignalDetachment(uint8_t PortNum)
{
34194978:	b480      	push	{r7}
3419497a:	b083      	sub	sp, #12
3419497c:	af00      	add	r7, sp, #0
3419497e:	4603      	mov	r3, r0
34194980:	71fb      	strb	r3, [r7, #7]
    (void)BSP_USBPD_PWR_VBUSDeInit(PortNum);
  }


#endif /* !USBPDCORE_LIB_NO_PD */
  Ports[PortNum].CCx = CCNONE;
34194982:	79fa      	ldrb	r2, [r7, #7]
34194984:	4907      	ldr	r1, [pc, #28]	@ (341949a4 <HW_SignalDetachment+0x2c>)
34194986:	4613      	mov	r3, r2
34194988:	00db      	lsls	r3, r3, #3
3419498a:	1a9b      	subs	r3, r3, r2
3419498c:	00db      	lsls	r3, r3, #3
3419498e:	440b      	add	r3, r1
34194990:	3330      	adds	r3, #48	@ 0x30
34194992:	2200      	movs	r2, #0
34194994:	601a      	str	r2, [r3, #0]
#if !defined(USBPDCORE_LIB_NO_PD)
  /* DeInit timer to detect the reception of goodCRC */
  USBPD_TIM_DeInit();
#endif /* !USBPDCORE_LIB_NO_PD */
}
34194996:	bf00      	nop
34194998:	370c      	adds	r7, #12
3419499a:	46bd      	mov	sp, r7
3419499c:	f85d 7b04 	ldr.w	r7, [sp], #4
341949a0:	4770      	bx	lr
341949a2:	bf00      	nop
341949a4:	341c2d7c 	.word	0x341c2d7c

341949a8 <HW_IF_PWR_GetVoltage>:
  UNUSED(voltage);
  return USBPD_OK;
}

uint16_t HW_IF_PWR_GetVoltage(uint8_t PortNum)
{
341949a8:	b580      	push	{r7, lr}
341949aa:	b084      	sub	sp, #16
341949ac:	af00      	add	r7, sp, #0
341949ae:	4603      	mov	r3, r0
341949b0:	71fb      	strb	r3, [r7, #7]
  uint32_t _voltage;
  BSP_USBPD_PWR_VBUSGetVoltage(PortNum, &_voltage);
341949b2:	79fb      	ldrb	r3, [r7, #7]
341949b4:	f107 020c 	add.w	r2, r7, #12
341949b8:	4611      	mov	r1, r2
341949ba:	4618      	mov	r0, r3
341949bc:	f7ef ffec 	bl	34184998 <BSP_USBPD_PWR_VBUSGetVoltage>
  return (uint16_t)_voltage;
341949c0:	68fb      	ldr	r3, [r7, #12]
341949c2:	b29b      	uxth	r3, r3
}
341949c4:	4618      	mov	r0, r3
341949c6:	3710      	adds	r7, #16
341949c8:	46bd      	mov	sp, r7
341949ca:	bd80      	pop	{r7, pc}

341949cc <USBPD_TRACE_Add>:
  TRACER_EMB_DeInit();
#endif /* _TRACE */
}

void  USBPD_TRACE_Add(TRACE_EVENT Type, uint8_t PortNum, uint8_t Sop, uint8_t *Ptr, uint32_t Size)
{
341949cc:	b480      	push	{r7}
341949ce:	b083      	sub	sp, #12
341949d0:	af00      	add	r7, sp, #0
341949d2:	603b      	str	r3, [r7, #0]
341949d4:	4603      	mov	r3, r0
341949d6:	71fb      	strb	r3, [r7, #7]
341949d8:	460b      	mov	r3, r1
341949da:	71bb      	strb	r3, [r7, #6]
341949dc:	4613      	mov	r3, r2
341949de:	717b      	strb	r3, [r7, #5]

  TRACER_EMB_UnLock();

  TRACER_EMB_SendData();
#else
  return;
341949e0:	bf00      	nop
#endif /* _TRACE */
}
341949e2:	370c      	adds	r7, #12
341949e4:	46bd      	mov	sp, r7
341949e6:	f85d 7b04 	ldr.w	r7, [sp], #4
341949ea:	4770      	bx	lr

341949ec <_tx_byte_allocate>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_byte_allocate(TX_BYTE_POOL *pool_ptr, VOID **memory_ptr, ULONG memory_size,  ULONG wait_option)
{
341949ec:	b580      	push	{r7, lr}
341949ee:	b096      	sub	sp, #88	@ 0x58
341949f0:	af00      	add	r7, sp, #0
341949f2:	60f8      	str	r0, [r7, #12]
341949f4:	60b9      	str	r1, [r7, #8]
341949f6:	607a      	str	r2, [r7, #4]
341949f8:	603b      	str	r3, [r7, #0]
#endif


    /* Round the memory size up to the next size that is evenly divisible by
       an ALIGN_TYPE (this is typically a 32-bit ULONG).  This guarantees proper alignment.  */
    memory_size = (((memory_size + (sizeof(ALIGN_TYPE)))-((ALIGN_TYPE) 1))/(sizeof(ALIGN_TYPE))) * (sizeof(ALIGN_TYPE));
341949fa:	687b      	ldr	r3, [r7, #4]
341949fc:	3303      	adds	r3, #3
341949fe:	f023 0303 	bic.w	r3, r3, #3
34194a02:	607b      	str	r3, [r7, #4]
{
UINT posture;
#ifdef TX_PORT_USE_BASEPRI
    __asm__ volatile ("MRS  %0, BASEPRI ": "=r" (posture));
#else
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34194a04:	f3ef 8310 	mrs	r3, PRIMASK
34194a08:	637b      	str	r3, [r7, #52]	@ 0x34
#endif
    return(posture);
34194a0a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34

__attribute__( ( always_inline ) ) static inline UINT __disable_interrupts(void)
{
UINT int_posture;

    int_posture = __get_interrupt_posture();
34194a0c:	633b      	str	r3, [r7, #48]	@ 0x30

#ifdef TX_PORT_USE_BASEPRI
    __set_basepri_value(TX_PORT_BASEPRI);
#else
    __asm__ volatile ("CPSID i" : : : "memory");
34194a0e:	b672      	cpsid	i
#endif
    return(int_posture);
34194a10:	6b3b      	ldr	r3, [r7, #48]	@ 0x30

    /* Disable interrupts.  */
    TX_DISABLE
34194a12:	657b      	str	r3, [r7, #84]	@ 0x54

    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(thread_ptr)
34194a14:	4b55      	ldr	r3, [pc, #340]	@ (34194b6c <_tx_byte_allocate+0x180>)
34194a16:	681b      	ldr	r3, [r3, #0]
34194a18:	64bb      	str	r3, [r7, #72]	@ 0x48
    lower_tbu =  *((ULONG *) (log_entry_ptr + TX_EL_EVENT_TIME_LOWER_OFFSET));
    upper_tbu =  *((ULONG *) (log_entry_ptr + TX_EL_EVENT_TIME_UPPER_OFFSET));
#endif

    /* Set the search finished flag to false.  */
    finished =  TX_FALSE;
34194a1a:	2300      	movs	r3, #0
34194a1c:	64fb      	str	r3, [r7, #76]	@ 0x4c
    /* Loop to handle cases where the owner of the pool changed.  */
    do
    {

        /* Indicate that this thread is the current owner.  */
        pool_ptr -> tx_byte_pool_owner =  thread_ptr;
34194a1e:	68fb      	ldr	r3, [r7, #12]
34194a20:	6cba      	ldr	r2, [r7, #72]	@ 0x48
34194a22:	621a      	str	r2, [r3, #32]
34194a24:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34194a26:	627b      	str	r3, [r7, #36]	@ 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34194a28:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34194a2a:	f383 8810 	msr	PRIMASK, r3
}
34194a2e:	bf00      	nop
        /* Restore interrupts.  */
        TX_RESTORE

        /* At this point, the executing thread owns the pool and can perform a search
           for free memory.  */
        work_ptr =  _tx_byte_pool_search(pool_ptr, memory_size);
34194a30:	6879      	ldr	r1, [r7, #4]
34194a32:	68f8      	ldr	r0, [r7, #12]
34194a34:	f000 f9b2 	bl	34194d9c <_tx_byte_pool_search>
34194a38:	6478      	str	r0, [r7, #68]	@ 0x44
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34194a3a:	f3ef 8310 	mrs	r3, PRIMASK
34194a3e:	62fb      	str	r3, [r7, #44]	@ 0x2c
    return(posture);
34194a40:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
    int_posture = __get_interrupt_posture();
34194a42:	62bb      	str	r3, [r7, #40]	@ 0x28
    __asm__ volatile ("CPSID i" : : : "memory");
34194a44:	b672      	cpsid	i
    return(int_posture);
34194a46:	6abb      	ldr	r3, [r7, #40]	@ 0x28

        /* Optional processing extension.  */
        TX_BYTE_ALLOCATE_EXTENSION

        /* Lockout interrupts.  */
        TX_DISABLE
34194a48:	657b      	str	r3, [r7, #84]	@ 0x54

        /* Determine if we are finished.  */
        if (work_ptr != TX_NULL)
34194a4a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34194a4c:	2b00      	cmp	r3, #0
34194a4e:	d002      	beq.n	34194a56 <_tx_byte_allocate+0x6a>
        {

            /* Yes, we have found a block the search is finished.  */
            finished =  TX_TRUE;
34194a50:	2301      	movs	r3, #1
34194a52:	64fb      	str	r3, [r7, #76]	@ 0x4c
34194a54:	e006      	b.n	34194a64 <_tx_byte_allocate+0x78>
        }
        else
        {

            /* No block was found, does this thread still own the pool?  */
            if (pool_ptr -> tx_byte_pool_owner == thread_ptr)
34194a56:	68fb      	ldr	r3, [r7, #12]
34194a58:	6a1b      	ldr	r3, [r3, #32]
34194a5a:	6cba      	ldr	r2, [r7, #72]	@ 0x48
34194a5c:	429a      	cmp	r2, r3
34194a5e:	d101      	bne.n	34194a64 <_tx_byte_allocate+0x78>
            {

                /* Yes, then we have looked through the entire pool and haven't found the memory.  */
                finished =  TX_TRUE;
34194a60:	2301      	movs	r3, #1
34194a62:	64fb      	str	r3, [r7, #76]	@ 0x4c
            }
        }

    } while (finished == TX_FALSE);
34194a64:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34194a66:	2b00      	cmp	r3, #0
34194a68:	d0d9      	beq.n	34194a1e <_tx_byte_allocate+0x32>

    /* Copy the pointer into the return destination.  */
    *memory_ptr =  (VOID *) work_ptr;
34194a6a:	68bb      	ldr	r3, [r7, #8]
34194a6c:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
34194a6e:	601a      	str	r2, [r3, #0]

    /* Determine if memory was found.  */
    if (work_ptr != TX_NULL)
34194a70:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34194a72:	2b00      	cmp	r3, #0
34194a74:	d008      	beq.n	34194a88 <_tx_byte_allocate+0x9c>
34194a76:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34194a78:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34194a7a:	6a3b      	ldr	r3, [r7, #32]
34194a7c:	f383 8810 	msr	PRIMASK, r3
}
34194a80:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Set the status to success.  */
        status =  TX_SUCCESS;
34194a82:	2300      	movs	r3, #0
34194a84:	653b      	str	r3, [r7, #80]	@ 0x50
34194a86:	e06c      	b.n	34194b62 <_tx_byte_allocate+0x176>
    {

        /* No memory of sufficient size was found...  */

        /* Determine if the request specifies suspension.  */
        if (wait_option != TX_NO_WAIT)
34194a88:	683b      	ldr	r3, [r7, #0]
34194a8a:	2b00      	cmp	r3, #0
34194a8c:	d061      	beq.n	34194b52 <_tx_byte_allocate+0x166>
        {

            /* Determine if the preempt disable flag is non-zero.  */
            if (_tx_thread_preempt_disable != ((UINT) 0))
34194a8e:	4b38      	ldr	r3, [pc, #224]	@ (34194b70 <_tx_byte_allocate+0x184>)
34194a90:	681b      	ldr	r3, [r3, #0]
34194a92:	2b00      	cmp	r3, #0
34194a94:	d007      	beq.n	34194aa6 <_tx_byte_allocate+0xba>
            {

                /* Suspension is not allowed if the preempt disable flag is non-zero at this point - return error completion.  */
                status =  TX_NO_MEMORY;
34194a96:	2310      	movs	r3, #16
34194a98:	653b      	str	r3, [r7, #80]	@ 0x50
34194a9a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34194a9c:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34194a9e:	69fb      	ldr	r3, [r7, #28]
34194aa0:	f383 8810 	msr	PRIMASK, r3
}
34194aa4:	e05d      	b.n	34194b62 <_tx_byte_allocate+0x176>
                /* Increment the number of suspensions on this pool.  */
                pool_ptr -> tx_byte_pool_performance_suspension_count++;
#endif

                /* Setup cleanup routine pointer.  */
                thread_ptr -> tx_thread_suspend_cleanup =  &(_tx_byte_pool_cleanup);
34194aa6:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
34194aa8:	4a32      	ldr	r2, [pc, #200]	@ (34194b74 <_tx_byte_allocate+0x188>)
34194aaa:	669a      	str	r2, [r3, #104]	@ 0x68

                /* Setup cleanup information, i.e. this pool control
                   block.  */
                thread_ptr -> tx_thread_suspend_control_block =  (VOID *) pool_ptr;
34194aac:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
34194aae:	68fa      	ldr	r2, [r7, #12]
34194ab0:	66da      	str	r2, [r3, #108]	@ 0x6c

                /* Save the return memory pointer address as well.  */
                thread_ptr -> tx_thread_additional_suspend_info =  (VOID *) memory_ptr;
34194ab2:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
34194ab4:	68ba      	ldr	r2, [r7, #8]
34194ab6:	67da      	str	r2, [r3, #124]	@ 0x7c

                /* Save the byte size requested.  */
                thread_ptr -> tx_thread_suspend_info =  memory_size;
34194ab8:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
34194aba:	687a      	ldr	r2, [r7, #4]
34194abc:	679a      	str	r2, [r3, #120]	@ 0x78

#ifndef TX_NOT_INTERRUPTABLE

                /* Increment the suspension sequence number, which is used to identify
                   this suspension event.  */
                thread_ptr -> tx_thread_suspension_sequence++;
34194abe:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
34194ac0:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
34194ac4:	1c5a      	adds	r2, r3, #1
34194ac6:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
34194ac8:	f8c3 20ac 	str.w	r2, [r3, #172]	@ 0xac
#endif

                /* Pickup the number of suspended threads.  */
                suspended_count =  pool_ptr -> tx_byte_pool_suspended_count;
34194acc:	68fb      	ldr	r3, [r7, #12]
34194ace:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34194ad0:	643b      	str	r3, [r7, #64]	@ 0x40

                /* Increment the suspension count.  */
                (pool_ptr -> tx_byte_pool_suspended_count)++;
34194ad2:	68fb      	ldr	r3, [r7, #12]
34194ad4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34194ad6:	1c5a      	adds	r2, r3, #1
34194ad8:	68fb      	ldr	r3, [r7, #12]
34194ada:	629a      	str	r2, [r3, #40]	@ 0x28

                /* Setup suspension list.  */
                if (suspended_count == TX_NO_SUSPENSIONS)
34194adc:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34194ade:	2b00      	cmp	r3, #0
34194ae0:	d109      	bne.n	34194af6 <_tx_byte_allocate+0x10a>
                {

                    /* No other threads are suspended.  Setup the head pointer and
                       just setup this threads pointers to itself.  */
                    pool_ptr -> tx_byte_pool_suspension_list =      thread_ptr;
34194ae2:	68fb      	ldr	r3, [r7, #12]
34194ae4:	6cba      	ldr	r2, [r7, #72]	@ 0x48
34194ae6:	625a      	str	r2, [r3, #36]	@ 0x24
                    thread_ptr -> tx_thread_suspended_next =        thread_ptr;
34194ae8:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
34194aea:	6cba      	ldr	r2, [r7, #72]	@ 0x48
34194aec:	671a      	str	r2, [r3, #112]	@ 0x70
                    thread_ptr -> tx_thread_suspended_previous =    thread_ptr;
34194aee:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
34194af0:	6cba      	ldr	r2, [r7, #72]	@ 0x48
34194af2:	675a      	str	r2, [r3, #116]	@ 0x74
34194af4:	e011      	b.n	34194b1a <_tx_byte_allocate+0x12e>
                }
                else
                {

                    /* This list is not NULL, add current thread to the end. */
                    next_thread =                                   pool_ptr -> tx_byte_pool_suspension_list;
34194af6:	68fb      	ldr	r3, [r7, #12]
34194af8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34194afa:	63fb      	str	r3, [r7, #60]	@ 0x3c
                    thread_ptr -> tx_thread_suspended_next =        next_thread;
34194afc:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
34194afe:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
34194b00:	671a      	str	r2, [r3, #112]	@ 0x70
                    previous_thread =                               next_thread -> tx_thread_suspended_previous;
34194b02:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34194b04:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34194b06:	63bb      	str	r3, [r7, #56]	@ 0x38
                    thread_ptr -> tx_thread_suspended_previous =    previous_thread;
34194b08:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
34194b0a:	6bba      	ldr	r2, [r7, #56]	@ 0x38
34194b0c:	675a      	str	r2, [r3, #116]	@ 0x74
                    previous_thread -> tx_thread_suspended_next =   thread_ptr;
34194b0e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34194b10:	6cba      	ldr	r2, [r7, #72]	@ 0x48
34194b12:	671a      	str	r2, [r3, #112]	@ 0x70
                    next_thread -> tx_thread_suspended_previous =   thread_ptr;
34194b14:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34194b16:	6cba      	ldr	r2, [r7, #72]	@ 0x48
34194b18:	675a      	str	r2, [r3, #116]	@ 0x74
                }

                /* Set the state to suspended.  */
                thread_ptr -> tx_thread_state =       TX_BYTE_MEMORY;
34194b1a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
34194b1c:	2209      	movs	r2, #9
34194b1e:	631a      	str	r2, [r3, #48]	@ 0x30
                /* Restore interrupts.  */
                TX_RESTORE
#else

                /* Set the suspending flag.  */
                thread_ptr -> tx_thread_suspending =  TX_TRUE;
34194b20:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
34194b22:	2201      	movs	r2, #1
34194b24:	639a      	str	r2, [r3, #56]	@ 0x38

                /* Setup the timeout period.  */
                thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  wait_option;
34194b26:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
34194b28:	683a      	ldr	r2, [r7, #0]
34194b2a:	64da      	str	r2, [r3, #76]	@ 0x4c

                /* Temporarily disable preemption.  */
                _tx_thread_preempt_disable++;
34194b2c:	4b10      	ldr	r3, [pc, #64]	@ (34194b70 <_tx_byte_allocate+0x184>)
34194b2e:	681b      	ldr	r3, [r3, #0]
34194b30:	3301      	adds	r3, #1
34194b32:	4a0f      	ldr	r2, [pc, #60]	@ (34194b70 <_tx_byte_allocate+0x184>)
34194b34:	6013      	str	r3, [r2, #0]
34194b36:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34194b38:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34194b3a:	69bb      	ldr	r3, [r7, #24]
34194b3c:	f383 8810 	msr	PRIMASK, r3
}
34194b40:	bf00      	nop

                /* Restore interrupts.  */
                TX_RESTORE

                /* Call actual thread suspension routine.  */
                _tx_thread_system_suspend(thread_ptr);
34194b42:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
34194b44:	f002 ff9e 	bl	34197a84 <_tx_thread_system_suspend>
                    *((ULONG *) (log_entry_ptr + TX_EL_EVENT_INFO_4_OFFSET)) =  (ULONG) *memory_ptr;
                }
#endif

                /* Return the completion status.  */
                status =  thread_ptr -> tx_thread_suspend_status;
34194b48:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
34194b4a:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
34194b4e:	653b      	str	r3, [r7, #80]	@ 0x50
34194b50:	e007      	b.n	34194b62 <_tx_byte_allocate+0x176>
34194b52:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34194b54:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34194b56:	697b      	ldr	r3, [r7, #20]
34194b58:	f383 8810 	msr	PRIMASK, r3
}
34194b5c:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Immediate return, return error completion.  */
            status =  TX_NO_MEMORY;
34194b5e:	2310      	movs	r3, #16
34194b60:	653b      	str	r3, [r7, #80]	@ 0x50
        }
    }

    /* Return completion status.  */
    return(status);
34194b62:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
}
34194b64:	4618      	mov	r0, r3
34194b66:	3758      	adds	r7, #88	@ 0x58
34194b68:	46bd      	mov	sp, r7
34194b6a:	bd80      	pop	{r7, pc}
34194b6c:	341c2dec 	.word	0x341c2dec
34194b70:	341c2e84 	.word	0x341c2e84
34194b74:	34194b79 	.word	0x34194b79

34194b78 <_tx_byte_pool_cleanup>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_byte_pool_cleanup(TX_THREAD *thread_ptr, ULONG suspension_sequence)
{
34194b78:	b580      	push	{r7, lr}
34194b7a:	b08e      	sub	sp, #56	@ 0x38
34194b7c:	af00      	add	r7, sp, #0
34194b7e:	6078      	str	r0, [r7, #4]
34194b80:	6039      	str	r1, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34194b82:	f3ef 8310 	mrs	r3, PRIMASK
34194b86:	623b      	str	r3, [r7, #32]
    return(posture);
34194b88:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
34194b8a:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
34194b8c:	b672      	cpsid	i
    return(int_posture);
34194b8e:	69fb      	ldr	r3, [r7, #28]


#ifndef TX_NOT_INTERRUPTABLE

    /* Disable interrupts to remove the suspended thread from the byte pool.  */
    TX_DISABLE
34194b90:	637b      	str	r3, [r7, #52]	@ 0x34

    /* Determine if the cleanup is still required.  */
    if (thread_ptr -> tx_thread_suspend_cleanup == &(_tx_byte_pool_cleanup))
34194b92:	687b      	ldr	r3, [r7, #4]
34194b94:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
34194b96:	4a33      	ldr	r2, [pc, #204]	@ (34194c64 <_tx_byte_pool_cleanup+0xec>)
34194b98:	4293      	cmp	r3, r2
34194b9a:	d158      	bne.n	34194c4e <_tx_byte_pool_cleanup+0xd6>
    {

        /* Check for valid suspension sequence.  */
        if (suspension_sequence == thread_ptr -> tx_thread_suspension_sequence)
34194b9c:	687b      	ldr	r3, [r7, #4]
34194b9e:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
34194ba2:	683a      	ldr	r2, [r7, #0]
34194ba4:	429a      	cmp	r2, r3
34194ba6:	d152      	bne.n	34194c4e <_tx_byte_pool_cleanup+0xd6>
        {

            /* Setup pointer to byte pool control block.  */
            pool_ptr =  TX_VOID_TO_BYTE_POOL_POINTER_CONVERT(thread_ptr -> tx_thread_suspend_control_block);
34194ba8:	687b      	ldr	r3, [r7, #4]
34194baa:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
34194bac:	633b      	str	r3, [r7, #48]	@ 0x30

            /* Check for a NULL byte pool pointer.  */
            if (pool_ptr != TX_NULL)
34194bae:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34194bb0:	2b00      	cmp	r3, #0
34194bb2:	d04c      	beq.n	34194c4e <_tx_byte_pool_cleanup+0xd6>
            {

                /* Check for valid pool ID.  */
                if (pool_ptr -> tx_byte_pool_id == TX_BYTE_POOL_ID)
34194bb4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34194bb6:	681b      	ldr	r3, [r3, #0]
34194bb8:	4a2b      	ldr	r2, [pc, #172]	@ (34194c68 <_tx_byte_pool_cleanup+0xf0>)
34194bba:	4293      	cmp	r3, r2
34194bbc:	d147      	bne.n	34194c4e <_tx_byte_pool_cleanup+0xd6>
                {

                    /* Determine if there are any thread suspensions.  */
                    if (pool_ptr -> tx_byte_pool_suspended_count != TX_NO_SUSPENSIONS)
34194bbe:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34194bc0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34194bc2:	2b00      	cmp	r3, #0
34194bc4:	d043      	beq.n	34194c4e <_tx_byte_pool_cleanup+0xd6>
                        /* Setup pointer to byte pool control block.  */
                        pool_ptr =  TX_VOID_TO_BYTE_POOL_POINTER_CONVERT(thread_ptr -> tx_thread_suspend_control_block);
#endif

                        /* Thread suspended for memory... Clear the suspension cleanup flag.  */
                        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
34194bc6:	687b      	ldr	r3, [r7, #4]
34194bc8:	2200      	movs	r2, #0
34194bca:	669a      	str	r2, [r3, #104]	@ 0x68

                        /* Decrement the suspension count.  */
                        pool_ptr -> tx_byte_pool_suspended_count--;
34194bcc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34194bce:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34194bd0:	1e5a      	subs	r2, r3, #1
34194bd2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34194bd4:	629a      	str	r2, [r3, #40]	@ 0x28

                        /* Pickup the suspended count.  */
                        suspended_count =  pool_ptr -> tx_byte_pool_suspended_count;
34194bd6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34194bd8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34194bda:	62fb      	str	r3, [r7, #44]	@ 0x2c

                        /* Remove the suspended thread from the list.  */

                        /* See if this is the only suspended thread on the list.  */
                        if (suspended_count == TX_NO_SUSPENSIONS)
34194bdc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34194bde:	2b00      	cmp	r3, #0
34194be0:	d103      	bne.n	34194bea <_tx_byte_pool_cleanup+0x72>
                        {

                            /* Yes, the only suspended thread.  */

                            /* Update the head pointer.  */
                            pool_ptr -> tx_byte_pool_suspension_list =  TX_NULL;
34194be2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34194be4:	2200      	movs	r2, #0
34194be6:	625a      	str	r2, [r3, #36]	@ 0x24
34194be8:	e013      	b.n	34194c12 <_tx_byte_pool_cleanup+0x9a>
                        {

                            /* At least one more thread is on the same suspension list.  */

                            /* Update the links of the adjacent threads.  */
                            next_thread =                                   thread_ptr -> tx_thread_suspended_next;
34194bea:	687b      	ldr	r3, [r7, #4]
34194bec:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34194bee:	62bb      	str	r3, [r7, #40]	@ 0x28
                            previous_thread =                               thread_ptr -> tx_thread_suspended_previous;
34194bf0:	687b      	ldr	r3, [r7, #4]
34194bf2:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34194bf4:	627b      	str	r3, [r7, #36]	@ 0x24
                            next_thread -> tx_thread_suspended_previous =   previous_thread;
34194bf6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34194bf8:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
34194bfa:	675a      	str	r2, [r3, #116]	@ 0x74
                            previous_thread -> tx_thread_suspended_next =   next_thread;
34194bfc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34194bfe:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34194c00:	671a      	str	r2, [r3, #112]	@ 0x70

                            /* Determine if we need to update the head pointer.  */
                            if (pool_ptr -> tx_byte_pool_suspension_list == thread_ptr)
34194c02:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34194c04:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34194c06:	687a      	ldr	r2, [r7, #4]
34194c08:	429a      	cmp	r2, r3
34194c0a:	d102      	bne.n	34194c12 <_tx_byte_pool_cleanup+0x9a>
                            {

                                /* Update the list head pointer.  */
                                pool_ptr -> tx_byte_pool_suspension_list =      next_thread;
34194c0c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34194c0e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34194c10:	625a      	str	r2, [r3, #36]	@ 0x24
                            }
                        }

                        /* Now we need to determine if this cleanup is from a terminate, timeout,
                           or from a wait abort.  */
                        if (thread_ptr -> tx_thread_state == TX_BYTE_MEMORY)
34194c12:	687b      	ldr	r3, [r7, #4]
34194c14:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34194c16:	2b09      	cmp	r3, #9
34194c18:	d119      	bne.n	34194c4e <_tx_byte_pool_cleanup+0xd6>
                            /* Increment the number of timeouts on this byte pool.  */
                            pool_ptr -> tx_byte_pool_performance_timeout_count++;
#endif

                            /* Setup return status.  */
                            thread_ptr -> tx_thread_suspend_status =  TX_NO_MEMORY;
34194c1a:	687b      	ldr	r3, [r7, #4]
34194c1c:	2210      	movs	r2, #16
34194c1e:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
                            /* Resume the thread!  */
                            _tx_thread_system_ni_resume(thread_ptr);
#else

                            /* Temporarily disable preemption.  */
                            _tx_thread_preempt_disable++;
34194c22:	4b12      	ldr	r3, [pc, #72]	@ (34194c6c <_tx_byte_pool_cleanup+0xf4>)
34194c24:	681b      	ldr	r3, [r3, #0]
34194c26:	3301      	adds	r3, #1
34194c28:	4a10      	ldr	r2, [pc, #64]	@ (34194c6c <_tx_byte_pool_cleanup+0xf4>)
34194c2a:	6013      	str	r3, [r2, #0]
34194c2c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34194c2e:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34194c30:	693b      	ldr	r3, [r7, #16]
34194c32:	f383 8810 	msr	PRIMASK, r3
}
34194c36:	bf00      	nop

                            /* Restore interrupts.  */
                            TX_RESTORE

                            /* Resume the thread!  */
                            _tx_thread_system_resume(thread_ptr);
34194c38:	6878      	ldr	r0, [r7, #4]
34194c3a:	f002 fe23 	bl	34197884 <_tx_thread_system_resume>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34194c3e:	f3ef 8310 	mrs	r3, PRIMASK
34194c42:	61bb      	str	r3, [r7, #24]
    return(posture);
34194c44:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
34194c46:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
34194c48:	b672      	cpsid	i
    return(int_posture);
34194c4a:	697b      	ldr	r3, [r7, #20]

                            /* Disable interrupts.  */
                            TX_DISABLE
34194c4c:	637b      	str	r3, [r7, #52]	@ 0x34
34194c4e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34194c50:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34194c52:	68fb      	ldr	r3, [r7, #12]
34194c54:	f383 8810 	msr	PRIMASK, r3
}
34194c58:	bf00      	nop
    }

    /* Restore interrupts.  */
    TX_RESTORE
#endif
}
34194c5a:	bf00      	nop
34194c5c:	3738      	adds	r7, #56	@ 0x38
34194c5e:	46bd      	mov	sp, r7
34194c60:	bd80      	pop	{r7, pc}
34194c62:	bf00      	nop
34194c64:	34194b79 	.word	0x34194b79
34194c68:	42595445 	.word	0x42595445
34194c6c:	341c2e84 	.word	0x341c2e84

34194c70 <_tx_byte_pool_create>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_byte_pool_create(TX_BYTE_POOL *pool_ptr, CHAR *name_ptr, VOID *pool_start, ULONG pool_size)
{
34194c70:	b580      	push	{r7, lr}
34194c72:	b08e      	sub	sp, #56	@ 0x38
34194c74:	af00      	add	r7, sp, #0
34194c76:	60f8      	str	r0, [r7, #12]
34194c78:	60b9      	str	r1, [r7, #8]
34194c7a:	607a      	str	r2, [r7, #4]
34194c7c:	603b      	str	r3, [r7, #0]
TX_BYTE_POOL        *previous_pool;
ALIGN_TYPE          *free_ptr;


    /* Initialize the byte pool control block to all zeros.  */
    TX_MEMSET(pool_ptr, 0, (sizeof(TX_BYTE_POOL)));
34194c7e:	2234      	movs	r2, #52	@ 0x34
34194c80:	2100      	movs	r1, #0
34194c82:	68f8      	ldr	r0, [r7, #12]
34194c84:	f009 fa1c 	bl	3419e0c0 <memset>

    /* Round the pool size down to something that is evenly divisible by
       an ULONG.  */
    pool_size =   (pool_size/(sizeof(ALIGN_TYPE))) * (sizeof(ALIGN_TYPE));
34194c88:	683b      	ldr	r3, [r7, #0]
34194c8a:	f023 0303 	bic.w	r3, r3, #3
34194c8e:	603b      	str	r3, [r7, #0]

    /* Setup the basic byte pool fields.  */
    pool_ptr -> tx_byte_pool_name =              name_ptr;
34194c90:	68fb      	ldr	r3, [r7, #12]
34194c92:	68ba      	ldr	r2, [r7, #8]
34194c94:	605a      	str	r2, [r3, #4]

    /* Save the start and size of the pool.  */
    pool_ptr -> tx_byte_pool_start =   TX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
34194c96:	68fb      	ldr	r3, [r7, #12]
34194c98:	687a      	ldr	r2, [r7, #4]
34194c9a:	619a      	str	r2, [r3, #24]
    pool_ptr -> tx_byte_pool_size =    pool_size;
34194c9c:	68fb      	ldr	r3, [r7, #12]
34194c9e:	683a      	ldr	r2, [r7, #0]
34194ca0:	61da      	str	r2, [r3, #28]

    /* Setup memory list to the beginning as well as the search pointer.  */
    pool_ptr -> tx_byte_pool_list =    TX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
34194ca2:	68fb      	ldr	r3, [r7, #12]
34194ca4:	687a      	ldr	r2, [r7, #4]
34194ca6:	611a      	str	r2, [r3, #16]
    pool_ptr -> tx_byte_pool_search =  TX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
34194ca8:	68fb      	ldr	r3, [r7, #12]
34194caa:	687a      	ldr	r2, [r7, #4]
34194cac:	615a      	str	r2, [r3, #20]

    /* Initially, the pool will have two blocks.  One large block at the
       beginning that is available and a small allocated block at the end
       of the pool that is there just for the algorithm.  Be sure to count
       the available block's header in the available bytes count.  */
    pool_ptr -> tx_byte_pool_available =   pool_size - ((sizeof(VOID *)) + (sizeof(ALIGN_TYPE)));
34194cae:	683b      	ldr	r3, [r7, #0]
34194cb0:	f1a3 0208 	sub.w	r2, r3, #8
34194cb4:	68fb      	ldr	r3, [r7, #12]
34194cb6:	609a      	str	r2, [r3, #8]
    pool_ptr -> tx_byte_pool_fragments =   ((UINT) 2);
34194cb8:	68fb      	ldr	r3, [r7, #12]
34194cba:	2202      	movs	r2, #2
34194cbc:	60da      	str	r2, [r3, #12]
    /* Each block contains a "next" pointer that points to the next block in the pool followed by a ALIGN_TYPE
       field that contains either the constant TX_BYTE_BLOCK_FREE (if the block is free) or a pointer to the
       owning pool (if the block is allocated).  */

    /* Calculate the end of the pool's memory area.  */
    block_ptr =  TX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
34194cbe:	687b      	ldr	r3, [r7, #4]
34194cc0:	637b      	str	r3, [r7, #52]	@ 0x34
    block_ptr =  TX_UCHAR_POINTER_ADD(block_ptr, pool_size);
34194cc2:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
34194cc4:	683b      	ldr	r3, [r7, #0]
34194cc6:	4413      	add	r3, r2
34194cc8:	637b      	str	r3, [r7, #52]	@ 0x34

    /* Backup the end of the pool pointer and build the pre-allocated block.  */
    block_ptr =  TX_UCHAR_POINTER_SUB(block_ptr, (sizeof(ALIGN_TYPE)));
34194cca:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34194ccc:	3b04      	subs	r3, #4
34194cce:	637b      	str	r3, [r7, #52]	@ 0x34

    /* Cast the pool pointer into a ULONG.  */
    temp_ptr =             TX_BYTE_POOL_TO_UCHAR_POINTER_CONVERT(pool_ptr);
34194cd0:	68fb      	ldr	r3, [r7, #12]
34194cd2:	633b      	str	r3, [r7, #48]	@ 0x30
    block_indirect_ptr =   TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(block_ptr);
34194cd4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34194cd6:	62fb      	str	r3, [r7, #44]	@ 0x2c
    *block_indirect_ptr =  temp_ptr;
34194cd8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34194cda:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
34194cdc:	601a      	str	r2, [r3, #0]

    block_ptr =            TX_UCHAR_POINTER_SUB(block_ptr, (sizeof(UCHAR *)));
34194cde:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34194ce0:	3b04      	subs	r3, #4
34194ce2:	637b      	str	r3, [r7, #52]	@ 0x34
    block_indirect_ptr =   TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(block_ptr);
34194ce4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34194ce6:	62fb      	str	r3, [r7, #44]	@ 0x2c
    *block_indirect_ptr =  TX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
34194ce8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34194cea:	687a      	ldr	r2, [r7, #4]
34194cec:	601a      	str	r2, [r3, #0]

    /* Now setup the large available block in the pool.  */
    temp_ptr =             TX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
34194cee:	687b      	ldr	r3, [r7, #4]
34194cf0:	633b      	str	r3, [r7, #48]	@ 0x30
    block_indirect_ptr =   TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(temp_ptr);
34194cf2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34194cf4:	62fb      	str	r3, [r7, #44]	@ 0x2c
    *block_indirect_ptr =  block_ptr;
34194cf6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34194cf8:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
34194cfa:	601a      	str	r2, [r3, #0]
    block_ptr =            TX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
34194cfc:	687b      	ldr	r3, [r7, #4]
34194cfe:	637b      	str	r3, [r7, #52]	@ 0x34
    block_ptr =            TX_UCHAR_POINTER_ADD(block_ptr, (sizeof(UCHAR *)));
34194d00:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34194d02:	3304      	adds	r3, #4
34194d04:	637b      	str	r3, [r7, #52]	@ 0x34
    free_ptr =             TX_UCHAR_TO_ALIGN_TYPE_POINTER_CONVERT(block_ptr);
34194d06:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34194d08:	62bb      	str	r3, [r7, #40]	@ 0x28
    *free_ptr =            TX_BYTE_BLOCK_FREE;
34194d0a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34194d0c:	4a1f      	ldr	r2, [pc, #124]	@ (34194d8c <_tx_byte_pool_create+0x11c>)
34194d0e:	601a      	str	r2, [r3, #0]

    /* Clear the owner id.  */
    pool_ptr -> tx_byte_pool_owner =  TX_NULL;
34194d10:	68fb      	ldr	r3, [r7, #12]
34194d12:	2200      	movs	r2, #0
34194d14:	621a      	str	r2, [r3, #32]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34194d16:	f3ef 8310 	mrs	r3, PRIMASK
34194d1a:	61bb      	str	r3, [r7, #24]
    return(posture);
34194d1c:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
34194d1e:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
34194d20:	b672      	cpsid	i
    return(int_posture);
34194d22:	697b      	ldr	r3, [r7, #20]

    /* Disable interrupts to place the byte pool on the created list.  */
    TX_DISABLE
34194d24:	627b      	str	r3, [r7, #36]	@ 0x24

    /* Setup the byte pool ID to make it valid.  */
    pool_ptr -> tx_byte_pool_id =  TX_BYTE_POOL_ID;
34194d26:	68fb      	ldr	r3, [r7, #12]
34194d28:	4a19      	ldr	r2, [pc, #100]	@ (34194d90 <_tx_byte_pool_create+0x120>)
34194d2a:	601a      	str	r2, [r3, #0]

    /* Place the byte pool on the list of created byte pools.  First,
       check for an empty list.  */
    if (_tx_byte_pool_created_count == TX_EMPTY)
34194d2c:	4b19      	ldr	r3, [pc, #100]	@ (34194d94 <_tx_byte_pool_create+0x124>)
34194d2e:	681b      	ldr	r3, [r3, #0]
34194d30:	2b00      	cmp	r3, #0
34194d32:	d109      	bne.n	34194d48 <_tx_byte_pool_create+0xd8>
    {

        /* The created byte pool list is empty.  Add byte pool to empty list.  */
        _tx_byte_pool_created_ptr =                  pool_ptr;
34194d34:	4a18      	ldr	r2, [pc, #96]	@ (34194d98 <_tx_byte_pool_create+0x128>)
34194d36:	68fb      	ldr	r3, [r7, #12]
34194d38:	6013      	str	r3, [r2, #0]
        pool_ptr -> tx_byte_pool_created_next =      pool_ptr;
34194d3a:	68fb      	ldr	r3, [r7, #12]
34194d3c:	68fa      	ldr	r2, [r7, #12]
34194d3e:	62da      	str	r2, [r3, #44]	@ 0x2c
        pool_ptr -> tx_byte_pool_created_previous =  pool_ptr;
34194d40:	68fb      	ldr	r3, [r7, #12]
34194d42:	68fa      	ldr	r2, [r7, #12]
34194d44:	631a      	str	r2, [r3, #48]	@ 0x30
34194d46:	e011      	b.n	34194d6c <_tx_byte_pool_create+0xfc>
    }
    else
    {

        /* This list is not NULL, add to the end of the list.  */
        next_pool =      _tx_byte_pool_created_ptr;
34194d48:	4b13      	ldr	r3, [pc, #76]	@ (34194d98 <_tx_byte_pool_create+0x128>)
34194d4a:	681b      	ldr	r3, [r3, #0]
34194d4c:	623b      	str	r3, [r7, #32]
        previous_pool =  next_pool -> tx_byte_pool_created_previous;
34194d4e:	6a3b      	ldr	r3, [r7, #32]
34194d50:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34194d52:	61fb      	str	r3, [r7, #28]

        /* Place the new byte pool in the list.  */
        next_pool -> tx_byte_pool_created_previous =  pool_ptr;
34194d54:	6a3b      	ldr	r3, [r7, #32]
34194d56:	68fa      	ldr	r2, [r7, #12]
34194d58:	631a      	str	r2, [r3, #48]	@ 0x30
        previous_pool -> tx_byte_pool_created_next =  pool_ptr;
34194d5a:	69fb      	ldr	r3, [r7, #28]
34194d5c:	68fa      	ldr	r2, [r7, #12]
34194d5e:	62da      	str	r2, [r3, #44]	@ 0x2c

        /* Setup this byte pool's created links.  */
        pool_ptr -> tx_byte_pool_created_previous =  previous_pool;
34194d60:	68fb      	ldr	r3, [r7, #12]
34194d62:	69fa      	ldr	r2, [r7, #28]
34194d64:	631a      	str	r2, [r3, #48]	@ 0x30
        pool_ptr -> tx_byte_pool_created_next =      next_pool;
34194d66:	68fb      	ldr	r3, [r7, #12]
34194d68:	6a3a      	ldr	r2, [r7, #32]
34194d6a:	62da      	str	r2, [r3, #44]	@ 0x2c
    }

    /* Increment the number of created byte pools.  */
    _tx_byte_pool_created_count++;
34194d6c:	4b09      	ldr	r3, [pc, #36]	@ (34194d94 <_tx_byte_pool_create+0x124>)
34194d6e:	681b      	ldr	r3, [r3, #0]
34194d70:	3301      	adds	r3, #1
34194d72:	4a08      	ldr	r2, [pc, #32]	@ (34194d94 <_tx_byte_pool_create+0x124>)
34194d74:	6013      	str	r3, [r2, #0]
34194d76:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34194d78:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34194d7a:	693b      	ldr	r3, [r7, #16]
34194d7c:	f383 8810 	msr	PRIMASK, r3
}
34194d80:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
34194d82:	2300      	movs	r3, #0
}
34194d84:	4618      	mov	r0, r3
34194d86:	3738      	adds	r7, #56	@ 0x38
34194d88:	46bd      	mov	sp, r7
34194d8a:	bd80      	pop	{r7, pc}
34194d8c:	ffffeeee 	.word	0xffffeeee
34194d90:	42595445 	.word	0x42595445
34194d94:	341c2de0 	.word	0x341c2de0
34194d98:	341c2ddc 	.word	0x341c2ddc

34194d9c <_tx_byte_pool_search>:
/*                                            calculation,                */
/*                                            resulting in version 6.1.7  */
/*                                                                        */
/**************************************************************************/
UCHAR  *_tx_byte_pool_search(TX_BYTE_POOL *pool_ptr, ULONG memory_size)
{
34194d9c:	b480      	push	{r7}
34194d9e:	b097      	sub	sp, #92	@ 0x5c
34194da0:	af00      	add	r7, sp, #0
34194da2:	6078      	str	r0, [r7, #4]
34194da4:	6039      	str	r1, [r7, #0]
UCHAR           *next_ptr;
UCHAR           **this_block_link_ptr;
UCHAR           **next_block_link_ptr;
ULONG           available_bytes;
UINT            examine_blocks;
UINT            first_free_block_found =  TX_FALSE;
34194da6:	2300      	movs	r3, #0
34194da8:	647b      	str	r3, [r7, #68]	@ 0x44
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34194daa:	f3ef 8310 	mrs	r3, PRIMASK
34194dae:	627b      	str	r3, [r7, #36]	@ 0x24
    return(posture);
34194db0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
    int_posture = __get_interrupt_posture();
34194db2:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("CPSID i" : : : "memory");
34194db4:	b672      	cpsid	i
    return(int_posture);
34194db6:	6a3b      	ldr	r3, [r7, #32]
UCHAR           *work_ptr;
ULONG           total_theoretical_available;


    /* Disable interrupts.  */
    TX_DISABLE
34194db8:	657b      	str	r3, [r7, #84]	@ 0x54

    /* First, determine if there are enough bytes in the pool.  */
    /* Theoretical bytes available = free bytes + ((fragments-2) * overhead of each block) */
    total_theoretical_available = pool_ptr -> tx_byte_pool_available + ((pool_ptr -> tx_byte_pool_fragments - 2) * ((sizeof(UCHAR *)) + (sizeof(ALIGN_TYPE))));
34194dba:	687b      	ldr	r3, [r7, #4]
34194dbc:	689a      	ldr	r2, [r3, #8]
34194dbe:	687b      	ldr	r3, [r7, #4]
34194dc0:	68db      	ldr	r3, [r3, #12]
34194dc2:	3b02      	subs	r3, #2
34194dc4:	00db      	lsls	r3, r3, #3
34194dc6:	4413      	add	r3, r2
34194dc8:	643b      	str	r3, [r7, #64]	@ 0x40
    if (memory_size >= total_theoretical_available)
34194dca:	683a      	ldr	r2, [r7, #0]
34194dcc:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34194dce:	429a      	cmp	r2, r3
34194dd0:	d308      	bcc.n	34194de4 <_tx_byte_pool_search+0x48>
34194dd2:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34194dd4:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34194dd6:	69fb      	ldr	r3, [r7, #28]
34194dd8:	f383 8810 	msr	PRIMASK, r3
}
34194ddc:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Not enough memory, return a NULL pointer.  */
        current_ptr =  TX_NULL;
34194dde:	2300      	movs	r3, #0
34194de0:	653b      	str	r3, [r7, #80]	@ 0x50
34194de2:	e0dd      	b.n	34194fa0 <_tx_byte_pool_search+0x204>
    }
    else
    {

        /* Pickup thread pointer.  */
        TX_THREAD_GET_CURRENT(thread_ptr)
34194de4:	4b72      	ldr	r3, [pc, #456]	@ (34194fb0 <_tx_byte_pool_search+0x214>)
34194de6:	681b      	ldr	r3, [r3, #0]
34194de8:	63fb      	str	r3, [r7, #60]	@ 0x3c

        /* Setup ownership of the byte pool.  */
        pool_ptr -> tx_byte_pool_owner =  thread_ptr;
34194dea:	687b      	ldr	r3, [r7, #4]
34194dec:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
34194dee:	621a      	str	r2, [r3, #32]

        /* Walk through the memory pool in search for a large enough block.  */
        current_ptr =      pool_ptr -> tx_byte_pool_search;
34194df0:	687b      	ldr	r3, [r7, #4]
34194df2:	695b      	ldr	r3, [r3, #20]
34194df4:	653b      	str	r3, [r7, #80]	@ 0x50
        examine_blocks =   pool_ptr -> tx_byte_pool_fragments + ((UINT) 1);
34194df6:	687b      	ldr	r3, [r7, #4]
34194df8:	68db      	ldr	r3, [r3, #12]
34194dfa:	3301      	adds	r3, #1
34194dfc:	64bb      	str	r3, [r7, #72]	@ 0x48
        available_bytes =  ((ULONG) 0);
34194dfe:	2300      	movs	r3, #0
34194e00:	64fb      	str	r3, [r7, #76]	@ 0x4c
            /* Increment the number of fragments searched on this pool.  */
            pool_ptr -> tx_byte_pool_performance_search_count++;
#endif

            /* Check to see if this block is free.  */
            work_ptr =  TX_UCHAR_POINTER_ADD(current_ptr, (sizeof(UCHAR *)));
34194e02:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
34194e04:	3304      	adds	r3, #4
34194e06:	63bb      	str	r3, [r7, #56]	@ 0x38
            free_ptr =  TX_UCHAR_TO_ALIGN_TYPE_POINTER_CONVERT(work_ptr);
34194e08:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34194e0a:	637b      	str	r3, [r7, #52]	@ 0x34
            if ((*free_ptr) == TX_BYTE_BLOCK_FREE)
34194e0c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34194e0e:	681b      	ldr	r3, [r3, #0]
34194e10:	4a68      	ldr	r2, [pc, #416]	@ (34194fb4 <_tx_byte_pool_search+0x218>)
34194e12:	4293      	cmp	r3, r2
34194e14:	d143      	bne.n	34194e9e <_tx_byte_pool_search+0x102>
            {

                /* Determine if this is the first free block.  */
                if (first_free_block_found == TX_FALSE)
34194e16:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34194e18:	2b00      	cmp	r3, #0
34194e1a:	d104      	bne.n	34194e26 <_tx_byte_pool_search+0x8a>
                {
                    /* This is the first free block.  */
                    pool_ptr->tx_byte_pool_search =  current_ptr;
34194e1c:	687b      	ldr	r3, [r7, #4]
34194e1e:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
34194e20:	615a      	str	r2, [r3, #20]

                    /* Set the flag to indicate we have found the first free
                       block.  */
                    first_free_block_found =  TX_TRUE;
34194e22:	2301      	movs	r3, #1
34194e24:	647b      	str	r3, [r7, #68]	@ 0x44
                }

                /* Block is free, see if it is large enough.  */

                /* Pickup the next block's pointer.  */
                this_block_link_ptr =  TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(current_ptr);
34194e26:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
34194e28:	633b      	str	r3, [r7, #48]	@ 0x30
                next_ptr =             *this_block_link_ptr;
34194e2a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34194e2c:	681b      	ldr	r3, [r3, #0]
34194e2e:	62fb      	str	r3, [r7, #44]	@ 0x2c

                /* Calculate the number of bytes available in this block.  */
                available_bytes =   TX_UCHAR_POINTER_DIF(next_ptr, current_ptr);
34194e30:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
34194e32:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
34194e34:	1ad3      	subs	r3, r2, r3
34194e36:	64fb      	str	r3, [r7, #76]	@ 0x4c
                available_bytes =   available_bytes - ((sizeof(UCHAR *)) + (sizeof(ALIGN_TYPE)));
34194e38:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34194e3a:	3b08      	subs	r3, #8
34194e3c:	64fb      	str	r3, [r7, #76]	@ 0x4c

                /* If this is large enough, we are done because our first-fit algorithm
                   has been satisfied!  */
                if (available_bytes >= memory_size)
34194e3e:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
34194e40:	683b      	ldr	r3, [r7, #0]
34194e42:	429a      	cmp	r2, r3
34194e44:	d257      	bcs.n	34194ef6 <_tx_byte_pool_search+0x15a>
                }
                else
                {

                    /* Clear the available bytes variable.  */
                    available_bytes =  ((ULONG) 0);
34194e46:	2300      	movs	r3, #0
34194e48:	64fb      	str	r3, [r7, #76]	@ 0x4c

                    /* Not enough memory, check to see if the neighbor is
                       free and can be merged.  */
                    work_ptr =  TX_UCHAR_POINTER_ADD(next_ptr, (sizeof(UCHAR *)));
34194e4a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34194e4c:	3304      	adds	r3, #4
34194e4e:	63bb      	str	r3, [r7, #56]	@ 0x38
                    free_ptr =  TX_UCHAR_TO_ALIGN_TYPE_POINTER_CONVERT(work_ptr);
34194e50:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34194e52:	637b      	str	r3, [r7, #52]	@ 0x34
                    if ((*free_ptr) == TX_BYTE_BLOCK_FREE)
34194e54:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34194e56:	681b      	ldr	r3, [r3, #0]
34194e58:	4a56      	ldr	r2, [pc, #344]	@ (34194fb4 <_tx_byte_pool_search+0x218>)
34194e5a:	4293      	cmp	r3, r2
34194e5c:	d113      	bne.n	34194e86 <_tx_byte_pool_search+0xea>
                    {

                        /* Yes, neighbor block can be merged!  This is quickly accomplished
                           by updating the current block with the next blocks pointer.  */
                        next_block_link_ptr =  TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(next_ptr);
34194e5e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34194e60:	62bb      	str	r3, [r7, #40]	@ 0x28
                        *this_block_link_ptr =  *next_block_link_ptr;
34194e62:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34194e64:	681a      	ldr	r2, [r3, #0]
34194e66:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34194e68:	601a      	str	r2, [r3, #0]

                        /* Reduce the fragment total.  We don't need to increase the bytes
                           available because all free headers are also included in the available
                           count.  */
                        pool_ptr -> tx_byte_pool_fragments--;
34194e6a:	687b      	ldr	r3, [r7, #4]
34194e6c:	68db      	ldr	r3, [r3, #12]
34194e6e:	1e5a      	subs	r2, r3, #1
34194e70:	687b      	ldr	r3, [r7, #4]
34194e72:	60da      	str	r2, [r3, #12]
                        /* Increment the number of blocks merged on this pool.  */
                        pool_ptr -> tx_byte_pool_performance_merge_count++;
#endif

                        /* See if the search pointer is affected.  */
                        if (pool_ptr -> tx_byte_pool_search ==  next_ptr)
34194e74:	687b      	ldr	r3, [r7, #4]
34194e76:	695b      	ldr	r3, [r3, #20]
34194e78:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
34194e7a:	429a      	cmp	r2, r3
34194e7c:	d114      	bne.n	34194ea8 <_tx_byte_pool_search+0x10c>
                        {
                            /* Yes, update the search pointer.   */
                            pool_ptr -> tx_byte_pool_search =  current_ptr;
34194e7e:	687b      	ldr	r3, [r7, #4]
34194e80:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
34194e82:	615a      	str	r2, [r3, #20]
34194e84:	e010      	b.n	34194ea8 <_tx_byte_pool_search+0x10c>
                        }
                    }
                    else
                    {
                        /* Neighbor is not free so we can skip over it!  */
                        next_block_link_ptr =  TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(next_ptr);
34194e86:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34194e88:	62bb      	str	r3, [r7, #40]	@ 0x28
                        current_ptr =  *next_block_link_ptr;
34194e8a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34194e8c:	681b      	ldr	r3, [r3, #0]
34194e8e:	653b      	str	r3, [r7, #80]	@ 0x50

                        /* Decrement the examined block count to account for this one.  */
                        if (examine_blocks != ((UINT) 0))
34194e90:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
34194e92:	2b00      	cmp	r3, #0
34194e94:	d008      	beq.n	34194ea8 <_tx_byte_pool_search+0x10c>
                        {
                            examine_blocks--;
34194e96:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
34194e98:	3b01      	subs	r3, #1
34194e9a:	64bb      	str	r3, [r7, #72]	@ 0x48
34194e9c:	e004      	b.n	34194ea8 <_tx_byte_pool_search+0x10c>
            }
            else
            {

                /* Block is not free, move to next block.  */
                this_block_link_ptr =  TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(current_ptr);
34194e9e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
34194ea0:	633b      	str	r3, [r7, #48]	@ 0x30
                current_ptr =  *this_block_link_ptr;
34194ea2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34194ea4:	681b      	ldr	r3, [r3, #0]
34194ea6:	653b      	str	r3, [r7, #80]	@ 0x50
            }

            /* Another block has been searched... decrement counter.  */
            if (examine_blocks != ((UINT) 0))
34194ea8:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
34194eaa:	2b00      	cmp	r3, #0
34194eac:	d002      	beq.n	34194eb4 <_tx_byte_pool_search+0x118>
            {

                examine_blocks--;
34194eae:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
34194eb0:	3b01      	subs	r3, #1
34194eb2:	64bb      	str	r3, [r7, #72]	@ 0x48
34194eb4:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34194eb6:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34194eb8:	693b      	ldr	r3, [r7, #16]
34194eba:	f383 8810 	msr	PRIMASK, r3
}
34194ebe:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34194ec0:	f3ef 8310 	mrs	r3, PRIMASK
34194ec4:	61bb      	str	r3, [r7, #24]
    return(posture);
34194ec6:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
34194ec8:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
34194eca:	b672      	cpsid	i
    return(int_posture);
34194ecc:	697b      	ldr	r3, [r7, #20]

            /* Restore interrupts temporarily.  */
            TX_RESTORE

            /* Disable interrupts.  */
            TX_DISABLE
34194ece:	657b      	str	r3, [r7, #84]	@ 0x54

            /* Determine if anything has changed in terms of pool ownership.  */
            if (pool_ptr -> tx_byte_pool_owner != thread_ptr)
34194ed0:	687b      	ldr	r3, [r7, #4]
34194ed2:	6a1b      	ldr	r3, [r3, #32]
34194ed4:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
34194ed6:	429a      	cmp	r2, r3
34194ed8:	d009      	beq.n	34194eee <_tx_byte_pool_search+0x152>
            {

                /* Pool changed ownership in the brief period interrupts were
                   enabled.  Reset the search.  */
                current_ptr =      pool_ptr -> tx_byte_pool_search;
34194eda:	687b      	ldr	r3, [r7, #4]
34194edc:	695b      	ldr	r3, [r3, #20]
34194ede:	653b      	str	r3, [r7, #80]	@ 0x50
                examine_blocks =   pool_ptr -> tx_byte_pool_fragments + ((UINT) 1);
34194ee0:	687b      	ldr	r3, [r7, #4]
34194ee2:	68db      	ldr	r3, [r3, #12]
34194ee4:	3301      	adds	r3, #1
34194ee6:	64bb      	str	r3, [r7, #72]	@ 0x48

                /* Setup our ownership again.  */
                pool_ptr -> tx_byte_pool_owner =  thread_ptr;
34194ee8:	687b      	ldr	r3, [r7, #4]
34194eea:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
34194eec:	621a      	str	r2, [r3, #32]
            }
        } while(examine_blocks != ((UINT) 0));
34194eee:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
34194ef0:	2b00      	cmp	r3, #0
34194ef2:	d186      	bne.n	34194e02 <_tx_byte_pool_search+0x66>
34194ef4:	e000      	b.n	34194ef8 <_tx_byte_pool_search+0x15c>
                    break;
34194ef6:	bf00      	nop

        /* Determine if a block was found.  If so, determine if it needs to be
           split.  */
        if (available_bytes != ((ULONG) 0))
34194ef8:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34194efa:	2b00      	cmp	r3, #0
34194efc:	d048      	beq.n	34194f90 <_tx_byte_pool_search+0x1f4>
        {

            /* Determine if we need to split this block.  */
            if ((available_bytes - memory_size) >= ((ULONG) TX_BYTE_BLOCK_MIN))
34194efe:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
34194f00:	683b      	ldr	r3, [r7, #0]
34194f02:	1ad3      	subs	r3, r2, r3
34194f04:	2b13      	cmp	r3, #19
34194f06:	d91e      	bls.n	34194f46 <_tx_byte_pool_search+0x1aa>
            {

                /* Split the block.  */
                next_ptr =  TX_UCHAR_POINTER_ADD(current_ptr, (memory_size + ((sizeof(UCHAR *)) + (sizeof(ALIGN_TYPE)))));
34194f08:	683b      	ldr	r3, [r7, #0]
34194f0a:	3308      	adds	r3, #8
34194f0c:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
34194f0e:	4413      	add	r3, r2
34194f10:	62fb      	str	r3, [r7, #44]	@ 0x2c

                /* Setup the new free block.  */
                next_block_link_ptr =   TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(next_ptr);
34194f12:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34194f14:	62bb      	str	r3, [r7, #40]	@ 0x28
                this_block_link_ptr =   TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(current_ptr);
34194f16:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
34194f18:	633b      	str	r3, [r7, #48]	@ 0x30
                *next_block_link_ptr =  *this_block_link_ptr;
34194f1a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34194f1c:	681a      	ldr	r2, [r3, #0]
34194f1e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34194f20:	601a      	str	r2, [r3, #0]
                work_ptr =              TX_UCHAR_POINTER_ADD(next_ptr, (sizeof(UCHAR *)));
34194f22:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34194f24:	3304      	adds	r3, #4
34194f26:	63bb      	str	r3, [r7, #56]	@ 0x38
                free_ptr =              TX_UCHAR_TO_ALIGN_TYPE_POINTER_CONVERT(work_ptr);
34194f28:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34194f2a:	637b      	str	r3, [r7, #52]	@ 0x34
                *free_ptr =             TX_BYTE_BLOCK_FREE;
34194f2c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34194f2e:	4a21      	ldr	r2, [pc, #132]	@ (34194fb4 <_tx_byte_pool_search+0x218>)
34194f30:	601a      	str	r2, [r3, #0]

                /* Increase the total fragment counter.  */
                pool_ptr -> tx_byte_pool_fragments++;
34194f32:	687b      	ldr	r3, [r7, #4]
34194f34:	68db      	ldr	r3, [r3, #12]
34194f36:	1c5a      	adds	r2, r3, #1
34194f38:	687b      	ldr	r3, [r7, #4]
34194f3a:	60da      	str	r2, [r3, #12]

                /* Update the current pointer to point at the newly created block.  */
                *this_block_link_ptr =  next_ptr;
34194f3c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34194f3e:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
34194f40:	601a      	str	r2, [r3, #0]

                /* Set available equal to memory size for subsequent calculation.  */
                available_bytes =  memory_size;
34194f42:	683b      	ldr	r3, [r7, #0]
34194f44:	64fb      	str	r3, [r7, #76]	@ 0x4c
                pool_ptr -> tx_byte_pool_performance_split_count++;
#endif
            }

            /* In any case, mark the current block as allocated.  */
            work_ptr =              TX_UCHAR_POINTER_ADD(current_ptr, (sizeof(UCHAR *)));
34194f46:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
34194f48:	3304      	adds	r3, #4
34194f4a:	63bb      	str	r3, [r7, #56]	@ 0x38
            this_block_link_ptr =   TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(work_ptr);
34194f4c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34194f4e:	633b      	str	r3, [r7, #48]	@ 0x30
            *this_block_link_ptr =  TX_BYTE_POOL_TO_UCHAR_POINTER_CONVERT(pool_ptr);
34194f50:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34194f52:	687a      	ldr	r2, [r7, #4]
34194f54:	601a      	str	r2, [r3, #0]

            /* Reduce the number of available bytes in the pool.  */
            pool_ptr -> tx_byte_pool_available =  (pool_ptr -> tx_byte_pool_available - available_bytes) - ((sizeof(UCHAR *)) + (sizeof(ALIGN_TYPE)));
34194f56:	687b      	ldr	r3, [r7, #4]
34194f58:	689a      	ldr	r2, [r3, #8]
34194f5a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34194f5c:	1ad3      	subs	r3, r2, r3
34194f5e:	f1a3 0208 	sub.w	r2, r3, #8
34194f62:	687b      	ldr	r3, [r7, #4]
34194f64:	609a      	str	r2, [r3, #8]

            /* Determine if the search pointer needs to be updated. This is only done
               if the search pointer matches the block to be returned.  */
            if (current_ptr == pool_ptr -> tx_byte_pool_search)
34194f66:	687b      	ldr	r3, [r7, #4]
34194f68:	695b      	ldr	r3, [r3, #20]
34194f6a:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
34194f6c:	429a      	cmp	r2, r3
34194f6e:	d105      	bne.n	34194f7c <_tx_byte_pool_search+0x1e0>
            {

                /* Yes, update the search pointer to the next block.  */
                this_block_link_ptr =   TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(current_ptr);
34194f70:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
34194f72:	633b      	str	r3, [r7, #48]	@ 0x30
                pool_ptr -> tx_byte_pool_search =  *this_block_link_ptr;
34194f74:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34194f76:	681a      	ldr	r2, [r3, #0]
34194f78:	687b      	ldr	r3, [r7, #4]
34194f7a:	615a      	str	r2, [r3, #20]
34194f7c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34194f7e:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34194f80:	68fb      	ldr	r3, [r7, #12]
34194f82:	f383 8810 	msr	PRIMASK, r3
}
34194f86:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Adjust the pointer for the application.  */
            current_ptr =  TX_UCHAR_POINTER_ADD(current_ptr, (((sizeof(UCHAR *)) + (sizeof(ALIGN_TYPE)))));
34194f88:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
34194f8a:	3308      	adds	r3, #8
34194f8c:	653b      	str	r3, [r7, #80]	@ 0x50
34194f8e:	e007      	b.n	34194fa0 <_tx_byte_pool_search+0x204>
34194f90:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34194f92:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34194f94:	68bb      	ldr	r3, [r7, #8]
34194f96:	f383 8810 	msr	PRIMASK, r3
}
34194f9a:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Set current pointer to NULL to indicate nothing was found.  */
            current_ptr =  TX_NULL;
34194f9c:	2300      	movs	r3, #0
34194f9e:	653b      	str	r3, [r7, #80]	@ 0x50
        }
    }

    /* Return the search pointer.  */
    return(current_ptr);
34194fa0:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
}
34194fa2:	4618      	mov	r0, r3
34194fa4:	375c      	adds	r7, #92	@ 0x5c
34194fa6:	46bd      	mov	sp, r7
34194fa8:	f85d 7b04 	ldr.w	r7, [sp], #4
34194fac:	4770      	bx	lr
34194fae:	bf00      	nop
34194fb0:	341c2dec 	.word	0x341c2dec
34194fb4:	ffffeeee 	.word	0xffffeeee

34194fb8 <_tx_event_flags_cleanup>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_event_flags_cleanup(TX_THREAD  *thread_ptr, ULONG suspension_sequence)
{
34194fb8:	b580      	push	{r7, lr}
34194fba:	b08e      	sub	sp, #56	@ 0x38
34194fbc:	af00      	add	r7, sp, #0
34194fbe:	6078      	str	r0, [r7, #4]
34194fc0:	6039      	str	r1, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34194fc2:	f3ef 8310 	mrs	r3, PRIMASK
34194fc6:	61fb      	str	r3, [r7, #28]
    return(posture);
34194fc8:	69fb      	ldr	r3, [r7, #28]
    int_posture = __get_interrupt_posture();
34194fca:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("CPSID i" : : : "memory");
34194fcc:	b672      	cpsid	i
    return(int_posture);
34194fce:	69bb      	ldr	r3, [r7, #24]


#ifndef TX_NOT_INTERRUPTABLE

    /* Disable interrupts to remove the suspended thread from the event flags group.  */
    TX_DISABLE
34194fd0:	637b      	str	r3, [r7, #52]	@ 0x34

    /* Determine if the cleanup is still required.  */
    if (thread_ptr -> tx_thread_suspend_cleanup == &(_tx_event_flags_cleanup))
34194fd2:	687b      	ldr	r3, [r7, #4]
34194fd4:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
34194fd6:	4a38      	ldr	r2, [pc, #224]	@ (341950b8 <_tx_event_flags_cleanup+0x100>)
34194fd8:	4293      	cmp	r3, r2
34194fda:	d162      	bne.n	341950a2 <_tx_event_flags_cleanup+0xea>
    {

        /* Check for valid suspension sequence.  */
        if (suspension_sequence == thread_ptr -> tx_thread_suspension_sequence)
34194fdc:	687b      	ldr	r3, [r7, #4]
34194fde:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
34194fe2:	683a      	ldr	r2, [r7, #0]
34194fe4:	429a      	cmp	r2, r3
34194fe6:	d15c      	bne.n	341950a2 <_tx_event_flags_cleanup+0xea>
        {

            /* Setup pointer to event flags control block.  */
            group_ptr =  TX_VOID_TO_EVENT_FLAGS_POINTER_CONVERT(thread_ptr -> tx_thread_suspend_control_block);
34194fe8:	687b      	ldr	r3, [r7, #4]
34194fea:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
34194fec:	633b      	str	r3, [r7, #48]	@ 0x30

            /* Check for a NULL event flags control block pointer.  */
            if (group_ptr != TX_NULL)
34194fee:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34194ff0:	2b00      	cmp	r3, #0
34194ff2:	d056      	beq.n	341950a2 <_tx_event_flags_cleanup+0xea>
            {

                /* Is the group pointer ID valid?  */
                if (group_ptr -> tx_event_flags_group_id == TX_EVENT_FLAGS_ID)
34194ff4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34194ff6:	681b      	ldr	r3, [r3, #0]
34194ff8:	4a30      	ldr	r2, [pc, #192]	@ (341950bc <_tx_event_flags_cleanup+0x104>)
34194ffa:	4293      	cmp	r3, r2
34194ffc:	d151      	bne.n	341950a2 <_tx_event_flags_cleanup+0xea>
                {

                    /* Determine if there are any thread suspensions.  */
                    if (group_ptr -> tx_event_flags_group_suspended_count != TX_NO_SUSPENSIONS)
34194ffe:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34195000:	695b      	ldr	r3, [r3, #20]
34195002:	2b00      	cmp	r3, #0
34195004:	d04d      	beq.n	341950a2 <_tx_event_flags_cleanup+0xea>
#endif

                        /* Yes, we still have thread suspension!  */

                        /* Clear the suspension cleanup flag.  */
                        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
34195006:	687b      	ldr	r3, [r7, #4]
34195008:	2200      	movs	r2, #0
3419500a:	669a      	str	r2, [r3, #104]	@ 0x68

                        /* Pickup the suspended count.  */
                        suspended_count =  group_ptr -> tx_event_flags_group_suspended_count;
3419500c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3419500e:	695b      	ldr	r3, [r3, #20]
34195010:	62fb      	str	r3, [r7, #44]	@ 0x2c

                        /* Pickup the suspension head.  */
                        suspension_head =  group_ptr -> tx_event_flags_group_suspension_list;
34195012:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34195014:	691b      	ldr	r3, [r3, #16]
34195016:	62bb      	str	r3, [r7, #40]	@ 0x28

                        /* Determine if the cleanup is being done while a set operation was interrupted.  If the
                           suspended count is non-zero and the suspension head is NULL, the list is being processed
                           and cannot be touched from here. The suspension list removal will instead take place
                           inside the event flag set code.  */
                        if (suspension_head != TX_NULL)
34195018:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419501a:	2b00      	cmp	r3, #0
3419501c:	d020      	beq.n	34195060 <_tx_event_flags_cleanup+0xa8>
                        {

                            /* Remove the suspended thread from the list.  */

                            /* Decrement the local suspension count.  */
                            suspended_count--;
3419501e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34195020:	3b01      	subs	r3, #1
34195022:	62fb      	str	r3, [r7, #44]	@ 0x2c

                            /* Store the updated suspended count.  */
                            group_ptr -> tx_event_flags_group_suspended_count =  suspended_count;
34195024:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34195026:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
34195028:	615a      	str	r2, [r3, #20]

                            /* See if this is the only suspended thread on the list.  */
                            if (suspended_count == TX_NO_SUSPENSIONS)
3419502a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3419502c:	2b00      	cmp	r3, #0
3419502e:	d103      	bne.n	34195038 <_tx_event_flags_cleanup+0x80>
                            {

                                /* Yes, the only suspended thread.  */

                                /* Update the head pointer.  */
                                group_ptr -> tx_event_flags_group_suspension_list =  TX_NULL;
34195030:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34195032:	2200      	movs	r2, #0
34195034:	611a      	str	r2, [r3, #16]
34195036:	e016      	b.n	34195066 <_tx_event_flags_cleanup+0xae>
                            {

                                /* At least one more thread is on the same suspension list.  */

                                /* Update the links of the adjacent threads.  */
                                next_thread =                                  thread_ptr -> tx_thread_suspended_next;
34195038:	687b      	ldr	r3, [r7, #4]
3419503a:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3419503c:	627b      	str	r3, [r7, #36]	@ 0x24
                                previous_thread =                              thread_ptr -> tx_thread_suspended_previous;
3419503e:	687b      	ldr	r3, [r7, #4]
34195040:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34195042:	623b      	str	r3, [r7, #32]
                                next_thread -> tx_thread_suspended_previous =  previous_thread;
34195044:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34195046:	6a3a      	ldr	r2, [r7, #32]
34195048:	675a      	str	r2, [r3, #116]	@ 0x74
                                previous_thread -> tx_thread_suspended_next =  next_thread;
3419504a:	6a3b      	ldr	r3, [r7, #32]
3419504c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
3419504e:	671a      	str	r2, [r3, #112]	@ 0x70

                                /* Determine if we need to update the head pointer.  */
                                if (suspension_head == thread_ptr)
34195050:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34195052:	687b      	ldr	r3, [r7, #4]
34195054:	429a      	cmp	r2, r3
34195056:	d106      	bne.n	34195066 <_tx_event_flags_cleanup+0xae>
                                {

                                    /* Update the list head pointer.  */
                                    group_ptr -> tx_event_flags_group_suspension_list =  next_thread;
34195058:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3419505a:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
3419505c:	611a      	str	r2, [r3, #16]
3419505e:	e002      	b.n	34195066 <_tx_event_flags_cleanup+0xae>
                        }
                        else
                        {

                            /* In this case, the search pointer in an interrupted event flag set must be reset.  */
                            group_ptr -> tx_event_flags_group_reset_search =  TX_TRUE;
34195060:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34195062:	2201      	movs	r2, #1
34195064:	60da      	str	r2, [r3, #12]
                        }

                        /* Now we need to determine if this cleanup is from a terminate, timeout,
                           or from a wait abort.  */
                        if (thread_ptr -> tx_thread_state == TX_EVENT_FLAG)
34195066:	687b      	ldr	r3, [r7, #4]
34195068:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3419506a:	2b07      	cmp	r3, #7
3419506c:	d119      	bne.n	341950a2 <_tx_event_flags_cleanup+0xea>
                            /* Increment the number of timeouts on this event flags group.  */
                            group_ptr -> tx_event_flags_group____performance_timeout_count++;
#endif

                            /* Setup return status.  */
                            thread_ptr -> tx_thread_suspend_status =  TX_NO_EVENTS;
3419506e:	687b      	ldr	r3, [r7, #4]
34195070:	2207      	movs	r2, #7
34195072:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
                            /* Resume the thread!  */
                            _tx_thread_system_ni_resume(thread_ptr);
#else

                           /* Temporarily disable preemption.  */
                            _tx_thread_preempt_disable++;
34195076:	4b12      	ldr	r3, [pc, #72]	@ (341950c0 <_tx_event_flags_cleanup+0x108>)
34195078:	681b      	ldr	r3, [r3, #0]
3419507a:	3301      	adds	r3, #1
3419507c:	4a10      	ldr	r2, [pc, #64]	@ (341950c0 <_tx_event_flags_cleanup+0x108>)
3419507e:	6013      	str	r3, [r2, #0]
34195080:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34195082:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34195084:	68fb      	ldr	r3, [r7, #12]
34195086:	f383 8810 	msr	PRIMASK, r3
}
3419508a:	bf00      	nop
                            TX_RESTORE

                            /* Resume the thread!  Check for preemption even though we are executing
                               from the system timer thread right now which normally executes at the
                               highest priority.  */
                            _tx_thread_system_resume(thread_ptr);
3419508c:	6878      	ldr	r0, [r7, #4]
3419508e:	f002 fbf9 	bl	34197884 <_tx_thread_system_resume>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34195092:	f3ef 8310 	mrs	r3, PRIMASK
34195096:	617b      	str	r3, [r7, #20]
    return(posture);
34195098:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
3419509a:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
3419509c:	b672      	cpsid	i
    return(int_posture);
3419509e:	693b      	ldr	r3, [r7, #16]

                            /* Disable interrupts.  */
                            TX_DISABLE
341950a0:	637b      	str	r3, [r7, #52]	@ 0x34
341950a2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
341950a4:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
341950a6:	68bb      	ldr	r3, [r7, #8]
341950a8:	f383 8810 	msr	PRIMASK, r3
}
341950ac:	bf00      	nop
    }

    /* Restore interrupts.  */
    TX_RESTORE
#endif
}
341950ae:	bf00      	nop
341950b0:	3738      	adds	r7, #56	@ 0x38
341950b2:	46bd      	mov	sp, r7
341950b4:	bd80      	pop	{r7, pc}
341950b6:	bf00      	nop
341950b8:	34194fb9 	.word	0x34194fb9
341950bc:	4456444e 	.word	0x4456444e
341950c0:	341c2e84 	.word	0x341c2e84

341950c4 <_tx_event_flags_create>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_event_flags_create(TX_EVENT_FLAGS_GROUP *group_ptr, CHAR *name_ptr)
{
341950c4:	b580      	push	{r7, lr}
341950c6:	b088      	sub	sp, #32
341950c8:	af00      	add	r7, sp, #0
341950ca:	6078      	str	r0, [r7, #4]
341950cc:	6039      	str	r1, [r7, #0]
TX_EVENT_FLAGS_GROUP    *next_group;
TX_EVENT_FLAGS_GROUP    *previous_group;


    /* Initialize event flags control block to all zeros.  */
    TX_MEMSET(group_ptr, 0, (sizeof(TX_EVENT_FLAGS_GROUP)));
341950ce:	2224      	movs	r2, #36	@ 0x24
341950d0:	2100      	movs	r1, #0
341950d2:	6878      	ldr	r0, [r7, #4]
341950d4:	f008 fff4 	bl	3419e0c0 <memset>

    /* Setup the basic event flags group fields.  */
    group_ptr -> tx_event_flags_group_name =             name_ptr;
341950d8:	687b      	ldr	r3, [r7, #4]
341950da:	683a      	ldr	r2, [r7, #0]
341950dc:	605a      	str	r2, [r3, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
341950de:	f3ef 8310 	mrs	r3, PRIMASK
341950e2:	613b      	str	r3, [r7, #16]
    return(posture);
341950e4:	693b      	ldr	r3, [r7, #16]
    int_posture = __get_interrupt_posture();
341950e6:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("CPSID i" : : : "memory");
341950e8:	b672      	cpsid	i
    return(int_posture);
341950ea:	68fb      	ldr	r3, [r7, #12]

    /* Disable interrupts to put the event flags group on the created list.  */
    TX_DISABLE
341950ec:	61fb      	str	r3, [r7, #28]

    /* Setup the event flags ID to make it valid.  */
    group_ptr -> tx_event_flags_group_id =  TX_EVENT_FLAGS_ID;
341950ee:	687b      	ldr	r3, [r7, #4]
341950f0:	4a18      	ldr	r2, [pc, #96]	@ (34195154 <_tx_event_flags_create+0x90>)
341950f2:	601a      	str	r2, [r3, #0]

    /* Place the group on the list of created event flag groups.  First,
       check for an empty list.  */
    if (_tx_event_flags_created_count == TX_EMPTY)
341950f4:	4b18      	ldr	r3, [pc, #96]	@ (34195158 <_tx_event_flags_create+0x94>)
341950f6:	681b      	ldr	r3, [r3, #0]
341950f8:	2b00      	cmp	r3, #0
341950fa:	d109      	bne.n	34195110 <_tx_event_flags_create+0x4c>
    {

        /* The created event flags list is empty.  Add event flag group to empty list.  */
        _tx_event_flags_created_ptr =                         group_ptr;
341950fc:	4a17      	ldr	r2, [pc, #92]	@ (3419515c <_tx_event_flags_create+0x98>)
341950fe:	687b      	ldr	r3, [r7, #4]
34195100:	6013      	str	r3, [r2, #0]
        group_ptr -> tx_event_flags_group_created_next =      group_ptr;
34195102:	687b      	ldr	r3, [r7, #4]
34195104:	687a      	ldr	r2, [r7, #4]
34195106:	619a      	str	r2, [r3, #24]
        group_ptr -> tx_event_flags_group_created_previous =  group_ptr;
34195108:	687b      	ldr	r3, [r7, #4]
3419510a:	687a      	ldr	r2, [r7, #4]
3419510c:	61da      	str	r2, [r3, #28]
3419510e:	e011      	b.n	34195134 <_tx_event_flags_create+0x70>
    }
    else
    {

        /* This list is not NULL, add to the end of the list.  */
        next_group =      _tx_event_flags_created_ptr;
34195110:	4b12      	ldr	r3, [pc, #72]	@ (3419515c <_tx_event_flags_create+0x98>)
34195112:	681b      	ldr	r3, [r3, #0]
34195114:	61bb      	str	r3, [r7, #24]
        previous_group =  next_group -> tx_event_flags_group_created_previous;
34195116:	69bb      	ldr	r3, [r7, #24]
34195118:	69db      	ldr	r3, [r3, #28]
3419511a:	617b      	str	r3, [r7, #20]

        /* Place the new event flag group in the list.  */
        next_group -> tx_event_flags_group_created_previous =  group_ptr;
3419511c:	69bb      	ldr	r3, [r7, #24]
3419511e:	687a      	ldr	r2, [r7, #4]
34195120:	61da      	str	r2, [r3, #28]
        previous_group -> tx_event_flags_group_created_next =  group_ptr;
34195122:	697b      	ldr	r3, [r7, #20]
34195124:	687a      	ldr	r2, [r7, #4]
34195126:	619a      	str	r2, [r3, #24]

        /* Setup this group's created links.  */
        group_ptr -> tx_event_flags_group_created_previous =  previous_group;
34195128:	687b      	ldr	r3, [r7, #4]
3419512a:	697a      	ldr	r2, [r7, #20]
3419512c:	61da      	str	r2, [r3, #28]
        group_ptr -> tx_event_flags_group_created_next =      next_group;
3419512e:	687b      	ldr	r3, [r7, #4]
34195130:	69ba      	ldr	r2, [r7, #24]
34195132:	619a      	str	r2, [r3, #24]
    }

    /* Increment the number of created event flag groups.  */
    _tx_event_flags_created_count++;
34195134:	4b08      	ldr	r3, [pc, #32]	@ (34195158 <_tx_event_flags_create+0x94>)
34195136:	681b      	ldr	r3, [r3, #0]
34195138:	3301      	adds	r3, #1
3419513a:	4a07      	ldr	r2, [pc, #28]	@ (34195158 <_tx_event_flags_create+0x94>)
3419513c:	6013      	str	r3, [r2, #0]
3419513e:	69fb      	ldr	r3, [r7, #28]
34195140:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34195142:	68bb      	ldr	r3, [r7, #8]
34195144:	f383 8810 	msr	PRIMASK, r3
}
34195148:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
3419514a:	2300      	movs	r3, #0
}
3419514c:	4618      	mov	r0, r3
3419514e:	3720      	adds	r7, #32
34195150:	46bd      	mov	sp, r7
34195152:	bd80      	pop	{r7, pc}
34195154:	4456444e 	.word	0x4456444e
34195158:	341c2dc8 	.word	0x341c2dc8
3419515c:	341c2dc4 	.word	0x341c2dc4

34195160 <_tx_event_flags_get>:
/*                                            resulting in version 6.2.0  */
/*                                                                        */
/**************************************************************************/
UINT  _tx_event_flags_get(TX_EVENT_FLAGS_GROUP *group_ptr, ULONG requested_flags,
                    UINT get_option, ULONG *actual_flags_ptr, ULONG wait_option)
{
34195160:	b580      	push	{r7, lr}
34195162:	b096      	sub	sp, #88	@ 0x58
34195164:	af00      	add	r7, sp, #0
34195166:	60f8      	str	r0, [r7, #12]
34195168:	60b9      	str	r1, [r7, #8]
3419516a:	607a      	str	r2, [r7, #4]
3419516c:	603b      	str	r3, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
3419516e:	f3ef 8310 	mrs	r3, PRIMASK
34195172:	627b      	str	r3, [r7, #36]	@ 0x24
    return(posture);
34195174:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
    int_posture = __get_interrupt_posture();
34195176:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("CPSID i" : : : "memory");
34195178:	b672      	cpsid	i
    return(int_posture);
3419517a:	6a3b      	ldr	r3, [r7, #32]
UINT            interrupted_set_request;
#endif


    /* Disable interrupts to examine the event flags group.  */
    TX_DISABLE
3419517c:	657b      	str	r3, [r7, #84]	@ 0x54

    /* Log this kernel call.  */
    TX_EL_EVENT_FLAGS_GET_INSERT

    /* Pickup current flags.  */
    current_flags =  group_ptr -> tx_event_flags_group_current;
3419517e:	68fb      	ldr	r3, [r7, #12]
34195180:	689b      	ldr	r3, [r3, #8]
34195182:	64fb      	str	r3, [r7, #76]	@ 0x4c

    /* Return the actual event flags and apply delayed clearing.  */
    *actual_flags_ptr =  current_flags & ~group_ptr -> tx_event_flags_group_delayed_clear;
34195184:	68fb      	ldr	r3, [r7, #12]
34195186:	6a1b      	ldr	r3, [r3, #32]
34195188:	43da      	mvns	r2, r3
3419518a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3419518c:	401a      	ands	r2, r3
3419518e:	683b      	ldr	r3, [r7, #0]
34195190:	601a      	str	r2, [r3, #0]

    /* Apply the event flag option mask.  */
    and_request =  (get_option & TX_AND);
34195192:	687b      	ldr	r3, [r7, #4]
34195194:	f003 0302 	and.w	r3, r3, #2
34195198:	643b      	str	r3, [r7, #64]	@ 0x40
    }

#else

    /* Pickup delayed clear flags.  */
    delayed_clear_flags =  group_ptr -> tx_event_flags_group_delayed_clear;
3419519a:	68fb      	ldr	r3, [r7, #12]
3419519c:	6a1b      	ldr	r3, [r3, #32]
3419519e:	63fb      	str	r3, [r7, #60]	@ 0x3c

    /* Determine if there are any delayed clear operations pending.  */
    if (delayed_clear_flags != ((ULONG) 0))
341951a0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
341951a2:	2b00      	cmp	r3, #0
341951a4:	d004      	beq.n	341951b0 <_tx_event_flags_get+0x50>
    {

        /* Yes, apply them to the current flags.  */
        current_flags =  current_flags & (~delayed_clear_flags);
341951a6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
341951a8:	43db      	mvns	r3, r3
341951aa:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
341951ac:	4013      	ands	r3, r2
341951ae:	64fb      	str	r3, [r7, #76]	@ 0x4c
    }

    /* Check for AND condition. All flags must be present to satisfy request.  */
    if (and_request == TX_AND)
341951b0:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
341951b2:	2b02      	cmp	r3, #2
341951b4:	d10a      	bne.n	341951cc <_tx_event_flags_get+0x6c>
    {

        /* AND request is present.  */

        /* Calculate the flags present.  */
        flags_satisfied =  (current_flags & requested_flags);
341951b6:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
341951b8:	68bb      	ldr	r3, [r7, #8]
341951ba:	4013      	ands	r3, r2
341951bc:	64bb      	str	r3, [r7, #72]	@ 0x48

        /* Determine if they satisfy the AND request.  */
        if (flags_satisfied != requested_flags)
341951be:	6cba      	ldr	r2, [r7, #72]	@ 0x48
341951c0:	68bb      	ldr	r3, [r7, #8]
341951c2:	429a      	cmp	r2, r3
341951c4:	d006      	beq.n	341951d4 <_tx_event_flags_get+0x74>
        {

            /* No, not all the requested flags are present. Clear the flags present variable.  */
            flags_satisfied =  ((ULONG) 0);
341951c6:	2300      	movs	r3, #0
341951c8:	64bb      	str	r3, [r7, #72]	@ 0x48
341951ca:	e003      	b.n	341951d4 <_tx_event_flags_get+0x74>
    else
    {

        /* OR request is present. Simply AND together the requested flags and the current flags
           to see if any are present.  */
        flags_satisfied =  (current_flags & requested_flags);
341951cc:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
341951ce:	68bb      	ldr	r3, [r7, #8]
341951d0:	4013      	ands	r3, r2
341951d2:	64bb      	str	r3, [r7, #72]	@ 0x48
    }

    /* Determine if the request is satisfied.  */
    if (flags_satisfied != ((ULONG) 0))
341951d4:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
341951d6:	2b00      	cmp	r3, #0
341951d8:	d026      	beq.n	34195228 <_tx_event_flags_get+0xc8>
    {

        /* Yes, this request can be handled immediately.  */

        /* Pickup the clear bit.  */
        clear_request =  (get_option & TX_EVENT_FLAGS_CLEAR_MASK);
341951da:	687b      	ldr	r3, [r7, #4]
341951dc:	f003 0301 	and.w	r3, r3, #1
341951e0:	62bb      	str	r3, [r7, #40]	@ 0x28

        /* Determine whether or not clearing needs to take place.  */
        if (clear_request == TX_TRUE)
341951e2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
341951e4:	2b01      	cmp	r3, #1
341951e6:	d11c      	bne.n	34195222 <_tx_event_flags_get+0xc2>
        {

            /* Set interrupted set request flag to false.  */
            interrupted_set_request =  TX_FALSE;
341951e8:	2300      	movs	r3, #0
341951ea:	647b      	str	r3, [r7, #68]	@ 0x44

            /* Determine if the suspension list is being processed by an interrupted
               set request.  */
            if (group_ptr -> tx_event_flags_group_suspended_count != TX_NO_SUSPENSIONS)
341951ec:	68fb      	ldr	r3, [r7, #12]
341951ee:	695b      	ldr	r3, [r3, #20]
341951f0:	2b00      	cmp	r3, #0
341951f2:	d005      	beq.n	34195200 <_tx_event_flags_get+0xa0>
            {

                if (group_ptr -> tx_event_flags_group_suspension_list == TX_NULL)
341951f4:	68fb      	ldr	r3, [r7, #12]
341951f6:	691b      	ldr	r3, [r3, #16]
341951f8:	2b00      	cmp	r3, #0
341951fa:	d101      	bne.n	34195200 <_tx_event_flags_get+0xa0>
                {

                    /* Set the interrupted set request flag.  */
                    interrupted_set_request =  TX_TRUE;
341951fc:	2301      	movs	r3, #1
341951fe:	647b      	str	r3, [r7, #68]	@ 0x44
                }
            }

            /* Was a set request interrupted?  */
            if (interrupted_set_request == TX_TRUE)
34195200:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34195202:	2b01      	cmp	r3, #1
34195204:	d106      	bne.n	34195214 <_tx_event_flags_get+0xb4>
                /* A previous set operation is was interrupted, we need to defer the
                   event clearing until the set operation is complete.  */

                /* Remember the events to clear.  */
                group_ptr -> tx_event_flags_group_delayed_clear =
                                        group_ptr -> tx_event_flags_group_delayed_clear | requested_flags;
34195206:	68fb      	ldr	r3, [r7, #12]
34195208:	6a1a      	ldr	r2, [r3, #32]
3419520a:	68bb      	ldr	r3, [r7, #8]
3419520c:	431a      	orrs	r2, r3
                group_ptr -> tx_event_flags_group_delayed_clear =
3419520e:	68fb      	ldr	r3, [r7, #12]
34195210:	621a      	str	r2, [r3, #32]
34195212:	e006      	b.n	34195222 <_tx_event_flags_get+0xc2>
            else
            {

                /* Yes, clear the flags that satisfied this request.  */
                group_ptr -> tx_event_flags_group_current =
                                        group_ptr -> tx_event_flags_group_current & ~requested_flags;
34195214:	68fb      	ldr	r3, [r7, #12]
34195216:	689a      	ldr	r2, [r3, #8]
34195218:	68bb      	ldr	r3, [r7, #8]
3419521a:	43db      	mvns	r3, r3
3419521c:	401a      	ands	r2, r3
                group_ptr -> tx_event_flags_group_current =
3419521e:	68fb      	ldr	r3, [r7, #12]
34195220:	609a      	str	r2, [r3, #8]
            }
        }

        /* Set status to success.  */
        status =  TX_SUCCESS;
34195222:	2300      	movs	r3, #0
34195224:	653b      	str	r3, [r7, #80]	@ 0x50
34195226:	e073      	b.n	34195310 <_tx_event_flags_get+0x1b0>
#endif
    else
    {
        /* flags_satisfied is 0.  */
        /* Determine if the request specifies suspension.  */
        if (wait_option != TX_NO_WAIT)
34195228:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3419522a:	2b00      	cmp	r3, #0
3419522c:	d06e      	beq.n	3419530c <_tx_event_flags_get+0x1ac>
        {

            /* Determine if the preempt disable flag is non-zero OR the requested events is 0.  */
            if ((_tx_thread_preempt_disable != ((UINT) 0)) || (requested_flags == (UINT) 0))
3419522e:	4b3e      	ldr	r3, [pc, #248]	@ (34195328 <_tx_event_flags_get+0x1c8>)
34195230:	681b      	ldr	r3, [r3, #0]
34195232:	2b00      	cmp	r3, #0
34195234:	d102      	bne.n	3419523c <_tx_event_flags_get+0xdc>
34195236:	68bb      	ldr	r3, [r7, #8]
34195238:	2b00      	cmp	r3, #0
3419523a:	d102      	bne.n	34195242 <_tx_event_flags_get+0xe2>
            {

                /* Suspension is not allowed if the preempt disable flag is non-zero at this point,
                   or if requested_flags is 0, return error completion.  */
                status =  TX_NO_EVENTS;
3419523c:	2307      	movs	r3, #7
3419523e:	653b      	str	r3, [r7, #80]	@ 0x50
34195240:	e066      	b.n	34195310 <_tx_event_flags_get+0x1b0>
                /* Increment the number of event flags suspensions on this semaphore.  */
                group_ptr -> tx_event_flags_group___performance_suspension_count++;
#endif

                /* Pickup thread pointer.  */
                TX_THREAD_GET_CURRENT(thread_ptr)
34195242:	4b3a      	ldr	r3, [pc, #232]	@ (3419532c <_tx_event_flags_get+0x1cc>)
34195244:	681b      	ldr	r3, [r3, #0]
34195246:	63bb      	str	r3, [r7, #56]	@ 0x38

                /* Setup cleanup routine pointer.  */
                thread_ptr -> tx_thread_suspend_cleanup =  &(_tx_event_flags_cleanup);
34195248:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419524a:	4a39      	ldr	r2, [pc, #228]	@ (34195330 <_tx_event_flags_get+0x1d0>)
3419524c:	669a      	str	r2, [r3, #104]	@ 0x68

                /* Remember which event flags we are looking for.  */
                thread_ptr -> tx_thread_suspend_info =  requested_flags;
3419524e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34195250:	68ba      	ldr	r2, [r7, #8]
34195252:	679a      	str	r2, [r3, #120]	@ 0x78

                /* Save the get option as well.  */
                thread_ptr -> tx_thread_suspend_option =  get_option;
34195254:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34195256:	687a      	ldr	r2, [r7, #4]
34195258:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

                /* Save the destination for the current events.  */
                thread_ptr -> tx_thread_additional_suspend_info =  (VOID *) actual_flags_ptr;
3419525c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419525e:	683a      	ldr	r2, [r7, #0]
34195260:	67da      	str	r2, [r3, #124]	@ 0x7c

                /* Setup cleanup information, i.e. this event flags group control
                   block.  */
                thread_ptr -> tx_thread_suspend_control_block =  (VOID *) group_ptr;
34195262:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34195264:	68fa      	ldr	r2, [r7, #12]
34195266:	66da      	str	r2, [r3, #108]	@ 0x6c

#ifndef TX_NOT_INTERRUPTABLE

                /* Increment the suspension sequence number, which is used to identify
                   this suspension event.  */
                thread_ptr -> tx_thread_suspension_sequence++;
34195268:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419526a:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
3419526e:	1c5a      	adds	r2, r3, #1
34195270:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34195272:	f8c3 20ac 	str.w	r2, [r3, #172]	@ 0xac
#endif

                /* Pickup the suspended count.  */
                suspended_count =  group_ptr -> tx_event_flags_group_suspended_count;
34195276:	68fb      	ldr	r3, [r7, #12]
34195278:	695b      	ldr	r3, [r3, #20]
3419527a:	637b      	str	r3, [r7, #52]	@ 0x34

                /* Setup suspension list.  */
                if (suspended_count == TX_NO_SUSPENSIONS)
3419527c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
3419527e:	2b00      	cmp	r3, #0
34195280:	d109      	bne.n	34195296 <_tx_event_flags_get+0x136>
                {

                    /* No other threads are suspended.  Setup the head pointer and
                       just setup this threads pointers to itself.  */
                    group_ptr -> tx_event_flags_group_suspension_list =   thread_ptr;
34195282:	68fb      	ldr	r3, [r7, #12]
34195284:	6bba      	ldr	r2, [r7, #56]	@ 0x38
34195286:	611a      	str	r2, [r3, #16]
                    thread_ptr -> tx_thread_suspended_next =              thread_ptr;
34195288:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419528a:	6bba      	ldr	r2, [r7, #56]	@ 0x38
3419528c:	671a      	str	r2, [r3, #112]	@ 0x70
                    thread_ptr -> tx_thread_suspended_previous =          thread_ptr;
3419528e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34195290:	6bba      	ldr	r2, [r7, #56]	@ 0x38
34195292:	675a      	str	r2, [r3, #116]	@ 0x74
34195294:	e011      	b.n	341952ba <_tx_event_flags_get+0x15a>
                }
                else
                {

                    /* This list is not NULL, add current thread to the end. */
                    next_thread =                                   group_ptr -> tx_event_flags_group_suspension_list;
34195296:	68fb      	ldr	r3, [r7, #12]
34195298:	691b      	ldr	r3, [r3, #16]
3419529a:	633b      	str	r3, [r7, #48]	@ 0x30
                    thread_ptr -> tx_thread_suspended_next =        next_thread;
3419529c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419529e:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
341952a0:	671a      	str	r2, [r3, #112]	@ 0x70
                    previous_thread =                               next_thread -> tx_thread_suspended_previous;
341952a2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
341952a4:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
341952a6:	62fb      	str	r3, [r7, #44]	@ 0x2c
                    thread_ptr -> tx_thread_suspended_previous =    previous_thread;
341952a8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
341952aa:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
341952ac:	675a      	str	r2, [r3, #116]	@ 0x74
                    previous_thread -> tx_thread_suspended_next =   thread_ptr;
341952ae:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
341952b0:	6bba      	ldr	r2, [r7, #56]	@ 0x38
341952b2:	671a      	str	r2, [r3, #112]	@ 0x70
                    next_thread -> tx_thread_suspended_previous =   thread_ptr;
341952b4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
341952b6:	6bba      	ldr	r2, [r7, #56]	@ 0x38
341952b8:	675a      	str	r2, [r3, #116]	@ 0x74
                }

                /* Increment the number of threads suspended.  */
                group_ptr -> tx_event_flags_group_suspended_count++;
341952ba:	68fb      	ldr	r3, [r7, #12]
341952bc:	695b      	ldr	r3, [r3, #20]
341952be:	1c5a      	adds	r2, r3, #1
341952c0:	68fb      	ldr	r3, [r7, #12]
341952c2:	615a      	str	r2, [r3, #20]

                /* Set the state to suspended.  */
                thread_ptr -> tx_thread_state =    TX_EVENT_FLAG;
341952c4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
341952c6:	2207      	movs	r2, #7
341952c8:	631a      	str	r2, [r3, #48]	@ 0x30
                /* Return the completion status.  */
                status =  thread_ptr -> tx_thread_suspend_status;
#else

                /* Set the suspending flag.  */
                thread_ptr -> tx_thread_suspending =  TX_TRUE;
341952ca:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
341952cc:	2201      	movs	r2, #1
341952ce:	639a      	str	r2, [r3, #56]	@ 0x38

                /* Setup the timeout period.  */
                thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  wait_option;
341952d0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
341952d2:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
341952d4:	64da      	str	r2, [r3, #76]	@ 0x4c

                /* Temporarily disable preemption.  */
                _tx_thread_preempt_disable++;
341952d6:	4b14      	ldr	r3, [pc, #80]	@ (34195328 <_tx_event_flags_get+0x1c8>)
341952d8:	681b      	ldr	r3, [r3, #0]
341952da:	3301      	adds	r3, #1
341952dc:	4a12      	ldr	r2, [pc, #72]	@ (34195328 <_tx_event_flags_get+0x1c8>)
341952de:	6013      	str	r3, [r2, #0]
341952e0:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
341952e2:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
341952e4:	697b      	ldr	r3, [r7, #20]
341952e6:	f383 8810 	msr	PRIMASK, r3
}
341952ea:	bf00      	nop

                /* Restore interrupts.  */
                TX_RESTORE

                /* Call actual thread suspension routine.  */
                _tx_thread_system_suspend(thread_ptr);
341952ec:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
341952ee:	f002 fbc9 	bl	34197a84 <_tx_thread_system_suspend>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
341952f2:	f3ef 8310 	mrs	r3, PRIMASK
341952f6:	61fb      	str	r3, [r7, #28]
    return(posture);
341952f8:	69fb      	ldr	r3, [r7, #28]
    int_posture = __get_interrupt_posture();
341952fa:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("CPSID i" : : : "memory");
341952fc:	b672      	cpsid	i
    return(int_posture);
341952fe:	69bb      	ldr	r3, [r7, #24]

                /* Disable interrupts.  */
                TX_DISABLE
34195300:	657b      	str	r3, [r7, #84]	@ 0x54

                /* Return the completion status.  */
                status =  thread_ptr -> tx_thread_suspend_status;
34195302:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34195304:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
34195308:	653b      	str	r3, [r7, #80]	@ 0x50
3419530a:	e001      	b.n	34195310 <_tx_event_flags_get+0x1b0>
        }
        else
        {

            /* Immediate return, return error completion.  */
            status =  TX_NO_EVENTS;
3419530c:	2307      	movs	r3, #7
3419530e:	653b      	str	r3, [r7, #80]	@ 0x50
34195310:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34195312:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34195314:	693b      	ldr	r3, [r7, #16]
34195316:	f383 8810 	msr	PRIMASK, r3
}
3419531a:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return completion status.  */
    return(status);
3419531c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
}
3419531e:	4618      	mov	r0, r3
34195320:	3758      	adds	r7, #88	@ 0x58
34195322:	46bd      	mov	sp, r7
34195324:	bd80      	pop	{r7, pc}
34195326:	bf00      	nop
34195328:	341c2e84 	.word	0x341c2e84
3419532c:	341c2dec 	.word	0x341c2dec
34195330:	34194fb9 	.word	0x34194fb9

34195334 <_tx_event_flags_set>:
/*                                            check logic, resulting in   */
/*                                            version 6.1.11              */
/*                                                                        */
/**************************************************************************/
UINT  _tx_event_flags_set(TX_EVENT_FLAGS_GROUP *group_ptr, ULONG flags_to_set, UINT set_option)
{
34195334:	b580      	push	{r7, lr}
34195336:	b0a6      	sub	sp, #152	@ 0x98
34195338:	af00      	add	r7, sp, #0
3419533a:	60f8      	str	r0, [r7, #12]
3419533c:	60b9      	str	r1, [r7, #8]
3419533e:	607a      	str	r2, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34195340:	f3ef 8310 	mrs	r3, PRIMASK
34195344:	64fb      	str	r3, [r7, #76]	@ 0x4c
    return(posture);
34195346:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
    int_posture = __get_interrupt_posture();
34195348:	64bb      	str	r3, [r7, #72]	@ 0x48
    __asm__ volatile ("CPSID i" : : : "memory");
3419534a:	b672      	cpsid	i
    return(int_posture);
3419534c:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
VOID            (*events_set_notify)(struct TX_EVENT_FLAGS_GROUP_STRUCT *notify_group_ptr);
#endif


    /* Disable interrupts to remove the semaphore from the created list.  */
    TX_DISABLE
3419534e:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94

    /* Log this kernel call.  */
    TX_EL_EVENT_FLAGS_SET_INSERT

    /* Determine how to set this group's event flags.  */
    if ((set_option & TX_EVENT_FLAGS_AND_MASK) == TX_AND)
34195352:	687b      	ldr	r3, [r7, #4]
34195354:	f003 0302 	and.w	r3, r3, #2
34195358:	2b00      	cmp	r3, #0
3419535a:	d023      	beq.n	341953a4 <_tx_event_flags_set+0x70>
    {

#ifndef TX_NOT_INTERRUPTABLE

        /* Set interrupted set request flag to false.  */
        interrupted_set_request =  TX_FALSE;
3419535c:	2300      	movs	r3, #0
3419535e:	673b      	str	r3, [r7, #112]	@ 0x70

        /* Determine if the suspension list is being processed by an interrupted
           set request.  */
        if (group_ptr -> tx_event_flags_group_suspended_count != TX_NO_SUSPENSIONS)
34195360:	68fb      	ldr	r3, [r7, #12]
34195362:	695b      	ldr	r3, [r3, #20]
34195364:	2b00      	cmp	r3, #0
34195366:	d005      	beq.n	34195374 <_tx_event_flags_set+0x40>
        {

            if (group_ptr -> tx_event_flags_group_suspension_list == TX_NULL)
34195368:	68fb      	ldr	r3, [r7, #12]
3419536a:	691b      	ldr	r3, [r3, #16]
3419536c:	2b00      	cmp	r3, #0
3419536e:	d101      	bne.n	34195374 <_tx_event_flags_set+0x40>
            {

                /* Set the interrupted set request flag.  */
                interrupted_set_request =  TX_TRUE;
34195370:	2301      	movs	r3, #1
34195372:	673b      	str	r3, [r7, #112]	@ 0x70
            }
        }

        /* Was a set request interrupted?  */
        if (interrupted_set_request == TX_TRUE)
34195374:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
34195376:	2b01      	cmp	r3, #1
34195378:	d107      	bne.n	3419538a <_tx_event_flags_set+0x56>
            /* A previous set operation was interrupted, we need to defer the
               event clearing until the set operation is complete.  */

            /* Remember the events to clear.  */
            group_ptr -> tx_event_flags_group_delayed_clear =
                                        group_ptr -> tx_event_flags_group_delayed_clear | ~flags_to_set;
3419537a:	68fb      	ldr	r3, [r7, #12]
3419537c:	6a1a      	ldr	r2, [r3, #32]
3419537e:	68bb      	ldr	r3, [r7, #8]
34195380:	43db      	mvns	r3, r3
34195382:	431a      	orrs	r2, r3
            group_ptr -> tx_event_flags_group_delayed_clear =
34195384:	68fb      	ldr	r3, [r7, #12]
34195386:	621a      	str	r2, [r3, #32]
34195388:	e005      	b.n	34195396 <_tx_event_flags_set+0x62>

            /* Previous set operation was not interrupted, simply clear the
               specified flags by "ANDing" the flags into the current events
               of the group.  */
            group_ptr -> tx_event_flags_group_current =
                group_ptr -> tx_event_flags_group_current & flags_to_set;
3419538a:	68fb      	ldr	r3, [r7, #12]
3419538c:	689a      	ldr	r2, [r3, #8]
3419538e:	68bb      	ldr	r3, [r7, #8]
34195390:	401a      	ands	r2, r3
            group_ptr -> tx_event_flags_group_current =
34195392:	68fb      	ldr	r3, [r7, #12]
34195394:	609a      	str	r2, [r3, #8]
34195396:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
3419539a:	647b      	str	r3, [r7, #68]	@ 0x44
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
3419539c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3419539e:	f383 8810 	msr	PRIMASK, r3
}
341953a2:	e1d2      	b.n	3419574a <_tx_event_flags_set+0x416>
        events_set_notify =  group_ptr -> tx_event_flags_group_set_notify;
#endif

        /* "OR" the flags into the current events of the group.  */
        group_ptr -> tx_event_flags_group_current =
            group_ptr -> tx_event_flags_group_current | flags_to_set;
341953a4:	68fb      	ldr	r3, [r7, #12]
341953a6:	689a      	ldr	r2, [r3, #8]
341953a8:	68bb      	ldr	r3, [r7, #8]
341953aa:	431a      	orrs	r2, r3
        group_ptr -> tx_event_flags_group_current =
341953ac:	68fb      	ldr	r3, [r7, #12]
341953ae:	609a      	str	r2, [r3, #8]

#ifndef TX_NOT_INTERRUPTABLE

        /* Determine if there are any delayed flags to clear.  */
        if (group_ptr -> tx_event_flags_group_delayed_clear != ((ULONG) 0))
341953b0:	68fb      	ldr	r3, [r7, #12]
341953b2:	6a1b      	ldr	r3, [r3, #32]
341953b4:	2b00      	cmp	r3, #0
341953b6:	d006      	beq.n	341953c6 <_tx_event_flags_set+0x92>
        {

            /* Yes, we need to neutralize the delayed clearing as well.  */
            group_ptr -> tx_event_flags_group_delayed_clear =
                                        group_ptr -> tx_event_flags_group_delayed_clear & ~flags_to_set;
341953b8:	68fb      	ldr	r3, [r7, #12]
341953ba:	6a1a      	ldr	r2, [r3, #32]
341953bc:	68bb      	ldr	r3, [r7, #8]
341953be:	43db      	mvns	r3, r3
341953c0:	401a      	ands	r2, r3
            group_ptr -> tx_event_flags_group_delayed_clear =
341953c2:	68fb      	ldr	r3, [r7, #12]
341953c4:	621a      	str	r2, [r3, #32]
        }
#endif

        /* Clear the preempt check flag.  */
        preempt_check =  TX_FALSE;
341953c6:	2300      	movs	r3, #0
341953c8:	677b      	str	r3, [r7, #116]	@ 0x74

        /* Pickup the thread suspended count.  */
        suspended_count =  group_ptr -> tx_event_flags_group_suspended_count;
341953ca:	68fb      	ldr	r3, [r7, #12]
341953cc:	695b      	ldr	r3, [r3, #20]
341953ce:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80

        /* Determine if there are any threads suspended on the event flag group.  */
        if (group_ptr -> tx_event_flags_group_suspension_list != TX_NULL)
341953d2:	68fb      	ldr	r3, [r7, #12]
341953d4:	691b      	ldr	r3, [r3, #16]
341953d6:	2b00      	cmp	r3, #0
341953d8:	f000 81a4 	beq.w	34195724 <_tx_event_flags_set+0x3f0>
        {

            /* Determine if there is just a single thread waiting on the event
               flag group.  */
            if (suspended_count == ((UINT) 1))
341953dc:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
341953e0:	2b01      	cmp	r3, #1
341953e2:	d167      	bne.n	341954b4 <_tx_event_flags_set+0x180>

                /* Single thread waiting for event flags.  Bypass the multiple thread
                   logic.  */

                /* Setup thread pointer.  */
                thread_ptr =  group_ptr -> tx_event_flags_group_suspension_list;
341953e4:	68fb      	ldr	r3, [r7, #12]
341953e6:	691b      	ldr	r3, [r3, #16]
341953e8:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90

                /* Pickup the current event flags.  */
                current_event_flags =  group_ptr -> tx_event_flags_group_current;
341953ec:	68fb      	ldr	r3, [r7, #12]
341953ee:	689b      	ldr	r3, [r3, #8]
341953f0:	67fb      	str	r3, [r7, #124]	@ 0x7c

                /* Pickup the suspend information.  */
                requested_flags =  thread_ptr -> tx_thread_suspend_info;
341953f2:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
341953f6:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
341953f8:	66bb      	str	r3, [r7, #104]	@ 0x68

                /* Pickup the suspend option.  */
                get_option =  thread_ptr -> tx_thread_suspend_option;
341953fa:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
341953fe:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34195402:	667b      	str	r3, [r7, #100]	@ 0x64

                /* Isolate the AND selection.  */
                and_request =  (get_option & TX_AND);
34195404:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
34195406:	f003 0302 	and.w	r3, r3, #2
3419540a:	663b      	str	r3, [r7, #96]	@ 0x60

                /* Check for AND condition. All flags must be present to satisfy request.  */
                if (and_request == TX_AND)
3419540c:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3419540e:	2b02      	cmp	r3, #2
34195410:	d10a      	bne.n	34195428 <_tx_event_flags_set+0xf4>
                {

                    /* AND request is present.  */

                    /* Calculate the flags present.  */
                    flags_satisfied =  (current_event_flags & requested_flags);
34195412:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
34195414:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
34195416:	4013      	ands	r3, r2
34195418:	67bb      	str	r3, [r7, #120]	@ 0x78

                    /* Determine if they satisfy the AND request.  */
                    if (flags_satisfied != requested_flags)
3419541a:	6fba      	ldr	r2, [r7, #120]	@ 0x78
3419541c:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3419541e:	429a      	cmp	r2, r3
34195420:	d006      	beq.n	34195430 <_tx_event_flags_set+0xfc>
                    {

                        /* No, not all the requested flags are present. Clear the flags present variable.  */
                        flags_satisfied =  ((ULONG) 0);
34195422:	2300      	movs	r3, #0
34195424:	67bb      	str	r3, [r7, #120]	@ 0x78
34195426:	e003      	b.n	34195430 <_tx_event_flags_set+0xfc>
                }
                else
                {

                    /* OR request is present. Simply or the requested flags and the current flags.  */
                    flags_satisfied =  (current_event_flags & requested_flags);
34195428:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
3419542a:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3419542c:	4013      	ands	r3, r2
3419542e:	67bb      	str	r3, [r7, #120]	@ 0x78
                }

                /* Determine if the request is satisfied.  */
                if (flags_satisfied != ((ULONG) 0))
34195430:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
34195432:	2b00      	cmp	r3, #0
34195434:	f000 817d 	beq.w	34195732 <_tx_event_flags_set+0x3fe>

                    /* Yes, resume the thread and apply any event flag
                       clearing.  */

                    /* Return the actual event flags that satisfied the request.  */
                    suspend_info_ptr =   TX_VOID_TO_ULONG_POINTER_CONVERT(thread_ptr -> tx_thread_additional_suspend_info);
34195438:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
3419543c:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3419543e:	65fb      	str	r3, [r7, #92]	@ 0x5c
                    *suspend_info_ptr =  current_event_flags;
34195440:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
34195442:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
34195444:	601a      	str	r2, [r3, #0]

                    /* Pickup the clear bit.  */
                    clear_request =  (get_option & TX_EVENT_FLAGS_CLEAR_MASK);
34195446:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
34195448:	f003 0301 	and.w	r3, r3, #1
3419544c:	65bb      	str	r3, [r7, #88]	@ 0x58

                    /* Determine whether or not clearing needs to take place.  */
                    if (clear_request == TX_TRUE)
3419544e:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
34195450:	2b01      	cmp	r3, #1
34195452:	d106      	bne.n	34195462 <_tx_event_flags_set+0x12e>
                    {

                        /* Yes, clear the flags that satisfied this request.  */
                        group_ptr -> tx_event_flags_group_current =  group_ptr -> tx_event_flags_group_current & (~requested_flags);
34195454:	68fb      	ldr	r3, [r7, #12]
34195456:	689a      	ldr	r2, [r3, #8]
34195458:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3419545a:	43db      	mvns	r3, r3
3419545c:	401a      	ands	r2, r3
3419545e:	68fb      	ldr	r3, [r7, #12]
34195460:	609a      	str	r2, [r3, #8]
                    }

                    /* Clear the suspension information in the event flag group.  */
                    group_ptr -> tx_event_flags_group_suspension_list =  TX_NULL;
34195462:	68fb      	ldr	r3, [r7, #12]
34195464:	2200      	movs	r2, #0
34195466:	611a      	str	r2, [r3, #16]
                    group_ptr -> tx_event_flags_group_suspended_count =  TX_NO_SUSPENSIONS;
34195468:	68fb      	ldr	r3, [r7, #12]
3419546a:	2200      	movs	r2, #0
3419546c:	615a      	str	r2, [r3, #20]

                    /* Clear cleanup routine to avoid timeout.  */
                    thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
3419546e:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
34195472:	2200      	movs	r2, #0
34195474:	669a      	str	r2, [r3, #104]	@ 0x68

                    /* Put return status into the thread control block.  */
                    thread_ptr -> tx_thread_suspend_status =  TX_SUCCESS;
34195476:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
3419547a:	2200      	movs	r2, #0
3419547c:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
                    /* Resume the thread!  */
                    _tx_thread_system_ni_resume(thread_ptr);
#else

                    /* Temporarily disable preemption.  */
                    _tx_thread_preempt_disable++;
34195480:	4ba7      	ldr	r3, [pc, #668]	@ (34195720 <_tx_event_flags_set+0x3ec>)
34195482:	681b      	ldr	r3, [r3, #0]
34195484:	3301      	adds	r3, #1
34195486:	4aa6      	ldr	r2, [pc, #664]	@ (34195720 <_tx_event_flags_set+0x3ec>)
34195488:	6013      	str	r3, [r2, #0]
3419548a:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
3419548e:	63bb      	str	r3, [r7, #56]	@ 0x38
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34195490:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34195492:	f383 8810 	msr	PRIMASK, r3
}
34195496:	bf00      	nop

                    /* Restore interrupts.  */
                    TX_RESTORE

                    /* Resume thread.  */
                    _tx_thread_system_resume(thread_ptr);
34195498:	f8d7 0090 	ldr.w	r0, [r7, #144]	@ 0x90
3419549c:	f002 f9f2 	bl	34197884 <_tx_thread_system_resume>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
341954a0:	f3ef 8310 	mrs	r3, PRIMASK
341954a4:	643b      	str	r3, [r7, #64]	@ 0x40
    return(posture);
341954a6:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
    int_posture = __get_interrupt_posture();
341954a8:	63fb      	str	r3, [r7, #60]	@ 0x3c
    __asm__ volatile ("CPSID i" : : : "memory");
341954aa:	b672      	cpsid	i
    return(int_posture);
341954ac:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c

                    /* Disable interrupts to remove the semaphore from the created list.  */
                    TX_DISABLE
341954ae:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
341954b2:	e13e      	b.n	34195732 <_tx_event_flags_set+0x3fe>

                /* Otherwise, the event flag requests of multiple threads must be
                   examined.  */

                /* Setup thread pointer, keep a local copy of the head pointer.  */
                suspended_list =  group_ptr -> tx_event_flags_group_suspension_list;
341954b4:	68fb      	ldr	r3, [r7, #12]
341954b6:	691b      	ldr	r3, [r3, #16]
341954b8:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
                thread_ptr =      suspended_list;
341954bc:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
341954c0:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90

                /* Clear the suspended list head pointer to thwart manipulation of
                   the list in ISR's while we are processing here.  */
                group_ptr -> tx_event_flags_group_suspension_list =  TX_NULL;
341954c4:	68fb      	ldr	r3, [r7, #12]
341954c6:	2200      	movs	r2, #0
341954c8:	611a      	str	r2, [r3, #16]

                /* Setup the satisfied thread pointers.  */
                satisfied_list =  TX_NULL;
341954ca:	2300      	movs	r3, #0
341954cc:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
                last_satisfied =  TX_NULL;
341954d0:	2300      	movs	r3, #0
341954d2:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88

                /* Pickup the current event flags.  */
                current_event_flags =  group_ptr -> tx_event_flags_group_current;
341954d6:	68fb      	ldr	r3, [r7, #12]
341954d8:	689b      	ldr	r3, [r3, #8]
341954da:	67fb      	str	r3, [r7, #124]	@ 0x7c

                /* Disable preemption while we process the suspended list.  */
                _tx_thread_preempt_disable++;
341954dc:	4b90      	ldr	r3, [pc, #576]	@ (34195720 <_tx_event_flags_set+0x3ec>)
341954de:	681b      	ldr	r3, [r3, #0]
341954e0:	3301      	adds	r3, #1
341954e2:	4a8f      	ldr	r2, [pc, #572]	@ (34195720 <_tx_event_flags_set+0x3ec>)
341954e4:	6013      	str	r3, [r2, #0]

                /* Since we have temporarily disabled preemption globally, set the preempt 
                   check flag to check for any preemption condition - including from 
                   unrelated ISR processing.  */
                preempt_check =  TX_TRUE;
341954e6:	2301      	movs	r3, #1
341954e8:	677b      	str	r3, [r7, #116]	@ 0x74
341954ea:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
341954ee:	62fb      	str	r3, [r7, #44]	@ 0x2c
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
341954f0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
341954f2:	f383 8810 	msr	PRIMASK, r3
}
341954f6:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
341954f8:	f3ef 8310 	mrs	r3, PRIMASK
341954fc:	637b      	str	r3, [r7, #52]	@ 0x34
    return(posture);
341954fe:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
    int_posture = __get_interrupt_posture();
34195500:	633b      	str	r3, [r7, #48]	@ 0x30
    __asm__ volatile ("CPSID i" : : : "memory");
34195502:	b672      	cpsid	i
    return(int_posture);
34195504:	6b3b      	ldr	r3, [r7, #48]	@ 0x30

                    /* Restore interrupts temporarily.  */
                    TX_RESTORE

                    /* Disable interrupts again.  */
                    TX_DISABLE
34195506:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
#endif

                    /* Determine if we need to reset the search.  */
                    if (group_ptr -> tx_event_flags_group_reset_search != TX_FALSE)
3419550a:	68fb      	ldr	r3, [r7, #12]
3419550c:	68db      	ldr	r3, [r3, #12]
3419550e:	2b00      	cmp	r3, #0
34195510:	d00f      	beq.n	34195532 <_tx_event_flags_set+0x1fe>
                    {

                        /* Clear the reset search flag.  */
                        group_ptr -> tx_event_flags_group_reset_search =  TX_FALSE;
34195512:	68fb      	ldr	r3, [r7, #12]
34195514:	2200      	movs	r2, #0
34195516:	60da      	str	r2, [r3, #12]

                        /* Move the thread pointer to the beginning of the search list.  */
                        thread_ptr =  suspended_list;
34195518:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
3419551c:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90

                        /* Reset the suspended count.  */
                        suspended_count =  group_ptr -> tx_event_flags_group_suspended_count;
34195520:	68fb      	ldr	r3, [r7, #12]
34195522:	695b      	ldr	r3, [r3, #20]
34195524:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80

                        /* Update the current events with any new ones that might
                           have been set in a nested set events call from an ISR.  */
                        current_event_flags =  current_event_flags | group_ptr -> tx_event_flags_group_current;
34195528:	68fb      	ldr	r3, [r7, #12]
3419552a:	689b      	ldr	r3, [r3, #8]
3419552c:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
3419552e:	4313      	orrs	r3, r2
34195530:	67fb      	str	r3, [r7, #124]	@ 0x7c
                    }

                    /* Save next thread pointer.  */
                    next_thread_ptr =  thread_ptr -> tx_thread_suspended_next;
34195532:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
34195536:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34195538:	66fb      	str	r3, [r7, #108]	@ 0x6c

                    /* Pickup the suspend information.  */
                    requested_flags =  thread_ptr -> tx_thread_suspend_info;
3419553a:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
3419553e:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
34195540:	66bb      	str	r3, [r7, #104]	@ 0x68

                    /* Pickup this thread's suspension get option.  */
                    get_option =  thread_ptr -> tx_thread_suspend_option;
34195542:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
34195546:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3419554a:	667b      	str	r3, [r7, #100]	@ 0x64

                    /* Isolate the AND selection.  */
                    and_request =  (get_option & TX_AND);
3419554c:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3419554e:	f003 0302 	and.w	r3, r3, #2
34195552:	663b      	str	r3, [r7, #96]	@ 0x60

                    /* Check for AND condition. All flags must be present to satisfy request.  */
                    if (and_request == TX_AND)
34195554:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
34195556:	2b02      	cmp	r3, #2
34195558:	d10a      	bne.n	34195570 <_tx_event_flags_set+0x23c>
                    {

                        /* AND request is present.  */

                        /* Calculate the flags present.  */
                        flags_satisfied =  (current_event_flags & requested_flags);
3419555a:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
3419555c:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3419555e:	4013      	ands	r3, r2
34195560:	67bb      	str	r3, [r7, #120]	@ 0x78

                        /* Determine if they satisfy the AND request.  */
                        if (flags_satisfied != requested_flags)
34195562:	6fba      	ldr	r2, [r7, #120]	@ 0x78
34195564:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
34195566:	429a      	cmp	r2, r3
34195568:	d006      	beq.n	34195578 <_tx_event_flags_set+0x244>
                        {

                            /* No, not all the requested flags are present. Clear the flags present variable.  */
                            flags_satisfied =  ((ULONG) 0);
3419556a:	2300      	movs	r3, #0
3419556c:	67bb      	str	r3, [r7, #120]	@ 0x78
3419556e:	e003      	b.n	34195578 <_tx_event_flags_set+0x244>
                    }
                    else
                    {

                        /* OR request is present. Simply or the requested flags and the current flags.  */
                        flags_satisfied =  (current_event_flags & requested_flags);
34195570:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
34195572:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
34195574:	4013      	ands	r3, r2
34195576:	67bb      	str	r3, [r7, #120]	@ 0x78
                    }

                    /* Check to see if the thread had a timeout or wait abort during the event search processing.
                       If so, just set the flags satisfied to ensure the processing here removes the thread from
                       the suspension list.  */
                    if (thread_ptr -> tx_thread_state != TX_EVENT_FLAG)
34195578:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
3419557c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3419557e:	2b07      	cmp	r3, #7
34195580:	d001      	beq.n	34195586 <_tx_event_flags_set+0x252>
                    {

                       /* Simply set the satisfied flags to 1 in order to remove the thread from the suspension list.  */
                        flags_satisfied =  ((ULONG) 1);
34195582:	2301      	movs	r3, #1
34195584:	67bb      	str	r3, [r7, #120]	@ 0x78
                    }

                    /* Determine if the request is satisfied.  */
                    if (flags_satisfied != ((ULONG) 0))
34195586:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
34195588:	2b00      	cmp	r3, #0
3419558a:	d069      	beq.n	34195660 <_tx_event_flags_set+0x32c>

                        /* Yes, this request can be handled now.  */

                        /* Determine if the thread is still suspended on the event flag group. If not, a wait
                           abort must have been done from an ISR.  */
                        if (thread_ptr -> tx_thread_state == TX_EVENT_FLAG)
3419558c:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
34195590:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34195592:	2b07      	cmp	r3, #7
34195594:	d11d      	bne.n	341955d2 <_tx_event_flags_set+0x29e>
                        {

                            /* Return the actual event flags that satisfied the request.  */
                            suspend_info_ptr =   TX_VOID_TO_ULONG_POINTER_CONVERT(thread_ptr -> tx_thread_additional_suspend_info);
34195596:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
3419559a:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3419559c:	65fb      	str	r3, [r7, #92]	@ 0x5c
                            *suspend_info_ptr =  current_event_flags;
3419559e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
341955a0:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
341955a2:	601a      	str	r2, [r3, #0]

                            /* Pickup the clear bit.  */
                            clear_request =  (get_option & TX_EVENT_FLAGS_CLEAR_MASK);
341955a4:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
341955a6:	f003 0301 	and.w	r3, r3, #1
341955aa:	65bb      	str	r3, [r7, #88]	@ 0x58

                            /* Determine whether or not clearing needs to take place.  */
                            if (clear_request == TX_TRUE)
341955ac:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
341955ae:	2b01      	cmp	r3, #1
341955b0:	d106      	bne.n	341955c0 <_tx_event_flags_set+0x28c>
                            {

                                /* Yes, clear the flags that satisfied this request.  */
                                group_ptr -> tx_event_flags_group_current =  group_ptr -> tx_event_flags_group_current & ~requested_flags;
341955b2:	68fb      	ldr	r3, [r7, #12]
341955b4:	689a      	ldr	r2, [r3, #8]
341955b6:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
341955b8:	43db      	mvns	r3, r3
341955ba:	401a      	ands	r2, r3
341955bc:	68fb      	ldr	r3, [r7, #12]
341955be:	609a      	str	r2, [r3, #8]
                            }

                            /* Prepare for resumption of the first thread.  */

                            /* Clear cleanup routine to avoid timeout.  */
                            thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
341955c0:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
341955c4:	2200      	movs	r2, #0
341955c6:	669a      	str	r2, [r3, #104]	@ 0x68

                            /* Put return status into the thread control block.  */
                            thread_ptr -> tx_thread_suspend_status =  TX_SUCCESS;
341955c8:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
341955cc:	2200      	movs	r2, #0
341955ce:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84

                        /* We need to remove the thread from the suspension list and place it in the
                           expired list.  */

                        /* See if this is the only suspended thread on the list.  */
                        if (thread_ptr == thread_ptr -> tx_thread_suspended_next)
341955d2:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
341955d6:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
341955d8:	f8d7 2090 	ldr.w	r2, [r7, #144]	@ 0x90
341955dc:	429a      	cmp	r2, r3
341955de:	d103      	bne.n	341955e8 <_tx_event_flags_set+0x2b4>
                        {

                            /* Yes, the only suspended thread.  */

                            /* Update the head pointer.  */
                            suspended_list =  TX_NULL;
341955e0:	2300      	movs	r3, #0
341955e2:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
341955e6:	e018      	b.n	3419561a <_tx_event_flags_set+0x2e6>
                        {

                            /* At least one more thread is on the same expiration list.  */

                            /* Update the links of the adjacent threads.  */
                            next_thread =                                  thread_ptr -> tx_thread_suspended_next;
341955e8:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
341955ec:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
341955ee:	657b      	str	r3, [r7, #84]	@ 0x54
                            previous_thread =                              thread_ptr -> tx_thread_suspended_previous;
341955f0:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
341955f4:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
341955f6:	653b      	str	r3, [r7, #80]	@ 0x50
                            next_thread -> tx_thread_suspended_previous =  previous_thread;
341955f8:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
341955fa:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
341955fc:	675a      	str	r2, [r3, #116]	@ 0x74
                            previous_thread -> tx_thread_suspended_next =  next_thread;
341955fe:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
34195600:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
34195602:	671a      	str	r2, [r3, #112]	@ 0x70

                            /* Update the list head pointer, if removing the head of the
                               list.  */
                            if (suspended_list == thread_ptr)
34195604:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
34195608:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
3419560c:	429a      	cmp	r2, r3
3419560e:	d104      	bne.n	3419561a <_tx_event_flags_set+0x2e6>
                            {

                                /* Yes, head pointer needs to be updated.  */
                                suspended_list =  thread_ptr -> tx_thread_suspended_next;
34195610:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
34195614:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34195616:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
                            }
                        }

                        /* Decrement the suspension count.  */
                        group_ptr -> tx_event_flags_group_suspended_count--;
3419561a:	68fb      	ldr	r3, [r7, #12]
3419561c:	695b      	ldr	r3, [r3, #20]
3419561e:	1e5a      	subs	r2, r3, #1
34195620:	68fb      	ldr	r3, [r7, #12]
34195622:	615a      	str	r2, [r3, #20]

                        /* Place this thread on the expired list.  */
                        if (satisfied_list == TX_NULL)
34195624:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
34195628:	2b00      	cmp	r3, #0
3419562a:	d10c      	bne.n	34195646 <_tx_event_flags_set+0x312>
                        {

                            /* First thread on the satisfied list.  */
                            satisfied_list =  thread_ptr;
3419562c:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
34195630:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
                            last_satisfied =  thread_ptr;
34195634:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
34195638:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88

                            /* Setup initial next pointer.  */
                            thread_ptr -> tx_thread_suspended_next =  TX_NULL;
3419563c:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
34195640:	2200      	movs	r2, #0
34195642:	671a      	str	r2, [r3, #112]	@ 0x70
34195644:	e00c      	b.n	34195660 <_tx_event_flags_set+0x32c>
                        {

                            /* Not the first thread on the satisfied list.  */

                            /* Link it up at the end.  */
                            last_satisfied -> tx_thread_suspended_next =  thread_ptr;
34195646:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
3419564a:	f8d7 2090 	ldr.w	r2, [r7, #144]	@ 0x90
3419564e:	671a      	str	r2, [r3, #112]	@ 0x70
                            thread_ptr -> tx_thread_suspended_next =      TX_NULL;
34195650:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
34195654:	2200      	movs	r2, #0
34195656:	671a      	str	r2, [r3, #112]	@ 0x70
                            last_satisfied =                              thread_ptr;
34195658:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
3419565c:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
                        }
                    }

                    /* Copy next thread pointer to working thread ptr.  */
                    thread_ptr =  next_thread_ptr;
34195660:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
34195662:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90

                    /* Decrement the suspension count.  */
                    suspended_count--;
34195666:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3419566a:	3b01      	subs	r3, #1
3419566c:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80

                } while (suspended_count != TX_NO_SUSPENSIONS);
34195670:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
34195674:	2b00      	cmp	r3, #0
34195676:	f47f af38 	bne.w	341954ea <_tx_event_flags_set+0x1b6>

                /* Setup the group's suspension list head again.  */
                group_ptr -> tx_event_flags_group_suspension_list =  suspended_list;
3419567a:	68fb      	ldr	r3, [r7, #12]
3419567c:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
34195680:	611a      	str	r2, [r3, #16]

#ifndef TX_NOT_INTERRUPTABLE

                /* Determine if there is any delayed event clearing to perform.  */
                if (group_ptr -> tx_event_flags_group_delayed_clear != ((ULONG) 0))
34195682:	68fb      	ldr	r3, [r7, #12]
34195684:	6a1b      	ldr	r3, [r3, #32]
34195686:	2b00      	cmp	r3, #0
34195688:	d00a      	beq.n	341956a0 <_tx_event_flags_set+0x36c>
                {

                    /* Perform the delayed event clearing.  */
                    group_ptr -> tx_event_flags_group_current =
                        group_ptr -> tx_event_flags_group_current & ~(group_ptr -> tx_event_flags_group_delayed_clear);
3419568a:	68fb      	ldr	r3, [r7, #12]
3419568c:	689a      	ldr	r2, [r3, #8]
3419568e:	68fb      	ldr	r3, [r7, #12]
34195690:	6a1b      	ldr	r3, [r3, #32]
34195692:	43db      	mvns	r3, r3
34195694:	401a      	ands	r2, r3
                    group_ptr -> tx_event_flags_group_current =
34195696:	68fb      	ldr	r3, [r7, #12]
34195698:	609a      	str	r2, [r3, #8]

                    /* Clear the delayed event flag clear value.  */
                    group_ptr -> tx_event_flags_group_delayed_clear =  ((ULONG) 0);
3419569a:	68fb      	ldr	r3, [r7, #12]
3419569c:	2200      	movs	r2, #0
3419569e:	621a      	str	r2, [r3, #32]
341956a0:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
341956a4:	62bb      	str	r3, [r7, #40]	@ 0x28
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
341956a6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
341956a8:	f383 8810 	msr	PRIMASK, r3
}
341956ac:	bf00      	nop

                /* Restore interrupts.  */
                TX_RESTORE

                /* Walk through the satisfied list, setup initial thread pointer. */
                thread_ptr =  satisfied_list;
341956ae:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
341956b2:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
                while(thread_ptr != TX_NULL)
341956b6:	e01f      	b.n	341956f8 <_tx_event_flags_set+0x3c4>
                {

                    /* Get next pointer first.  */
                    next_thread_ptr =  thread_ptr -> tx_thread_suspended_next;
341956b8:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
341956bc:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
341956be:	66fb      	str	r3, [r7, #108]	@ 0x6c
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
341956c0:	f3ef 8310 	mrs	r3, PRIMASK
341956c4:	623b      	str	r3, [r7, #32]
    return(posture);
341956c6:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
341956c8:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
341956ca:	b672      	cpsid	i
    return(int_posture);
341956cc:	69fb      	ldr	r3, [r7, #28]

                    /* Disable interrupts.  */
                    TX_DISABLE
341956ce:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
                    /* Restore interrupts.  */
                    TX_RESTORE
#else

                    /* Disable preemption again.  */
                    _tx_thread_preempt_disable++;
341956d2:	4b13      	ldr	r3, [pc, #76]	@ (34195720 <_tx_event_flags_set+0x3ec>)
341956d4:	681b      	ldr	r3, [r3, #0]
341956d6:	3301      	adds	r3, #1
341956d8:	4a11      	ldr	r2, [pc, #68]	@ (34195720 <_tx_event_flags_set+0x3ec>)
341956da:	6013      	str	r3, [r2, #0]
341956dc:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
341956e0:	627b      	str	r3, [r7, #36]	@ 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
341956e2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
341956e4:	f383 8810 	msr	PRIMASK, r3
}
341956e8:	bf00      	nop

                    /* Restore interrupt posture.  */
                    TX_RESTORE

                    /* Resume the thread.  */
                    _tx_thread_system_resume(thread_ptr);
341956ea:	f8d7 0090 	ldr.w	r0, [r7, #144]	@ 0x90
341956ee:	f002 f8c9 	bl	34197884 <_tx_thread_system_resume>
#endif

                    /* Move next thread to current.  */
                    thread_ptr =  next_thread_ptr;
341956f2:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
341956f4:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
                while(thread_ptr != TX_NULL)
341956f8:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
341956fc:	2b00      	cmp	r3, #0
341956fe:	d1db      	bne.n	341956b8 <_tx_event_flags_set+0x384>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34195700:	f3ef 8310 	mrs	r3, PRIMASK
34195704:	61bb      	str	r3, [r7, #24]
    return(posture);
34195706:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
34195708:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
3419570a:	b672      	cpsid	i
    return(int_posture);
3419570c:	697b      	ldr	r3, [r7, #20]
                }

                /* Disable interrupts.  */
                TX_DISABLE
3419570e:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94

                /* Release thread preemption disable.  */
                _tx_thread_preempt_disable--;
34195712:	4b03      	ldr	r3, [pc, #12]	@ (34195720 <_tx_event_flags_set+0x3ec>)
34195714:	681b      	ldr	r3, [r3, #0]
34195716:	3b01      	subs	r3, #1
34195718:	4a01      	ldr	r2, [pc, #4]	@ (34195720 <_tx_event_flags_set+0x3ec>)
3419571a:	6013      	str	r3, [r2, #0]
3419571c:	e009      	b.n	34195732 <_tx_event_flags_set+0x3fe>
3419571e:	bf00      	nop
34195720:	341c2e84 	.word	0x341c2e84
        }
        else
        {

            /* Determine if we need to set the reset search field.  */
            if (group_ptr -> tx_event_flags_group_suspended_count != TX_NO_SUSPENSIONS)
34195724:	68fb      	ldr	r3, [r7, #12]
34195726:	695b      	ldr	r3, [r3, #20]
34195728:	2b00      	cmp	r3, #0
3419572a:	d002      	beq.n	34195732 <_tx_event_flags_set+0x3fe>
            {

                /* We interrupted a search of an event flag group suspension
                   list.  Make sure we reset the search.  */
                group_ptr -> tx_event_flags_group_reset_search =  TX_TRUE;
3419572c:	68fb      	ldr	r3, [r7, #12]
3419572e:	2201      	movs	r2, #1
34195730:	60da      	str	r2, [r3, #12]
34195732:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
34195736:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34195738:	693b      	ldr	r3, [r7, #16]
3419573a:	f383 8810 	msr	PRIMASK, r3
}
3419573e:	bf00      	nop
            (events_set_notify)(group_ptr);
        }
#endif

        /* Determine if a check for preemption is necessary.  */
        if (preempt_check == TX_TRUE)
34195740:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
34195742:	2b01      	cmp	r3, #1
34195744:	d101      	bne.n	3419574a <_tx_event_flags_set+0x416>
        {

            /* Yes, one or more threads were resumed, check for preemption.  */
            _tx_thread_system_preempt_check();
34195746:	f002 f863 	bl	34197810 <_tx_thread_system_preempt_check>
        }
    }

    /* Return completion status.  */
    return(TX_SUCCESS);
3419574a:	2300      	movs	r3, #0
}
3419574c:	4618      	mov	r0, r3
3419574e:	3798      	adds	r7, #152	@ 0x98
34195750:	46bd      	mov	sp, r7
34195752:	bd80      	pop	{r7, pc}

34195754 <_tx_initialize_high_level>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID    _tx_initialize_high_level(VOID)
{
34195754:	b580      	push	{r7, lr}
34195756:	af00      	add	r7, sp, #0

    /* Initialize the event log, if enabled.  */
    TX_EL_INITIALIZE

    /* Call the thread control initialization function.  */
    _tx_thread_initialize();
34195758:	f001 fe1c 	bl	34197394 <_tx_thread_initialize>

#ifndef TX_NO_TIMER

    /* Call the timer control initialization function.  */
    _tx_timer_initialize();
3419575c:	f002 fcf8 	bl	34198150 <_tx_timer_initialize>
#endif

#ifndef TX_DISABLE_REDUNDANT_CLEARING

    /* Call the semaphore initialization function.  */
    _tx_semaphore_initialize();
34195760:	4b12      	ldr	r3, [pc, #72]	@ (341957ac <_tx_initialize_high_level+0x58>)
34195762:	2200      	movs	r2, #0
34195764:	601a      	str	r2, [r3, #0]
34195766:	4b12      	ldr	r3, [pc, #72]	@ (341957b0 <_tx_initialize_high_level+0x5c>)
34195768:	2200      	movs	r2, #0
3419576a:	601a      	str	r2, [r3, #0]

    /* Call the queue initialization function.  */
    _tx_queue_initialize();
3419576c:	4b11      	ldr	r3, [pc, #68]	@ (341957b4 <_tx_initialize_high_level+0x60>)
3419576e:	2200      	movs	r2, #0
34195770:	601a      	str	r2, [r3, #0]
34195772:	4b11      	ldr	r3, [pc, #68]	@ (341957b8 <_tx_initialize_high_level+0x64>)
34195774:	2200      	movs	r2, #0
34195776:	601a      	str	r2, [r3, #0]

    /* Call the event flag initialization function.  */
    _tx_event_flags_initialize();
34195778:	4b10      	ldr	r3, [pc, #64]	@ (341957bc <_tx_initialize_high_level+0x68>)
3419577a:	2200      	movs	r2, #0
3419577c:	601a      	str	r2, [r3, #0]
3419577e:	4b10      	ldr	r3, [pc, #64]	@ (341957c0 <_tx_initialize_high_level+0x6c>)
34195780:	2200      	movs	r2, #0
34195782:	601a      	str	r2, [r3, #0]

    /* Call the block pool initialization function.  */
    _tx_block_pool_initialize();
34195784:	4b0f      	ldr	r3, [pc, #60]	@ (341957c4 <_tx_initialize_high_level+0x70>)
34195786:	2200      	movs	r2, #0
34195788:	601a      	str	r2, [r3, #0]
3419578a:	4b0f      	ldr	r3, [pc, #60]	@ (341957c8 <_tx_initialize_high_level+0x74>)
3419578c:	2200      	movs	r2, #0
3419578e:	601a      	str	r2, [r3, #0]

    /* Call the byte pool initialization function.  */
    _tx_byte_pool_initialize();
34195790:	4b0e      	ldr	r3, [pc, #56]	@ (341957cc <_tx_initialize_high_level+0x78>)
34195792:	2200      	movs	r2, #0
34195794:	601a      	str	r2, [r3, #0]
34195796:	4b0e      	ldr	r3, [pc, #56]	@ (341957d0 <_tx_initialize_high_level+0x7c>)
34195798:	2200      	movs	r2, #0
3419579a:	601a      	str	r2, [r3, #0]

    /* Call the mutex initialization function.  */
    _tx_mutex_initialize();
3419579c:	4b0d      	ldr	r3, [pc, #52]	@ (341957d4 <_tx_initialize_high_level+0x80>)
3419579e:	2200      	movs	r2, #0
341957a0:	601a      	str	r2, [r3, #0]
341957a2:	4b0d      	ldr	r3, [pc, #52]	@ (341957d8 <_tx_initialize_high_level+0x84>)
341957a4:	2200      	movs	r2, #0
341957a6:	601a      	str	r2, [r3, #0]
#endif
}
341957a8:	bf00      	nop
341957aa:	bd80      	pop	{r7, pc}
341957ac:	341c2db4 	.word	0x341c2db4
341957b0:	341c2db8 	.word	0x341c2db8
341957b4:	341c2dbc 	.word	0x341c2dbc
341957b8:	341c2dc0 	.word	0x341c2dc0
341957bc:	341c2dc4 	.word	0x341c2dc4
341957c0:	341c2dc8 	.word	0x341c2dc8
341957c4:	341c2dd4 	.word	0x341c2dd4
341957c8:	341c2dd8 	.word	0x341c2dd8
341957cc:	341c2ddc 	.word	0x341c2ddc
341957d0:	341c2de0 	.word	0x341c2de0
341957d4:	341c2dcc 	.word	0x341c2dcc
341957d8:	341c2dd0 	.word	0x341c2dd0

341957dc <_tx_initialize_kernel_enter>:
/*                                            initialization,             */
/*                                            resulting in version 6.3.0  */
/*                                                                        */
/**************************************************************************/
VOID  _tx_initialize_kernel_enter(VOID)
{
341957dc:	b580      	push	{r7, lr}
341957de:	af00      	add	r7, sp, #0

    /* Determine if the compiler has pre-initialized ThreadX.  */
    if (_tx_thread_system_state != TX_INITIALIZE_ALMOST_DONE)
341957e0:	4b10      	ldr	r3, [pc, #64]	@ (34195824 <_tx_initialize_kernel_enter+0x48>)
341957e2:	681b      	ldr	r3, [r3, #0]
341957e4:	f113 3f0f 	cmn.w	r3, #252645135	@ 0xf0f0f0f
341957e8:	d00c      	beq.n	34195804 <_tx_initialize_kernel_enter+0x28>
        /* No, the initialization still needs to take place.  */

        /* Ensure that the system state variable is set to indicate
           initialization is in progress.  Note that this variable is
           later used to represent interrupt nesting.  */
        _tx_thread_system_state =  TX_INITIALIZE_IN_PROGRESS;
341957ea:	4b0e      	ldr	r3, [pc, #56]	@ (34195824 <_tx_initialize_kernel_enter+0x48>)
341957ec:	f04f 32f0 	mov.w	r2, #4042322160	@ 0xf0f0f0f0
341957f0:	601a      	str	r2, [r3, #0]
        /* Call any port specific preprocessing.  */
        TX_PORT_SPECIFIC_PRE_INITIALIZATION

        /* Invoke the low-level initialization to handle all processor specific
           initialization issues.  */
        _tx_initialize_low_level();
341957f2:	f7ea ffcb 	bl	3418078c <_tx_initialize_low_level>

        /* Invoke the high-level initialization to exercise all of the
           ThreadX components and the application's initialization
           function.  */
        _tx_initialize_high_level();
341957f6:	f7ff ffad 	bl	34195754 <_tx_initialize_high_level>

        /* Call any port specific post-processing.  */
        TX_PORT_SPECIFIC_POST_INITIALIZATION
341957fa:	4b0b      	ldr	r3, [pc, #44]	@ (34195828 <_tx_initialize_kernel_enter+0x4c>)
341957fc:	681b      	ldr	r3, [r3, #0]
341957fe:	3301      	adds	r3, #1
34195800:	4a09      	ldr	r2, [pc, #36]	@ (34195828 <_tx_initialize_kernel_enter+0x4c>)
34195802:	6013      	str	r3, [r2, #0]
    TX_INITIALIZE_KERNEL_ENTER_EXTENSION

    /* Ensure that the system state variable is set to indicate
       initialization is in progress.  Note that this variable is
       later used to represent interrupt nesting.  */
    _tx_thread_system_state =  TX_INITIALIZE_IN_PROGRESS;
34195804:	4b07      	ldr	r3, [pc, #28]	@ (34195824 <_tx_initialize_kernel_enter+0x48>)
34195806:	f04f 32f0 	mov.w	r2, #4042322160	@ 0xf0f0f0f0
3419580a:	601a      	str	r2, [r3, #0]
    /* Optional random number generator initialization.  */
    TX_INITIALIZE_RANDOM_GENERATOR_INITIALIZATION

    /* Call the application provided initialization function.  Pass the
       first available memory address to it.  */
    tx_application_define(_tx_initialize_unused_memory);
3419580c:	4b07      	ldr	r3, [pc, #28]	@ (3419582c <_tx_initialize_kernel_enter+0x50>)
3419580e:	681b      	ldr	r3, [r3, #0]
34195810:	4618      	mov	r0, r3
34195812:	f7eb f9ed 	bl	34180bf0 <tx_application_define>

    /* Set the system state in preparation for entering the thread
       scheduler.  */
    _tx_thread_system_state =  TX_INITIALIZE_IS_FINISHED;
34195816:	4b03      	ldr	r3, [pc, #12]	@ (34195824 <_tx_initialize_kernel_enter+0x48>)
34195818:	2200      	movs	r2, #0
3419581a:	601a      	str	r2, [r3, #0]
    /* Initialize Execution Profile Kit.  */
    _tx_execution_initialize();
#endif

    /* Enter the scheduling loop to start executing threads!  */
    _tx_thread_schedule();
3419581c:	f7ea fff2 	bl	34180804 <_tx_thread_schedule>
#ifdef TX_SAFETY_CRITICAL

    /* If we ever get here, raise safety critical exception.  */
    TX_SAFETY_CRITICAL_EXCEPTION(__FILE__, __LINE__, 0);
#endif
}
34195820:	bf00      	nop
34195822:	bd80      	pop	{r7, pc}
34195824:	341c009c 	.word	0x341c009c
34195828:	341c2e84 	.word	0x341c2e84
3419582c:	341c2de4 	.word	0x341c2de4

34195830 <_tx_mutex_cleanup>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_mutex_cleanup(TX_THREAD  *thread_ptr, ULONG suspension_sequence)
{
34195830:	b580      	push	{r7, lr}
34195832:	b08e      	sub	sp, #56	@ 0x38
34195834:	af00      	add	r7, sp, #0
34195836:	6078      	str	r0, [r7, #4]
34195838:	6039      	str	r1, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
3419583a:	f3ef 8310 	mrs	r3, PRIMASK
3419583e:	623b      	str	r3, [r7, #32]
    return(posture);
34195840:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
34195842:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
34195844:	b672      	cpsid	i
    return(int_posture);
34195846:	69fb      	ldr	r3, [r7, #28]


#ifndef TX_NOT_INTERRUPTABLE

    /* Disable interrupts to remove the suspended thread from the mutex.  */
    TX_DISABLE
34195848:	637b      	str	r3, [r7, #52]	@ 0x34

    /* Determine if the cleanup is still required.  */
    if (thread_ptr -> tx_thread_suspend_cleanup == &(_tx_mutex_cleanup))
3419584a:	687b      	ldr	r3, [r7, #4]
3419584c:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
3419584e:	4a33      	ldr	r2, [pc, #204]	@ (3419591c <_tx_mutex_cleanup+0xec>)
34195850:	4293      	cmp	r3, r2
34195852:	d158      	bne.n	34195906 <_tx_mutex_cleanup+0xd6>
    {

        /* Check for valid suspension sequence.  */
        if (suspension_sequence == thread_ptr -> tx_thread_suspension_sequence)
34195854:	687b      	ldr	r3, [r7, #4]
34195856:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
3419585a:	683a      	ldr	r2, [r7, #0]
3419585c:	429a      	cmp	r2, r3
3419585e:	d152      	bne.n	34195906 <_tx_mutex_cleanup+0xd6>
        {

            /* Setup pointer to mutex control block.  */
            mutex_ptr =  TX_VOID_TO_MUTEX_POINTER_CONVERT(thread_ptr -> tx_thread_suspend_control_block);
34195860:	687b      	ldr	r3, [r7, #4]
34195862:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
34195864:	633b      	str	r3, [r7, #48]	@ 0x30

            /* Check for NULL mutex pointer.  */
            if (mutex_ptr != TX_NULL)
34195866:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34195868:	2b00      	cmp	r3, #0
3419586a:	d04c      	beq.n	34195906 <_tx_mutex_cleanup+0xd6>
            {

                /* Determine if the mutex ID is valid.  */
                if (mutex_ptr -> tx_mutex_id == TX_MUTEX_ID)
3419586c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3419586e:	681b      	ldr	r3, [r3, #0]
34195870:	4a2b      	ldr	r2, [pc, #172]	@ (34195920 <_tx_mutex_cleanup+0xf0>)
34195872:	4293      	cmp	r3, r2
34195874:	d147      	bne.n	34195906 <_tx_mutex_cleanup+0xd6>
                {

                    /* Determine if there are any thread suspensions.  */
                    if (mutex_ptr -> tx_mutex_suspended_count != TX_NO_SUSPENSIONS)
34195876:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34195878:	69db      	ldr	r3, [r3, #28]
3419587a:	2b00      	cmp	r3, #0
3419587c:	d043      	beq.n	34195906 <_tx_mutex_cleanup+0xd6>
#endif

                        /* Yes, we still have thread suspension!  */

                        /* Clear the suspension cleanup flag.  */
                        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
3419587e:	687b      	ldr	r3, [r7, #4]
34195880:	2200      	movs	r2, #0
34195882:	669a      	str	r2, [r3, #104]	@ 0x68

                        /* Decrement the suspension count.  */
                        mutex_ptr -> tx_mutex_suspended_count--;
34195884:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34195886:	69db      	ldr	r3, [r3, #28]
34195888:	1e5a      	subs	r2, r3, #1
3419588a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3419588c:	61da      	str	r2, [r3, #28]

                        /* Pickup the suspended count.  */
                        suspended_count =  mutex_ptr -> tx_mutex_suspended_count;
3419588e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34195890:	69db      	ldr	r3, [r3, #28]
34195892:	62fb      	str	r3, [r7, #44]	@ 0x2c

                        /* Remove the suspended thread from the list.  */

                        /* See if this is the only suspended thread on the list.  */
                        if (suspended_count == TX_NO_SUSPENSIONS)
34195894:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34195896:	2b00      	cmp	r3, #0
34195898:	d103      	bne.n	341958a2 <_tx_mutex_cleanup+0x72>
                        {

                            /* Yes, the only suspended thread.  */

                            /* Update the head pointer.  */
                            mutex_ptr -> tx_mutex_suspension_list =  TX_NULL;
3419589a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3419589c:	2200      	movs	r2, #0
3419589e:	619a      	str	r2, [r3, #24]
341958a0:	e013      	b.n	341958ca <_tx_mutex_cleanup+0x9a>
                        {

                            /* At least one more thread is on the same suspension list.  */

                            /* Update the links of the adjacent threads.  */
                            next_thread =                                   thread_ptr -> tx_thread_suspended_next;
341958a2:	687b      	ldr	r3, [r7, #4]
341958a4:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
341958a6:	62bb      	str	r3, [r7, #40]	@ 0x28
                            previous_thread =                               thread_ptr -> tx_thread_suspended_previous;
341958a8:	687b      	ldr	r3, [r7, #4]
341958aa:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
341958ac:	627b      	str	r3, [r7, #36]	@ 0x24
                            next_thread -> tx_thread_suspended_previous =   previous_thread;
341958ae:	6abb      	ldr	r3, [r7, #40]	@ 0x28
341958b0:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
341958b2:	675a      	str	r2, [r3, #116]	@ 0x74
                            previous_thread -> tx_thread_suspended_next =   next_thread;
341958b4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
341958b6:	6aba      	ldr	r2, [r7, #40]	@ 0x28
341958b8:	671a      	str	r2, [r3, #112]	@ 0x70

                            /* Determine if we need to update the head pointer.  */
                            if (mutex_ptr -> tx_mutex_suspension_list == thread_ptr)
341958ba:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
341958bc:	699b      	ldr	r3, [r3, #24]
341958be:	687a      	ldr	r2, [r7, #4]
341958c0:	429a      	cmp	r2, r3
341958c2:	d102      	bne.n	341958ca <_tx_mutex_cleanup+0x9a>
                            {

                                /* Update the list head pointer.  */
                                mutex_ptr -> tx_mutex_suspension_list =         next_thread;
341958c4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
341958c6:	6aba      	ldr	r2, [r7, #40]	@ 0x28
341958c8:	619a      	str	r2, [r3, #24]
                            }
                        }

                        /* Now we need to determine if this cleanup is from a terminate, timeout,
                           or from a wait abort.  */
                        if (thread_ptr -> tx_thread_state == TX_MUTEX_SUSP)
341958ca:	687b      	ldr	r3, [r7, #4]
341958cc:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
341958ce:	2b0d      	cmp	r3, #13
341958d0:	d119      	bne.n	34195906 <_tx_mutex_cleanup+0xd6>
                            /* Increment the number of timeouts on this semaphore.  */
                            mutex_ptr -> tx_mutex_performance_timeout_count++;
#endif

                            /* Setup return status.  */
                            thread_ptr -> tx_thread_suspend_status =  TX_NOT_AVAILABLE;
341958d2:	687b      	ldr	r3, [r7, #4]
341958d4:	221d      	movs	r2, #29
341958d6:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
                            /* Resume the thread!  */
                            _tx_thread_system_ni_resume(thread_ptr);
#else

                            /* Temporarily disable preemption.  */
                            _tx_thread_preempt_disable++;
341958da:	4b12      	ldr	r3, [pc, #72]	@ (34195924 <_tx_mutex_cleanup+0xf4>)
341958dc:	681b      	ldr	r3, [r3, #0]
341958de:	3301      	adds	r3, #1
341958e0:	4a10      	ldr	r2, [pc, #64]	@ (34195924 <_tx_mutex_cleanup+0xf4>)
341958e2:	6013      	str	r3, [r2, #0]
341958e4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
341958e6:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
341958e8:	693b      	ldr	r3, [r7, #16]
341958ea:	f383 8810 	msr	PRIMASK, r3
}
341958ee:	bf00      	nop

                            /* Restore interrupts.  */
                            TX_RESTORE

                            /* Resume the thread!  */
                            _tx_thread_system_resume(thread_ptr);
341958f0:	6878      	ldr	r0, [r7, #4]
341958f2:	f001 ffc7 	bl	34197884 <_tx_thread_system_resume>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
341958f6:	f3ef 8310 	mrs	r3, PRIMASK
341958fa:	61bb      	str	r3, [r7, #24]
    return(posture);
341958fc:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
341958fe:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
34195900:	b672      	cpsid	i
    return(int_posture);
34195902:	697b      	ldr	r3, [r7, #20]

                            /* Disable interrupts.  */
                            TX_DISABLE
34195904:	637b      	str	r3, [r7, #52]	@ 0x34
34195906:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34195908:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
3419590a:	68fb      	ldr	r3, [r7, #12]
3419590c:	f383 8810 	msr	PRIMASK, r3
}
34195910:	bf00      	nop
    }

    /* Restore interrupts.  */
    TX_RESTORE
#endif
}
34195912:	bf00      	nop
34195914:	3738      	adds	r7, #56	@ 0x38
34195916:	46bd      	mov	sp, r7
34195918:	bd80      	pop	{r7, pc}
3419591a:	bf00      	nop
3419591c:	34195831 	.word	0x34195831
34195920:	4d555445 	.word	0x4d555445
34195924:	341c2e84 	.word	0x341c2e84

34195928 <_tx_mutex_thread_release>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_mutex_thread_release(TX_THREAD  *thread_ptr)
{
34195928:	b580      	push	{r7, lr}
3419592a:	b08a      	sub	sp, #40	@ 0x28
3419592c:	af00      	add	r7, sp, #0
3419592e:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34195930:	f3ef 8310 	mrs	r3, PRIMASK
34195934:	61fb      	str	r3, [r7, #28]
    return(posture);
34195936:	69fb      	ldr	r3, [r7, #28]
    int_posture = __get_interrupt_posture();
34195938:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("CPSID i" : : : "memory");
3419593a:	b672      	cpsid	i
    return(int_posture);
3419593c:	69bb      	ldr	r3, [r7, #24]
UINT        status;
#endif


    /* Disable interrupts.  */
    TX_DISABLE
3419593e:	627b      	str	r3, [r7, #36]	@ 0x24

    /* Temporarily disable preemption.  */
    _tx_thread_preempt_disable++;
34195940:	4b1a      	ldr	r3, [pc, #104]	@ (341959ac <_tx_mutex_thread_release+0x84>)
34195942:	681b      	ldr	r3, [r3, #0]
34195944:	3301      	adds	r3, #1
34195946:	4a19      	ldr	r2, [pc, #100]	@ (341959ac <_tx_mutex_thread_release+0x84>)
34195948:	6013      	str	r3, [r2, #0]
    /* Loop to look at all the mutexes.  */
    do
    {

        /* Pickup the mutex head pointer.  */
        mutex_ptr =  thread_ptr -> tx_thread_owned_mutex_list;
3419594a:	687b      	ldr	r3, [r7, #4]
3419594c:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
34195950:	623b      	str	r3, [r7, #32]

        /* Determine if there is a mutex.  */
        if (mutex_ptr != TX_NULL)
34195952:	6a3b      	ldr	r3, [r7, #32]
34195954:	2b00      	cmp	r3, #0
34195956:	d017      	beq.n	34195988 <_tx_mutex_thread_release+0x60>
        {

            /* Yes, set the ownership count to 1.  */
            mutex_ptr -> tx_mutex_ownership_count =  ((UINT) 1);
34195958:	6a3b      	ldr	r3, [r7, #32]
3419595a:	2201      	movs	r2, #1
3419595c:	609a      	str	r2, [r3, #8]
3419595e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34195960:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34195962:	68fb      	ldr	r3, [r7, #12]
34195964:	f383 8810 	msr	PRIMASK, r3
}
34195968:	bf00      	nop
            do
            {
                status =  _tx_mutex_put(mutex_ptr);
            } while (status != TX_SUCCESS);
#else
            _tx_mutex_put(mutex_ptr);
3419596a:	6a38      	ldr	r0, [r7, #32]
3419596c:	f000 faf2 	bl	34195f54 <_tx_mutex_put>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34195970:	f3ef 8310 	mrs	r3, PRIMASK
34195974:	617b      	str	r3, [r7, #20]
    return(posture);
34195976:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
34195978:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
3419597a:	b672      	cpsid	i
    return(int_posture);
3419597c:	693b      	ldr	r3, [r7, #16]
#endif

            /* Disable interrupts.  */
            TX_DISABLE
3419597e:	627b      	str	r3, [r7, #36]	@ 0x24

            /* Move to the next mutex.  */
            mutex_ptr =  thread_ptr -> tx_thread_owned_mutex_list;
34195980:	687b      	ldr	r3, [r7, #4]
34195982:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
34195986:	623b      	str	r3, [r7, #32]
        }
    } while (mutex_ptr != TX_NULL);
34195988:	6a3b      	ldr	r3, [r7, #32]
3419598a:	2b00      	cmp	r3, #0
3419598c:	d1dd      	bne.n	3419594a <_tx_mutex_thread_release+0x22>

    /* Restore preemption.  */
    _tx_thread_preempt_disable--;
3419598e:	4b07      	ldr	r3, [pc, #28]	@ (341959ac <_tx_mutex_thread_release+0x84>)
34195990:	681b      	ldr	r3, [r3, #0]
34195992:	3b01      	subs	r3, #1
34195994:	4a05      	ldr	r2, [pc, #20]	@ (341959ac <_tx_mutex_thread_release+0x84>)
34195996:	6013      	str	r3, [r2, #0]
34195998:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419599a:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
3419599c:	68bb      	ldr	r3, [r7, #8]
3419599e:	f383 8810 	msr	PRIMASK, r3
}
341959a2:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE
}
341959a4:	bf00      	nop
341959a6:	3728      	adds	r7, #40	@ 0x28
341959a8:	46bd      	mov	sp, r7
341959aa:	bd80      	pop	{r7, pc}
341959ac:	341c2e84 	.word	0x341c2e84

341959b0 <_tx_mutex_create>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_mutex_create(TX_MUTEX *mutex_ptr, CHAR *name_ptr, UINT inherit)
{
341959b0:	b580      	push	{r7, lr}
341959b2:	b08a      	sub	sp, #40	@ 0x28
341959b4:	af00      	add	r7, sp, #0
341959b6:	60f8      	str	r0, [r7, #12]
341959b8:	60b9      	str	r1, [r7, #8]
341959ba:	607a      	str	r2, [r7, #4]
TX_MUTEX        *next_mutex;
TX_MUTEX        *previous_mutex;


    /* Initialize mutex control block to all zeros.  */
    TX_MEMSET(mutex_ptr, 0, (sizeof(TX_MUTEX)));
341959bc:	2234      	movs	r2, #52	@ 0x34
341959be:	2100      	movs	r1, #0
341959c0:	68f8      	ldr	r0, [r7, #12]
341959c2:	f008 fb7d 	bl	3419e0c0 <memset>

    /* Setup the basic mutex fields.  */
    mutex_ptr -> tx_mutex_name =             name_ptr;
341959c6:	68fb      	ldr	r3, [r7, #12]
341959c8:	68ba      	ldr	r2, [r7, #8]
341959ca:	605a      	str	r2, [r3, #4]
    mutex_ptr -> tx_mutex_inherit =          inherit;
341959cc:	68fb      	ldr	r3, [r7, #12]
341959ce:	687a      	ldr	r2, [r7, #4]
341959d0:	611a      	str	r2, [r3, #16]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
341959d2:	f3ef 8310 	mrs	r3, PRIMASK
341959d6:	61bb      	str	r3, [r7, #24]
    return(posture);
341959d8:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
341959da:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
341959dc:	b672      	cpsid	i
    return(int_posture);
341959de:	697b      	ldr	r3, [r7, #20]

    /* Disable interrupts to place the mutex on the created list.  */
    TX_DISABLE
341959e0:	627b      	str	r3, [r7, #36]	@ 0x24

    /* Setup the mutex ID to make it valid.  */
    mutex_ptr -> tx_mutex_id =  TX_MUTEX_ID;
341959e2:	68fb      	ldr	r3, [r7, #12]
341959e4:	4a1a      	ldr	r2, [pc, #104]	@ (34195a50 <_tx_mutex_create+0xa0>)
341959e6:	601a      	str	r2, [r3, #0]

    /* Setup the thread mutex release function pointer.  */
    _tx_thread_mutex_release =  &(_tx_mutex_thread_release);
341959e8:	4b1a      	ldr	r3, [pc, #104]	@ (34195a54 <_tx_mutex_create+0xa4>)
341959ea:	4a1b      	ldr	r2, [pc, #108]	@ (34195a58 <_tx_mutex_create+0xa8>)
341959ec:	601a      	str	r2, [r3, #0]

    /* Place the mutex on the list of created mutexes.  First,
       check for an empty list.  */
    if (_tx_mutex_created_count == TX_EMPTY)
341959ee:	4b1b      	ldr	r3, [pc, #108]	@ (34195a5c <_tx_mutex_create+0xac>)
341959f0:	681b      	ldr	r3, [r3, #0]
341959f2:	2b00      	cmp	r3, #0
341959f4:	d109      	bne.n	34195a0a <_tx_mutex_create+0x5a>
    {

        /* The created mutex list is empty.  Add mutex to empty list.  */
        _tx_mutex_created_ptr =                   mutex_ptr;
341959f6:	4a1a      	ldr	r2, [pc, #104]	@ (34195a60 <_tx_mutex_create+0xb0>)
341959f8:	68fb      	ldr	r3, [r7, #12]
341959fa:	6013      	str	r3, [r2, #0]
        mutex_ptr -> tx_mutex_created_next =      mutex_ptr;
341959fc:	68fb      	ldr	r3, [r7, #12]
341959fe:	68fa      	ldr	r2, [r7, #12]
34195a00:	621a      	str	r2, [r3, #32]
        mutex_ptr -> tx_mutex_created_previous =  mutex_ptr;
34195a02:	68fb      	ldr	r3, [r7, #12]
34195a04:	68fa      	ldr	r2, [r7, #12]
34195a06:	625a      	str	r2, [r3, #36]	@ 0x24
34195a08:	e011      	b.n	34195a2e <_tx_mutex_create+0x7e>
    }
    else
    {

        /* This list is not NULL, add to the end of the list.  */
        next_mutex =      _tx_mutex_created_ptr;
34195a0a:	4b15      	ldr	r3, [pc, #84]	@ (34195a60 <_tx_mutex_create+0xb0>)
34195a0c:	681b      	ldr	r3, [r3, #0]
34195a0e:	623b      	str	r3, [r7, #32]
        previous_mutex =  next_mutex -> tx_mutex_created_previous;
34195a10:	6a3b      	ldr	r3, [r7, #32]
34195a12:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34195a14:	61fb      	str	r3, [r7, #28]

        /* Place the new mutex in the list.  */
        next_mutex -> tx_mutex_created_previous =  mutex_ptr;
34195a16:	6a3b      	ldr	r3, [r7, #32]
34195a18:	68fa      	ldr	r2, [r7, #12]
34195a1a:	625a      	str	r2, [r3, #36]	@ 0x24
        previous_mutex -> tx_mutex_created_next =  mutex_ptr;
34195a1c:	69fb      	ldr	r3, [r7, #28]
34195a1e:	68fa      	ldr	r2, [r7, #12]
34195a20:	621a      	str	r2, [r3, #32]

        /* Setup this mutex's next and previous created links.  */
        mutex_ptr -> tx_mutex_created_previous =  previous_mutex;
34195a22:	68fb      	ldr	r3, [r7, #12]
34195a24:	69fa      	ldr	r2, [r7, #28]
34195a26:	625a      	str	r2, [r3, #36]	@ 0x24
        mutex_ptr -> tx_mutex_created_next =      next_mutex;
34195a28:	68fb      	ldr	r3, [r7, #12]
34195a2a:	6a3a      	ldr	r2, [r7, #32]
34195a2c:	621a      	str	r2, [r3, #32]
    }

    /* Increment the ownership count.  */
    _tx_mutex_created_count++;
34195a2e:	4b0b      	ldr	r3, [pc, #44]	@ (34195a5c <_tx_mutex_create+0xac>)
34195a30:	681b      	ldr	r3, [r3, #0]
34195a32:	3301      	adds	r3, #1
34195a34:	4a09      	ldr	r2, [pc, #36]	@ (34195a5c <_tx_mutex_create+0xac>)
34195a36:	6013      	str	r3, [r2, #0]
34195a38:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34195a3a:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34195a3c:	693b      	ldr	r3, [r7, #16]
34195a3e:	f383 8810 	msr	PRIMASK, r3
}
34195a42:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
34195a44:	2300      	movs	r3, #0
}
34195a46:	4618      	mov	r0, r3
34195a48:	3728      	adds	r7, #40	@ 0x28
34195a4a:	46bd      	mov	sp, r7
34195a4c:	bd80      	pop	{r7, pc}
34195a4e:	bf00      	nop
34195a50:	4d555445 	.word	0x4d555445
34195a54:	341c2e88 	.word	0x341c2e88
34195a58:	34195929 	.word	0x34195929
34195a5c:	341c2dd0 	.word	0x341c2dd0
34195a60:	341c2dcc 	.word	0x341c2dcc

34195a64 <_tx_mutex_get>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_mutex_get(TX_MUTEX *mutex_ptr, ULONG wait_option)
{
34195a64:	b580      	push	{r7, lr}
34195a66:	b092      	sub	sp, #72	@ 0x48
34195a68:	af00      	add	r7, sp, #0
34195a6a:	6078      	str	r0, [r7, #4]
34195a6c:	6039      	str	r1, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34195a6e:	f3ef 8310 	mrs	r3, PRIMASK
34195a72:	627b      	str	r3, [r7, #36]	@ 0x24
    return(posture);
34195a74:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
    int_posture = __get_interrupt_posture();
34195a76:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("CPSID i" : : : "memory");
34195a78:	b672      	cpsid	i
    return(int_posture);
34195a7a:	6a3b      	ldr	r3, [r7, #32]
TX_THREAD       *previous_thread;
UINT            status;


    /* Disable interrupts to get an instance from the mutex.  */
    TX_DISABLE
34195a7c:	643b      	str	r3, [r7, #64]	@ 0x40

    /* Log this kernel call.  */
    TX_EL_MUTEX_GET_INSERT

    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(thread_ptr)
34195a7e:	4b7a      	ldr	r3, [pc, #488]	@ (34195c68 <_tx_mutex_get+0x204>)
34195a80:	681b      	ldr	r3, [r3, #0]
34195a82:	63fb      	str	r3, [r7, #60]	@ 0x3c

    /* Determine if this mutex is available.  */
    if (mutex_ptr -> tx_mutex_ownership_count == ((UINT) 0))
34195a84:	687b      	ldr	r3, [r7, #4]
34195a86:	689b      	ldr	r3, [r3, #8]
34195a88:	2b00      	cmp	r3, #0
34195a8a:	d144      	bne.n	34195b16 <_tx_mutex_get+0xb2>
    {

        /* Set the ownership count to 1.  */
        mutex_ptr -> tx_mutex_ownership_count =  ((UINT) 1);
34195a8c:	687b      	ldr	r3, [r7, #4]
34195a8e:	2201      	movs	r2, #1
34195a90:	609a      	str	r2, [r3, #8]

        /* Remember that the calling thread owns the mutex.  */
        mutex_ptr -> tx_mutex_owner =  thread_ptr;
34195a92:	687b      	ldr	r3, [r7, #4]
34195a94:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
34195a96:	60da      	str	r2, [r3, #12]

        /* Determine if the thread pointer is valid.  */
        if (thread_ptr != TX_NULL)
34195a98:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34195a9a:	2b00      	cmp	r3, #0
34195a9c:	d032      	beq.n	34195b04 <_tx_mutex_get+0xa0>
        {

            /* Determine if priority inheritance is required.  */
            if (mutex_ptr -> tx_mutex_inherit == TX_TRUE)
34195a9e:	687b      	ldr	r3, [r7, #4]
34195aa0:	691b      	ldr	r3, [r3, #16]
34195aa2:	2b01      	cmp	r3, #1
34195aa4:	d106      	bne.n	34195ab4 <_tx_mutex_get+0x50>
            {

                /* Remember the current priority of thread.  */
                mutex_ptr -> tx_mutex_original_priority =   thread_ptr -> tx_thread_priority;
34195aa6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34195aa8:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
34195aaa:	687b      	ldr	r3, [r7, #4]
34195aac:	615a      	str	r2, [r3, #20]

                /* Setup the highest priority waiting thread.  */
                mutex_ptr -> tx_mutex_highest_priority_waiting =  ((UINT) TX_MAX_PRIORITIES);
34195aae:	687b      	ldr	r3, [r7, #4]
34195ab0:	2220      	movs	r2, #32
34195ab2:	629a      	str	r2, [r3, #40]	@ 0x28
            }

            /* Pickup next mutex pointer, which is the head of the list.  */
            next_mutex =  thread_ptr -> tx_thread_owned_mutex_list;
34195ab4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34195ab6:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
34195aba:	62fb      	str	r3, [r7, #44]	@ 0x2c

            /* Determine if this thread owns any other mutexes that have priority inheritance.  */
            if (next_mutex != TX_NULL)
34195abc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34195abe:	2b00      	cmp	r3, #0
34195ac0:	d00f      	beq.n	34195ae2 <_tx_mutex_get+0x7e>
            {

                /* Non-empty list. Link up the mutex.  */

                /* Pickup the next and previous mutex pointer.  */
                previous_mutex =  next_mutex -> tx_mutex_owned_previous;
34195ac2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34195ac4:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34195ac6:	62bb      	str	r3, [r7, #40]	@ 0x28

                /* Place the owned mutex in the list.  */
                next_mutex -> tx_mutex_owned_previous =  mutex_ptr;
34195ac8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34195aca:	687a      	ldr	r2, [r7, #4]
34195acc:	631a      	str	r2, [r3, #48]	@ 0x30
                previous_mutex -> tx_mutex_owned_next =  mutex_ptr;
34195ace:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34195ad0:	687a      	ldr	r2, [r7, #4]
34195ad2:	62da      	str	r2, [r3, #44]	@ 0x2c

                /* Setup this mutex's next and previous created links.  */
                mutex_ptr -> tx_mutex_owned_previous =  previous_mutex;
34195ad4:	687b      	ldr	r3, [r7, #4]
34195ad6:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34195ad8:	631a      	str	r2, [r3, #48]	@ 0x30
                mutex_ptr -> tx_mutex_owned_next =      next_mutex;
34195ada:	687b      	ldr	r3, [r7, #4]
34195adc:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
34195ade:	62da      	str	r2, [r3, #44]	@ 0x2c
34195ae0:	e009      	b.n	34195af6 <_tx_mutex_get+0x92>
            }
            else
            {

                /* The owned mutex list is empty.  Add mutex to empty list.  */
                thread_ptr -> tx_thread_owned_mutex_list =     mutex_ptr;
34195ae2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34195ae4:	687a      	ldr	r2, [r7, #4]
34195ae6:	f8c3 20a4 	str.w	r2, [r3, #164]	@ 0xa4
                mutex_ptr -> tx_mutex_owned_next =             mutex_ptr;
34195aea:	687b      	ldr	r3, [r7, #4]
34195aec:	687a      	ldr	r2, [r7, #4]
34195aee:	62da      	str	r2, [r3, #44]	@ 0x2c
                mutex_ptr -> tx_mutex_owned_previous =         mutex_ptr;
34195af0:	687b      	ldr	r3, [r7, #4]
34195af2:	687a      	ldr	r2, [r7, #4]
34195af4:	631a      	str	r2, [r3, #48]	@ 0x30
            }

            /* Increment the number of mutexes owned counter.  */
            thread_ptr -> tx_thread_owned_mutex_count++;
34195af6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34195af8:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
34195afc:	1c5a      	adds	r2, r3, #1
34195afe:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34195b00:	f8c3 20a0 	str.w	r2, [r3, #160]	@ 0xa0
34195b04:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34195b06:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34195b08:	69fb      	ldr	r3, [r7, #28]
34195b0a:	f383 8810 	msr	PRIMASK, r3
}
34195b0e:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Return success.  */
        status =  TX_SUCCESS;
34195b10:	2300      	movs	r3, #0
34195b12:	647b      	str	r3, [r7, #68]	@ 0x44
34195b14:	e0a2      	b.n	34195c5c <_tx_mutex_get+0x1f8>
    }

    /* Otherwise, see if the owning thread is trying to obtain the same mutex.  */
    else if (mutex_ptr -> tx_mutex_owner == thread_ptr)
34195b16:	687b      	ldr	r3, [r7, #4]
34195b18:	68db      	ldr	r3, [r3, #12]
34195b1a:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
34195b1c:	429a      	cmp	r2, r3
34195b1e:	d10d      	bne.n	34195b3c <_tx_mutex_get+0xd8>
    {

        /* The owning thread is requesting the mutex again, just
           increment the ownership count.  */
        mutex_ptr -> tx_mutex_ownership_count++;
34195b20:	687b      	ldr	r3, [r7, #4]
34195b22:	689b      	ldr	r3, [r3, #8]
34195b24:	1c5a      	adds	r2, r3, #1
34195b26:	687b      	ldr	r3, [r7, #4]
34195b28:	609a      	str	r2, [r3, #8]
34195b2a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34195b2c:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34195b2e:	69bb      	ldr	r3, [r7, #24]
34195b30:	f383 8810 	msr	PRIMASK, r3
}
34195b34:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Return success.  */
        status =  TX_SUCCESS;
34195b36:	2300      	movs	r3, #0
34195b38:	647b      	str	r3, [r7, #68]	@ 0x44
34195b3a:	e08f      	b.n	34195c5c <_tx_mutex_get+0x1f8>
    }
    else
    {

        /* Determine if the request specifies suspension.  */
        if (wait_option != TX_NO_WAIT)
34195b3c:	683b      	ldr	r3, [r7, #0]
34195b3e:	2b00      	cmp	r3, #0
34195b40:	f000 8084 	beq.w	34195c4c <_tx_mutex_get+0x1e8>
        {

            /* Determine if the preempt disable flag is non-zero.  */
            if (_tx_thread_preempt_disable != ((UINT) 0))
34195b44:	4b49      	ldr	r3, [pc, #292]	@ (34195c6c <_tx_mutex_get+0x208>)
34195b46:	681b      	ldr	r3, [r3, #0]
34195b48:	2b00      	cmp	r3, #0
34195b4a:	d008      	beq.n	34195b5e <_tx_mutex_get+0xfa>
34195b4c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34195b4e:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34195b50:	697b      	ldr	r3, [r7, #20]
34195b52:	f383 8810 	msr	PRIMASK, r3
}
34195b56:	bf00      	nop

                /* Restore interrupts.  */
                TX_RESTORE

                /* Suspension is not allowed if the preempt disable flag is non-zero at this point - return error completion.  */
                status =  TX_NOT_AVAILABLE;
34195b58:	231d      	movs	r3, #29
34195b5a:	647b      	str	r3, [r7, #68]	@ 0x44
34195b5c:	e07e      	b.n	34195c5c <_tx_mutex_get+0x1f8>
            {

                /* Prepare for suspension of this thread.  */

                /* Pickup the mutex owner.  */
                mutex_owner =  mutex_ptr -> tx_mutex_owner;
34195b5e:	687b      	ldr	r3, [r7, #4]
34195b60:	68db      	ldr	r3, [r3, #12]
34195b62:	63bb      	str	r3, [r7, #56]	@ 0x38
#endif
                }
#endif

                /* Setup cleanup routine pointer.  */
                thread_ptr -> tx_thread_suspend_cleanup =  &(_tx_mutex_cleanup);
34195b64:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34195b66:	4a42      	ldr	r2, [pc, #264]	@ (34195c70 <_tx_mutex_get+0x20c>)
34195b68:	669a      	str	r2, [r3, #104]	@ 0x68

                /* Setup cleanup information, i.e. this mutex control
                   block.  */
                thread_ptr -> tx_thread_suspend_control_block =  (VOID *) mutex_ptr;
34195b6a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34195b6c:	687a      	ldr	r2, [r7, #4]
34195b6e:	66da      	str	r2, [r3, #108]	@ 0x6c

#ifndef TX_NOT_INTERRUPTABLE

                /* Increment the suspension sequence number, which is used to identify
                   this suspension event.  */
                thread_ptr -> tx_thread_suspension_sequence++;
34195b70:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34195b72:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
34195b76:	1c5a      	adds	r2, r3, #1
34195b78:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34195b7a:	f8c3 20ac 	str.w	r2, [r3, #172]	@ 0xac
#endif

                /* Setup suspension list.  */
                if (mutex_ptr -> tx_mutex_suspended_count == TX_NO_SUSPENSIONS)
34195b7e:	687b      	ldr	r3, [r7, #4]
34195b80:	69db      	ldr	r3, [r3, #28]
34195b82:	2b00      	cmp	r3, #0
34195b84:	d109      	bne.n	34195b9a <_tx_mutex_get+0x136>
                {

                    /* No other threads are suspended.  Setup the head pointer and
                       just setup this threads pointers to itself.  */
                    mutex_ptr -> tx_mutex_suspension_list =         thread_ptr;
34195b86:	687b      	ldr	r3, [r7, #4]
34195b88:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
34195b8a:	619a      	str	r2, [r3, #24]
                    thread_ptr -> tx_thread_suspended_next =        thread_ptr;
34195b8c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34195b8e:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
34195b90:	671a      	str	r2, [r3, #112]	@ 0x70
                    thread_ptr -> tx_thread_suspended_previous =    thread_ptr;
34195b92:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34195b94:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
34195b96:	675a      	str	r2, [r3, #116]	@ 0x74
34195b98:	e011      	b.n	34195bbe <_tx_mutex_get+0x15a>
                }
                else
                {

                    /* This list is not NULL, add current thread to the end. */
                    next_thread =                                   mutex_ptr -> tx_mutex_suspension_list;
34195b9a:	687b      	ldr	r3, [r7, #4]
34195b9c:	699b      	ldr	r3, [r3, #24]
34195b9e:	637b      	str	r3, [r7, #52]	@ 0x34
                    thread_ptr -> tx_thread_suspended_next =        next_thread;
34195ba0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34195ba2:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
34195ba4:	671a      	str	r2, [r3, #112]	@ 0x70
                    previous_thread =                               next_thread -> tx_thread_suspended_previous;
34195ba6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34195ba8:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34195baa:	633b      	str	r3, [r7, #48]	@ 0x30
                    thread_ptr -> tx_thread_suspended_previous =    previous_thread;
34195bac:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34195bae:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
34195bb0:	675a      	str	r2, [r3, #116]	@ 0x74
                    previous_thread -> tx_thread_suspended_next =   thread_ptr;
34195bb2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34195bb4:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
34195bb6:	671a      	str	r2, [r3, #112]	@ 0x70
                    next_thread -> tx_thread_suspended_previous =   thread_ptr;
34195bb8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34195bba:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
34195bbc:	675a      	str	r2, [r3, #116]	@ 0x74
                }

                /* Increment the suspension count.  */
                mutex_ptr -> tx_mutex_suspended_count++;
34195bbe:	687b      	ldr	r3, [r7, #4]
34195bc0:	69db      	ldr	r3, [r3, #28]
34195bc2:	1c5a      	adds	r2, r3, #1
34195bc4:	687b      	ldr	r3, [r7, #4]
34195bc6:	61da      	str	r2, [r3, #28]

                /* Set the state to suspended.  */
                thread_ptr -> tx_thread_state =    TX_MUTEX_SUSP;
34195bc8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34195bca:	220d      	movs	r2, #13
34195bcc:	631a      	str	r2, [r3, #48]	@ 0x30
                /* Restore interrupts.  */
                TX_RESTORE
#else

                /* Set the suspending flag.  */
                thread_ptr -> tx_thread_suspending =  TX_TRUE;
34195bce:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34195bd0:	2201      	movs	r2, #1
34195bd2:	639a      	str	r2, [r3, #56]	@ 0x38

                /* Setup the timeout period.  */
                thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  wait_option;
34195bd4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34195bd6:	683a      	ldr	r2, [r7, #0]
34195bd8:	64da      	str	r2, [r3, #76]	@ 0x4c

                /* Temporarily disable preemption.  */
                _tx_thread_preempt_disable++;
34195bda:	4b24      	ldr	r3, [pc, #144]	@ (34195c6c <_tx_mutex_get+0x208>)
34195bdc:	681b      	ldr	r3, [r3, #0]
34195bde:	3301      	adds	r3, #1
34195be0:	4a22      	ldr	r2, [pc, #136]	@ (34195c6c <_tx_mutex_get+0x208>)
34195be2:	6013      	str	r3, [r2, #0]
34195be4:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34195be6:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34195be8:	693b      	ldr	r3, [r7, #16]
34195bea:	f383 8810 	msr	PRIMASK, r3
}
34195bee:	bf00      	nop
                /* Restore interrupts.  */
                TX_RESTORE

                /* Determine if we need to raise the priority of the thread
                   owning the mutex.  */
                if (mutex_ptr -> tx_mutex_inherit == TX_TRUE)
34195bf0:	687b      	ldr	r3, [r7, #4]
34195bf2:	691b      	ldr	r3, [r3, #16]
34195bf4:	2b01      	cmp	r3, #1
34195bf6:	d121      	bne.n	34195c3c <_tx_mutex_get+0x1d8>
                {

                    /* Determine if this is the highest priority to raise for this mutex.  */
                    if (mutex_ptr -> tx_mutex_highest_priority_waiting > thread_ptr -> tx_thread_priority)
34195bf8:	687b      	ldr	r3, [r7, #4]
34195bfa:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
34195bfc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34195bfe:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34195c00:	429a      	cmp	r2, r3
34195c02:	d903      	bls.n	34195c0c <_tx_mutex_get+0x1a8>
                    {

                        /* Remember this priority.  */
                        mutex_ptr -> tx_mutex_highest_priority_waiting =  thread_ptr -> tx_thread_priority;
34195c04:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34195c06:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
34195c08:	687b      	ldr	r3, [r7, #4]
34195c0a:	629a      	str	r2, [r3, #40]	@ 0x28
                    }

                    /* Determine if we have to update inherit priority level of the mutex owner.  */
                    if (thread_ptr -> tx_thread_priority < mutex_owner -> tx_thread_inherit_priority)
34195c0c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34195c0e:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
34195c10:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34195c12:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
34195c16:	429a      	cmp	r2, r3
34195c18:	d204      	bcs.n	34195c24 <_tx_mutex_get+0x1c0>
                    {

                        /* Remember the new priority inheritance priority.  */
                        mutex_owner -> tx_thread_inherit_priority =  thread_ptr -> tx_thread_priority;
34195c1a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34195c1c:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
34195c1e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34195c20:	f8c3 209c 	str.w	r2, [r3, #156]	@ 0x9c
                    }

                    /* Priority inheritance is requested, check to see if the thread that owns the mutex is lower priority.  */
                    if (mutex_owner -> tx_thread_priority > thread_ptr -> tx_thread_priority)
34195c24:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34195c26:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
34195c28:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34195c2a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34195c2c:	429a      	cmp	r2, r3
34195c2e:	d905      	bls.n	34195c3c <_tx_mutex_get+0x1d8>
                    {

                        /* Yes, raise the suspended, owning thread's priority to that
                           of the current thread.  */
                        _tx_mutex_priority_change(mutex_owner, thread_ptr -> tx_thread_priority);
34195c30:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34195c32:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34195c34:	4619      	mov	r1, r3
34195c36:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
34195c38:	f000 f8ce 	bl	34195dd8 <_tx_mutex_priority_change>
#endif
                    }
                }

                /* Call actual thread suspension routine.  */
                _tx_thread_system_suspend(thread_ptr);
34195c3c:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
34195c3e:	f001 ff21 	bl	34197a84 <_tx_thread_system_suspend>
#endif
                /* Return the completion status.  */
                status =  thread_ptr -> tx_thread_suspend_status;
34195c42:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34195c44:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
34195c48:	647b      	str	r3, [r7, #68]	@ 0x44
34195c4a:	e007      	b.n	34195c5c <_tx_mutex_get+0x1f8>
34195c4c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34195c4e:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34195c50:	68fb      	ldr	r3, [r7, #12]
34195c52:	f383 8810 	msr	PRIMASK, r3
}
34195c56:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Immediate return, return error completion.  */
            status =  TX_NOT_AVAILABLE;
34195c58:	231d      	movs	r3, #29
34195c5a:	647b      	str	r3, [r7, #68]	@ 0x44
        }
    }

    /* Return completion status.  */
    return(status);
34195c5c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
}
34195c5e:	4618      	mov	r0, r3
34195c60:	3748      	adds	r7, #72	@ 0x48
34195c62:	46bd      	mov	sp, r7
34195c64:	bd80      	pop	{r7, pc}
34195c66:	bf00      	nop
34195c68:	341c2dec 	.word	0x341c2dec
34195c6c:	341c2e84 	.word	0x341c2e84
34195c70:	34195831 	.word	0x34195831

34195c74 <_tx_mutex_prioritize>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_mutex_prioritize(TX_MUTEX *mutex_ptr)
{
34195c74:	b580      	push	{r7, lr}
34195c76:	b092      	sub	sp, #72	@ 0x48
34195c78:	af00      	add	r7, sp, #0
34195c7a:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34195c7c:	f3ef 8310 	mrs	r3, PRIMASK
34195c80:	627b      	str	r3, [r7, #36]	@ 0x24
    return(posture);
34195c82:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
    int_posture = __get_interrupt_posture();
34195c84:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("CPSID i" : : : "memory");
34195c86:	b672      	cpsid	i
    return(int_posture);
34195c88:	6a3b      	ldr	r3, [r7, #32]
UINT            status;
#endif


    /* Disable interrupts.  */
    TX_DISABLE
34195c8a:	647b      	str	r3, [r7, #68]	@ 0x44

    /* Log this kernel call.  */
    TX_EL_MUTEX_PRIORITIZE_INSERT

    /* Pickup the suspended count.  */
    suspended_count =  mutex_ptr -> tx_mutex_suspended_count;
34195c8c:	687b      	ldr	r3, [r7, #4]
34195c8e:	69db      	ldr	r3, [r3, #28]
34195c90:	637b      	str	r3, [r7, #52]	@ 0x34

    /* Determine if there are fewer than 2 suspended threads.  */
    if (suspended_count < ((UINT) 2))
34195c92:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34195c94:	2b01      	cmp	r3, #1
34195c96:	d805      	bhi.n	34195ca4 <_tx_mutex_prioritize+0x30>
34195c98:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34195c9a:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34195c9c:	69fb      	ldr	r3, [r7, #28]
34195c9e:	f383 8810 	msr	PRIMASK, r3
}
34195ca2:	e092      	b.n	34195dca <_tx_mutex_prioritize+0x156>
        /* Restore interrupts.  */
        TX_RESTORE
    }

    /* Determine if there how many threads are suspended on this mutex.  */
    else if (suspended_count == ((UINT) 2))
34195ca4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34195ca6:	2b02      	cmp	r3, #2
34195ca8:	d114      	bne.n	34195cd4 <_tx_mutex_prioritize+0x60>
    {

        /* Pickup the head pointer and the next pointer.  */
        head_ptr =  mutex_ptr -> tx_mutex_suspension_list;
34195caa:	687b      	ldr	r3, [r7, #4]
34195cac:	699b      	ldr	r3, [r3, #24]
34195cae:	63bb      	str	r3, [r7, #56]	@ 0x38
        next_thread =  head_ptr -> tx_thread_suspended_next;
34195cb0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34195cb2:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34195cb4:	62fb      	str	r3, [r7, #44]	@ 0x2c

        /* Determine if the next suspended thread has a higher priority.  */
        if ((next_thread -> tx_thread_priority) < (head_ptr -> tx_thread_priority))
34195cb6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34195cb8:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
34195cba:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34195cbc:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34195cbe:	429a      	cmp	r2, r3
34195cc0:	d202      	bcs.n	34195cc8 <_tx_mutex_prioritize+0x54>
        {

            /* Yes, move the list head to the next thread.  */
            mutex_ptr -> tx_mutex_suspension_list =  next_thread;
34195cc2:	687b      	ldr	r3, [r7, #4]
34195cc4:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
34195cc6:	619a      	str	r2, [r3, #24]
34195cc8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34195cca:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34195ccc:	69bb      	ldr	r3, [r7, #24]
34195cce:	f383 8810 	msr	PRIMASK, r3
}
34195cd2:	e07a      	b.n	34195dca <_tx_mutex_prioritize+0x156>
    }
    else
    {

        /* Remember the suspension count and head pointer.  */
        head_ptr =   mutex_ptr -> tx_mutex_suspension_list;
34195cd4:	687b      	ldr	r3, [r7, #4]
34195cd6:	699b      	ldr	r3, [r3, #24]
34195cd8:	63bb      	str	r3, [r7, #56]	@ 0x38

        /* Default the highest priority thread to the thread at the front of the list.  */
        priority_thread_ptr =  head_ptr;
34195cda:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34195cdc:	63fb      	str	r3, [r7, #60]	@ 0x3c

        /* Setup search pointer.  */
        thread_ptr =  priority_thread_ptr -> tx_thread_suspended_next;
34195cde:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34195ce0:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34195ce2:	643b      	str	r3, [r7, #64]	@ 0x40

        /* Disable preemption.  */
        _tx_thread_preempt_disable++;
34195ce4:	4b3b      	ldr	r3, [pc, #236]	@ (34195dd4 <_tx_mutex_prioritize+0x160>)
34195ce6:	681b      	ldr	r3, [r3, #0]
34195ce8:	3301      	adds	r3, #1
34195cea:	4a3a      	ldr	r2, [pc, #232]	@ (34195dd4 <_tx_mutex_prioritize+0x160>)
34195cec:	6013      	str	r3, [r2, #0]

        /* Set the list changed flag to false.  */
        list_changed =  TX_FALSE;
34195cee:	2300      	movs	r3, #0
34195cf0:	633b      	str	r3, [r7, #48]	@ 0x30
        /* Search through the list to find the highest priority thread.  */
        do
        {

            /* Is the current thread higher priority?  */
            if (thread_ptr -> tx_thread_priority < priority_thread_ptr -> tx_thread_priority)
34195cf2:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34195cf4:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
34195cf6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34195cf8:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34195cfa:	429a      	cmp	r2, r3
34195cfc:	d201      	bcs.n	34195d02 <_tx_mutex_prioritize+0x8e>
            {

                /* Yes, remember that this thread is the highest priority.  */
                priority_thread_ptr =  thread_ptr;
34195cfe:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34195d00:	63fb      	str	r3, [r7, #60]	@ 0x3c
34195d02:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34195d04:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34195d06:	68fb      	ldr	r3, [r7, #12]
34195d08:	f383 8810 	msr	PRIMASK, r3
}
34195d0c:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34195d0e:	f3ef 8310 	mrs	r3, PRIMASK
34195d12:	617b      	str	r3, [r7, #20]
    return(posture);
34195d14:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
34195d16:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
34195d18:	b672      	cpsid	i
    return(int_posture);
34195d1a:	693b      	ldr	r3, [r7, #16]

            /* Restore interrupts temporarily.  */
            TX_RESTORE

            /* Disable interrupts again.  */
            TX_DISABLE
34195d1c:	647b      	str	r3, [r7, #68]	@ 0x44

            /* Determine if any changes to the list have occurred while
               interrupts were enabled.  */

            /* Is the list head the same?  */
            if (head_ptr != mutex_ptr -> tx_mutex_suspension_list)
34195d1e:	687b      	ldr	r3, [r7, #4]
34195d20:	699b      	ldr	r3, [r3, #24]
34195d22:	6bba      	ldr	r2, [r7, #56]	@ 0x38
34195d24:	429a      	cmp	r2, r3
34195d26:	d002      	beq.n	34195d2e <_tx_mutex_prioritize+0xba>
            {

                /* The list head has changed, set the list changed flag.  */
                list_changed =  TX_TRUE;
34195d28:	2301      	movs	r3, #1
34195d2a:	633b      	str	r3, [r7, #48]	@ 0x30
34195d2c:	e006      	b.n	34195d3c <_tx_mutex_prioritize+0xc8>
            }
            else
            {

                /* Is the suspended count the same?  */
                if (suspended_count != mutex_ptr -> tx_mutex_suspended_count)
34195d2e:	687b      	ldr	r3, [r7, #4]
34195d30:	69db      	ldr	r3, [r3, #28]
34195d32:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
34195d34:	429a      	cmp	r2, r3
34195d36:	d001      	beq.n	34195d3c <_tx_mutex_prioritize+0xc8>
                {

                    /* The list head has changed, set the list changed flag.  */
                    list_changed =  TX_TRUE;
34195d38:	2301      	movs	r3, #1
34195d3a:	633b      	str	r3, [r7, #48]	@ 0x30
                }
            }

            /* Determine if the list has changed.  */
            if (list_changed == TX_FALSE)
34195d3c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34195d3e:	2b00      	cmp	r3, #0
34195d40:	d103      	bne.n	34195d4a <_tx_mutex_prioritize+0xd6>
            {

                /* Move the thread pointer to the next thread.  */
                thread_ptr =  thread_ptr -> tx_thread_suspended_next;
34195d42:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34195d44:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34195d46:	643b      	str	r3, [r7, #64]	@ 0x40
34195d48:	e00c      	b.n	34195d64 <_tx_mutex_prioritize+0xf0>
            }
            else
            {

                /* Remember the suspension count and head pointer.  */
                head_ptr =   mutex_ptr -> tx_mutex_suspension_list;
34195d4a:	687b      	ldr	r3, [r7, #4]
34195d4c:	699b      	ldr	r3, [r3, #24]
34195d4e:	63bb      	str	r3, [r7, #56]	@ 0x38
                suspended_count =  mutex_ptr -> tx_mutex_suspended_count;
34195d50:	687b      	ldr	r3, [r7, #4]
34195d52:	69db      	ldr	r3, [r3, #28]
34195d54:	637b      	str	r3, [r7, #52]	@ 0x34

                /* Default the highest priority thread to the thread at the front of the list.  */
                priority_thread_ptr =  head_ptr;
34195d56:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34195d58:	63fb      	str	r3, [r7, #60]	@ 0x3c

                /* Setup search pointer.  */
                thread_ptr =  priority_thread_ptr -> tx_thread_suspended_next;
34195d5a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34195d5c:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34195d5e:	643b      	str	r3, [r7, #64]	@ 0x40

                /* Reset the list changed flag.  */
                list_changed =  TX_FALSE;
34195d60:	2300      	movs	r3, #0
34195d62:	633b      	str	r3, [r7, #48]	@ 0x30
            }

        } while (thread_ptr != head_ptr);
34195d64:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
34195d66:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34195d68:	429a      	cmp	r2, r3
34195d6a:	d1c2      	bne.n	34195cf2 <_tx_mutex_prioritize+0x7e>

        /* Release preemption.  */
        _tx_thread_preempt_disable--;
34195d6c:	4b19      	ldr	r3, [pc, #100]	@ (34195dd4 <_tx_mutex_prioritize+0x160>)
34195d6e:	681b      	ldr	r3, [r3, #0]
34195d70:	3b01      	subs	r3, #1
34195d72:	4a18      	ldr	r2, [pc, #96]	@ (34195dd4 <_tx_mutex_prioritize+0x160>)
34195d74:	6013      	str	r3, [r2, #0]

        /* Now determine if the highest priority thread is at the front
           of the list.  */
        if (priority_thread_ptr != head_ptr)
34195d76:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
34195d78:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34195d7a:	429a      	cmp	r2, r3
34195d7c:	d01d      	beq.n	34195dba <_tx_mutex_prioritize+0x146>
            /* No, we need to move the highest priority suspended thread to the
               front of the list.  */

            /* First, remove the highest priority thread by updating the
               adjacent suspended threads.  */
            next_thread =                                  priority_thread_ptr -> tx_thread_suspended_next;
34195d7e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34195d80:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34195d82:	62fb      	str	r3, [r7, #44]	@ 0x2c
            previous_thread =                              priority_thread_ptr -> tx_thread_suspended_previous;
34195d84:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34195d86:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34195d88:	62bb      	str	r3, [r7, #40]	@ 0x28
            next_thread -> tx_thread_suspended_previous =  previous_thread;
34195d8a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34195d8c:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34195d8e:	675a      	str	r2, [r3, #116]	@ 0x74
            previous_thread -> tx_thread_suspended_next =  next_thread;
34195d90:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34195d92:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
34195d94:	671a      	str	r2, [r3, #112]	@ 0x70

            /* Now, link the highest priority thread at the front of the list.  */
            previous_thread =                                      head_ptr -> tx_thread_suspended_previous;
34195d96:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34195d98:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34195d9a:	62bb      	str	r3, [r7, #40]	@ 0x28
            priority_thread_ptr -> tx_thread_suspended_next =      head_ptr;
34195d9c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34195d9e:	6bba      	ldr	r2, [r7, #56]	@ 0x38
34195da0:	671a      	str	r2, [r3, #112]	@ 0x70
            priority_thread_ptr -> tx_thread_suspended_previous =  previous_thread;
34195da2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34195da4:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34195da6:	675a      	str	r2, [r3, #116]	@ 0x74
            previous_thread -> tx_thread_suspended_next =          priority_thread_ptr;
34195da8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34195daa:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
34195dac:	671a      	str	r2, [r3, #112]	@ 0x70
            head_ptr -> tx_thread_suspended_previous =             priority_thread_ptr;
34195dae:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34195db0:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
34195db2:	675a      	str	r2, [r3, #116]	@ 0x74

            /* Move the list head pointer to the highest priority suspended thread.  */
            mutex_ptr -> tx_mutex_suspension_list =  priority_thread_ptr;
34195db4:	687b      	ldr	r3, [r7, #4]
34195db6:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
34195db8:	619a      	str	r2, [r3, #24]
34195dba:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34195dbc:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34195dbe:	68bb      	ldr	r3, [r7, #8]
34195dc0:	f383 8810 	msr	PRIMASK, r3
}
34195dc4:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Check for preemption.  */
        _tx_thread_system_preempt_check();
34195dc6:	f001 fd23 	bl	34197810 <_tx_thread_system_preempt_check>
    /* Return completion status.  */
    return(status);
#else

    /* Return successful completion.  */
    return(TX_SUCCESS);
34195dca:	2300      	movs	r3, #0
#endif
}
34195dcc:	4618      	mov	r0, r3
34195dce:	3748      	adds	r7, #72	@ 0x48
34195dd0:	46bd      	mov	sp, r7
34195dd2:	bd80      	pop	{r7, pc}
34195dd4:	341c2e84 	.word	0x341c2e84

34195dd8 <_tx_mutex_priority_change>:
/*                                            priority rather than next,  */
/*                                            resulting in version 6.1.6  */
/*                                                                        */
/**************************************************************************/
VOID  _tx_mutex_priority_change(TX_THREAD *thread_ptr, UINT new_priority)
{
34195dd8:	b580      	push	{r7, lr}
34195dda:	b090      	sub	sp, #64	@ 0x40
34195ddc:	af00      	add	r7, sp, #0
34195dde:	6078      	str	r0, [r7, #4]
34195de0:	6039      	str	r1, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34195de2:	f3ef 8310 	mrs	r3, PRIMASK
34195de6:	62fb      	str	r3, [r7, #44]	@ 0x2c
    return(posture);
34195de8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
    int_posture = __get_interrupt_posture();
34195dea:	62bb      	str	r3, [r7, #40]	@ 0x28
    __asm__ volatile ("CPSID i" : : : "memory");
34195dec:	b672      	cpsid	i
    return(int_posture);
34195dee:	6abb      	ldr	r3, [r7, #40]	@ 0x28


#ifndef TX_NOT_INTERRUPTABLE

    /* Lockout interrupts while the thread is being suspended.  */
    TX_DISABLE
34195df0:	63fb      	str	r3, [r7, #60]	@ 0x3c
#endif

    /* Determine if this thread is currently ready.  */
    if (thread_ptr -> tx_thread_state != TX_READY)
34195df2:	687b      	ldr	r3, [r7, #4]
34195df4:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34195df6:	2b00      	cmp	r3, #0
34195df8:	d017      	beq.n	34195e2a <_tx_mutex_priority_change+0x52>
    {

        /* Change thread priority to the new mutex priority-inheritance priority.  */
        thread_ptr -> tx_thread_priority =  new_priority;
34195dfa:	687b      	ldr	r3, [r7, #4]
34195dfc:	683a      	ldr	r2, [r7, #0]
34195dfe:	62da      	str	r2, [r3, #44]	@ 0x2c

        /* Determine how to setup the thread's preemption-threshold.  */
        if (thread_ptr -> tx_thread_user_preempt_threshold < new_priority)
34195e00:	687b      	ldr	r3, [r7, #4]
34195e02:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
34195e06:	683a      	ldr	r2, [r7, #0]
34195e08:	429a      	cmp	r2, r3
34195e0a:	d905      	bls.n	34195e18 <_tx_mutex_priority_change+0x40>
        {

            /* Change thread preemption-threshold to the user's preemption-threshold.  */
            thread_ptr -> tx_thread_preempt_threshold =  thread_ptr -> tx_thread_user_preempt_threshold;
34195e0c:	687b      	ldr	r3, [r7, #4]
34195e0e:	f8d3 2098 	ldr.w	r2, [r3, #152]	@ 0x98
34195e12:	687b      	ldr	r3, [r7, #4]
34195e14:	63da      	str	r2, [r3, #60]	@ 0x3c
34195e16:	e002      	b.n	34195e1e <_tx_mutex_priority_change+0x46>
        }
        else
        {

            /* Change the thread preemption-threshold to the new threshold.  */
            thread_ptr -> tx_thread_preempt_threshold =  new_priority;
34195e18:	687b      	ldr	r3, [r7, #4]
34195e1a:	683a      	ldr	r2, [r7, #0]
34195e1c:	63da      	str	r2, [r3, #60]	@ 0x3c
34195e1e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34195e20:	627b      	str	r3, [r7, #36]	@ 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34195e22:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34195e24:	f383 8810 	msr	PRIMASK, r3
}
34195e28:	e089      	b.n	34195f3e <_tx_mutex_priority_change+0x166>
    }
    else
    {

        /* Pickup the next thread to execute.  */
        execute_ptr =  _tx_thread_execute_ptr;
34195e2a:	4b47      	ldr	r3, [pc, #284]	@ (34195f48 <_tx_mutex_priority_change+0x170>)
34195e2c:	681b      	ldr	r3, [r3, #0]
34195e2e:	63bb      	str	r3, [r7, #56]	@ 0x38

        /* Save the original priority.  */
        original_priority =  thread_ptr -> tx_thread_priority;
34195e30:	687b      	ldr	r3, [r7, #4]
34195e32:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34195e34:	637b      	str	r3, [r7, #52]	@ 0x34
        /* Decrement the preempt disable flag.  */
        _tx_thread_preempt_disable--;
#else

        /* Increment the preempt disable flag.  */
        _tx_thread_preempt_disable =  _tx_thread_preempt_disable + ((UINT) 2);
34195e36:	4b45      	ldr	r3, [pc, #276]	@ (34195f4c <_tx_mutex_priority_change+0x174>)
34195e38:	681b      	ldr	r3, [r3, #0]
34195e3a:	3302      	adds	r3, #2
34195e3c:	4a43      	ldr	r2, [pc, #268]	@ (34195f4c <_tx_mutex_priority_change+0x174>)
34195e3e:	6013      	str	r3, [r2, #0]

        /* Set the state to priority change.  */
        thread_ptr -> tx_thread_state =    TX_PRIORITY_CHANGE;
34195e40:	687b      	ldr	r3, [r7, #4]
34195e42:	220e      	movs	r2, #14
34195e44:	631a      	str	r2, [r3, #48]	@ 0x30

        /* Set the suspending flag. */
        thread_ptr -> tx_thread_suspending =  TX_TRUE;
34195e46:	687b      	ldr	r3, [r7, #4]
34195e48:	2201      	movs	r2, #1
34195e4a:	639a      	str	r2, [r3, #56]	@ 0x38

        /* Setup the timeout period.  */
        thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  ((ULONG) 0);
34195e4c:	687b      	ldr	r3, [r7, #4]
34195e4e:	2200      	movs	r2, #0
34195e50:	64da      	str	r2, [r3, #76]	@ 0x4c
34195e52:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34195e54:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34195e56:	69bb      	ldr	r3, [r7, #24]
34195e58:	f383 8810 	msr	PRIMASK, r3
}
34195e5c:	bf00      	nop
        /* Restore interrupts.  */
        TX_RESTORE

        /* The thread is ready and must first be removed from the list.  Call the
           system suspend function to accomplish this.  */
        _tx_thread_system_suspend(thread_ptr);
34195e5e:	6878      	ldr	r0, [r7, #4]
34195e60:	f001 fe10 	bl	34197a84 <_tx_thread_system_suspend>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34195e64:	f3ef 8310 	mrs	r3, PRIMASK
34195e68:	623b      	str	r3, [r7, #32]
    return(posture);
34195e6a:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
34195e6c:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
34195e6e:	b672      	cpsid	i
    return(int_posture);
34195e70:	69fb      	ldr	r3, [r7, #28]

        /* Disable interrupts.  */
        TX_DISABLE
34195e72:	63fb      	str	r3, [r7, #60]	@ 0x3c

        /* At this point, the preempt disable flag is still set, so we still have
           protection against all preemption.  */

        /* Change thread priority to the new mutex priority-inheritance priority.  */
        thread_ptr -> tx_thread_priority =  new_priority;
34195e74:	687b      	ldr	r3, [r7, #4]
34195e76:	683a      	ldr	r2, [r7, #0]
34195e78:	62da      	str	r2, [r3, #44]	@ 0x2c

        /* Determine how to setup the thread's preemption-threshold.  */
        if (thread_ptr -> tx_thread_user_preempt_threshold < new_priority)
34195e7a:	687b      	ldr	r3, [r7, #4]
34195e7c:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
34195e80:	683a      	ldr	r2, [r7, #0]
34195e82:	429a      	cmp	r2, r3
34195e84:	d905      	bls.n	34195e92 <_tx_mutex_priority_change+0xba>
        {

            /* Change thread preemption-threshold to the user's preemption-threshold.  */
            thread_ptr -> tx_thread_preempt_threshold =  thread_ptr -> tx_thread_user_preempt_threshold;
34195e86:	687b      	ldr	r3, [r7, #4]
34195e88:	f8d3 2098 	ldr.w	r2, [r3, #152]	@ 0x98
34195e8c:	687b      	ldr	r3, [r7, #4]
34195e8e:	63da      	str	r2, [r3, #60]	@ 0x3c
34195e90:	e002      	b.n	34195e98 <_tx_mutex_priority_change+0xc0>
        }
        else
        {

            /* Change the thread preemption-threshold to the new threshold.  */
            thread_ptr -> tx_thread_preempt_threshold =  new_priority;
34195e92:	687b      	ldr	r3, [r7, #4]
34195e94:	683a      	ldr	r2, [r7, #0]
34195e96:	63da      	str	r2, [r3, #60]	@ 0x3c
34195e98:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34195e9a:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34195e9c:	68fb      	ldr	r3, [r7, #12]
34195e9e:	f383 8810 	msr	PRIMASK, r3
}
34195ea2:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Resume the thread with the new priority.  */
        _tx_thread_system_resume(thread_ptr);
34195ea4:	6878      	ldr	r0, [r7, #4]
34195ea6:	f001 fced 	bl	34197884 <_tx_thread_system_resume>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34195eaa:	f3ef 8310 	mrs	r3, PRIMASK
34195eae:	617b      	str	r3, [r7, #20]
    return(posture);
34195eb0:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
34195eb2:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
34195eb4:	b672      	cpsid	i
    return(int_posture);
34195eb6:	693b      	ldr	r3, [r7, #16]
        TX_MUTEX_PRIORITY_CHANGE_EXTENSION

#ifndef TX_NOT_INTERRUPTABLE

        /* Disable interrupts.  */
        TX_DISABLE
34195eb8:	63fb      	str	r3, [r7, #60]	@ 0x3c
#endif

        /* Pickup the next thread to execute.  */
        next_execute_ptr =  _tx_thread_execute_ptr;
34195eba:	4b23      	ldr	r3, [pc, #140]	@ (34195f48 <_tx_mutex_priority_change+0x170>)
34195ebc:	681b      	ldr	r3, [r3, #0]
34195ebe:	633b      	str	r3, [r7, #48]	@ 0x30

        /* Determine if this thread is not the next thread to execute.  */
        if (thread_ptr != next_execute_ptr)
34195ec0:	687a      	ldr	r2, [r7, #4]
34195ec2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34195ec4:	429a      	cmp	r2, r3
34195ec6:	d034      	beq.n	34195f32 <_tx_mutex_priority_change+0x15a>
        {

            /* Make sure the thread is still ready.  */
            if (thread_ptr -> tx_thread_state == TX_READY)
34195ec8:	687b      	ldr	r3, [r7, #4]
34195eca:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34195ecc:	2b00      	cmp	r3, #0
34195ece:	d130      	bne.n	34195f32 <_tx_mutex_priority_change+0x15a>
            {

                /* Now check and see if this thread has an equal or higher priority.  */
                if (thread_ptr -> tx_thread_priority <= next_execute_ptr -> tx_thread_priority)
34195ed0:	687b      	ldr	r3, [r7, #4]
34195ed2:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
34195ed4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34195ed6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34195ed8:	429a      	cmp	r2, r3
34195eda:	d811      	bhi.n	34195f00 <_tx_mutex_priority_change+0x128>
                {

                    /* Now determine if this thread was the previously executing thread.  */
                    if (thread_ptr == execute_ptr)
34195edc:	687a      	ldr	r2, [r7, #4]
34195ede:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34195ee0:	429a      	cmp	r2, r3
34195ee2:	d126      	bne.n	34195f32 <_tx_mutex_priority_change+0x15a>

                        /* Yes, this thread was previously executing before we temporarily suspended and resumed
                           it in order to change the priority. A lower or same priority thread cannot be the next thread
                           to execute in this case since this thread really didn't suspend.  Simply reset the execute
                           pointer to this thread.  */
                        _tx_thread_execute_ptr =  thread_ptr;
34195ee4:	4a18      	ldr	r2, [pc, #96]	@ (34195f48 <_tx_mutex_priority_change+0x170>)
34195ee6:	687b      	ldr	r3, [r7, #4]
34195ee8:	6013      	str	r3, [r2, #0]

                        /* Determine if we moved to a lower priority. If so, move the thread to the front of its priority list.  */
                        if (original_priority < new_priority)
34195eea:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
34195eec:	683b      	ldr	r3, [r7, #0]
34195eee:	429a      	cmp	r2, r3
34195ef0:	d21f      	bcs.n	34195f32 <_tx_mutex_priority_change+0x15a>
                        {

                            /* Ensure that this thread is placed at the front of the priority list.  */
                            _tx_thread_priority_list[thread_ptr -> tx_thread_priority] =  thread_ptr;
34195ef2:	687b      	ldr	r3, [r7, #4]
34195ef4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34195ef6:	4916      	ldr	r1, [pc, #88]	@ (34195f50 <_tx_mutex_priority_change+0x178>)
34195ef8:	687a      	ldr	r2, [r7, #4]
34195efa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
34195efe:	e018      	b.n	34195f32 <_tx_mutex_priority_change+0x15a>
                }
                else
                {

                    /* Now determine if this thread's preemption-threshold needs to be enforced.  */
                    if (thread_ptr -> tx_thread_preempt_threshold < thread_ptr -> tx_thread_priority)
34195f00:	687b      	ldr	r3, [r7, #4]
34195f02:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
34195f04:	687b      	ldr	r3, [r7, #4]
34195f06:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34195f08:	429a      	cmp	r2, r3
34195f0a:	d212      	bcs.n	34195f32 <_tx_mutex_priority_change+0x15a>
                    {

                        /* Yes, preemption-threshold is in force for this thread. */

                        /* Compare the next thread to execute thread's priority against the thread's preemption-threshold.  */
                        if (thread_ptr -> tx_thread_preempt_threshold <= next_execute_ptr -> tx_thread_priority)
34195f0c:	687b      	ldr	r3, [r7, #4]
34195f0e:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
34195f10:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34195f12:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34195f14:	429a      	cmp	r2, r3
34195f16:	d80c      	bhi.n	34195f32 <_tx_mutex_priority_change+0x15a>
                        {

                            /* We must swap execute pointers to enforce the preemption-threshold of a thread coming out of
                               priority inheritance.  */
                            _tx_thread_execute_ptr =  thread_ptr;
34195f18:	4a0b      	ldr	r2, [pc, #44]	@ (34195f48 <_tx_mutex_priority_change+0x170>)
34195f1a:	687b      	ldr	r3, [r7, #4]
34195f1c:	6013      	str	r3, [r2, #0]

                            /* Determine if we moved to a lower priority. If so, move the thread to the front of its priority list.  */
                            if (original_priority < new_priority)
34195f1e:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
34195f20:	683b      	ldr	r3, [r7, #0]
34195f22:	429a      	cmp	r2, r3
34195f24:	d205      	bcs.n	34195f32 <_tx_mutex_priority_change+0x15a>
                            {

                                /* Ensure that this thread is placed at the front of the priority list.  */
                                _tx_thread_priority_list[thread_ptr -> tx_thread_priority] =  thread_ptr;
34195f26:	687b      	ldr	r3, [r7, #4]
34195f28:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34195f2a:	4909      	ldr	r1, [pc, #36]	@ (34195f50 <_tx_mutex_priority_change+0x178>)
34195f2c:	687a      	ldr	r2, [r7, #4]
34195f2e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
34195f32:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34195f34:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34195f36:	68bb      	ldr	r3, [r7, #8]
34195f38:	f383 8810 	msr	PRIMASK, r3
}
34195f3c:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE
#endif
    }
}
34195f3e:	bf00      	nop
34195f40:	3740      	adds	r7, #64	@ 0x40
34195f42:	46bd      	mov	sp, r7
34195f44:	bd80      	pop	{r7, pc}
34195f46:	bf00      	nop
34195f48:	341c2df0 	.word	0x341c2df0
34195f4c:	341c2e84 	.word	0x341c2e84
34195f50:	341c2e04 	.word	0x341c2e04

34195f54 <_tx_mutex_put>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_mutex_put(TX_MUTEX *mutex_ptr)
{
34195f54:	b580      	push	{r7, lr}
34195f56:	b0a6      	sub	sp, #152	@ 0x98
34195f58:	af00      	add	r7, sp, #0
34195f5a:	6078      	str	r0, [r7, #4]
TX_THREAD       *suspended_thread;
UINT            inheritance_priority;


    /* Setup status to indicate the processing is not complete.  */
    status =  TX_NOT_DONE;
34195f5c:	2320      	movs	r3, #32
34195f5e:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34195f62:	f3ef 8310 	mrs	r3, PRIMASK
34195f66:	65fb      	str	r3, [r7, #92]	@ 0x5c
    return(posture);
34195f68:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
    int_posture = __get_interrupt_posture();
34195f6a:	65bb      	str	r3, [r7, #88]	@ 0x58
    __asm__ volatile ("CPSID i" : : : "memory");
34195f6c:	b672      	cpsid	i
    return(int_posture);
34195f6e:	6dbb      	ldr	r3, [r7, #88]	@ 0x58

    /* Disable interrupts to put an instance back to the mutex.  */
    TX_DISABLE
34195f70:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94

    /* Log this kernel call.  */
    TX_EL_MUTEX_PUT_INSERT

    /* Determine if this mutex is owned.  */
    if (mutex_ptr -> tx_mutex_ownership_count != ((UINT) 0))
34195f74:	687b      	ldr	r3, [r7, #4]
34195f76:	689b      	ldr	r3, [r3, #8]
34195f78:	2b00      	cmp	r3, #0
34195f7a:	f000 81ff 	beq.w	3419637c <_tx_mutex_put+0x428>
    {

        /* Pickup the owning thread pointer.  */
        thread_ptr =  mutex_ptr -> tx_mutex_owner;
34195f7e:	687b      	ldr	r3, [r7, #4]
34195f80:	68db      	ldr	r3, [r3, #12]
34195f82:	67fb      	str	r3, [r7, #124]	@ 0x7c

        /* Pickup thread pointer.  */
        TX_THREAD_GET_CURRENT(current_thread)
34195f84:	4ba3      	ldr	r3, [pc, #652]	@ (34196214 <_tx_mutex_put+0x2c0>)
34195f86:	681b      	ldr	r3, [r3, #0]
34195f88:	67bb      	str	r3, [r7, #120]	@ 0x78

        /* Check to see if the mutex is owned by the calling thread.  */
        if (mutex_ptr -> tx_mutex_owner != current_thread)
34195f8a:	687b      	ldr	r3, [r7, #4]
34195f8c:	68db      	ldr	r3, [r3, #12]
34195f8e:	6fba      	ldr	r2, [r7, #120]	@ 0x78
34195f90:	429a      	cmp	r2, r3
34195f92:	d00d      	beq.n	34195fb0 <_tx_mutex_put+0x5c>
        {

            /* Determine if the preempt disable flag is set, indicating that
               the caller is not the application but from ThreadX. In such
               cases, the thread mutex owner does not need to match.  */
            if (_tx_thread_preempt_disable == ((UINT) 0))
34195f94:	4ba0      	ldr	r3, [pc, #640]	@ (34196218 <_tx_mutex_put+0x2c4>)
34195f96:	681b      	ldr	r3, [r3, #0]
34195f98:	2b00      	cmp	r3, #0
34195f9a:	d109      	bne.n	34195fb0 <_tx_mutex_put+0x5c>
34195f9c:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
34195fa0:	657b      	str	r3, [r7, #84]	@ 0x54
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34195fa2:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34195fa4:	f383 8810 	msr	PRIMASK, r3
}
34195fa8:	bf00      	nop

                /* Restore interrupts.  */
                TX_RESTORE

                /* Caller does not own the mutex.  */
                status =  TX_NOT_OWNED;
34195faa:	231e      	movs	r3, #30
34195fac:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
            }
        }

        /* Determine if we should continue.  */
        if (status == TX_NOT_DONE)
34195fb0:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
34195fb4:	2b20      	cmp	r3, #32
34195fb6:	f040 81eb 	bne.w	34196390 <_tx_mutex_put+0x43c>
        {

            /* Decrement the mutex ownership count.  */
            mutex_ptr -> tx_mutex_ownership_count--;
34195fba:	687b      	ldr	r3, [r7, #4]
34195fbc:	689b      	ldr	r3, [r3, #8]
34195fbe:	1e5a      	subs	r2, r3, #1
34195fc0:	687b      	ldr	r3, [r7, #4]
34195fc2:	609a      	str	r2, [r3, #8]

            /* Determine if the mutex is still owned by the current thread.  */
            if (mutex_ptr -> tx_mutex_ownership_count != ((UINT) 0))
34195fc4:	687b      	ldr	r3, [r7, #4]
34195fc6:	689b      	ldr	r3, [r3, #8]
34195fc8:	2b00      	cmp	r3, #0
34195fca:	d00a      	beq.n	34195fe2 <_tx_mutex_put+0x8e>
34195fcc:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
34195fd0:	653b      	str	r3, [r7, #80]	@ 0x50
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34195fd2:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
34195fd4:	f383 8810 	msr	PRIMASK, r3
}
34195fd8:	bf00      	nop

                /* Restore interrupts.  */
                TX_RESTORE

                /* Mutex is still owned, just return successful status.  */
                status =  TX_SUCCESS;
34195fda:	2300      	movs	r3, #0
34195fdc:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
34195fe0:	e1d6      	b.n	34196390 <_tx_mutex_put+0x43c>
            }
            else
            {

                /* Check for a NULL thread pointer, which can only happen during initialization.   */
                if (thread_ptr == TX_NULL)
34195fe2:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
34195fe4:	2b00      	cmp	r3, #0
34195fe6:	d10a      	bne.n	34195ffe <_tx_mutex_put+0xaa>
34195fe8:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
34195fec:	64fb      	str	r3, [r7, #76]	@ 0x4c
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34195fee:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34195ff0:	f383 8810 	msr	PRIMASK, r3
}
34195ff4:	bf00      	nop

                    /* Restore interrupts.  */
                    TX_RESTORE

                    /* Mutex is now available, return successful status.  */
                    status =  TX_SUCCESS;
34195ff6:	2300      	movs	r3, #0
34195ff8:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
34195ffc:	e1c8      	b.n	34196390 <_tx_mutex_put+0x43c>
                    /* The mutex is now available.   */

                    /* Remove this mutex from the owned mutex list.  */

                    /* Decrement the ownership count.  */
                    thread_ptr -> tx_thread_owned_mutex_count--;
34195ffe:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
34196000:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
34196004:	1e5a      	subs	r2, r3, #1
34196006:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
34196008:	f8c3 20a0 	str.w	r2, [r3, #160]	@ 0xa0

                    /* Determine if this mutex was the only one on the list.  */
                    if (thread_ptr -> tx_thread_owned_mutex_count == ((UINT) 0))
3419600c:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
3419600e:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
34196012:	2b00      	cmp	r3, #0
34196014:	d104      	bne.n	34196020 <_tx_mutex_put+0xcc>
                    {

                        /* Yes, the list is empty.  Simply set the head pointer to NULL.  */
                        thread_ptr -> tx_thread_owned_mutex_list =  TX_NULL;
34196016:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
34196018:	2200      	movs	r2, #0
3419601a:	f8c3 20a4 	str.w	r2, [r3, #164]	@ 0xa4
3419601e:	e019      	b.n	34196054 <_tx_mutex_put+0x100>
                    {

                        /* No, there are more mutexes on the list.  */

                        /* Link-up the neighbors.  */
                        next_mutex =                             mutex_ptr -> tx_mutex_owned_next;
34196020:	687b      	ldr	r3, [r7, #4]
34196022:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34196024:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
                        previous_mutex =                         mutex_ptr -> tx_mutex_owned_previous;
34196028:	687b      	ldr	r3, [r7, #4]
3419602a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3419602c:	677b      	str	r3, [r7, #116]	@ 0x74
                        next_mutex -> tx_mutex_owned_previous =  previous_mutex;
3419602e:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
34196032:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
34196034:	631a      	str	r2, [r3, #48]	@ 0x30
                        previous_mutex -> tx_mutex_owned_next =  next_mutex;
34196036:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
34196038:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
3419603c:	62da      	str	r2, [r3, #44]	@ 0x2c

                        /* See if we have to update the created list head pointer.  */
                        if (thread_ptr -> tx_thread_owned_mutex_list == mutex_ptr)
3419603e:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
34196040:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
34196044:	687a      	ldr	r2, [r7, #4]
34196046:	429a      	cmp	r2, r3
34196048:	d104      	bne.n	34196054 <_tx_mutex_put+0x100>
                        {

                            /* Yes, move the head pointer to the next link. */
                            thread_ptr -> tx_thread_owned_mutex_list =  next_mutex;
3419604a:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
3419604c:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
34196050:	f8c3 20a4 	str.w	r2, [r3, #164]	@ 0xa4
                        }
                    }

                    /* Determine if the simple, non-suspension, non-priority inheritance case is present.  */
                    if (mutex_ptr -> tx_mutex_suspension_list == TX_NULL)
34196054:	687b      	ldr	r3, [r7, #4]
34196056:	699b      	ldr	r3, [r3, #24]
34196058:	2b00      	cmp	r3, #0
3419605a:	d110      	bne.n	3419607e <_tx_mutex_put+0x12a>
                    {

                        /* Is this a priority inheritance mutex?  */
                        if (mutex_ptr -> tx_mutex_inherit == TX_FALSE)
3419605c:	687b      	ldr	r3, [r7, #4]
3419605e:	691b      	ldr	r3, [r3, #16]
34196060:	2b00      	cmp	r3, #0
34196062:	d10c      	bne.n	3419607e <_tx_mutex_put+0x12a>
                        {

                            /* Yes, we are done - set the mutex owner to NULL.   */
                            mutex_ptr -> tx_mutex_owner =  TX_NULL;
34196064:	687b      	ldr	r3, [r7, #4]
34196066:	2200      	movs	r2, #0
34196068:	60da      	str	r2, [r3, #12]
3419606a:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
3419606e:	64bb      	str	r3, [r7, #72]	@ 0x48
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34196070:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
34196072:	f383 8810 	msr	PRIMASK, r3
}
34196076:	bf00      	nop

                            /* Restore interrupts.  */
                            TX_RESTORE

                            /* Mutex is now available, return successful status.  */
                            status =  TX_SUCCESS;
34196078:	2300      	movs	r3, #0
3419607a:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
                        }
                    }

                    /* Determine if the processing is complete.  */
                    if (status == TX_NOT_DONE)
3419607e:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
34196082:	2b20      	cmp	r3, #32
34196084:	f040 8184 	bne.w	34196390 <_tx_mutex_put+0x43c>
                    {

                        /* Initialize original owner and thread priority.  */
                        old_owner =      TX_NULL;
34196088:	2300      	movs	r3, #0
3419608a:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
                        old_priority =   thread_ptr -> tx_thread_user_priority;
3419608e:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
34196090:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
34196094:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c

                        /* Does this mutex support priority inheritance?  */
                        if (mutex_ptr -> tx_mutex_inherit == TX_TRUE)
34196098:	687b      	ldr	r3, [r7, #4]
3419609a:	691b      	ldr	r3, [r3, #16]
3419609c:	2b01      	cmp	r3, #1
3419609e:	d155      	bne.n	3419614c <_tx_mutex_put+0x1f8>
                        {

#ifndef TX_NOT_INTERRUPTABLE

                            /* Temporarily disable preemption.  */
                            _tx_thread_preempt_disable++;
341960a0:	4b5d      	ldr	r3, [pc, #372]	@ (34196218 <_tx_mutex_put+0x2c4>)
341960a2:	681b      	ldr	r3, [r3, #0]
341960a4:	3301      	adds	r3, #1
341960a6:	4a5c      	ldr	r2, [pc, #368]	@ (34196218 <_tx_mutex_put+0x2c4>)
341960a8:	6013      	str	r3, [r2, #0]
341960aa:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
341960ae:	647b      	str	r3, [r7, #68]	@ 0x44
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
341960b0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
341960b2:	f383 8810 	msr	PRIMASK, r3
}
341960b6:	bf00      	nop
                            /* Restore interrupts.  */
                            TX_RESTORE
#endif

                            /* Default the inheritance priority to disabled.  */
                            inheritance_priority =  ((UINT) TX_MAX_PRIORITIES);
341960b8:	2320      	movs	r3, #32
341960ba:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80

                            /* Search the owned mutexes for this thread to determine the highest priority for this
                               former mutex owner to return to.  */
                            next_mutex =  thread_ptr -> tx_thread_owned_mutex_list;
341960be:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
341960c0:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
341960c4:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
                            while (next_mutex != TX_NULL)
341960c8:	e01f      	b.n	3419610a <_tx_mutex_put+0x1b6>
                            {

                                /* Does this mutex support priority inheritance?  */
                                if (next_mutex -> tx_mutex_inherit == TX_TRUE)
341960ca:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
341960ce:	691b      	ldr	r3, [r3, #16]
341960d0:	2b01      	cmp	r3, #1
341960d2:	d10b      	bne.n	341960ec <_tx_mutex_put+0x198>
                                {

                                    /* Determine if highest priority field of the mutex is higher than the priority to
                                       restore.  */
                                    if (next_mutex -> tx_mutex_highest_priority_waiting < inheritance_priority)
341960d4:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
341960d8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
341960da:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
341960de:	429a      	cmp	r2, r3
341960e0:	d904      	bls.n	341960ec <_tx_mutex_put+0x198>
                                    {

                                        /* Use this priority to return releasing thread to.  */
                                        inheritance_priority =   next_mutex -> tx_mutex_highest_priority_waiting;
341960e2:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
341960e6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
341960e8:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
                                    }
                                }

                                /* Move mutex pointer to the next mutex in the list.  */
                                next_mutex =  next_mutex -> tx_mutex_owned_next;
341960ec:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
341960f0:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
341960f2:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84

                                /* Are we at the end of the list?  */
                                if (next_mutex == thread_ptr -> tx_thread_owned_mutex_list)
341960f6:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
341960f8:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
341960fc:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
34196100:	429a      	cmp	r2, r3
34196102:	d102      	bne.n	3419610a <_tx_mutex_put+0x1b6>
                                {

                                    /* Yes, set the next mutex to NULL.  */
                                    next_mutex =  TX_NULL;
34196104:	2300      	movs	r3, #0
34196106:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
                            while (next_mutex != TX_NULL)
3419610a:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
3419610e:	2b00      	cmp	r3, #0
34196110:	d1db      	bne.n	341960ca <_tx_mutex_put+0x176>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34196112:	f3ef 8310 	mrs	r3, PRIMASK
34196116:	643b      	str	r3, [r7, #64]	@ 0x40
    return(posture);
34196118:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
    int_posture = __get_interrupt_posture();
3419611a:	63fb      	str	r3, [r7, #60]	@ 0x3c
    __asm__ volatile ("CPSID i" : : : "memory");
3419611c:	b672      	cpsid	i
    return(int_posture);
3419611e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
                            }

#ifndef TX_NOT_INTERRUPTABLE

                            /* Disable interrupts.  */
                            TX_DISABLE
34196120:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94

                            /* Undo the temporarily preemption disable.  */
                            _tx_thread_preempt_disable--;
34196124:	4b3c      	ldr	r3, [pc, #240]	@ (34196218 <_tx_mutex_put+0x2c4>)
34196126:	681b      	ldr	r3, [r3, #0]
34196128:	3b01      	subs	r3, #1
3419612a:	4a3b      	ldr	r2, [pc, #236]	@ (34196218 <_tx_mutex_put+0x2c4>)
3419612c:	6013      	str	r3, [r2, #0]
#endif

                            /* Set the inherit priority to that of the highest priority thread waiting on the mutex.  */
                            thread_ptr -> tx_thread_inherit_priority =  inheritance_priority;
3419612e:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
34196130:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
34196134:	f8c3 209c 	str.w	r2, [r3, #156]	@ 0x9c

                            /* Determine if the inheritance priority is less than the default old priority.  */
                            if (inheritance_priority < old_priority)
34196138:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
3419613c:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
34196140:	429a      	cmp	r2, r3
34196142:	d203      	bcs.n	3419614c <_tx_mutex_put+0x1f8>
                            {

                                /* Yes, update the old priority.  */
                                old_priority =  inheritance_priority;
34196144:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
34196148:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
                            }
                        }

                        /* Determine if priority inheritance is in effect and there are one or more
                           threads suspended on the mutex.  */
                        if (mutex_ptr -> tx_mutex_suspended_count > ((UINT) 1))
3419614c:	687b      	ldr	r3, [r7, #4]
3419614e:	69db      	ldr	r3, [r3, #28]
34196150:	2b01      	cmp	r3, #1
34196152:	d920      	bls.n	34196196 <_tx_mutex_put+0x242>
                        {

                            /* Is priority inheritance in effect?  */
                            if (mutex_ptr -> tx_mutex_inherit == TX_TRUE)
34196154:	687b      	ldr	r3, [r7, #4]
34196156:	691b      	ldr	r3, [r3, #16]
34196158:	2b01      	cmp	r3, #1
3419615a:	d11c      	bne.n	34196196 <_tx_mutex_put+0x242>
                                   at the front of the suspension list.  */

#ifndef TX_NOT_INTERRUPTABLE

                                /* Temporarily disable preemption.  */
                                _tx_thread_preempt_disable++;
3419615c:	4b2e      	ldr	r3, [pc, #184]	@ (34196218 <_tx_mutex_put+0x2c4>)
3419615e:	681b      	ldr	r3, [r3, #0]
34196160:	3301      	adds	r3, #1
34196162:	4a2d      	ldr	r2, [pc, #180]	@ (34196218 <_tx_mutex_put+0x2c4>)
34196164:	6013      	str	r3, [r2, #0]
34196166:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
3419616a:	633b      	str	r3, [r7, #48]	@ 0x30
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
3419616c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3419616e:	f383 8810 	msr	PRIMASK, r3
}
34196172:	bf00      	nop
                                do
                                {
                                    status =  _tx_mutex_prioritize(mutex_ptr);
                                } while (status != TX_SUCCESS);
#else
                                _tx_mutex_prioritize(mutex_ptr);
34196174:	6878      	ldr	r0, [r7, #4]
34196176:	f7ff fd7d 	bl	34195c74 <_tx_mutex_prioritize>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
3419617a:	f3ef 8310 	mrs	r3, PRIMASK
3419617e:	63bb      	str	r3, [r7, #56]	@ 0x38
    return(posture);
34196180:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
    int_posture = __get_interrupt_posture();
34196182:	637b      	str	r3, [r7, #52]	@ 0x34
    __asm__ volatile ("CPSID i" : : : "memory");
34196184:	b672      	cpsid	i
    return(int_posture);
34196186:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
                                TX_MUTEX_PUT_EXTENSION_1

#ifndef TX_NOT_INTERRUPTABLE

                                /* Disable interrupts.  */
                                TX_DISABLE
34196188:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94

                                /* Back off the preemption disable.  */
                                _tx_thread_preempt_disable--;
3419618c:	4b22      	ldr	r3, [pc, #136]	@ (34196218 <_tx_mutex_put+0x2c4>)
3419618e:	681b      	ldr	r3, [r3, #0]
34196190:	3b01      	subs	r3, #1
34196192:	4a21      	ldr	r2, [pc, #132]	@ (34196218 <_tx_mutex_put+0x2c4>)
34196194:	6013      	str	r3, [r2, #0]
#endif
                            }
                        }

                        /* Now determine if there are any threads still waiting on the mutex.  */
                        if (mutex_ptr -> tx_mutex_suspension_list == TX_NULL)
34196196:	687b      	ldr	r3, [r7, #4]
34196198:	699b      	ldr	r3, [r3, #24]
3419619a:	2b00      	cmp	r3, #0
3419619c:	d13e      	bne.n	3419621c <_tx_mutex_put+0x2c8>
                            /* No, there are no longer any threads waiting on the mutex.  */

#ifndef TX_NOT_INTERRUPTABLE

                            /* Temporarily disable preemption.  */
                            _tx_thread_preempt_disable++;
3419619e:	4b1e      	ldr	r3, [pc, #120]	@ (34196218 <_tx_mutex_put+0x2c4>)
341961a0:	681b      	ldr	r3, [r3, #0]
341961a2:	3301      	adds	r3, #1
341961a4:	4a1c      	ldr	r2, [pc, #112]	@ (34196218 <_tx_mutex_put+0x2c4>)
341961a6:	6013      	str	r3, [r2, #0]
341961a8:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
341961ac:	62fb      	str	r3, [r7, #44]	@ 0x2c
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
341961ae:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
341961b0:	f383 8810 	msr	PRIMASK, r3
}
341961b4:	bf00      	nop
                            /* Mutex is not owned, but it is possible that a thread that
                               caused a priority inheritance to occur is no longer waiting
                               on the mutex.  */

                            /* Setup the highest priority waiting thread.  */
                            mutex_ptr -> tx_mutex_highest_priority_waiting =  (UINT) TX_MAX_PRIORITIES;
341961b6:	687b      	ldr	r3, [r7, #4]
341961b8:	2220      	movs	r2, #32
341961ba:	629a      	str	r2, [r3, #40]	@ 0x28

                            /* Determine if we need to restore priority.  */
                            if ((mutex_ptr -> tx_mutex_owner) -> tx_thread_priority != old_priority)
341961bc:	687b      	ldr	r3, [r7, #4]
341961be:	68db      	ldr	r3, [r3, #12]
341961c0:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
341961c2:	f8d7 208c 	ldr.w	r2, [r7, #140]	@ 0x8c
341961c6:	429a      	cmp	r2, r3
341961c8:	d006      	beq.n	341961d8 <_tx_mutex_put+0x284>
                            {

                                /* Yes, restore the priority of thread.  */
                                _tx_mutex_priority_change(mutex_ptr -> tx_mutex_owner, old_priority);
341961ca:	687b      	ldr	r3, [r7, #4]
341961cc:	68db      	ldr	r3, [r3, #12]
341961ce:	f8d7 108c 	ldr.w	r1, [r7, #140]	@ 0x8c
341961d2:	4618      	mov	r0, r3
341961d4:	f7ff fe00 	bl	34195dd8 <_tx_mutex_priority_change>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
341961d8:	f3ef 8310 	mrs	r3, PRIMASK
341961dc:	627b      	str	r3, [r7, #36]	@ 0x24
    return(posture);
341961de:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
    int_posture = __get_interrupt_posture();
341961e0:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("CPSID i" : : : "memory");
341961e2:	b672      	cpsid	i
    return(int_posture);
341961e4:	6a3b      	ldr	r3, [r7, #32]
                            }

#ifndef TX_NOT_INTERRUPTABLE

                            /* Disable interrupts again.  */
                            TX_DISABLE
341961e6:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94

                            /* Back off the preemption disable.  */
                            _tx_thread_preempt_disable--;
341961ea:	4b0b      	ldr	r3, [pc, #44]	@ (34196218 <_tx_mutex_put+0x2c4>)
341961ec:	681b      	ldr	r3, [r3, #0]
341961ee:	3b01      	subs	r3, #1
341961f0:	4a09      	ldr	r2, [pc, #36]	@ (34196218 <_tx_mutex_put+0x2c4>)
341961f2:	6013      	str	r3, [r2, #0]
#endif

                            /* Set the mutex owner to NULL.  */
                            mutex_ptr -> tx_mutex_owner =  TX_NULL;
341961f4:	687b      	ldr	r3, [r7, #4]
341961f6:	2200      	movs	r2, #0
341961f8:	60da      	str	r2, [r3, #12]
341961fa:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
341961fe:	62bb      	str	r3, [r7, #40]	@ 0x28
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34196200:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34196202:	f383 8810 	msr	PRIMASK, r3
}
34196206:	bf00      	nop

                            /* Restore interrupts.  */
                            TX_RESTORE

                            /* Check for preemption.  */
                            _tx_thread_system_preempt_check();
34196208:	f001 fb02 	bl	34197810 <_tx_thread_system_preempt_check>

                            /* Set status to success.  */
                            status =  TX_SUCCESS;
3419620c:	2300      	movs	r3, #0
3419620e:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
34196212:	e0bd      	b.n	34196390 <_tx_mutex_put+0x43c>
34196214:	341c2dec 	.word	0x341c2dec
34196218:	341c2e84 	.word	0x341c2e84
                        }
                        else
                        {

                            /* Pickup the thread at the front of the suspension list.  */
                            thread_ptr =  mutex_ptr -> tx_mutex_suspension_list;
3419621c:	687b      	ldr	r3, [r7, #4]
3419621e:	699b      	ldr	r3, [r3, #24]
34196220:	67fb      	str	r3, [r7, #124]	@ 0x7c

                            /* Save the previous ownership information, if inheritance is
                               in effect.  */
                            if (mutex_ptr -> tx_mutex_inherit == TX_TRUE)
34196222:	687b      	ldr	r3, [r7, #4]
34196224:	691b      	ldr	r3, [r3, #16]
34196226:	2b01      	cmp	r3, #1
34196228:	d10a      	bne.n	34196240 <_tx_mutex_put+0x2ec>
                            {

                                /* Remember the old mutex owner.  */
                                old_owner =  mutex_ptr -> tx_mutex_owner;
3419622a:	687b      	ldr	r3, [r7, #4]
3419622c:	68db      	ldr	r3, [r3, #12]
3419622e:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90

                                /* Setup owner thread priority information.  */
                                mutex_ptr -> tx_mutex_original_priority =   thread_ptr -> tx_thread_priority;
34196232:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
34196234:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
34196236:	687b      	ldr	r3, [r7, #4]
34196238:	615a      	str	r2, [r3, #20]

                                /* Setup the highest priority waiting thread.  */
                                mutex_ptr -> tx_mutex_highest_priority_waiting =  (UINT) TX_MAX_PRIORITIES;
3419623a:	687b      	ldr	r3, [r7, #4]
3419623c:	2220      	movs	r2, #32
3419623e:	629a      	str	r2, [r3, #40]	@ 0x28
                            }

                            /* Determine how many mutexes are owned by this thread.  */
                            owned_count =  thread_ptr -> tx_thread_owned_mutex_count;
34196240:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
34196242:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
34196246:	673b      	str	r3, [r7, #112]	@ 0x70

                            /* Determine if this thread owns any other mutexes that have priority inheritance.  */
                            if (owned_count == ((UINT) 0))
34196248:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
3419624a:	2b00      	cmp	r3, #0
3419624c:	d10a      	bne.n	34196264 <_tx_mutex_put+0x310>
                            {

                                /* The owned mutex list is empty.  Add mutex to empty list.  */
                                thread_ptr -> tx_thread_owned_mutex_list =     mutex_ptr;
3419624e:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
34196250:	687a      	ldr	r2, [r7, #4]
34196252:	f8c3 20a4 	str.w	r2, [r3, #164]	@ 0xa4
                                mutex_ptr -> tx_mutex_owned_next =             mutex_ptr;
34196256:	687b      	ldr	r3, [r7, #4]
34196258:	687a      	ldr	r2, [r7, #4]
3419625a:	62da      	str	r2, [r3, #44]	@ 0x2c
                                mutex_ptr -> tx_mutex_owned_previous =         mutex_ptr;
3419625c:	687b      	ldr	r3, [r7, #4]
3419625e:	687a      	ldr	r2, [r7, #4]
34196260:	631a      	str	r2, [r3, #48]	@ 0x30
34196262:	e016      	b.n	34196292 <_tx_mutex_put+0x33e>
                            {

                                /* Non-empty list. Link up the mutex.  */

                                /* Pickup tail pointer.  */
                                next_mutex =                            thread_ptr -> tx_thread_owned_mutex_list;
34196264:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
34196266:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
3419626a:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
                                previous_mutex =                        next_mutex -> tx_mutex_owned_previous;
3419626e:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
34196272:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34196274:	677b      	str	r3, [r7, #116]	@ 0x74

                                /* Place the owned mutex in the list.  */
                                next_mutex -> tx_mutex_owned_previous =  mutex_ptr;
34196276:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
3419627a:	687a      	ldr	r2, [r7, #4]
3419627c:	631a      	str	r2, [r3, #48]	@ 0x30
                                previous_mutex -> tx_mutex_owned_next =  mutex_ptr;
3419627e:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
34196280:	687a      	ldr	r2, [r7, #4]
34196282:	62da      	str	r2, [r3, #44]	@ 0x2c

                                /* Setup this mutex's next and previous created links.  */
                                mutex_ptr -> tx_mutex_owned_previous =   previous_mutex;
34196284:	687b      	ldr	r3, [r7, #4]
34196286:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
34196288:	631a      	str	r2, [r3, #48]	@ 0x30
                                mutex_ptr -> tx_mutex_owned_next =       next_mutex;
3419628a:	687b      	ldr	r3, [r7, #4]
3419628c:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
34196290:	62da      	str	r2, [r3, #44]	@ 0x2c
                            }

                            /* Increment the number of mutexes owned counter.  */
                            thread_ptr -> tx_thread_owned_mutex_count =  owned_count + ((UINT) 1);
34196292:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
34196294:	1c5a      	adds	r2, r3, #1
34196296:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
34196298:	f8c3 20a0 	str.w	r2, [r3, #160]	@ 0xa0

                            /* Mark the Mutex as owned and fill in the corresponding information.  */
                            mutex_ptr -> tx_mutex_ownership_count =  (UINT) 1;
3419629c:	687b      	ldr	r3, [r7, #4]
3419629e:	2201      	movs	r2, #1
341962a0:	609a      	str	r2, [r3, #8]
                            mutex_ptr -> tx_mutex_owner =            thread_ptr;
341962a2:	687b      	ldr	r3, [r7, #4]
341962a4:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
341962a6:	60da      	str	r2, [r3, #12]

                            /* Remove the suspended thread from the list.  */

                            /* Decrement the suspension count.  */
                            mutex_ptr -> tx_mutex_suspended_count--;
341962a8:	687b      	ldr	r3, [r7, #4]
341962aa:	69db      	ldr	r3, [r3, #28]
341962ac:	1e5a      	subs	r2, r3, #1
341962ae:	687b      	ldr	r3, [r7, #4]
341962b0:	61da      	str	r2, [r3, #28]

                            /* Pickup the suspended count.  */
                            suspended_count =  mutex_ptr -> tx_mutex_suspended_count;
341962b2:	687b      	ldr	r3, [r7, #4]
341962b4:	69db      	ldr	r3, [r3, #28]
341962b6:	66fb      	str	r3, [r7, #108]	@ 0x6c

                            /* See if this is the only suspended thread on the list.  */
                            if (suspended_count == TX_NO_SUSPENSIONS)
341962b8:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
341962ba:	2b00      	cmp	r3, #0
341962bc:	d103      	bne.n	341962c6 <_tx_mutex_put+0x372>
                            {

                                /* Yes, the only suspended thread.  */

                                /* Update the head pointer.  */
                                mutex_ptr -> tx_mutex_suspension_list =  TX_NULL;
341962be:	687b      	ldr	r3, [r7, #4]
341962c0:	2200      	movs	r2, #0
341962c2:	619a      	str	r2, [r3, #24]
341962c4:	e00e      	b.n	341962e4 <_tx_mutex_put+0x390>
                            {

                                /* At least one more thread is on the same expiration list.  */

                                /* Update the list head pointer.  */
                                next_thread =                                  thread_ptr -> tx_thread_suspended_next;
341962c6:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
341962c8:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
341962ca:	66bb      	str	r3, [r7, #104]	@ 0x68
                                mutex_ptr -> tx_mutex_suspension_list =        next_thread;
341962cc:	687b      	ldr	r3, [r7, #4]
341962ce:	6eba      	ldr	r2, [r7, #104]	@ 0x68
341962d0:	619a      	str	r2, [r3, #24]

                                /* Update the links of the adjacent threads.  */
                                previous_thread =                              thread_ptr -> tx_thread_suspended_previous;
341962d2:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
341962d4:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
341962d6:	667b      	str	r3, [r7, #100]	@ 0x64
                                next_thread -> tx_thread_suspended_previous =  previous_thread;
341962d8:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
341962da:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
341962dc:	675a      	str	r2, [r3, #116]	@ 0x74
                                previous_thread -> tx_thread_suspended_next =  next_thread;
341962de:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
341962e0:	6eba      	ldr	r2, [r7, #104]	@ 0x68
341962e2:	671a      	str	r2, [r3, #112]	@ 0x70
                            }

                            /* Prepare for resumption of the first thread.  */

                            /* Clear cleanup routine to avoid timeout.  */
                            thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
341962e4:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
341962e6:	2200      	movs	r2, #0
341962e8:	669a      	str	r2, [r3, #104]	@ 0x68

                            /* Put return status into the thread control block.  */
                            thread_ptr -> tx_thread_suspend_status =  TX_SUCCESS;
341962ea:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
341962ec:	2200      	movs	r2, #0
341962ee:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
                            /* Restore interrupts.  */
                            TX_RESTORE
#else

                            /* Temporarily disable preemption.  */
                            _tx_thread_preempt_disable++;
341962f2:	4b2a      	ldr	r3, [pc, #168]	@ (3419639c <_tx_mutex_put+0x448>)
341962f4:	681b      	ldr	r3, [r3, #0]
341962f6:	3301      	adds	r3, #1
341962f8:	4a28      	ldr	r2, [pc, #160]	@ (3419639c <_tx_mutex_put+0x448>)
341962fa:	6013      	str	r3, [r2, #0]
341962fc:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
34196300:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34196302:	69fb      	ldr	r3, [r7, #28]
34196304:	f383 8810 	msr	PRIMASK, r3
}
34196308:	bf00      	nop

                            /* Restore interrupts.  */
                            TX_RESTORE

                            /* Determine if priority inheritance is enabled for this mutex.  */
                            if (mutex_ptr -> tx_mutex_inherit == TX_TRUE)
3419630a:	687b      	ldr	r3, [r7, #4]
3419630c:	691b      	ldr	r3, [r3, #16]
3419630e:	2b01      	cmp	r3, #1
34196310:	d12d      	bne.n	3419636e <_tx_mutex_put+0x41a>
                            {

                                /* Yes, priority inheritance is requested.  */

                                /* Determine if there are any more threads still suspended on the mutex.  */
                                if (mutex_ptr -> tx_mutex_suspended_count != TX_NO_SUSPENSIONS)
34196312:	687b      	ldr	r3, [r7, #4]
34196314:	69db      	ldr	r3, [r3, #28]
34196316:	2b00      	cmp	r3, #0
34196318:	d01c      	beq.n	34196354 <_tx_mutex_put+0x400>
                                    do
                                    {
                                        status =  _tx_mutex_prioritize(mutex_ptr);
                                    } while (status != TX_SUCCESS);
#else
                                    _tx_mutex_prioritize(mutex_ptr);
3419631a:	6878      	ldr	r0, [r7, #4]
3419631c:	f7ff fcaa 	bl	34195c74 <_tx_mutex_prioritize>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34196320:	f3ef 8310 	mrs	r3, PRIMASK
34196324:	61bb      	str	r3, [r7, #24]
    return(posture);
34196326:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
34196328:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
3419632a:	b672      	cpsid	i
    return(int_posture);
3419632c:	697b      	ldr	r3, [r7, #20]

                                    /* Optional processing extension.  */
                                    TX_MUTEX_PUT_EXTENSION_2

                                    /* Disable interrupts.  */
                                    TX_DISABLE
3419632e:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94

                                    /* Determine if there still are threads suspended for this mutex.  */
                                    suspended_thread =  mutex_ptr -> tx_mutex_suspension_list;
34196332:	687b      	ldr	r3, [r7, #4]
34196334:	699b      	ldr	r3, [r3, #24]
34196336:	663b      	str	r3, [r7, #96]	@ 0x60
                                    if (suspended_thread != TX_NULL)
34196338:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3419633a:	2b00      	cmp	r3, #0
3419633c:	d003      	beq.n	34196346 <_tx_mutex_put+0x3f2>
                                    {

                                        /* Setup the highest priority thread waiting on this mutex.  */
                                        mutex_ptr -> tx_mutex_highest_priority_waiting =  suspended_thread -> tx_thread_priority;
3419633e:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
34196340:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
34196342:	687b      	ldr	r3, [r7, #4]
34196344:	629a      	str	r2, [r3, #40]	@ 0x28
34196346:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
3419634a:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
3419634c:	693b      	ldr	r3, [r7, #16]
3419634e:	f383 8810 	msr	PRIMASK, r3
}
34196352:	bf00      	nop

                                /* Restore previous priority needs to be restored after priority
                                   inheritance.  */

                                /* Is the priority different?  */
                                if (old_owner -> tx_thread_priority != old_priority)
34196354:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
34196358:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3419635a:	f8d7 208c 	ldr.w	r2, [r7, #140]	@ 0x8c
3419635e:	429a      	cmp	r2, r3
34196360:	d005      	beq.n	3419636e <_tx_mutex_put+0x41a>
                                {

                                    /* Restore the priority of thread.  */
                                    _tx_mutex_priority_change(old_owner, old_priority);
34196362:	f8d7 108c 	ldr.w	r1, [r7, #140]	@ 0x8c
34196366:	f8d7 0090 	ldr.w	r0, [r7, #144]	@ 0x90
3419636a:	f7ff fd35 	bl	34195dd8 <_tx_mutex_priority_change>
                                }
                            }

                            /* Resume thread.  */
                            _tx_thread_system_resume(thread_ptr);
3419636e:	6ff8      	ldr	r0, [r7, #124]	@ 0x7c
34196370:	f001 fa88 	bl	34197884 <_tx_thread_system_resume>
#endif

                            /* Return a successful status.  */
                            status =  TX_SUCCESS;
34196374:	2300      	movs	r3, #0
34196376:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
3419637a:	e009      	b.n	34196390 <_tx_mutex_put+0x43c>
3419637c:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
34196380:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34196382:	68fb      	ldr	r3, [r7, #12]
34196384:	f383 8810 	msr	PRIMASK, r3
}
34196388:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Caller does not own the mutex.  */
        status =  TX_NOT_OWNED;
3419638a:	231e      	movs	r3, #30
3419638c:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
    }

    /* Return the completion status.  */
    return(status);
34196390:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
}
34196394:	4618      	mov	r0, r3
34196396:	3798      	adds	r7, #152	@ 0x98
34196398:	46bd      	mov	sp, r7
3419639a:	bd80      	pop	{r7, pc}
3419639c:	341c2e84 	.word	0x341c2e84

341963a0 <_tx_queue_cleanup>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_queue_cleanup(TX_THREAD  *thread_ptr, ULONG suspension_sequence)
{
341963a0:	b580      	push	{r7, lr}
341963a2:	b08e      	sub	sp, #56	@ 0x38
341963a4:	af00      	add	r7, sp, #0
341963a6:	6078      	str	r0, [r7, #4]
341963a8:	6039      	str	r1, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
341963aa:	f3ef 8310 	mrs	r3, PRIMASK
341963ae:	623b      	str	r3, [r7, #32]
    return(posture);
341963b0:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
341963b2:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
341963b4:	b672      	cpsid	i
    return(int_posture);
341963b6:	69fb      	ldr	r3, [r7, #28]


#ifndef TX_NOT_INTERRUPTABLE

    /* Disable interrupts to remove the suspended thread from the queue.  */
    TX_DISABLE
341963b8:	637b      	str	r3, [r7, #52]	@ 0x34

    /* Determine if the cleanup is still required.  */
    if (thread_ptr -> tx_thread_suspend_cleanup == &(_tx_queue_cleanup))
341963ba:	687b      	ldr	r3, [r7, #4]
341963bc:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
341963be:	4a37      	ldr	r2, [pc, #220]	@ (3419649c <_tx_queue_cleanup+0xfc>)
341963c0:	4293      	cmp	r3, r2
341963c2:	d161      	bne.n	34196488 <_tx_queue_cleanup+0xe8>
    {

        /* Check for valid suspension sequence.  */
        if (suspension_sequence == thread_ptr -> tx_thread_suspension_sequence)
341963c4:	687b      	ldr	r3, [r7, #4]
341963c6:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
341963ca:	683a      	ldr	r2, [r7, #0]
341963cc:	429a      	cmp	r2, r3
341963ce:	d15b      	bne.n	34196488 <_tx_queue_cleanup+0xe8>
        {

            /* Setup pointer to queue control block.  */
            queue_ptr =  TX_VOID_TO_QUEUE_POINTER_CONVERT(thread_ptr -> tx_thread_suspend_control_block);
341963d0:	687b      	ldr	r3, [r7, #4]
341963d2:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
341963d4:	633b      	str	r3, [r7, #48]	@ 0x30

            /* Check for NULL queue pointer.  */
            if (queue_ptr != TX_NULL)
341963d6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
341963d8:	2b00      	cmp	r3, #0
341963da:	d055      	beq.n	34196488 <_tx_queue_cleanup+0xe8>
            {

                /* Is the queue ID valid?  */
                if (queue_ptr -> tx_queue_id == TX_QUEUE_ID)
341963dc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
341963de:	681b      	ldr	r3, [r3, #0]
341963e0:	4a2f      	ldr	r2, [pc, #188]	@ (341964a0 <_tx_queue_cleanup+0x100>)
341963e2:	4293      	cmp	r3, r2
341963e4:	d150      	bne.n	34196488 <_tx_queue_cleanup+0xe8>
                {

                    /* Determine if there are any thread suspensions.  */
                    if (queue_ptr -> tx_queue_suspended_count != TX_NO_SUSPENSIONS)
341963e6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
341963e8:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
341963ea:	2b00      	cmp	r3, #0
341963ec:	d04c      	beq.n	34196488 <_tx_queue_cleanup+0xe8>
#endif

                        /* Yes, we still have thread suspension!  */

                        /* Clear the suspension cleanup flag.  */
                        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
341963ee:	687b      	ldr	r3, [r7, #4]
341963f0:	2200      	movs	r2, #0
341963f2:	669a      	str	r2, [r3, #104]	@ 0x68

                        /* Decrement the suspended count.  */
                        queue_ptr -> tx_queue_suspended_count--;
341963f4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
341963f6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
341963f8:	1e5a      	subs	r2, r3, #1
341963fa:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
341963fc:	62da      	str	r2, [r3, #44]	@ 0x2c

                        /* Pickup the suspended count.  */
                        suspended_count =  queue_ptr -> tx_queue_suspended_count;
341963fe:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34196400:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34196402:	62fb      	str	r3, [r7, #44]	@ 0x2c

                        /* Remove the suspended thread from the list.  */

                        /* See if this is the only suspended thread on the list.  */
                        if (suspended_count == TX_NO_SUSPENSIONS)
34196404:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34196406:	2b00      	cmp	r3, #0
34196408:	d103      	bne.n	34196412 <_tx_queue_cleanup+0x72>
                        {

                            /* Yes, the only suspended thread.  */

                            /* Update the head pointer.  */
                            queue_ptr -> tx_queue_suspension_list =  TX_NULL;
3419640a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3419640c:	2200      	movs	r2, #0
3419640e:	629a      	str	r2, [r3, #40]	@ 0x28
34196410:	e013      	b.n	3419643a <_tx_queue_cleanup+0x9a>
                        {

                            /* At least one more thread is on the same suspension list.  */

                            /* Update the links of the adjacent threads.  */
                            next_thread =                                   thread_ptr -> tx_thread_suspended_next;
34196412:	687b      	ldr	r3, [r7, #4]
34196414:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34196416:	62bb      	str	r3, [r7, #40]	@ 0x28
                            previous_thread =                               thread_ptr -> tx_thread_suspended_previous;
34196418:	687b      	ldr	r3, [r7, #4]
3419641a:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3419641c:	627b      	str	r3, [r7, #36]	@ 0x24
                            next_thread -> tx_thread_suspended_previous =   previous_thread;
3419641e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34196420:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
34196422:	675a      	str	r2, [r3, #116]	@ 0x74
                            previous_thread -> tx_thread_suspended_next =   next_thread;
34196424:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34196426:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34196428:	671a      	str	r2, [r3, #112]	@ 0x70

                            /* Determine if we need to update the head pointer.  */
                            if (queue_ptr -> tx_queue_suspension_list == thread_ptr)
3419642a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3419642c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3419642e:	687a      	ldr	r2, [r7, #4]
34196430:	429a      	cmp	r2, r3
34196432:	d102      	bne.n	3419643a <_tx_queue_cleanup+0x9a>
                            {

                                /* Update the list head pointer.  */
                                queue_ptr -> tx_queue_suspension_list =         next_thread;
34196434:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34196436:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34196438:	629a      	str	r2, [r3, #40]	@ 0x28
                            }
                        }

                        /* Now we need to determine if this cleanup is from a terminate, timeout,
                           or from a wait abort.  */
                        if (thread_ptr -> tx_thread_state == TX_QUEUE_SUSP)
3419643a:	687b      	ldr	r3, [r7, #4]
3419643c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3419643e:	2b05      	cmp	r3, #5
34196440:	d122      	bne.n	34196488 <_tx_queue_cleanup+0xe8>
                            /* Increment the number of timeouts on this queue.  */
                            queue_ptr -> tx_queue_performance_timeout_count++;
#endif

                            /* Setup return status.  */
                            if (queue_ptr -> tx_queue_enqueued != TX_NO_MESSAGES)
34196442:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34196444:	691b      	ldr	r3, [r3, #16]
34196446:	2b00      	cmp	r3, #0
34196448:	d004      	beq.n	34196454 <_tx_queue_cleanup+0xb4>
                            {

                                /* Queue full timeout!  */
                                thread_ptr -> tx_thread_suspend_status =  TX_QUEUE_FULL;
3419644a:	687b      	ldr	r3, [r7, #4]
3419644c:	220b      	movs	r2, #11
3419644e:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
34196452:	e003      	b.n	3419645c <_tx_queue_cleanup+0xbc>
                            }
                            else
                            {

                                /* Queue empty timeout!  */
                                thread_ptr -> tx_thread_suspend_status =  TX_QUEUE_EMPTY;
34196454:	687b      	ldr	r3, [r7, #4]
34196456:	220a      	movs	r2, #10
34196458:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
                            /* Resume the thread!  */
                            _tx_thread_system_ni_resume(thread_ptr);
#else

                            /* Temporarily disable preemption.  */
                            _tx_thread_preempt_disable++;
3419645c:	4b11      	ldr	r3, [pc, #68]	@ (341964a4 <_tx_queue_cleanup+0x104>)
3419645e:	681b      	ldr	r3, [r3, #0]
34196460:	3301      	adds	r3, #1
34196462:	4a10      	ldr	r2, [pc, #64]	@ (341964a4 <_tx_queue_cleanup+0x104>)
34196464:	6013      	str	r3, [r2, #0]
34196466:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34196468:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
3419646a:	693b      	ldr	r3, [r7, #16]
3419646c:	f383 8810 	msr	PRIMASK, r3
}
34196470:	bf00      	nop

                            /* Restore interrupts.  */
                            TX_RESTORE

                            /* Resume the thread!  */
                            _tx_thread_system_resume(thread_ptr);
34196472:	6878      	ldr	r0, [r7, #4]
34196474:	f001 fa06 	bl	34197884 <_tx_thread_system_resume>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34196478:	f3ef 8310 	mrs	r3, PRIMASK
3419647c:	61bb      	str	r3, [r7, #24]
    return(posture);
3419647e:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
34196480:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
34196482:	b672      	cpsid	i
    return(int_posture);
34196484:	697b      	ldr	r3, [r7, #20]

                            /* Disable interrupts.  */
                            TX_DISABLE
34196486:	637b      	str	r3, [r7, #52]	@ 0x34
34196488:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
3419648a:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
3419648c:	68fb      	ldr	r3, [r7, #12]
3419648e:	f383 8810 	msr	PRIMASK, r3
}
34196492:	bf00      	nop
    }

    /* Restore interrupts.  */
    TX_RESTORE
#endif
}
34196494:	bf00      	nop
34196496:	3738      	adds	r7, #56	@ 0x38
34196498:	46bd      	mov	sp, r7
3419649a:	bd80      	pop	{r7, pc}
3419649c:	341963a1 	.word	0x341963a1
341964a0:	51554555 	.word	0x51554555
341964a4:	341c2e84 	.word	0x341c2e84

341964a8 <_tx_queue_create>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_queue_create(TX_QUEUE *queue_ptr, CHAR *name_ptr, UINT message_size,
                        VOID *queue_start, ULONG queue_size)
{
341964a8:	b580      	push	{r7, lr}
341964aa:	b08c      	sub	sp, #48	@ 0x30
341964ac:	af00      	add	r7, sp, #0
341964ae:	60f8      	str	r0, [r7, #12]
341964b0:	60b9      	str	r1, [r7, #8]
341964b2:	607a      	str	r2, [r7, #4]
341964b4:	603b      	str	r3, [r7, #0]
TX_QUEUE        *next_queue;
TX_QUEUE        *previous_queue;


    /* Initialize queue control block to all zeros.  */
    TX_MEMSET(queue_ptr, 0, (sizeof(TX_QUEUE)));
341964b6:	2238      	movs	r2, #56	@ 0x38
341964b8:	2100      	movs	r1, #0
341964ba:	68f8      	ldr	r0, [r7, #12]
341964bc:	f007 fe00 	bl	3419e0c0 <memset>

    /* Setup the basic queue fields.  */
    queue_ptr -> tx_queue_name =             name_ptr;
341964c0:	68fb      	ldr	r3, [r7, #12]
341964c2:	68ba      	ldr	r2, [r7, #8]
341964c4:	605a      	str	r2, [r3, #4]

    /* Save the message size in the control block.  */
    queue_ptr -> tx_queue_message_size =  message_size;
341964c6:	68fb      	ldr	r3, [r7, #12]
341964c8:	687a      	ldr	r2, [r7, #4]
341964ca:	609a      	str	r2, [r3, #8]

    /* Determine how many messages will fit in the queue area and the number
       of ULONGs used.  */
    capacity =    (UINT) (queue_size / ((ULONG) (((ULONG) message_size) * (sizeof(ULONG)))));
341964cc:	687b      	ldr	r3, [r7, #4]
341964ce:	009b      	lsls	r3, r3, #2
341964d0:	6bba      	ldr	r2, [r7, #56]	@ 0x38
341964d2:	fbb2 f3f3 	udiv	r3, r2, r3
341964d6:	62fb      	str	r3, [r7, #44]	@ 0x2c
    used_words =  capacity * message_size;
341964d8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
341964da:	687a      	ldr	r2, [r7, #4]
341964dc:	fb02 f303 	mul.w	r3, r2, r3
341964e0:	62bb      	str	r3, [r7, #40]	@ 0x28

    /* Save the starting address and calculate the ending address of
       the queue.  Note that the ending address is really one past the
       end!  */
    queue_ptr -> tx_queue_start =  TX_VOID_TO_ULONG_POINTER_CONVERT(queue_start);
341964e2:	68fb      	ldr	r3, [r7, #12]
341964e4:	683a      	ldr	r2, [r7, #0]
341964e6:	619a      	str	r2, [r3, #24]
    queue_ptr -> tx_queue_end =    TX_ULONG_POINTER_ADD(queue_ptr -> tx_queue_start, used_words);
341964e8:	68fb      	ldr	r3, [r7, #12]
341964ea:	699a      	ldr	r2, [r3, #24]
341964ec:	6abb      	ldr	r3, [r7, #40]	@ 0x28
341964ee:	009b      	lsls	r3, r3, #2
341964f0:	441a      	add	r2, r3
341964f2:	68fb      	ldr	r3, [r7, #12]
341964f4:	61da      	str	r2, [r3, #28]

    /* Set the read and write pointers to the beginning of the queue
       area.  */
    queue_ptr -> tx_queue_read =   TX_VOID_TO_ULONG_POINTER_CONVERT(queue_start);
341964f6:	68fb      	ldr	r3, [r7, #12]
341964f8:	683a      	ldr	r2, [r7, #0]
341964fa:	621a      	str	r2, [r3, #32]
    queue_ptr -> tx_queue_write =  TX_VOID_TO_ULONG_POINTER_CONVERT(queue_start);
341964fc:	68fb      	ldr	r3, [r7, #12]
341964fe:	683a      	ldr	r2, [r7, #0]
34196500:	625a      	str	r2, [r3, #36]	@ 0x24

    /* Setup the number of enqueued messages and the number of message
       slots available in the queue.  */
    queue_ptr -> tx_queue_available_storage =  (UINT) capacity;
34196502:	68fb      	ldr	r3, [r7, #12]
34196504:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
34196506:	615a      	str	r2, [r3, #20]
    queue_ptr -> tx_queue_capacity =           (UINT) capacity;
34196508:	68fb      	ldr	r3, [r7, #12]
3419650a:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
3419650c:	60da      	str	r2, [r3, #12]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
3419650e:	f3ef 8310 	mrs	r3, PRIMASK
34196512:	61bb      	str	r3, [r7, #24]
    return(posture);
34196514:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
34196516:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
34196518:	b672      	cpsid	i
    return(int_posture);
3419651a:	697b      	ldr	r3, [r7, #20]

    /* Disable interrupts to put the queue on the created list.  */
    TX_DISABLE
3419651c:	627b      	str	r3, [r7, #36]	@ 0x24

    /* Setup the queue ID to make it valid.  */
    queue_ptr -> tx_queue_id =  TX_QUEUE_ID;
3419651e:	68fb      	ldr	r3, [r7, #12]
34196520:	4a18      	ldr	r2, [pc, #96]	@ (34196584 <_tx_queue_create+0xdc>)
34196522:	601a      	str	r2, [r3, #0]

    /* Place the queue on the list of created queues.  First,
       check for an empty list.  */
    if (_tx_queue_created_count == TX_EMPTY)
34196524:	4b18      	ldr	r3, [pc, #96]	@ (34196588 <_tx_queue_create+0xe0>)
34196526:	681b      	ldr	r3, [r3, #0]
34196528:	2b00      	cmp	r3, #0
3419652a:	d109      	bne.n	34196540 <_tx_queue_create+0x98>
    {

        /* The created queue list is empty.  Add queue to empty list.  */
        _tx_queue_created_ptr =                   queue_ptr;
3419652c:	4a17      	ldr	r2, [pc, #92]	@ (3419658c <_tx_queue_create+0xe4>)
3419652e:	68fb      	ldr	r3, [r7, #12]
34196530:	6013      	str	r3, [r2, #0]
        queue_ptr -> tx_queue_created_next =      queue_ptr;
34196532:	68fb      	ldr	r3, [r7, #12]
34196534:	68fa      	ldr	r2, [r7, #12]
34196536:	631a      	str	r2, [r3, #48]	@ 0x30
        queue_ptr -> tx_queue_created_previous =  queue_ptr;
34196538:	68fb      	ldr	r3, [r7, #12]
3419653a:	68fa      	ldr	r2, [r7, #12]
3419653c:	635a      	str	r2, [r3, #52]	@ 0x34
3419653e:	e011      	b.n	34196564 <_tx_queue_create+0xbc>
    }
    else
    {

        /* This list is not NULL, add to the end of the list.  */
        next_queue =      _tx_queue_created_ptr;
34196540:	4b12      	ldr	r3, [pc, #72]	@ (3419658c <_tx_queue_create+0xe4>)
34196542:	681b      	ldr	r3, [r3, #0]
34196544:	623b      	str	r3, [r7, #32]
        previous_queue =  next_queue -> tx_queue_created_previous;
34196546:	6a3b      	ldr	r3, [r7, #32]
34196548:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3419654a:	61fb      	str	r3, [r7, #28]

        /* Place the new queue in the list.  */
        next_queue -> tx_queue_created_previous =  queue_ptr;
3419654c:	6a3b      	ldr	r3, [r7, #32]
3419654e:	68fa      	ldr	r2, [r7, #12]
34196550:	635a      	str	r2, [r3, #52]	@ 0x34
        previous_queue -> tx_queue_created_next =  queue_ptr;
34196552:	69fb      	ldr	r3, [r7, #28]
34196554:	68fa      	ldr	r2, [r7, #12]
34196556:	631a      	str	r2, [r3, #48]	@ 0x30

        /* Setup this queues's created links.  */
        queue_ptr -> tx_queue_created_previous =  previous_queue;
34196558:	68fb      	ldr	r3, [r7, #12]
3419655a:	69fa      	ldr	r2, [r7, #28]
3419655c:	635a      	str	r2, [r3, #52]	@ 0x34
        queue_ptr -> tx_queue_created_next =      next_queue;
3419655e:	68fb      	ldr	r3, [r7, #12]
34196560:	6a3a      	ldr	r2, [r7, #32]
34196562:	631a      	str	r2, [r3, #48]	@ 0x30
    }

    /* Increment the created queue count.  */
    _tx_queue_created_count++;
34196564:	4b08      	ldr	r3, [pc, #32]	@ (34196588 <_tx_queue_create+0xe0>)
34196566:	681b      	ldr	r3, [r3, #0]
34196568:	3301      	adds	r3, #1
3419656a:	4a07      	ldr	r2, [pc, #28]	@ (34196588 <_tx_queue_create+0xe0>)
3419656c:	6013      	str	r3, [r2, #0]
3419656e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34196570:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34196572:	693b      	ldr	r3, [r7, #16]
34196574:	f383 8810 	msr	PRIMASK, r3
}
34196578:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
3419657a:	2300      	movs	r3, #0
}
3419657c:	4618      	mov	r0, r3
3419657e:	3730      	adds	r7, #48	@ 0x30
34196580:	46bd      	mov	sp, r7
34196582:	bd80      	pop	{r7, pc}
34196584:	51554555 	.word	0x51554555
34196588:	341c2dc0 	.word	0x341c2dc0
3419658c:	341c2dbc 	.word	0x341c2dbc

34196590 <_tx_queue_receive>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_queue_receive(TX_QUEUE *queue_ptr, VOID *destination_ptr, ULONG wait_option)
{
34196590:	b580      	push	{r7, lr}
34196592:	b096      	sub	sp, #88	@ 0x58
34196594:	af00      	add	r7, sp, #0
34196596:	60f8      	str	r0, [r7, #12]
34196598:	60b9      	str	r1, [r7, #8]
3419659a:	607a      	str	r2, [r7, #4]
TX_THREAD       *previous_thread;
UINT            status;


    /* Default the status to TX_SUCCESS.  */
    status =  TX_SUCCESS;
3419659c:	2300      	movs	r3, #0
3419659e:	64bb      	str	r3, [r7, #72]	@ 0x48
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
341965a0:	f3ef 8310 	mrs	r3, PRIMASK
341965a4:	633b      	str	r3, [r7, #48]	@ 0x30
    return(posture);
341965a6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    int_posture = __get_interrupt_posture();
341965a8:	62fb      	str	r3, [r7, #44]	@ 0x2c
    __asm__ volatile ("CPSID i" : : : "memory");
341965aa:	b672      	cpsid	i
    return(int_posture);
341965ac:	6afb      	ldr	r3, [r7, #44]	@ 0x2c

    /* Disable interrupts to receive message from queue.  */
    TX_DISABLE
341965ae:	647b      	str	r3, [r7, #68]	@ 0x44

    /* Log this kernel call.  */
    TX_EL_QUEUE_RECEIVE_INSERT

    /* Pickup the thread suspension count.  */
    suspended_count =  queue_ptr -> tx_queue_suspended_count;
341965b0:	68fb      	ldr	r3, [r7, #12]
341965b2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
341965b4:	643b      	str	r3, [r7, #64]	@ 0x40

    /* Determine if there is anything in the queue.  */
    if (queue_ptr -> tx_queue_enqueued != TX_NO_MESSAGES)
341965b6:	68fb      	ldr	r3, [r7, #12]
341965b8:	691b      	ldr	r3, [r3, #16]
341965ba:	2b00      	cmp	r3, #0
341965bc:	f000 8136 	beq.w	3419682c <_tx_queue_receive+0x29c>
    {

        /* Determine if there are any suspensions.  */
        if (suspended_count == TX_NO_SUSPENSIONS)
341965c0:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
341965c2:	2b00      	cmp	r3, #0
341965c4:	d13c      	bne.n	34196640 <_tx_queue_receive+0xb0>
        {

            /* There is a message waiting in the queue and there are no suspensi.  */

            /* Setup source and destination pointers.  */
            source =       queue_ptr -> tx_queue_read;
341965c6:	68fb      	ldr	r3, [r7, #12]
341965c8:	6a1b      	ldr	r3, [r3, #32]
341965ca:	657b      	str	r3, [r7, #84]	@ 0x54
            destination =  TX_VOID_TO_ULONG_POINTER_CONVERT(destination_ptr);
341965cc:	68bb      	ldr	r3, [r7, #8]
341965ce:	653b      	str	r3, [r7, #80]	@ 0x50
            size =         queue_ptr -> tx_queue_message_size;
341965d0:	68fb      	ldr	r3, [r7, #12]
341965d2:	689b      	ldr	r3, [r3, #8]
341965d4:	64fb      	str	r3, [r7, #76]	@ 0x4c

            /* Copy message. Note that the source and destination pointers are
               incremented by the macro.  */
            TX_QUEUE_MESSAGE_COPY(source, destination, size)
341965d6:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
341965d8:	1d13      	adds	r3, r2, #4
341965da:	657b      	str	r3, [r7, #84]	@ 0x54
341965dc:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
341965de:	1d19      	adds	r1, r3, #4
341965e0:	6539      	str	r1, [r7, #80]	@ 0x50
341965e2:	6812      	ldr	r2, [r2, #0]
341965e4:	601a      	str	r2, [r3, #0]
341965e6:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
341965e8:	2b01      	cmp	r3, #1
341965ea:	d90e      	bls.n	3419660a <_tx_queue_receive+0x7a>
341965ec:	e007      	b.n	341965fe <_tx_queue_receive+0x6e>
341965ee:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
341965f0:	1d13      	adds	r3, r2, #4
341965f2:	657b      	str	r3, [r7, #84]	@ 0x54
341965f4:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
341965f6:	1d19      	adds	r1, r3, #4
341965f8:	6539      	str	r1, [r7, #80]	@ 0x50
341965fa:	6812      	ldr	r2, [r2, #0]
341965fc:	601a      	str	r2, [r3, #0]
341965fe:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34196600:	3b01      	subs	r3, #1
34196602:	64fb      	str	r3, [r7, #76]	@ 0x4c
34196604:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34196606:	2b00      	cmp	r3, #0
34196608:	d1f1      	bne.n	341965ee <_tx_queue_receive+0x5e>

            /* Determine if we are at the end.  */
            if (source == queue_ptr -> tx_queue_end)
3419660a:	68fb      	ldr	r3, [r7, #12]
3419660c:	69db      	ldr	r3, [r3, #28]
3419660e:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
34196610:	429a      	cmp	r2, r3
34196612:	d102      	bne.n	3419661a <_tx_queue_receive+0x8a>
            {

                /* Yes, wrap around to the beginning.  */
                source =  queue_ptr -> tx_queue_start;
34196614:	68fb      	ldr	r3, [r7, #12]
34196616:	699b      	ldr	r3, [r3, #24]
34196618:	657b      	str	r3, [r7, #84]	@ 0x54
            }

            /* Setup the queue read pointer.   */
            queue_ptr -> tx_queue_read =  source;
3419661a:	68fb      	ldr	r3, [r7, #12]
3419661c:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
3419661e:	621a      	str	r2, [r3, #32]

            /* Increase the amount of available storage.  */
            queue_ptr -> tx_queue_available_storage++;
34196620:	68fb      	ldr	r3, [r7, #12]
34196622:	695b      	ldr	r3, [r3, #20]
34196624:	1c5a      	adds	r2, r3, #1
34196626:	68fb      	ldr	r3, [r7, #12]
34196628:	615a      	str	r2, [r3, #20]

            /* Decrease the enqueued count.  */
            queue_ptr -> tx_queue_enqueued--;
3419662a:	68fb      	ldr	r3, [r7, #12]
3419662c:	691b      	ldr	r3, [r3, #16]
3419662e:	1e5a      	subs	r2, r3, #1
34196630:	68fb      	ldr	r3, [r7, #12]
34196632:	611a      	str	r2, [r3, #16]
34196634:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34196636:	62bb      	str	r3, [r7, #40]	@ 0x28
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34196638:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419663a:	f383 8810 	msr	PRIMASK, r3
}
3419663e:	e163      	b.n	34196908 <_tx_queue_receive+0x378>
        {

            /* At this point we know the queue is full.  */

            /* Pickup thread suspension list head pointer.  */
            thread_ptr =  queue_ptr -> tx_queue_suspension_list;
34196640:	68fb      	ldr	r3, [r7, #12]
34196642:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34196644:	63fb      	str	r3, [r7, #60]	@ 0x3c

            /* Now determine if there is a queue front suspension active.   */

            /* Is the front suspension flag set?  */
            if (thread_ptr -> tx_thread_suspend_option == TX_TRUE)
34196646:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34196648:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3419664c:	2b01      	cmp	r3, #1
3419664e:	d153      	bne.n	341966f8 <_tx_queue_receive+0x168>
                /* Yes, a queue front suspension is present.  */

                /* Return the message associated with this suspension.  */

                /* Setup source and destination pointers.  */
                source =       TX_VOID_TO_ULONG_POINTER_CONVERT(thread_ptr -> tx_thread_additional_suspend_info);
34196650:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34196652:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34196654:	657b      	str	r3, [r7, #84]	@ 0x54
                destination =  TX_VOID_TO_ULONG_POINTER_CONVERT(destination_ptr);
34196656:	68bb      	ldr	r3, [r7, #8]
34196658:	653b      	str	r3, [r7, #80]	@ 0x50
                size =         queue_ptr -> tx_queue_message_size;
3419665a:	68fb      	ldr	r3, [r7, #12]
3419665c:	689b      	ldr	r3, [r3, #8]
3419665e:	64fb      	str	r3, [r7, #76]	@ 0x4c

                /* Copy message. Note that the source and destination pointers are
                   incremented by the macro.  */
                TX_QUEUE_MESSAGE_COPY(source, destination, size)
34196660:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
34196662:	1d13      	adds	r3, r2, #4
34196664:	657b      	str	r3, [r7, #84]	@ 0x54
34196666:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
34196668:	1d19      	adds	r1, r3, #4
3419666a:	6539      	str	r1, [r7, #80]	@ 0x50
3419666c:	6812      	ldr	r2, [r2, #0]
3419666e:	601a      	str	r2, [r3, #0]
34196670:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34196672:	2b01      	cmp	r3, #1
34196674:	d90e      	bls.n	34196694 <_tx_queue_receive+0x104>
34196676:	e007      	b.n	34196688 <_tx_queue_receive+0xf8>
34196678:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
3419667a:	1d13      	adds	r3, r2, #4
3419667c:	657b      	str	r3, [r7, #84]	@ 0x54
3419667e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
34196680:	1d19      	adds	r1, r3, #4
34196682:	6539      	str	r1, [r7, #80]	@ 0x50
34196684:	6812      	ldr	r2, [r2, #0]
34196686:	601a      	str	r2, [r3, #0]
34196688:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3419668a:	3b01      	subs	r3, #1
3419668c:	64fb      	str	r3, [r7, #76]	@ 0x4c
3419668e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34196690:	2b00      	cmp	r3, #0
34196692:	d1f1      	bne.n	34196678 <_tx_queue_receive+0xe8>

                /* Message is now in the caller's destination. See if this is the only suspended thread
                   on the list.  */
                suspended_count--;
34196694:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34196696:	3b01      	subs	r3, #1
34196698:	643b      	str	r3, [r7, #64]	@ 0x40
                if (suspended_count == TX_NO_SUSPENSIONS)
3419669a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419669c:	2b00      	cmp	r3, #0
3419669e:	d103      	bne.n	341966a8 <_tx_queue_receive+0x118>
                {

                    /* Yes, the only suspended thread.  */

                    /* Update the head pointer.  */
                    queue_ptr -> tx_queue_suspension_list =  TX_NULL;
341966a0:	68fb      	ldr	r3, [r7, #12]
341966a2:	2200      	movs	r2, #0
341966a4:	629a      	str	r2, [r3, #40]	@ 0x28
341966a6:	e00e      	b.n	341966c6 <_tx_queue_receive+0x136>
                {

                    /* At least one more thread is on the same expiration list.  */

                    /* Update the list head pointer.  */
                    next_thread =                            thread_ptr -> tx_thread_suspended_next;
341966a8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
341966aa:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
341966ac:	63bb      	str	r3, [r7, #56]	@ 0x38
                    queue_ptr -> tx_queue_suspension_list =  next_thread;
341966ae:	68fb      	ldr	r3, [r7, #12]
341966b0:	6bba      	ldr	r2, [r7, #56]	@ 0x38
341966b2:	629a      	str	r2, [r3, #40]	@ 0x28

                    /* Update the links of the adjacent threads.  */
                    previous_thread =                              thread_ptr -> tx_thread_suspended_previous;
341966b4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
341966b6:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
341966b8:	637b      	str	r3, [r7, #52]	@ 0x34
                    next_thread -> tx_thread_suspended_previous =  previous_thread;
341966ba:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
341966bc:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
341966be:	675a      	str	r2, [r3, #116]	@ 0x74
                    previous_thread -> tx_thread_suspended_next =  next_thread;
341966c0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
341966c2:	6bba      	ldr	r2, [r7, #56]	@ 0x38
341966c4:	671a      	str	r2, [r3, #112]	@ 0x70
                }

                /* Decrement the suspension count.  */
                queue_ptr -> tx_queue_suspended_count =  suspended_count;
341966c6:	68fb      	ldr	r3, [r7, #12]
341966c8:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
341966ca:	62da      	str	r2, [r3, #44]	@ 0x2c

                /* Prepare for resumption of the first thread.  */

                /* Clear cleanup routine to avoid timeout.  */
                thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
341966cc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
341966ce:	2200      	movs	r2, #0
341966d0:	669a      	str	r2, [r3, #104]	@ 0x68

                /* Put return status into the thread control block.  */
                thread_ptr -> tx_thread_suspend_status =  TX_SUCCESS;
341966d2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
341966d4:	2200      	movs	r2, #0
341966d6:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
                /* Restore interrupts.  */
                TX_RESTORE
#else

                /* Temporarily disable preemption.  */
                _tx_thread_preempt_disable++;
341966da:	4b8e      	ldr	r3, [pc, #568]	@ (34196914 <_tx_queue_receive+0x384>)
341966dc:	681b      	ldr	r3, [r3, #0]
341966de:	3301      	adds	r3, #1
341966e0:	4a8c      	ldr	r2, [pc, #560]	@ (34196914 <_tx_queue_receive+0x384>)
341966e2:	6013      	str	r3, [r2, #0]
341966e4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
341966e6:	627b      	str	r3, [r7, #36]	@ 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
341966e8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
341966ea:	f383 8810 	msr	PRIMASK, r3
}
341966ee:	bf00      	nop

                /* Restore interrupts.  */
                TX_RESTORE

                /* Resume thread.  */
                _tx_thread_system_resume(thread_ptr);
341966f0:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
341966f2:	f001 f8c7 	bl	34197884 <_tx_thread_system_resume>
341966f6:	e107      	b.n	34196908 <_tx_queue_receive+0x378>
                /* At this point, we know that the queue is full and there
                   are one or more threads suspended trying to send another
                   message to this queue.  */

                /* Setup source and destination pointers.  */
                source =       queue_ptr -> tx_queue_read;
341966f8:	68fb      	ldr	r3, [r7, #12]
341966fa:	6a1b      	ldr	r3, [r3, #32]
341966fc:	657b      	str	r3, [r7, #84]	@ 0x54
                destination =  TX_VOID_TO_ULONG_POINTER_CONVERT(destination_ptr);
341966fe:	68bb      	ldr	r3, [r7, #8]
34196700:	653b      	str	r3, [r7, #80]	@ 0x50
                size =         queue_ptr -> tx_queue_message_size;
34196702:	68fb      	ldr	r3, [r7, #12]
34196704:	689b      	ldr	r3, [r3, #8]
34196706:	64fb      	str	r3, [r7, #76]	@ 0x4c

                /* Copy message. Note that the source and destination pointers are
                   incremented by the macro.  */
                TX_QUEUE_MESSAGE_COPY(source, destination, size)
34196708:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
3419670a:	1d13      	adds	r3, r2, #4
3419670c:	657b      	str	r3, [r7, #84]	@ 0x54
3419670e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
34196710:	1d19      	adds	r1, r3, #4
34196712:	6539      	str	r1, [r7, #80]	@ 0x50
34196714:	6812      	ldr	r2, [r2, #0]
34196716:	601a      	str	r2, [r3, #0]
34196718:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3419671a:	2b01      	cmp	r3, #1
3419671c:	d90e      	bls.n	3419673c <_tx_queue_receive+0x1ac>
3419671e:	e007      	b.n	34196730 <_tx_queue_receive+0x1a0>
34196720:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
34196722:	1d13      	adds	r3, r2, #4
34196724:	657b      	str	r3, [r7, #84]	@ 0x54
34196726:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
34196728:	1d19      	adds	r1, r3, #4
3419672a:	6539      	str	r1, [r7, #80]	@ 0x50
3419672c:	6812      	ldr	r2, [r2, #0]
3419672e:	601a      	str	r2, [r3, #0]
34196730:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34196732:	3b01      	subs	r3, #1
34196734:	64fb      	str	r3, [r7, #76]	@ 0x4c
34196736:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34196738:	2b00      	cmp	r3, #0
3419673a:	d1f1      	bne.n	34196720 <_tx_queue_receive+0x190>

                /* Determine if we are at the end.  */
                if (source == queue_ptr -> tx_queue_end)
3419673c:	68fb      	ldr	r3, [r7, #12]
3419673e:	69db      	ldr	r3, [r3, #28]
34196740:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
34196742:	429a      	cmp	r2, r3
34196744:	d102      	bne.n	3419674c <_tx_queue_receive+0x1bc>
                {

                    /* Yes, wrap around to the beginning.  */
                    source =  queue_ptr -> tx_queue_start;
34196746:	68fb      	ldr	r3, [r7, #12]
34196748:	699b      	ldr	r3, [r3, #24]
3419674a:	657b      	str	r3, [r7, #84]	@ 0x54
                }

                /* Setup the queue read pointer.   */
                queue_ptr -> tx_queue_read =  source;
3419674c:	68fb      	ldr	r3, [r7, #12]
3419674e:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
34196750:	621a      	str	r2, [r3, #32]

                /* Disable preemption.  */
                _tx_thread_preempt_disable++;
34196752:	4b70      	ldr	r3, [pc, #448]	@ (34196914 <_tx_queue_receive+0x384>)
34196754:	681b      	ldr	r3, [r3, #0]
34196756:	3301      	adds	r3, #1
34196758:	4a6e      	ldr	r2, [pc, #440]	@ (34196914 <_tx_queue_receive+0x384>)
3419675a:	6013      	str	r3, [r2, #0]
                /* Disable interrupts again.  */
                TX_DISABLE
#endif

                /* Decrement the preemption disable variable.  */
                _tx_thread_preempt_disable--;
3419675c:	4b6d      	ldr	r3, [pc, #436]	@ (34196914 <_tx_queue_receive+0x384>)
3419675e:	681b      	ldr	r3, [r3, #0]
34196760:	3b01      	subs	r3, #1
34196762:	4a6c      	ldr	r2, [pc, #432]	@ (34196914 <_tx_queue_receive+0x384>)
34196764:	6013      	str	r3, [r2, #0]

                /* Setup source and destination pointers.  */
                source =       TX_VOID_TO_ULONG_POINTER_CONVERT(thread_ptr -> tx_thread_additional_suspend_info);
34196766:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34196768:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3419676a:	657b      	str	r3, [r7, #84]	@ 0x54
                destination =  queue_ptr -> tx_queue_write;
3419676c:	68fb      	ldr	r3, [r7, #12]
3419676e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34196770:	653b      	str	r3, [r7, #80]	@ 0x50
                size =         queue_ptr -> tx_queue_message_size;
34196772:	68fb      	ldr	r3, [r7, #12]
34196774:	689b      	ldr	r3, [r3, #8]
34196776:	64fb      	str	r3, [r7, #76]	@ 0x4c

                /* Copy message. Note that the source and destination pointers are
                   incremented by the macro.  */
                TX_QUEUE_MESSAGE_COPY(source, destination, size)
34196778:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
3419677a:	1d13      	adds	r3, r2, #4
3419677c:	657b      	str	r3, [r7, #84]	@ 0x54
3419677e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
34196780:	1d19      	adds	r1, r3, #4
34196782:	6539      	str	r1, [r7, #80]	@ 0x50
34196784:	6812      	ldr	r2, [r2, #0]
34196786:	601a      	str	r2, [r3, #0]
34196788:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3419678a:	2b01      	cmp	r3, #1
3419678c:	d90e      	bls.n	341967ac <_tx_queue_receive+0x21c>
3419678e:	e007      	b.n	341967a0 <_tx_queue_receive+0x210>
34196790:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
34196792:	1d13      	adds	r3, r2, #4
34196794:	657b      	str	r3, [r7, #84]	@ 0x54
34196796:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
34196798:	1d19      	adds	r1, r3, #4
3419679a:	6539      	str	r1, [r7, #80]	@ 0x50
3419679c:	6812      	ldr	r2, [r2, #0]
3419679e:	601a      	str	r2, [r3, #0]
341967a0:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
341967a2:	3b01      	subs	r3, #1
341967a4:	64fb      	str	r3, [r7, #76]	@ 0x4c
341967a6:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
341967a8:	2b00      	cmp	r3, #0
341967aa:	d1f1      	bne.n	34196790 <_tx_queue_receive+0x200>

                /* Determine if we are at the end.  */
                if (destination == queue_ptr -> tx_queue_end)
341967ac:	68fb      	ldr	r3, [r7, #12]
341967ae:	69db      	ldr	r3, [r3, #28]
341967b0:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
341967b2:	429a      	cmp	r2, r3
341967b4:	d102      	bne.n	341967bc <_tx_queue_receive+0x22c>
                {

                    /* Yes, wrap around to the beginning.  */
                    destination =  queue_ptr -> tx_queue_start;
341967b6:	68fb      	ldr	r3, [r7, #12]
341967b8:	699b      	ldr	r3, [r3, #24]
341967ba:	653b      	str	r3, [r7, #80]	@ 0x50
                }

                /* Adjust the write pointer.  */
                queue_ptr -> tx_queue_write =  destination;
341967bc:	68fb      	ldr	r3, [r7, #12]
341967be:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
341967c0:	625a      	str	r2, [r3, #36]	@ 0x24

                /* Pickup thread pointer.  */
                thread_ptr =  queue_ptr -> tx_queue_suspension_list;
341967c2:	68fb      	ldr	r3, [r7, #12]
341967c4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
341967c6:	63fb      	str	r3, [r7, #60]	@ 0x3c

                /* Message is now in the queue.  See if this is the only suspended thread
                   on the list.  */
                suspended_count--;
341967c8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
341967ca:	3b01      	subs	r3, #1
341967cc:	643b      	str	r3, [r7, #64]	@ 0x40
                if (suspended_count == TX_NO_SUSPENSIONS)
341967ce:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
341967d0:	2b00      	cmp	r3, #0
341967d2:	d103      	bne.n	341967dc <_tx_queue_receive+0x24c>
                {

                  /* Yes, the only suspended thread.  */

                    /* Update the head pointer.  */
                    queue_ptr -> tx_queue_suspension_list =  TX_NULL;
341967d4:	68fb      	ldr	r3, [r7, #12]
341967d6:	2200      	movs	r2, #0
341967d8:	629a      	str	r2, [r3, #40]	@ 0x28
341967da:	e00e      	b.n	341967fa <_tx_queue_receive+0x26a>
                {

                    /* At least one more thread is on the same expiration list.  */

                    /* Update the list head pointer.  */
                    next_thread =                            thread_ptr -> tx_thread_suspended_next;
341967dc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
341967de:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
341967e0:	63bb      	str	r3, [r7, #56]	@ 0x38
                    queue_ptr -> tx_queue_suspension_list =  next_thread;
341967e2:	68fb      	ldr	r3, [r7, #12]
341967e4:	6bba      	ldr	r2, [r7, #56]	@ 0x38
341967e6:	629a      	str	r2, [r3, #40]	@ 0x28

                    /* Update the links of the adjacent threads.  */
                    previous_thread =                               thread_ptr -> tx_thread_suspended_previous;
341967e8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
341967ea:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
341967ec:	637b      	str	r3, [r7, #52]	@ 0x34
                    next_thread -> tx_thread_suspended_previous =   previous_thread;
341967ee:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
341967f0:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
341967f2:	675a      	str	r2, [r3, #116]	@ 0x74
                    previous_thread -> tx_thread_suspended_next =   next_thread;
341967f4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
341967f6:	6bba      	ldr	r2, [r7, #56]	@ 0x38
341967f8:	671a      	str	r2, [r3, #112]	@ 0x70
                }

                /* Decrement the suspension count.  */
                queue_ptr -> tx_queue_suspended_count =  suspended_count;
341967fa:	68fb      	ldr	r3, [r7, #12]
341967fc:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
341967fe:	62da      	str	r2, [r3, #44]	@ 0x2c

                /* Prepare for resumption of the first thread.  */

                /* Clear cleanup routine to avoid timeout.  */
                thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
34196800:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34196802:	2200      	movs	r2, #0
34196804:	669a      	str	r2, [r3, #104]	@ 0x68

                /* Put return status into the thread control block.  */
                thread_ptr -> tx_thread_suspend_status =  TX_SUCCESS;
34196806:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34196808:	2200      	movs	r2, #0
3419680a:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
                /* Restore interrupts.  */
                TX_RESTORE
#else

                /* Temporarily disable preemption.  */
                _tx_thread_preempt_disable++;
3419680e:	4b41      	ldr	r3, [pc, #260]	@ (34196914 <_tx_queue_receive+0x384>)
34196810:	681b      	ldr	r3, [r3, #0]
34196812:	3301      	adds	r3, #1
34196814:	4a3f      	ldr	r2, [pc, #252]	@ (34196914 <_tx_queue_receive+0x384>)
34196816:	6013      	str	r3, [r2, #0]
34196818:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3419681a:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
3419681c:	6a3b      	ldr	r3, [r7, #32]
3419681e:	f383 8810 	msr	PRIMASK, r3
}
34196822:	bf00      	nop

                /* Restore interrupts.  */
                TX_RESTORE

                /* Resume thread.  */
                _tx_thread_system_resume(thread_ptr);
34196824:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
34196826:	f001 f82d 	bl	34197884 <_tx_thread_system_resume>
3419682a:	e06d      	b.n	34196908 <_tx_queue_receive+0x378>
            }
        }
    }

    /* Determine if the request specifies suspension.  */
    else if (wait_option != TX_NO_WAIT)
3419682c:	687b      	ldr	r3, [r7, #4]
3419682e:	2b00      	cmp	r3, #0
34196830:	d062      	beq.n	341968f8 <_tx_queue_receive+0x368>
    {

        /* Determine if the preempt disable flag is non-zero.  */
        if (_tx_thread_preempt_disable != ((UINT) 0))
34196832:	4b38      	ldr	r3, [pc, #224]	@ (34196914 <_tx_queue_receive+0x384>)
34196834:	681b      	ldr	r3, [r3, #0]
34196836:	2b00      	cmp	r3, #0
34196838:	d008      	beq.n	3419684c <_tx_queue_receive+0x2bc>
3419683a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3419683c:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
3419683e:	69fb      	ldr	r3, [r7, #28]
34196840:	f383 8810 	msr	PRIMASK, r3
}
34196844:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Suspension is not allowed if the preempt disable flag is non-zero at this point - return error completion.  */
            status =  TX_QUEUE_EMPTY;
34196846:	230a      	movs	r3, #10
34196848:	64bb      	str	r3, [r7, #72]	@ 0x48
3419684a:	e05d      	b.n	34196908 <_tx_queue_receive+0x378>
            /* Increment the number of empty suspensions on this queue.  */
            queue_ptr -> tx_queue_performance_empty_suspension_count++;
#endif

            /* Pickup thread pointer.  */
            TX_THREAD_GET_CURRENT(thread_ptr)
3419684c:	4b32      	ldr	r3, [pc, #200]	@ (34196918 <_tx_queue_receive+0x388>)
3419684e:	681b      	ldr	r3, [r3, #0]
34196850:	63fb      	str	r3, [r7, #60]	@ 0x3c

            /* Setup cleanup routine pointer.  */
            thread_ptr -> tx_thread_suspend_cleanup =  &(_tx_queue_cleanup);
34196852:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34196854:	4a31      	ldr	r2, [pc, #196]	@ (3419691c <_tx_queue_receive+0x38c>)
34196856:	669a      	str	r2, [r3, #104]	@ 0x68

            /* Setup cleanup information, i.e. this queue control
               block and the source pointer.  */
            thread_ptr -> tx_thread_suspend_control_block =    (VOID *) queue_ptr;
34196858:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3419685a:	68fa      	ldr	r2, [r7, #12]
3419685c:	66da      	str	r2, [r3, #108]	@ 0x6c
            thread_ptr -> tx_thread_additional_suspend_info =  (VOID *) destination_ptr;
3419685e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34196860:	68ba      	ldr	r2, [r7, #8]
34196862:	67da      	str	r2, [r3, #124]	@ 0x7c
            thread_ptr -> tx_thread_suspend_option =           TX_FALSE;
34196864:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34196866:	2200      	movs	r2, #0
34196868:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

#ifndef TX_NOT_INTERRUPTABLE

            /* Increment the suspension sequence number, which is used to identify
               this suspension event.  */
            thread_ptr -> tx_thread_suspension_sequence++;
3419686c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3419686e:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
34196872:	1c5a      	adds	r2, r3, #1
34196874:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34196876:	f8c3 20ac 	str.w	r2, [r3, #172]	@ 0xac
#endif

            /* Setup suspension list.  */
            if (suspended_count == TX_NO_SUSPENSIONS)
3419687a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419687c:	2b00      	cmp	r3, #0
3419687e:	d109      	bne.n	34196894 <_tx_queue_receive+0x304>
            {

                /* No other threads are suspended.  Setup the head pointer and
                   just setup this threads pointers to itself.  */
                queue_ptr -> tx_queue_suspension_list =         thread_ptr;
34196880:	68fb      	ldr	r3, [r7, #12]
34196882:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
34196884:	629a      	str	r2, [r3, #40]	@ 0x28
                thread_ptr -> tx_thread_suspended_next =        thread_ptr;
34196886:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34196888:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
3419688a:	671a      	str	r2, [r3, #112]	@ 0x70
                thread_ptr -> tx_thread_suspended_previous =    thread_ptr;
3419688c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3419688e:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
34196890:	675a      	str	r2, [r3, #116]	@ 0x74
34196892:	e011      	b.n	341968b8 <_tx_queue_receive+0x328>
            }
            else
            {

                /* This list is not NULL, add current thread to the end. */
                next_thread =                                   queue_ptr -> tx_queue_suspension_list;
34196894:	68fb      	ldr	r3, [r7, #12]
34196896:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34196898:	63bb      	str	r3, [r7, #56]	@ 0x38
                thread_ptr -> tx_thread_suspended_next =        next_thread;
3419689a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3419689c:	6bba      	ldr	r2, [r7, #56]	@ 0x38
3419689e:	671a      	str	r2, [r3, #112]	@ 0x70
                previous_thread =                               next_thread -> tx_thread_suspended_previous;
341968a0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
341968a2:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
341968a4:	637b      	str	r3, [r7, #52]	@ 0x34
                thread_ptr -> tx_thread_suspended_previous =    previous_thread;
341968a6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
341968a8:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
341968aa:	675a      	str	r2, [r3, #116]	@ 0x74
                previous_thread -> tx_thread_suspended_next =   thread_ptr;
341968ac:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
341968ae:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
341968b0:	671a      	str	r2, [r3, #112]	@ 0x70
                next_thread -> tx_thread_suspended_previous =   thread_ptr;
341968b2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
341968b4:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
341968b6:	675a      	str	r2, [r3, #116]	@ 0x74
            }

            /* Increment the suspended thread count.  */
            queue_ptr -> tx_queue_suspended_count =  suspended_count + ((UINT) 1);
341968b8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
341968ba:	1c5a      	adds	r2, r3, #1
341968bc:	68fb      	ldr	r3, [r7, #12]
341968be:	62da      	str	r2, [r3, #44]	@ 0x2c

            /* Set the state to suspended.  */
            thread_ptr -> tx_thread_state =    TX_QUEUE_SUSP;
341968c0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
341968c2:	2205      	movs	r2, #5
341968c4:	631a      	str	r2, [r3, #48]	@ 0x30
            /* Restore interrupts.  */
            TX_RESTORE
#else

            /* Set the suspending flag.  */
            thread_ptr -> tx_thread_suspending =  TX_TRUE;
341968c6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
341968c8:	2201      	movs	r2, #1
341968ca:	639a      	str	r2, [r3, #56]	@ 0x38

            /* Setup the timeout period.  */
            thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  wait_option;
341968cc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
341968ce:	687a      	ldr	r2, [r7, #4]
341968d0:	64da      	str	r2, [r3, #76]	@ 0x4c

            /* Temporarily disable preemption.  */
            _tx_thread_preempt_disable++;
341968d2:	4b10      	ldr	r3, [pc, #64]	@ (34196914 <_tx_queue_receive+0x384>)
341968d4:	681b      	ldr	r3, [r3, #0]
341968d6:	3301      	adds	r3, #1
341968d8:	4a0e      	ldr	r2, [pc, #56]	@ (34196914 <_tx_queue_receive+0x384>)
341968da:	6013      	str	r3, [r2, #0]
341968dc:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
341968de:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
341968e0:	69bb      	ldr	r3, [r7, #24]
341968e2:	f383 8810 	msr	PRIMASK, r3
}
341968e6:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Call actual thread suspension routine.  */
            _tx_thread_system_suspend(thread_ptr);
341968e8:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
341968ea:	f001 f8cb 	bl	34197a84 <_tx_thread_system_suspend>
#endif

            /* Return the completion status.  */
            status =  thread_ptr -> tx_thread_suspend_status;
341968ee:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
341968f0:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
341968f4:	64bb      	str	r3, [r7, #72]	@ 0x48
341968f6:	e007      	b.n	34196908 <_tx_queue_receive+0x378>
341968f8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
341968fa:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
341968fc:	697b      	ldr	r3, [r7, #20]
341968fe:	f383 8810 	msr	PRIMASK, r3
}
34196902:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Immediate return, return error completion.  */
        status =  TX_QUEUE_EMPTY;
34196904:	230a      	movs	r3, #10
34196906:	64bb      	str	r3, [r7, #72]	@ 0x48
    }

    /* Return completion status.  */
    return(status);
34196908:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
}
3419690a:	4618      	mov	r0, r3
3419690c:	3758      	adds	r7, #88	@ 0x58
3419690e:	46bd      	mov	sp, r7
34196910:	bd80      	pop	{r7, pc}
34196912:	bf00      	nop
34196914:	341c2e84 	.word	0x341c2e84
34196918:	341c2dec 	.word	0x341c2dec
3419691c:	341963a1 	.word	0x341963a1

34196920 <_tx_queue_send>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_queue_send(TX_QUEUE *queue_ptr, VOID *source_ptr, ULONG wait_option)
{
34196920:	b580      	push	{r7, lr}
34196922:	b094      	sub	sp, #80	@ 0x50
34196924:	af00      	add	r7, sp, #0
34196926:	60f8      	str	r0, [r7, #12]
34196928:	60b9      	str	r1, [r7, #8]
3419692a:	607a      	str	r2, [r7, #4]
VOID            (*queue_send_notify)(struct TX_QUEUE_STRUCT *notify_queue_ptr);
#endif


    /* Default the status to TX_SUCCESS.  */
    status =  TX_SUCCESS;
3419692c:	2300      	movs	r3, #0
3419692e:	643b      	str	r3, [r7, #64]	@ 0x40
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34196930:	f3ef 8310 	mrs	r3, PRIMASK
34196934:	62bb      	str	r3, [r7, #40]	@ 0x28
    return(posture);
34196936:	6abb      	ldr	r3, [r7, #40]	@ 0x28
    int_posture = __get_interrupt_posture();
34196938:	627b      	str	r3, [r7, #36]	@ 0x24
    __asm__ volatile ("CPSID i" : : : "memory");
3419693a:	b672      	cpsid	i
    return(int_posture);
3419693c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24

    /* Disable interrupts to place message in the queue.  */
    TX_DISABLE
3419693e:	63fb      	str	r3, [r7, #60]	@ 0x3c

    /* Log this kernel call.  */
    TX_EL_QUEUE_SEND_INSERT

    /* Pickup the thread suspension count.  */
    suspended_count =  queue_ptr -> tx_queue_suspended_count;
34196940:	68fb      	ldr	r3, [r7, #12]
34196942:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34196944:	63bb      	str	r3, [r7, #56]	@ 0x38

    /* Determine if there is room in the queue.  */
    if (queue_ptr -> tx_queue_available_storage != TX_NO_MESSAGES)
34196946:	68fb      	ldr	r3, [r7, #12]
34196948:	695b      	ldr	r3, [r3, #20]
3419694a:	2b00      	cmp	r3, #0
3419694c:	f000 809b 	beq.w	34196a86 <_tx_queue_send+0x166>
    {

        /* There is room for the message in the queue.  */

        /* Determine if there are suspended on this queue.  */
        if (suspended_count == TX_NO_SUSPENSIONS)
34196950:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34196952:	2b00      	cmp	r3, #0
34196954:	d13c      	bne.n	341969d0 <_tx_queue_send+0xb0>
        {

            /* No suspended threads, simply place the message in the queue.  */

            /* Reduce the amount of available storage.  */
            queue_ptr -> tx_queue_available_storage--;
34196956:	68fb      	ldr	r3, [r7, #12]
34196958:	695b      	ldr	r3, [r3, #20]
3419695a:	1e5a      	subs	r2, r3, #1
3419695c:	68fb      	ldr	r3, [r7, #12]
3419695e:	615a      	str	r2, [r3, #20]

            /* Increase the enqueued count.  */
            queue_ptr -> tx_queue_enqueued++;
34196960:	68fb      	ldr	r3, [r7, #12]
34196962:	691b      	ldr	r3, [r3, #16]
34196964:	1c5a      	adds	r2, r3, #1
34196966:	68fb      	ldr	r3, [r7, #12]
34196968:	611a      	str	r2, [r3, #16]

            /* Setup source and destination pointers.  */
            source =       TX_VOID_TO_ULONG_POINTER_CONVERT(source_ptr);
3419696a:	68bb      	ldr	r3, [r7, #8]
3419696c:	64fb      	str	r3, [r7, #76]	@ 0x4c
            destination =  queue_ptr -> tx_queue_write;
3419696e:	68fb      	ldr	r3, [r7, #12]
34196970:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34196972:	64bb      	str	r3, [r7, #72]	@ 0x48
            size =         queue_ptr -> tx_queue_message_size;
34196974:	68fb      	ldr	r3, [r7, #12]
34196976:	689b      	ldr	r3, [r3, #8]
34196978:	647b      	str	r3, [r7, #68]	@ 0x44

            /* Copy message. Note that the source and destination pointers are
               incremented by the macro.  */
            TX_QUEUE_MESSAGE_COPY(source, destination, size)
3419697a:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
3419697c:	1d13      	adds	r3, r2, #4
3419697e:	64fb      	str	r3, [r7, #76]	@ 0x4c
34196980:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
34196982:	1d19      	adds	r1, r3, #4
34196984:	64b9      	str	r1, [r7, #72]	@ 0x48
34196986:	6812      	ldr	r2, [r2, #0]
34196988:	601a      	str	r2, [r3, #0]
3419698a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3419698c:	2b01      	cmp	r3, #1
3419698e:	d90e      	bls.n	341969ae <_tx_queue_send+0x8e>
34196990:	e007      	b.n	341969a2 <_tx_queue_send+0x82>
34196992:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
34196994:	1d13      	adds	r3, r2, #4
34196996:	64fb      	str	r3, [r7, #76]	@ 0x4c
34196998:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3419699a:	1d19      	adds	r1, r3, #4
3419699c:	64b9      	str	r1, [r7, #72]	@ 0x48
3419699e:	6812      	ldr	r2, [r2, #0]
341969a0:	601a      	str	r2, [r3, #0]
341969a2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
341969a4:	3b01      	subs	r3, #1
341969a6:	647b      	str	r3, [r7, #68]	@ 0x44
341969a8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
341969aa:	2b00      	cmp	r3, #0
341969ac:	d1f1      	bne.n	34196992 <_tx_queue_send+0x72>

            /* Determine if we are at the end.  */
            if (destination == queue_ptr -> tx_queue_end)
341969ae:	68fb      	ldr	r3, [r7, #12]
341969b0:	69db      	ldr	r3, [r3, #28]
341969b2:	6cba      	ldr	r2, [r7, #72]	@ 0x48
341969b4:	429a      	cmp	r2, r3
341969b6:	d102      	bne.n	341969be <_tx_queue_send+0x9e>
            {

                /* Yes, wrap around to the beginning.  */
                destination =  queue_ptr -> tx_queue_start;
341969b8:	68fb      	ldr	r3, [r7, #12]
341969ba:	699b      	ldr	r3, [r3, #24]
341969bc:	64bb      	str	r3, [r7, #72]	@ 0x48
            }

            /* Adjust the write pointer.  */
            queue_ptr -> tx_queue_write =  destination;
341969be:	68fb      	ldr	r3, [r7, #12]
341969c0:	6cba      	ldr	r2, [r7, #72]	@ 0x48
341969c2:	625a      	str	r2, [r3, #36]	@ 0x24
341969c4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
341969c6:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
341969c8:	6a3b      	ldr	r3, [r7, #32]
341969ca:	f383 8810 	msr	PRIMASK, r3
}
341969ce:	e0c8      	b.n	34196b62 <_tx_queue_send+0x242>
            /* There is a thread suspended on an empty queue. Simply
               copy the message to the suspended thread's destination
               pointer.  */

            /* Pickup the head of the suspension list.  */
            thread_ptr =  queue_ptr -> tx_queue_suspension_list;
341969d0:	68fb      	ldr	r3, [r7, #12]
341969d2:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
341969d4:	637b      	str	r3, [r7, #52]	@ 0x34

            /* See if this is the only suspended thread on the list.  */
            suspended_count--;
341969d6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
341969d8:	3b01      	subs	r3, #1
341969da:	63bb      	str	r3, [r7, #56]	@ 0x38
            if (suspended_count == TX_NO_SUSPENSIONS)
341969dc:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
341969de:	2b00      	cmp	r3, #0
341969e0:	d103      	bne.n	341969ea <_tx_queue_send+0xca>
            {

                /* Yes, the only suspended thread.  */

                /* Update the head pointer.  */
                queue_ptr -> tx_queue_suspension_list =  TX_NULL;
341969e2:	68fb      	ldr	r3, [r7, #12]
341969e4:	2200      	movs	r2, #0
341969e6:	629a      	str	r2, [r3, #40]	@ 0x28
341969e8:	e012      	b.n	34196a10 <_tx_queue_send+0xf0>
            {

                /* At least one more thread is on the same expiration list.  */

                /* Update the list head pointer.  */
                queue_ptr -> tx_queue_suspension_list =  thread_ptr -> tx_thread_suspended_next;
341969ea:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
341969ec:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
341969ee:	68fb      	ldr	r3, [r7, #12]
341969f0:	629a      	str	r2, [r3, #40]	@ 0x28

                /* Update the links of the adjacent threads.  */
                next_thread =                            thread_ptr -> tx_thread_suspended_next;
341969f2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
341969f4:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
341969f6:	633b      	str	r3, [r7, #48]	@ 0x30
                queue_ptr -> tx_queue_suspension_list =  next_thread;
341969f8:	68fb      	ldr	r3, [r7, #12]
341969fa:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
341969fc:	629a      	str	r2, [r3, #40]	@ 0x28

                /* Update the links of the adjacent threads.  */
                previous_thread =                               thread_ptr -> tx_thread_suspended_previous;
341969fe:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34196a00:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34196a02:	62fb      	str	r3, [r7, #44]	@ 0x2c
                next_thread -> tx_thread_suspended_previous =   previous_thread;
34196a04:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34196a06:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
34196a08:	675a      	str	r2, [r3, #116]	@ 0x74
                previous_thread -> tx_thread_suspended_next =   next_thread;
34196a0a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34196a0c:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
34196a0e:	671a      	str	r2, [r3, #112]	@ 0x70
            }

            /* Decrement the suspension count.  */
            queue_ptr -> tx_queue_suspended_count =  suspended_count;
34196a10:	68fb      	ldr	r3, [r7, #12]
34196a12:	6bba      	ldr	r2, [r7, #56]	@ 0x38
34196a14:	62da      	str	r2, [r3, #44]	@ 0x2c

            /* Prepare for resumption of the thread.  */

            /* Clear cleanup routine to avoid timeout.  */
            thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
34196a16:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34196a18:	2200      	movs	r2, #0
34196a1a:	669a      	str	r2, [r3, #104]	@ 0x68

            /* Setup source and destination pointers.  */
            source =       TX_VOID_TO_ULONG_POINTER_CONVERT(source_ptr);
34196a1c:	68bb      	ldr	r3, [r7, #8]
34196a1e:	64fb      	str	r3, [r7, #76]	@ 0x4c
            destination =  TX_VOID_TO_ULONG_POINTER_CONVERT(thread_ptr -> tx_thread_additional_suspend_info);
34196a20:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34196a22:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34196a24:	64bb      	str	r3, [r7, #72]	@ 0x48
            size =         queue_ptr -> tx_queue_message_size;
34196a26:	68fb      	ldr	r3, [r7, #12]
34196a28:	689b      	ldr	r3, [r3, #8]
34196a2a:	647b      	str	r3, [r7, #68]	@ 0x44

            /* Copy message. Note that the source and destination pointers are
               incremented by the macro.  */
            TX_QUEUE_MESSAGE_COPY(source, destination, size)
34196a2c:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
34196a2e:	1d13      	adds	r3, r2, #4
34196a30:	64fb      	str	r3, [r7, #76]	@ 0x4c
34196a32:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
34196a34:	1d19      	adds	r1, r3, #4
34196a36:	64b9      	str	r1, [r7, #72]	@ 0x48
34196a38:	6812      	ldr	r2, [r2, #0]
34196a3a:	601a      	str	r2, [r3, #0]
34196a3c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34196a3e:	2b01      	cmp	r3, #1
34196a40:	d90e      	bls.n	34196a60 <_tx_queue_send+0x140>
34196a42:	e007      	b.n	34196a54 <_tx_queue_send+0x134>
34196a44:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
34196a46:	1d13      	adds	r3, r2, #4
34196a48:	64fb      	str	r3, [r7, #76]	@ 0x4c
34196a4a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
34196a4c:	1d19      	adds	r1, r3, #4
34196a4e:	64b9      	str	r1, [r7, #72]	@ 0x48
34196a50:	6812      	ldr	r2, [r2, #0]
34196a52:	601a      	str	r2, [r3, #0]
34196a54:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34196a56:	3b01      	subs	r3, #1
34196a58:	647b      	str	r3, [r7, #68]	@ 0x44
34196a5a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34196a5c:	2b00      	cmp	r3, #0
34196a5e:	d1f1      	bne.n	34196a44 <_tx_queue_send+0x124>

            /* Put return status into the thread control block.  */
            thread_ptr -> tx_thread_suspend_status =  TX_SUCCESS;
34196a60:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34196a62:	2200      	movs	r2, #0
34196a64:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
            /* Restore interrupts.  */
            TX_RESTORE
#else

            /* Temporarily disable preemption.  */
            _tx_thread_preempt_disable++;
34196a68:	4b40      	ldr	r3, [pc, #256]	@ (34196b6c <_tx_queue_send+0x24c>)
34196a6a:	681b      	ldr	r3, [r3, #0]
34196a6c:	3301      	adds	r3, #1
34196a6e:	4a3f      	ldr	r2, [pc, #252]	@ (34196b6c <_tx_queue_send+0x24c>)
34196a70:	6013      	str	r3, [r2, #0]
34196a72:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34196a74:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34196a76:	69fb      	ldr	r3, [r7, #28]
34196a78:	f383 8810 	msr	PRIMASK, r3
}
34196a7c:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Resume thread.  */
            _tx_thread_system_resume(thread_ptr);
34196a7e:	6b78      	ldr	r0, [r7, #52]	@ 0x34
34196a80:	f000 ff00 	bl	34197884 <_tx_thread_system_resume>
34196a84:	e06d      	b.n	34196b62 <_tx_queue_send+0x242>
#endif
        }
    }

    /* At this point, the queue is full. Determine if suspension is requested.  */
    else if (wait_option != TX_NO_WAIT)
34196a86:	687b      	ldr	r3, [r7, #4]
34196a88:	2b00      	cmp	r3, #0
34196a8a:	d062      	beq.n	34196b52 <_tx_queue_send+0x232>
    {

        /* Determine if the preempt disable flag is non-zero.  */
        if (_tx_thread_preempt_disable != ((UINT) 0))
34196a8c:	4b37      	ldr	r3, [pc, #220]	@ (34196b6c <_tx_queue_send+0x24c>)
34196a8e:	681b      	ldr	r3, [r3, #0]
34196a90:	2b00      	cmp	r3, #0
34196a92:	d008      	beq.n	34196aa6 <_tx_queue_send+0x186>
34196a94:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34196a96:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34196a98:	69bb      	ldr	r3, [r7, #24]
34196a9a:	f383 8810 	msr	PRIMASK, r3
}
34196a9e:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Suspension is not allowed if the preempt disable flag is non-zero at this point - return error completion.  */
            status =  TX_QUEUE_FULL;
34196aa0:	230b      	movs	r3, #11
34196aa2:	643b      	str	r3, [r7, #64]	@ 0x40
34196aa4:	e05d      	b.n	34196b62 <_tx_queue_send+0x242>
            /* Increment the number of full suspensions on this queue.  */
            queue_ptr -> tx_queue_performance_full_suspension_count++;
#endif

            /* Pickup thread pointer.  */
            TX_THREAD_GET_CURRENT(thread_ptr)
34196aa6:	4b32      	ldr	r3, [pc, #200]	@ (34196b70 <_tx_queue_send+0x250>)
34196aa8:	681b      	ldr	r3, [r3, #0]
34196aaa:	637b      	str	r3, [r7, #52]	@ 0x34

            /* Setup cleanup routine pointer.  */
            thread_ptr -> tx_thread_suspend_cleanup =  &(_tx_queue_cleanup);
34196aac:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34196aae:	4a31      	ldr	r2, [pc, #196]	@ (34196b74 <_tx_queue_send+0x254>)
34196ab0:	669a      	str	r2, [r3, #104]	@ 0x68

            /* Setup cleanup information, i.e. this queue control
               block and the source pointer.  */
            thread_ptr -> tx_thread_suspend_control_block =    (VOID *) queue_ptr;
34196ab2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34196ab4:	68fa      	ldr	r2, [r7, #12]
34196ab6:	66da      	str	r2, [r3, #108]	@ 0x6c
            thread_ptr -> tx_thread_additional_suspend_info =  (VOID *) source_ptr;
34196ab8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34196aba:	68ba      	ldr	r2, [r7, #8]
34196abc:	67da      	str	r2, [r3, #124]	@ 0x7c
            thread_ptr -> tx_thread_suspend_option =           TX_FALSE;
34196abe:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34196ac0:	2200      	movs	r2, #0
34196ac2:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

#ifndef TX_NOT_INTERRUPTABLE

            /* Increment the suspension sequence number, which is used to identify
               this suspension event.  */
            thread_ptr -> tx_thread_suspension_sequence++;
34196ac6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34196ac8:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
34196acc:	1c5a      	adds	r2, r3, #1
34196ace:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34196ad0:	f8c3 20ac 	str.w	r2, [r3, #172]	@ 0xac
#endif

            /* Setup suspension list.  */
            if (suspended_count == TX_NO_SUSPENSIONS)
34196ad4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34196ad6:	2b00      	cmp	r3, #0
34196ad8:	d109      	bne.n	34196aee <_tx_queue_send+0x1ce>
            {

                /* No other threads are suspended.  Setup the head pointer and
                   just setup this threads pointers to itself.  */
                queue_ptr -> tx_queue_suspension_list =         thread_ptr;
34196ada:	68fb      	ldr	r3, [r7, #12]
34196adc:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
34196ade:	629a      	str	r2, [r3, #40]	@ 0x28
                thread_ptr -> tx_thread_suspended_next =        thread_ptr;
34196ae0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34196ae2:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
34196ae4:	671a      	str	r2, [r3, #112]	@ 0x70
                thread_ptr -> tx_thread_suspended_previous =    thread_ptr;
34196ae6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34196ae8:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
34196aea:	675a      	str	r2, [r3, #116]	@ 0x74
34196aec:	e011      	b.n	34196b12 <_tx_queue_send+0x1f2>
            }
            else
            {

                /* This list is not NULL, add current thread to the end. */
                next_thread =                                   queue_ptr -> tx_queue_suspension_list;
34196aee:	68fb      	ldr	r3, [r7, #12]
34196af0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34196af2:	633b      	str	r3, [r7, #48]	@ 0x30
                thread_ptr -> tx_thread_suspended_next =        next_thread;
34196af4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34196af6:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
34196af8:	671a      	str	r2, [r3, #112]	@ 0x70
                previous_thread =                               next_thread -> tx_thread_suspended_previous;
34196afa:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34196afc:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34196afe:	62fb      	str	r3, [r7, #44]	@ 0x2c
                thread_ptr -> tx_thread_suspended_previous =    previous_thread;
34196b00:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34196b02:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
34196b04:	675a      	str	r2, [r3, #116]	@ 0x74
                previous_thread -> tx_thread_suspended_next =   thread_ptr;
34196b06:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34196b08:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
34196b0a:	671a      	str	r2, [r3, #112]	@ 0x70
                next_thread -> tx_thread_suspended_previous =   thread_ptr;
34196b0c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34196b0e:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
34196b10:	675a      	str	r2, [r3, #116]	@ 0x74
            }

            /* Increment the suspended thread count.  */
            queue_ptr -> tx_queue_suspended_count =  suspended_count + ((UINT) 1);
34196b12:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34196b14:	1c5a      	adds	r2, r3, #1
34196b16:	68fb      	ldr	r3, [r7, #12]
34196b18:	62da      	str	r2, [r3, #44]	@ 0x2c

            /* Set the state to suspended.  */
            thread_ptr -> tx_thread_state =    TX_QUEUE_SUSP;
34196b1a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34196b1c:	2205      	movs	r2, #5
34196b1e:	631a      	str	r2, [r3, #48]	@ 0x30
            /* Restore interrupts.  */
            TX_RESTORE
#else

            /* Set the suspending flag.  */
            thread_ptr -> tx_thread_suspending =  TX_TRUE;
34196b20:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34196b22:	2201      	movs	r2, #1
34196b24:	639a      	str	r2, [r3, #56]	@ 0x38

            /* Setup the timeout period.  */
            thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  wait_option;
34196b26:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34196b28:	687a      	ldr	r2, [r7, #4]
34196b2a:	64da      	str	r2, [r3, #76]	@ 0x4c

            /* Temporarily disable preemption.  */
            _tx_thread_preempt_disable++;
34196b2c:	4b0f      	ldr	r3, [pc, #60]	@ (34196b6c <_tx_queue_send+0x24c>)
34196b2e:	681b      	ldr	r3, [r3, #0]
34196b30:	3301      	adds	r3, #1
34196b32:	4a0e      	ldr	r2, [pc, #56]	@ (34196b6c <_tx_queue_send+0x24c>)
34196b34:	6013      	str	r3, [r2, #0]
34196b36:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34196b38:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34196b3a:	697b      	ldr	r3, [r7, #20]
34196b3c:	f383 8810 	msr	PRIMASK, r3
}
34196b40:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Call actual thread suspension routine.  */
            _tx_thread_system_suspend(thread_ptr);
34196b42:	6b78      	ldr	r0, [r7, #52]	@ 0x34
34196b44:	f000 ff9e 	bl	34197a84 <_tx_thread_system_suspend>
                }
            }
#endif

            /* Return the completion status.  */
            status =  thread_ptr -> tx_thread_suspend_status;
34196b48:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34196b4a:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
34196b4e:	643b      	str	r3, [r7, #64]	@ 0x40
34196b50:	e007      	b.n	34196b62 <_tx_queue_send+0x242>
34196b52:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34196b54:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34196b56:	693b      	ldr	r3, [r7, #16]
34196b58:	f383 8810 	msr	PRIMASK, r3
}
34196b5c:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Return error completion.  */
        status =  TX_QUEUE_FULL;
34196b5e:	230b      	movs	r3, #11
34196b60:	643b      	str	r3, [r7, #64]	@ 0x40
    }

    /* Return completion status.  */
    return(status);
34196b62:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
}
34196b64:	4618      	mov	r0, r3
34196b66:	3750      	adds	r7, #80	@ 0x50
34196b68:	46bd      	mov	sp, r7
34196b6a:	bd80      	pop	{r7, pc}
34196b6c:	341c2e84 	.word	0x341c2e84
34196b70:	341c2dec 	.word	0x341c2dec
34196b74:	341963a1 	.word	0x341963a1

34196b78 <_tx_semaphore_cleanup>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_semaphore_cleanup(TX_THREAD *thread_ptr, ULONG suspension_sequence)
{
34196b78:	b580      	push	{r7, lr}
34196b7a:	b08e      	sub	sp, #56	@ 0x38
34196b7c:	af00      	add	r7, sp, #0
34196b7e:	6078      	str	r0, [r7, #4]
34196b80:	6039      	str	r1, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34196b82:	f3ef 8310 	mrs	r3, PRIMASK
34196b86:	623b      	str	r3, [r7, #32]
    return(posture);
34196b88:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
34196b8a:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
34196b8c:	b672      	cpsid	i
    return(int_posture);
34196b8e:	69fb      	ldr	r3, [r7, #28]


#ifndef TX_NOT_INTERRUPTABLE

    /* Disable interrupts to remove the suspended thread from the semaphore.  */
    TX_DISABLE
34196b90:	637b      	str	r3, [r7, #52]	@ 0x34

    /* Determine if the cleanup is still required.  */
    if (thread_ptr -> tx_thread_suspend_cleanup == &(_tx_semaphore_cleanup))
34196b92:	687b      	ldr	r3, [r7, #4]
34196b94:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
34196b96:	4a33      	ldr	r2, [pc, #204]	@ (34196c64 <_tx_semaphore_cleanup+0xec>)
34196b98:	4293      	cmp	r3, r2
34196b9a:	d158      	bne.n	34196c4e <_tx_semaphore_cleanup+0xd6>
    {

        /* Check for valid suspension sequence.  */
        if (suspension_sequence == thread_ptr -> tx_thread_suspension_sequence)
34196b9c:	687b      	ldr	r3, [r7, #4]
34196b9e:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
34196ba2:	683a      	ldr	r2, [r7, #0]
34196ba4:	429a      	cmp	r2, r3
34196ba6:	d152      	bne.n	34196c4e <_tx_semaphore_cleanup+0xd6>
        {

            /* Setup pointer to semaphore control block.  */
            semaphore_ptr =  TX_VOID_TO_SEMAPHORE_POINTER_CONVERT(thread_ptr -> tx_thread_suspend_control_block);
34196ba8:	687b      	ldr	r3, [r7, #4]
34196baa:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
34196bac:	633b      	str	r3, [r7, #48]	@ 0x30

            /* Check for a NULL semaphore pointer.  */
            if (semaphore_ptr != TX_NULL)
34196bae:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34196bb0:	2b00      	cmp	r3, #0
34196bb2:	d04c      	beq.n	34196c4e <_tx_semaphore_cleanup+0xd6>
            {

                /* Check for a valid semaphore ID.  */
                if (semaphore_ptr -> tx_semaphore_id == TX_SEMAPHORE_ID)
34196bb4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34196bb6:	681b      	ldr	r3, [r3, #0]
34196bb8:	4a2b      	ldr	r2, [pc, #172]	@ (34196c68 <_tx_semaphore_cleanup+0xf0>)
34196bba:	4293      	cmp	r3, r2
34196bbc:	d147      	bne.n	34196c4e <_tx_semaphore_cleanup+0xd6>
                {

                    /* Determine if there are any thread suspensions.  */
                    if (semaphore_ptr -> tx_semaphore_suspended_count != TX_NO_SUSPENSIONS)
34196bbe:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34196bc0:	691b      	ldr	r3, [r3, #16]
34196bc2:	2b00      	cmp	r3, #0
34196bc4:	d043      	beq.n	34196c4e <_tx_semaphore_cleanup+0xd6>
#endif

                        /* Yes, we still have thread suspension!  */

                        /* Clear the suspension cleanup flag.  */
                        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
34196bc6:	687b      	ldr	r3, [r7, #4]
34196bc8:	2200      	movs	r2, #0
34196bca:	669a      	str	r2, [r3, #104]	@ 0x68

                        /* Decrement the suspended count.  */
                        semaphore_ptr -> tx_semaphore_suspended_count--;
34196bcc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34196bce:	691b      	ldr	r3, [r3, #16]
34196bd0:	1e5a      	subs	r2, r3, #1
34196bd2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34196bd4:	611a      	str	r2, [r3, #16]

                        /* Pickup the suspended count.  */
                        suspended_count =  semaphore_ptr -> tx_semaphore_suspended_count;
34196bd6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34196bd8:	691b      	ldr	r3, [r3, #16]
34196bda:	62fb      	str	r3, [r7, #44]	@ 0x2c

                        /* Remove the suspended thread from the list.  */

                        /* See if this is the only suspended thread on the list.  */
                        if (suspended_count == TX_NO_SUSPENSIONS)
34196bdc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34196bde:	2b00      	cmp	r3, #0
34196be0:	d103      	bne.n	34196bea <_tx_semaphore_cleanup+0x72>
                        {

                            /* Yes, the only suspended thread.  */

                            /* Update the head pointer.  */
                            semaphore_ptr -> tx_semaphore_suspension_list =  TX_NULL;
34196be2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34196be4:	2200      	movs	r2, #0
34196be6:	60da      	str	r2, [r3, #12]
34196be8:	e013      	b.n	34196c12 <_tx_semaphore_cleanup+0x9a>
                        {

                            /* At least one more thread is on the same suspension list.  */

                            /* Update the links of the adjacent threads.  */
                            next_thread =                                   thread_ptr -> tx_thread_suspended_next;
34196bea:	687b      	ldr	r3, [r7, #4]
34196bec:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34196bee:	62bb      	str	r3, [r7, #40]	@ 0x28
                            previous_thread =                               thread_ptr -> tx_thread_suspended_previous;
34196bf0:	687b      	ldr	r3, [r7, #4]
34196bf2:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34196bf4:	627b      	str	r3, [r7, #36]	@ 0x24
                            next_thread -> tx_thread_suspended_previous =   previous_thread;
34196bf6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34196bf8:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
34196bfa:	675a      	str	r2, [r3, #116]	@ 0x74
                            previous_thread -> tx_thread_suspended_next =   next_thread;
34196bfc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34196bfe:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34196c00:	671a      	str	r2, [r3, #112]	@ 0x70

                            /* Determine if we need to update the head pointer.  */
                            if (semaphore_ptr -> tx_semaphore_suspension_list == thread_ptr)
34196c02:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34196c04:	68db      	ldr	r3, [r3, #12]
34196c06:	687a      	ldr	r2, [r7, #4]
34196c08:	429a      	cmp	r2, r3
34196c0a:	d102      	bne.n	34196c12 <_tx_semaphore_cleanup+0x9a>
                            {

                                /* Update the list head pointer.  */
                                semaphore_ptr -> tx_semaphore_suspension_list =   next_thread;
34196c0c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34196c0e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34196c10:	60da      	str	r2, [r3, #12]
                            }
                        }

                        /* Now we need to determine if this cleanup is from a terminate, timeout,
                           or from a wait abort.  */
                        if (thread_ptr -> tx_thread_state == TX_SEMAPHORE_SUSP)
34196c12:	687b      	ldr	r3, [r7, #4]
34196c14:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34196c16:	2b06      	cmp	r3, #6
34196c18:	d119      	bne.n	34196c4e <_tx_semaphore_cleanup+0xd6>
                            /* Increment the number of timeouts on this semaphore.  */
                            semaphore_ptr -> tx_semaphore_performance_timeout_count++;
#endif

                            /* Setup return status.  */
                            thread_ptr -> tx_thread_suspend_status =  TX_NO_INSTANCE;
34196c1a:	687b      	ldr	r3, [r7, #4]
34196c1c:	220d      	movs	r2, #13
34196c1e:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
                            /* Resume the thread!  */
                            _tx_thread_system_ni_resume(thread_ptr);
#else

                            /* Temporarily disable preemption.  */
                            _tx_thread_preempt_disable++;
34196c22:	4b12      	ldr	r3, [pc, #72]	@ (34196c6c <_tx_semaphore_cleanup+0xf4>)
34196c24:	681b      	ldr	r3, [r3, #0]
34196c26:	3301      	adds	r3, #1
34196c28:	4a10      	ldr	r2, [pc, #64]	@ (34196c6c <_tx_semaphore_cleanup+0xf4>)
34196c2a:	6013      	str	r3, [r2, #0]
34196c2c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34196c2e:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34196c30:	693b      	ldr	r3, [r7, #16]
34196c32:	f383 8810 	msr	PRIMASK, r3
}
34196c36:	bf00      	nop

                            /* Restore interrupts.  */
                            TX_RESTORE

                            /* Resume the thread!  */
                            _tx_thread_system_resume(thread_ptr);
34196c38:	6878      	ldr	r0, [r7, #4]
34196c3a:	f000 fe23 	bl	34197884 <_tx_thread_system_resume>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34196c3e:	f3ef 8310 	mrs	r3, PRIMASK
34196c42:	61bb      	str	r3, [r7, #24]
    return(posture);
34196c44:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
34196c46:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
34196c48:	b672      	cpsid	i
    return(int_posture);
34196c4a:	697b      	ldr	r3, [r7, #20]

                            /* Disable interrupts.  */
                            TX_DISABLE
34196c4c:	637b      	str	r3, [r7, #52]	@ 0x34
34196c4e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34196c50:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34196c52:	68fb      	ldr	r3, [r7, #12]
34196c54:	f383 8810 	msr	PRIMASK, r3
}
34196c58:	bf00      	nop
    }

    /* Restore interrupts.  */
    TX_RESTORE
#endif
}
34196c5a:	bf00      	nop
34196c5c:	3738      	adds	r7, #56	@ 0x38
34196c5e:	46bd      	mov	sp, r7
34196c60:	bd80      	pop	{r7, pc}
34196c62:	bf00      	nop
34196c64:	34196b79 	.word	0x34196b79
34196c68:	53454d41 	.word	0x53454d41
34196c6c:	341c2e84 	.word	0x341c2e84

34196c70 <_tx_semaphore_create>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_semaphore_create(TX_SEMAPHORE *semaphore_ptr, CHAR *name_ptr, ULONG initial_count)
{
34196c70:	b580      	push	{r7, lr}
34196c72:	b08a      	sub	sp, #40	@ 0x28
34196c74:	af00      	add	r7, sp, #0
34196c76:	60f8      	str	r0, [r7, #12]
34196c78:	60b9      	str	r1, [r7, #8]
34196c7a:	607a      	str	r2, [r7, #4]
TX_SEMAPHORE    *next_semaphore;
TX_SEMAPHORE    *previous_semaphore;


    /* Initialize semaphore control block to all zeros.  */
    TX_MEMSET(semaphore_ptr, 0, (sizeof(TX_SEMAPHORE)));
34196c7c:	221c      	movs	r2, #28
34196c7e:	2100      	movs	r1, #0
34196c80:	68f8      	ldr	r0, [r7, #12]
34196c82:	f007 fa1d 	bl	3419e0c0 <memset>

    /* Setup the basic semaphore fields.  */
    semaphore_ptr -> tx_semaphore_name =             name_ptr;
34196c86:	68fb      	ldr	r3, [r7, #12]
34196c88:	68ba      	ldr	r2, [r7, #8]
34196c8a:	605a      	str	r2, [r3, #4]
    semaphore_ptr -> tx_semaphore_count =            initial_count;
34196c8c:	68fb      	ldr	r3, [r7, #12]
34196c8e:	687a      	ldr	r2, [r7, #4]
34196c90:	609a      	str	r2, [r3, #8]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34196c92:	f3ef 8310 	mrs	r3, PRIMASK
34196c96:	61bb      	str	r3, [r7, #24]
    return(posture);
34196c98:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
34196c9a:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
34196c9c:	b672      	cpsid	i
    return(int_posture);
34196c9e:	697b      	ldr	r3, [r7, #20]

    /* Disable interrupts to place the semaphore on the created list.  */
    TX_DISABLE
34196ca0:	627b      	str	r3, [r7, #36]	@ 0x24

    /* Setup the semaphore ID to make it valid.  */
    semaphore_ptr -> tx_semaphore_id =  TX_SEMAPHORE_ID;
34196ca2:	68fb      	ldr	r3, [r7, #12]
34196ca4:	4a18      	ldr	r2, [pc, #96]	@ (34196d08 <_tx_semaphore_create+0x98>)
34196ca6:	601a      	str	r2, [r3, #0]

    /* Place the semaphore on the list of created semaphores.  First,
       check for an empty list.  */
    if (_tx_semaphore_created_count == TX_EMPTY)
34196ca8:	4b18      	ldr	r3, [pc, #96]	@ (34196d0c <_tx_semaphore_create+0x9c>)
34196caa:	681b      	ldr	r3, [r3, #0]
34196cac:	2b00      	cmp	r3, #0
34196cae:	d109      	bne.n	34196cc4 <_tx_semaphore_create+0x54>
    {

        /* The created semaphore list is empty.  Add semaphore to empty list.  */
        _tx_semaphore_created_ptr =                       semaphore_ptr;
34196cb0:	4a17      	ldr	r2, [pc, #92]	@ (34196d10 <_tx_semaphore_create+0xa0>)
34196cb2:	68fb      	ldr	r3, [r7, #12]
34196cb4:	6013      	str	r3, [r2, #0]
        semaphore_ptr -> tx_semaphore_created_next =      semaphore_ptr;
34196cb6:	68fb      	ldr	r3, [r7, #12]
34196cb8:	68fa      	ldr	r2, [r7, #12]
34196cba:	615a      	str	r2, [r3, #20]
        semaphore_ptr -> tx_semaphore_created_previous =  semaphore_ptr;
34196cbc:	68fb      	ldr	r3, [r7, #12]
34196cbe:	68fa      	ldr	r2, [r7, #12]
34196cc0:	619a      	str	r2, [r3, #24]
34196cc2:	e011      	b.n	34196ce8 <_tx_semaphore_create+0x78>
    }
    else
    {

        /* This list is not NULL, add to the end of the list.  */
        next_semaphore =      _tx_semaphore_created_ptr;
34196cc4:	4b12      	ldr	r3, [pc, #72]	@ (34196d10 <_tx_semaphore_create+0xa0>)
34196cc6:	681b      	ldr	r3, [r3, #0]
34196cc8:	623b      	str	r3, [r7, #32]
        previous_semaphore =  next_semaphore -> tx_semaphore_created_previous;
34196cca:	6a3b      	ldr	r3, [r7, #32]
34196ccc:	699b      	ldr	r3, [r3, #24]
34196cce:	61fb      	str	r3, [r7, #28]

        /* Place the new semaphore in the list.  */
        next_semaphore -> tx_semaphore_created_previous =  semaphore_ptr;
34196cd0:	6a3b      	ldr	r3, [r7, #32]
34196cd2:	68fa      	ldr	r2, [r7, #12]
34196cd4:	619a      	str	r2, [r3, #24]
        previous_semaphore -> tx_semaphore_created_next =  semaphore_ptr;
34196cd6:	69fb      	ldr	r3, [r7, #28]
34196cd8:	68fa      	ldr	r2, [r7, #12]
34196cda:	615a      	str	r2, [r3, #20]

        /* Setup this semaphore's next and previous created links.  */
        semaphore_ptr -> tx_semaphore_created_previous =  previous_semaphore;
34196cdc:	68fb      	ldr	r3, [r7, #12]
34196cde:	69fa      	ldr	r2, [r7, #28]
34196ce0:	619a      	str	r2, [r3, #24]
        semaphore_ptr -> tx_semaphore_created_next =      next_semaphore;
34196ce2:	68fb      	ldr	r3, [r7, #12]
34196ce4:	6a3a      	ldr	r2, [r7, #32]
34196ce6:	615a      	str	r2, [r3, #20]
    }

    /* Increment the created count.  */
    _tx_semaphore_created_count++;
34196ce8:	4b08      	ldr	r3, [pc, #32]	@ (34196d0c <_tx_semaphore_create+0x9c>)
34196cea:	681b      	ldr	r3, [r3, #0]
34196cec:	3301      	adds	r3, #1
34196cee:	4a07      	ldr	r2, [pc, #28]	@ (34196d0c <_tx_semaphore_create+0x9c>)
34196cf0:	6013      	str	r3, [r2, #0]
34196cf2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34196cf4:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34196cf6:	693b      	ldr	r3, [r7, #16]
34196cf8:	f383 8810 	msr	PRIMASK, r3
}
34196cfc:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
34196cfe:	2300      	movs	r3, #0
}
34196d00:	4618      	mov	r0, r3
34196d02:	3728      	adds	r7, #40	@ 0x28
34196d04:	46bd      	mov	sp, r7
34196d06:	bd80      	pop	{r7, pc}
34196d08:	53454d41 	.word	0x53454d41
34196d0c:	341c2db8 	.word	0x341c2db8
34196d10:	341c2db4 	.word	0x341c2db4

34196d14 <_tx_semaphore_delete>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_semaphore_delete(TX_SEMAPHORE *semaphore_ptr)
{
34196d14:	b580      	push	{r7, lr}
34196d16:	b092      	sub	sp, #72	@ 0x48
34196d18:	af00      	add	r7, sp, #0
34196d1a:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34196d1c:	f3ef 8310 	mrs	r3, PRIMASK
34196d20:	62fb      	str	r3, [r7, #44]	@ 0x2c
    return(posture);
34196d22:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
    int_posture = __get_interrupt_posture();
34196d24:	62bb      	str	r3, [r7, #40]	@ 0x28
    __asm__ volatile ("CPSID i" : : : "memory");
34196d26:	b672      	cpsid	i
    return(int_posture);
34196d28:	6abb      	ldr	r3, [r7, #40]	@ 0x28
TX_SEMAPHORE    *next_semaphore;
TX_SEMAPHORE    *previous_semaphore;


    /* Disable interrupts to remove the semaphore from the created list.  */
    TX_DISABLE
34196d2a:	63fb      	str	r3, [r7, #60]	@ 0x3c

    /* Log this kernel call.  */
    TX_EL_SEMAPHORE_DELETE_INSERT

    /* Clear the semaphore ID to make it invalid.  */
    semaphore_ptr -> tx_semaphore_id =  TX_CLEAR_ID;
34196d2c:	687b      	ldr	r3, [r7, #4]
34196d2e:	2200      	movs	r2, #0
34196d30:	601a      	str	r2, [r3, #0]

    /* Decrement the number of semaphores.  */
    _tx_semaphore_created_count--;
34196d32:	4b3d      	ldr	r3, [pc, #244]	@ (34196e28 <_tx_semaphore_delete+0x114>)
34196d34:	681b      	ldr	r3, [r3, #0]
34196d36:	3b01      	subs	r3, #1
34196d38:	4a3b      	ldr	r2, [pc, #236]	@ (34196e28 <_tx_semaphore_delete+0x114>)
34196d3a:	6013      	str	r3, [r2, #0]

    /* See if the semaphore is the only one on the list.  */
    if (_tx_semaphore_created_count == TX_EMPTY)
34196d3c:	4b3a      	ldr	r3, [pc, #232]	@ (34196e28 <_tx_semaphore_delete+0x114>)
34196d3e:	681b      	ldr	r3, [r3, #0]
34196d40:	2b00      	cmp	r3, #0
34196d42:	d103      	bne.n	34196d4c <_tx_semaphore_delete+0x38>
    {

        /* Only created semaphore, just set the created list to NULL.  */
        _tx_semaphore_created_ptr =  TX_NULL;
34196d44:	4b39      	ldr	r3, [pc, #228]	@ (34196e2c <_tx_semaphore_delete+0x118>)
34196d46:	2200      	movs	r2, #0
34196d48:	601a      	str	r2, [r3, #0]
34196d4a:	e013      	b.n	34196d74 <_tx_semaphore_delete+0x60>
    }
    else
    {

        /* Link-up the neighbors.  */
        next_semaphore =                                   semaphore_ptr -> tx_semaphore_created_next;
34196d4c:	687b      	ldr	r3, [r7, #4]
34196d4e:	695b      	ldr	r3, [r3, #20]
34196d50:	63bb      	str	r3, [r7, #56]	@ 0x38
        previous_semaphore =                               semaphore_ptr -> tx_semaphore_created_previous;
34196d52:	687b      	ldr	r3, [r7, #4]
34196d54:	699b      	ldr	r3, [r3, #24]
34196d56:	637b      	str	r3, [r7, #52]	@ 0x34
        next_semaphore -> tx_semaphore_created_previous =  previous_semaphore;
34196d58:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34196d5a:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
34196d5c:	619a      	str	r2, [r3, #24]
        previous_semaphore -> tx_semaphore_created_next =  next_semaphore;
34196d5e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34196d60:	6bba      	ldr	r2, [r7, #56]	@ 0x38
34196d62:	615a      	str	r2, [r3, #20]

        /* See if we have to update the created list head pointer.  */
        if (_tx_semaphore_created_ptr == semaphore_ptr)
34196d64:	4b31      	ldr	r3, [pc, #196]	@ (34196e2c <_tx_semaphore_delete+0x118>)
34196d66:	681b      	ldr	r3, [r3, #0]
34196d68:	687a      	ldr	r2, [r7, #4]
34196d6a:	429a      	cmp	r2, r3
34196d6c:	d102      	bne.n	34196d74 <_tx_semaphore_delete+0x60>
        {

            /* Yes, move the head pointer to the next link. */
            _tx_semaphore_created_ptr =  next_semaphore;
34196d6e:	4a2f      	ldr	r2, [pc, #188]	@ (34196e2c <_tx_semaphore_delete+0x118>)
34196d70:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34196d72:	6013      	str	r3, [r2, #0]
        }
    }

    /* Temporarily disable preemption.  */
    _tx_thread_preempt_disable++;
34196d74:	4b2e      	ldr	r3, [pc, #184]	@ (34196e30 <_tx_semaphore_delete+0x11c>)
34196d76:	681b      	ldr	r3, [r3, #0]
34196d78:	3301      	adds	r3, #1
34196d7a:	4a2d      	ldr	r2, [pc, #180]	@ (34196e30 <_tx_semaphore_delete+0x11c>)
34196d7c:	6013      	str	r3, [r2, #0]

    /* Pickup the suspension information.  */
    thread_ptr =                                     semaphore_ptr -> tx_semaphore_suspension_list;
34196d7e:	687b      	ldr	r3, [r7, #4]
34196d80:	68db      	ldr	r3, [r3, #12]
34196d82:	647b      	str	r3, [r7, #68]	@ 0x44
    semaphore_ptr -> tx_semaphore_suspension_list =  TX_NULL;
34196d84:	687b      	ldr	r3, [r7, #4]
34196d86:	2200      	movs	r2, #0
34196d88:	60da      	str	r2, [r3, #12]
    suspended_count =                                semaphore_ptr -> tx_semaphore_suspended_count;
34196d8a:	687b      	ldr	r3, [r7, #4]
34196d8c:	691b      	ldr	r3, [r3, #16]
34196d8e:	643b      	str	r3, [r7, #64]	@ 0x40
    semaphore_ptr -> tx_semaphore_suspended_count =  TX_NO_SUSPENSIONS;
34196d90:	687b      	ldr	r3, [r7, #4]
34196d92:	2200      	movs	r2, #0
34196d94:	611a      	str	r2, [r3, #16]
34196d96:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34196d98:	627b      	str	r3, [r7, #36]	@ 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34196d9a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34196d9c:	f383 8810 	msr	PRIMASK, r3
}
34196da0:	bf00      	nop
    /* Restore interrupts.  */
    TX_RESTORE

    /* Walk through the semaphore list to resume any and all threads suspended
       on this semaphore.  */
    while (suspended_count != TX_NO_SUSPENSIONS)
34196da2:	e024      	b.n	34196dee <_tx_semaphore_delete+0xda>
    {

        /* Decrement the suspension count.  */
        suspended_count--;
34196da4:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34196da6:	3b01      	subs	r3, #1
34196da8:	643b      	str	r3, [r7, #64]	@ 0x40
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34196daa:	f3ef 8310 	mrs	r3, PRIMASK
34196dae:	61fb      	str	r3, [r7, #28]
    return(posture);
34196db0:	69fb      	ldr	r3, [r7, #28]
    int_posture = __get_interrupt_posture();
34196db2:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("CPSID i" : : : "memory");
34196db4:	b672      	cpsid	i
    return(int_posture);
34196db6:	69bb      	ldr	r3, [r7, #24]

        /* Lockout interrupts.  */
        TX_DISABLE
34196db8:	63fb      	str	r3, [r7, #60]	@ 0x3c

        /* Clear the cleanup pointer, this prevents the timeout from doing
           anything.  */
        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
34196dba:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34196dbc:	2200      	movs	r2, #0
34196dbe:	669a      	str	r2, [r3, #104]	@ 0x68

        /* Set the return status in the thread to TX_DELETED.  */
        thread_ptr -> tx_thread_suspend_status =  TX_DELETED;
34196dc0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34196dc2:	2201      	movs	r2, #1
34196dc4:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84

        /* Move the thread pointer ahead.  */
        next_thread =  thread_ptr -> tx_thread_suspended_next;
34196dc8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34196dca:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34196dcc:	633b      	str	r3, [r7, #48]	@ 0x30
        /* Restore interrupts.  */
        TX_RESTORE
#else

        /* Temporarily disable preemption again.  */
        _tx_thread_preempt_disable++;
34196dce:	4b18      	ldr	r3, [pc, #96]	@ (34196e30 <_tx_semaphore_delete+0x11c>)
34196dd0:	681b      	ldr	r3, [r3, #0]
34196dd2:	3301      	adds	r3, #1
34196dd4:	4a16      	ldr	r2, [pc, #88]	@ (34196e30 <_tx_semaphore_delete+0x11c>)
34196dd6:	6013      	str	r3, [r2, #0]
34196dd8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34196dda:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34196ddc:	6a3b      	ldr	r3, [r7, #32]
34196dde:	f383 8810 	msr	PRIMASK, r3
}
34196de2:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Resume the thread.  */
        _tx_thread_system_resume(thread_ptr);
34196de4:	6c78      	ldr	r0, [r7, #68]	@ 0x44
34196de6:	f000 fd4d 	bl	34197884 <_tx_thread_system_resume>
#endif

        /* Move to next thread.  */
        thread_ptr =  next_thread;
34196dea:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34196dec:	647b      	str	r3, [r7, #68]	@ 0x44
    while (suspended_count != TX_NO_SUSPENSIONS)
34196dee:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34196df0:	2b00      	cmp	r3, #0
34196df2:	d1d7      	bne.n	34196da4 <_tx_semaphore_delete+0x90>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34196df4:	f3ef 8310 	mrs	r3, PRIMASK
34196df8:	613b      	str	r3, [r7, #16]
    return(posture);
34196dfa:	693b      	ldr	r3, [r7, #16]
    int_posture = __get_interrupt_posture();
34196dfc:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("CPSID i" : : : "memory");
34196dfe:	b672      	cpsid	i
    return(int_posture);
34196e00:	68fb      	ldr	r3, [r7, #12]

    /* Execute Port-Specific completion processing. If needed, it is typically defined in tx_port.h.  */
    TX_SEMAPHORE_DELETE_PORT_COMPLETION(semaphore_ptr)

    /* Disable interrupts.  */
    TX_DISABLE
34196e02:	63fb      	str	r3, [r7, #60]	@ 0x3c

    /* Release previous preempt disable.  */
    _tx_thread_preempt_disable--;
34196e04:	4b0a      	ldr	r3, [pc, #40]	@ (34196e30 <_tx_semaphore_delete+0x11c>)
34196e06:	681b      	ldr	r3, [r3, #0]
34196e08:	3b01      	subs	r3, #1
34196e0a:	4a09      	ldr	r2, [pc, #36]	@ (34196e30 <_tx_semaphore_delete+0x11c>)
34196e0c:	6013      	str	r3, [r2, #0]
34196e0e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34196e10:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34196e12:	697b      	ldr	r3, [r7, #20]
34196e14:	f383 8810 	msr	PRIMASK, r3
}
34196e18:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Check for preemption.  */
    _tx_thread_system_preempt_check();
34196e1a:	f000 fcf9 	bl	34197810 <_tx_thread_system_preempt_check>

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
34196e1e:	2300      	movs	r3, #0
}
34196e20:	4618      	mov	r0, r3
34196e22:	3748      	adds	r7, #72	@ 0x48
34196e24:	46bd      	mov	sp, r7
34196e26:	bd80      	pop	{r7, pc}
34196e28:	341c2db8 	.word	0x341c2db8
34196e2c:	341c2db4 	.word	0x341c2db4
34196e30:	341c2e84 	.word	0x341c2e84

34196e34 <_tx_semaphore_get>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_semaphore_get(TX_SEMAPHORE *semaphore_ptr, ULONG wait_option)
{
34196e34:	b580      	push	{r7, lr}
34196e36:	b08e      	sub	sp, #56	@ 0x38
34196e38:	af00      	add	r7, sp, #0
34196e3a:	6078      	str	r0, [r7, #4]
34196e3c:	6039      	str	r1, [r7, #0]
TX_THREAD       *previous_thread;
UINT            status;


    /* Default the status to TX_SUCCESS.  */
    status =  TX_SUCCESS;
34196e3e:	2300      	movs	r3, #0
34196e40:	637b      	str	r3, [r7, #52]	@ 0x34
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34196e42:	f3ef 8310 	mrs	r3, PRIMASK
34196e46:	623b      	str	r3, [r7, #32]
    return(posture);
34196e48:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
34196e4a:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
34196e4c:	b672      	cpsid	i
    return(int_posture);
34196e4e:	69fb      	ldr	r3, [r7, #28]

    /* Disable interrupts to get an instance from the semaphore.  */
    TX_DISABLE
34196e50:	633b      	str	r3, [r7, #48]	@ 0x30

    /* Log this kernel call.  */
    TX_EL_SEMAPHORE_GET_INSERT

    /* Determine if there is an instance of the semaphore.  */
    if (semaphore_ptr -> tx_semaphore_count != ((ULONG) 0))
34196e52:	687b      	ldr	r3, [r7, #4]
34196e54:	689b      	ldr	r3, [r3, #8]
34196e56:	2b00      	cmp	r3, #0
34196e58:	d00a      	beq.n	34196e70 <_tx_semaphore_get+0x3c>
    {

        /* Decrement the semaphore count.  */
        semaphore_ptr -> tx_semaphore_count--;
34196e5a:	687b      	ldr	r3, [r7, #4]
34196e5c:	689b      	ldr	r3, [r3, #8]
34196e5e:	1e5a      	subs	r2, r3, #1
34196e60:	687b      	ldr	r3, [r7, #4]
34196e62:	609a      	str	r2, [r3, #8]
34196e64:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34196e66:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34196e68:	69bb      	ldr	r3, [r7, #24]
34196e6a:	f383 8810 	msr	PRIMASK, r3
}
34196e6e:	e068      	b.n	34196f42 <_tx_semaphore_get+0x10e>
        /* Restore interrupts.  */
        TX_RESTORE
    }

    /* Determine if the request specifies suspension.  */
    else if (wait_option != TX_NO_WAIT)
34196e70:	683b      	ldr	r3, [r7, #0]
34196e72:	2b00      	cmp	r3, #0
34196e74:	d05d      	beq.n	34196f32 <_tx_semaphore_get+0xfe>
    {

        /* Determine if the preempt disable flag is non-zero.  */
        if (_tx_thread_preempt_disable != ((UINT) 0))
34196e76:	4b35      	ldr	r3, [pc, #212]	@ (34196f4c <_tx_semaphore_get+0x118>)
34196e78:	681b      	ldr	r3, [r3, #0]
34196e7a:	2b00      	cmp	r3, #0
34196e7c:	d008      	beq.n	34196e90 <_tx_semaphore_get+0x5c>
34196e7e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34196e80:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34196e82:	697b      	ldr	r3, [r7, #20]
34196e84:	f383 8810 	msr	PRIMASK, r3
}
34196e88:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Suspension is not allowed if the preempt disable flag is non-zero at this point - return error completion.  */
            status =  TX_NO_INSTANCE;
34196e8a:	230d      	movs	r3, #13
34196e8c:	637b      	str	r3, [r7, #52]	@ 0x34
34196e8e:	e058      	b.n	34196f42 <_tx_semaphore_get+0x10e>
            /* Increment the number of suspensions on this semaphore.  */
            semaphore_ptr -> tx_semaphore_performance_suspension_count++;
#endif

            /* Pickup thread pointer.  */
            TX_THREAD_GET_CURRENT(thread_ptr)
34196e90:	4b2f      	ldr	r3, [pc, #188]	@ (34196f50 <_tx_semaphore_get+0x11c>)
34196e92:	681b      	ldr	r3, [r3, #0]
34196e94:	62fb      	str	r3, [r7, #44]	@ 0x2c

            /* Setup cleanup routine pointer.  */
            thread_ptr -> tx_thread_suspend_cleanup =  &(_tx_semaphore_cleanup);
34196e96:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34196e98:	4a2e      	ldr	r2, [pc, #184]	@ (34196f54 <_tx_semaphore_get+0x120>)
34196e9a:	669a      	str	r2, [r3, #104]	@ 0x68

            /* Setup cleanup information, i.e. this semaphore control
               block.  */
            thread_ptr -> tx_thread_suspend_control_block =  (VOID *) semaphore_ptr;
34196e9c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34196e9e:	687a      	ldr	r2, [r7, #4]
34196ea0:	66da      	str	r2, [r3, #108]	@ 0x6c

#ifndef TX_NOT_INTERRUPTABLE

            /* Increment the suspension sequence number, which is used to identify
               this suspension event.  */
            thread_ptr -> tx_thread_suspension_sequence++;
34196ea2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34196ea4:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
34196ea8:	1c5a      	adds	r2, r3, #1
34196eaa:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34196eac:	f8c3 20ac 	str.w	r2, [r3, #172]	@ 0xac
#endif

            /* Setup suspension list.  */
            if (semaphore_ptr -> tx_semaphore_suspended_count == TX_NO_SUSPENSIONS)
34196eb0:	687b      	ldr	r3, [r7, #4]
34196eb2:	691b      	ldr	r3, [r3, #16]
34196eb4:	2b00      	cmp	r3, #0
34196eb6:	d109      	bne.n	34196ecc <_tx_semaphore_get+0x98>
            {

                /* No other threads are suspended.  Setup the head pointer and
                   just setup this threads pointers to itself.  */
                semaphore_ptr -> tx_semaphore_suspension_list =         thread_ptr;
34196eb8:	687b      	ldr	r3, [r7, #4]
34196eba:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
34196ebc:	60da      	str	r2, [r3, #12]
                thread_ptr -> tx_thread_suspended_next =                thread_ptr;
34196ebe:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34196ec0:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
34196ec2:	671a      	str	r2, [r3, #112]	@ 0x70
                thread_ptr -> tx_thread_suspended_previous =            thread_ptr;
34196ec4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34196ec6:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
34196ec8:	675a      	str	r2, [r3, #116]	@ 0x74
34196eca:	e011      	b.n	34196ef0 <_tx_semaphore_get+0xbc>
            }
            else
            {

                /* This list is not NULL, add current thread to the end. */
                next_thread =                                   semaphore_ptr -> tx_semaphore_suspension_list;
34196ecc:	687b      	ldr	r3, [r7, #4]
34196ece:	68db      	ldr	r3, [r3, #12]
34196ed0:	62bb      	str	r3, [r7, #40]	@ 0x28
                thread_ptr -> tx_thread_suspended_next =        next_thread;
34196ed2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34196ed4:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34196ed6:	671a      	str	r2, [r3, #112]	@ 0x70
                previous_thread =                               next_thread -> tx_thread_suspended_previous;
34196ed8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34196eda:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34196edc:	627b      	str	r3, [r7, #36]	@ 0x24
                thread_ptr -> tx_thread_suspended_previous =    previous_thread;
34196ede:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34196ee0:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
34196ee2:	675a      	str	r2, [r3, #116]	@ 0x74
                previous_thread -> tx_thread_suspended_next =   thread_ptr;
34196ee4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34196ee6:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
34196ee8:	671a      	str	r2, [r3, #112]	@ 0x70
                next_thread -> tx_thread_suspended_previous =   thread_ptr;
34196eea:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34196eec:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
34196eee:	675a      	str	r2, [r3, #116]	@ 0x74
            }

            /* Increment the number of suspensions.  */
            semaphore_ptr -> tx_semaphore_suspended_count++;
34196ef0:	687b      	ldr	r3, [r7, #4]
34196ef2:	691b      	ldr	r3, [r3, #16]
34196ef4:	1c5a      	adds	r2, r3, #1
34196ef6:	687b      	ldr	r3, [r7, #4]
34196ef8:	611a      	str	r2, [r3, #16]

            /* Set the state to suspended.  */
            thread_ptr -> tx_thread_state =    TX_SEMAPHORE_SUSP;
34196efa:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34196efc:	2206      	movs	r2, #6
34196efe:	631a      	str	r2, [r3, #48]	@ 0x30
            /* Restore interrupts.  */
            TX_RESTORE
#else

            /* Set the suspending flag.  */
            thread_ptr -> tx_thread_suspending =  TX_TRUE;
34196f00:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34196f02:	2201      	movs	r2, #1
34196f04:	639a      	str	r2, [r3, #56]	@ 0x38

            /* Setup the timeout period.  */
            thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  wait_option;
34196f06:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34196f08:	683a      	ldr	r2, [r7, #0]
34196f0a:	64da      	str	r2, [r3, #76]	@ 0x4c

            /* Temporarily disable preemption.  */
            _tx_thread_preempt_disable++;
34196f0c:	4b0f      	ldr	r3, [pc, #60]	@ (34196f4c <_tx_semaphore_get+0x118>)
34196f0e:	681b      	ldr	r3, [r3, #0]
34196f10:	3301      	adds	r3, #1
34196f12:	4a0e      	ldr	r2, [pc, #56]	@ (34196f4c <_tx_semaphore_get+0x118>)
34196f14:	6013      	str	r3, [r2, #0]
34196f16:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34196f18:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34196f1a:	693b      	ldr	r3, [r7, #16]
34196f1c:	f383 8810 	msr	PRIMASK, r3
}
34196f20:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Call actual thread suspension routine.  */
            _tx_thread_system_suspend(thread_ptr);
34196f22:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
34196f24:	f000 fdae 	bl	34197a84 <_tx_thread_system_suspend>
#endif

            /* Return the completion status.  */
            status =  thread_ptr -> tx_thread_suspend_status;
34196f28:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34196f2a:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
34196f2e:	637b      	str	r3, [r7, #52]	@ 0x34
34196f30:	e007      	b.n	34196f42 <_tx_semaphore_get+0x10e>
34196f32:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34196f34:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34196f36:	68fb      	ldr	r3, [r7, #12]
34196f38:	f383 8810 	msr	PRIMASK, r3
}
34196f3c:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Immediate return, return error completion.  */
        status =  TX_NO_INSTANCE;
34196f3e:	230d      	movs	r3, #13
34196f40:	637b      	str	r3, [r7, #52]	@ 0x34
    }

    /* Return completion status.  */
    return(status);
34196f42:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
}
34196f44:	4618      	mov	r0, r3
34196f46:	3738      	adds	r7, #56	@ 0x38
34196f48:	46bd      	mov	sp, r7
34196f4a:	bd80      	pop	{r7, pc}
34196f4c:	341c2e84 	.word	0x341c2e84
34196f50:	341c2dec 	.word	0x341c2dec
34196f54:	34196b79 	.word	0x34196b79

34196f58 <_tx_semaphore_put>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_semaphore_put(TX_SEMAPHORE *semaphore_ptr)
{
34196f58:	b580      	push	{r7, lr}
34196f5a:	b08c      	sub	sp, #48	@ 0x30
34196f5c:	af00      	add	r7, sp, #0
34196f5e:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34196f60:	f3ef 8310 	mrs	r3, PRIMASK
34196f64:	61bb      	str	r3, [r7, #24]
    return(posture);
34196f66:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
34196f68:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
34196f6a:	b672      	cpsid	i
    return(int_posture);
34196f6c:	697b      	ldr	r3, [r7, #20]
TX_THREAD       *next_thread;
TX_THREAD       *previous_thread;


    /* Disable interrupts to put an instance back to the semaphore.  */
    TX_DISABLE
34196f6e:	62fb      	str	r3, [r7, #44]	@ 0x2c

    /* Log this kernel call.  */
    TX_EL_SEMAPHORE_PUT_INSERT

    /* Pickup the number of suspended threads.  */
    suspended_count =  semaphore_ptr -> tx_semaphore_suspended_count;
34196f70:	687b      	ldr	r3, [r7, #4]
34196f72:	691b      	ldr	r3, [r3, #16]
34196f74:	62bb      	str	r3, [r7, #40]	@ 0x28

    /* Determine if there are any threads suspended on the semaphore.  */
    if (suspended_count == TX_NO_SUSPENSIONS)
34196f76:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34196f78:	2b00      	cmp	r3, #0
34196f7a:	d10a      	bne.n	34196f92 <_tx_semaphore_put+0x3a>
    {

        /* Increment the semaphore count.  */
        semaphore_ptr -> tx_semaphore_count++;
34196f7c:	687b      	ldr	r3, [r7, #4]
34196f7e:	689b      	ldr	r3, [r3, #8]
34196f80:	1c5a      	adds	r2, r3, #1
34196f82:	687b      	ldr	r3, [r7, #4]
34196f84:	609a      	str	r2, [r3, #8]
34196f86:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34196f88:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34196f8a:	693b      	ldr	r3, [r7, #16]
34196f8c:	f383 8810 	msr	PRIMASK, r3
}
34196f90:	e033      	b.n	34196ffa <_tx_semaphore_put+0xa2>
    {

        /* A thread is suspended on this semaphore.  */

        /* Pickup the pointer to the first suspended thread.  */
        thread_ptr =  semaphore_ptr -> tx_semaphore_suspension_list;
34196f92:	687b      	ldr	r3, [r7, #4]
34196f94:	68db      	ldr	r3, [r3, #12]
34196f96:	627b      	str	r3, [r7, #36]	@ 0x24

        /* Remove the suspended thread from the list.  */

        /* See if this is the only suspended thread on the list.  */
        suspended_count--;
34196f98:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34196f9a:	3b01      	subs	r3, #1
34196f9c:	62bb      	str	r3, [r7, #40]	@ 0x28
        if (suspended_count == TX_NO_SUSPENSIONS)
34196f9e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34196fa0:	2b00      	cmp	r3, #0
34196fa2:	d103      	bne.n	34196fac <_tx_semaphore_put+0x54>
        {

            /* Yes, the only suspended thread.  */

            /* Update the head pointer.  */
            semaphore_ptr -> tx_semaphore_suspension_list =  TX_NULL;
34196fa4:	687b      	ldr	r3, [r7, #4]
34196fa6:	2200      	movs	r2, #0
34196fa8:	60da      	str	r2, [r3, #12]
34196faa:	e00e      	b.n	34196fca <_tx_semaphore_put+0x72>
        {

            /* At least one more thread is on the same expiration list.  */

            /* Update the list head pointer.  */
            next_thread =                                     thread_ptr -> tx_thread_suspended_next;
34196fac:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34196fae:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34196fb0:	623b      	str	r3, [r7, #32]
            semaphore_ptr -> tx_semaphore_suspension_list =   next_thread;
34196fb2:	687b      	ldr	r3, [r7, #4]
34196fb4:	6a3a      	ldr	r2, [r7, #32]
34196fb6:	60da      	str	r2, [r3, #12]

            /* Update the links of the adjacent threads.  */
            previous_thread =                               thread_ptr -> tx_thread_suspended_previous;
34196fb8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34196fba:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34196fbc:	61fb      	str	r3, [r7, #28]
            next_thread -> tx_thread_suspended_previous =   previous_thread;
34196fbe:	6a3b      	ldr	r3, [r7, #32]
34196fc0:	69fa      	ldr	r2, [r7, #28]
34196fc2:	675a      	str	r2, [r3, #116]	@ 0x74
            previous_thread -> tx_thread_suspended_next =   next_thread;
34196fc4:	69fb      	ldr	r3, [r7, #28]
34196fc6:	6a3a      	ldr	r2, [r7, #32]
34196fc8:	671a      	str	r2, [r3, #112]	@ 0x70
        }

        /* Decrement the suspension count.  */
        semaphore_ptr -> tx_semaphore_suspended_count =  suspended_count;
34196fca:	687b      	ldr	r3, [r7, #4]
34196fcc:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34196fce:	611a      	str	r2, [r3, #16]

        /* Prepare for resumption of the first thread.  */

        /* Clear cleanup routine to avoid timeout.  */
        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
34196fd0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34196fd2:	2200      	movs	r2, #0
34196fd4:	669a      	str	r2, [r3, #104]	@ 0x68
        /* Pickup the application notify function.  */
        semaphore_put_notify =  semaphore_ptr -> tx_semaphore_put_notify;
#endif

        /* Put return status into the thread control block.  */
        thread_ptr -> tx_thread_suspend_status =  TX_SUCCESS;
34196fd6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34196fd8:	2200      	movs	r2, #0
34196fda:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
        /* Restore interrupts.  */
        TX_RESTORE
#else

        /* Temporarily disable preemption.  */
        _tx_thread_preempt_disable++;
34196fde:	4b09      	ldr	r3, [pc, #36]	@ (34197004 <_tx_semaphore_put+0xac>)
34196fe0:	681b      	ldr	r3, [r3, #0]
34196fe2:	3301      	adds	r3, #1
34196fe4:	4a07      	ldr	r2, [pc, #28]	@ (34197004 <_tx_semaphore_put+0xac>)
34196fe6:	6013      	str	r3, [r2, #0]
34196fe8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34196fea:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34196fec:	68fb      	ldr	r3, [r7, #12]
34196fee:	f383 8810 	msr	PRIMASK, r3
}
34196ff2:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Resume thread.  */
        _tx_thread_system_resume(thread_ptr);
34196ff4:	6a78      	ldr	r0, [r7, #36]	@ 0x24
34196ff6:	f000 fc45 	bl	34197884 <_tx_thread_system_resume>
        }
#endif
    }

    /* Return successful completion.  */
    return(TX_SUCCESS);
34196ffa:	2300      	movs	r3, #0
}
34196ffc:	4618      	mov	r0, r3
34196ffe:	3730      	adds	r7, #48	@ 0x30
34197000:	46bd      	mov	sp, r7
34197002:	bd80      	pop	{r7, pc}
34197004:	341c2e84 	.word	0x341c2e84

34197008 <_tx_thread_create>:
/*                                                                        */
/**************************************************************************/
UINT  _tx_thread_create(TX_THREAD *thread_ptr, CHAR *name_ptr, VOID (*entry_function)(ULONG id), ULONG entry_input,
                            VOID *stack_start, ULONG stack_size, UINT priority, UINT preempt_threshold,
                            ULONG time_slice, UINT auto_start)
{
34197008:	b580      	push	{r7, lr}
3419700a:	b092      	sub	sp, #72	@ 0x48
3419700c:	af00      	add	r7, sp, #0
3419700e:	60f8      	str	r0, [r7, #12]
34197010:	60b9      	str	r1, [r7, #8]
34197012:	607a      	str	r2, [r7, #4]
34197014:	603b      	str	r3, [r7, #0]
TX_INTERRUPT_SAVE_AREA

TX_THREAD               *next_thread;
TX_THREAD               *previous_thread;
TX_THREAD               *saved_thread_ptr;
UINT                    saved_threshold =  ((UINT) 0);
34197016:	2300      	movs	r3, #0
34197018:	643b      	str	r3, [r7, #64]	@ 0x40
#endif

    /* Set the thread stack to a pattern prior to creating the initial
       stack frame.  This pattern is used by the stack checking routines
       to see how much has been used.  */
    TX_MEMSET(stack_start, ((UCHAR) TX_STACK_FILL), stack_size);
3419701a:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
3419701c:	21ef      	movs	r1, #239	@ 0xef
3419701e:	6d38      	ldr	r0, [r7, #80]	@ 0x50
34197020:	f007 f84e 	bl	3419e0c0 <memset>

    /* Prepare the thread control block prior to placing it on the created
       list.  */

    /* Initialize thread control block to all zeros.  */
    TX_MEMSET(thread_ptr, 0, (sizeof(TX_THREAD)));
34197024:	22b0      	movs	r2, #176	@ 0xb0
34197026:	2100      	movs	r1, #0
34197028:	68f8      	ldr	r0, [r7, #12]
3419702a:	f007 f849 	bl	3419e0c0 <memset>

    /* Place the supplied parameters into the thread's control block.  */
    thread_ptr -> tx_thread_name =              name_ptr;
3419702e:	68fb      	ldr	r3, [r7, #12]
34197030:	68ba      	ldr	r2, [r7, #8]
34197032:	629a      	str	r2, [r3, #40]	@ 0x28
    thread_ptr -> tx_thread_entry =             entry_function;
34197034:	68fb      	ldr	r3, [r7, #12]
34197036:	687a      	ldr	r2, [r7, #4]
34197038:	645a      	str	r2, [r3, #68]	@ 0x44
    thread_ptr -> tx_thread_entry_parameter =   entry_input;
3419703a:	68fb      	ldr	r3, [r7, #12]
3419703c:	683a      	ldr	r2, [r7, #0]
3419703e:	649a      	str	r2, [r3, #72]	@ 0x48
    thread_ptr -> tx_thread_stack_start =       stack_start;
34197040:	68fb      	ldr	r3, [r7, #12]
34197042:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
34197044:	60da      	str	r2, [r3, #12]
    thread_ptr -> tx_thread_stack_size =        stack_size;
34197046:	68fb      	ldr	r3, [r7, #12]
34197048:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
3419704a:	615a      	str	r2, [r3, #20]
    thread_ptr -> tx_thread_priority =          priority;
3419704c:	68fb      	ldr	r3, [r7, #12]
3419704e:	6dba      	ldr	r2, [r7, #88]	@ 0x58
34197050:	62da      	str	r2, [r3, #44]	@ 0x2c
    thread_ptr -> tx_thread_user_priority =     priority;
34197052:	68fb      	ldr	r3, [r7, #12]
34197054:	6dba      	ldr	r2, [r7, #88]	@ 0x58
34197056:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
    thread_ptr -> tx_thread_time_slice =        time_slice;
3419705a:	68fb      	ldr	r3, [r7, #12]
3419705c:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
3419705e:	619a      	str	r2, [r3, #24]
    thread_ptr -> tx_thread_new_time_slice =    time_slice;
34197060:	68fb      	ldr	r3, [r7, #12]
34197062:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
34197064:	61da      	str	r2, [r3, #28]
    thread_ptr -> tx_thread_inherit_priority =  ((UINT) TX_MAX_PRIORITIES);
34197066:	68fb      	ldr	r3, [r7, #12]
34197068:	2220      	movs	r2, #32
3419706a:	f8c3 209c 	str.w	r2, [r3, #156]	@ 0x9c

    /* Calculate the end of the thread's stack area.  */
    temp_ptr =  TX_VOID_TO_UCHAR_POINTER_CONVERT(stack_start);
3419706e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
34197070:	63fb      	str	r3, [r7, #60]	@ 0x3c
    temp_ptr =  (TX_UCHAR_POINTER_ADD(temp_ptr, (stack_size - ((ULONG) 1))));
34197072:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34197074:	3b01      	subs	r3, #1
34197076:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
34197078:	4413      	add	r3, r2
3419707a:	63fb      	str	r3, [r7, #60]	@ 0x3c
    thread_ptr -> tx_thread_stack_end =         TX_UCHAR_TO_VOID_POINTER_CONVERT(temp_ptr);
3419707c:	68fb      	ldr	r3, [r7, #12]
3419707e:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
34197080:	611a      	str	r2, [r3, #16]
    thread_ptr -> tx_thread_preempt_threshold =       preempt_threshold;
    thread_ptr -> tx_thread_user_preempt_threshold =  preempt_threshold;
#else

    /* Preemption-threshold is disabled, determine if preemption-threshold was required.  */
    if (priority != preempt_threshold)
34197082:	6dba      	ldr	r2, [r7, #88]	@ 0x58
34197084:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
34197086:	429a      	cmp	r2, r3
34197088:	d007      	beq.n	3419709a <_tx_thread_create+0x92>
    {

        /* Preemption-threshold specified. Since specific preemption-threshold is not supported,
           disable all preemption.  */
        thread_ptr -> tx_thread_preempt_threshold =       ((UINT) 0);
3419708a:	68fb      	ldr	r3, [r7, #12]
3419708c:	2200      	movs	r2, #0
3419708e:	63da      	str	r2, [r3, #60]	@ 0x3c
        thread_ptr -> tx_thread_user_preempt_threshold =  ((UINT) 0);
34197090:	68fb      	ldr	r3, [r7, #12]
34197092:	2200      	movs	r2, #0
34197094:	f8c3 2098 	str.w	r2, [r3, #152]	@ 0x98
34197098:	e006      	b.n	341970a8 <_tx_thread_create+0xa0>
    }
    else
    {

        /* Preemption-threshold is not specified, just setup with the priority.  */
        thread_ptr -> tx_thread_preempt_threshold =       priority;
3419709a:	68fb      	ldr	r3, [r7, #12]
3419709c:	6dba      	ldr	r2, [r7, #88]	@ 0x58
3419709e:	63da      	str	r2, [r3, #60]	@ 0x3c
        thread_ptr -> tx_thread_user_preempt_threshold =  priority;
341970a0:	68fb      	ldr	r3, [r7, #12]
341970a2:	6dba      	ldr	r2, [r7, #88]	@ 0x58
341970a4:	f8c3 2098 	str.w	r2, [r3, #152]	@ 0x98
    }
#endif

    /* Now fill in the values that are required for thread initialization.  */
    thread_ptr -> tx_thread_state =  TX_SUSPENDED;
341970a8:	68fb      	ldr	r3, [r7, #12]
341970aa:	2203      	movs	r2, #3
341970ac:	631a      	str	r2, [r3, #48]	@ 0x30

    /* Setup the necessary fields in the thread timer block.  */
    TX_THREAD_CREATE_TIMEOUT_SETUP(thread_ptr)
341970ae:	68fb      	ldr	r3, [r7, #12]
341970b0:	4a48      	ldr	r2, [pc, #288]	@ (341971d4 <_tx_thread_create+0x1cc>)
341970b2:	655a      	str	r2, [r3, #84]	@ 0x54
341970b4:	68fa      	ldr	r2, [r7, #12]
341970b6:	68fb      	ldr	r3, [r7, #12]
341970b8:	659a      	str	r2, [r3, #88]	@ 0x58
    TX_THREAD_CREATE_INTERNAL_EXTENSION(thread_ptr)

    /* Call the target specific stack frame building routine to build the
       thread's initial stack and to setup the actual stack pointer in the
       control block.  */
    _tx_thread_stack_build(thread_ptr, _tx_thread_shell_entry);
341970ba:	4947      	ldr	r1, [pc, #284]	@ (341971d8 <_tx_thread_create+0x1d0>)
341970bc:	68f8      	ldr	r0, [r7, #12]
341970be:	f7e9 fc07 	bl	341808d0 <_tx_thread_stack_build>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
341970c2:	f3ef 8310 	mrs	r3, PRIMASK
341970c6:	62fb      	str	r3, [r7, #44]	@ 0x2c
    return(posture);
341970c8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
    int_posture = __get_interrupt_posture();
341970ca:	62bb      	str	r3, [r7, #40]	@ 0x28
    __asm__ volatile ("CPSID i" : : : "memory");
341970cc:	b672      	cpsid	i
    return(int_posture);
341970ce:	6abb      	ldr	r3, [r7, #40]	@ 0x28
    /* Setup the highest usage stack pointer.  */
    thread_ptr -> tx_thread_stack_highest_ptr =  thread_ptr -> tx_thread_stack_ptr;
#endif

    /* Prepare to make this thread a member of the created thread list.  */
    TX_DISABLE
341970d0:	63bb      	str	r3, [r7, #56]	@ 0x38

    /* Load the thread ID field in the thread control block.  */
    thread_ptr -> tx_thread_id =  TX_THREAD_ID;
341970d2:	68fb      	ldr	r3, [r7, #12]
341970d4:	4a41      	ldr	r2, [pc, #260]	@ (341971dc <_tx_thread_create+0x1d4>)
341970d6:	601a      	str	r2, [r3, #0]

    /* Place the thread on the list of created threads.  First,
       check for an empty list.  */
    if (_tx_thread_created_count == TX_EMPTY)
341970d8:	4b41      	ldr	r3, [pc, #260]	@ (341971e0 <_tx_thread_create+0x1d8>)
341970da:	681b      	ldr	r3, [r3, #0]
341970dc:	2b00      	cmp	r3, #0
341970de:	d10b      	bne.n	341970f8 <_tx_thread_create+0xf0>
    {

        /* The created thread list is empty.  Add thread to empty list.  */
        _tx_thread_created_ptr =                    thread_ptr;
341970e0:	4a40      	ldr	r2, [pc, #256]	@ (341971e4 <_tx_thread_create+0x1dc>)
341970e2:	68fb      	ldr	r3, [r7, #12]
341970e4:	6013      	str	r3, [r2, #0]
        thread_ptr -> tx_thread_created_next =      thread_ptr;
341970e6:	68fb      	ldr	r3, [r7, #12]
341970e8:	68fa      	ldr	r2, [r7, #12]
341970ea:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
        thread_ptr -> tx_thread_created_previous =  thread_ptr;
341970ee:	68fb      	ldr	r3, [r7, #12]
341970f0:	68fa      	ldr	r2, [r7, #12]
341970f2:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
341970f6:	e016      	b.n	34197126 <_tx_thread_create+0x11e>
    }
    else
    {

        /* This list is not NULL, add to the end of the list.  */
        next_thread =  _tx_thread_created_ptr;
341970f8:	4b3a      	ldr	r3, [pc, #232]	@ (341971e4 <_tx_thread_create+0x1dc>)
341970fa:	681b      	ldr	r3, [r3, #0]
341970fc:	637b      	str	r3, [r7, #52]	@ 0x34
        previous_thread =  next_thread -> tx_thread_created_previous;
341970fe:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34197100:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
34197104:	633b      	str	r3, [r7, #48]	@ 0x30

        /* Place the new thread in the list.  */
        next_thread -> tx_thread_created_previous =  thread_ptr;
34197106:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34197108:	68fa      	ldr	r2, [r7, #12]
3419710a:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
        previous_thread -> tx_thread_created_next =  thread_ptr;
3419710e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34197110:	68fa      	ldr	r2, [r7, #12]
34197112:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

        /* Setup this thread's created links.  */
        thread_ptr -> tx_thread_created_previous =  previous_thread;
34197116:	68fb      	ldr	r3, [r7, #12]
34197118:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
3419711a:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
        thread_ptr -> tx_thread_created_next =      next_thread;
3419711e:	68fb      	ldr	r3, [r7, #12]
34197120:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
34197122:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
    }

    /* Increment the thread created count.  */
    _tx_thread_created_count++;
34197126:	4b2e      	ldr	r3, [pc, #184]	@ (341971e0 <_tx_thread_create+0x1d8>)
34197128:	681b      	ldr	r3, [r3, #0]
3419712a:	3301      	adds	r3, #1
3419712c:	4a2c      	ldr	r2, [pc, #176]	@ (341971e0 <_tx_thread_create+0x1d8>)
3419712e:	6013      	str	r3, [r2, #0]
    TX_EL_THREAD_CREATE_INSERT

#ifndef TX_NOT_INTERRUPTABLE

    /* Temporarily disable preemption.  */
    _tx_thread_preempt_disable++;
34197130:	4b2d      	ldr	r3, [pc, #180]	@ (341971e8 <_tx_thread_create+0x1e0>)
34197132:	681b      	ldr	r3, [r3, #0]
34197134:	3301      	adds	r3, #1
34197136:	4a2c      	ldr	r2, [pc, #176]	@ (341971e8 <_tx_thread_create+0x1e0>)
34197138:	6013      	str	r3, [r2, #0]
#endif

    /* Determine if an automatic start was requested.  If so, call the resume
       thread function and then check for a preemption condition.  */
    if (auto_start == TX_AUTO_START)
3419713a:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3419713c:	2b01      	cmp	r3, #1
3419713e:	d129      	bne.n	34197194 <_tx_thread_create+0x18c>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
34197140:	f3ef 8305 	mrs	r3, IPSR
34197144:	627b      	str	r3, [r7, #36]	@ 0x24
    return(ipsr_value);
34197146:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
    {

        /* Determine if the create call is being called from initialization.  */
        if (TX_THREAD_GET_SYSTEM_STATE() >= TX_INITIALIZE_IN_PROGRESS)
34197148:	4b28      	ldr	r3, [pc, #160]	@ (341971ec <_tx_thread_create+0x1e4>)
3419714a:	681b      	ldr	r3, [r3, #0]
3419714c:	4313      	orrs	r3, r2
3419714e:	f1b3 3ff0 	cmp.w	r3, #4042322160	@ 0xf0f0f0f0
34197152:	d30d      	bcc.n	34197170 <_tx_thread_create+0x168>

            /* Pickup the current thread execute pointer, which corresponds to the
               highest priority thread ready to execute.  Interrupt lockout is
               not required, since interrupts are assumed to be disabled during
               initialization.  */
            saved_thread_ptr =  _tx_thread_execute_ptr;
34197154:	4b26      	ldr	r3, [pc, #152]	@ (341971f0 <_tx_thread_create+0x1e8>)
34197156:	681b      	ldr	r3, [r3, #0]
34197158:	647b      	str	r3, [r7, #68]	@ 0x44

            /* Determine if there is thread ready for execution.  */
            if (saved_thread_ptr != TX_NULL)
3419715a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3419715c:	2b00      	cmp	r3, #0
3419715e:	d009      	beq.n	34197174 <_tx_thread_create+0x16c>
            {

                /* Yes, a thread is ready for execution when initialization completes.  */

                /* Save the current preemption-threshold.  */
                saved_threshold =  saved_thread_ptr -> tx_thread_preempt_threshold;
34197160:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34197162:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34197164:	643b      	str	r3, [r7, #64]	@ 0x40

                /* For initialization, temporarily set the preemption-threshold to the
                   priority level to make sure the highest-priority thread runs once
                   initialization is complete.  */
                saved_thread_ptr -> tx_thread_preempt_threshold =  saved_thread_ptr -> tx_thread_priority;
34197166:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34197168:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
3419716a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3419716c:	63da      	str	r2, [r3, #60]	@ 0x3c
3419716e:	e001      	b.n	34197174 <_tx_thread_create+0x16c>
        }
        else
        {

            /* Simply set the saved thread pointer to NULL.  */
            saved_thread_ptr =  TX_NULL;
34197170:	2300      	movs	r3, #0
34197172:	647b      	str	r3, [r7, #68]	@ 0x44
34197174:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34197176:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34197178:	6a3b      	ldr	r3, [r7, #32]
3419717a:	f383 8810 	msr	PRIMASK, r3
}
3419717e:	bf00      	nop

        /* Perform any additional activities for tool or user purpose.  */
        TX_THREAD_CREATE_EXTENSION(thread_ptr)

        /* Call the resume thread function to make this thread ready.  */
        _tx_thread_system_resume(thread_ptr);
34197180:	68f8      	ldr	r0, [r7, #12]
34197182:	f000 fb7f 	bl	34197884 <_tx_thread_system_resume>
#endif

        /* Determine if the thread's preemption-threshold needs to be restored.  */
        if (saved_thread_ptr != TX_NULL)
34197186:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34197188:	2b00      	cmp	r3, #0
3419718a:	d01e      	beq.n	341971ca <_tx_thread_create+0x1c2>
        {

            /* Yes, restore the previous highest-priority thread's preemption-threshold. This
               can only happen if this routine is called from initialization.  */
            saved_thread_ptr -> tx_thread_preempt_threshold =  saved_threshold;
3419718c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3419718e:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
34197190:	63da      	str	r2, [r3, #60]	@ 0x3c
34197192:	e01a      	b.n	341971ca <_tx_thread_create+0x1c2>
34197194:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34197196:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34197198:	693b      	ldr	r3, [r7, #16]
3419719a:	f383 8810 	msr	PRIMASK, r3
}
3419719e:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
341971a0:	f3ef 8310 	mrs	r3, PRIMASK
341971a4:	61bb      	str	r3, [r7, #24]
    return(posture);
341971a6:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
341971a8:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
341971aa:	b672      	cpsid	i
    return(int_posture);
341971ac:	697b      	ldr	r3, [r7, #20]

        /* Perform any additional activities for tool or user purpose.  */
        TX_THREAD_CREATE_EXTENSION(thread_ptr)

        /* Disable interrupts.  */
        TX_DISABLE
341971ae:	63bb      	str	r3, [r7, #56]	@ 0x38

        /* Re-enable preemption.  */
        _tx_thread_preempt_disable--;
341971b0:	4b0d      	ldr	r3, [pc, #52]	@ (341971e8 <_tx_thread_create+0x1e0>)
341971b2:	681b      	ldr	r3, [r3, #0]
341971b4:	3b01      	subs	r3, #1
341971b6:	4a0c      	ldr	r2, [pc, #48]	@ (341971e8 <_tx_thread_create+0x1e0>)
341971b8:	6013      	str	r3, [r2, #0]
341971ba:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
341971bc:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
341971be:	69fb      	ldr	r3, [r7, #28]
341971c0:	f383 8810 	msr	PRIMASK, r3
}
341971c4:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Check for preemption.  */
        _tx_thread_system_preempt_check();
341971c6:	f000 fb23 	bl	34197810 <_tx_thread_system_preempt_check>
#endif
    }

    /* Always return a success.  */
    return(TX_SUCCESS);
341971ca:	2300      	movs	r3, #0
}
341971cc:	4618      	mov	r0, r3
341971ce:	3748      	adds	r7, #72	@ 0x48
341971d0:	46bd      	mov	sp, r7
341971d2:	bd80      	pop	{r7, pc}
341971d4:	34198059 	.word	0x34198059
341971d8:	34197599 	.word	0x34197599
341971dc:	54485244 	.word	0x54485244
341971e0:	341c2df8 	.word	0x341c2df8
341971e4:	341c2df4 	.word	0x341c2df4
341971e8:	341c2e84 	.word	0x341c2e84
341971ec:	341c009c 	.word	0x341c009c
341971f0:	341c2df0 	.word	0x341c2df0

341971f4 <_tx_thread_delete>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_thread_delete(TX_THREAD *thread_ptr)
{
341971f4:	b480      	push	{r7}
341971f6:	b08b      	sub	sp, #44	@ 0x2c
341971f8:	af00      	add	r7, sp, #0
341971fa:	6078      	str	r0, [r7, #4]
TX_THREAD       *previous_thread;
UINT            status;


    /* Default status to success.  */
    status =  TX_SUCCESS;
341971fc:	2300      	movs	r3, #0
341971fe:	627b      	str	r3, [r7, #36]	@ 0x24
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34197200:	f3ef 8310 	mrs	r3, PRIMASK
34197204:	617b      	str	r3, [r7, #20]
    return(posture);
34197206:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
34197208:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
3419720a:	b672      	cpsid	i
    return(int_posture);
3419720c:	693b      	ldr	r3, [r7, #16]

    /* Lockout interrupts while the thread is being deleted.  */
    TX_DISABLE
3419720e:	623b      	str	r3, [r7, #32]

    /* Check for proper status of this thread to delete.  */
    if (thread_ptr -> tx_thread_state != TX_COMPLETED)
34197210:	687b      	ldr	r3, [r7, #4]
34197212:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34197214:	2b01      	cmp	r3, #1
34197216:	d00b      	beq.n	34197230 <_tx_thread_delete+0x3c>
    {

        /* Now check for terminated state.  */
        if (thread_ptr -> tx_thread_state != TX_TERMINATED)
34197218:	687b      	ldr	r3, [r7, #4]
3419721a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3419721c:	2b02      	cmp	r3, #2
3419721e:	d007      	beq.n	34197230 <_tx_thread_delete+0x3c>
34197220:	6a3b      	ldr	r3, [r7, #32]
34197222:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34197224:	68fb      	ldr	r3, [r7, #12]
34197226:	f383 8810 	msr	PRIMASK, r3
}
3419722a:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Thread not completed or terminated - return an error!  */
            status =  TX_DELETE_ERROR;
3419722c:	2311      	movs	r3, #17
3419722e:	627b      	str	r3, [r7, #36]	@ 0x24
        }
    }

    /* Determine if the delete operation is okay.  */
    if (status == TX_SUCCESS)
34197230:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34197232:	2b00      	cmp	r3, #0
34197234:	d12d      	bne.n	34197292 <_tx_thread_delete+0x9e>

        /* Unregister thread in the thread array structure.  */
        TX_EL_THREAD_UNREGISTER(thread_ptr)

        /* Clear the thread ID to make it invalid.  */
        thread_ptr -> tx_thread_id =  TX_CLEAR_ID;
34197236:	687b      	ldr	r3, [r7, #4]
34197238:	2200      	movs	r2, #0
3419723a:	601a      	str	r2, [r3, #0]

        /* Decrement the number of created threads.  */
        _tx_thread_created_count--;
3419723c:	4b18      	ldr	r3, [pc, #96]	@ (341972a0 <_tx_thread_delete+0xac>)
3419723e:	681b      	ldr	r3, [r3, #0]
34197240:	3b01      	subs	r3, #1
34197242:	4a17      	ldr	r2, [pc, #92]	@ (341972a0 <_tx_thread_delete+0xac>)
34197244:	6013      	str	r3, [r2, #0]

        /* See if the thread is the only one on the list.  */
        if (_tx_thread_created_count == TX_EMPTY)
34197246:	4b16      	ldr	r3, [pc, #88]	@ (341972a0 <_tx_thread_delete+0xac>)
34197248:	681b      	ldr	r3, [r3, #0]
3419724a:	2b00      	cmp	r3, #0
3419724c:	d103      	bne.n	34197256 <_tx_thread_delete+0x62>
        {

            /* Only created thread, just set the created list to NULL.  */
            _tx_thread_created_ptr =  TX_NULL;
3419724e:	4b15      	ldr	r3, [pc, #84]	@ (341972a4 <_tx_thread_delete+0xb0>)
34197250:	2200      	movs	r2, #0
34197252:	601a      	str	r2, [r3, #0]
34197254:	e017      	b.n	34197286 <_tx_thread_delete+0x92>
        }
        else
        {

            /* Otherwise, not the only created thread, link-up the neighbors.  */
            next_thread =                                thread_ptr -> tx_thread_created_next;
34197256:	687b      	ldr	r3, [r7, #4]
34197258:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
3419725c:	61fb      	str	r3, [r7, #28]
            previous_thread =                            thread_ptr -> tx_thread_created_previous;
3419725e:	687b      	ldr	r3, [r7, #4]
34197260:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
34197264:	61bb      	str	r3, [r7, #24]
            next_thread -> tx_thread_created_previous =  previous_thread;
34197266:	69fb      	ldr	r3, [r7, #28]
34197268:	69ba      	ldr	r2, [r7, #24]
3419726a:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
            previous_thread -> tx_thread_created_next =  next_thread;
3419726e:	69bb      	ldr	r3, [r7, #24]
34197270:	69fa      	ldr	r2, [r7, #28]
34197272:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

            /* See if we have to update the created list head pointer.  */
            if (_tx_thread_created_ptr == thread_ptr)
34197276:	4b0b      	ldr	r3, [pc, #44]	@ (341972a4 <_tx_thread_delete+0xb0>)
34197278:	681b      	ldr	r3, [r3, #0]
3419727a:	687a      	ldr	r2, [r7, #4]
3419727c:	429a      	cmp	r2, r3
3419727e:	d102      	bne.n	34197286 <_tx_thread_delete+0x92>
            {

                /* Yes, move the head pointer to the next link. */
                _tx_thread_created_ptr =  next_thread;
34197280:	4a08      	ldr	r2, [pc, #32]	@ (341972a4 <_tx_thread_delete+0xb0>)
34197282:	69fb      	ldr	r3, [r7, #28]
34197284:	6013      	str	r3, [r2, #0]
34197286:	6a3b      	ldr	r3, [r7, #32]
34197288:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
3419728a:	68bb      	ldr	r3, [r7, #8]
3419728c:	f383 8810 	msr	PRIMASK, r3
}
34197290:	bf00      	nop
        /* Restore interrupts.  */
        TX_RESTORE
    }

    /* Return completion status.  */
    return(status);
34197292:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
34197294:	4618      	mov	r0, r3
34197296:	372c      	adds	r7, #44	@ 0x2c
34197298:	46bd      	mov	sp, r7
3419729a:	f85d 7b04 	ldr.w	r7, [sp], #4
3419729e:	4770      	bx	lr
341972a0:	341c2df8 	.word	0x341c2df8
341972a4:	341c2df4 	.word	0x341c2df4

341972a8 <_tx_thread_identify>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
TX_THREAD  *_tx_thread_identify(VOID)
{
341972a8:	b480      	push	{r7}
341972aa:	b087      	sub	sp, #28
341972ac:	af00      	add	r7, sp, #0
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
341972ae:	f3ef 8310 	mrs	r3, PRIMASK
341972b2:	60bb      	str	r3, [r7, #8]
    return(posture);
341972b4:	68bb      	ldr	r3, [r7, #8]
    int_posture = __get_interrupt_posture();
341972b6:	607b      	str	r3, [r7, #4]
    __asm__ volatile ("CPSID i" : : : "memory");
341972b8:	b672      	cpsid	i
    return(int_posture);
341972ba:	687b      	ldr	r3, [r7, #4]

TX_INTERRUPT_SAVE_AREA


    /* Disable interrupts to put the timer on the created list.  */
    TX_DISABLE
341972bc:	617b      	str	r3, [r7, #20]

   /* Log this kernel call.  */
    TX_EL_THREAD_IDENTIFY_INSERT

    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(thread_ptr)
341972be:	4b08      	ldr	r3, [pc, #32]	@ (341972e0 <_tx_thread_identify+0x38>)
341972c0:	681b      	ldr	r3, [r3, #0]
341972c2:	613b      	str	r3, [r7, #16]
341972c4:	697b      	ldr	r3, [r7, #20]
341972c6:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
341972c8:	68fb      	ldr	r3, [r7, #12]
341972ca:	f383 8810 	msr	PRIMASK, r3
}
341972ce:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return the current thread pointer.  */
    return(thread_ptr);
341972d0:	693b      	ldr	r3, [r7, #16]
}
341972d2:	4618      	mov	r0, r3
341972d4:	371c      	adds	r7, #28
341972d6:	46bd      	mov	sp, r7
341972d8:	f85d 7b04 	ldr.w	r7, [sp], #4
341972dc:	4770      	bx	lr
341972de:	bf00      	nop
341972e0:	341c2dec 	.word	0x341c2dec

341972e4 <_tx_thread_info_get>:
/*                                                                        */
/**************************************************************************/
UINT  _tx_thread_info_get(TX_THREAD *thread_ptr, CHAR **name, UINT *state, ULONG *run_count,
                UINT *priority, UINT *preemption_threshold, ULONG *time_slice,
                TX_THREAD **next_thread, TX_THREAD **next_suspended_thread)
{
341972e4:	b480      	push	{r7}
341972e6:	b089      	sub	sp, #36	@ 0x24
341972e8:	af00      	add	r7, sp, #0
341972ea:	60f8      	str	r0, [r7, #12]
341972ec:	60b9      	str	r1, [r7, #8]
341972ee:	607a      	str	r2, [r7, #4]
341972f0:	603b      	str	r3, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
341972f2:	f3ef 8310 	mrs	r3, PRIMASK
341972f6:	61bb      	str	r3, [r7, #24]
    return(posture);
341972f8:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
341972fa:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
341972fc:	b672      	cpsid	i
    return(int_posture);
341972fe:	697b      	ldr	r3, [r7, #20]

TX_INTERRUPT_SAVE_AREA


    /* Disable interrupts.  */
    TX_DISABLE
34197300:	61fb      	str	r3, [r7, #28]

    /* Retrieve all the pertinent information and return it in the supplied
       destinations.  */

    /* Retrieve the name of the thread.  */
    if (name != TX_NULL)
34197302:	68bb      	ldr	r3, [r7, #8]
34197304:	2b00      	cmp	r3, #0
34197306:	d003      	beq.n	34197310 <_tx_thread_info_get+0x2c>
    {

        *name =  thread_ptr -> tx_thread_name;
34197308:	68fb      	ldr	r3, [r7, #12]
3419730a:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
3419730c:	68bb      	ldr	r3, [r7, #8]
3419730e:	601a      	str	r2, [r3, #0]
    }

    /* Pickup the thread's current state.  */
    if (state != TX_NULL)
34197310:	687b      	ldr	r3, [r7, #4]
34197312:	2b00      	cmp	r3, #0
34197314:	d003      	beq.n	3419731e <_tx_thread_info_get+0x3a>
    {

        *state =  thread_ptr -> tx_thread_state;
34197316:	68fb      	ldr	r3, [r7, #12]
34197318:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
3419731a:	687b      	ldr	r3, [r7, #4]
3419731c:	601a      	str	r2, [r3, #0]
    }

    /* Pickup the number of times the thread has been scheduled.  */
    if (run_count != TX_NULL)
3419731e:	683b      	ldr	r3, [r7, #0]
34197320:	2b00      	cmp	r3, #0
34197322:	d003      	beq.n	3419732c <_tx_thread_info_get+0x48>
    {

        *run_count =  thread_ptr -> tx_thread_run_count;
34197324:	68fb      	ldr	r3, [r7, #12]
34197326:	685a      	ldr	r2, [r3, #4]
34197328:	683b      	ldr	r3, [r7, #0]
3419732a:	601a      	str	r2, [r3, #0]
    }

    /* Pickup the thread's priority.  */
    if (priority != TX_NULL)
3419732c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419732e:	2b00      	cmp	r3, #0
34197330:	d004      	beq.n	3419733c <_tx_thread_info_get+0x58>
    {

        *priority =  thread_ptr -> tx_thread_user_priority;
34197332:	68fb      	ldr	r3, [r7, #12]
34197334:	f8d3 2094 	ldr.w	r2, [r3, #148]	@ 0x94
34197338:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419733a:	601a      	str	r2, [r3, #0]
    }

    /* Pickup the thread's preemption-threshold.  */
    if (preemption_threshold != TX_NULL)
3419733c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3419733e:	2b00      	cmp	r3, #0
34197340:	d004      	beq.n	3419734c <_tx_thread_info_get+0x68>
    {

        *preemption_threshold =  thread_ptr -> tx_thread_user_preempt_threshold;
34197342:	68fb      	ldr	r3, [r7, #12]
34197344:	f8d3 2098 	ldr.w	r2, [r3, #152]	@ 0x98
34197348:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3419734a:	601a      	str	r2, [r3, #0]
    }

    /* Pickup the thread's current time-slice.  */
    if (time_slice != TX_NULL)
3419734c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3419734e:	2b00      	cmp	r3, #0
34197350:	d003      	beq.n	3419735a <_tx_thread_info_get+0x76>
    {

        *time_slice =  thread_ptr -> tx_thread_time_slice;
34197352:	68fb      	ldr	r3, [r7, #12]
34197354:	699a      	ldr	r2, [r3, #24]
34197356:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34197358:	601a      	str	r2, [r3, #0]
    }

    /* Pickup the next created thread.  */
    if (next_thread != TX_NULL)
3419735a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
3419735c:	2b00      	cmp	r3, #0
3419735e:	d004      	beq.n	3419736a <_tx_thread_info_get+0x86>
    {

        *next_thread =  thread_ptr -> tx_thread_created_next;
34197360:	68fb      	ldr	r3, [r7, #12]
34197362:	f8d3 2088 	ldr.w	r2, [r3, #136]	@ 0x88
34197366:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34197368:	601a      	str	r2, [r3, #0]
    }

    /* Pickup the next thread suspended.  */
    if (next_suspended_thread != TX_NULL)
3419736a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419736c:	2b00      	cmp	r3, #0
3419736e:	d003      	beq.n	34197378 <_tx_thread_info_get+0x94>
    {

        *next_suspended_thread =  thread_ptr -> tx_thread_suspended_next;
34197370:	68fb      	ldr	r3, [r7, #12]
34197372:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
34197374:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34197376:	601a      	str	r2, [r3, #0]
34197378:	69fb      	ldr	r3, [r7, #28]
3419737a:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
3419737c:	693b      	ldr	r3, [r7, #16]
3419737e:	f383 8810 	msr	PRIMASK, r3
}
34197382:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return completion status.  */
    return(TX_SUCCESS);
34197384:	2300      	movs	r3, #0
}
34197386:	4618      	mov	r0, r3
34197388:	3724      	adds	r7, #36	@ 0x24
3419738a:	46bd      	mov	sp, r7
3419738c:	f85d 7b04 	ldr.w	r7, [sp], #4
34197390:	4770      	bx	lr
	...

34197394 <_tx_thread_initialize>:
/*                                            stack check error handling, */
/*                                            resulting in version 6.1.9  */   
/*                                                                        */
/**************************************************************************/
VOID  _tx_thread_initialize(VOID)
{
34197394:	b580      	push	{r7, lr}
34197396:	af00      	add	r7, sp, #0
       respectively.  */

#ifndef TX_DISABLE_REDUNDANT_CLEARING

    /* Set current thread pointer to NULL.  */
    TX_THREAD_SET_CURRENT(TX_NULL)
34197398:	4b12      	ldr	r3, [pc, #72]	@ (341973e4 <_tx_thread_initialize+0x50>)
3419739a:	2200      	movs	r2, #0
3419739c:	601a      	str	r2, [r3, #0]

    /* Initialize the execute thread pointer to NULL.  */
    _tx_thread_execute_ptr =  TX_NULL;
3419739e:	4b12      	ldr	r3, [pc, #72]	@ (341973e8 <_tx_thread_initialize+0x54>)
341973a0:	2200      	movs	r2, #0
341973a2:	601a      	str	r2, [r3, #0]

    /* Initialize the priority information.  */
    TX_MEMSET(&_tx_thread_priority_maps[0], 0, (sizeof(_tx_thread_priority_maps)));
341973a4:	4b11      	ldr	r3, [pc, #68]	@ (341973ec <_tx_thread_initialize+0x58>)
341973a6:	2200      	movs	r2, #0
341973a8:	601a      	str	r2, [r3, #0]
#endif
#endif

    /* Setup the highest priority variable to the max, indicating no thread is currently
       ready.  */
    _tx_thread_highest_priority =  ((UINT) TX_MAX_PRIORITIES);
341973aa:	4b11      	ldr	r3, [pc, #68]	@ (341973f0 <_tx_thread_initialize+0x5c>)
341973ac:	2220      	movs	r2, #32
341973ae:	601a      	str	r2, [r3, #0]


#ifndef TX_DISABLE_REDUNDANT_CLEARING

    /* Initialize the array of priority head pointers.  */
    TX_MEMSET(&_tx_thread_priority_list[0], 0, (sizeof(_tx_thread_priority_list)));
341973b0:	2280      	movs	r2, #128	@ 0x80
341973b2:	2100      	movs	r1, #0
341973b4:	480f      	ldr	r0, [pc, #60]	@ (341973f4 <_tx_thread_initialize+0x60>)
341973b6:	f006 fe83 	bl	3419e0c0 <memset>

    /* Initialize the head pointer of the created threads list and the
       number of threads created.  */
    _tx_thread_created_ptr =        TX_NULL;
341973ba:	4b0f      	ldr	r3, [pc, #60]	@ (341973f8 <_tx_thread_initialize+0x64>)
341973bc:	2200      	movs	r2, #0
341973be:	601a      	str	r2, [r3, #0]
    _tx_thread_created_count =      TX_EMPTY;
341973c0:	4b0e      	ldr	r3, [pc, #56]	@ (341973fc <_tx_thread_initialize+0x68>)
341973c2:	2200      	movs	r2, #0
341973c4:	601a      	str	r2, [r3, #0]

    /* Clear the global preempt disable variable.  */
    _tx_thread_preempt_disable =    ((UINT) 0);
341973c6:	4b0e      	ldr	r3, [pc, #56]	@ (34197400 <_tx_thread_initialize+0x6c>)
341973c8:	2200      	movs	r2, #0
341973ca:	601a      	str	r2, [r3, #0]

    /* Initialize the thread mutex release function pointer.  */
    _tx_thread_mutex_release =      TX_NULL;
341973cc:	4b0d      	ldr	r3, [pc, #52]	@ (34197404 <_tx_thread_initialize+0x70>)
341973ce:	2200      	movs	r2, #0
341973d0:	601a      	str	r2, [r3, #0]
#endif
#ifdef TX_DISABLE_REDUNDANT_CLEARING
                            | (((ULONG) 1) << 18)
#endif
#ifdef TX_DISABLE_NOTIFY_CALLBACKS
                            | (((ULONG) 1) << 17)
341973d2:	4b0d      	ldr	r3, [pc, #52]	@ (34197408 <_tx_thread_initialize+0x74>)
341973d4:	681b      	ldr	r3, [r3, #0]
341973d6:	f043 7385 	orr.w	r3, r3, #17432576	@ 0x10a0000
    _tx_build_options =  _tx_build_options 
341973da:	4a0b      	ldr	r2, [pc, #44]	@ (34197408 <_tx_thread_initialize+0x74>)
341973dc:	6013      	str	r3, [r2, #0]
#endif
#if TX_PORT_SPECIFIC_BUILD_OPTIONS != 0
                            | TX_PORT_SPECIFIC_BUILD_OPTIONS
#endif
                            ;
}
341973de:	bf00      	nop
341973e0:	bd80      	pop	{r7, pc}
341973e2:	bf00      	nop
341973e4:	341c2dec 	.word	0x341c2dec
341973e8:	341c2df0 	.word	0x341c2df0
341973ec:	341c2dfc 	.word	0x341c2dfc
341973f0:	341c2e00 	.word	0x341c2e00
341973f4:	341c2e04 	.word	0x341c2e04
341973f8:	341c2df4 	.word	0x341c2df4
341973fc:	341c2df8 	.word	0x341c2df8
34197400:	341c2e84 	.word	0x341c2e84
34197404:	341c2e88 	.word	0x341c2e88
34197408:	341c2e8c 	.word	0x341c2e8c

3419740c <_tx_thread_relinquish>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_thread_relinquish(VOID)
{
3419740c:	b480      	push	{r7}
3419740e:	b08b      	sub	sp, #44	@ 0x2c
34197410:	af00      	add	r7, sp, #0
UINT            priority;
TX_THREAD       *thread_ptr;


    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(thread_ptr)
34197412:	4b2b      	ldr	r3, [pc, #172]	@ (341974c0 <_tx_thread_relinquish+0xb4>)
34197414:	681b      	ldr	r3, [r3, #0]
34197416:	627b      	str	r3, [r7, #36]	@ 0x24
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34197418:	f3ef 8310 	mrs	r3, PRIMASK
3419741c:	61bb      	str	r3, [r7, #24]
    return(posture);
3419741e:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
34197420:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
34197422:	b672      	cpsid	i
    return(int_posture);
34197424:	697b      	ldr	r3, [r7, #20]
    /* Check this thread's stack.  */
    TX_THREAD_STACK_CHECK(thread_ptr)
#endif

    /* Disable interrupts.  */
    TX_DISABLE
34197426:	623b      	str	r3, [r7, #32]

#ifndef TX_NO_TIMER

    /* Reset time slice for current thread.  */
    _tx_timer_time_slice =  thread_ptr -> tx_thread_new_time_slice;
34197428:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419742a:	69db      	ldr	r3, [r3, #28]
3419742c:	4a25      	ldr	r2, [pc, #148]	@ (341974c4 <_tx_thread_relinquish+0xb8>)
3419742e:	6013      	str	r3, [r2, #0]
#endif

    /* Pickup the thread's priority.  */
    priority =  thread_ptr -> tx_thread_priority;
34197430:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34197432:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34197434:	61fb      	str	r3, [r7, #28]

    /* Determine if there is another thread at the same priority.  */
    if (thread_ptr -> tx_thread_ready_next != thread_ptr)
34197436:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34197438:	6a1b      	ldr	r3, [r3, #32]
3419743a:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
3419743c:	429a      	cmp	r2, r3
3419743e:	d009      	beq.n	34197454 <_tx_thread_relinquish+0x48>
    {

        /* Yes, there is another thread at this priority, make it the highest at
           this priority level.  */
        _tx_thread_priority_list[priority] =  thread_ptr -> tx_thread_ready_next;
34197440:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34197442:	6a1a      	ldr	r2, [r3, #32]
34197444:	4920      	ldr	r1, [pc, #128]	@ (341974c8 <_tx_thread_relinquish+0xbc>)
34197446:	69fb      	ldr	r3, [r7, #28]
34197448:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Mark the new thread as the one to execute.  */
        _tx_thread_execute_ptr = thread_ptr -> tx_thread_ready_next;
3419744c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419744e:	6a1b      	ldr	r3, [r3, #32]
34197450:	4a1e      	ldr	r2, [pc, #120]	@ (341974cc <_tx_thread_relinquish+0xc0>)
34197452:	6013      	str	r3, [r2, #0]
    }

    /* Determine if there is a higher-priority thread ready.  */
    if (_tx_thread_highest_priority < priority)
34197454:	4b1e      	ldr	r3, [pc, #120]	@ (341974d0 <_tx_thread_relinquish+0xc4>)
34197456:	681b      	ldr	r3, [r3, #0]
34197458:	69fa      	ldr	r2, [r7, #28]
3419745a:	429a      	cmp	r2, r3
3419745c:	d906      	bls.n	3419746c <_tx_thread_relinquish+0x60>
    {

        /* Yes, there is a higher priority thread ready to execute.  Make
           it visible to the thread scheduler.  */
        _tx_thread_execute_ptr =  _tx_thread_priority_list[_tx_thread_highest_priority];
3419745e:	4b1c      	ldr	r3, [pc, #112]	@ (341974d0 <_tx_thread_relinquish+0xc4>)
34197460:	681b      	ldr	r3, [r3, #0]
34197462:	4a19      	ldr	r2, [pc, #100]	@ (341974c8 <_tx_thread_relinquish+0xbc>)
34197464:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
34197468:	4a18      	ldr	r2, [pc, #96]	@ (341974cc <_tx_thread_relinquish+0xc0>)
3419746a:	6013      	str	r3, [r2, #0]
3419746c:	6a3b      	ldr	r3, [r7, #32]
3419746e:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34197470:	693b      	ldr	r3, [r7, #16]
34197472:	f383 8810 	msr	PRIMASK, r3
}
34197476:	bf00      	nop

    /* Restore previous interrupt posture.  */
    TX_RESTORE

    /* Determine if this thread needs to return to the system.  */
    if (_tx_thread_execute_ptr != thread_ptr)
34197478:	4b14      	ldr	r3, [pc, #80]	@ (341974cc <_tx_thread_relinquish+0xc0>)
3419747a:	681b      	ldr	r3, [r3, #0]
3419747c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
3419747e:	429a      	cmp	r2, r3
34197480:	d017      	beq.n	341974b2 <_tx_thread_relinquish+0xa6>
__attribute__( ( always_inline ) ) static inline void _tx_thread_system_return_inline(void)
{
UINT interrupt_save;

    /* Set PendSV to invoke ThreadX scheduler.  */
    *((volatile ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
34197482:	4b14      	ldr	r3, [pc, #80]	@ (341974d4 <_tx_thread_relinquish+0xc8>)
34197484:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
34197488:	601a      	str	r2, [r3, #0]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
3419748a:	f3ef 8305 	mrs	r3, IPSR
3419748e:	60fb      	str	r3, [r7, #12]
    return(ipsr_value);
34197490:	68fb      	ldr	r3, [r7, #12]
    if (_tx_ipsr_get() == 0)
34197492:	2b00      	cmp	r3, #0
34197494:	d10c      	bne.n	341974b0 <_tx_thread_relinquish+0xa4>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34197496:	f3ef 8310 	mrs	r3, PRIMASK
3419749a:	60bb      	str	r3, [r7, #8]
    return(posture);
3419749c:	68bb      	ldr	r3, [r7, #8]
    {
        interrupt_save = __get_interrupt_posture();
3419749e:	607b      	str	r3, [r7, #4]
    __asm__ volatile ("CPSIE  i": : : "memory");
341974a0:	b662      	cpsie	i
}
341974a2:	bf00      	nop
341974a4:	687b      	ldr	r3, [r7, #4]
341974a6:	603b      	str	r3, [r7, #0]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
341974a8:	683b      	ldr	r3, [r7, #0]
341974aa:	f383 8810 	msr	PRIMASK, r3
}
341974ae:	bf00      	nop
#else
        __enable_interrupts();
#endif
        __restore_interrupt(interrupt_save);
    }
}
341974b0:	bf00      	nop

        /* Transfer control to the system so the scheduler can execute
           the next thread.  */
        _tx_thread_system_return();
    }
}
341974b2:	bf00      	nop
341974b4:	372c      	adds	r7, #44	@ 0x2c
341974b6:	46bd      	mov	sp, r7
341974b8:	f85d 7b04 	ldr.w	r7, [sp], #4
341974bc:	4770      	bx	lr
341974be:	bf00      	nop
341974c0:	341c2dec 	.word	0x341c2dec
341974c4:	341c33f0 	.word	0x341c33f0
341974c8:	341c2e04 	.word	0x341c2e04
341974cc:	341c2df0 	.word	0x341c2df0
341974d0:	341c2e00 	.word	0x341c2e00
341974d4:	e000ed04 	.word	0xe000ed04

341974d8 <_tx_thread_resume>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_thread_resume(TX_THREAD *thread_ptr)
{
341974d8:	b580      	push	{r7, lr}
341974da:	b08c      	sub	sp, #48	@ 0x30
341974dc:	af00      	add	r7, sp, #0
341974de:	6078      	str	r0, [r7, #4]

TX_INTERRUPT_SAVE_AREA

UINT        status;
TX_THREAD   *saved_thread_ptr;
UINT        saved_threshold =  ((UINT) 0);
341974e0:	2300      	movs	r3, #0
341974e2:	627b      	str	r3, [r7, #36]	@ 0x24
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
341974e4:	f3ef 8310 	mrs	r3, PRIMASK
341974e8:	61fb      	str	r3, [r7, #28]
    return(posture);
341974ea:	69fb      	ldr	r3, [r7, #28]
    int_posture = __get_interrupt_posture();
341974ec:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("CPSID i" : : : "memory");
341974ee:	b672      	cpsid	i
    return(int_posture);
341974f0:	69bb      	ldr	r3, [r7, #24]
    TX_THREAD_STACK_CHECK(thread_ptr)
#endif
#endif

    /* Lockout interrupts while the thread is being resumed.  */
    TX_DISABLE
341974f2:	623b      	str	r3, [r7, #32]
    /* Log this kernel call.  */
    TX_EL_THREAD_RESUME_INSERT

    /* Determine if the thread is suspended or in the process of suspending.
       If so, call the thread resume processing.  */
    if (thread_ptr -> tx_thread_state == TX_SUSPENDED)
341974f4:	687b      	ldr	r3, [r7, #4]
341974f6:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
341974f8:	2b03      	cmp	r3, #3
341974fa:	d12f      	bne.n	3419755c <_tx_thread_resume+0x84>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
341974fc:	f3ef 8305 	mrs	r3, IPSR
34197500:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
34197502:	697a      	ldr	r2, [r7, #20]
    {

        /* Determine if the create call is being called from initialization.  */
        if (TX_THREAD_GET_SYSTEM_STATE() >= TX_INITIALIZE_IN_PROGRESS)
34197504:	4b21      	ldr	r3, [pc, #132]	@ (3419758c <_tx_thread_resume+0xb4>)
34197506:	681b      	ldr	r3, [r3, #0]
34197508:	4313      	orrs	r3, r2
3419750a:	f1b3 3ff0 	cmp.w	r3, #4042322160	@ 0xf0f0f0f0
3419750e:	d30d      	bcc.n	3419752c <_tx_thread_resume+0x54>

            /* Pickup the current thread execute pointer, which corresponds to the
               highest priority thread ready to execute.  Interrupt lockout is
               not required, since interrupts are assumed to be disabled during
               initialization.  */
            saved_thread_ptr =  _tx_thread_execute_ptr;
34197510:	4b1f      	ldr	r3, [pc, #124]	@ (34197590 <_tx_thread_resume+0xb8>)
34197512:	681b      	ldr	r3, [r3, #0]
34197514:	62bb      	str	r3, [r7, #40]	@ 0x28

            /* Determine if there is thread ready for execution.  */
            if (saved_thread_ptr != TX_NULL)
34197516:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34197518:	2b00      	cmp	r3, #0
3419751a:	d009      	beq.n	34197530 <_tx_thread_resume+0x58>
            {

                /* Yes, a thread is ready for execution when initialization completes.  */

                /* Save the current preemption-threshold.  */
                saved_threshold =  saved_thread_ptr -> tx_thread_preempt_threshold;
3419751c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419751e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34197520:	627b      	str	r3, [r7, #36]	@ 0x24

                /* For initialization, temporarily set the preemption-threshold to the
                   priority level to make sure the highest-priority thread runs once
                   initialization is complete.  */
                saved_thread_ptr -> tx_thread_preempt_threshold =  saved_thread_ptr -> tx_thread_priority;
34197522:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34197524:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
34197526:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34197528:	63da      	str	r2, [r3, #60]	@ 0x3c
3419752a:	e001      	b.n	34197530 <_tx_thread_resume+0x58>
        }
        else
        {

            /* Simply set the saved thread pointer to NULL.  */
            saved_thread_ptr =  TX_NULL;
3419752c:	2300      	movs	r3, #0
3419752e:	62bb      	str	r3, [r7, #40]	@ 0x28
        /* Restore interrupts.  */
        TX_RESTORE
#else

        /* Temporarily disable preemption.  */
        _tx_thread_preempt_disable++;
34197530:	4b18      	ldr	r3, [pc, #96]	@ (34197594 <_tx_thread_resume+0xbc>)
34197532:	681b      	ldr	r3, [r3, #0]
34197534:	3301      	adds	r3, #1
34197536:	4a17      	ldr	r2, [pc, #92]	@ (34197594 <_tx_thread_resume+0xbc>)
34197538:	6013      	str	r3, [r2, #0]
3419753a:	6a3b      	ldr	r3, [r7, #32]
3419753c:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
3419753e:	693b      	ldr	r3, [r7, #16]
34197540:	f383 8810 	msr	PRIMASK, r3
}
34197544:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Call the actual resume service to resume the thread.  */
        _tx_thread_system_resume(thread_ptr);
34197546:	6878      	ldr	r0, [r7, #4]
34197548:	f000 f99c 	bl	34197884 <_tx_thread_system_resume>
#endif

        /* Determine if the thread's preemption-threshold needs to be restored.  */
        if (saved_thread_ptr != TX_NULL)
3419754c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419754e:	2b00      	cmp	r3, #0
34197550:	d002      	beq.n	34197558 <_tx_thread_resume+0x80>
        {

            /* Yes, restore the previous highest-priority thread's preemption-threshold. This
               can only happen if this routine is called from initialization.  */
            saved_thread_ptr -> tx_thread_preempt_threshold =  saved_threshold;
34197552:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34197554:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
34197556:	63da      	str	r2, [r3, #60]	@ 0x3c
        /* Setup successful return status.  */
        status =  TX_SUCCESS;
#else

        /* Return successful completion.  */
        return(TX_SUCCESS);
34197558:	2300      	movs	r3, #0
3419755a:	e012      	b.n	34197582 <_tx_thread_resume+0xaa>

        /* Setup successful return status.  */
        status =  TX_SUCCESS;
#endif
    }
    else if (thread_ptr -> tx_thread_delayed_suspend == TX_TRUE)
3419755c:	687b      	ldr	r3, [r7, #4]
3419755e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
34197560:	2b01      	cmp	r3, #1
34197562:	d105      	bne.n	34197570 <_tx_thread_resume+0x98>
    {

        /* Clear the delayed suspension.  */
        thread_ptr -> tx_thread_delayed_suspend =  TX_FALSE;
34197564:	687b      	ldr	r3, [r7, #4]
34197566:	2200      	movs	r2, #0
34197568:	635a      	str	r2, [r3, #52]	@ 0x34

        /* Setup delayed suspend lifted return status.  */
        status =  TX_SUSPEND_LIFTED;
3419756a:	2319      	movs	r3, #25
3419756c:	62fb      	str	r3, [r7, #44]	@ 0x2c
3419756e:	e001      	b.n	34197574 <_tx_thread_resume+0x9c>
    }
    else
    {

        /* Setup invalid resume return status.  */
        status =  TX_RESUME_ERROR;
34197570:	2312      	movs	r3, #18
34197572:	62fb      	str	r3, [r7, #44]	@ 0x2c
34197574:	6a3b      	ldr	r3, [r7, #32]
34197576:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34197578:	68fb      	ldr	r3, [r7, #12]
3419757a:	f383 8810 	msr	PRIMASK, r3
}
3419757e:	bf00      	nop
        }
    }
#endif

    /* Return completion status. */
    return(status);
34197580:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
}
34197582:	4618      	mov	r0, r3
34197584:	3730      	adds	r7, #48	@ 0x30
34197586:	46bd      	mov	sp, r7
34197588:	bd80      	pop	{r7, pc}
3419758a:	bf00      	nop
3419758c:	341c009c 	.word	0x341c009c
34197590:	341c2df0 	.word	0x341c2df0
34197594:	341c2e84 	.word	0x341c2e84

34197598 <_tx_thread_shell_entry>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_thread_shell_entry(VOID)
{
34197598:	b580      	push	{r7, lr}
3419759a:	b088      	sub	sp, #32
3419759c:	af00      	add	r7, sp, #0
VOID            (*entry_exit_notify)(TX_THREAD *notify_thread_ptr, UINT type);
#endif


    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(thread_ptr)
3419759e:	4b21      	ldr	r3, [pc, #132]	@ (34197624 <_tx_thread_shell_entry+0x8c>)
341975a0:	681b      	ldr	r3, [r3, #0]
341975a2:	61fb      	str	r3, [r7, #28]
        (entry_exit_notify)(thread_ptr, TX_THREAD_ENTRY);
    }
#endif

    /* Call current thread's entry function.  */
    (thread_ptr -> tx_thread_entry) (thread_ptr -> tx_thread_entry_parameter);
341975a4:	69fb      	ldr	r3, [r7, #28]
341975a6:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
341975a8:	69fa      	ldr	r2, [r7, #28]
341975aa:	6c92      	ldr	r2, [r2, #72]	@ 0x48
341975ac:	4610      	mov	r0, r2
341975ae:	4798      	blx	r3

    /* Suspend thread with a "completed" state.  */

    /* Determine if the application is using mutexes.  */
    if (_tx_thread_mutex_release != TX_NULL)
341975b0:	4b1d      	ldr	r3, [pc, #116]	@ (34197628 <_tx_thread_shell_entry+0x90>)
341975b2:	681b      	ldr	r3, [r3, #0]
341975b4:	2b00      	cmp	r3, #0
341975b6:	d003      	beq.n	341975c0 <_tx_thread_shell_entry+0x28>
    {

        /* Yes, call the mutex release function via a function pointer that
           is setup during mutex initialization.  */
        (_tx_thread_mutex_release)(thread_ptr);
341975b8:	4b1b      	ldr	r3, [pc, #108]	@ (34197628 <_tx_thread_shell_entry+0x90>)
341975ba:	681b      	ldr	r3, [r3, #0]
341975bc:	69f8      	ldr	r0, [r7, #28]
341975be:	4798      	blx	r3
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
341975c0:	f3ef 8310 	mrs	r3, PRIMASK
341975c4:	607b      	str	r3, [r7, #4]
    return(posture);
341975c6:	687b      	ldr	r3, [r7, #4]
    int_posture = __get_interrupt_posture();
341975c8:	603b      	str	r3, [r7, #0]
    __asm__ volatile ("CPSID i" : : : "memory");
341975ca:	b672      	cpsid	i
    return(int_posture);
341975cc:	683b      	ldr	r3, [r7, #0]
    }

    /* Lockout interrupts while the thread state is setup.  */
    TX_DISABLE
341975ce:	61bb      	str	r3, [r7, #24]
    entry_exit_notify =  thread_ptr -> tx_thread_entry_exit_notify;
#endif

    /* Set the status to suspending, in order to indicate the suspension
       is in progress.  */
    thread_ptr -> tx_thread_state =  TX_COMPLETED;
341975d0:	69fb      	ldr	r3, [r7, #28]
341975d2:	2201      	movs	r2, #1
341975d4:	631a      	str	r2, [r3, #48]	@ 0x30
    /* Restore interrupts.  */
    TX_RESTORE
#else

    /* Set the suspending flag. */
    thread_ptr -> tx_thread_suspending =  TX_TRUE;
341975d6:	69fb      	ldr	r3, [r7, #28]
341975d8:	2201      	movs	r2, #1
341975da:	639a      	str	r2, [r3, #56]	@ 0x38

    /* Setup for no timeout period.  */
    thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  ((ULONG) 0);
341975dc:	69fb      	ldr	r3, [r7, #28]
341975de:	2200      	movs	r2, #0
341975e0:	64da      	str	r2, [r3, #76]	@ 0x4c

    /* Temporarily disable preemption.  */
    _tx_thread_preempt_disable++;
341975e2:	4b12      	ldr	r3, [pc, #72]	@ (3419762c <_tx_thread_shell_entry+0x94>)
341975e4:	681b      	ldr	r3, [r3, #0]
341975e6:	3301      	adds	r3, #1
341975e8:	4a10      	ldr	r2, [pc, #64]	@ (3419762c <_tx_thread_shell_entry+0x94>)
341975ea:	6013      	str	r3, [r2, #0]
341975ec:	69bb      	ldr	r3, [r7, #24]
341975ee:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
341975f0:	68bb      	ldr	r3, [r7, #8]
341975f2:	f383 8810 	msr	PRIMASK, r3
}
341975f6:	bf00      	nop
    __asm__ volatile (" MRS  %0,CONTROL ": "=r" (control_value) );
341975f8:	f3ef 8314 	mrs	r3, CONTROL
341975fc:	60fb      	str	r3, [r7, #12]
    return(control_value);
341975fe:	68fb      	ldr	r3, [r7, #12]

    /* Restore interrupts.  */
    TX_RESTORE

    /* Perform any additional activities for tool or user purpose.  */
    TX_THREAD_COMPLETED_EXTENSION(thread_ptr)
34197600:	617b      	str	r3, [r7, #20]
34197602:	697b      	ldr	r3, [r7, #20]
34197604:	f023 0304 	bic.w	r3, r3, #4
34197608:	617b      	str	r3, [r7, #20]
3419760a:	697b      	ldr	r3, [r7, #20]
3419760c:	613b      	str	r3, [r7, #16]
    __asm__ volatile (" MSR  CONTROL,%0": : "r" (control_value): "memory" );
3419760e:	693b      	ldr	r3, [r7, #16]
34197610:	f383 8814 	msr	CONTROL, r3
}
34197614:	bf00      	nop
        (entry_exit_notify)(thread_ptr, TX_THREAD_EXIT);
    }
#endif

    /* Call actual thread suspension routine.  */
    _tx_thread_system_suspend(thread_ptr);
34197616:	69f8      	ldr	r0, [r7, #28]
34197618:	f000 fa34 	bl	34197a84 <_tx_thread_system_suspend>
#ifdef TX_SAFETY_CRITICAL

    /* If we ever get here, raise safety critical exception.  */
    TX_SAFETY_CRITICAL_EXCEPTION(__FILE__, __LINE__, 0);
#endif
}
3419761c:	bf00      	nop
3419761e:	3720      	adds	r7, #32
34197620:	46bd      	mov	sp, r7
34197622:	bd80      	pop	{r7, pc}
34197624:	341c2dec 	.word	0x341c2dec
34197628:	341c2e88 	.word	0x341c2e88
3419762c:	341c2e84 	.word	0x341c2e84

34197630 <_tx_thread_sleep>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_thread_sleep(ULONG timer_ticks)
{
34197630:	b580      	push	{r7, lr}
34197632:	b08e      	sub	sp, #56	@ 0x38
34197634:	af00      	add	r7, sp, #0
34197636:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34197638:	f3ef 8310 	mrs	r3, PRIMASK
3419763c:	62bb      	str	r3, [r7, #40]	@ 0x28
    return(posture);
3419763e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
    int_posture = __get_interrupt_posture();
34197640:	627b      	str	r3, [r7, #36]	@ 0x24
    __asm__ volatile ("CPSID i" : : : "memory");
34197642:	b672      	cpsid	i
    return(int_posture);
34197644:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
UINT            status;
TX_THREAD       *thread_ptr;


    /* Lockout interrupts while the thread is being resumed.  */
    TX_DISABLE
34197646:	633b      	str	r3, [r7, #48]	@ 0x30

    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(thread_ptr)
34197648:	4b35      	ldr	r3, [pc, #212]	@ (34197720 <_tx_thread_sleep+0xf0>)
3419764a:	681b      	ldr	r3, [r3, #0]
3419764c:	62fb      	str	r3, [r7, #44]	@ 0x2c

    /* Determine if this is a legal request.  */

    /* Is there a current thread?  */
    if (thread_ptr == TX_NULL)
3419764e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34197650:	2b00      	cmp	r3, #0
34197652:	d108      	bne.n	34197666 <_tx_thread_sleep+0x36>
34197654:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34197656:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34197658:	6a3b      	ldr	r3, [r7, #32]
3419765a:	f383 8810 	msr	PRIMASK, r3
}
3419765e:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Illegal caller of this service.  */
        status =  TX_CALLER_ERROR;
34197660:	2313      	movs	r3, #19
34197662:	637b      	str	r3, [r7, #52]	@ 0x34
34197664:	e056      	b.n	34197714 <_tx_thread_sleep+0xe4>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
34197666:	f3ef 8305 	mrs	r3, IPSR
3419766a:	61fb      	str	r3, [r7, #28]
    return(ipsr_value);
3419766c:	69fa      	ldr	r2, [r7, #28]
    }

    /* Is the caller an ISR or Initialization?  */
    else if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
3419766e:	4b2d      	ldr	r3, [pc, #180]	@ (34197724 <_tx_thread_sleep+0xf4>)
34197670:	681b      	ldr	r3, [r3, #0]
34197672:	4313      	orrs	r3, r2
34197674:	2b00      	cmp	r3, #0
34197676:	d008      	beq.n	3419768a <_tx_thread_sleep+0x5a>
34197678:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3419767a:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
3419767c:	69bb      	ldr	r3, [r7, #24]
3419767e:	f383 8810 	msr	PRIMASK, r3
}
34197682:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Illegal caller of this service.  */
        status =  TX_CALLER_ERROR;
34197684:	2313      	movs	r3, #19
34197686:	637b      	str	r3, [r7, #52]	@ 0x34
34197688:	e044      	b.n	34197714 <_tx_thread_sleep+0xe4>
    }

#ifndef TX_TIMER_PROCESS_IN_ISR

    /* Is the caller the system timer thread?  */
    else if (thread_ptr == &_tx_timer_thread)
3419768a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3419768c:	4a26      	ldr	r2, [pc, #152]	@ (34197728 <_tx_thread_sleep+0xf8>)
3419768e:	4293      	cmp	r3, r2
34197690:	d108      	bne.n	341976a4 <_tx_thread_sleep+0x74>
34197692:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34197694:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34197696:	697b      	ldr	r3, [r7, #20]
34197698:	f383 8810 	msr	PRIMASK, r3
}
3419769c:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Illegal caller of this service.  */
        status =  TX_CALLER_ERROR;
3419769e:	2313      	movs	r3, #19
341976a0:	637b      	str	r3, [r7, #52]	@ 0x34
341976a2:	e037      	b.n	34197714 <_tx_thread_sleep+0xe4>
    }
#endif

    /* Determine if the requested number of ticks is zero.  */
    else if (timer_ticks == ((ULONG) 0))
341976a4:	687b      	ldr	r3, [r7, #4]
341976a6:	2b00      	cmp	r3, #0
341976a8:	d108      	bne.n	341976bc <_tx_thread_sleep+0x8c>
341976aa:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
341976ac:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
341976ae:	693b      	ldr	r3, [r7, #16]
341976b0:	f383 8810 	msr	PRIMASK, r3
}
341976b4:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Just return with a successful status.  */
        status =  TX_SUCCESS;
341976b6:	2300      	movs	r3, #0
341976b8:	637b      	str	r3, [r7, #52]	@ 0x34
341976ba:	e02b      	b.n	34197714 <_tx_thread_sleep+0xe4>
    }
    else
    {

        /* Determine if the preempt disable flag is non-zero.  */
        if (_tx_thread_preempt_disable != ((UINT) 0))
341976bc:	4b1b      	ldr	r3, [pc, #108]	@ (3419772c <_tx_thread_sleep+0xfc>)
341976be:	681b      	ldr	r3, [r3, #0]
341976c0:	2b00      	cmp	r3, #0
341976c2:	d008      	beq.n	341976d6 <_tx_thread_sleep+0xa6>
341976c4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
341976c6:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
341976c8:	68fb      	ldr	r3, [r7, #12]
341976ca:	f383 8810 	msr	PRIMASK, r3
}
341976ce:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Suspension is not allowed if the preempt disable flag is non-zero at this point - return error completion.  */
            status =  TX_CALLER_ERROR;
341976d0:	2313      	movs	r3, #19
341976d2:	637b      	str	r3, [r7, #52]	@ 0x34
341976d4:	e01e      	b.n	34197714 <_tx_thread_sleep+0xe4>
            TX_EL_THREAD_SLEEP_INSERT

            /* Suspend the current thread.  */

            /* Set the state to suspended.  */
            thread_ptr -> tx_thread_state =    TX_SLEEP;
341976d6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
341976d8:	2204      	movs	r2, #4
341976da:	631a      	str	r2, [r3, #48]	@ 0x30
            /* Restore interrupts.  */
            TX_RESTORE
#else

            /* Set the suspending flag. */
            thread_ptr -> tx_thread_suspending =  TX_TRUE;
341976dc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
341976de:	2201      	movs	r2, #1
341976e0:	639a      	str	r2, [r3, #56]	@ 0x38

            /* Initialize the status to successful.  */
            thread_ptr -> tx_thread_suspend_status =  TX_SUCCESS;
341976e2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
341976e4:	2200      	movs	r2, #0
341976e6:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84

            /* Setup the timeout period.  */
            thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  timer_ticks;
341976ea:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
341976ec:	687a      	ldr	r2, [r7, #4]
341976ee:	64da      	str	r2, [r3, #76]	@ 0x4c

            /* Temporarily disable preemption.  */
            _tx_thread_preempt_disable++;
341976f0:	4b0e      	ldr	r3, [pc, #56]	@ (3419772c <_tx_thread_sleep+0xfc>)
341976f2:	681b      	ldr	r3, [r3, #0]
341976f4:	3301      	adds	r3, #1
341976f6:	4a0d      	ldr	r2, [pc, #52]	@ (3419772c <_tx_thread_sleep+0xfc>)
341976f8:	6013      	str	r3, [r2, #0]
341976fa:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
341976fc:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
341976fe:	68bb      	ldr	r3, [r7, #8]
34197700:	f383 8810 	msr	PRIMASK, r3
}
34197704:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Call actual thread suspension routine.  */
            _tx_thread_system_suspend(thread_ptr);
34197706:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
34197708:	f000 f9bc 	bl	34197a84 <_tx_thread_system_suspend>
#endif

            /* Return status to the caller.  */
            status =  thread_ptr -> tx_thread_suspend_status;
3419770c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3419770e:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
34197712:	637b      	str	r3, [r7, #52]	@ 0x34
        }
    }

    /* Return completion status.  */
    return(status);
34197714:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
}
34197716:	4618      	mov	r0, r3
34197718:	3738      	adds	r7, #56	@ 0x38
3419771a:	46bd      	mov	sp, r7
3419771c:	bd80      	pop	{r7, pc}
3419771e:	bf00      	nop
34197720:	341c2dec 	.word	0x341c2dec
34197724:	341c009c 	.word	0x341c009c
34197728:	341c2f34 	.word	0x341c2f34
3419772c:	341c2e84 	.word	0x341c2e84

34197730 <_tx_thread_suspend>:
/*                                            a MISRA compliance issue,   */
/*                                            resulting in version 6.1.1  */
/*                                                                        */
/**************************************************************************/
UINT  _tx_thread_suspend(TX_THREAD *thread_ptr)
{
34197730:	b580      	push	{r7, lr}
34197732:	b08a      	sub	sp, #40	@ 0x28
34197734:	af00      	add	r7, sp, #0
34197736:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34197738:	f3ef 8310 	mrs	r3, PRIMASK
3419773c:	61bb      	str	r3, [r7, #24]
    return(posture);
3419773e:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
34197740:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
34197742:	b672      	cpsid	i
    return(int_posture);
34197744:	697b      	ldr	r3, [r7, #20]


#ifndef TX_INLINE_THREAD_RESUME_SUSPEND

    /* Lockout interrupts while the thread is being suspended.  */
    TX_DISABLE
34197746:	623b      	str	r3, [r7, #32]

    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(current_thread)
34197748:	4b2e      	ldr	r3, [pc, #184]	@ (34197804 <_tx_thread_suspend+0xd4>)
3419774a:	681b      	ldr	r3, [r3, #0]
3419774c:	61fb      	str	r3, [r7, #28]

    /* Log this kernel call.  */
    TX_EL_THREAD_SUSPEND_INSERT

    /* Check the specified thread's current status.  */
    if (thread_ptr -> tx_thread_state == TX_READY)
3419774e:	687b      	ldr	r3, [r7, #4]
34197750:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34197752:	2b00      	cmp	r3, #0
34197754:	d130      	bne.n	341977b8 <_tx_thread_suspend+0x88>
    {

        /* Initialize status to success.  */
        status =  TX_SUCCESS;
34197756:	2300      	movs	r3, #0
34197758:	627b      	str	r3, [r7, #36]	@ 0x24
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
3419775a:	f3ef 8305 	mrs	r3, IPSR
3419775e:	613b      	str	r3, [r7, #16]
    return(ipsr_value);
34197760:	693a      	ldr	r2, [r7, #16]

        /* Determine if we are in a thread context.  */
        if (TX_THREAD_GET_SYSTEM_STATE() == ((ULONG) 0))
34197762:	4b29      	ldr	r3, [pc, #164]	@ (34197808 <_tx_thread_suspend+0xd8>)
34197764:	681b      	ldr	r3, [r3, #0]
34197766:	4313      	orrs	r3, r2
34197768:	2b00      	cmp	r3, #0
3419776a:	d109      	bne.n	34197780 <_tx_thread_suspend+0x50>
        {

            /* Yes, we are in a thread context.  */

            /* Determine if the current thread is also the suspending thread.  */
            if (current_thread == thread_ptr)
3419776c:	69fa      	ldr	r2, [r7, #28]
3419776e:	687b      	ldr	r3, [r7, #4]
34197770:	429a      	cmp	r2, r3
34197772:	d105      	bne.n	34197780 <_tx_thread_suspend+0x50>
            {

                /* Now determine if the preempt disable flag is non-zero.  */
                if (_tx_thread_preempt_disable != ((UINT) 0))
34197774:	4b25      	ldr	r3, [pc, #148]	@ (3419780c <_tx_thread_suspend+0xdc>)
34197776:	681b      	ldr	r3, [r3, #0]
34197778:	2b00      	cmp	r3, #0
3419777a:	d001      	beq.n	34197780 <_tx_thread_suspend+0x50>
                {

                    /* Current thread cannot suspend when the preempt disable flag is non-zero,
                       return an error.  */
                    status =  TX_SUSPEND_ERROR;
3419777c:	2314      	movs	r3, #20
3419777e:	627b      	str	r3, [r7, #36]	@ 0x24
                }
            }
        }

        /* Determine if the status is still successful.  */
        if (status == TX_SUCCESS)
34197780:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34197782:	2b00      	cmp	r3, #0
34197784:	d132      	bne.n	341977ec <_tx_thread_suspend+0xbc>
        {

            /* Set the state to suspended.  */
            thread_ptr -> tx_thread_state =    TX_SUSPENDED;
34197786:	687b      	ldr	r3, [r7, #4]
34197788:	2203      	movs	r2, #3
3419778a:	631a      	str	r2, [r3, #48]	@ 0x30
            /* Restore interrupts.  */
            TX_RESTORE
#else

            /* Set the suspending flag. */
            thread_ptr -> tx_thread_suspending =  TX_TRUE;
3419778c:	687b      	ldr	r3, [r7, #4]
3419778e:	2201      	movs	r2, #1
34197790:	639a      	str	r2, [r3, #56]	@ 0x38

            /* Setup for no timeout period.  */
            thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  ((ULONG) 0);
34197792:	687b      	ldr	r3, [r7, #4]
34197794:	2200      	movs	r2, #0
34197796:	64da      	str	r2, [r3, #76]	@ 0x4c

            /* Temporarily disable preemption.  */
            _tx_thread_preempt_disable++;
34197798:	4b1c      	ldr	r3, [pc, #112]	@ (3419780c <_tx_thread_suspend+0xdc>)
3419779a:	681b      	ldr	r3, [r3, #0]
3419779c:	3301      	adds	r3, #1
3419779e:	4a1b      	ldr	r2, [pc, #108]	@ (3419780c <_tx_thread_suspend+0xdc>)
341977a0:	6013      	str	r3, [r2, #0]
341977a2:	6a3b      	ldr	r3, [r7, #32]
341977a4:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
341977a6:	68fb      	ldr	r3, [r7, #12]
341977a8:	f383 8810 	msr	PRIMASK, r3
}
341977ac:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Call actual thread suspension routine.  */
            _tx_thread_system_suspend(thread_ptr);
341977ae:	6878      	ldr	r0, [r7, #4]
341977b0:	f000 f968 	bl	34197a84 <_tx_thread_system_suspend>
            /* Return success.  */
            status =  TX_SUCCESS;
#else

            /* If MISRA is not enabled, return directly.  */
            return(TX_SUCCESS);
341977b4:	2300      	movs	r3, #0
341977b6:	e020      	b.n	341977fa <_tx_thread_suspend+0xca>
#endif
        }
    }
    else if (thread_ptr -> tx_thread_state == TX_TERMINATED)
341977b8:	687b      	ldr	r3, [r7, #4]
341977ba:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
341977bc:	2b02      	cmp	r3, #2
341977be:	d102      	bne.n	341977c6 <_tx_thread_suspend+0x96>
    {

        /* Thread is terminated.  */
        status =  TX_SUSPEND_ERROR;
341977c0:	2314      	movs	r3, #20
341977c2:	627b      	str	r3, [r7, #36]	@ 0x24
341977c4:	e012      	b.n	341977ec <_tx_thread_suspend+0xbc>
    }
    else if (thread_ptr -> tx_thread_state == TX_COMPLETED)
341977c6:	687b      	ldr	r3, [r7, #4]
341977c8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
341977ca:	2b01      	cmp	r3, #1
341977cc:	d102      	bne.n	341977d4 <_tx_thread_suspend+0xa4>
    {

        /* Thread is completed.  */
        status =  TX_SUSPEND_ERROR;
341977ce:	2314      	movs	r3, #20
341977d0:	627b      	str	r3, [r7, #36]	@ 0x24
341977d2:	e00b      	b.n	341977ec <_tx_thread_suspend+0xbc>
    }
    else if (thread_ptr -> tx_thread_state == TX_SUSPENDED)
341977d4:	687b      	ldr	r3, [r7, #4]
341977d6:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
341977d8:	2b03      	cmp	r3, #3
341977da:	d102      	bne.n	341977e2 <_tx_thread_suspend+0xb2>
    {

        /* Already suspended, just set status to success.  */
        status =  TX_SUCCESS;
341977dc:	2300      	movs	r3, #0
341977de:	627b      	str	r3, [r7, #36]	@ 0x24
341977e0:	e004      	b.n	341977ec <_tx_thread_suspend+0xbc>
    }
    else
    {

        /* Just set the delayed suspension flag.  */
        thread_ptr -> tx_thread_delayed_suspend =  TX_TRUE;
341977e2:	687b      	ldr	r3, [r7, #4]
341977e4:	2201      	movs	r2, #1
341977e6:	635a      	str	r2, [r3, #52]	@ 0x34

        /* Set status to success.  */
        status =  TX_SUCCESS;
341977e8:	2300      	movs	r3, #0
341977ea:	627b      	str	r3, [r7, #36]	@ 0x24
341977ec:	6a3b      	ldr	r3, [r7, #32]
341977ee:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
341977f0:	68bb      	ldr	r3, [r7, #8]
341977f2:	f383 8810 	msr	PRIMASK, r3
}
341977f6:	bf00      	nop
    /* Restore interrupts.  */
    TX_RESTORE

    /* Always return success, since this function does not perform error
       checking.  */
    return(status);
341977f8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
    TX_RESTORE

    /* Return completion status.  */
    return(status);
#endif
}
341977fa:	4618      	mov	r0, r3
341977fc:	3728      	adds	r7, #40	@ 0x28
341977fe:	46bd      	mov	sp, r7
34197800:	bd80      	pop	{r7, pc}
34197802:	bf00      	nop
34197804:	341c2dec 	.word	0x341c2dec
34197808:	341c009c 	.word	0x341c009c
3419780c:	341c2e84 	.word	0x341c2e84

34197810 <_tx_thread_system_preempt_check>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_thread_system_preempt_check(VOID)
{
34197810:	b480      	push	{r7}
34197812:	b089      	sub	sp, #36	@ 0x24
34197814:	af00      	add	r7, sp, #0
TX_THREAD       *current_thread;
TX_THREAD       *thread_ptr;


    /* Combine the system state and preempt disable flags into one for comparison.  */
    TX_THREAD_SYSTEM_RETURN_CHECK(combined_flags)
34197816:	4b17      	ldr	r3, [pc, #92]	@ (34197874 <_tx_thread_system_preempt_check+0x64>)
34197818:	681b      	ldr	r3, [r3, #0]
3419781a:	61fb      	str	r3, [r7, #28]

    /* Determine if we are in a system state (ISR or Initialization) or internal preemption is disabled.  */
    if (combined_flags == ((ULONG) 0))
3419781c:	69fb      	ldr	r3, [r7, #28]
3419781e:	2b00      	cmp	r3, #0
34197820:	d121      	bne.n	34197866 <_tx_thread_system_preempt_check+0x56>
    {

        /* No, at thread execution level so continue checking for preemption.  */

        /* Pickup thread pointer.  */
        TX_THREAD_GET_CURRENT(current_thread)
34197822:	4b15      	ldr	r3, [pc, #84]	@ (34197878 <_tx_thread_system_preempt_check+0x68>)
34197824:	681b      	ldr	r3, [r3, #0]
34197826:	61bb      	str	r3, [r7, #24]

        /* Pickup the next execute pointer.  */
        thread_ptr =  _tx_thread_execute_ptr;
34197828:	4b14      	ldr	r3, [pc, #80]	@ (3419787c <_tx_thread_system_preempt_check+0x6c>)
3419782a:	681b      	ldr	r3, [r3, #0]
3419782c:	617b      	str	r3, [r7, #20]

        /* Determine if preemption should take place.  */
        if (current_thread != thread_ptr)
3419782e:	69ba      	ldr	r2, [r7, #24]
34197830:	697b      	ldr	r3, [r7, #20]
34197832:	429a      	cmp	r2, r3
34197834:	d017      	beq.n	34197866 <_tx_thread_system_preempt_check+0x56>
    *((volatile ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
34197836:	4b12      	ldr	r3, [pc, #72]	@ (34197880 <_tx_thread_system_preempt_check+0x70>)
34197838:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
3419783c:	601a      	str	r2, [r3, #0]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
3419783e:	f3ef 8305 	mrs	r3, IPSR
34197842:	613b      	str	r3, [r7, #16]
    return(ipsr_value);
34197844:	693b      	ldr	r3, [r7, #16]
    if (_tx_ipsr_get() == 0)
34197846:	2b00      	cmp	r3, #0
34197848:	d10c      	bne.n	34197864 <_tx_thread_system_preempt_check+0x54>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
3419784a:	f3ef 8310 	mrs	r3, PRIMASK
3419784e:	60fb      	str	r3, [r7, #12]
    return(posture);
34197850:	68fb      	ldr	r3, [r7, #12]
        interrupt_save = __get_interrupt_posture();
34197852:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("CPSIE  i": : : "memory");
34197854:	b662      	cpsie	i
}
34197856:	bf00      	nop
34197858:	68bb      	ldr	r3, [r7, #8]
3419785a:	607b      	str	r3, [r7, #4]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
3419785c:	687b      	ldr	r3, [r7, #4]
3419785e:	f383 8810 	msr	PRIMASK, r3
}
34197862:	bf00      	nop
}
34197864:	bf00      	nop

            /* Return to the system so the higher priority thread can be scheduled.  */
            _tx_thread_system_return();
        }
    }
}
34197866:	bf00      	nop
34197868:	3724      	adds	r7, #36	@ 0x24
3419786a:	46bd      	mov	sp, r7
3419786c:	f85d 7b04 	ldr.w	r7, [sp], #4
34197870:	4770      	bx	lr
34197872:	bf00      	nop
34197874:	341c2e84 	.word	0x341c2e84
34197878:	341c2dec 	.word	0x341c2dec
3419787c:	341c2df0 	.word	0x341c2df0
34197880:	e000ed04 	.word	0xe000ed04

34197884 <_tx_thread_system_resume>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_thread_system_resume(TX_THREAD *thread_ptr)
#ifndef TX_NOT_INTERRUPTABLE
{
34197884:	b580      	push	{r7, lr}
34197886:	b096      	sub	sp, #88	@ 0x58
34197888:	af00      	add	r7, sp, #0
3419788a:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
3419788c:	f3ef 8310 	mrs	r3, PRIMASK
34197890:	637b      	str	r3, [r7, #52]	@ 0x34
    return(posture);
34197892:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
    int_posture = __get_interrupt_posture();
34197894:	633b      	str	r3, [r7, #48]	@ 0x30
    __asm__ volatile ("CPSID i" : : : "memory");
34197896:	b672      	cpsid	i
    return(int_posture);
34197898:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    /* Check this thread's stack.  */
    TX_THREAD_STACK_CHECK(thread_ptr)
#endif

    /* Lockout interrupts while the thread is being resumed.  */
    TX_DISABLE
3419789a:	657b      	str	r3, [r7, #84]	@ 0x54

#ifndef TX_NO_TIMER

    /* Deactivate the timeout timer if necessary.  */
    if (thread_ptr -> tx_thread_timer.tx_timer_internal_list_head != TX_NULL)
3419789c:	687b      	ldr	r3, [r7, #4]
3419789e:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
341978a0:	2b00      	cmp	r3, #0
341978a2:	d005      	beq.n	341978b0 <_tx_thread_system_resume+0x2c>
    {

        /* Deactivate the thread's timeout timer.  */
        _tx_timer_system_deactivate(&(thread_ptr -> tx_thread_timer));
341978a4:	687b      	ldr	r3, [r7, #4]
341978a6:	334c      	adds	r3, #76	@ 0x4c
341978a8:	4618      	mov	r0, r3
341978aa:	f000 fd2f 	bl	3419830c <_tx_timer_system_deactivate>
341978ae:	e002      	b.n	341978b6 <_tx_thread_system_resume+0x32>
    }
    else
    {

        /* Clear the remaining time to ensure timer doesn't get activated.  */
        thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  ((ULONG) 0);
341978b0:	687b      	ldr	r3, [r7, #4]
341978b2:	2200      	movs	r2, #0
341978b4:	64da      	str	r2, [r3, #76]	@ 0x4c
        time_stamp =  entry_ptr -> tx_trace_buffer_entry_time_stamp;
    }
#endif

    /* Decrease the preempt disabled count.  */
    _tx_thread_preempt_disable--;
341978b6:	4b6c      	ldr	r3, [pc, #432]	@ (34197a68 <_tx_thread_system_resume+0x1e4>)
341978b8:	681b      	ldr	r3, [r3, #0]
341978ba:	3b01      	subs	r3, #1
341978bc:	4a6a      	ldr	r2, [pc, #424]	@ (34197a68 <_tx_thread_system_resume+0x1e4>)
341978be:	6013      	str	r3, [r2, #0]

    /* Determine if the thread is in the process of suspending.  If so, the thread
       control block is already on the linked list so nothing needs to be done.  */
    if (thread_ptr -> tx_thread_suspending == TX_FALSE)
341978c0:	687b      	ldr	r3, [r7, #4]
341978c2:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
341978c4:	2b00      	cmp	r3, #0
341978c6:	f040 8083 	bne.w	341979d0 <_tx_thread_system_resume+0x14c>
    {

        /* Thread is not in the process of suspending. Now check to make sure the thread
           has not already been resumed.  */
        if (thread_ptr -> tx_thread_state != TX_READY)
341978ca:	687b      	ldr	r3, [r7, #4]
341978cc:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
341978ce:	2b00      	cmp	r3, #0
341978d0:	f000 8097 	beq.w	34197a02 <_tx_thread_system_resume+0x17e>
        {

            /* No, now check to see if the delayed suspension flag is set.  */
            if (thread_ptr -> tx_thread_delayed_suspend == TX_FALSE)
341978d4:	687b      	ldr	r3, [r7, #4]
341978d6:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
341978d8:	2b00      	cmp	r3, #0
341978da:	d172      	bne.n	341979c2 <_tx_thread_system_resume+0x13e>
                /* Resume the thread!  */

                /* Make this thread ready.  */

                /* Change the state to ready.  */
                thread_ptr -> tx_thread_state =  TX_READY;
341978dc:	687b      	ldr	r3, [r7, #4]
341978de:	2200      	movs	r2, #0
341978e0:	631a      	str	r2, [r3, #48]	@ 0x30

                /* Pickup priority of thread.  */
                priority =  thread_ptr -> tx_thread_priority;
341978e2:	687b      	ldr	r3, [r7, #4]
341978e4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
341978e6:	653b      	str	r3, [r7, #80]	@ 0x50
                thread_ptr -> tx_thread_performance_resume_count++;
#endif

                /* Determine if there are other threads at this priority that are
                   ready.  */
                head_ptr =  _tx_thread_priority_list[priority];
341978e8:	4a60      	ldr	r2, [pc, #384]	@ (34197a6c <_tx_thread_system_resume+0x1e8>)
341978ea:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
341978ec:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
341978f0:	64fb      	str	r3, [r7, #76]	@ 0x4c
                if (head_ptr == TX_NULL)
341978f2:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
341978f4:	2b00      	cmp	r3, #0
341978f6:	d154      	bne.n	341979a2 <_tx_thread_system_resume+0x11e>
                {

                    /* First thread at this priority ready.  Add to the front of the list.  */
                    _tx_thread_priority_list[priority] =       thread_ptr;
341978f8:	495c      	ldr	r1, [pc, #368]	@ (34197a6c <_tx_thread_system_resume+0x1e8>)
341978fa:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
341978fc:	687a      	ldr	r2, [r7, #4]
341978fe:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
                    thread_ptr -> tx_thread_ready_next =       thread_ptr;
34197902:	687b      	ldr	r3, [r7, #4]
34197904:	687a      	ldr	r2, [r7, #4]
34197906:	621a      	str	r2, [r3, #32]
                    thread_ptr -> tx_thread_ready_previous =   thread_ptr;
34197908:	687b      	ldr	r3, [r7, #4]
3419790a:	687a      	ldr	r2, [r7, #4]
3419790c:	625a      	str	r2, [r3, #36]	@ 0x24
                    TX_DIV32_BIT_SET(priority, priority_bit)
                    _tx_thread_priority_map_active =  _tx_thread_priority_map_active | priority_bit;
#endif

                    /* Or in the thread's priority bit.  */
                    TX_MOD32_BIT_SET(priority, priority_bit)
3419790e:	2201      	movs	r2, #1
34197910:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
34197912:	fa02 f303 	lsl.w	r3, r2, r3
34197916:	647b      	str	r3, [r7, #68]	@ 0x44
                    _tx_thread_priority_maps[MAP_INDEX] =  _tx_thread_priority_maps[MAP_INDEX] | priority_bit;
34197918:	4b55      	ldr	r3, [pc, #340]	@ (34197a70 <_tx_thread_system_resume+0x1ec>)
3419791a:	681a      	ldr	r2, [r3, #0]
3419791c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3419791e:	4313      	orrs	r3, r2
34197920:	4a53      	ldr	r2, [pc, #332]	@ (34197a70 <_tx_thread_system_resume+0x1ec>)
34197922:	6013      	str	r3, [r2, #0]

                    /* Determine if this newly ready thread is the highest priority.  */
                    if (priority < _tx_thread_highest_priority)
34197924:	4b53      	ldr	r3, [pc, #332]	@ (34197a74 <_tx_thread_system_resume+0x1f0>)
34197926:	681b      	ldr	r3, [r3, #0]
34197928:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
3419792a:	429a      	cmp	r2, r3
3419792c:	d269      	bcs.n	34197a02 <_tx_thread_system_resume+0x17e>
                    {

                        /* A new highest priority thread is present. */

                        /* Update the highest priority variable.  */
                        _tx_thread_highest_priority =  priority;
3419792e:	4a51      	ldr	r2, [pc, #324]	@ (34197a74 <_tx_thread_system_resume+0x1f0>)
34197930:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
34197932:	6013      	str	r3, [r2, #0]

                        /* Pickup the execute pointer. Since it is going to be referenced multiple
                           times, it is placed in a local variable.  */
                        execute_ptr =  _tx_thread_execute_ptr;
34197934:	4b50      	ldr	r3, [pc, #320]	@ (34197a78 <_tx_thread_system_resume+0x1f4>)
34197936:	681b      	ldr	r3, [r3, #0]
34197938:	643b      	str	r3, [r7, #64]	@ 0x40

                        /* Determine if no thread is currently executing.  */
                        if (execute_ptr == TX_NULL)
3419793a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419793c:	2b00      	cmp	r3, #0
3419793e:	d103      	bne.n	34197948 <_tx_thread_system_resume+0xc4>
                        {

                            /* Simply setup the execute pointer.  */
                            _tx_thread_execute_ptr =  thread_ptr;
34197940:	4a4d      	ldr	r2, [pc, #308]	@ (34197a78 <_tx_thread_system_resume+0x1f4>)
34197942:	687b      	ldr	r3, [r7, #4]
34197944:	6013      	str	r3, [r2, #0]
34197946:	e05c      	b.n	34197a02 <_tx_thread_system_resume+0x17e>
                        {

                            /* Another thread has been scheduled for execution.  */

                            /* Check to see if this is a higher priority thread and determine if preemption is allowed.  */
                            if (priority < execute_ptr -> tx_thread_preempt_threshold)
34197948:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419794a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3419794c:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
3419794e:	429a      	cmp	r2, r3
34197950:	d257      	bcs.n	34197a02 <_tx_thread_system_resume+0x17e>
                                execute_ptr -> tx_thread_performance_last_preempting_thread =  thread_ptr;

#endif

                                /* Yes, modify the execute thread pointer.  */
                                _tx_thread_execute_ptr =  thread_ptr;
34197952:	4a49      	ldr	r2, [pc, #292]	@ (34197a78 <_tx_thread_system_resume+0x1f4>)
34197954:	687b      	ldr	r3, [r7, #4]
34197956:	6013      	str	r3, [r2, #0]
34197958:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3419795a:	62fb      	str	r3, [r7, #44]	@ 0x2c
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
3419795c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3419795e:	f383 8810 	msr	PRIMASK, r3
}
34197962:	bf00      	nop
                                TX_THREAD_STACK_CHECK(thread_ptr)
#endif

                                /* Now determine if preemption should take place. This is only possible if the current thread pointer is
                                   not the same as the execute thread pointer AND the system state and preempt disable flags are clear.  */
                                TX_THREAD_SYSTEM_RETURN_CHECK(combined_flags)
34197964:	4b40      	ldr	r3, [pc, #256]	@ (34197a68 <_tx_thread_system_resume+0x1e4>)
34197966:	681b      	ldr	r3, [r3, #0]
34197968:	63fb      	str	r3, [r7, #60]	@ 0x3c
                                if (combined_flags == ((ULONG) 0))
3419796a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3419796c:	2b00      	cmp	r3, #0
3419796e:	d174      	bne.n	34197a5a <_tx_thread_system_resume+0x1d6>
    *((volatile ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
34197970:	4b42      	ldr	r3, [pc, #264]	@ (34197a7c <_tx_thread_system_resume+0x1f8>)
34197972:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
34197976:	601a      	str	r2, [r3, #0]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
34197978:	f3ef 8305 	mrs	r3, IPSR
3419797c:	62bb      	str	r3, [r7, #40]	@ 0x28
    return(ipsr_value);
3419797e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
    if (_tx_ipsr_get() == 0)
34197980:	2b00      	cmp	r3, #0
34197982:	d10c      	bne.n	3419799e <_tx_thread_system_resume+0x11a>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34197984:	f3ef 8310 	mrs	r3, PRIMASK
34197988:	627b      	str	r3, [r7, #36]	@ 0x24
    return(posture);
3419798a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
        interrupt_save = __get_interrupt_posture();
3419798c:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("CPSIE  i": : : "memory");
3419798e:	b662      	cpsie	i
}
34197990:	bf00      	nop
34197992:	6a3b      	ldr	r3, [r7, #32]
34197994:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34197996:	69fb      	ldr	r3, [r7, #28]
34197998:	f383 8810 	msr	PRIMASK, r3
}
3419799c:	bf00      	nop
}
3419799e:	bf00      	nop
                                    /* Preemption is needed - return to the system!  */
                                    _tx_thread_system_return();
                                }

                                /* Return in-line when MISRA is not enabled.  */
                                return;
341979a0:	e05b      	b.n	34197a5a <_tx_thread_system_resume+0x1d6>
                {

                    /* No, there are other threads at this priority already ready.  */

                    /* Just add this thread to the priority list.  */
                    tail_ptr =                                 head_ptr -> tx_thread_ready_previous;
341979a2:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
341979a4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
341979a6:	64bb      	str	r3, [r7, #72]	@ 0x48
                    tail_ptr -> tx_thread_ready_next =         thread_ptr;
341979a8:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
341979aa:	687a      	ldr	r2, [r7, #4]
341979ac:	621a      	str	r2, [r3, #32]
                    head_ptr -> tx_thread_ready_previous =     thread_ptr;
341979ae:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
341979b0:	687a      	ldr	r2, [r7, #4]
341979b2:	625a      	str	r2, [r3, #36]	@ 0x24
                    thread_ptr -> tx_thread_ready_previous =   tail_ptr;
341979b4:	687b      	ldr	r3, [r7, #4]
341979b6:	6cba      	ldr	r2, [r7, #72]	@ 0x48
341979b8:	625a      	str	r2, [r3, #36]	@ 0x24
                    thread_ptr -> tx_thread_ready_next =       head_ptr;
341979ba:	687b      	ldr	r3, [r7, #4]
341979bc:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
341979be:	621a      	str	r2, [r3, #32]
341979c0:	e01f      	b.n	34197a02 <_tx_thread_system_resume+0x17e>
            /* Else, delayed suspend flag was set.  */
            else
            {

                /* Clear the delayed suspend flag and change the state.  */
                thread_ptr -> tx_thread_delayed_suspend =  TX_FALSE;
341979c2:	687b      	ldr	r3, [r7, #4]
341979c4:	2200      	movs	r2, #0
341979c6:	635a      	str	r2, [r3, #52]	@ 0x34
                thread_ptr -> tx_thread_state =            TX_SUSPENDED;
341979c8:	687b      	ldr	r3, [r7, #4]
341979ca:	2203      	movs	r2, #3
341979cc:	631a      	str	r2, [r3, #48]	@ 0x30
341979ce:	e018      	b.n	34197a02 <_tx_thread_system_resume+0x17e>
        /* A resumption occurred in the middle of a previous thread suspension.  */

        /* Make sure the type of suspension under way is not a terminate or
           thread completion.  In either of these cases, do not void the
           interrupted suspension processing.  */
        if (thread_ptr -> tx_thread_state != TX_COMPLETED)
341979d0:	687b      	ldr	r3, [r7, #4]
341979d2:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
341979d4:	2b01      	cmp	r3, #1
341979d6:	d014      	beq.n	34197a02 <_tx_thread_system_resume+0x17e>
        {

            /* Make sure the thread isn't terminated.  */
            if (thread_ptr -> tx_thread_state != TX_TERMINATED)
341979d8:	687b      	ldr	r3, [r7, #4]
341979da:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
341979dc:	2b02      	cmp	r3, #2
341979de:	d010      	beq.n	34197a02 <_tx_thread_system_resume+0x17e>
            {

                /* No, now check to see if the delayed suspension flag is set.  */
                if (thread_ptr -> tx_thread_delayed_suspend == TX_FALSE)
341979e0:	687b      	ldr	r3, [r7, #4]
341979e2:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
341979e4:	2b00      	cmp	r3, #0
341979e6:	d106      	bne.n	341979f6 <_tx_thread_system_resume+0x172>
                {

                    /* Clear the suspending flag.  */
                    thread_ptr -> tx_thread_suspending =   TX_FALSE;
341979e8:	687b      	ldr	r3, [r7, #4]
341979ea:	2200      	movs	r2, #0
341979ec:	639a      	str	r2, [r3, #56]	@ 0x38

                    /* Restore the state to ready.  */
                    thread_ptr -> tx_thread_state =        TX_READY;
341979ee:	687b      	ldr	r3, [r7, #4]
341979f0:	2200      	movs	r2, #0
341979f2:	631a      	str	r2, [r3, #48]	@ 0x30
341979f4:	e005      	b.n	34197a02 <_tx_thread_system_resume+0x17e>
                }
                else
                {

                    /* Clear the delayed suspend flag and change the state.  */
                    thread_ptr -> tx_thread_delayed_suspend =  TX_FALSE;
341979f6:	687b      	ldr	r3, [r7, #4]
341979f8:	2200      	movs	r2, #0
341979fa:	635a      	str	r2, [r3, #52]	@ 0x34
                    thread_ptr -> tx_thread_state =            TX_SUSPENDED;
341979fc:	687b      	ldr	r3, [r7, #4]
341979fe:	2203      	movs	r2, #3
34197a00:	631a      	str	r2, [r3, #48]	@ 0x30
        }
    }
#endif

    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(current_thread)
34197a02:	4b1f      	ldr	r3, [pc, #124]	@ (34197a80 <_tx_thread_system_resume+0x1fc>)
34197a04:	681b      	ldr	r3, [r3, #0]
34197a06:	63bb      	str	r3, [r7, #56]	@ 0x38
34197a08:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34197a0a:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34197a0c:	69bb      	ldr	r3, [r7, #24]
34197a0e:	f383 8810 	msr	PRIMASK, r3
}
34197a12:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Determine if a preemption condition is present.  */
    if (current_thread != _tx_thread_execute_ptr)
34197a14:	4b18      	ldr	r3, [pc, #96]	@ (34197a78 <_tx_thread_system_resume+0x1f4>)
34197a16:	681b      	ldr	r3, [r3, #0]
34197a18:	6bba      	ldr	r2, [r7, #56]	@ 0x38
34197a1a:	429a      	cmp	r2, r3
34197a1c:	d020      	beq.n	34197a60 <_tx_thread_system_resume+0x1dc>
        TX_THREAD_STACK_CHECK(thread_ptr)
#endif

        /* Now determine if preemption should take place. This is only possible if the current thread pointer is
           not the same as the execute thread pointer AND the system state and preempt disable flags are clear.  */
        TX_THREAD_SYSTEM_RETURN_CHECK(combined_flags)
34197a1e:	4b12      	ldr	r3, [pc, #72]	@ (34197a68 <_tx_thread_system_resume+0x1e4>)
34197a20:	681b      	ldr	r3, [r3, #0]
34197a22:	63fb      	str	r3, [r7, #60]	@ 0x3c
        if (combined_flags == ((ULONG) 0))
34197a24:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34197a26:	2b00      	cmp	r3, #0
34197a28:	d11a      	bne.n	34197a60 <_tx_thread_system_resume+0x1dc>
    *((volatile ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
34197a2a:	4b14      	ldr	r3, [pc, #80]	@ (34197a7c <_tx_thread_system_resume+0x1f8>)
34197a2c:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
34197a30:	601a      	str	r2, [r3, #0]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
34197a32:	f3ef 8305 	mrs	r3, IPSR
34197a36:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
34197a38:	697b      	ldr	r3, [r7, #20]
    if (_tx_ipsr_get() == 0)
34197a3a:	2b00      	cmp	r3, #0
34197a3c:	d10f      	bne.n	34197a5e <_tx_thread_system_resume+0x1da>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34197a3e:	f3ef 8310 	mrs	r3, PRIMASK
34197a42:	613b      	str	r3, [r7, #16]
    return(posture);
34197a44:	693b      	ldr	r3, [r7, #16]
        interrupt_save = __get_interrupt_posture();
34197a46:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("CPSIE  i": : : "memory");
34197a48:	b662      	cpsie	i
}
34197a4a:	bf00      	nop
34197a4c:	68fb      	ldr	r3, [r7, #12]
34197a4e:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34197a50:	68bb      	ldr	r3, [r7, #8]
34197a52:	f383 8810 	msr	PRIMASK, r3
}
34197a56:	bf00      	nop
}
34197a58:	e001      	b.n	34197a5e <_tx_thread_system_resume+0x1da>
                                return;
34197a5a:	bf00      	nop
34197a5c:	e000      	b.n	34197a60 <_tx_thread_system_resume+0x1dc>
34197a5e:	bf00      	nop

            /* Preemption is needed - return to the system!  */
            _tx_thread_system_return();
        }
    }
}
34197a60:	3758      	adds	r7, #88	@ 0x58
34197a62:	46bd      	mov	sp, r7
34197a64:	bd80      	pop	{r7, pc}
34197a66:	bf00      	nop
34197a68:	341c2e84 	.word	0x341c2e84
34197a6c:	341c2e04 	.word	0x341c2e04
34197a70:	341c2dfc 	.word	0x341c2dfc
34197a74:	341c2e00 	.word	0x341c2e00
34197a78:	341c2df0 	.word	0x341c2df0
34197a7c:	e000ed04 	.word	0xe000ed04
34197a80:	341c2dec 	.word	0x341c2dec

34197a84 <_tx_thread_system_suspend>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_thread_system_suspend(TX_THREAD *thread_ptr)
#ifndef TX_NOT_INTERRUPTABLE
{
34197a84:	b580      	push	{r7, lr}
34197a86:	b09e      	sub	sp, #120	@ 0x78
34197a88:	af00      	add	r7, sp, #0
34197a8a:	6078      	str	r0, [r7, #4]
TX_TRACE_BUFFER_ENTRY       *entry_ptr;
ULONG                       time_stamp =  ((ULONG) 0);
#endif

    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(current_thread)
34197a8c:	4b81      	ldr	r3, [pc, #516]	@ (34197c94 <_tx_thread_system_suspend+0x210>)
34197a8e:	681b      	ldr	r3, [r3, #0]
34197a90:	677b      	str	r3, [r7, #116]	@ 0x74
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34197a92:	f3ef 8310 	mrs	r3, PRIMASK
34197a96:	64fb      	str	r3, [r7, #76]	@ 0x4c
    return(posture);
34197a98:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
    int_posture = __get_interrupt_posture();
34197a9a:	64bb      	str	r3, [r7, #72]	@ 0x48
    __asm__ volatile ("CPSID i" : : : "memory");
34197a9c:	b672      	cpsid	i
    return(int_posture);
34197a9e:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
    /* Check this thread's stack.  */
    TX_THREAD_STACK_CHECK(thread_ptr)
#endif

    /* Lockout interrupts while the thread is being suspended.  */
    TX_DISABLE
34197aa0:	673b      	str	r3, [r7, #112]	@ 0x70

#ifndef TX_NO_TIMER

    /* Is the current thread suspending?  */
    if (thread_ptr == current_thread)
34197aa2:	687a      	ldr	r2, [r7, #4]
34197aa4:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
34197aa6:	429a      	cmp	r2, r3
34197aa8:	d112      	bne.n	34197ad0 <_tx_thread_system_suspend+0x4c>
    {

        /* Pickup the wait option.  */
        timeout =  thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks;
34197aaa:	687b      	ldr	r3, [r7, #4]
34197aac:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34197aae:	66fb      	str	r3, [r7, #108]	@ 0x6c

        /* Determine if an activation is needed.  */
        if (timeout != TX_NO_WAIT)
34197ab0:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
34197ab2:	2b00      	cmp	r3, #0
34197ab4:	d008      	beq.n	34197ac8 <_tx_thread_system_suspend+0x44>
        {

            /* Make sure the suspension is not a wait-forever.  */
            if (timeout != TX_WAIT_FOREVER)
34197ab6:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
34197ab8:	f1b3 3fff 	cmp.w	r3, #4294967295
34197abc:	d004      	beq.n	34197ac8 <_tx_thread_system_suspend+0x44>
            {

                /* Activate the thread timer with the timeout value setup in the caller.  */
                _tx_timer_system_activate(&(thread_ptr -> tx_thread_timer));
34197abe:	687b      	ldr	r3, [r7, #4]
34197ac0:	334c      	adds	r3, #76	@ 0x4c
34197ac2:	4618      	mov	r0, r3
34197ac4:	f000 fbc0 	bl	34198248 <_tx_timer_system_activate>
            }
        }

        /* Yes, reset time slice for current thread.  */
        _tx_timer_time_slice =  thread_ptr -> tx_thread_new_time_slice;
34197ac8:	687b      	ldr	r3, [r7, #4]
34197aca:	69db      	ldr	r3, [r3, #28]
34197acc:	4a72      	ldr	r2, [pc, #456]	@ (34197c98 <_tx_thread_system_suspend+0x214>)
34197ace:	6013      	str	r3, [r2, #0]
    }
#endif

    /* Decrease the preempt disabled count.  */
    _tx_thread_preempt_disable--;
34197ad0:	4b72      	ldr	r3, [pc, #456]	@ (34197c9c <_tx_thread_system_suspend+0x218>)
34197ad2:	681b      	ldr	r3, [r3, #0]
34197ad4:	3b01      	subs	r3, #1
34197ad6:	4a71      	ldr	r2, [pc, #452]	@ (34197c9c <_tx_thread_system_suspend+0x218>)
34197ad8:	6013      	str	r3, [r2, #0]
    _tx_thread_performance_suspend_count++;
#endif

    /* Check to make sure the thread suspending flag is still set.  If not, it
       has already been resumed.  */
    if (thread_ptr -> tx_thread_suspending == TX_TRUE)
34197ada:	687b      	ldr	r3, [r7, #4]
34197adc:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34197ade:	2b01      	cmp	r3, #1
34197ae0:	f040 80a6 	bne.w	34197c30 <_tx_thread_system_suspend+0x1ac>
            time_stamp =  entry_ptr -> tx_trace_buffer_entry_time_stamp;
        }
#endif

        /* Actually suspend this thread.  But first, clear the suspending flag.  */
        thread_ptr -> tx_thread_suspending =  TX_FALSE;
34197ae4:	687b      	ldr	r3, [r7, #4]
34197ae6:	2200      	movs	r2, #0
34197ae8:	639a      	str	r2, [r3, #56]	@ 0x38

        /* Pickup priority of thread.  */
        priority =  thread_ptr -> tx_thread_priority;
34197aea:	687b      	ldr	r3, [r7, #4]
34197aec:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34197aee:	66bb      	str	r3, [r7, #104]	@ 0x68

        /* Pickup the next ready thread pointer.  */
        ready_next =      thread_ptr -> tx_thread_ready_next;
34197af0:	687b      	ldr	r3, [r7, #4]
34197af2:	6a1b      	ldr	r3, [r3, #32]
34197af4:	667b      	str	r3, [r7, #100]	@ 0x64

        /* Determine if there are other threads at this priority that are
           ready.  */
        if (ready_next != thread_ptr)
34197af6:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
34197af8:	687b      	ldr	r3, [r7, #4]
34197afa:	429a      	cmp	r2, r3
34197afc:	d015      	beq.n	34197b2a <_tx_thread_system_suspend+0xa6>
        {

            /* Yes, there are other threads at this priority ready.  */

            /* Pickup the previous ready thread pointer.  */
            ready_previous =  thread_ptr -> tx_thread_ready_previous;
34197afe:	687b      	ldr	r3, [r7, #4]
34197b00:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34197b02:	653b      	str	r3, [r7, #80]	@ 0x50

            /* Just remove this thread from the priority list.  */
            ready_next -> tx_thread_ready_previous =    ready_previous;
34197b04:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
34197b06:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
34197b08:	625a      	str	r2, [r3, #36]	@ 0x24
            ready_previous -> tx_thread_ready_next =    ready_next;
34197b0a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
34197b0c:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
34197b0e:	621a      	str	r2, [r3, #32]

            /* Determine if this is the head of the priority list.  */
            if (_tx_thread_priority_list[priority] == thread_ptr)
34197b10:	4a63      	ldr	r2, [pc, #396]	@ (34197ca0 <_tx_thread_system_suspend+0x21c>)
34197b12:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
34197b14:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
34197b18:	687a      	ldr	r2, [r7, #4]
34197b1a:	429a      	cmp	r2, r3
34197b1c:	d157      	bne.n	34197bce <_tx_thread_system_suspend+0x14a>
            {

                /* Update the head pointer of this priority list.  */
                _tx_thread_priority_list[priority] =  ready_next;
34197b1e:	4960      	ldr	r1, [pc, #384]	@ (34197ca0 <_tx_thread_system_suspend+0x21c>)
34197b20:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
34197b22:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
34197b24:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
34197b28:	e051      	b.n	34197bce <_tx_thread_system_suspend+0x14a>
        else
        {

            /* This is the only thread at this priority ready to run.  Set the head
               pointer to NULL.  */
            _tx_thread_priority_list[priority] =    TX_NULL;
34197b2a:	4a5d      	ldr	r2, [pc, #372]	@ (34197ca0 <_tx_thread_system_suspend+0x21c>)
34197b2c:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
34197b2e:	2100      	movs	r1, #0
34197b30:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
            /* Calculate the index into the bit map array.  */
            map_index =  priority/((UINT) 32);
#endif

            /* Clear this priority bit in the ready priority bit map.  */
            TX_MOD32_BIT_SET(priority, priority_bit)
34197b34:	2201      	movs	r2, #1
34197b36:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
34197b38:	fa02 f303 	lsl.w	r3, r2, r3
34197b3c:	663b      	str	r3, [r7, #96]	@ 0x60
            _tx_thread_priority_maps[MAP_INDEX] =  _tx_thread_priority_maps[MAP_INDEX] & (~(priority_bit));
34197b3e:	4b59      	ldr	r3, [pc, #356]	@ (34197ca4 <_tx_thread_system_suspend+0x220>)
34197b40:	681a      	ldr	r2, [r3, #0]
34197b42:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
34197b44:	43db      	mvns	r3, r3
34197b46:	4013      	ands	r3, r2
34197b48:	4a56      	ldr	r2, [pc, #344]	@ (34197ca4 <_tx_thread_system_suspend+0x220>)
34197b4a:	6013      	str	r3, [r2, #0]
            /* Calculate the base priority as well.  */
            base_priority =  map_index * ((UINT) 32);
#else

            /* Setup the base priority to zero.  */
            base_priority =   ((UINT) 0);
34197b4c:	2300      	movs	r3, #0
34197b4e:	65fb      	str	r3, [r7, #92]	@ 0x5c
#endif

            /* Setup working variable for the priority map.  */
            priority_map =    _tx_thread_priority_maps[MAP_INDEX];
34197b50:	4b54      	ldr	r3, [pc, #336]	@ (34197ca4 <_tx_thread_system_suspend+0x220>)
34197b52:	681b      	ldr	r3, [r3, #0]
34197b54:	65bb      	str	r3, [r7, #88]	@ 0x58

            /* Make a quick check for no other threads ready for execution.  */
            if (priority_map == ((ULONG) 0))
34197b56:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
34197b58:	2b00      	cmp	r3, #0
34197b5a:	d12b      	bne.n	34197bb4 <_tx_thread_system_suspend+0x130>
            {

                /* Nothing else is ready.  Set highest priority and execute thread
                   accordingly.  */
                _tx_thread_highest_priority =  ((UINT) TX_MAX_PRIORITIES);
34197b5c:	4b52      	ldr	r3, [pc, #328]	@ (34197ca8 <_tx_thread_system_suspend+0x224>)
34197b5e:	2220      	movs	r2, #32
34197b60:	601a      	str	r2, [r3, #0]
                _tx_thread_execute_ptr =       TX_NULL;
34197b62:	4b52      	ldr	r3, [pc, #328]	@ (34197cac <_tx_thread_system_suspend+0x228>)
34197b64:	2200      	movs	r2, #0
34197b66:	601a      	str	r2, [r3, #0]
34197b68:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
34197b6a:	647b      	str	r3, [r7, #68]	@ 0x44
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34197b6c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34197b6e:	f383 8810 	msr	PRIMASK, r3
}
34197b72:	bf00      	nop
                /* Restore interrupts.  */
                TX_RESTORE

                /* Determine if preemption should take place. This is only possible if the current thread pointer is
                   not the same as the execute thread pointer AND the system state and preempt disable flags are clear.  */
                TX_THREAD_SYSTEM_RETURN_CHECK(combined_flags)
34197b74:	4b49      	ldr	r3, [pc, #292]	@ (34197c9c <_tx_thread_system_suspend+0x218>)
34197b76:	681b      	ldr	r3, [r3, #0]
34197b78:	657b      	str	r3, [r7, #84]	@ 0x54
                if (combined_flags == ((ULONG) 0))
34197b7a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34197b7c:	2b00      	cmp	r3, #0
34197b7e:	f040 8081 	bne.w	34197c84 <_tx_thread_system_suspend+0x200>
    *((volatile ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
34197b82:	4b4b      	ldr	r3, [pc, #300]	@ (34197cb0 <_tx_thread_system_suspend+0x22c>)
34197b84:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
34197b88:	601a      	str	r2, [r3, #0]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
34197b8a:	f3ef 8305 	mrs	r3, IPSR
34197b8e:	643b      	str	r3, [r7, #64]	@ 0x40
    return(ipsr_value);
34197b90:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
    if (_tx_ipsr_get() == 0)
34197b92:	2b00      	cmp	r3, #0
34197b94:	d10c      	bne.n	34197bb0 <_tx_thread_system_suspend+0x12c>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34197b96:	f3ef 8310 	mrs	r3, PRIMASK
34197b9a:	63fb      	str	r3, [r7, #60]	@ 0x3c
    return(posture);
34197b9c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
        interrupt_save = __get_interrupt_posture();
34197b9e:	63bb      	str	r3, [r7, #56]	@ 0x38
    __asm__ volatile ("CPSIE  i": : : "memory");
34197ba0:	b662      	cpsie	i
}
34197ba2:	bf00      	nop
34197ba4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34197ba6:	637b      	str	r3, [r7, #52]	@ 0x34
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34197ba8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34197baa:	f383 8810 	msr	PRIMASK, r3
}
34197bae:	bf00      	nop
}
34197bb0:	bf00      	nop
                    /* Preemption is needed - return to the system!  */
                    _tx_thread_system_return();
                }

                /* Return to caller.  */
                return;
34197bb2:	e067      	b.n	34197c84 <_tx_thread_system_suspend+0x200>
            {

                /* Other threads at different priority levels are ready to run.  */

                /* Calculate the lowest bit set in the priority map. */
                TX_LOWEST_SET_BIT_CALCULATE(priority_map, priority_bit)
34197bb4:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
34197bb6:	fa93 f3a3 	rbit	r3, r3
34197bba:	65bb      	str	r3, [r7, #88]	@ 0x58
34197bbc:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
34197bbe:	fab3 f383 	clz	r3, r3
34197bc2:	663b      	str	r3, [r7, #96]	@ 0x60

                /* Setup the next highest priority variable.  */
                _tx_thread_highest_priority =  base_priority + ((UINT) priority_bit);
34197bc4:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
34197bc6:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
34197bc8:	4413      	add	r3, r2
34197bca:	4a37      	ldr	r2, [pc, #220]	@ (34197ca8 <_tx_thread_system_suspend+0x224>)
34197bcc:	6013      	str	r3, [r2, #0]
            }
        }

        /* Determine if the suspending thread is the thread designated to execute.  */
        if (thread_ptr == _tx_thread_execute_ptr)
34197bce:	4b37      	ldr	r3, [pc, #220]	@ (34197cac <_tx_thread_system_suspend+0x228>)
34197bd0:	681b      	ldr	r3, [r3, #0]
34197bd2:	687a      	ldr	r2, [r7, #4]
34197bd4:	429a      	cmp	r2, r3
34197bd6:	d12b      	bne.n	34197c30 <_tx_thread_system_suspend+0x1ac>
        {

            /* Pickup the highest priority thread to execute.  */
            _tx_thread_execute_ptr =  _tx_thread_priority_list[_tx_thread_highest_priority];
34197bd8:	4b33      	ldr	r3, [pc, #204]	@ (34197ca8 <_tx_thread_system_suspend+0x224>)
34197bda:	681b      	ldr	r3, [r3, #0]
34197bdc:	4a30      	ldr	r2, [pc, #192]	@ (34197ca0 <_tx_thread_system_suspend+0x21c>)
34197bde:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
34197be2:	4a32      	ldr	r2, [pc, #200]	@ (34197cac <_tx_thread_system_suspend+0x228>)
34197be4:	6013      	str	r3, [r2, #0]
34197be6:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
34197be8:	633b      	str	r3, [r7, #48]	@ 0x30
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34197bea:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34197bec:	f383 8810 	msr	PRIMASK, r3
}
34197bf0:	bf00      	nop
            /* Restore interrupts.  */
            TX_RESTORE

            /* Determine if preemption should take place. This is only possible if the current thread pointer is
               not the same as the execute thread pointer AND the system state and preempt disable flags are clear.  */
            TX_THREAD_SYSTEM_RETURN_CHECK(combined_flags)
34197bf2:	4b2a      	ldr	r3, [pc, #168]	@ (34197c9c <_tx_thread_system_suspend+0x218>)
34197bf4:	681b      	ldr	r3, [r3, #0]
34197bf6:	657b      	str	r3, [r7, #84]	@ 0x54
            if (combined_flags == ((ULONG) 0))
34197bf8:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34197bfa:	2b00      	cmp	r3, #0
34197bfc:	d144      	bne.n	34197c88 <_tx_thread_system_suspend+0x204>
    *((volatile ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
34197bfe:	4b2c      	ldr	r3, [pc, #176]	@ (34197cb0 <_tx_thread_system_suspend+0x22c>)
34197c00:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
34197c04:	601a      	str	r2, [r3, #0]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
34197c06:	f3ef 8305 	mrs	r3, IPSR
34197c0a:	62fb      	str	r3, [r7, #44]	@ 0x2c
    return(ipsr_value);
34197c0c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
    if (_tx_ipsr_get() == 0)
34197c0e:	2b00      	cmp	r3, #0
34197c10:	d10c      	bne.n	34197c2c <_tx_thread_system_suspend+0x1a8>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34197c12:	f3ef 8310 	mrs	r3, PRIMASK
34197c16:	62bb      	str	r3, [r7, #40]	@ 0x28
    return(posture);
34197c18:	6abb      	ldr	r3, [r7, #40]	@ 0x28
        interrupt_save = __get_interrupt_posture();
34197c1a:	627b      	str	r3, [r7, #36]	@ 0x24
    __asm__ volatile ("CPSIE  i": : : "memory");
34197c1c:	b662      	cpsie	i
}
34197c1e:	bf00      	nop
34197c20:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34197c22:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34197c24:	6a3b      	ldr	r3, [r7, #32]
34197c26:	f383 8810 	msr	PRIMASK, r3
}
34197c2a:	bf00      	nop
}
34197c2c:	bf00      	nop
                /* Preemption is needed - return to the system!  */
                _tx_thread_system_return();
            }

            /* Return to caller.  */
            return;
34197c2e:	e02b      	b.n	34197c88 <_tx_thread_system_suspend+0x204>
34197c30:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
34197c32:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34197c34:	69fb      	ldr	r3, [r7, #28]
34197c36:	f383 8810 	msr	PRIMASK, r3
}
34197c3a:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Determine if a preemption condition is present.  */
    if (current_thread != _tx_thread_execute_ptr)
34197c3c:	4b1b      	ldr	r3, [pc, #108]	@ (34197cac <_tx_thread_system_suspend+0x228>)
34197c3e:	681b      	ldr	r3, [r3, #0]
34197c40:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
34197c42:	429a      	cmp	r2, r3
34197c44:	d022      	beq.n	34197c8c <_tx_thread_system_suspend+0x208>
        TX_THREAD_STACK_CHECK(thread_ptr)
#endif

        /* Determine if preemption should take place. This is only possible if the current thread pointer is
           not the same as the execute thread pointer AND the system state and preempt disable flags are clear.  */
        TX_THREAD_SYSTEM_RETURN_CHECK(combined_flags)
34197c46:	4b15      	ldr	r3, [pc, #84]	@ (34197c9c <_tx_thread_system_suspend+0x218>)
34197c48:	681b      	ldr	r3, [r3, #0]
34197c4a:	657b      	str	r3, [r7, #84]	@ 0x54
        if (combined_flags == ((ULONG) 0))
34197c4c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34197c4e:	2b00      	cmp	r3, #0
34197c50:	d11c      	bne.n	34197c8c <_tx_thread_system_suspend+0x208>
    *((volatile ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
34197c52:	4b17      	ldr	r3, [pc, #92]	@ (34197cb0 <_tx_thread_system_suspend+0x22c>)
34197c54:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
34197c58:	601a      	str	r2, [r3, #0]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
34197c5a:	f3ef 8305 	mrs	r3, IPSR
34197c5e:	61bb      	str	r3, [r7, #24]
    return(ipsr_value);
34197c60:	69bb      	ldr	r3, [r7, #24]
    if (_tx_ipsr_get() == 0)
34197c62:	2b00      	cmp	r3, #0
34197c64:	d10c      	bne.n	34197c80 <_tx_thread_system_suspend+0x1fc>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34197c66:	f3ef 8310 	mrs	r3, PRIMASK
34197c6a:	617b      	str	r3, [r7, #20]
    return(posture);
34197c6c:	697b      	ldr	r3, [r7, #20]
        interrupt_save = __get_interrupt_posture();
34197c6e:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSIE  i": : : "memory");
34197c70:	b662      	cpsie	i
}
34197c72:	bf00      	nop
34197c74:	693b      	ldr	r3, [r7, #16]
34197c76:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34197c78:	68fb      	ldr	r3, [r7, #12]
34197c7a:	f383 8810 	msr	PRIMASK, r3
}
34197c7e:	bf00      	nop
}
34197c80:	bf00      	nop
            _tx_thread_system_return();
        }
    }

    /* Return to caller.  */
    return;
34197c82:	e003      	b.n	34197c8c <_tx_thread_system_suspend+0x208>
                return;
34197c84:	bf00      	nop
34197c86:	e002      	b.n	34197c8e <_tx_thread_system_suspend+0x20a>
            return;
34197c88:	bf00      	nop
34197c8a:	e000      	b.n	34197c8e <_tx_thread_system_suspend+0x20a>
    return;
34197c8c:	bf00      	nop
}
34197c8e:	3778      	adds	r7, #120	@ 0x78
34197c90:	46bd      	mov	sp, r7
34197c92:	bd80      	pop	{r7, pc}
34197c94:	341c2dec 	.word	0x341c2dec
34197c98:	341c33f0 	.word	0x341c33f0
34197c9c:	341c2e84 	.word	0x341c2e84
34197ca0:	341c2e04 	.word	0x341c2e04
34197ca4:	341c2dfc 	.word	0x341c2dfc
34197ca8:	341c2e00 	.word	0x341c2e00
34197cac:	341c2df0 	.word	0x341c2df0
34197cb0:	e000ed04 	.word	0xe000ed04

34197cb4 <_tx_thread_terminate>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_thread_terminate(TX_THREAD *thread_ptr)
{
34197cb4:	b580      	push	{r7, lr}
34197cb6:	b0ac      	sub	sp, #176	@ 0xb0
34197cb8:	af00      	add	r7, sp, #0
34197cba:	6078      	str	r0, [r7, #4]
UINT        status;
ULONG       suspension_sequence;


    /* Default to successful completion.  */
    status =  TX_SUCCESS;
34197cbc:	2300      	movs	r3, #0
34197cbe:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34197cc2:	f3ef 8310 	mrs	r3, PRIMASK
34197cc6:	67fb      	str	r3, [r7, #124]	@ 0x7c
    return(posture);
34197cc8:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
    int_posture = __get_interrupt_posture();
34197cca:	67bb      	str	r3, [r7, #120]	@ 0x78
    __asm__ volatile ("CPSID i" : : : "memory");
34197ccc:	b672      	cpsid	i
    return(int_posture);
34197cce:	6fbb      	ldr	r3, [r7, #120]	@ 0x78

    /* Lockout interrupts while the thread is being terminated.  */
    TX_DISABLE
34197cd0:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac

    /* Deactivate thread timer, if active.  */
    _tx_timer_system_deactivate(&thread_ptr -> tx_thread_timer);
34197cd4:	687b      	ldr	r3, [r7, #4]
34197cd6:	334c      	adds	r3, #76	@ 0x4c
34197cd8:	4618      	mov	r0, r3
34197cda:	f000 fb17 	bl	3419830c <_tx_timer_system_deactivate>

    /* Log this kernel call.  */
    TX_EL_THREAD_TERMINATE_INSERT

    /* Is the thread already terminated?  */
    if (thread_ptr -> tx_thread_state == TX_TERMINATED)
34197cde:	687b      	ldr	r3, [r7, #4]
34197ce0:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34197ce2:	2b02      	cmp	r3, #2
34197ce4:	d10a      	bne.n	34197cfc <_tx_thread_terminate+0x48>
34197ce6:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
34197cea:	677b      	str	r3, [r7, #116]	@ 0x74
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34197cec:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
34197cee:	f383 8810 	msr	PRIMASK, r3
}
34197cf2:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Return success since thread is already terminated.  */
        status =  TX_SUCCESS;
34197cf4:	2300      	movs	r3, #0
34197cf6:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
34197cfa:	e148      	b.n	34197f8e <_tx_thread_terminate+0x2da>
    }

    /* Check the specified thread's current status.  */
    else if (thread_ptr -> tx_thread_state != TX_COMPLETED)
34197cfc:	687b      	ldr	r3, [r7, #4]
34197cfe:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34197d00:	2b01      	cmp	r3, #1
34197d02:	f000 813d 	beq.w	34197f80 <_tx_thread_terminate+0x2cc>
    {

        /* Disable preemption.  */
        _tx_thread_preempt_disable++;
34197d06:	4ba6      	ldr	r3, [pc, #664]	@ (34197fa0 <_tx_thread_terminate+0x2ec>)
34197d08:	681b      	ldr	r3, [r3, #0]
34197d0a:	3301      	adds	r3, #1
34197d0c:	4aa4      	ldr	r2, [pc, #656]	@ (34197fa0 <_tx_thread_terminate+0x2ec>)
34197d0e:	6013      	str	r3, [r2, #0]
        /* Pickup the entry/exit application callback routine.  */
        entry_exit_notify =  thread_ptr -> tx_thread_entry_exit_notify;
#endif

        /* Check to see if the thread is currently ready.  */
        if (thread_ptr -> tx_thread_state == TX_READY)
34197d10:	687b      	ldr	r3, [r7, #4]
34197d12:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34197d14:	2b00      	cmp	r3, #0
34197d16:	d17a      	bne.n	34197e0e <_tx_thread_terminate+0x15a>
        {

            /* Set the state to terminated.  */
            thread_ptr -> tx_thread_state =  TX_TERMINATED;
34197d18:	687b      	ldr	r3, [r7, #4]
34197d1a:	2202      	movs	r2, #2
34197d1c:	631a      	str	r2, [r3, #48]	@ 0x30
            /* Call actual non-interruptable thread suspension routine.  */
            _tx_thread_system_ni_suspend(thread_ptr, ((ULONG) 0));
#else

            /* Set the suspending flag.  */
            thread_ptr -> tx_thread_suspending =  TX_TRUE;
34197d1e:	687b      	ldr	r3, [r7, #4]
34197d20:	2201      	movs	r2, #1
34197d22:	639a      	str	r2, [r3, #56]	@ 0x38

            /* Setup for no timeout period.  */
            thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  ((ULONG) 0);
34197d24:	687b      	ldr	r3, [r7, #4]
34197d26:	2200      	movs	r2, #0
34197d28:	64da      	str	r2, [r3, #76]	@ 0x4c

            /* Disable preemption.  */
            _tx_thread_preempt_disable++;
34197d2a:	4b9d      	ldr	r3, [pc, #628]	@ (34197fa0 <_tx_thread_terminate+0x2ec>)
34197d2c:	681b      	ldr	r3, [r3, #0]
34197d2e:	3301      	adds	r3, #1
34197d30:	4a9b      	ldr	r2, [pc, #620]	@ (34197fa0 <_tx_thread_terminate+0x2ec>)
34197d32:	6013      	str	r3, [r2, #0]
34197d34:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
34197d38:	66fb      	str	r3, [r7, #108]	@ 0x6c
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34197d3a:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
34197d3c:	f383 8810 	msr	PRIMASK, r3
}
34197d40:	bf00      	nop
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
34197d42:	f3ef 8305 	mrs	r3, IPSR
34197d46:	673b      	str	r3, [r7, #112]	@ 0x70
    return(ipsr_value);
34197d48:	6f3a      	ldr	r2, [r7, #112]	@ 0x70

            /* Restore interrupts.  */
            TX_RESTORE

            /* Perform any additional activities for tool or user purpose.  */
            TX_THREAD_TERMINATED_EXTENSION(thread_ptr)
34197d4a:	4b96      	ldr	r3, [pc, #600]	@ (34197fa4 <_tx_thread_terminate+0x2f0>)
34197d4c:	681b      	ldr	r3, [r3, #0]
34197d4e:	4313      	orrs	r3, r2
34197d50:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
34197d54:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
34197d58:	2b00      	cmp	r3, #0
34197d5a:	d118      	bne.n	34197d8e <_tx_thread_terminate+0xda>
34197d5c:	4b92      	ldr	r3, [pc, #584]	@ (34197fa8 <_tx_thread_terminate+0x2f4>)
34197d5e:	681b      	ldr	r3, [r3, #0]
34197d60:	687a      	ldr	r2, [r7, #4]
34197d62:	429a      	cmp	r2, r3
34197d64:	d113      	bne.n	34197d8e <_tx_thread_terminate+0xda>
    __asm__ volatile (" MRS  %0,CONTROL ": "=r" (control_value) );
34197d66:	f3ef 8314 	mrs	r3, CONTROL
34197d6a:	667b      	str	r3, [r7, #100]	@ 0x64
    return(control_value);
34197d6c:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
34197d6e:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
34197d72:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
34197d76:	f023 0304 	bic.w	r3, r3, #4
34197d7a:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
34197d7e:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
34197d82:	66bb      	str	r3, [r7, #104]	@ 0x68
    __asm__ volatile (" MSR  CONTROL,%0": : "r" (control_value): "memory" );
34197d84:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
34197d86:	f383 8814 	msr	CONTROL, r3
}
34197d8a:	bf00      	nop
34197d8c:	e032      	b.n	34197df4 <_tx_thread_terminate+0x140>
34197d8e:	4b87      	ldr	r3, [pc, #540]	@ (34197fac <_tx_thread_terminate+0x2f8>)
34197d90:	681b      	ldr	r3, [r3, #0]
34197d92:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
34197d96:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
34197d9a:	f003 0301 	and.w	r3, r3, #1
34197d9e:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
34197da2:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
34197da6:	2b01      	cmp	r3, #1
34197da8:	d124      	bne.n	34197df4 <_tx_thread_terminate+0x140>
    __asm__ volatile (" MRS  %0,CONTROL ": "=r" (control_value) );
34197daa:	f3ef 8314 	mrs	r3, CONTROL
34197dae:	663b      	str	r3, [r7, #96]	@ 0x60
    return(control_value);
34197db0:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
34197db2:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
34197db6:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
34197dba:	f003 0304 	and.w	r3, r3, #4
34197dbe:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
34197dc2:	eeb0 0a40 	vmov.f32	s0, s0
34197dc6:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
34197dca:	2b00      	cmp	r3, #0
34197dcc:	d112      	bne.n	34197df4 <_tx_thread_terminate+0x140>
    __asm__ volatile (" MRS  %0,CONTROL ": "=r" (control_value) );
34197dce:	f3ef 8314 	mrs	r3, CONTROL
34197dd2:	65bb      	str	r3, [r7, #88]	@ 0x58
    return(control_value);
34197dd4:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
34197dd6:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
34197dda:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
34197dde:	f023 0304 	bic.w	r3, r3, #4
34197de2:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
34197de6:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
34197dea:	65fb      	str	r3, [r7, #92]	@ 0x5c
    __asm__ volatile (" MSR  CONTROL,%0": : "r" (control_value): "memory" );
34197dec:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
34197dee:	f383 8814 	msr	CONTROL, r3
}
34197df2:	bf00      	nop
                (entry_exit_notify)(thread_ptr, TX_THREAD_EXIT);
            }
#endif

            /* Call actual thread suspension routine.  */
            _tx_thread_system_suspend(thread_ptr);
34197df4:	6878      	ldr	r0, [r7, #4]
34197df6:	f7ff fe45 	bl	34197a84 <_tx_thread_system_suspend>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34197dfa:	f3ef 8310 	mrs	r3, PRIMASK
34197dfe:	657b      	str	r3, [r7, #84]	@ 0x54
    return(posture);
34197e00:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
    int_posture = __get_interrupt_posture();
34197e02:	653b      	str	r3, [r7, #80]	@ 0x50
    __asm__ volatile ("CPSID i" : : : "memory");
34197e04:	b672      	cpsid	i
    return(int_posture);
34197e06:	6d3b      	ldr	r3, [r7, #80]	@ 0x50

            /* Disable interrupts.  */
            TX_DISABLE
34197e08:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
34197e0c:	e094      	b.n	34197f38 <_tx_thread_terminate+0x284>
        }
        else
        {

            /* Change the state to terminated.  */
            thread_ptr -> tx_thread_state =    TX_TERMINATED;
34197e0e:	687b      	ldr	r3, [r7, #4]
34197e10:	2202      	movs	r2, #2
34197e12:	631a      	str	r2, [r3, #48]	@ 0x30
            /* Thread state change.  */
            TX_THREAD_STATE_CHANGE(thread_ptr, TX_TERMINATED)

            /* Set the suspending flag.  This prevents the thread from being
               resumed before the cleanup routine is executed.  */
            thread_ptr -> tx_thread_suspending =  TX_TRUE;
34197e14:	687b      	ldr	r3, [r7, #4]
34197e16:	2201      	movs	r2, #1
34197e18:	639a      	str	r2, [r3, #56]	@ 0x38

            /* Pickup the cleanup routine address.  */
            suspend_cleanup =  thread_ptr -> tx_thread_suspend_cleanup;
34197e1a:	687b      	ldr	r3, [r7, #4]
34197e1c:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
34197e1e:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4

#ifndef TX_NOT_INTERRUPTABLE

            /* Pickup the suspension sequence number that is used later to verify that the
               cleanup is still necessary.  */
            suspension_sequence =  thread_ptr -> tx_thread_suspension_sequence;
34197e22:	687b      	ldr	r3, [r7, #4]
34197e24:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
34197e28:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
34197e2c:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
34197e30:	64fb      	str	r3, [r7, #76]	@ 0x4c
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34197e32:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34197e34:	f383 8810 	msr	PRIMASK, r3
}
34197e38:	bf00      	nop
            /* Restore interrupts.  */
            TX_RESTORE
#endif

            /* Call any cleanup routines.  */
            if (suspend_cleanup != TX_NULL)
34197e3a:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
34197e3e:	2b00      	cmp	r3, #0
34197e40:	d005      	beq.n	34197e4e <_tx_thread_terminate+0x19a>
            {

                /* Yes, there is a function to call.  */
                (suspend_cleanup)(thread_ptr, suspension_sequence);
34197e42:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
34197e46:	f8d7 10a0 	ldr.w	r1, [r7, #160]	@ 0xa0
34197e4a:	6878      	ldr	r0, [r7, #4]
34197e4c:	4798      	blx	r3
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34197e4e:	f3ef 8310 	mrs	r3, PRIMASK
34197e52:	643b      	str	r3, [r7, #64]	@ 0x40
    return(posture);
34197e54:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
    int_posture = __get_interrupt_posture();
34197e56:	63fb      	str	r3, [r7, #60]	@ 0x3c
    __asm__ volatile ("CPSID i" : : : "memory");
34197e58:	b672      	cpsid	i
    return(int_posture);
34197e5a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
            }

#ifndef TX_NOT_INTERRUPTABLE

            /* Disable interrupts.  */
            TX_DISABLE
34197e5c:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
#endif

            /* Clear the suspending flag.  */
            thread_ptr -> tx_thread_suspending =  TX_FALSE;
34197e60:	687b      	ldr	r3, [r7, #4]
34197e62:	2200      	movs	r2, #0
34197e64:	639a      	str	r2, [r3, #56]	@ 0x38
34197e66:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
34197e6a:	647b      	str	r3, [r7, #68]	@ 0x44
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34197e6c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34197e6e:	f383 8810 	msr	PRIMASK, r3
}
34197e72:	bf00      	nop
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
34197e74:	f3ef 8305 	mrs	r3, IPSR
34197e78:	64bb      	str	r3, [r7, #72]	@ 0x48
    return(ipsr_value);
34197e7a:	6cba      	ldr	r2, [r7, #72]	@ 0x48
            /* Restore interrupts.  */
            TX_RESTORE
#endif

            /* Perform any additional activities for tool or user purpose.  */
            TX_THREAD_TERMINATED_EXTENSION(thread_ptr)
34197e7c:	4b49      	ldr	r3, [pc, #292]	@ (34197fa4 <_tx_thread_terminate+0x2f0>)
34197e7e:	681b      	ldr	r3, [r3, #0]
34197e80:	4313      	orrs	r3, r2
34197e82:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
34197e86:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
34197e8a:	2b00      	cmp	r3, #0
34197e8c:	d118      	bne.n	34197ec0 <_tx_thread_terminate+0x20c>
34197e8e:	4b46      	ldr	r3, [pc, #280]	@ (34197fa8 <_tx_thread_terminate+0x2f4>)
34197e90:	681b      	ldr	r3, [r3, #0]
34197e92:	687a      	ldr	r2, [r7, #4]
34197e94:	429a      	cmp	r2, r3
34197e96:	d113      	bne.n	34197ec0 <_tx_thread_terminate+0x20c>
    __asm__ volatile (" MRS  %0,CONTROL ": "=r" (control_value) );
34197e98:	f3ef 8314 	mrs	r3, CONTROL
34197e9c:	637b      	str	r3, [r7, #52]	@ 0x34
    return(control_value);
34197e9e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34197ea0:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
34197ea4:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
34197ea8:	f023 0304 	bic.w	r3, r3, #4
34197eac:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
34197eb0:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
34197eb4:	63bb      	str	r3, [r7, #56]	@ 0x38
    __asm__ volatile (" MSR  CONTROL,%0": : "r" (control_value): "memory" );
34197eb6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34197eb8:	f383 8814 	msr	CONTROL, r3
}
34197ebc:	bf00      	nop
34197ebe:	e032      	b.n	34197f26 <_tx_thread_terminate+0x272>
34197ec0:	4b3a      	ldr	r3, [pc, #232]	@ (34197fac <_tx_thread_terminate+0x2f8>)
34197ec2:	681b      	ldr	r3, [r3, #0]
34197ec4:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
34197ec8:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
34197ecc:	f003 0301 	and.w	r3, r3, #1
34197ed0:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
34197ed4:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
34197ed8:	2b01      	cmp	r3, #1
34197eda:	d124      	bne.n	34197f26 <_tx_thread_terminate+0x272>
    __asm__ volatile (" MRS  %0,CONTROL ": "=r" (control_value) );
34197edc:	f3ef 8314 	mrs	r3, CONTROL
34197ee0:	633b      	str	r3, [r7, #48]	@ 0x30
    return(control_value);
34197ee2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34197ee4:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
34197ee8:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
34197eec:	f003 0304 	and.w	r3, r3, #4
34197ef0:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
34197ef4:	eeb0 0a40 	vmov.f32	s0, s0
34197ef8:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
34197efc:	2b00      	cmp	r3, #0
34197efe:	d112      	bne.n	34197f26 <_tx_thread_terminate+0x272>
    __asm__ volatile (" MRS  %0,CONTROL ": "=r" (control_value) );
34197f00:	f3ef 8314 	mrs	r3, CONTROL
34197f04:	62bb      	str	r3, [r7, #40]	@ 0x28
    return(control_value);
34197f06:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34197f08:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
34197f0c:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
34197f10:	f023 0304 	bic.w	r3, r3, #4
34197f14:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
34197f18:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
34197f1c:	62fb      	str	r3, [r7, #44]	@ 0x2c
    __asm__ volatile (" MSR  CONTROL,%0": : "r" (control_value): "memory" );
34197f1e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34197f20:	f383 8814 	msr	CONTROL, r3
}
34197f24:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34197f26:	f3ef 8310 	mrs	r3, PRIMASK
34197f2a:	627b      	str	r3, [r7, #36]	@ 0x24
    return(posture);
34197f2c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
    int_posture = __get_interrupt_posture();
34197f2e:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("CPSID i" : : : "memory");
34197f30:	b672      	cpsid	i
    return(int_posture);
34197f32:	6a3b      	ldr	r3, [r7, #32]
#endif

#ifndef TX_NOT_INTERRUPTABLE

            /* Disable interrupts.  */
            TX_DISABLE
34197f34:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
34197f38:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
34197f3c:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34197f3e:	69fb      	ldr	r3, [r7, #28]
34197f40:	f383 8810 	msr	PRIMASK, r3
}
34197f44:	bf00      	nop
        /* Restore interrupts.  */
        TX_RESTORE
#endif

        /* Determine if the application is using mutexes.  */
        if (_tx_thread_mutex_release != TX_NULL)
34197f46:	4b1a      	ldr	r3, [pc, #104]	@ (34197fb0 <_tx_thread_terminate+0x2fc>)
34197f48:	681b      	ldr	r3, [r3, #0]
34197f4a:	2b00      	cmp	r3, #0
34197f4c:	d003      	beq.n	34197f56 <_tx_thread_terminate+0x2a2>
        {

            /* Yes, call the mutex release function via a function pointer that
               is setup during initialization.  */
            (_tx_thread_mutex_release)(thread_ptr);
34197f4e:	4b18      	ldr	r3, [pc, #96]	@ (34197fb0 <_tx_thread_terminate+0x2fc>)
34197f50:	681b      	ldr	r3, [r3, #0]
34197f52:	6878      	ldr	r0, [r7, #4]
34197f54:	4798      	blx	r3
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34197f56:	f3ef 8310 	mrs	r3, PRIMASK
34197f5a:	617b      	str	r3, [r7, #20]
    return(posture);
34197f5c:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
34197f5e:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
34197f60:	b672      	cpsid	i
    return(int_posture);
34197f62:	693b      	ldr	r3, [r7, #16]
        }

#ifndef TX_NOT_INTERRUPTABLE

        /* Disable interrupts.  */
        TX_DISABLE
34197f64:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
#endif

        /* Enable preemption.  */
        _tx_thread_preempt_disable--;
34197f68:	4b0d      	ldr	r3, [pc, #52]	@ (34197fa0 <_tx_thread_terminate+0x2ec>)
34197f6a:	681b      	ldr	r3, [r3, #0]
34197f6c:	3b01      	subs	r3, #1
34197f6e:	4a0c      	ldr	r2, [pc, #48]	@ (34197fa0 <_tx_thread_terminate+0x2ec>)
34197f70:	6013      	str	r3, [r2, #0]
34197f72:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
34197f76:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34197f78:	69bb      	ldr	r3, [r7, #24]
34197f7a:	f383 8810 	msr	PRIMASK, r3
}
34197f7e:	e006      	b.n	34197f8e <_tx_thread_terminate+0x2da>
34197f80:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
34197f84:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34197f86:	68fb      	ldr	r3, [r7, #12]
34197f88:	f383 8810 	msr	PRIMASK, r3
}
34197f8c:	bf00      	nop
        /* Restore interrupts.  */
        TX_RESTORE
    }

    /* Check for preemption.  */
    _tx_thread_system_preempt_check();
34197f8e:	f7ff fc3f 	bl	34197810 <_tx_thread_system_preempt_check>

    /* Return completion status.  */
    return(status);
34197f92:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
}
34197f96:	4618      	mov	r0, r3
34197f98:	37b0      	adds	r7, #176	@ 0xb0
34197f9a:	46bd      	mov	sp, r7
34197f9c:	bd80      	pop	{r7, pc}
34197f9e:	bf00      	nop
34197fa0:	341c2e84 	.word	0x341c2e84
34197fa4:	341c009c 	.word	0x341c009c
34197fa8:	341c2dec 	.word	0x341c2dec
34197fac:	e000ef34 	.word	0xe000ef34
34197fb0:	341c2e88 	.word	0x341c2e88

34197fb4 <_tx_thread_time_slice>:
/*                                            TX_NO_TIMER is defined,     */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_thread_time_slice(VOID)
{
34197fb4:	b480      	push	{r7}
34197fb6:	b087      	sub	sp, #28
34197fb8:	af00      	add	r7, sp, #0
ULONG           system_state;
UINT            preempt_disable;
#endif

    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(thread_ptr)
34197fba:	4b21      	ldr	r3, [pc, #132]	@ (34198040 <_tx_thread_time_slice+0x8c>)
34197fbc:	681b      	ldr	r3, [r3, #0]
34197fbe:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34197fc0:	f3ef 8310 	mrs	r3, PRIMASK
34197fc4:	60fb      	str	r3, [r7, #12]
    return(posture);
34197fc6:	68fb      	ldr	r3, [r7, #12]
    int_posture = __get_interrupt_posture();
34197fc8:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("CPSID i" : : : "memory");
34197fca:	b672      	cpsid	i
    return(int_posture);
34197fcc:	68bb      	ldr	r3, [r7, #8]
    /* Set the next thread pointer to NULL.  */
    next_thread_ptr =  TX_NULL;
#endif

    /* Lockout interrupts while the time-slice is evaluated.  */
    TX_DISABLE
34197fce:	613b      	str	r3, [r7, #16]

    /* Clear the expired time-slice flag.  */
    _tx_timer_expired_time_slice =  TX_FALSE;
34197fd0:	4b1c      	ldr	r3, [pc, #112]	@ (34198044 <_tx_thread_time_slice+0x90>)
34197fd2:	2200      	movs	r2, #0
34197fd4:	601a      	str	r2, [r3, #0]

    /* Make sure the thread pointer is valid.  */
    if (thread_ptr != TX_NULL)
34197fd6:	697b      	ldr	r3, [r7, #20]
34197fd8:	2b00      	cmp	r3, #0
34197fda:	d024      	beq.n	34198026 <_tx_thread_time_slice+0x72>
    {

        /* Make sure the thread is still active, i.e. not suspended.  */
        if (thread_ptr -> tx_thread_state == TX_READY)
34197fdc:	697b      	ldr	r3, [r7, #20]
34197fde:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34197fe0:	2b00      	cmp	r3, #0
34197fe2:	d120      	bne.n	34198026 <_tx_thread_time_slice+0x72>
        {

            /* Setup a fresh time-slice for the thread.  */
            thread_ptr -> tx_thread_time_slice =  thread_ptr -> tx_thread_new_time_slice;
34197fe4:	697b      	ldr	r3, [r7, #20]
34197fe6:	69da      	ldr	r2, [r3, #28]
34197fe8:	697b      	ldr	r3, [r7, #20]
34197fea:	619a      	str	r2, [r3, #24]

            /* Reset the actual time-slice variable.  */
            _tx_timer_time_slice =  thread_ptr -> tx_thread_time_slice;
34197fec:	697b      	ldr	r3, [r7, #20]
34197fee:	699b      	ldr	r3, [r3, #24]
34197ff0:	4a15      	ldr	r2, [pc, #84]	@ (34198048 <_tx_thread_time_slice+0x94>)
34197ff2:	6013      	str	r3, [r2, #0]

            /* Determine if there is another thread at the same priority and preemption-threshold
               is not set.  Preemption-threshold overrides time-slicing.  */
            if (thread_ptr -> tx_thread_ready_next != thread_ptr)
34197ff4:	697b      	ldr	r3, [r7, #20]
34197ff6:	6a1b      	ldr	r3, [r3, #32]
34197ff8:	697a      	ldr	r2, [r7, #20]
34197ffa:	429a      	cmp	r2, r3
34197ffc:	d013      	beq.n	34198026 <_tx_thread_time_slice+0x72>
            {

                /* Check to see if preemption-threshold is not being used.  */
                if (thread_ptr -> tx_thread_priority == thread_ptr -> tx_thread_preempt_threshold)
34197ffe:	697b      	ldr	r3, [r7, #20]
34198000:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
34198002:	697b      	ldr	r3, [r7, #20]
34198004:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34198006:	429a      	cmp	r2, r3
34198008:	d10d      	bne.n	34198026 <_tx_thread_time_slice+0x72>

                    /* Preemption-threshold is not being used by this thread.  */

                    /* There is another thread at this priority, make it the highest at
                       this priority level.  */
                    _tx_thread_priority_list[thread_ptr -> tx_thread_priority] =  thread_ptr -> tx_thread_ready_next;
3419800a:	697b      	ldr	r3, [r7, #20]
3419800c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3419800e:	697a      	ldr	r2, [r7, #20]
34198010:	6a12      	ldr	r2, [r2, #32]
34198012:	490e      	ldr	r1, [pc, #56]	@ (3419804c <_tx_thread_time_slice+0x98>)
34198014:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

                    /* Designate the highest priority thread as the one to execute.  Don't use this
                       thread's priority as an index just in case a higher priority thread is now
                       ready!  */
                    _tx_thread_execute_ptr =  _tx_thread_priority_list[_tx_thread_highest_priority];
34198018:	4b0d      	ldr	r3, [pc, #52]	@ (34198050 <_tx_thread_time_slice+0x9c>)
3419801a:	681b      	ldr	r3, [r3, #0]
3419801c:	4a0b      	ldr	r2, [pc, #44]	@ (3419804c <_tx_thread_time_slice+0x98>)
3419801e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
34198022:	4a0c      	ldr	r2, [pc, #48]	@ (34198054 <_tx_thread_time_slice+0xa0>)
34198024:	6013      	str	r3, [r2, #0]
34198026:	693b      	ldr	r3, [r7, #16]
34198028:	607b      	str	r3, [r7, #4]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
3419802a:	687b      	ldr	r3, [r7, #4]
3419802c:	f383 8810 	msr	PRIMASK, r3
}
34198030:	bf00      	nop

        /* Yes, check this thread's stack.  */
        TX_THREAD_STACK_CHECK(next_thread_ptr)
    }
#endif
}
34198032:	bf00      	nop
34198034:	371c      	adds	r7, #28
34198036:	46bd      	mov	sp, r7
34198038:	f85d 7b04 	ldr.w	r7, [sp], #4
3419803c:	4770      	bx	lr
3419803e:	bf00      	nop
34198040:	341c2dec 	.word	0x341c2dec
34198044:	341c2e94 	.word	0x341c2e94
34198048:	341c33f0 	.word	0x341c33f0
3419804c:	341c2e04 	.word	0x341c2e04
34198050:	341c2e00 	.word	0x341c2e00
34198054:	341c2df0 	.word	0x341c2df0

34198058 <_tx_thread_timeout>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_thread_timeout(ULONG timeout_input)
{
34198058:	b580      	push	{r7, lr}
3419805a:	b08a      	sub	sp, #40	@ 0x28
3419805c:	af00      	add	r7, sp, #0
3419805e:	6078      	str	r0, [r7, #4]
VOID            (*suspend_cleanup)(struct TX_THREAD_STRUCT *suspend_thread_ptr, ULONG suspension_sequence);
ULONG           suspension_sequence;


    /* Pickup the thread pointer.  */
    TX_THREAD_TIMEOUT_POINTER_SETUP(thread_ptr)
34198060:	687b      	ldr	r3, [r7, #4]
34198062:	627b      	str	r3, [r7, #36]	@ 0x24
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34198064:	f3ef 8310 	mrs	r3, PRIMASK
34198068:	617b      	str	r3, [r7, #20]
    return(posture);
3419806a:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
3419806c:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
3419806e:	b672      	cpsid	i
    return(int_posture);
34198070:	693b      	ldr	r3, [r7, #16]

    /* Disable interrupts.  */
    TX_DISABLE
34198072:	623b      	str	r3, [r7, #32]

    /* Determine how the thread is currently suspended.  */
    if (thread_ptr -> tx_thread_state == TX_SLEEP)
34198074:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34198076:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34198078:	2b04      	cmp	r3, #4
3419807a:	d10e      	bne.n	3419809a <_tx_thread_timeout+0x42>
        /* Restore interrupts.  */
        TX_RESTORE
#else

        /* Increment the disable preemption flag.  */
        _tx_thread_preempt_disable++;
3419807c:	4b13      	ldr	r3, [pc, #76]	@ (341980cc <_tx_thread_timeout+0x74>)
3419807e:	681b      	ldr	r3, [r3, #0]
34198080:	3301      	adds	r3, #1
34198082:	4a12      	ldr	r2, [pc, #72]	@ (341980cc <_tx_thread_timeout+0x74>)
34198084:	6013      	str	r3, [r2, #0]
34198086:	6a3b      	ldr	r3, [r7, #32]
34198088:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
3419808a:	68fb      	ldr	r3, [r7, #12]
3419808c:	f383 8810 	msr	PRIMASK, r3
}
34198090:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Lift the suspension on the sleeping thread.  */
        _tx_thread_system_resume(thread_ptr);
34198092:	6a78      	ldr	r0, [r7, #36]	@ 0x24
34198094:	f7ff fbf6 	bl	34197884 <_tx_thread_system_resume>

        /* Restore interrupts.  */
        TX_RESTORE
#endif
    }
}
34198098:	e013      	b.n	341980c2 <_tx_thread_timeout+0x6a>
        suspend_cleanup =  thread_ptr -> tx_thread_suspend_cleanup;
3419809a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419809c:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
3419809e:	61fb      	str	r3, [r7, #28]
        suspension_sequence =  thread_ptr -> tx_thread_suspension_sequence;
341980a0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
341980a2:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
341980a6:	61bb      	str	r3, [r7, #24]
341980a8:	6a3b      	ldr	r3, [r7, #32]
341980aa:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
341980ac:	68bb      	ldr	r3, [r7, #8]
341980ae:	f383 8810 	msr	PRIMASK, r3
}
341980b2:	bf00      	nop
        if (suspend_cleanup != TX_NULL)
341980b4:	69fb      	ldr	r3, [r7, #28]
341980b6:	2b00      	cmp	r3, #0
341980b8:	d003      	beq.n	341980c2 <_tx_thread_timeout+0x6a>
            (suspend_cleanup)(thread_ptr, suspension_sequence);
341980ba:	69fb      	ldr	r3, [r7, #28]
341980bc:	69b9      	ldr	r1, [r7, #24]
341980be:	6a78      	ldr	r0, [r7, #36]	@ 0x24
341980c0:	4798      	blx	r3
}
341980c2:	bf00      	nop
341980c4:	3728      	adds	r7, #40	@ 0x28
341980c6:	46bd      	mov	sp, r7
341980c8:	bd80      	pop	{r7, pc}
341980ca:	bf00      	nop
341980cc:	341c2e84 	.word	0x341c2e84

341980d0 <_tx_time_get>:
/*  12-31-2020     Andres Mlinar            Modified comment(s),          */
/*                                            resulting in version 6.1.3  */
/*                                                                        */
/**************************************************************************/
ULONG  _tx_time_get(VOID)
{
341980d0:	b480      	push	{r7}
341980d2:	b087      	sub	sp, #28
341980d4:	af00      	add	r7, sp, #0
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
341980d6:	f3ef 8310 	mrs	r3, PRIMASK
341980da:	60bb      	str	r3, [r7, #8]
    return(posture);
341980dc:	68bb      	ldr	r3, [r7, #8]
    int_posture = __get_interrupt_posture();
341980de:	607b      	str	r3, [r7, #4]
    __asm__ volatile ("CPSID i" : : : "memory");
341980e0:	b672      	cpsid	i
    return(int_posture);
341980e2:	687b      	ldr	r3, [r7, #4]
#endif
ULONG   temp_time;


    /* Disable interrupts.  */
    TX_DISABLE
341980e4:	617b      	str	r3, [r7, #20]

    /* Pickup the system clock time.  */
    temp_time =  _tx_timer_system_clock;
341980e6:	4b08      	ldr	r3, [pc, #32]	@ (34198108 <_tx_time_get+0x38>)
341980e8:	681b      	ldr	r3, [r3, #0]
341980ea:	613b      	str	r3, [r7, #16]
341980ec:	697b      	ldr	r3, [r7, #20]
341980ee:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
341980f0:	68fb      	ldr	r3, [r7, #12]
341980f2:	f383 8810 	msr	PRIMASK, r3
}
341980f6:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return the time.  */
    return(temp_time);
341980f8:	693b      	ldr	r3, [r7, #16]
}
341980fa:	4618      	mov	r0, r3
341980fc:	371c      	adds	r7, #28
341980fe:	46bd      	mov	sp, r7
34198100:	f85d 7b04 	ldr.w	r7, [sp], #4
34198104:	4770      	bx	lr
34198106:	bf00      	nop
34198108:	341c2e90 	.word	0x341c2e90

3419810c <_tx_timer_expiration_process>:
/*                                            TX_NO_TIMER is defined,     */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_timer_expiration_process(VOID)
{
3419810c:	b580      	push	{r7, lr}
3419810e:	b084      	sub	sp, #16
34198110:	af00      	add	r7, sp, #0
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34198112:	f3ef 8310 	mrs	r3, PRIMASK
34198116:	607b      	str	r3, [r7, #4]
    return(posture);
34198118:	687b      	ldr	r3, [r7, #4]
    int_posture = __get_interrupt_posture();
3419811a:	603b      	str	r3, [r7, #0]
    __asm__ volatile ("CPSID i" : : : "memory");
3419811c:	b672      	cpsid	i
    return(int_posture);
3419811e:	683b      	ldr	r3, [r7, #0]

    /* Don't process in the ISR, wakeup the system timer thread to process the
       timer expiration.  */

    /* Disable interrupts.  */
    TX_DISABLE
34198120:	60fb      	str	r3, [r7, #12]
    /* Restore interrupts.  */
    TX_RESTORE
#else

    /* Increment the preempt disable flag.  */
    _tx_thread_preempt_disable++;
34198122:	4b09      	ldr	r3, [pc, #36]	@ (34198148 <_tx_timer_expiration_process+0x3c>)
34198124:	681b      	ldr	r3, [r3, #0]
34198126:	3301      	adds	r3, #1
34198128:	4a07      	ldr	r2, [pc, #28]	@ (34198148 <_tx_timer_expiration_process+0x3c>)
3419812a:	6013      	str	r3, [r2, #0]
3419812c:	68fb      	ldr	r3, [r7, #12]
3419812e:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34198130:	68bb      	ldr	r3, [r7, #8]
34198132:	f383 8810 	msr	PRIMASK, r3
}
34198136:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Call the system resume function to activate the timer thread.  */
    _tx_thread_system_resume(&_tx_timer_thread);
34198138:	4804      	ldr	r0, [pc, #16]	@ (3419814c <_tx_timer_expiration_process+0x40>)
3419813a:	f7ff fba3 	bl	34197884 <_tx_thread_system_resume>
    }

    /* Restore interrupts.  */
    TX_RESTORE
#endif
}
3419813e:	bf00      	nop
34198140:	3710      	adds	r7, #16
34198142:	46bd      	mov	sp, r7
34198144:	bd80      	pop	{r7, pc}
34198146:	bf00      	nop
34198148:	341c2e84 	.word	0x341c2e84
3419814c:	341c2f34 	.word	0x341c2f34

34198150 <_tx_timer_initialize>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_timer_initialize(VOID)
{
34198150:	b590      	push	{r4, r7, lr}
34198152:	b089      	sub	sp, #36	@ 0x24
34198154:	af06      	add	r7, sp, #24
#endif

#ifndef TX_DISABLE_REDUNDANT_CLEARING

    /* Initialize the system clock to 0.  */
    _tx_timer_system_clock =  ((ULONG) 0);
34198156:	4b28      	ldr	r3, [pc, #160]	@ (341981f8 <_tx_timer_initialize+0xa8>)
34198158:	2200      	movs	r2, #0
3419815a:	601a      	str	r2, [r3, #0]

    /* Initialize the time-slice value to 0 to make sure it is disabled.  */
    _tx_timer_time_slice =  ((ULONG) 0);
3419815c:	4b27      	ldr	r3, [pc, #156]	@ (341981fc <_tx_timer_initialize+0xac>)
3419815e:	2200      	movs	r2, #0
34198160:	601a      	str	r2, [r3, #0]

    /* Clear the expired flags.  */
    _tx_timer_expired_time_slice =  TX_FALSE;
34198162:	4b27      	ldr	r3, [pc, #156]	@ (34198200 <_tx_timer_initialize+0xb0>)
34198164:	2200      	movs	r2, #0
34198166:	601a      	str	r2, [r3, #0]
    _tx_timer_expired =             TX_FALSE;
34198168:	4b26      	ldr	r3, [pc, #152]	@ (34198204 <_tx_timer_initialize+0xb4>)
3419816a:	2200      	movs	r2, #0
3419816c:	601a      	str	r2, [r3, #0]

    /* Set the currently expired timer being processed pointer to NULL.  */
    _tx_timer_expired_timer_ptr =  TX_NULL;
3419816e:	4b26      	ldr	r3, [pc, #152]	@ (34198208 <_tx_timer_initialize+0xb8>)
34198170:	2200      	movs	r2, #0
34198172:	601a      	str	r2, [r3, #0]

    /* Initialize the thread and application timer management control structures.  */

    /* First, initialize the timer list.  */
    TX_MEMSET(&_tx_timer_list[0], 0, (sizeof(_tx_timer_list)));
34198174:	2280      	movs	r2, #128	@ 0x80
34198176:	2100      	movs	r1, #0
34198178:	4824      	ldr	r0, [pc, #144]	@ (3419820c <_tx_timer_initialize+0xbc>)
3419817a:	f005 ffa1 	bl	3419e0c0 <memset>
#endif

    /* Initialize all of the list pointers.  */
    _tx_timer_list_start =   &_tx_timer_list[0];
3419817e:	4b24      	ldr	r3, [pc, #144]	@ (34198210 <_tx_timer_initialize+0xc0>)
34198180:	4a22      	ldr	r2, [pc, #136]	@ (3419820c <_tx_timer_initialize+0xbc>)
34198182:	601a      	str	r2, [r3, #0]
    _tx_timer_current_ptr =  &_tx_timer_list[0];
34198184:	4b23      	ldr	r3, [pc, #140]	@ (34198214 <_tx_timer_initialize+0xc4>)
34198186:	4a21      	ldr	r2, [pc, #132]	@ (3419820c <_tx_timer_initialize+0xbc>)
34198188:	601a      	str	r2, [r3, #0]

    /* Set the timer list end pointer to one past the actual timer list.  This is done
       to make the timer interrupt handling in assembly language a little easier.  */
    _tx_timer_list_end =     &_tx_timer_list[TX_TIMER_ENTRIES-((ULONG) 1)];
3419818a:	4b23      	ldr	r3, [pc, #140]	@ (34198218 <_tx_timer_initialize+0xc8>)
3419818c:	4a23      	ldr	r2, [pc, #140]	@ (3419821c <_tx_timer_initialize+0xcc>)
3419818e:	601a      	str	r2, [r3, #0]
    _tx_timer_list_end =     TX_TIMER_POINTER_ADD(_tx_timer_list_end, ((ULONG) 1));
34198190:	4b21      	ldr	r3, [pc, #132]	@ (34198218 <_tx_timer_initialize+0xc8>)
34198192:	681b      	ldr	r3, [r3, #0]
34198194:	3304      	adds	r3, #4
34198196:	4a20      	ldr	r2, [pc, #128]	@ (34198218 <_tx_timer_initialize+0xc8>)
34198198:	6013      	str	r3, [r2, #0]

#ifndef TX_TIMER_PROCESS_IN_ISR

    /* Setup the variables associated with the system timer thread's stack and
       priority.  */
    _tx_timer_stack_start =  (VOID *) &_tx_timer_thread_stack_area[0];
3419819a:	4b21      	ldr	r3, [pc, #132]	@ (34198220 <_tx_timer_initialize+0xd0>)
3419819c:	4a21      	ldr	r2, [pc, #132]	@ (34198224 <_tx_timer_initialize+0xd4>)
3419819e:	601a      	str	r2, [r3, #0]
    _tx_timer_stack_size =   ((ULONG) TX_TIMER_THREAD_STACK_SIZE);
341981a0:	4b21      	ldr	r3, [pc, #132]	@ (34198228 <_tx_timer_initialize+0xd8>)
341981a2:	f44f 6280 	mov.w	r2, #1024	@ 0x400
341981a6:	601a      	str	r2, [r3, #0]
    _tx_timer_priority =     ((UINT) TX_TIMER_THREAD_PRIORITY);
341981a8:	4b20      	ldr	r3, [pc, #128]	@ (3419822c <_tx_timer_initialize+0xdc>)
341981aa:	2200      	movs	r2, #0
341981ac:	601a      	str	r2, [r3, #0]
       low-level initialization component.  */
    do
    {

        /* Create the system timer thread.  */
        status =  _tx_thread_create(&_tx_timer_thread,
341981ae:	4b1c      	ldr	r3, [pc, #112]	@ (34198220 <_tx_timer_initialize+0xd0>)
341981b0:	681b      	ldr	r3, [r3, #0]
341981b2:	4a1d      	ldr	r2, [pc, #116]	@ (34198228 <_tx_timer_initialize+0xd8>)
341981b4:	6812      	ldr	r2, [r2, #0]
341981b6:	491d      	ldr	r1, [pc, #116]	@ (3419822c <_tx_timer_initialize+0xdc>)
341981b8:	6809      	ldr	r1, [r1, #0]
341981ba:	481c      	ldr	r0, [pc, #112]	@ (3419822c <_tx_timer_initialize+0xdc>)
341981bc:	6800      	ldr	r0, [r0, #0]
341981be:	2400      	movs	r4, #0
341981c0:	9405      	str	r4, [sp, #20]
341981c2:	2400      	movs	r4, #0
341981c4:	9404      	str	r4, [sp, #16]
341981c6:	9003      	str	r0, [sp, #12]
341981c8:	9102      	str	r1, [sp, #8]
341981ca:	9201      	str	r2, [sp, #4]
341981cc:	9300      	str	r3, [sp, #0]
341981ce:	4b18      	ldr	r3, [pc, #96]	@ (34198230 <_tx_timer_initialize+0xe0>)
341981d0:	4a18      	ldr	r2, [pc, #96]	@ (34198234 <_tx_timer_initialize+0xe4>)
341981d2:	4919      	ldr	r1, [pc, #100]	@ (34198238 <_tx_timer_initialize+0xe8>)
341981d4:	4819      	ldr	r0, [pc, #100]	@ (3419823c <_tx_timer_initialize+0xec>)
341981d6:	f7fe ff17 	bl	34197008 <_tx_thread_create>
341981da:	6078      	str	r0, [r7, #4]
#endif

        /* Define timer initialize extension.  */
        TX_TIMER_INITIALIZE_EXTENSION(status)

    } while (status != TX_SUCCESS);
341981dc:	687b      	ldr	r3, [r7, #4]
341981de:	2b00      	cmp	r3, #0
341981e0:	d1e5      	bne.n	341981ae <_tx_timer_initialize+0x5e>
#endif

#ifndef TX_DISABLE_REDUNDANT_CLEARING

    /* Initialize the head pointer of the created application timer list.  */
    _tx_timer_created_ptr =  TX_NULL;
341981e2:	4b17      	ldr	r3, [pc, #92]	@ (34198240 <_tx_timer_initialize+0xf0>)
341981e4:	2200      	movs	r2, #0
341981e6:	601a      	str	r2, [r3, #0]

    /* Set the created count to zero.  */
    _tx_timer_created_count =  TX_EMPTY;
341981e8:	4b16      	ldr	r3, [pc, #88]	@ (34198244 <_tx_timer_initialize+0xf4>)
341981ea:	2200      	movs	r2, #0
341981ec:	601a      	str	r2, [r3, #0]
    _tx_timer_performance_expiration_count =         ((ULONG) 0);
    _tx_timer_performance__expiration_adjust_count =  ((ULONG) 0);
#endif
#endif
#endif
}
341981ee:	bf00      	nop
341981f0:	370c      	adds	r7, #12
341981f2:	46bd      	mov	sp, r7
341981f4:	bd90      	pop	{r4, r7, pc}
341981f6:	bf00      	nop
341981f8:	341c2e90 	.word	0x341c2e90
341981fc:	341c33f0 	.word	0x341c33f0
34198200:	341c2e94 	.word	0x341c2e94
34198204:	341c2f24 	.word	0x341c2f24
34198208:	341c2f30 	.word	0x341c2f30
3419820c:	341c2e98 	.word	0x341c2e98
34198210:	341c2f18 	.word	0x341c2f18
34198214:	341c2f20 	.word	0x341c2f20
34198218:	341c2f1c 	.word	0x341c2f1c
3419821c:	341c2f14 	.word	0x341c2f14
34198220:	341c2fe4 	.word	0x341c2fe4
34198224:	341c2ff0 	.word	0x341c2ff0
34198228:	341c2fe8 	.word	0x341c2fe8
3419822c:	341c2fec 	.word	0x341c2fec
34198230:	4154494d 	.word	0x4154494d
34198234:	3419837d 	.word	0x3419837d
34198238:	3419e2f0 	.word	0x3419e2f0
3419823c:	341c2f34 	.word	0x341c2f34
34198240:	341c2f28 	.word	0x341c2f28
34198244:	341c2f2c 	.word	0x341c2f2c

34198248 <_tx_timer_system_activate>:
/*                                            TX_NO_TIMER is defined,     */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_timer_system_activate(TX_TIMER_INTERNAL *timer_ptr)
{
34198248:	b480      	push	{r7}
3419824a:	b089      	sub	sp, #36	@ 0x24
3419824c:	af00      	add	r7, sp, #0
3419824e:	6078      	str	r0, [r7, #4]
ULONG                       remaining_ticks;
ULONG                       expiration_time;


    /* Pickup the remaining ticks.  */
    remaining_ticks =  timer_ptr -> tx_timer_internal_remaining_ticks;
34198250:	687b      	ldr	r3, [r7, #4]
34198252:	681b      	ldr	r3, [r3, #0]
34198254:	617b      	str	r3, [r7, #20]

    /* Determine if there is a timer to activate.  */
    if (remaining_ticks != ((ULONG) 0))
34198256:	697b      	ldr	r3, [r7, #20]
34198258:	2b00      	cmp	r3, #0
3419825a:	d04a      	beq.n	341982f2 <_tx_timer_system_activate+0xaa>
    {

        /* Determine if the timer is set to wait forever.  */
        if (remaining_ticks != TX_WAIT_FOREVER)
3419825c:	697b      	ldr	r3, [r7, #20]
3419825e:	f1b3 3fff 	cmp.w	r3, #4294967295
34198262:	d046      	beq.n	341982f2 <_tx_timer_system_activate+0xaa>
        {

            /* Valid timer activate request.  */

            /* Determine if the timer still needs activation.  */
            if (timer_ptr -> tx_timer_internal_list_head == TX_NULL)
34198264:	687b      	ldr	r3, [r7, #4]
34198266:	699b      	ldr	r3, [r3, #24]
34198268:	2b00      	cmp	r3, #0
3419826a:	d142      	bne.n	341982f2 <_tx_timer_system_activate+0xaa>
            {

                /* Activate the timer.  */

                /* Calculate the amount of time remaining for the timer.  */
                if (remaining_ticks > TX_TIMER_ENTRIES)
3419826c:	697b      	ldr	r3, [r7, #20]
3419826e:	2b20      	cmp	r3, #32
34198270:	d902      	bls.n	34198278 <_tx_timer_system_activate+0x30>
                {

                    /* Set expiration time to the maximum number of entries.  */
                    expiration_time =  TX_TIMER_ENTRIES - ((ULONG) 1);
34198272:	231f      	movs	r3, #31
34198274:	61bb      	str	r3, [r7, #24]
34198276:	e002      	b.n	3419827e <_tx_timer_system_activate+0x36>
                {

                    /* Timer value fits in the timer entries.  */

                    /* Set the expiration time.  */
                    expiration_time =  (remaining_ticks - ((ULONG) 1));
34198278:	697b      	ldr	r3, [r7, #20]
3419827a:	3b01      	subs	r3, #1
3419827c:	61bb      	str	r3, [r7, #24]

                /* At this point, we are ready to put the timer on one of
                   the timer lists.  */

                /* Calculate the proper place for the timer.  */
                timer_list =  TX_TIMER_POINTER_ADD(_tx_timer_current_ptr, expiration_time);
3419827e:	4b20      	ldr	r3, [pc, #128]	@ (34198300 <_tx_timer_system_activate+0xb8>)
34198280:	681a      	ldr	r2, [r3, #0]
34198282:	69bb      	ldr	r3, [r7, #24]
34198284:	009b      	lsls	r3, r3, #2
34198286:	4413      	add	r3, r2
34198288:	61fb      	str	r3, [r7, #28]
                if (TX_TIMER_INDIRECT_TO_VOID_POINTER_CONVERT(timer_list) >= TX_TIMER_INDIRECT_TO_VOID_POINTER_CONVERT(_tx_timer_list_end))
3419828a:	4b1e      	ldr	r3, [pc, #120]	@ (34198304 <_tx_timer_system_activate+0xbc>)
3419828c:	681b      	ldr	r3, [r3, #0]
3419828e:	69fa      	ldr	r2, [r7, #28]
34198290:	429a      	cmp	r2, r3
34198292:	d30b      	bcc.n	341982ac <_tx_timer_system_activate+0x64>
                {

                    /* Wrap from the beginning of the list.  */
                    delta =  TX_TIMER_POINTER_DIF(timer_list, _tx_timer_list_end);
34198294:	4b1b      	ldr	r3, [pc, #108]	@ (34198304 <_tx_timer_system_activate+0xbc>)
34198296:	681b      	ldr	r3, [r3, #0]
34198298:	69fa      	ldr	r2, [r7, #28]
3419829a:	1ad3      	subs	r3, r2, r3
3419829c:	109b      	asrs	r3, r3, #2
3419829e:	613b      	str	r3, [r7, #16]
                    timer_list =  TX_TIMER_POINTER_ADD(_tx_timer_list_start, delta);
341982a0:	4b19      	ldr	r3, [pc, #100]	@ (34198308 <_tx_timer_system_activate+0xc0>)
341982a2:	681a      	ldr	r2, [r3, #0]
341982a4:	693b      	ldr	r3, [r7, #16]
341982a6:	009b      	lsls	r3, r3, #2
341982a8:	4413      	add	r3, r2
341982aa:	61fb      	str	r3, [r7, #28]
                }

                /* Now put the timer on this list.  */
                if ((*timer_list) == TX_NULL)
341982ac:	69fb      	ldr	r3, [r7, #28]
341982ae:	681b      	ldr	r3, [r3, #0]
341982b0:	2b00      	cmp	r3, #0
341982b2:	d109      	bne.n	341982c8 <_tx_timer_system_activate+0x80>
                {

                    /* This list is NULL, just put the new timer on it.  */

                    /* Setup the links in this timer.  */
                    timer_ptr -> tx_timer_internal_active_next =      timer_ptr;
341982b4:	687b      	ldr	r3, [r7, #4]
341982b6:	687a      	ldr	r2, [r7, #4]
341982b8:	611a      	str	r2, [r3, #16]
                    timer_ptr -> tx_timer_internal_active_previous =  timer_ptr;
341982ba:	687b      	ldr	r3, [r7, #4]
341982bc:	687a      	ldr	r2, [r7, #4]
341982be:	615a      	str	r2, [r3, #20]

                    /* Setup the list head pointer.  */
                    *timer_list =  timer_ptr;
341982c0:	69fb      	ldr	r3, [r7, #28]
341982c2:	687a      	ldr	r2, [r7, #4]
341982c4:	601a      	str	r2, [r3, #0]
341982c6:	e011      	b.n	341982ec <_tx_timer_system_activate+0xa4>
                }
                else
                {

                    /* This list is not NULL, add current timer to the end. */
                    next_timer =                                        *timer_list;
341982c8:	69fb      	ldr	r3, [r7, #28]
341982ca:	681b      	ldr	r3, [r3, #0]
341982cc:	60fb      	str	r3, [r7, #12]
                    previous_timer =                                    next_timer -> tx_timer_internal_active_previous;
341982ce:	68fb      	ldr	r3, [r7, #12]
341982d0:	695b      	ldr	r3, [r3, #20]
341982d2:	60bb      	str	r3, [r7, #8]
                    previous_timer -> tx_timer_internal_active_next =   timer_ptr;
341982d4:	68bb      	ldr	r3, [r7, #8]
341982d6:	687a      	ldr	r2, [r7, #4]
341982d8:	611a      	str	r2, [r3, #16]
                    next_timer -> tx_timer_internal_active_previous =   timer_ptr;
341982da:	68fb      	ldr	r3, [r7, #12]
341982dc:	687a      	ldr	r2, [r7, #4]
341982de:	615a      	str	r2, [r3, #20]
                    timer_ptr -> tx_timer_internal_active_next =        next_timer;
341982e0:	687b      	ldr	r3, [r7, #4]
341982e2:	68fa      	ldr	r2, [r7, #12]
341982e4:	611a      	str	r2, [r3, #16]
                    timer_ptr -> tx_timer_internal_active_previous =    previous_timer;
341982e6:	687b      	ldr	r3, [r7, #4]
341982e8:	68ba      	ldr	r2, [r7, #8]
341982ea:	615a      	str	r2, [r3, #20]
                }

                /* Setup list head pointer.  */
                timer_ptr -> tx_timer_internal_list_head =  timer_list;
341982ec:	687b      	ldr	r3, [r7, #4]
341982ee:	69fa      	ldr	r2, [r7, #28]
341982f0:	619a      	str	r2, [r3, #24]
            }
        }
    }
}
341982f2:	bf00      	nop
341982f4:	3724      	adds	r7, #36	@ 0x24
341982f6:	46bd      	mov	sp, r7
341982f8:	f85d 7b04 	ldr.w	r7, [sp], #4
341982fc:	4770      	bx	lr
341982fe:	bf00      	nop
34198300:	341c2f20 	.word	0x341c2f20
34198304:	341c2f1c 	.word	0x341c2f1c
34198308:	341c2f18 	.word	0x341c2f18

3419830c <_tx_timer_system_deactivate>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_timer_system_deactivate(TX_TIMER_INTERNAL *timer_ptr)
{
3419830c:	b480      	push	{r7}
3419830e:	b087      	sub	sp, #28
34198310:	af00      	add	r7, sp, #0
34198312:	6078      	str	r0, [r7, #4]
TX_TIMER_INTERNAL   *next_timer;
TX_TIMER_INTERNAL   *previous_timer;


    /* Pickup the list head pointer.  */
    list_head =  timer_ptr -> tx_timer_internal_list_head;
34198314:	687b      	ldr	r3, [r7, #4]
34198316:	699b      	ldr	r3, [r3, #24]
34198318:	617b      	str	r3, [r7, #20]

    /* Determine if the timer still needs deactivation.  */
    if (list_head != TX_NULL)
3419831a:	697b      	ldr	r3, [r7, #20]
3419831c:	2b00      	cmp	r3, #0
3419831e:	d026      	beq.n	3419836e <_tx_timer_system_deactivate+0x62>
    {

        /* Deactivate the timer.  */

        /* Pickup the next active timer.  */
        next_timer =  timer_ptr -> tx_timer_internal_active_next;
34198320:	687b      	ldr	r3, [r7, #4]
34198322:	691b      	ldr	r3, [r3, #16]
34198324:	613b      	str	r3, [r7, #16]

        /* See if this is the only timer in the list.  */
        if (timer_ptr == next_timer)
34198326:	687a      	ldr	r2, [r7, #4]
34198328:	693b      	ldr	r3, [r7, #16]
3419832a:	429a      	cmp	r2, r3
3419832c:	d108      	bne.n	34198340 <_tx_timer_system_deactivate+0x34>
        {

            /* Yes, the only timer on the list.  */

            /* Determine if the head pointer needs to be updated.  */
            if (*(list_head) == timer_ptr)
3419832e:	697b      	ldr	r3, [r7, #20]
34198330:	681b      	ldr	r3, [r3, #0]
34198332:	687a      	ldr	r2, [r7, #4]
34198334:	429a      	cmp	r2, r3
34198336:	d117      	bne.n	34198368 <_tx_timer_system_deactivate+0x5c>
            {

                /* Update the head pointer.  */
                *(list_head) =  TX_NULL;
34198338:	697b      	ldr	r3, [r7, #20]
3419833a:	2200      	movs	r2, #0
3419833c:	601a      	str	r2, [r3, #0]
3419833e:	e013      	b.n	34198368 <_tx_timer_system_deactivate+0x5c>
        {

            /* At least one more timer is on the same expiration list.  */

            /* Update the links of the adjacent timers.  */
            previous_timer =                                   timer_ptr -> tx_timer_internal_active_previous;
34198340:	687b      	ldr	r3, [r7, #4]
34198342:	695b      	ldr	r3, [r3, #20]
34198344:	60fb      	str	r3, [r7, #12]
            next_timer -> tx_timer_internal_active_previous =  previous_timer;
34198346:	693b      	ldr	r3, [r7, #16]
34198348:	68fa      	ldr	r2, [r7, #12]
3419834a:	615a      	str	r2, [r3, #20]
            previous_timer -> tx_timer_internal_active_next =  next_timer;
3419834c:	68fb      	ldr	r3, [r7, #12]
3419834e:	693a      	ldr	r2, [r7, #16]
34198350:	611a      	str	r2, [r3, #16]

            /* Determine if the head pointer needs to be updated.  */
            if (*(list_head) == timer_ptr)
34198352:	697b      	ldr	r3, [r7, #20]
34198354:	681b      	ldr	r3, [r3, #0]
34198356:	687a      	ldr	r2, [r7, #4]
34198358:	429a      	cmp	r2, r3
3419835a:	d105      	bne.n	34198368 <_tx_timer_system_deactivate+0x5c>
            {

                /* Update the next timer in the list with the list head pointer.  */
                next_timer -> tx_timer_internal_list_head =  list_head;
3419835c:	693b      	ldr	r3, [r7, #16]
3419835e:	697a      	ldr	r2, [r7, #20]
34198360:	619a      	str	r2, [r3, #24]

                /* Update the head pointer.  */
                *(list_head) =  next_timer;
34198362:	697b      	ldr	r3, [r7, #20]
34198364:	693a      	ldr	r2, [r7, #16]
34198366:	601a      	str	r2, [r3, #0]
            }
        }

        /* Clear the timer's list head pointer.  */
        timer_ptr -> tx_timer_internal_list_head =  TX_NULL;
34198368:	687b      	ldr	r3, [r7, #4]
3419836a:	2200      	movs	r2, #0
3419836c:	619a      	str	r2, [r3, #24]
    }
}
3419836e:	bf00      	nop
34198370:	371c      	adds	r7, #28
34198372:	46bd      	mov	sp, r7
34198374:	f85d 7b04 	ldr.w	r7, [sp], #4
34198378:	4770      	bx	lr
	...

3419837c <_tx_timer_thread_entry>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
#ifndef TX_TIMER_PROCESS_IN_ISR
VOID  _tx_timer_thread_entry(ULONG timer_thread_input)
{
3419837c:	b580      	push	{r7, lr}
3419837e:	b098      	sub	sp, #96	@ 0x60
34198380:	af00      	add	r7, sp, #0
34198382:	6078      	str	r0, [r7, #4]
TX_TIMER_INTERNAL           *reactivate_timer;
TX_TIMER_INTERNAL           *next_timer;
TX_TIMER_INTERNAL           *previous_timer;
TX_TIMER_INTERNAL           *current_timer;
VOID                        (*timeout_function)(ULONG id);
ULONG                       timeout_param =  ((ULONG) 0);
34198384:	2300      	movs	r3, #0
34198386:	657b      	str	r3, [r7, #84]	@ 0x54
#endif


    /* Make sure the timer input is correct.  This also gets rid of the
       silly compiler warnings.  */
    if (timer_thread_input == TX_TIMER_ID)
34198388:	687b      	ldr	r3, [r7, #4]
3419838a:	4a73      	ldr	r2, [pc, #460]	@ (34198558 <_tx_timer_thread_entry+0x1dc>)
3419838c:	4293      	cmp	r3, r2
3419838e:	f040 80de 	bne.w	3419854e <_tx_timer_thread_entry+0x1d2>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34198392:	f3ef 8310 	mrs	r3, PRIMASK
34198396:	643b      	str	r3, [r7, #64]	@ 0x40
    return(posture);
34198398:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
    int_posture = __get_interrupt_posture();
3419839a:	63fb      	str	r3, [r7, #60]	@ 0x3c
    __asm__ volatile ("CPSID i" : : : "memory");
3419839c:	b672      	cpsid	i
    return(int_posture);
3419839e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
        {

            /* First, move the current list pointer and clear the timer
               expired value.  This allows the interrupt handling portion
               to continue looking for timer expirations.  */
            TX_DISABLE
341983a0:	65fb      	str	r3, [r7, #92]	@ 0x5c

            /* Save the current timer expiration list pointer.  */
            expired_timers =  *_tx_timer_current_ptr;
341983a2:	4b6e      	ldr	r3, [pc, #440]	@ (3419855c <_tx_timer_thread_entry+0x1e0>)
341983a4:	681b      	ldr	r3, [r3, #0]
341983a6:	681b      	ldr	r3, [r3, #0]
341983a8:	60fb      	str	r3, [r7, #12]

            /* Modify the head pointer in the first timer in the list, if there
               is one!  */
            if (expired_timers != TX_NULL)
341983aa:	68fb      	ldr	r3, [r7, #12]
341983ac:	2b00      	cmp	r3, #0
341983ae:	d003      	beq.n	341983b8 <_tx_timer_thread_entry+0x3c>
            {

                expired_timers -> tx_timer_internal_list_head =  &expired_timers;
341983b0:	68fb      	ldr	r3, [r7, #12]
341983b2:	f107 020c 	add.w	r2, r7, #12
341983b6:	619a      	str	r2, [r3, #24]
            }

            /* Set the current list pointer to NULL.  */
            *_tx_timer_current_ptr =  TX_NULL;
341983b8:	4b68      	ldr	r3, [pc, #416]	@ (3419855c <_tx_timer_thread_entry+0x1e0>)
341983ba:	681b      	ldr	r3, [r3, #0]
341983bc:	2200      	movs	r2, #0
341983be:	601a      	str	r2, [r3, #0]

            /* Move the current pointer up one timer entry wrap if we get to
               the end of the list.  */
            _tx_timer_current_ptr =  TX_TIMER_POINTER_ADD(_tx_timer_current_ptr, 1);
341983c0:	4b66      	ldr	r3, [pc, #408]	@ (3419855c <_tx_timer_thread_entry+0x1e0>)
341983c2:	681b      	ldr	r3, [r3, #0]
341983c4:	3304      	adds	r3, #4
341983c6:	4a65      	ldr	r2, [pc, #404]	@ (3419855c <_tx_timer_thread_entry+0x1e0>)
341983c8:	6013      	str	r3, [r2, #0]
            if (_tx_timer_current_ptr == _tx_timer_list_end)
341983ca:	4b64      	ldr	r3, [pc, #400]	@ (3419855c <_tx_timer_thread_entry+0x1e0>)
341983cc:	681a      	ldr	r2, [r3, #0]
341983ce:	4b64      	ldr	r3, [pc, #400]	@ (34198560 <_tx_timer_thread_entry+0x1e4>)
341983d0:	681b      	ldr	r3, [r3, #0]
341983d2:	429a      	cmp	r2, r3
341983d4:	d103      	bne.n	341983de <_tx_timer_thread_entry+0x62>
            {

                _tx_timer_current_ptr =  _tx_timer_list_start;
341983d6:	4b63      	ldr	r3, [pc, #396]	@ (34198564 <_tx_timer_thread_entry+0x1e8>)
341983d8:	681b      	ldr	r3, [r3, #0]
341983da:	4a60      	ldr	r2, [pc, #384]	@ (3419855c <_tx_timer_thread_entry+0x1e0>)
341983dc:	6013      	str	r3, [r2, #0]
            }

            /* Clear the expired flag.  */
            _tx_timer_expired =  TX_FALSE;
341983de:	4b62      	ldr	r3, [pc, #392]	@ (34198568 <_tx_timer_thread_entry+0x1ec>)
341983e0:	2200      	movs	r2, #0
341983e2:	601a      	str	r2, [r3, #0]
341983e4:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
341983e6:	633b      	str	r3, [r7, #48]	@ 0x30
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
341983e8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
341983ea:	f383 8810 	msr	PRIMASK, r3
}
341983ee:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
341983f0:	f3ef 8310 	mrs	r3, PRIMASK
341983f4:	63bb      	str	r3, [r7, #56]	@ 0x38
    return(posture);
341983f6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
    int_posture = __get_interrupt_posture();
341983f8:	637b      	str	r3, [r7, #52]	@ 0x34
    __asm__ volatile ("CPSID i" : : : "memory");
341983fa:	b672      	cpsid	i
    return(int_posture);
341983fc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34

            /* Restore interrupts temporarily.  */
            TX_RESTORE

            /* Disable interrupts again.  */
            TX_DISABLE
341983fe:	65fb      	str	r3, [r7, #92]	@ 0x5c

            /* Next, process the expiration of the associated timers at this
               time slot.  */
            while (expired_timers != TX_NULL)
34198400:	e07f      	b.n	34198502 <_tx_timer_thread_entry+0x186>
            {

                /* Something is on the list.  Remove it and process the expiration.  */
                current_timer =  expired_timers;
34198402:	68fb      	ldr	r3, [r7, #12]
34198404:	64fb      	str	r3, [r7, #76]	@ 0x4c

                /* Pickup the next timer.  */
                next_timer =  expired_timers -> tx_timer_internal_active_next;
34198406:	68fb      	ldr	r3, [r7, #12]
34198408:	691b      	ldr	r3, [r3, #16]
3419840a:	64bb      	str	r3, [r7, #72]	@ 0x48

                /* Set the reactivate_timer to NULL.  */
                reactivate_timer =  TX_NULL;
3419840c:	2300      	movs	r3, #0
3419840e:	60bb      	str	r3, [r7, #8]

                /* Determine if this is the only timer.  */
                if (current_timer == next_timer)
34198410:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
34198412:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
34198414:	429a      	cmp	r2, r3
34198416:	d102      	bne.n	3419841e <_tx_timer_thread_entry+0xa2>
                {

                    /* Yes, this is the only timer in the list.  */

                    /* Set the head pointer to NULL.  */
                    expired_timers =  TX_NULL;
34198418:	2300      	movs	r3, #0
3419841a:	60fb      	str	r3, [r7, #12]
3419841c:	e00e      	b.n	3419843c <_tx_timer_thread_entry+0xc0>
                {

                    /* No, not the only expired timer.  */

                    /* Remove this timer from the expired list.  */
                    previous_timer =                                   current_timer -> tx_timer_internal_active_previous;
3419841e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34198420:	695b      	ldr	r3, [r3, #20]
34198422:	647b      	str	r3, [r7, #68]	@ 0x44
                    next_timer -> tx_timer_internal_active_previous =  previous_timer;
34198424:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
34198426:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
34198428:	615a      	str	r2, [r3, #20]
                    previous_timer -> tx_timer_internal_active_next =  next_timer;
3419842a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3419842c:	6cba      	ldr	r2, [r7, #72]	@ 0x48
3419842e:	611a      	str	r2, [r3, #16]

                    /* Modify the next timer's list head to point at the current list head.  */
                    next_timer -> tx_timer_internal_list_head =  &expired_timers;
34198430:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
34198432:	f107 020c 	add.w	r2, r7, #12
34198436:	619a      	str	r2, [r3, #24]

                    /* Set the list head pointer.  */
                    expired_timers =  next_timer;
34198438:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3419843a:	60fb      	str	r3, [r7, #12]

                /* In any case, the timer is now off of the expired list.  */

                /* Determine if the timer has expired or if it is just a really
                   big timer that needs to be placed in the list again.  */
                if (current_timer -> tx_timer_internal_remaining_ticks > TX_TIMER_ENTRIES)
3419843c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3419843e:	681b      	ldr	r3, [r3, #0]
34198440:	2b20      	cmp	r3, #32
34198442:	d911      	bls.n	34198468 <_tx_timer_thread_entry+0xec>
                    }
#endif

                    /* Decrement the remaining ticks of the timer.  */
                    current_timer -> tx_timer_internal_remaining_ticks =
                            current_timer -> tx_timer_internal_remaining_ticks - TX_TIMER_ENTRIES;
34198444:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34198446:	681b      	ldr	r3, [r3, #0]
34198448:	f1a3 0220 	sub.w	r2, r3, #32
                    current_timer -> tx_timer_internal_remaining_ticks =
3419844c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3419844e:	601a      	str	r2, [r3, #0]

                    /* Set the timeout function to NULL in order to bypass the
                       expiration.  */
                    timeout_function =  TX_NULL;
34198450:	2300      	movs	r3, #0
34198452:	65bb      	str	r3, [r7, #88]	@ 0x58

                    /* Make the timer appear that it is still active while interrupts
                       are enabled.  This will permit proper processing of a timer
                       deactivate from an ISR.  */
                    current_timer -> tx_timer_internal_list_head =    &reactivate_timer;
34198454:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34198456:	f107 0208 	add.w	r2, r7, #8
3419845a:	619a      	str	r2, [r3, #24]
                    current_timer -> tx_timer_internal_active_next =  current_timer;
3419845c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3419845e:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
34198460:	611a      	str	r2, [r3, #16]

                    /* Setup the temporary timer list head pointer.  */
                    reactivate_timer =  current_timer;
34198462:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34198464:	60bb      	str	r3, [r7, #8]
34198466:	e01a      	b.n	3419849e <_tx_timer_thread_entry+0x122>
                    }
#endif

                    /* Copy the calling function and ID into local variables before interrupts
                       are re-enabled.  */
                    timeout_function =  current_timer -> tx_timer_internal_timeout_function;
34198468:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3419846a:	689b      	ldr	r3, [r3, #8]
3419846c:	65bb      	str	r3, [r7, #88]	@ 0x58
                    timeout_param =     current_timer -> tx_timer_internal_timeout_param;
3419846e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34198470:	68db      	ldr	r3, [r3, #12]
34198472:	657b      	str	r3, [r7, #84]	@ 0x54

                    /* Copy the reinitialize ticks into the remaining ticks.  */
                    current_timer -> tx_timer_internal_remaining_ticks =  current_timer -> tx_timer_internal_re_initialize_ticks;
34198474:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34198476:	685a      	ldr	r2, [r3, #4]
34198478:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3419847a:	601a      	str	r2, [r3, #0]

                    /* Determine if the timer should be reactivated.  */
                    if (current_timer -> tx_timer_internal_remaining_ticks != ((ULONG) 0))
3419847c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3419847e:	681b      	ldr	r3, [r3, #0]
34198480:	2b00      	cmp	r3, #0
34198482:	d009      	beq.n	34198498 <_tx_timer_thread_entry+0x11c>

                        /* Make the timer appear that it is still active while processing
                           the expiration routine and with interrupts enabled.  This will
                           permit proper processing of a timer deactivate from both the
                           expiration routine and an ISR.  */
                        current_timer -> tx_timer_internal_list_head =    &reactivate_timer;
34198484:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34198486:	f107 0208 	add.w	r2, r7, #8
3419848a:	619a      	str	r2, [r3, #24]
                        current_timer -> tx_timer_internal_active_next =  current_timer;
3419848c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3419848e:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
34198490:	611a      	str	r2, [r3, #16]

                        /* Setup the temporary timer list head pointer.  */
                        reactivate_timer =  current_timer;
34198492:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34198494:	60bb      	str	r3, [r7, #8]
34198496:	e002      	b.n	3419849e <_tx_timer_thread_entry+0x122>
                    else
                    {

                        /* Set the list pointer of this timer to NULL.  This is used to indicate
                           the timer is no longer active.  */
                        current_timer -> tx_timer_internal_list_head =  TX_NULL;
34198498:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3419849a:	2200      	movs	r2, #0
3419849c:	619a      	str	r2, [r3, #24]
                    }
                }

                /* Set pointer to indicate the expired timer that is currently being processed.  */
                _tx_timer_expired_timer_ptr =  current_timer;
3419849e:	4a33      	ldr	r2, [pc, #204]	@ (3419856c <_tx_timer_thread_entry+0x1f0>)
341984a0:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
341984a2:	6013      	str	r3, [r2, #0]
341984a4:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
341984a6:	62fb      	str	r3, [r7, #44]	@ 0x2c
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
341984a8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
341984aa:	f383 8810 	msr	PRIMASK, r3
}
341984ae:	bf00      	nop

                /* Restore interrupts for timer expiration call.  */
                TX_RESTORE

                /* Call the timer-expiration function, if non-NULL.  */
                if (timeout_function != TX_NULL)
341984b0:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
341984b2:	2b00      	cmp	r3, #0
341984b4:	d002      	beq.n	341984bc <_tx_timer_thread_entry+0x140>
                {

                    (timeout_function) (timeout_param);
341984b6:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
341984b8:	6d78      	ldr	r0, [r7, #84]	@ 0x54
341984ba:	4798      	blx	r3
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
341984bc:	f3ef 8310 	mrs	r3, PRIMASK
341984c0:	62bb      	str	r3, [r7, #40]	@ 0x28
    return(posture);
341984c2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
    int_posture = __get_interrupt_posture();
341984c4:	627b      	str	r3, [r7, #36]	@ 0x24
    __asm__ volatile ("CPSID i" : : : "memory");
341984c6:	b672      	cpsid	i
    return(int_posture);
341984c8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
                }

                /* Lockout interrupts again.  */
                TX_DISABLE
341984ca:	65fb      	str	r3, [r7, #92]	@ 0x5c

                /* Clear expired timer pointer.  */
                _tx_timer_expired_timer_ptr =  TX_NULL;
341984cc:	4b27      	ldr	r3, [pc, #156]	@ (3419856c <_tx_timer_thread_entry+0x1f0>)
341984ce:	2200      	movs	r2, #0
341984d0:	601a      	str	r2, [r3, #0]

                /* Determine if the timer needs to be reactivated.  */
                if (reactivate_timer == current_timer)
341984d2:	68bb      	ldr	r3, [r7, #8]
341984d4:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
341984d6:	429a      	cmp	r2, r3
341984d8:	d105      	bne.n	341984e6 <_tx_timer_thread_entry+0x16a>
#else

                    /* Reactivate through the timer activate function.  */

                    /* Clear the list head for the timer activate call.  */
                    current_timer -> tx_timer_internal_list_head = TX_NULL;
341984da:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
341984dc:	2200      	movs	r2, #0
341984de:	619a      	str	r2, [r3, #24]

                    /* Activate the current timer.  */
                    _tx_timer_system_activate(current_timer);
341984e0:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
341984e2:	f7ff feb1 	bl	34198248 <_tx_timer_system_activate>
341984e6:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
341984e8:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
341984ea:	69bb      	ldr	r3, [r7, #24]
341984ec:	f383 8810 	msr	PRIMASK, r3
}
341984f0:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
341984f2:	f3ef 8310 	mrs	r3, PRIMASK
341984f6:	623b      	str	r3, [r7, #32]
    return(posture);
341984f8:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
341984fa:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
341984fc:	b672      	cpsid	i
    return(int_posture);
341984fe:	69fb      	ldr	r3, [r7, #28]

                /* Restore interrupts.  */
                TX_RESTORE

                /* Lockout interrupts again.  */
                TX_DISABLE
34198500:	65fb      	str	r3, [r7, #92]	@ 0x5c
            while (expired_timers != TX_NULL)
34198502:	68fb      	ldr	r3, [r7, #12]
34198504:	2b00      	cmp	r3, #0
34198506:	f47f af7c 	bne.w	34198402 <_tx_timer_thread_entry+0x86>

            /* Finally, suspend this thread and wait for the next expiration.  */

            /* Determine if another expiration took place while we were in this
               thread.  If so, process another expiration.  */
            if (_tx_timer_expired == TX_FALSE)
3419850a:	4b17      	ldr	r3, [pc, #92]	@ (34198568 <_tx_timer_thread_entry+0x1ec>)
3419850c:	681b      	ldr	r3, [r3, #0]
3419850e:	2b00      	cmp	r3, #0
34198510:	d116      	bne.n	34198540 <_tx_timer_thread_entry+0x1c4>
            {

                /* Otherwise, no timer expiration, so suspend the thread.  */

                /* Build pointer to the timer thread.  */
                thread_ptr =  &_tx_timer_thread;
34198512:	4b17      	ldr	r3, [pc, #92]	@ (34198570 <_tx_timer_thread_entry+0x1f4>)
34198514:	653b      	str	r3, [r7, #80]	@ 0x50

                /* Set the status to suspending, in order to indicate the
                   suspension is in progress.  */
                thread_ptr -> tx_thread_state =  TX_SUSPENDED;
34198516:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
34198518:	2203      	movs	r2, #3
3419851a:	631a      	str	r2, [r3, #48]	@ 0x30
                /* Restore interrupts.  */
                TX_RESTORE
#else

                /* Set the suspending flag. */
                thread_ptr -> tx_thread_suspending =  TX_TRUE;
3419851c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
3419851e:	2201      	movs	r2, #1
34198520:	639a      	str	r2, [r3, #56]	@ 0x38

                /* Increment the preempt disable count prior to suspending.  */
                _tx_thread_preempt_disable++;
34198522:	4b14      	ldr	r3, [pc, #80]	@ (34198574 <_tx_timer_thread_entry+0x1f8>)
34198524:	681b      	ldr	r3, [r3, #0]
34198526:	3301      	adds	r3, #1
34198528:	4a12      	ldr	r2, [pc, #72]	@ (34198574 <_tx_timer_thread_entry+0x1f8>)
3419852a:	6013      	str	r3, [r2, #0]
3419852c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3419852e:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34198530:	697b      	ldr	r3, [r7, #20]
34198532:	f383 8810 	msr	PRIMASK, r3
}
34198536:	bf00      	nop

                /* Restore interrupts.  */
                TX_RESTORE

                /* Call actual thread suspension routine.  */
                _tx_thread_system_suspend(thread_ptr);
34198538:	6d38      	ldr	r0, [r7, #80]	@ 0x50
3419853a:	f7ff faa3 	bl	34197a84 <_tx_thread_system_suspend>
3419853e:	e728      	b.n	34198392 <_tx_timer_thread_entry+0x16>
34198540:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
34198542:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34198544:	693b      	ldr	r3, [r7, #16]
34198546:	f383 8810 	msr	PRIMASK, r3
}
3419854a:	bf00      	nop
            TX_DISABLE
3419854c:	e721      	b.n	34198392 <_tx_timer_thread_entry+0x16>

    /* If we ever get here, raise safety critical exception.  */
    TX_SAFETY_CRITICAL_EXCEPTION(__FILE__, __LINE__, 0);
#endif

}
3419854e:	bf00      	nop
34198550:	3760      	adds	r7, #96	@ 0x60
34198552:	46bd      	mov	sp, r7
34198554:	bd80      	pop	{r7, pc}
34198556:	bf00      	nop
34198558:	4154494d 	.word	0x4154494d
3419855c:	341c2f20 	.word	0x341c2f20
34198560:	341c2f1c 	.word	0x341c2f1c
34198564:	341c2f18 	.word	0x341c2f18
34198568:	341c2f24 	.word	0x341c2f24
3419856c:	341c2f30 	.word	0x341c2f30
34198570:	341c2f34 	.word	0x341c2f34
34198574:	341c2e84 	.word	0x341c2e84

34198578 <_txe_byte_allocate>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_byte_allocate(TX_BYTE_POOL *pool_ptr, VOID **memory_ptr,
                                    ULONG memory_size,  ULONG wait_option)
{
34198578:	b580      	push	{r7, lr}
3419857a:	b08a      	sub	sp, #40	@ 0x28
3419857c:	af00      	add	r7, sp, #0
3419857e:	60f8      	str	r0, [r7, #12]
34198580:	60b9      	str	r1, [r7, #8]
34198582:	607a      	str	r2, [r7, #4]
34198584:	603b      	str	r3, [r7, #0]
TX_THREAD       *thread_ptr;
#endif


    /* Default status to success.  */
    status =  TX_SUCCESS;
34198586:	2300      	movs	r3, #0
34198588:	627b      	str	r3, [r7, #36]	@ 0x24

    /* Check for an invalid byte pool pointer.  */
    if (pool_ptr == TX_NULL)
3419858a:	68fb      	ldr	r3, [r7, #12]
3419858c:	2b00      	cmp	r3, #0
3419858e:	d102      	bne.n	34198596 <_txe_byte_allocate+0x1e>
    {

        /* Byte pool pointer is invalid, return appropriate error code.  */
        status =  TX_POOL_ERROR;
34198590:	2302      	movs	r3, #2
34198592:	627b      	str	r3, [r7, #36]	@ 0x24
34198594:	e029      	b.n	341985ea <_txe_byte_allocate+0x72>
    }

    /* Now check for invalid pool ID.  */
    else if  (pool_ptr -> tx_byte_pool_id != TX_BYTE_POOL_ID)
34198596:	68fb      	ldr	r3, [r7, #12]
34198598:	681b      	ldr	r3, [r3, #0]
3419859a:	4a2d      	ldr	r2, [pc, #180]	@ (34198650 <_txe_byte_allocate+0xd8>)
3419859c:	4293      	cmp	r3, r2
3419859e:	d002      	beq.n	341985a6 <_txe_byte_allocate+0x2e>
    {

        /* Byte pool pointer is invalid, return appropriate error code.  */
        status =  TX_POOL_ERROR;
341985a0:	2302      	movs	r3, #2
341985a2:	627b      	str	r3, [r7, #36]	@ 0x24
341985a4:	e021      	b.n	341985ea <_txe_byte_allocate+0x72>
    }

    /* Check for an invalid destination for return pointer.  */
    else if (memory_ptr == TX_NULL)
341985a6:	68bb      	ldr	r3, [r7, #8]
341985a8:	2b00      	cmp	r3, #0
341985aa:	d102      	bne.n	341985b2 <_txe_byte_allocate+0x3a>
    {

        /* Null destination pointer, return appropriate error.  */
        status =  TX_PTR_ERROR;
341985ac:	2303      	movs	r3, #3
341985ae:	627b      	str	r3, [r7, #36]	@ 0x24
341985b0:	e01b      	b.n	341985ea <_txe_byte_allocate+0x72>
    }

    /* Check for an invalid memory size.  */
    else if (memory_size == ((ULONG) 0))
341985b2:	687b      	ldr	r3, [r7, #4]
341985b4:	2b00      	cmp	r3, #0
341985b6:	d102      	bne.n	341985be <_txe_byte_allocate+0x46>
    {

        /* Error in size, return appropriate error.  */
        status =  TX_SIZE_ERROR;
341985b8:	2305      	movs	r3, #5
341985ba:	627b      	str	r3, [r7, #36]	@ 0x24
341985bc:	e015      	b.n	341985ea <_txe_byte_allocate+0x72>
    }

    /* Determine if the size is greater than the pool size.  */
    else if (memory_size > pool_ptr -> tx_byte_pool_size)
341985be:	68fb      	ldr	r3, [r7, #12]
341985c0:	69db      	ldr	r3, [r3, #28]
341985c2:	687a      	ldr	r2, [r7, #4]
341985c4:	429a      	cmp	r2, r3
341985c6:	d902      	bls.n	341985ce <_txe_byte_allocate+0x56>
    {

        /* Error in size, return appropriate error.  */
        status =  TX_SIZE_ERROR;
341985c8:	2305      	movs	r3, #5
341985ca:	627b      	str	r3, [r7, #36]	@ 0x24
341985cc:	e00d      	b.n	341985ea <_txe_byte_allocate+0x72>
    else
    {

        /* Check for a wait option error.  Only threads are allowed any form of
           suspension.  */
        if (wait_option != TX_NO_WAIT)
341985ce:	683b      	ldr	r3, [r7, #0]
341985d0:	2b00      	cmp	r3, #0
341985d2:	d00a      	beq.n	341985ea <_txe_byte_allocate+0x72>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
341985d4:	f3ef 8305 	mrs	r3, IPSR
341985d8:	61fb      	str	r3, [r7, #28]
    return(ipsr_value);
341985da:	69fa      	ldr	r2, [r7, #28]
        {

            /* Is call from ISR or Initialization?  */
            if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
341985dc:	4b1d      	ldr	r3, [pc, #116]	@ (34198654 <_txe_byte_allocate+0xdc>)
341985de:	681b      	ldr	r3, [r3, #0]
341985e0:	4313      	orrs	r3, r2
341985e2:	2b00      	cmp	r3, #0
341985e4:	d001      	beq.n	341985ea <_txe_byte_allocate+0x72>
            {

                /* A non-thread is trying to suspend, return appropriate error code.  */
                status =  TX_WAIT_ERROR;
341985e6:	2304      	movs	r3, #4
341985e8:	627b      	str	r3, [r7, #36]	@ 0x24
        }
    }
#ifndef TX_TIMER_PROCESS_IN_ISR

    /* Check for timer execution.  */
    if (status == TX_SUCCESS)
341985ea:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
341985ec:	2b00      	cmp	r3, #0
341985ee:	d108      	bne.n	34198602 <_txe_byte_allocate+0x8a>
    {

        /* Pickup thread pointer.  */
        TX_THREAD_GET_CURRENT(thread_ptr)
341985f0:	4b19      	ldr	r3, [pc, #100]	@ (34198658 <_txe_byte_allocate+0xe0>)
341985f2:	681b      	ldr	r3, [r3, #0]
341985f4:	623b      	str	r3, [r7, #32]

        /* Check for invalid caller of this function.  First check for a calling thread.  */
        if (thread_ptr == &_tx_timer_thread)
341985f6:	6a3b      	ldr	r3, [r7, #32]
341985f8:	4a18      	ldr	r2, [pc, #96]	@ (3419865c <_txe_byte_allocate+0xe4>)
341985fa:	4293      	cmp	r3, r2
341985fc:	d101      	bne.n	34198602 <_txe_byte_allocate+0x8a>
        {

            /* Invalid caller of this function, return appropriate error code.  */
            status =  TX_CALLER_ERROR;
341985fe:	2313      	movs	r3, #19
34198600:	627b      	str	r3, [r7, #36]	@ 0x24
        }
    }
#endif

    /* Is everything still okay?  */
    if (status == TX_SUCCESS)
34198602:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34198604:	2b00      	cmp	r3, #0
34198606:	d114      	bne.n	34198632 <_txe_byte_allocate+0xba>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
34198608:	f3ef 8305 	mrs	r3, IPSR
3419860c:	61bb      	str	r3, [r7, #24]
    return(ipsr_value);
3419860e:	69ba      	ldr	r2, [r7, #24]
    {

        /* Check for interrupt call.  */
        if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
34198610:	4b10      	ldr	r3, [pc, #64]	@ (34198654 <_txe_byte_allocate+0xdc>)
34198612:	681b      	ldr	r3, [r3, #0]
34198614:	4313      	orrs	r3, r2
34198616:	2b00      	cmp	r3, #0
34198618:	d00b      	beq.n	34198632 <_txe_byte_allocate+0xba>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
3419861a:	f3ef 8305 	mrs	r3, IPSR
3419861e:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
34198620:	697a      	ldr	r2, [r7, #20]
        {

            /* Now, make sure the call is from an interrupt and not initialization.  */
            if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
34198622:	4b0c      	ldr	r3, [pc, #48]	@ (34198654 <_txe_byte_allocate+0xdc>)
34198624:	681b      	ldr	r3, [r3, #0]
34198626:	4313      	orrs	r3, r2
34198628:	f1b3 3ff0 	cmp.w	r3, #4042322160	@ 0xf0f0f0f0
3419862c:	d201      	bcs.n	34198632 <_txe_byte_allocate+0xba>
            {

                /* Invalid caller of this function, return appropriate error code.  */
                status =  TX_CALLER_ERROR;
3419862e:	2313      	movs	r3, #19
34198630:	627b      	str	r3, [r7, #36]	@ 0x24
            }
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
34198632:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34198634:	2b00      	cmp	r3, #0
34198636:	d106      	bne.n	34198646 <_txe_byte_allocate+0xce>
    {

        /* Call actual byte memory allocate function.  */
        status =  _tx_byte_allocate(pool_ptr, memory_ptr, memory_size,  wait_option);
34198638:	683b      	ldr	r3, [r7, #0]
3419863a:	687a      	ldr	r2, [r7, #4]
3419863c:	68b9      	ldr	r1, [r7, #8]
3419863e:	68f8      	ldr	r0, [r7, #12]
34198640:	f7fc f9d4 	bl	341949ec <_tx_byte_allocate>
34198644:	6278      	str	r0, [r7, #36]	@ 0x24
    }

    /* Return completion status.  */
    return(status);
34198646:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
34198648:	4618      	mov	r0, r3
3419864a:	3728      	adds	r7, #40	@ 0x28
3419864c:	46bd      	mov	sp, r7
3419864e:	bd80      	pop	{r7, pc}
34198650:	42595445 	.word	0x42595445
34198654:	341c009c 	.word	0x341c009c
34198658:	341c2dec 	.word	0x341c2dec
3419865c:	341c2f34 	.word	0x341c2f34

34198660 <_txe_byte_pool_create>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_byte_pool_create(TX_BYTE_POOL *pool_ptr, CHAR *name_ptr, VOID *pool_start, ULONG pool_size, UINT pool_control_block_size)
{
34198660:	b580      	push	{r7, lr}
34198662:	b092      	sub	sp, #72	@ 0x48
34198664:	af00      	add	r7, sp, #0
34198666:	60f8      	str	r0, [r7, #12]
34198668:	60b9      	str	r1, [r7, #8]
3419866a:	607a      	str	r2, [r7, #4]
3419866c:	603b      	str	r3, [r7, #0]
TX_THREAD       *thread_ptr;
#endif


    /* Default status to success.  */
    status =  TX_SUCCESS;
3419866e:	2300      	movs	r3, #0
34198670:	647b      	str	r3, [r7, #68]	@ 0x44

    /* Check for an invalid byte pool pointer.  */
    if (pool_ptr == TX_NULL)
34198672:	68fb      	ldr	r3, [r7, #12]
34198674:	2b00      	cmp	r3, #0
34198676:	d102      	bne.n	3419867e <_txe_byte_pool_create+0x1e>
    {

        /* Byte pool pointer is invalid, return appropriate error code.  */
        status =  TX_POOL_ERROR;
34198678:	2302      	movs	r3, #2
3419867a:	647b      	str	r3, [r7, #68]	@ 0x44
3419867c:	e075      	b.n	3419876a <_txe_byte_pool_create+0x10a>
    }

    /* Now see if the pool control block size is valid.  */
    else if (pool_control_block_size != (sizeof(TX_BYTE_POOL)))
3419867e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
34198680:	2b34      	cmp	r3, #52	@ 0x34
34198682:	d002      	beq.n	3419868a <_txe_byte_pool_create+0x2a>
    {

        /* Byte pool pointer is invalid, return appropriate error code.  */
        status =  TX_POOL_ERROR;
34198684:	2302      	movs	r3, #2
34198686:	647b      	str	r3, [r7, #68]	@ 0x44
34198688:	e06f      	b.n	3419876a <_txe_byte_pool_create+0x10a>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
3419868a:	f3ef 8310 	mrs	r3, PRIMASK
3419868e:	62fb      	str	r3, [r7, #44]	@ 0x2c
    return(posture);
34198690:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
    int_posture = __get_interrupt_posture();
34198692:	62bb      	str	r3, [r7, #40]	@ 0x28
    __asm__ volatile ("CPSID i" : : : "memory");
34198694:	b672      	cpsid	i
    return(int_posture);
34198696:	6abb      	ldr	r3, [r7, #40]	@ 0x28
    }
    else
    {

        /* Disable interrupts.  */
        TX_DISABLE
34198698:	63bb      	str	r3, [r7, #56]	@ 0x38

        /* Increment the preempt disable flag.  */
        _tx_thread_preempt_disable++;
3419869a:	4b3b      	ldr	r3, [pc, #236]	@ (34198788 <_txe_byte_pool_create+0x128>)
3419869c:	681b      	ldr	r3, [r3, #0]
3419869e:	3301      	adds	r3, #1
341986a0:	4a39      	ldr	r2, [pc, #228]	@ (34198788 <_txe_byte_pool_create+0x128>)
341986a2:	6013      	str	r3, [r2, #0]
341986a4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
341986a6:	633b      	str	r3, [r7, #48]	@ 0x30
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
341986a8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
341986aa:	f383 8810 	msr	PRIMASK, r3
}
341986ae:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Next see if it is already in the created list.  */
        next_pool =   _tx_byte_pool_created_ptr;
341986b0:	4b36      	ldr	r3, [pc, #216]	@ (3419878c <_txe_byte_pool_create+0x12c>)
341986b2:	681b      	ldr	r3, [r3, #0]
341986b4:	63fb      	str	r3, [r7, #60]	@ 0x3c
        for (i = ((ULONG) 0); i < _tx_byte_pool_created_count; i++)
341986b6:	2300      	movs	r3, #0
341986b8:	643b      	str	r3, [r7, #64]	@ 0x40
341986ba:	e009      	b.n	341986d0 <_txe_byte_pool_create+0x70>
        {

            /* Determine if this byte pool matches the pool in the list.  */
            if (pool_ptr == next_pool)
341986bc:	68fa      	ldr	r2, [r7, #12]
341986be:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
341986c0:	429a      	cmp	r2, r3
341986c2:	d00b      	beq.n	341986dc <_txe_byte_pool_create+0x7c>
            }
            else
            {

                /* Move to the next pool.  */
                next_pool =  next_pool -> tx_byte_pool_created_next;
341986c4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
341986c6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
341986c8:	63fb      	str	r3, [r7, #60]	@ 0x3c
        for (i = ((ULONG) 0); i < _tx_byte_pool_created_count; i++)
341986ca:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
341986cc:	3301      	adds	r3, #1
341986ce:	643b      	str	r3, [r7, #64]	@ 0x40
341986d0:	4b2f      	ldr	r3, [pc, #188]	@ (34198790 <_txe_byte_pool_create+0x130>)
341986d2:	681b      	ldr	r3, [r3, #0]
341986d4:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
341986d6:	429a      	cmp	r2, r3
341986d8:	d3f0      	bcc.n	341986bc <_txe_byte_pool_create+0x5c>
341986da:	e000      	b.n	341986de <_txe_byte_pool_create+0x7e>
                break;
341986dc:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
341986de:	f3ef 8310 	mrs	r3, PRIMASK
341986e2:	623b      	str	r3, [r7, #32]
    return(posture);
341986e4:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
341986e6:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
341986e8:	b672      	cpsid	i
    return(int_posture);
341986ea:	69fb      	ldr	r3, [r7, #28]
            }
        }

        /* Disable interrupts.  */
        TX_DISABLE
341986ec:	63bb      	str	r3, [r7, #56]	@ 0x38

        /* Decrement the preempt disable flag.  */
        _tx_thread_preempt_disable--;
341986ee:	4b26      	ldr	r3, [pc, #152]	@ (34198788 <_txe_byte_pool_create+0x128>)
341986f0:	681b      	ldr	r3, [r3, #0]
341986f2:	3b01      	subs	r3, #1
341986f4:	4a24      	ldr	r2, [pc, #144]	@ (34198788 <_txe_byte_pool_create+0x128>)
341986f6:	6013      	str	r3, [r2, #0]
341986f8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
341986fa:	627b      	str	r3, [r7, #36]	@ 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
341986fc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
341986fe:	f383 8810 	msr	PRIMASK, r3
}
34198702:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Check for preemption.  */
        _tx_thread_system_preempt_check();
34198704:	f7ff f884 	bl	34197810 <_tx_thread_system_preempt_check>

        /* At this point, check to see if there is a duplicate pool.  */
        if (pool_ptr == next_pool)
34198708:	68fa      	ldr	r2, [r7, #12]
3419870a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3419870c:	429a      	cmp	r2, r3
3419870e:	d102      	bne.n	34198716 <_txe_byte_pool_create+0xb6>
        {

            /* Pool is already created, return appropriate error code.  */
            status =  TX_POOL_ERROR;
34198710:	2302      	movs	r3, #2
34198712:	647b      	str	r3, [r7, #68]	@ 0x44
34198714:	e029      	b.n	3419876a <_txe_byte_pool_create+0x10a>
        }

        /* Check for an invalid starting address.  */
        else if (pool_start == TX_NULL)
34198716:	687b      	ldr	r3, [r7, #4]
34198718:	2b00      	cmp	r3, #0
3419871a:	d102      	bne.n	34198722 <_txe_byte_pool_create+0xc2>
        {

            /* Null starting address pointer, return appropriate error.  */
            status =  TX_PTR_ERROR;
3419871c:	2303      	movs	r3, #3
3419871e:	647b      	str	r3, [r7, #68]	@ 0x44
34198720:	e023      	b.n	3419876a <_txe_byte_pool_create+0x10a>
        }

        /* Check for invalid pool size.  */
        else if (pool_size < TX_BYTE_POOL_MIN)
34198722:	683b      	ldr	r3, [r7, #0]
34198724:	2b63      	cmp	r3, #99	@ 0x63
34198726:	d802      	bhi.n	3419872e <_txe_byte_pool_create+0xce>
        {

            /* Pool not big enough, return appropriate error.  */
            status =  TX_SIZE_ERROR;
34198728:	2305      	movs	r3, #5
3419872a:	647b      	str	r3, [r7, #68]	@ 0x44
3419872c:	e01d      	b.n	3419876a <_txe_byte_pool_create+0x10a>
        {

#ifndef TX_TIMER_PROCESS_IN_ISR

            /* Pickup thread pointer.  */
            TX_THREAD_GET_CURRENT(thread_ptr)
3419872e:	4b19      	ldr	r3, [pc, #100]	@ (34198794 <_txe_byte_pool_create+0x134>)
34198730:	681b      	ldr	r3, [r3, #0]
34198732:	637b      	str	r3, [r7, #52]	@ 0x34

            /* Check for invalid caller of this function.  First check for a calling thread.  */
            if (thread_ptr == &_tx_timer_thread)
34198734:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34198736:	4a18      	ldr	r2, [pc, #96]	@ (34198798 <_txe_byte_pool_create+0x138>)
34198738:	4293      	cmp	r3, r2
3419873a:	d101      	bne.n	34198740 <_txe_byte_pool_create+0xe0>
            {

                /* Invalid caller of this function, return appropriate error code.  */
                status =  TX_CALLER_ERROR;
3419873c:	2313      	movs	r3, #19
3419873e:	647b      	str	r3, [r7, #68]	@ 0x44
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
34198740:	f3ef 8305 	mrs	r3, IPSR
34198744:	61bb      	str	r3, [r7, #24]
    return(ipsr_value);
34198746:	69ba      	ldr	r2, [r7, #24]
            }
#endif

            /* Check for interrupt call.  */
            if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
34198748:	4b14      	ldr	r3, [pc, #80]	@ (3419879c <_txe_byte_pool_create+0x13c>)
3419874a:	681b      	ldr	r3, [r3, #0]
3419874c:	4313      	orrs	r3, r2
3419874e:	2b00      	cmp	r3, #0
34198750:	d00b      	beq.n	3419876a <_txe_byte_pool_create+0x10a>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
34198752:	f3ef 8305 	mrs	r3, IPSR
34198756:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
34198758:	697a      	ldr	r2, [r7, #20]
            {

                /* Now, make sure the call is from an interrupt and not initialization.  */
                if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
3419875a:	4b10      	ldr	r3, [pc, #64]	@ (3419879c <_txe_byte_pool_create+0x13c>)
3419875c:	681b      	ldr	r3, [r3, #0]
3419875e:	4313      	orrs	r3, r2
34198760:	f1b3 3ff0 	cmp.w	r3, #4042322160	@ 0xf0f0f0f0
34198764:	d201      	bcs.n	3419876a <_txe_byte_pool_create+0x10a>
                {

                    /* Invalid caller of this function, return appropriate error code.  */
                    status =  TX_CALLER_ERROR;
34198766:	2313      	movs	r3, #19
34198768:	647b      	str	r3, [r7, #68]	@ 0x44
            }
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
3419876a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3419876c:	2b00      	cmp	r3, #0
3419876e:	d106      	bne.n	3419877e <_txe_byte_pool_create+0x11e>
    {

        /* Call actual byte pool create function.  */
        status =  _tx_byte_pool_create(pool_ptr, name_ptr, pool_start, pool_size);
34198770:	683b      	ldr	r3, [r7, #0]
34198772:	687a      	ldr	r2, [r7, #4]
34198774:	68b9      	ldr	r1, [r7, #8]
34198776:	68f8      	ldr	r0, [r7, #12]
34198778:	f7fc fa7a 	bl	34194c70 <_tx_byte_pool_create>
3419877c:	6478      	str	r0, [r7, #68]	@ 0x44
    }

    /* Return completion status.  */
    return(status);
3419877e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
}
34198780:	4618      	mov	r0, r3
34198782:	3748      	adds	r7, #72	@ 0x48
34198784:	46bd      	mov	sp, r7
34198786:	bd80      	pop	{r7, pc}
34198788:	341c2e84 	.word	0x341c2e84
3419878c:	341c2ddc 	.word	0x341c2ddc
34198790:	341c2de0 	.word	0x341c2de0
34198794:	341c2dec 	.word	0x341c2dec
34198798:	341c2f34 	.word	0x341c2f34
3419879c:	341c009c 	.word	0x341c009c

341987a0 <_txe_event_flags_create>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_event_flags_create(TX_EVENT_FLAGS_GROUP *group_ptr, CHAR *name_ptr, UINT event_control_block_size)
{
341987a0:	b580      	push	{r7, lr}
341987a2:	b092      	sub	sp, #72	@ 0x48
341987a4:	af00      	add	r7, sp, #0
341987a6:	60f8      	str	r0, [r7, #12]
341987a8:	60b9      	str	r1, [r7, #8]
341987aa:	607a      	str	r2, [r7, #4]
TX_THREAD                   *thread_ptr;
#endif


    /* Default status to success.  */
    status =  TX_SUCCESS;
341987ac:	2300      	movs	r3, #0
341987ae:	647b      	str	r3, [r7, #68]	@ 0x44

    /* Check for an invalid event flags group pointer.  */
    if (group_ptr == TX_NULL)
341987b0:	68fb      	ldr	r3, [r7, #12]
341987b2:	2b00      	cmp	r3, #0
341987b4:	d102      	bne.n	341987bc <_txe_event_flags_create+0x1c>
    {

        /* Event flags group pointer is invalid, return appropriate error code.  */
        status =  TX_GROUP_ERROR;
341987b6:	2306      	movs	r3, #6
341987b8:	647b      	str	r3, [r7, #68]	@ 0x44
341987ba:	e069      	b.n	34198890 <_txe_event_flags_create+0xf0>
    }

    /* Now check for proper control block size.  */
    else if (event_control_block_size != (sizeof(TX_EVENT_FLAGS_GROUP)))
341987bc:	687b      	ldr	r3, [r7, #4]
341987be:	2b24      	cmp	r3, #36	@ 0x24
341987c0:	d002      	beq.n	341987c8 <_txe_event_flags_create+0x28>
    {

        /* Event flags group pointer is invalid, return appropriate error code.  */
        status =  TX_GROUP_ERROR;
341987c2:	2306      	movs	r3, #6
341987c4:	647b      	str	r3, [r7, #68]	@ 0x44
341987c6:	e063      	b.n	34198890 <_txe_event_flags_create+0xf0>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
341987c8:	f3ef 8310 	mrs	r3, PRIMASK
341987cc:	62fb      	str	r3, [r7, #44]	@ 0x2c
    return(posture);
341987ce:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
    int_posture = __get_interrupt_posture();
341987d0:	62bb      	str	r3, [r7, #40]	@ 0x28
    __asm__ volatile ("CPSID i" : : : "memory");
341987d2:	b672      	cpsid	i
    return(int_posture);
341987d4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
    }
    else
    {

        /* Disable interrupts.  */
        TX_DISABLE
341987d6:	63bb      	str	r3, [r7, #56]	@ 0x38

        /* Increment the preempt disable flag.  */
        _tx_thread_preempt_disable++;
341987d8:	4b34      	ldr	r3, [pc, #208]	@ (341988ac <_txe_event_flags_create+0x10c>)
341987da:	681b      	ldr	r3, [r3, #0]
341987dc:	3301      	adds	r3, #1
341987de:	4a33      	ldr	r2, [pc, #204]	@ (341988ac <_txe_event_flags_create+0x10c>)
341987e0:	6013      	str	r3, [r2, #0]
341987e2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
341987e4:	633b      	str	r3, [r7, #48]	@ 0x30
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
341987e6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
341987e8:	f383 8810 	msr	PRIMASK, r3
}
341987ec:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Next see if it is already in the created list.  */
        next_group =   _tx_event_flags_created_ptr;
341987ee:	4b30      	ldr	r3, [pc, #192]	@ (341988b0 <_txe_event_flags_create+0x110>)
341987f0:	681b      	ldr	r3, [r3, #0]
341987f2:	63fb      	str	r3, [r7, #60]	@ 0x3c
        for (i = ((ULONG) 0); i < _tx_event_flags_created_count; i++)
341987f4:	2300      	movs	r3, #0
341987f6:	643b      	str	r3, [r7, #64]	@ 0x40
341987f8:	e009      	b.n	3419880e <_txe_event_flags_create+0x6e>
        {

            /* Determine if this group matches the event flags group in the list.  */
            if (group_ptr == next_group)
341987fa:	68fa      	ldr	r2, [r7, #12]
341987fc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
341987fe:	429a      	cmp	r2, r3
34198800:	d00b      	beq.n	3419881a <_txe_event_flags_create+0x7a>
            }
            else
            {

                /* Move to the next group.  */
                next_group =  next_group -> tx_event_flags_group_created_next;
34198802:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34198804:	699b      	ldr	r3, [r3, #24]
34198806:	63fb      	str	r3, [r7, #60]	@ 0x3c
        for (i = ((ULONG) 0); i < _tx_event_flags_created_count; i++)
34198808:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419880a:	3301      	adds	r3, #1
3419880c:	643b      	str	r3, [r7, #64]	@ 0x40
3419880e:	4b29      	ldr	r3, [pc, #164]	@ (341988b4 <_txe_event_flags_create+0x114>)
34198810:	681b      	ldr	r3, [r3, #0]
34198812:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
34198814:	429a      	cmp	r2, r3
34198816:	d3f0      	bcc.n	341987fa <_txe_event_flags_create+0x5a>
34198818:	e000      	b.n	3419881c <_txe_event_flags_create+0x7c>
                break;
3419881a:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
3419881c:	f3ef 8310 	mrs	r3, PRIMASK
34198820:	623b      	str	r3, [r7, #32]
    return(posture);
34198822:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
34198824:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
34198826:	b672      	cpsid	i
    return(int_posture);
34198828:	69fb      	ldr	r3, [r7, #28]
            }
        }

        /* Disable interrupts.  */
        TX_DISABLE
3419882a:	63bb      	str	r3, [r7, #56]	@ 0x38

        /* Decrement the preempt disable flag.  */
        _tx_thread_preempt_disable--;
3419882c:	4b1f      	ldr	r3, [pc, #124]	@ (341988ac <_txe_event_flags_create+0x10c>)
3419882e:	681b      	ldr	r3, [r3, #0]
34198830:	3b01      	subs	r3, #1
34198832:	4a1e      	ldr	r2, [pc, #120]	@ (341988ac <_txe_event_flags_create+0x10c>)
34198834:	6013      	str	r3, [r2, #0]
34198836:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34198838:	627b      	str	r3, [r7, #36]	@ 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
3419883a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419883c:	f383 8810 	msr	PRIMASK, r3
}
34198840:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Check for preemption.  */
        _tx_thread_system_preempt_check();
34198842:	f7fe ffe5 	bl	34197810 <_tx_thread_system_preempt_check>

        /* At this point, check to see if there is a duplicate event flag group.  */
        if (group_ptr == next_group)
34198846:	68fa      	ldr	r2, [r7, #12]
34198848:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3419884a:	429a      	cmp	r2, r3
3419884c:	d102      	bne.n	34198854 <_txe_event_flags_create+0xb4>
        {

            /* Group is already created, return appropriate error code.  */
            status =  TX_GROUP_ERROR;
3419884e:	2306      	movs	r3, #6
34198850:	647b      	str	r3, [r7, #68]	@ 0x44
34198852:	e01d      	b.n	34198890 <_txe_event_flags_create+0xf0>
        {

#ifndef TX_TIMER_PROCESS_IN_ISR

            /* Pickup thread pointer.  */
            TX_THREAD_GET_CURRENT(thread_ptr)
34198854:	4b18      	ldr	r3, [pc, #96]	@ (341988b8 <_txe_event_flags_create+0x118>)
34198856:	681b      	ldr	r3, [r3, #0]
34198858:	637b      	str	r3, [r7, #52]	@ 0x34

            /* Check for invalid caller of this function.  First check for a calling thread.  */
            if (thread_ptr == &_tx_timer_thread)
3419885a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
3419885c:	4a17      	ldr	r2, [pc, #92]	@ (341988bc <_txe_event_flags_create+0x11c>)
3419885e:	4293      	cmp	r3, r2
34198860:	d101      	bne.n	34198866 <_txe_event_flags_create+0xc6>
            {

                /* Invalid caller of this function, return appropriate error code.  */
                status =  TX_CALLER_ERROR;
34198862:	2313      	movs	r3, #19
34198864:	647b      	str	r3, [r7, #68]	@ 0x44
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
34198866:	f3ef 8305 	mrs	r3, IPSR
3419886a:	61bb      	str	r3, [r7, #24]
    return(ipsr_value);
3419886c:	69ba      	ldr	r2, [r7, #24]
            }
#endif

            /* Check for interrupt call.  */
            if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
3419886e:	4b14      	ldr	r3, [pc, #80]	@ (341988c0 <_txe_event_flags_create+0x120>)
34198870:	681b      	ldr	r3, [r3, #0]
34198872:	4313      	orrs	r3, r2
34198874:	2b00      	cmp	r3, #0
34198876:	d00b      	beq.n	34198890 <_txe_event_flags_create+0xf0>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
34198878:	f3ef 8305 	mrs	r3, IPSR
3419887c:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
3419887e:	697a      	ldr	r2, [r7, #20]
            {

                /* Now, make sure the call is from an interrupt and not initialization.  */
                if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
34198880:	4b0f      	ldr	r3, [pc, #60]	@ (341988c0 <_txe_event_flags_create+0x120>)
34198882:	681b      	ldr	r3, [r3, #0]
34198884:	4313      	orrs	r3, r2
34198886:	f1b3 3ff0 	cmp.w	r3, #4042322160	@ 0xf0f0f0f0
3419888a:	d201      	bcs.n	34198890 <_txe_event_flags_create+0xf0>
                {

                    /* Invalid caller of this function, return appropriate error code.  */
                    status =  TX_CALLER_ERROR;
3419888c:	2313      	movs	r3, #19
3419888e:	647b      	str	r3, [r7, #68]	@ 0x44
            }
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
34198890:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34198892:	2b00      	cmp	r3, #0
34198894:	d104      	bne.n	341988a0 <_txe_event_flags_create+0x100>
    {

        /* Call actual event flags create function.  */
        status =  _tx_event_flags_create(group_ptr, name_ptr);
34198896:	68b9      	ldr	r1, [r7, #8]
34198898:	68f8      	ldr	r0, [r7, #12]
3419889a:	f7fc fc13 	bl	341950c4 <_tx_event_flags_create>
3419889e:	6478      	str	r0, [r7, #68]	@ 0x44
    }

    /* Return completion status.  */
    return(status);
341988a0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
}
341988a2:	4618      	mov	r0, r3
341988a4:	3748      	adds	r7, #72	@ 0x48
341988a6:	46bd      	mov	sp, r7
341988a8:	bd80      	pop	{r7, pc}
341988aa:	bf00      	nop
341988ac:	341c2e84 	.word	0x341c2e84
341988b0:	341c2dc4 	.word	0x341c2dc4
341988b4:	341c2dc8 	.word	0x341c2dc8
341988b8:	341c2dec 	.word	0x341c2dec
341988bc:	341c2f34 	.word	0x341c2f34
341988c0:	341c009c 	.word	0x341c009c

341988c4 <_txe_event_flags_get>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_event_flags_get(TX_EVENT_FLAGS_GROUP *group_ptr, ULONG requested_flags,
                    UINT get_option, ULONG *actual_flags_ptr, ULONG wait_option)
{
341988c4:	b580      	push	{r7, lr}
341988c6:	b08a      	sub	sp, #40	@ 0x28
341988c8:	af02      	add	r7, sp, #8
341988ca:	60f8      	str	r0, [r7, #12]
341988cc:	60b9      	str	r1, [r7, #8]
341988ce:	607a      	str	r2, [r7, #4]
341988d0:	603b      	str	r3, [r7, #0]
TX_THREAD       *current_thread;
#endif


    /* Default status to success.  */
    status =  TX_SUCCESS;
341988d2:	2300      	movs	r3, #0
341988d4:	61fb      	str	r3, [r7, #28]

    /* Check for an invalid event flag group pointer.  */
    if (group_ptr == TX_NULL)
341988d6:	68fb      	ldr	r3, [r7, #12]
341988d8:	2b00      	cmp	r3, #0
341988da:	d102      	bne.n	341988e2 <_txe_event_flags_get+0x1e>
    {

        /* Event flags group pointer is invalid, return appropriate error code.  */
        status =  TX_GROUP_ERROR;
341988dc:	2306      	movs	r3, #6
341988de:	61fb      	str	r3, [r7, #28]
341988e0:	e025      	b.n	3419892e <_txe_event_flags_get+0x6a>
    }

    /* Now check for invalid event group ID.  */
    else if (group_ptr -> tx_event_flags_group_id != TX_EVENT_FLAGS_ID)
341988e2:	68fb      	ldr	r3, [r7, #12]
341988e4:	681b      	ldr	r3, [r3, #0]
341988e6:	4a1e      	ldr	r2, [pc, #120]	@ (34198960 <_txe_event_flags_get+0x9c>)
341988e8:	4293      	cmp	r3, r2
341988ea:	d002      	beq.n	341988f2 <_txe_event_flags_get+0x2e>
    {

        /* Event flags group pointer is invalid, return appropriate error code.  */
        status =  TX_GROUP_ERROR;
341988ec:	2306      	movs	r3, #6
341988ee:	61fb      	str	r3, [r7, #28]
341988f0:	e01d      	b.n	3419892e <_txe_event_flags_get+0x6a>
    }

    /* Check for an invalid destination for actual flags.  */
    else if (actual_flags_ptr == TX_NULL)
341988f2:	683b      	ldr	r3, [r7, #0]
341988f4:	2b00      	cmp	r3, #0
341988f6:	d102      	bne.n	341988fe <_txe_event_flags_get+0x3a>
    {

        /* Null destination pointer, return appropriate error.  */
        status =  TX_PTR_ERROR;
341988f8:	2303      	movs	r3, #3
341988fa:	61fb      	str	r3, [r7, #28]
341988fc:	e017      	b.n	3419892e <_txe_event_flags_get+0x6a>
    else
    {

        /* Check for a wait option error.  Only threads are allowed any form of
           suspension.  */
        if (wait_option != TX_NO_WAIT)
341988fe:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34198900:	2b00      	cmp	r3, #0
34198902:	d014      	beq.n	3419892e <_txe_event_flags_get+0x6a>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
34198904:	f3ef 8305 	mrs	r3, IPSR
34198908:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
3419890a:	697a      	ldr	r2, [r7, #20]
        {

            /* Is the call from an ISR or Initialization?  */
            if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
3419890c:	4b15      	ldr	r3, [pc, #84]	@ (34198964 <_txe_event_flags_get+0xa0>)
3419890e:	681b      	ldr	r3, [r3, #0]
34198910:	4313      	orrs	r3, r2
34198912:	2b00      	cmp	r3, #0
34198914:	d002      	beq.n	3419891c <_txe_event_flags_get+0x58>
            {

                /* A non-thread is trying to suspend, return appropriate error code.  */
                status =  TX_WAIT_ERROR;
34198916:	2304      	movs	r3, #4
34198918:	61fb      	str	r3, [r7, #28]
3419891a:	e008      	b.n	3419892e <_txe_event_flags_get+0x6a>
#ifndef TX_TIMER_PROCESS_IN_ISR
            else
            {

                /* Pickup thread pointer.  */
                TX_THREAD_GET_CURRENT(current_thread)
3419891c:	4b12      	ldr	r3, [pc, #72]	@ (34198968 <_txe_event_flags_get+0xa4>)
3419891e:	681b      	ldr	r3, [r3, #0]
34198920:	61bb      	str	r3, [r7, #24]

                /* Is the current thread the timer thread?  */
                if (current_thread == &_tx_timer_thread)
34198922:	69bb      	ldr	r3, [r7, #24]
34198924:	4a11      	ldr	r2, [pc, #68]	@ (3419896c <_txe_event_flags_get+0xa8>)
34198926:	4293      	cmp	r3, r2
34198928:	d101      	bne.n	3419892e <_txe_event_flags_get+0x6a>
                {

                    /* A non-thread is trying to suspend, return appropriate error code.  */
                    status =  TX_WAIT_ERROR;
3419892a:	2304      	movs	r3, #4
3419892c:	61fb      	str	r3, [r7, #28]
#endif
        }
    }

    /* Is everything still okay?  */
    if (status == TX_SUCCESS)
3419892e:	69fb      	ldr	r3, [r7, #28]
34198930:	2b00      	cmp	r3, #0
34198932:	d104      	bne.n	3419893e <_txe_event_flags_get+0x7a>
    {

        /* Check for invalid get option.  */
        if (get_option > TX_AND_CLEAR)
34198934:	687b      	ldr	r3, [r7, #4]
34198936:	2b03      	cmp	r3, #3
34198938:	d901      	bls.n	3419893e <_txe_event_flags_get+0x7a>
        {

            /* Invalid get events option, return appropriate error.  */
            status =  TX_OPTION_ERROR;
3419893a:	2308      	movs	r3, #8
3419893c:	61fb      	str	r3, [r7, #28]
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
3419893e:	69fb      	ldr	r3, [r7, #28]
34198940:	2b00      	cmp	r3, #0
34198942:	d108      	bne.n	34198956 <_txe_event_flags_get+0x92>
    {

        /* Call actual event flags get function.  */
        status =  _tx_event_flags_get(group_ptr, requested_flags, get_option, actual_flags_ptr, wait_option);
34198944:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34198946:	9300      	str	r3, [sp, #0]
34198948:	683b      	ldr	r3, [r7, #0]
3419894a:	687a      	ldr	r2, [r7, #4]
3419894c:	68b9      	ldr	r1, [r7, #8]
3419894e:	68f8      	ldr	r0, [r7, #12]
34198950:	f7fc fc06 	bl	34195160 <_tx_event_flags_get>
34198954:	61f8      	str	r0, [r7, #28]
    }

    /* Return completion status.  */
    return(status);
34198956:	69fb      	ldr	r3, [r7, #28]
}
34198958:	4618      	mov	r0, r3
3419895a:	3720      	adds	r7, #32
3419895c:	46bd      	mov	sp, r7
3419895e:	bd80      	pop	{r7, pc}
34198960:	4456444e 	.word	0x4456444e
34198964:	341c009c 	.word	0x341c009c
34198968:	341c2dec 	.word	0x341c2dec
3419896c:	341c2f34 	.word	0x341c2f34

34198970 <_txe_event_flags_set>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_event_flags_set(TX_EVENT_FLAGS_GROUP *group_ptr, ULONG flags_to_set, UINT set_option)
{
34198970:	b580      	push	{r7, lr}
34198972:	b086      	sub	sp, #24
34198974:	af00      	add	r7, sp, #0
34198976:	60f8      	str	r0, [r7, #12]
34198978:	60b9      	str	r1, [r7, #8]
3419897a:	607a      	str	r2, [r7, #4]

UINT        status;


    /* Default status to success.  */
    status =  TX_SUCCESS;
3419897c:	2300      	movs	r3, #0
3419897e:	617b      	str	r3, [r7, #20]

    /* Check for an invalid event flag group pointer.  */
    if (group_ptr == TX_NULL)
34198980:	68fb      	ldr	r3, [r7, #12]
34198982:	2b00      	cmp	r3, #0
34198984:	d102      	bne.n	3419898c <_txe_event_flags_set+0x1c>
    {

        /* Event flags group pointer is invalid, return appropriate error code.  */
        status =  TX_GROUP_ERROR;
34198986:	2306      	movs	r3, #6
34198988:	617b      	str	r3, [r7, #20]
3419898a:	e00f      	b.n	341989ac <_txe_event_flags_set+0x3c>
    }

    /* Now check for invalid event flag group ID.  */
    else if (group_ptr -> tx_event_flags_group_id != TX_EVENT_FLAGS_ID)
3419898c:	68fb      	ldr	r3, [r7, #12]
3419898e:	681b      	ldr	r3, [r3, #0]
34198990:	4a0d      	ldr	r2, [pc, #52]	@ (341989c8 <_txe_event_flags_set+0x58>)
34198992:	4293      	cmp	r3, r2
34198994:	d002      	beq.n	3419899c <_txe_event_flags_set+0x2c>
    {

        /* Event flags group pointer is invalid, return appropriate error code.  */
        status =  TX_GROUP_ERROR;
34198996:	2306      	movs	r3, #6
34198998:	617b      	str	r3, [r7, #20]
3419899a:	e007      	b.n	341989ac <_txe_event_flags_set+0x3c>
    }
    else
    {

        /* Check for invalid set option.  */
        if (set_option != TX_AND)
3419899c:	687b      	ldr	r3, [r7, #4]
3419899e:	2b02      	cmp	r3, #2
341989a0:	d004      	beq.n	341989ac <_txe_event_flags_set+0x3c>
        {

            if (set_option != TX_OR)
341989a2:	687b      	ldr	r3, [r7, #4]
341989a4:	2b00      	cmp	r3, #0
341989a6:	d001      	beq.n	341989ac <_txe_event_flags_set+0x3c>
            {

                /* Invalid set events option, return appropriate error.  */
                status =  TX_OPTION_ERROR;
341989a8:	2308      	movs	r3, #8
341989aa:	617b      	str	r3, [r7, #20]
            }
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
341989ac:	697b      	ldr	r3, [r7, #20]
341989ae:	2b00      	cmp	r3, #0
341989b0:	d105      	bne.n	341989be <_txe_event_flags_set+0x4e>
    {

        /* Call actual event flags set function.  */
        status =  _tx_event_flags_set(group_ptr, flags_to_set, set_option);
341989b2:	687a      	ldr	r2, [r7, #4]
341989b4:	68b9      	ldr	r1, [r7, #8]
341989b6:	68f8      	ldr	r0, [r7, #12]
341989b8:	f7fc fcbc 	bl	34195334 <_tx_event_flags_set>
341989bc:	6178      	str	r0, [r7, #20]
    }

    /* Return completion status.  */
    return(status);
341989be:	697b      	ldr	r3, [r7, #20]
}
341989c0:	4618      	mov	r0, r3
341989c2:	3718      	adds	r7, #24
341989c4:	46bd      	mov	sp, r7
341989c6:	bd80      	pop	{r7, pc}
341989c8:	4456444e 	.word	0x4456444e

341989cc <_txe_mutex_create>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_mutex_create(TX_MUTEX *mutex_ptr, CHAR *name_ptr, UINT inherit, UINT mutex_control_block_size)
{
341989cc:	b580      	push	{r7, lr}
341989ce:	b092      	sub	sp, #72	@ 0x48
341989d0:	af00      	add	r7, sp, #0
341989d2:	60f8      	str	r0, [r7, #12]
341989d4:	60b9      	str	r1, [r7, #8]
341989d6:	607a      	str	r2, [r7, #4]
341989d8:	603b      	str	r3, [r7, #0]
TX_THREAD       *thread_ptr;
#endif


    /* Default status to success.  */
    status =  TX_SUCCESS;
341989da:	2300      	movs	r3, #0
341989dc:	647b      	str	r3, [r7, #68]	@ 0x44

    /* Check for an invalid mutex pointer.  */
    if (mutex_ptr == TX_NULL)
341989de:	68fb      	ldr	r3, [r7, #12]
341989e0:	2b00      	cmp	r3, #0
341989e2:	d102      	bne.n	341989ea <_txe_mutex_create+0x1e>
    {

        /* Mutex pointer is invalid, return appropriate error code.  */
        status =  TX_MUTEX_ERROR;
341989e4:	231c      	movs	r3, #28
341989e6:	647b      	str	r3, [r7, #68]	@ 0x44
341989e8:	e053      	b.n	34198a92 <_txe_mutex_create+0xc6>
    }

    /* Now check to make sure the control block is the correct size.  */
    else if (mutex_control_block_size != (sizeof(TX_MUTEX)))
341989ea:	683b      	ldr	r3, [r7, #0]
341989ec:	2b34      	cmp	r3, #52	@ 0x34
341989ee:	d002      	beq.n	341989f6 <_txe_mutex_create+0x2a>
    {

        /* Mutex pointer is invalid, return appropriate error code.  */
        status =  TX_MUTEX_ERROR;
341989f0:	231c      	movs	r3, #28
341989f2:	647b      	str	r3, [r7, #68]	@ 0x44
341989f4:	e04d      	b.n	34198a92 <_txe_mutex_create+0xc6>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
341989f6:	f3ef 8310 	mrs	r3, PRIMASK
341989fa:	62fb      	str	r3, [r7, #44]	@ 0x2c
    return(posture);
341989fc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
    int_posture = __get_interrupt_posture();
341989fe:	62bb      	str	r3, [r7, #40]	@ 0x28
    __asm__ volatile ("CPSID i" : : : "memory");
34198a00:	b672      	cpsid	i
    return(int_posture);
34198a02:	6abb      	ldr	r3, [r7, #40]	@ 0x28
    }
    else
    {

        /* Disable interrupts.  */
        TX_DISABLE
34198a04:	63bb      	str	r3, [r7, #56]	@ 0x38

        /* Increment the preempt disable flag.  */
        _tx_thread_preempt_disable++;
34198a06:	4b3a      	ldr	r3, [pc, #232]	@ (34198af0 <_txe_mutex_create+0x124>)
34198a08:	681b      	ldr	r3, [r3, #0]
34198a0a:	3301      	adds	r3, #1
34198a0c:	4a38      	ldr	r2, [pc, #224]	@ (34198af0 <_txe_mutex_create+0x124>)
34198a0e:	6013      	str	r3, [r2, #0]
34198a10:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34198a12:	633b      	str	r3, [r7, #48]	@ 0x30
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34198a14:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34198a16:	f383 8810 	msr	PRIMASK, r3
}
34198a1a:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Next see if it is already in the created list.  */
        next_mutex =   _tx_mutex_created_ptr;
34198a1c:	4b35      	ldr	r3, [pc, #212]	@ (34198af4 <_txe_mutex_create+0x128>)
34198a1e:	681b      	ldr	r3, [r3, #0]
34198a20:	63fb      	str	r3, [r7, #60]	@ 0x3c
        for (i = ((ULONG) 0); i < _tx_mutex_created_count; i++)
34198a22:	2300      	movs	r3, #0
34198a24:	643b      	str	r3, [r7, #64]	@ 0x40
34198a26:	e009      	b.n	34198a3c <_txe_mutex_create+0x70>
        {

            /* Determine if this mutex matches the mutex in the list.  */
            if (mutex_ptr == next_mutex)
34198a28:	68fa      	ldr	r2, [r7, #12]
34198a2a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34198a2c:	429a      	cmp	r2, r3
34198a2e:	d00b      	beq.n	34198a48 <_txe_mutex_create+0x7c>
            }
            else
            {

                /* Move to the next mutex.  */
                next_mutex =  next_mutex -> tx_mutex_created_next;
34198a30:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34198a32:	6a1b      	ldr	r3, [r3, #32]
34198a34:	63fb      	str	r3, [r7, #60]	@ 0x3c
        for (i = ((ULONG) 0); i < _tx_mutex_created_count; i++)
34198a36:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34198a38:	3301      	adds	r3, #1
34198a3a:	643b      	str	r3, [r7, #64]	@ 0x40
34198a3c:	4b2e      	ldr	r3, [pc, #184]	@ (34198af8 <_txe_mutex_create+0x12c>)
34198a3e:	681b      	ldr	r3, [r3, #0]
34198a40:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
34198a42:	429a      	cmp	r2, r3
34198a44:	d3f0      	bcc.n	34198a28 <_txe_mutex_create+0x5c>
34198a46:	e000      	b.n	34198a4a <_txe_mutex_create+0x7e>
                break;
34198a48:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34198a4a:	f3ef 8310 	mrs	r3, PRIMASK
34198a4e:	623b      	str	r3, [r7, #32]
    return(posture);
34198a50:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
34198a52:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
34198a54:	b672      	cpsid	i
    return(int_posture);
34198a56:	69fb      	ldr	r3, [r7, #28]
            }
        }

        /* Disable interrupts.  */
        TX_DISABLE
34198a58:	63bb      	str	r3, [r7, #56]	@ 0x38

        /* Decrement the preempt disable flag.  */
        _tx_thread_preempt_disable--;
34198a5a:	4b25      	ldr	r3, [pc, #148]	@ (34198af0 <_txe_mutex_create+0x124>)
34198a5c:	681b      	ldr	r3, [r3, #0]
34198a5e:	3b01      	subs	r3, #1
34198a60:	4a23      	ldr	r2, [pc, #140]	@ (34198af0 <_txe_mutex_create+0x124>)
34198a62:	6013      	str	r3, [r2, #0]
34198a64:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34198a66:	627b      	str	r3, [r7, #36]	@ 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34198a68:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34198a6a:	f383 8810 	msr	PRIMASK, r3
}
34198a6e:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Check for preemption.  */
        _tx_thread_system_preempt_check();
34198a70:	f7fe fece 	bl	34197810 <_tx_thread_system_preempt_check>

        /* At this point, check to see if there is a duplicate mutex.  */
        if (mutex_ptr == next_mutex)
34198a74:	68fa      	ldr	r2, [r7, #12]
34198a76:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34198a78:	429a      	cmp	r2, r3
34198a7a:	d102      	bne.n	34198a82 <_txe_mutex_create+0xb6>
        {

            /* Mutex is already created, return appropriate error code.  */
            status =  TX_MUTEX_ERROR;
34198a7c:	231c      	movs	r3, #28
34198a7e:	647b      	str	r3, [r7, #68]	@ 0x44
34198a80:	e007      	b.n	34198a92 <_txe_mutex_create+0xc6>
        }
        else
        {

            /* Check for a valid inherit option.  */
            if (inherit != TX_INHERIT)
34198a82:	687b      	ldr	r3, [r7, #4]
34198a84:	2b01      	cmp	r3, #1
34198a86:	d004      	beq.n	34198a92 <_txe_mutex_create+0xc6>
            {

                if (inherit != TX_NO_INHERIT)
34198a88:	687b      	ldr	r3, [r7, #4]
34198a8a:	2b00      	cmp	r3, #0
34198a8c:	d001      	beq.n	34198a92 <_txe_mutex_create+0xc6>
                {

                    /* Inherit option is illegal.  */
                    status =  TX_INHERIT_ERROR;
34198a8e:	231f      	movs	r3, #31
34198a90:	647b      	str	r3, [r7, #68]	@ 0x44
            }
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
34198a92:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34198a94:	2b00      	cmp	r3, #0
34198a96:	d11d      	bne.n	34198ad4 <_txe_mutex_create+0x108>
    {

#ifndef TX_TIMER_PROCESS_IN_ISR

        /* Pickup thread pointer.  */
        TX_THREAD_GET_CURRENT(thread_ptr)
34198a98:	4b18      	ldr	r3, [pc, #96]	@ (34198afc <_txe_mutex_create+0x130>)
34198a9a:	681b      	ldr	r3, [r3, #0]
34198a9c:	637b      	str	r3, [r7, #52]	@ 0x34

        /* Check for invalid caller of this function.  First check for a calling thread.  */
        if (thread_ptr == &_tx_timer_thread)
34198a9e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34198aa0:	4a17      	ldr	r2, [pc, #92]	@ (34198b00 <_txe_mutex_create+0x134>)
34198aa2:	4293      	cmp	r3, r2
34198aa4:	d101      	bne.n	34198aaa <_txe_mutex_create+0xde>
        {

            /* Invalid caller of this function, return appropriate error code.  */
            status =  TX_CALLER_ERROR;
34198aa6:	2313      	movs	r3, #19
34198aa8:	647b      	str	r3, [r7, #68]	@ 0x44
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
34198aaa:	f3ef 8305 	mrs	r3, IPSR
34198aae:	61bb      	str	r3, [r7, #24]
    return(ipsr_value);
34198ab0:	69ba      	ldr	r2, [r7, #24]
        }
#endif

        /* Check for interrupt call.  */
        if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
34198ab2:	4b14      	ldr	r3, [pc, #80]	@ (34198b04 <_txe_mutex_create+0x138>)
34198ab4:	681b      	ldr	r3, [r3, #0]
34198ab6:	4313      	orrs	r3, r2
34198ab8:	2b00      	cmp	r3, #0
34198aba:	d00b      	beq.n	34198ad4 <_txe_mutex_create+0x108>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
34198abc:	f3ef 8305 	mrs	r3, IPSR
34198ac0:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
34198ac2:	697a      	ldr	r2, [r7, #20]
        {

            /* Now, make sure the call is from an interrupt and not initialization.  */
            if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
34198ac4:	4b0f      	ldr	r3, [pc, #60]	@ (34198b04 <_txe_mutex_create+0x138>)
34198ac6:	681b      	ldr	r3, [r3, #0]
34198ac8:	4313      	orrs	r3, r2
34198aca:	f1b3 3ff0 	cmp.w	r3, #4042322160	@ 0xf0f0f0f0
34198ace:	d201      	bcs.n	34198ad4 <_txe_mutex_create+0x108>
            {

                /* Invalid caller of this function, return appropriate error code.  */
                status =  TX_CALLER_ERROR;
34198ad0:	2313      	movs	r3, #19
34198ad2:	647b      	str	r3, [r7, #68]	@ 0x44
            }
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
34198ad4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34198ad6:	2b00      	cmp	r3, #0
34198ad8:	d105      	bne.n	34198ae6 <_txe_mutex_create+0x11a>
    {

        /* Call actual mutex create function.  */
        status =  _tx_mutex_create(mutex_ptr, name_ptr, inherit);
34198ada:	687a      	ldr	r2, [r7, #4]
34198adc:	68b9      	ldr	r1, [r7, #8]
34198ade:	68f8      	ldr	r0, [r7, #12]
34198ae0:	f7fc ff66 	bl	341959b0 <_tx_mutex_create>
34198ae4:	6478      	str	r0, [r7, #68]	@ 0x44
    }

    /* Return completion status.  */
    return(status);
34198ae6:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
}
34198ae8:	4618      	mov	r0, r3
34198aea:	3748      	adds	r7, #72	@ 0x48
34198aec:	46bd      	mov	sp, r7
34198aee:	bd80      	pop	{r7, pc}
34198af0:	341c2e84 	.word	0x341c2e84
34198af4:	341c2dcc 	.word	0x341c2dcc
34198af8:	341c2dd0 	.word	0x341c2dd0
34198afc:	341c2dec 	.word	0x341c2dec
34198b00:	341c2f34 	.word	0x341c2f34
34198b04:	341c009c 	.word	0x341c009c

34198b08 <_txe_mutex_get>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_mutex_get(TX_MUTEX *mutex_ptr, ULONG wait_option)
{
34198b08:	b580      	push	{r7, lr}
34198b0a:	b088      	sub	sp, #32
34198b0c:	af00      	add	r7, sp, #0
34198b0e:	6078      	str	r0, [r7, #4]
34198b10:	6039      	str	r1, [r7, #0]
TX_THREAD       *current_thread;
#endif


    /* Default status to success.  */
    status =  TX_SUCCESS;
34198b12:	2300      	movs	r3, #0
34198b14:	61fb      	str	r3, [r7, #28]

    /* Check for an invalid mutex pointer.  */
    if (mutex_ptr == TX_NULL)
34198b16:	687b      	ldr	r3, [r7, #4]
34198b18:	2b00      	cmp	r3, #0
34198b1a:	d102      	bne.n	34198b22 <_txe_mutex_get+0x1a>
    {

        /* Mutex pointer is invalid, return appropriate error code.  */
        status =  TX_MUTEX_ERROR;
34198b1c:	231c      	movs	r3, #28
34198b1e:	61fb      	str	r3, [r7, #28]
34198b20:	e01f      	b.n	34198b62 <_txe_mutex_get+0x5a>
    }

    /* Now check for a valid mutex ID.  */
    else if (mutex_ptr -> tx_mutex_id != TX_MUTEX_ID)
34198b22:	687b      	ldr	r3, [r7, #4]
34198b24:	681b      	ldr	r3, [r3, #0]
34198b26:	4a21      	ldr	r2, [pc, #132]	@ (34198bac <_txe_mutex_get+0xa4>)
34198b28:	4293      	cmp	r3, r2
34198b2a:	d002      	beq.n	34198b32 <_txe_mutex_get+0x2a>
    {

        /* Mutex pointer is invalid, return appropriate error code.  */
        status =  TX_MUTEX_ERROR;
34198b2c:	231c      	movs	r3, #28
34198b2e:	61fb      	str	r3, [r7, #28]
34198b30:	e017      	b.n	34198b62 <_txe_mutex_get+0x5a>
    else
    {

        /* Check for a wait option error.  Only threads are allowed any form of
           suspension.  */
        if (wait_option != TX_NO_WAIT)
34198b32:	683b      	ldr	r3, [r7, #0]
34198b34:	2b00      	cmp	r3, #0
34198b36:	d014      	beq.n	34198b62 <_txe_mutex_get+0x5a>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
34198b38:	f3ef 8305 	mrs	r3, IPSR
34198b3c:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
34198b3e:	697a      	ldr	r2, [r7, #20]
        {

            /* Is the call from an ISR or Initialization?  */
            if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
34198b40:	4b1b      	ldr	r3, [pc, #108]	@ (34198bb0 <_txe_mutex_get+0xa8>)
34198b42:	681b      	ldr	r3, [r3, #0]
34198b44:	4313      	orrs	r3, r2
34198b46:	2b00      	cmp	r3, #0
34198b48:	d002      	beq.n	34198b50 <_txe_mutex_get+0x48>
            {

                /* A non-thread is trying to suspend, return appropriate error code.  */
                status =  TX_WAIT_ERROR;
34198b4a:	2304      	movs	r3, #4
34198b4c:	61fb      	str	r3, [r7, #28]
34198b4e:	e008      	b.n	34198b62 <_txe_mutex_get+0x5a>
#ifndef TX_TIMER_PROCESS_IN_ISR
            else
            {

                /* Pickup thread pointer.  */
                TX_THREAD_GET_CURRENT(current_thread)
34198b50:	4b18      	ldr	r3, [pc, #96]	@ (34198bb4 <_txe_mutex_get+0xac>)
34198b52:	681b      	ldr	r3, [r3, #0]
34198b54:	61bb      	str	r3, [r7, #24]

                /* Is the current thread the timer thread?  */
                if (current_thread == &_tx_timer_thread)
34198b56:	69bb      	ldr	r3, [r7, #24]
34198b58:	4a17      	ldr	r2, [pc, #92]	@ (34198bb8 <_txe_mutex_get+0xb0>)
34198b5a:	4293      	cmp	r3, r2
34198b5c:	d101      	bne.n	34198b62 <_txe_mutex_get+0x5a>
                {

                    /* A non-thread is trying to suspend, return appropriate error code.  */
                    status =  TX_WAIT_ERROR;
34198b5e:	2304      	movs	r3, #4
34198b60:	61fb      	str	r3, [r7, #28]
#endif
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
34198b62:	69fb      	ldr	r3, [r7, #28]
34198b64:	2b00      	cmp	r3, #0
34198b66:	d114      	bne.n	34198b92 <_txe_mutex_get+0x8a>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
34198b68:	f3ef 8305 	mrs	r3, IPSR
34198b6c:	613b      	str	r3, [r7, #16]
    return(ipsr_value);
34198b6e:	693a      	ldr	r2, [r7, #16]
    {

        /* Check for interrupt call.  */
        if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
34198b70:	4b0f      	ldr	r3, [pc, #60]	@ (34198bb0 <_txe_mutex_get+0xa8>)
34198b72:	681b      	ldr	r3, [r3, #0]
34198b74:	4313      	orrs	r3, r2
34198b76:	2b00      	cmp	r3, #0
34198b78:	d00b      	beq.n	34198b92 <_txe_mutex_get+0x8a>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
34198b7a:	f3ef 8305 	mrs	r3, IPSR
34198b7e:	60fb      	str	r3, [r7, #12]
    return(ipsr_value);
34198b80:	68fa      	ldr	r2, [r7, #12]
        {

            /* Now, make sure the call is from an interrupt and not initialization.  */
            if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
34198b82:	4b0b      	ldr	r3, [pc, #44]	@ (34198bb0 <_txe_mutex_get+0xa8>)
34198b84:	681b      	ldr	r3, [r3, #0]
34198b86:	4313      	orrs	r3, r2
34198b88:	f1b3 3ff0 	cmp.w	r3, #4042322160	@ 0xf0f0f0f0
34198b8c:	d201      	bcs.n	34198b92 <_txe_mutex_get+0x8a>
            {

                /* Yes, invalid caller of this function, return appropriate error code.  */
                status =  TX_CALLER_ERROR;
34198b8e:	2313      	movs	r3, #19
34198b90:	61fb      	str	r3, [r7, #28]
            }
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
34198b92:	69fb      	ldr	r3, [r7, #28]
34198b94:	2b00      	cmp	r3, #0
34198b96:	d104      	bne.n	34198ba2 <_txe_mutex_get+0x9a>
    {

        /* Call actual get mutex function.  */
        status =  _tx_mutex_get(mutex_ptr, wait_option);
34198b98:	6839      	ldr	r1, [r7, #0]
34198b9a:	6878      	ldr	r0, [r7, #4]
34198b9c:	f7fc ff62 	bl	34195a64 <_tx_mutex_get>
34198ba0:	61f8      	str	r0, [r7, #28]
    }

    /* Return completion status.  */
    return(status);
34198ba2:	69fb      	ldr	r3, [r7, #28]
}
34198ba4:	4618      	mov	r0, r3
34198ba6:	3720      	adds	r7, #32
34198ba8:	46bd      	mov	sp, r7
34198baa:	bd80      	pop	{r7, pc}
34198bac:	4d555445 	.word	0x4d555445
34198bb0:	341c009c 	.word	0x341c009c
34198bb4:	341c2dec 	.word	0x341c2dec
34198bb8:	341c2f34 	.word	0x341c2f34

34198bbc <_txe_mutex_put>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_mutex_put(TX_MUTEX *mutex_ptr)
{
34198bbc:	b580      	push	{r7, lr}
34198bbe:	b086      	sub	sp, #24
34198bc0:	af00      	add	r7, sp, #0
34198bc2:	6078      	str	r0, [r7, #4]

UINT            status;


    /* Default status to success.  */
    status =  TX_SUCCESS;
34198bc4:	2300      	movs	r3, #0
34198bc6:	617b      	str	r3, [r7, #20]

    /* Check for an invalid mutex pointer.  */
    if (mutex_ptr == TX_NULL)
34198bc8:	687b      	ldr	r3, [r7, #4]
34198bca:	2b00      	cmp	r3, #0
34198bcc:	d102      	bne.n	34198bd4 <_txe_mutex_put+0x18>
    {

        /* Mutex pointer is invalid, return appropriate error code.  */
        status =  TX_MUTEX_ERROR;
34198bce:	231c      	movs	r3, #28
34198bd0:	617b      	str	r3, [r7, #20]
34198bd2:	e01c      	b.n	34198c0e <_txe_mutex_put+0x52>
    }

    /* Now check for invalid mutex ID.  */
    else if (mutex_ptr -> tx_mutex_id != TX_MUTEX_ID)
34198bd4:	687b      	ldr	r3, [r7, #4]
34198bd6:	681b      	ldr	r3, [r3, #0]
34198bd8:	4a13      	ldr	r2, [pc, #76]	@ (34198c28 <_txe_mutex_put+0x6c>)
34198bda:	4293      	cmp	r3, r2
34198bdc:	d002      	beq.n	34198be4 <_txe_mutex_put+0x28>
    {

        /* Mutex pointer is invalid, return appropriate error code.  */
        status =  TX_MUTEX_ERROR;
34198bde:	231c      	movs	r3, #28
34198be0:	617b      	str	r3, [r7, #20]
34198be2:	e014      	b.n	34198c0e <_txe_mutex_put+0x52>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
34198be4:	f3ef 8305 	mrs	r3, IPSR
34198be8:	613b      	str	r3, [r7, #16]
    return(ipsr_value);
34198bea:	693a      	ldr	r2, [r7, #16]
    }
    else
    {

        /* Check for interrupt call.  */
        if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
34198bec:	4b0f      	ldr	r3, [pc, #60]	@ (34198c2c <_txe_mutex_put+0x70>)
34198bee:	681b      	ldr	r3, [r3, #0]
34198bf0:	4313      	orrs	r3, r2
34198bf2:	2b00      	cmp	r3, #0
34198bf4:	d00b      	beq.n	34198c0e <_txe_mutex_put+0x52>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
34198bf6:	f3ef 8305 	mrs	r3, IPSR
34198bfa:	60fb      	str	r3, [r7, #12]
    return(ipsr_value);
34198bfc:	68fa      	ldr	r2, [r7, #12]
        {

            /* Now, make sure the call is from an interrupt and not initialization.  */
            if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
34198bfe:	4b0b      	ldr	r3, [pc, #44]	@ (34198c2c <_txe_mutex_put+0x70>)
34198c00:	681b      	ldr	r3, [r3, #0]
34198c02:	4313      	orrs	r3, r2
34198c04:	f1b3 3ff0 	cmp.w	r3, #4042322160	@ 0xf0f0f0f0
34198c08:	d201      	bcs.n	34198c0e <_txe_mutex_put+0x52>
            {

                /* Invalid caller of this function, return appropriate error code.  */
                status =  TX_CALLER_ERROR;
34198c0a:	2313      	movs	r3, #19
34198c0c:	617b      	str	r3, [r7, #20]
            }
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
34198c0e:	697b      	ldr	r3, [r7, #20]
34198c10:	2b00      	cmp	r3, #0
34198c12:	d103      	bne.n	34198c1c <_txe_mutex_put+0x60>
    {

        /* Call actual put mutex function.  */
        status =  _tx_mutex_put(mutex_ptr);
34198c14:	6878      	ldr	r0, [r7, #4]
34198c16:	f7fd f99d 	bl	34195f54 <_tx_mutex_put>
34198c1a:	6178      	str	r0, [r7, #20]
    }

    /* Return completion status.  */
    return(status);
34198c1c:	697b      	ldr	r3, [r7, #20]
}
34198c1e:	4618      	mov	r0, r3
34198c20:	3718      	adds	r7, #24
34198c22:	46bd      	mov	sp, r7
34198c24:	bd80      	pop	{r7, pc}
34198c26:	bf00      	nop
34198c28:	4d555445 	.word	0x4d555445
34198c2c:	341c009c 	.word	0x341c009c

34198c30 <_txe_queue_create>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_queue_create(TX_QUEUE *queue_ptr, CHAR *name_ptr, UINT message_size,
                        VOID *queue_start, ULONG queue_size, UINT queue_control_block_size)
{
34198c30:	b580      	push	{r7, lr}
34198c32:	b094      	sub	sp, #80	@ 0x50
34198c34:	af02      	add	r7, sp, #8
34198c36:	60f8      	str	r0, [r7, #12]
34198c38:	60b9      	str	r1, [r7, #8]
34198c3a:	607a      	str	r2, [r7, #4]
34198c3c:	603b      	str	r3, [r7, #0]
TX_THREAD       *thread_ptr;
#endif


    /* Default status to success.  */
    status =  TX_SUCCESS;
34198c3e:	2300      	movs	r3, #0
34198c40:	647b      	str	r3, [r7, #68]	@ 0x44

    /* Check for an invalid queue pointer.  */
    if (queue_ptr == TX_NULL)
34198c42:	68fb      	ldr	r3, [r7, #12]
34198c44:	2b00      	cmp	r3, #0
34198c46:	d102      	bne.n	34198c4e <_txe_queue_create+0x1e>
    {

        /* Queue pointer is invalid, return appropriate error code.  */
        status =  TX_QUEUE_ERROR;
34198c48:	2309      	movs	r3, #9
34198c4a:	647b      	str	r3, [r7, #68]	@ 0x44
34198c4c:	e083      	b.n	34198d56 <_txe_queue_create+0x126>
    }

    /* Now check for a valid control block size.  */
    else if (queue_control_block_size != (sizeof(TX_QUEUE)))
34198c4e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34198c50:	2b38      	cmp	r3, #56	@ 0x38
34198c52:	d002      	beq.n	34198c5a <_txe_queue_create+0x2a>
    {

        /* Queue pointer is invalid, return appropriate error code.  */
        status =  TX_QUEUE_ERROR;
34198c54:	2309      	movs	r3, #9
34198c56:	647b      	str	r3, [r7, #68]	@ 0x44
34198c58:	e07d      	b.n	34198d56 <_txe_queue_create+0x126>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34198c5a:	f3ef 8310 	mrs	r3, PRIMASK
34198c5e:	62fb      	str	r3, [r7, #44]	@ 0x2c
    return(posture);
34198c60:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
    int_posture = __get_interrupt_posture();
34198c62:	62bb      	str	r3, [r7, #40]	@ 0x28
    __asm__ volatile ("CPSID i" : : : "memory");
34198c64:	b672      	cpsid	i
    return(int_posture);
34198c66:	6abb      	ldr	r3, [r7, #40]	@ 0x28
    }
    else
    {

        /* Disable interrupts.  */
        TX_DISABLE
34198c68:	63bb      	str	r3, [r7, #56]	@ 0x38

        /* Increment the preempt disable flag.  */
        _tx_thread_preempt_disable++;
34198c6a:	4b43      	ldr	r3, [pc, #268]	@ (34198d78 <_txe_queue_create+0x148>)
34198c6c:	681b      	ldr	r3, [r3, #0]
34198c6e:	3301      	adds	r3, #1
34198c70:	4a41      	ldr	r2, [pc, #260]	@ (34198d78 <_txe_queue_create+0x148>)
34198c72:	6013      	str	r3, [r2, #0]
34198c74:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34198c76:	633b      	str	r3, [r7, #48]	@ 0x30
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34198c78:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34198c7a:	f383 8810 	msr	PRIMASK, r3
}
34198c7e:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Next see if it is already in the created list.  */
        next_queue =   _tx_queue_created_ptr;
34198c80:	4b3e      	ldr	r3, [pc, #248]	@ (34198d7c <_txe_queue_create+0x14c>)
34198c82:	681b      	ldr	r3, [r3, #0]
34198c84:	63fb      	str	r3, [r7, #60]	@ 0x3c
        for (i = ((ULONG) 0); i < _tx_queue_created_count; i++)
34198c86:	2300      	movs	r3, #0
34198c88:	643b      	str	r3, [r7, #64]	@ 0x40
34198c8a:	e009      	b.n	34198ca0 <_txe_queue_create+0x70>
        {

            /* Determine if this queue matches the queue in the list.  */
            if (queue_ptr == next_queue)
34198c8c:	68fa      	ldr	r2, [r7, #12]
34198c8e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34198c90:	429a      	cmp	r2, r3
34198c92:	d00b      	beq.n	34198cac <_txe_queue_create+0x7c>
            }
            else
            {

                /* Move to the next queue.  */
                next_queue =  next_queue -> tx_queue_created_next;
34198c94:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34198c96:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34198c98:	63fb      	str	r3, [r7, #60]	@ 0x3c
        for (i = ((ULONG) 0); i < _tx_queue_created_count; i++)
34198c9a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34198c9c:	3301      	adds	r3, #1
34198c9e:	643b      	str	r3, [r7, #64]	@ 0x40
34198ca0:	4b37      	ldr	r3, [pc, #220]	@ (34198d80 <_txe_queue_create+0x150>)
34198ca2:	681b      	ldr	r3, [r3, #0]
34198ca4:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
34198ca6:	429a      	cmp	r2, r3
34198ca8:	d3f0      	bcc.n	34198c8c <_txe_queue_create+0x5c>
34198caa:	e000      	b.n	34198cae <_txe_queue_create+0x7e>
                break;
34198cac:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34198cae:	f3ef 8310 	mrs	r3, PRIMASK
34198cb2:	623b      	str	r3, [r7, #32]
    return(posture);
34198cb4:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
34198cb6:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
34198cb8:	b672      	cpsid	i
    return(int_posture);
34198cba:	69fb      	ldr	r3, [r7, #28]
            }
        }

        /* Disable interrupts.  */
        TX_DISABLE
34198cbc:	63bb      	str	r3, [r7, #56]	@ 0x38

        /* Decrement the preempt disable flag.  */
        _tx_thread_preempt_disable--;
34198cbe:	4b2e      	ldr	r3, [pc, #184]	@ (34198d78 <_txe_queue_create+0x148>)
34198cc0:	681b      	ldr	r3, [r3, #0]
34198cc2:	3b01      	subs	r3, #1
34198cc4:	4a2c      	ldr	r2, [pc, #176]	@ (34198d78 <_txe_queue_create+0x148>)
34198cc6:	6013      	str	r3, [r2, #0]
34198cc8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34198cca:	627b      	str	r3, [r7, #36]	@ 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34198ccc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34198cce:	f383 8810 	msr	PRIMASK, r3
}
34198cd2:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Check for preemption.  */
        _tx_thread_system_preempt_check();
34198cd4:	f7fe fd9c 	bl	34197810 <_tx_thread_system_preempt_check>

        /* At this point, check to see if there is a duplicate queue.  */
        if (queue_ptr == next_queue)
34198cd8:	68fa      	ldr	r2, [r7, #12]
34198cda:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34198cdc:	429a      	cmp	r2, r3
34198cde:	d102      	bne.n	34198ce6 <_txe_queue_create+0xb6>
        {

            /* Queue is already created, return appropriate error code.  */
            status =  TX_QUEUE_ERROR;
34198ce0:	2309      	movs	r3, #9
34198ce2:	647b      	str	r3, [r7, #68]	@ 0x44
34198ce4:	e037      	b.n	34198d56 <_txe_queue_create+0x126>
        }

        /* Check the starting address of the queue.  */
        else if (queue_start == TX_NULL)
34198ce6:	683b      	ldr	r3, [r7, #0]
34198ce8:	2b00      	cmp	r3, #0
34198cea:	d102      	bne.n	34198cf2 <_txe_queue_create+0xc2>
        {

            /* Invalid starting address of queue.  */
            status =  TX_PTR_ERROR;
34198cec:	2303      	movs	r3, #3
34198cee:	647b      	str	r3, [r7, #68]	@ 0x44
34198cf0:	e031      	b.n	34198d56 <_txe_queue_create+0x126>
        }

        /* Check for an invalid message size - less than 1.  */
        else if (message_size < TX_1_ULONG)
34198cf2:	687b      	ldr	r3, [r7, #4]
34198cf4:	2b00      	cmp	r3, #0
34198cf6:	d102      	bne.n	34198cfe <_txe_queue_create+0xce>
        {

            /* Invalid message size specified.  */
            status =  TX_SIZE_ERROR;
34198cf8:	2305      	movs	r3, #5
34198cfa:	647b      	str	r3, [r7, #68]	@ 0x44
34198cfc:	e02b      	b.n	34198d56 <_txe_queue_create+0x126>
        }

        /* Check for an invalid message size - greater than 16.  */
        else if (message_size > TX_16_ULONG)
34198cfe:	687b      	ldr	r3, [r7, #4]
34198d00:	2b10      	cmp	r3, #16
34198d02:	d902      	bls.n	34198d0a <_txe_queue_create+0xda>
        {

            /* Invalid message size specified.  */
            status =  TX_SIZE_ERROR;
34198d04:	2305      	movs	r3, #5
34198d06:	647b      	str	r3, [r7, #68]	@ 0x44
34198d08:	e025      	b.n	34198d56 <_txe_queue_create+0x126>
        }

        /* Check on the queue size.  */
        else if ((queue_size/(sizeof(ULONG))) < message_size)
34198d0a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
34198d0c:	089b      	lsrs	r3, r3, #2
34198d0e:	687a      	ldr	r2, [r7, #4]
34198d10:	429a      	cmp	r2, r3
34198d12:	d902      	bls.n	34198d1a <_txe_queue_create+0xea>
        {

            /* Invalid queue size specified.  */
            status =  TX_SIZE_ERROR;
34198d14:	2305      	movs	r3, #5
34198d16:	647b      	str	r3, [r7, #68]	@ 0x44
34198d18:	e01d      	b.n	34198d56 <_txe_queue_create+0x126>
        {

#ifndef TX_TIMER_PROCESS_IN_ISR

            /* Pickup thread pointer.  */
            TX_THREAD_GET_CURRENT(thread_ptr)
34198d1a:	4b1a      	ldr	r3, [pc, #104]	@ (34198d84 <_txe_queue_create+0x154>)
34198d1c:	681b      	ldr	r3, [r3, #0]
34198d1e:	637b      	str	r3, [r7, #52]	@ 0x34

            /* Check for invalid caller of this function.  First check for a calling thread.  */
            if (thread_ptr == &_tx_timer_thread)
34198d20:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34198d22:	4a19      	ldr	r2, [pc, #100]	@ (34198d88 <_txe_queue_create+0x158>)
34198d24:	4293      	cmp	r3, r2
34198d26:	d101      	bne.n	34198d2c <_txe_queue_create+0xfc>
            {

                /* Invalid caller of this function, return appropriate error code.  */
                status =  TX_CALLER_ERROR;
34198d28:	2313      	movs	r3, #19
34198d2a:	647b      	str	r3, [r7, #68]	@ 0x44
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
34198d2c:	f3ef 8305 	mrs	r3, IPSR
34198d30:	61bb      	str	r3, [r7, #24]
    return(ipsr_value);
34198d32:	69ba      	ldr	r2, [r7, #24]
            }
#endif

            /* Check for interrupt call.  */
            if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
34198d34:	4b15      	ldr	r3, [pc, #84]	@ (34198d8c <_txe_queue_create+0x15c>)
34198d36:	681b      	ldr	r3, [r3, #0]
34198d38:	4313      	orrs	r3, r2
34198d3a:	2b00      	cmp	r3, #0
34198d3c:	d00b      	beq.n	34198d56 <_txe_queue_create+0x126>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
34198d3e:	f3ef 8305 	mrs	r3, IPSR
34198d42:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
34198d44:	697a      	ldr	r2, [r7, #20]
            {

                /* Now, make sure the call is from an interrupt and not initialization.  */
                if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
34198d46:	4b11      	ldr	r3, [pc, #68]	@ (34198d8c <_txe_queue_create+0x15c>)
34198d48:	681b      	ldr	r3, [r3, #0]
34198d4a:	4313      	orrs	r3, r2
34198d4c:	f1b3 3ff0 	cmp.w	r3, #4042322160	@ 0xf0f0f0f0
34198d50:	d201      	bcs.n	34198d56 <_txe_queue_create+0x126>
                {

                    /* Invalid caller of this function, return appropriate error code.  */
                    status =  TX_CALLER_ERROR;
34198d52:	2313      	movs	r3, #19
34198d54:	647b      	str	r3, [r7, #68]	@ 0x44
            }
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
34198d56:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34198d58:	2b00      	cmp	r3, #0
34198d5a:	d108      	bne.n	34198d6e <_txe_queue_create+0x13e>
    {

        /* Call actual queue create function.  */
        status =  _tx_queue_create(queue_ptr, name_ptr, message_size, queue_start, queue_size);
34198d5c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
34198d5e:	9300      	str	r3, [sp, #0]
34198d60:	683b      	ldr	r3, [r7, #0]
34198d62:	687a      	ldr	r2, [r7, #4]
34198d64:	68b9      	ldr	r1, [r7, #8]
34198d66:	68f8      	ldr	r0, [r7, #12]
34198d68:	f7fd fb9e 	bl	341964a8 <_tx_queue_create>
34198d6c:	6478      	str	r0, [r7, #68]	@ 0x44
    }

    /* Return completion status.  */
    return(status);
34198d6e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
}
34198d70:	4618      	mov	r0, r3
34198d72:	3748      	adds	r7, #72	@ 0x48
34198d74:	46bd      	mov	sp, r7
34198d76:	bd80      	pop	{r7, pc}
34198d78:	341c2e84 	.word	0x341c2e84
34198d7c:	341c2dbc 	.word	0x341c2dbc
34198d80:	341c2dc0 	.word	0x341c2dc0
34198d84:	341c2dec 	.word	0x341c2dec
34198d88:	341c2f34 	.word	0x341c2f34
34198d8c:	341c009c 	.word	0x341c009c

34198d90 <_txe_queue_receive>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_queue_receive(TX_QUEUE *queue_ptr, VOID *destination_ptr, ULONG wait_option)
{
34198d90:	b580      	push	{r7, lr}
34198d92:	b088      	sub	sp, #32
34198d94:	af00      	add	r7, sp, #0
34198d96:	60f8      	str	r0, [r7, #12]
34198d98:	60b9      	str	r1, [r7, #8]
34198d9a:	607a      	str	r2, [r7, #4]
TX_THREAD   *current_thread;
#endif


    /* Default status to success.  */
    status =  TX_SUCCESS;
34198d9c:	2300      	movs	r3, #0
34198d9e:	61fb      	str	r3, [r7, #28]

    /* Check for an invalid queue pointer.  */
    if (queue_ptr == TX_NULL)
34198da0:	68fb      	ldr	r3, [r7, #12]
34198da2:	2b00      	cmp	r3, #0
34198da4:	d102      	bne.n	34198dac <_txe_queue_receive+0x1c>
    {

        /* Queue pointer is invalid, return appropriate error code.  */
        status =  TX_QUEUE_ERROR;
34198da6:	2309      	movs	r3, #9
34198da8:	61fb      	str	r3, [r7, #28]
34198daa:	e025      	b.n	34198df8 <_txe_queue_receive+0x68>
    }

    /* Now check for invalid queue ID.  */
    else if (queue_ptr -> tx_queue_id != TX_QUEUE_ID)
34198dac:	68fb      	ldr	r3, [r7, #12]
34198dae:	681b      	ldr	r3, [r3, #0]
34198db0:	4a18      	ldr	r2, [pc, #96]	@ (34198e14 <_txe_queue_receive+0x84>)
34198db2:	4293      	cmp	r3, r2
34198db4:	d002      	beq.n	34198dbc <_txe_queue_receive+0x2c>
    {

        /* Queue pointer is invalid, return appropriate error code.  */
        status =  TX_QUEUE_ERROR;
34198db6:	2309      	movs	r3, #9
34198db8:	61fb      	str	r3, [r7, #28]
34198dba:	e01d      	b.n	34198df8 <_txe_queue_receive+0x68>
    }

    /* Check for an invalid destination for message.  */
    else if (destination_ptr == TX_NULL)
34198dbc:	68bb      	ldr	r3, [r7, #8]
34198dbe:	2b00      	cmp	r3, #0
34198dc0:	d102      	bne.n	34198dc8 <_txe_queue_receive+0x38>
    {

        /* Null destination pointer, return appropriate error.  */
        status =  TX_PTR_ERROR;
34198dc2:	2303      	movs	r3, #3
34198dc4:	61fb      	str	r3, [r7, #28]
34198dc6:	e017      	b.n	34198df8 <_txe_queue_receive+0x68>
    else
    {

        /* Check for a wait option error.  Only threads are allowed any form of
           suspension.  */
        if (wait_option != TX_NO_WAIT)
34198dc8:	687b      	ldr	r3, [r7, #4]
34198dca:	2b00      	cmp	r3, #0
34198dcc:	d014      	beq.n	34198df8 <_txe_queue_receive+0x68>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
34198dce:	f3ef 8305 	mrs	r3, IPSR
34198dd2:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
34198dd4:	697a      	ldr	r2, [r7, #20]
        {

            /* Is the call from an ISR or Initialization?  */
            if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
34198dd6:	4b10      	ldr	r3, [pc, #64]	@ (34198e18 <_txe_queue_receive+0x88>)
34198dd8:	681b      	ldr	r3, [r3, #0]
34198dda:	4313      	orrs	r3, r2
34198ddc:	2b00      	cmp	r3, #0
34198dde:	d002      	beq.n	34198de6 <_txe_queue_receive+0x56>
            {

                /* A non-thread is trying to suspend, return appropriate error code.  */
                status =  TX_WAIT_ERROR;
34198de0:	2304      	movs	r3, #4
34198de2:	61fb      	str	r3, [r7, #28]
34198de4:	e008      	b.n	34198df8 <_txe_queue_receive+0x68>
#ifndef TX_TIMER_PROCESS_IN_ISR
            else
            {

                /* Pickup thread pointer.  */
                TX_THREAD_GET_CURRENT(current_thread)
34198de6:	4b0d      	ldr	r3, [pc, #52]	@ (34198e1c <_txe_queue_receive+0x8c>)
34198de8:	681b      	ldr	r3, [r3, #0]
34198dea:	61bb      	str	r3, [r7, #24]

                /* Is the current thread the timer thread?  */
                if (current_thread == &_tx_timer_thread)
34198dec:	69bb      	ldr	r3, [r7, #24]
34198dee:	4a0c      	ldr	r2, [pc, #48]	@ (34198e20 <_txe_queue_receive+0x90>)
34198df0:	4293      	cmp	r3, r2
34198df2:	d101      	bne.n	34198df8 <_txe_queue_receive+0x68>
                {

                    /* A non-thread is trying to suspend, return appropriate error code.  */
                    status =  TX_WAIT_ERROR;
34198df4:	2304      	movs	r3, #4
34198df6:	61fb      	str	r3, [r7, #28]
#endif
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
34198df8:	69fb      	ldr	r3, [r7, #28]
34198dfa:	2b00      	cmp	r3, #0
34198dfc:	d105      	bne.n	34198e0a <_txe_queue_receive+0x7a>
    {

        /* Call actual queue receive function.  */
        status =  _tx_queue_receive(queue_ptr, destination_ptr, wait_option);
34198dfe:	687a      	ldr	r2, [r7, #4]
34198e00:	68b9      	ldr	r1, [r7, #8]
34198e02:	68f8      	ldr	r0, [r7, #12]
34198e04:	f7fd fbc4 	bl	34196590 <_tx_queue_receive>
34198e08:	61f8      	str	r0, [r7, #28]
    }

    /* Return completion status.  */
    return(status);
34198e0a:	69fb      	ldr	r3, [r7, #28]
}
34198e0c:	4618      	mov	r0, r3
34198e0e:	3720      	adds	r7, #32
34198e10:	46bd      	mov	sp, r7
34198e12:	bd80      	pop	{r7, pc}
34198e14:	51554555 	.word	0x51554555
34198e18:	341c009c 	.word	0x341c009c
34198e1c:	341c2dec 	.word	0x341c2dec
34198e20:	341c2f34 	.word	0x341c2f34

34198e24 <_txe_queue_send>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_queue_send(TX_QUEUE *queue_ptr, VOID *source_ptr, ULONG wait_option)
{
34198e24:	b580      	push	{r7, lr}
34198e26:	b088      	sub	sp, #32
34198e28:	af00      	add	r7, sp, #0
34198e2a:	60f8      	str	r0, [r7, #12]
34198e2c:	60b9      	str	r1, [r7, #8]
34198e2e:	607a      	str	r2, [r7, #4]
TX_THREAD   *current_thread;
#endif


    /* Default status to success.  */
    status =  TX_SUCCESS;
34198e30:	2300      	movs	r3, #0
34198e32:	61fb      	str	r3, [r7, #28]

    /* Check for an invalid queue pointer.  */
    if (queue_ptr == TX_NULL)
34198e34:	68fb      	ldr	r3, [r7, #12]
34198e36:	2b00      	cmp	r3, #0
34198e38:	d102      	bne.n	34198e40 <_txe_queue_send+0x1c>
    {

        /* Queue pointer is invalid, return appropriate error code.  */
        status =  TX_QUEUE_ERROR;
34198e3a:	2309      	movs	r3, #9
34198e3c:	61fb      	str	r3, [r7, #28]
34198e3e:	e025      	b.n	34198e8c <_txe_queue_send+0x68>
    }

    /* Now check for invalid queue ID.  */
    else if (queue_ptr -> tx_queue_id != TX_QUEUE_ID)
34198e40:	68fb      	ldr	r3, [r7, #12]
34198e42:	681b      	ldr	r3, [r3, #0]
34198e44:	4a18      	ldr	r2, [pc, #96]	@ (34198ea8 <_txe_queue_send+0x84>)
34198e46:	4293      	cmp	r3, r2
34198e48:	d002      	beq.n	34198e50 <_txe_queue_send+0x2c>
    {

        /* Queue pointer is invalid, return appropriate error code.  */
        status =  TX_QUEUE_ERROR;
34198e4a:	2309      	movs	r3, #9
34198e4c:	61fb      	str	r3, [r7, #28]
34198e4e:	e01d      	b.n	34198e8c <_txe_queue_send+0x68>
    }

    /* Check for an invalid source for message.  */
    else if (source_ptr == TX_NULL)
34198e50:	68bb      	ldr	r3, [r7, #8]
34198e52:	2b00      	cmp	r3, #0
34198e54:	d102      	bne.n	34198e5c <_txe_queue_send+0x38>
    {

        /* Null source pointer, return appropriate error.  */
        status =  TX_PTR_ERROR;
34198e56:	2303      	movs	r3, #3
34198e58:	61fb      	str	r3, [r7, #28]
34198e5a:	e017      	b.n	34198e8c <_txe_queue_send+0x68>
    else
    {

        /* Check for a wait option error.  Only threads are allowed any form of
           suspension.  */
        if (wait_option != TX_NO_WAIT)
34198e5c:	687b      	ldr	r3, [r7, #4]
34198e5e:	2b00      	cmp	r3, #0
34198e60:	d014      	beq.n	34198e8c <_txe_queue_send+0x68>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
34198e62:	f3ef 8305 	mrs	r3, IPSR
34198e66:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
34198e68:	697a      	ldr	r2, [r7, #20]
        {

            /* Is the call from an ISR or Initialization?  */
            if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
34198e6a:	4b10      	ldr	r3, [pc, #64]	@ (34198eac <_txe_queue_send+0x88>)
34198e6c:	681b      	ldr	r3, [r3, #0]
34198e6e:	4313      	orrs	r3, r2
34198e70:	2b00      	cmp	r3, #0
34198e72:	d002      	beq.n	34198e7a <_txe_queue_send+0x56>
            {

                /* A non-thread is trying to suspend, return appropriate error code.  */
                status =  TX_WAIT_ERROR;
34198e74:	2304      	movs	r3, #4
34198e76:	61fb      	str	r3, [r7, #28]
34198e78:	e008      	b.n	34198e8c <_txe_queue_send+0x68>
#ifndef TX_TIMER_PROCESS_IN_ISR
            else
            {

                /* Pickup thread pointer.  */
                TX_THREAD_GET_CURRENT(current_thread)
34198e7a:	4b0d      	ldr	r3, [pc, #52]	@ (34198eb0 <_txe_queue_send+0x8c>)
34198e7c:	681b      	ldr	r3, [r3, #0]
34198e7e:	61bb      	str	r3, [r7, #24]

                /* Is the current thread the timer thread?  */
                if (current_thread == &_tx_timer_thread)
34198e80:	69bb      	ldr	r3, [r7, #24]
34198e82:	4a0c      	ldr	r2, [pc, #48]	@ (34198eb4 <_txe_queue_send+0x90>)
34198e84:	4293      	cmp	r3, r2
34198e86:	d101      	bne.n	34198e8c <_txe_queue_send+0x68>
                {

                    /* A non-thread is trying to suspend, return appropriate error code.  */
                    status =  TX_WAIT_ERROR;
34198e88:	2304      	movs	r3, #4
34198e8a:	61fb      	str	r3, [r7, #28]
#endif
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
34198e8c:	69fb      	ldr	r3, [r7, #28]
34198e8e:	2b00      	cmp	r3, #0
34198e90:	d105      	bne.n	34198e9e <_txe_queue_send+0x7a>
    {

        /* Call actual queue send function.  */
        status =  _tx_queue_send(queue_ptr, source_ptr, wait_option);
34198e92:	687a      	ldr	r2, [r7, #4]
34198e94:	68b9      	ldr	r1, [r7, #8]
34198e96:	68f8      	ldr	r0, [r7, #12]
34198e98:	f7fd fd42 	bl	34196920 <_tx_queue_send>
34198e9c:	61f8      	str	r0, [r7, #28]
    }

    /* Return completion status.  */
    return(status);
34198e9e:	69fb      	ldr	r3, [r7, #28]
}
34198ea0:	4618      	mov	r0, r3
34198ea2:	3720      	adds	r7, #32
34198ea4:	46bd      	mov	sp, r7
34198ea6:	bd80      	pop	{r7, pc}
34198ea8:	51554555 	.word	0x51554555
34198eac:	341c009c 	.word	0x341c009c
34198eb0:	341c2dec 	.word	0x341c2dec
34198eb4:	341c2f34 	.word	0x341c2f34

34198eb8 <_txe_semaphore_create>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_semaphore_create(TX_SEMAPHORE *semaphore_ptr, CHAR *name_ptr, ULONG initial_count, UINT semaphore_control_block_size)
{
34198eb8:	b580      	push	{r7, lr}
34198eba:	b092      	sub	sp, #72	@ 0x48
34198ebc:	af00      	add	r7, sp, #0
34198ebe:	60f8      	str	r0, [r7, #12]
34198ec0:	60b9      	str	r1, [r7, #8]
34198ec2:	607a      	str	r2, [r7, #4]
34198ec4:	603b      	str	r3, [r7, #0]
TX_THREAD           *thread_ptr;
#endif


    /* Default status to success.  */
    status =  TX_SUCCESS;
34198ec6:	2300      	movs	r3, #0
34198ec8:	647b      	str	r3, [r7, #68]	@ 0x44

    /* Check for an invalid semaphore pointer.  */
    if (semaphore_ptr == TX_NULL)
34198eca:	68fb      	ldr	r3, [r7, #12]
34198ecc:	2b00      	cmp	r3, #0
34198ece:	d102      	bne.n	34198ed6 <_txe_semaphore_create+0x1e>
    {

        /* Semaphore pointer is invalid, return appropriate error code.  */
        status =  TX_SEMAPHORE_ERROR;
34198ed0:	230c      	movs	r3, #12
34198ed2:	647b      	str	r3, [r7, #68]	@ 0x44
34198ed4:	e054      	b.n	34198f80 <_txe_semaphore_create+0xc8>
    }

    /* Now check for a valid semaphore ID.  */
    else if (semaphore_control_block_size != (sizeof(TX_SEMAPHORE)))
34198ed6:	683b      	ldr	r3, [r7, #0]
34198ed8:	2b1c      	cmp	r3, #28
34198eda:	d002      	beq.n	34198ee2 <_txe_semaphore_create+0x2a>
    {

        /* Semaphore pointer is invalid, return appropriate error code.  */
        status =  TX_SEMAPHORE_ERROR;
34198edc:	230c      	movs	r3, #12
34198ede:	647b      	str	r3, [r7, #68]	@ 0x44
34198ee0:	e04e      	b.n	34198f80 <_txe_semaphore_create+0xc8>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34198ee2:	f3ef 8310 	mrs	r3, PRIMASK
34198ee6:	62fb      	str	r3, [r7, #44]	@ 0x2c
    return(posture);
34198ee8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
    int_posture = __get_interrupt_posture();
34198eea:	62bb      	str	r3, [r7, #40]	@ 0x28
    __asm__ volatile ("CPSID i" : : : "memory");
34198eec:	b672      	cpsid	i
    return(int_posture);
34198eee:	6abb      	ldr	r3, [r7, #40]	@ 0x28
    }
    else
    {

        /* Disable interrupts.  */
        TX_DISABLE
34198ef0:	63bb      	str	r3, [r7, #56]	@ 0x38

        /* Increment the preempt disable flag.  */
        _tx_thread_preempt_disable++;
34198ef2:	4b36      	ldr	r3, [pc, #216]	@ (34198fcc <_txe_semaphore_create+0x114>)
34198ef4:	681b      	ldr	r3, [r3, #0]
34198ef6:	3301      	adds	r3, #1
34198ef8:	4a34      	ldr	r2, [pc, #208]	@ (34198fcc <_txe_semaphore_create+0x114>)
34198efa:	6013      	str	r3, [r2, #0]
34198efc:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34198efe:	633b      	str	r3, [r7, #48]	@ 0x30
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34198f00:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34198f02:	f383 8810 	msr	PRIMASK, r3
}
34198f06:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Next see if it is already in the created list.  */
        next_semaphore =  _tx_semaphore_created_ptr;
34198f08:	4b31      	ldr	r3, [pc, #196]	@ (34198fd0 <_txe_semaphore_create+0x118>)
34198f0a:	681b      	ldr	r3, [r3, #0]
34198f0c:	63fb      	str	r3, [r7, #60]	@ 0x3c
        for (i = ((ULONG) 0); i < _tx_semaphore_created_count; i++)
34198f0e:	2300      	movs	r3, #0
34198f10:	643b      	str	r3, [r7, #64]	@ 0x40
34198f12:	e009      	b.n	34198f28 <_txe_semaphore_create+0x70>
        {

            /* Determine if this semaphore matches the current semaphore in the list.  */
            if (semaphore_ptr == next_semaphore)
34198f14:	68fa      	ldr	r2, [r7, #12]
34198f16:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34198f18:	429a      	cmp	r2, r3
34198f1a:	d00b      	beq.n	34198f34 <_txe_semaphore_create+0x7c>
            }
            else
            {

                /* Move to next semaphore.  */
                next_semaphore =  next_semaphore -> tx_semaphore_created_next;
34198f1c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34198f1e:	695b      	ldr	r3, [r3, #20]
34198f20:	63fb      	str	r3, [r7, #60]	@ 0x3c
        for (i = ((ULONG) 0); i < _tx_semaphore_created_count; i++)
34198f22:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34198f24:	3301      	adds	r3, #1
34198f26:	643b      	str	r3, [r7, #64]	@ 0x40
34198f28:	4b2a      	ldr	r3, [pc, #168]	@ (34198fd4 <_txe_semaphore_create+0x11c>)
34198f2a:	681b      	ldr	r3, [r3, #0]
34198f2c:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
34198f2e:	429a      	cmp	r2, r3
34198f30:	d3f0      	bcc.n	34198f14 <_txe_semaphore_create+0x5c>
34198f32:	e000      	b.n	34198f36 <_txe_semaphore_create+0x7e>
                break;
34198f34:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34198f36:	f3ef 8310 	mrs	r3, PRIMASK
34198f3a:	623b      	str	r3, [r7, #32]
    return(posture);
34198f3c:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
34198f3e:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
34198f40:	b672      	cpsid	i
    return(int_posture);
34198f42:	69fb      	ldr	r3, [r7, #28]
            }
        }

        /* Disable interrupts.  */
        TX_DISABLE
34198f44:	63bb      	str	r3, [r7, #56]	@ 0x38

        /* Decrement the preempt disable flag.  */
        _tx_thread_preempt_disable--;
34198f46:	4b21      	ldr	r3, [pc, #132]	@ (34198fcc <_txe_semaphore_create+0x114>)
34198f48:	681b      	ldr	r3, [r3, #0]
34198f4a:	3b01      	subs	r3, #1
34198f4c:	4a1f      	ldr	r2, [pc, #124]	@ (34198fcc <_txe_semaphore_create+0x114>)
34198f4e:	6013      	str	r3, [r2, #0]
34198f50:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34198f52:	627b      	str	r3, [r7, #36]	@ 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34198f54:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34198f56:	f383 8810 	msr	PRIMASK, r3
}
34198f5a:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Check for preemption.  */
        _tx_thread_system_preempt_check();
34198f5c:	f7fe fc58 	bl	34197810 <_tx_thread_system_preempt_check>

        /* At this point, check to see if there is a duplicate semaphore.  */
        if (semaphore_ptr == next_semaphore)
34198f60:	68fa      	ldr	r2, [r7, #12]
34198f62:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34198f64:	429a      	cmp	r2, r3
34198f66:	d102      	bne.n	34198f6e <_txe_semaphore_create+0xb6>
        {

            /* Semaphore is already created, return appropriate error code.  */
            status =  TX_SEMAPHORE_ERROR;
34198f68:	230c      	movs	r3, #12
34198f6a:	647b      	str	r3, [r7, #68]	@ 0x44
34198f6c:	e008      	b.n	34198f80 <_txe_semaphore_create+0xc8>
#ifndef TX_TIMER_PROCESS_IN_ISR
        else
        {

            /* Pickup thread pointer.  */
            TX_THREAD_GET_CURRENT(thread_ptr)
34198f6e:	4b1a      	ldr	r3, [pc, #104]	@ (34198fd8 <_txe_semaphore_create+0x120>)
34198f70:	681b      	ldr	r3, [r3, #0]
34198f72:	637b      	str	r3, [r7, #52]	@ 0x34

            /* Check for invalid caller of this function.  First check for a calling thread.  */
            if (thread_ptr == &_tx_timer_thread)
34198f74:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34198f76:	4a19      	ldr	r2, [pc, #100]	@ (34198fdc <_txe_semaphore_create+0x124>)
34198f78:	4293      	cmp	r3, r2
34198f7a:	d101      	bne.n	34198f80 <_txe_semaphore_create+0xc8>
            {

                /* Invalid caller of this function, return appropriate error code.  */
                status =  TX_CALLER_ERROR;
34198f7c:	2313      	movs	r3, #19
34198f7e:	647b      	str	r3, [r7, #68]	@ 0x44
        }
#endif
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
34198f80:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34198f82:	2b00      	cmp	r3, #0
34198f84:	d114      	bne.n	34198fb0 <_txe_semaphore_create+0xf8>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
34198f86:	f3ef 8305 	mrs	r3, IPSR
34198f8a:	61bb      	str	r3, [r7, #24]
    return(ipsr_value);
34198f8c:	69ba      	ldr	r2, [r7, #24]
    {

        /* Check for interrupt call.  */
        if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
34198f8e:	4b14      	ldr	r3, [pc, #80]	@ (34198fe0 <_txe_semaphore_create+0x128>)
34198f90:	681b      	ldr	r3, [r3, #0]
34198f92:	4313      	orrs	r3, r2
34198f94:	2b00      	cmp	r3, #0
34198f96:	d00b      	beq.n	34198fb0 <_txe_semaphore_create+0xf8>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
34198f98:	f3ef 8305 	mrs	r3, IPSR
34198f9c:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
34198f9e:	697a      	ldr	r2, [r7, #20]
        {

            /* Now, make sure the call is from an interrupt and not initialization.  */
            if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
34198fa0:	4b0f      	ldr	r3, [pc, #60]	@ (34198fe0 <_txe_semaphore_create+0x128>)
34198fa2:	681b      	ldr	r3, [r3, #0]
34198fa4:	4313      	orrs	r3, r2
34198fa6:	f1b3 3ff0 	cmp.w	r3, #4042322160	@ 0xf0f0f0f0
34198faa:	d201      	bcs.n	34198fb0 <_txe_semaphore_create+0xf8>
            {

                /* Invalid caller of this function, return appropriate error code.  */
                status =  TX_CALLER_ERROR;
34198fac:	2313      	movs	r3, #19
34198fae:	647b      	str	r3, [r7, #68]	@ 0x44
            }
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
34198fb0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34198fb2:	2b00      	cmp	r3, #0
34198fb4:	d105      	bne.n	34198fc2 <_txe_semaphore_create+0x10a>
    {

        /* Call actual semaphore create function.  */
        status =  _tx_semaphore_create(semaphore_ptr, name_ptr, initial_count);
34198fb6:	687a      	ldr	r2, [r7, #4]
34198fb8:	68b9      	ldr	r1, [r7, #8]
34198fba:	68f8      	ldr	r0, [r7, #12]
34198fbc:	f7fd fe58 	bl	34196c70 <_tx_semaphore_create>
34198fc0:	6478      	str	r0, [r7, #68]	@ 0x44
    }

    /* Return completion status.  */
    return(status);
34198fc2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
}
34198fc4:	4618      	mov	r0, r3
34198fc6:	3748      	adds	r7, #72	@ 0x48
34198fc8:	46bd      	mov	sp, r7
34198fca:	bd80      	pop	{r7, pc}
34198fcc:	341c2e84 	.word	0x341c2e84
34198fd0:	341c2db4 	.word	0x341c2db4
34198fd4:	341c2db8 	.word	0x341c2db8
34198fd8:	341c2dec 	.word	0x341c2dec
34198fdc:	341c2f34 	.word	0x341c2f34
34198fe0:	341c009c 	.word	0x341c009c

34198fe4 <_txe_semaphore_delete>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_semaphore_delete(TX_SEMAPHORE *semaphore_ptr)
{
34198fe4:	b580      	push	{r7, lr}
34198fe6:	b086      	sub	sp, #24
34198fe8:	af00      	add	r7, sp, #0
34198fea:	6078      	str	r0, [r7, #4]
TX_THREAD       *thread_ptr;
#endif


    /* Default status to success.  */
    status =  TX_SUCCESS;
34198fec:	2300      	movs	r3, #0
34198fee:	617b      	str	r3, [r7, #20]

    /* Check for an invalid semaphore pointer.  */
    if (semaphore_ptr == TX_NULL)
34198ff0:	687b      	ldr	r3, [r7, #4]
34198ff2:	2b00      	cmp	r3, #0
34198ff4:	d102      	bne.n	34198ffc <_txe_semaphore_delete+0x18>
    {

        /* Semaphore pointer is invalid, return appropriate error code.  */
        status =  TX_SEMAPHORE_ERROR;
34198ff6:	230c      	movs	r3, #12
34198ff8:	617b      	str	r3, [r7, #20]
34198ffa:	e01c      	b.n	34199036 <_txe_semaphore_delete+0x52>
    }

    /* Now check for invalid semaphore ID.  */
    else if (semaphore_ptr -> tx_semaphore_id != TX_SEMAPHORE_ID)
34198ffc:	687b      	ldr	r3, [r7, #4]
34198ffe:	681b      	ldr	r3, [r3, #0]
34199000:	4a13      	ldr	r2, [pc, #76]	@ (34199050 <_txe_semaphore_delete+0x6c>)
34199002:	4293      	cmp	r3, r2
34199004:	d002      	beq.n	3419900c <_txe_semaphore_delete+0x28>
    {

        /* Semaphore pointer is invalid, return appropriate error code.  */
        status =  TX_SEMAPHORE_ERROR;
34199006:	230c      	movs	r3, #12
34199008:	617b      	str	r3, [r7, #20]
3419900a:	e014      	b.n	34199036 <_txe_semaphore_delete+0x52>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
3419900c:	f3ef 8305 	mrs	r3, IPSR
34199010:	60fb      	str	r3, [r7, #12]
    return(ipsr_value);
34199012:	68fa      	ldr	r2, [r7, #12]
    {

        /* Check for invalid caller of this function.  */

        /* Is the caller an ISR or Initialization?  */
        if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
34199014:	4b0f      	ldr	r3, [pc, #60]	@ (34199054 <_txe_semaphore_delete+0x70>)
34199016:	681b      	ldr	r3, [r3, #0]
34199018:	4313      	orrs	r3, r2
3419901a:	2b00      	cmp	r3, #0
3419901c:	d002      	beq.n	34199024 <_txe_semaphore_delete+0x40>
        {

            /* Invalid caller of this function, return appropriate error code.  */
            status =  TX_CALLER_ERROR;
3419901e:	2313      	movs	r3, #19
34199020:	617b      	str	r3, [r7, #20]
34199022:	e008      	b.n	34199036 <_txe_semaphore_delete+0x52>
#ifndef TX_TIMER_PROCESS_IN_ISR
        else
        {

            /* Pickup thread pointer.  */
            TX_THREAD_GET_CURRENT(thread_ptr)
34199024:	4b0c      	ldr	r3, [pc, #48]	@ (34199058 <_txe_semaphore_delete+0x74>)
34199026:	681b      	ldr	r3, [r3, #0]
34199028:	613b      	str	r3, [r7, #16]

            /* Is the caller the system timer thread?  */
            if (thread_ptr == &_tx_timer_thread)
3419902a:	693b      	ldr	r3, [r7, #16]
3419902c:	4a0b      	ldr	r2, [pc, #44]	@ (3419905c <_txe_semaphore_delete+0x78>)
3419902e:	4293      	cmp	r3, r2
34199030:	d101      	bne.n	34199036 <_txe_semaphore_delete+0x52>
            {

                /* Invalid caller of this function, return appropriate error code.  */
                status =  TX_CALLER_ERROR;
34199032:	2313      	movs	r3, #19
34199034:	617b      	str	r3, [r7, #20]
        }
#endif
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
34199036:	697b      	ldr	r3, [r7, #20]
34199038:	2b00      	cmp	r3, #0
3419903a:	d103      	bne.n	34199044 <_txe_semaphore_delete+0x60>
    {

        /* Call actual semaphore delete function.  */
        status =  _tx_semaphore_delete(semaphore_ptr);
3419903c:	6878      	ldr	r0, [r7, #4]
3419903e:	f7fd fe69 	bl	34196d14 <_tx_semaphore_delete>
34199042:	6178      	str	r0, [r7, #20]
    }

    /* Return completion status.  */
    return(status);
34199044:	697b      	ldr	r3, [r7, #20]
}
34199046:	4618      	mov	r0, r3
34199048:	3718      	adds	r7, #24
3419904a:	46bd      	mov	sp, r7
3419904c:	bd80      	pop	{r7, pc}
3419904e:	bf00      	nop
34199050:	53454d41 	.word	0x53454d41
34199054:	341c009c 	.word	0x341c009c
34199058:	341c2dec 	.word	0x341c2dec
3419905c:	341c2f34 	.word	0x341c2f34

34199060 <_txe_semaphore_get>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_semaphore_get(TX_SEMAPHORE *semaphore_ptr, ULONG wait_option)
{
34199060:	b580      	push	{r7, lr}
34199062:	b086      	sub	sp, #24
34199064:	af00      	add	r7, sp, #0
34199066:	6078      	str	r0, [r7, #4]
34199068:	6039      	str	r1, [r7, #0]
TX_THREAD   *current_thread;
#endif


    /* Default status to success.  */
    status =  TX_SUCCESS;
3419906a:	2300      	movs	r3, #0
3419906c:	617b      	str	r3, [r7, #20]

    /* Check for an invalid semaphore pointer.  */
    if (semaphore_ptr == TX_NULL)
3419906e:	687b      	ldr	r3, [r7, #4]
34199070:	2b00      	cmp	r3, #0
34199072:	d102      	bne.n	3419907a <_txe_semaphore_get+0x1a>
    {

        /* Semaphore pointer is invalid, return appropriate error code.  */
        status =  TX_SEMAPHORE_ERROR;
34199074:	230c      	movs	r3, #12
34199076:	617b      	str	r3, [r7, #20]
34199078:	e01f      	b.n	341990ba <_txe_semaphore_get+0x5a>
    }

    /* Now check for invalid semaphore ID.  */
    else if (semaphore_ptr -> tx_semaphore_id != TX_SEMAPHORE_ID)
3419907a:	687b      	ldr	r3, [r7, #4]
3419907c:	681b      	ldr	r3, [r3, #0]
3419907e:	4a15      	ldr	r2, [pc, #84]	@ (341990d4 <_txe_semaphore_get+0x74>)
34199080:	4293      	cmp	r3, r2
34199082:	d002      	beq.n	3419908a <_txe_semaphore_get+0x2a>
    {

        /* Semaphore pointer is invalid, return appropriate error code.  */
        status =  TX_SEMAPHORE_ERROR;
34199084:	230c      	movs	r3, #12
34199086:	617b      	str	r3, [r7, #20]
34199088:	e017      	b.n	341990ba <_txe_semaphore_get+0x5a>
    else
    {

        /* Check for a wait option error.  Only threads are allowed any form of
           suspension.  */
        if (wait_option != TX_NO_WAIT)
3419908a:	683b      	ldr	r3, [r7, #0]
3419908c:	2b00      	cmp	r3, #0
3419908e:	d014      	beq.n	341990ba <_txe_semaphore_get+0x5a>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
34199090:	f3ef 8305 	mrs	r3, IPSR
34199094:	60fb      	str	r3, [r7, #12]
    return(ipsr_value);
34199096:	68fa      	ldr	r2, [r7, #12]
        {

            /* Is the call from an ISR or Initialization?  */
            if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
34199098:	4b0f      	ldr	r3, [pc, #60]	@ (341990d8 <_txe_semaphore_get+0x78>)
3419909a:	681b      	ldr	r3, [r3, #0]
3419909c:	4313      	orrs	r3, r2
3419909e:	2b00      	cmp	r3, #0
341990a0:	d002      	beq.n	341990a8 <_txe_semaphore_get+0x48>
            {

                /* A non-thread is trying to suspend, return appropriate error code.  */
                status =  TX_WAIT_ERROR;
341990a2:	2304      	movs	r3, #4
341990a4:	617b      	str	r3, [r7, #20]
341990a6:	e008      	b.n	341990ba <_txe_semaphore_get+0x5a>
#ifndef TX_TIMER_PROCESS_IN_ISR
            else
            {

                /* Pickup thread pointer.  */
                TX_THREAD_GET_CURRENT(current_thread)
341990a8:	4b0c      	ldr	r3, [pc, #48]	@ (341990dc <_txe_semaphore_get+0x7c>)
341990aa:	681b      	ldr	r3, [r3, #0]
341990ac:	613b      	str	r3, [r7, #16]

                /* Is the current thread the timer thread?  */
                if (current_thread == &_tx_timer_thread)
341990ae:	693b      	ldr	r3, [r7, #16]
341990b0:	4a0b      	ldr	r2, [pc, #44]	@ (341990e0 <_txe_semaphore_get+0x80>)
341990b2:	4293      	cmp	r3, r2
341990b4:	d101      	bne.n	341990ba <_txe_semaphore_get+0x5a>
                {

                    /* A non-thread is trying to suspend, return appropriate error code.  */
                    status =  TX_WAIT_ERROR;
341990b6:	2304      	movs	r3, #4
341990b8:	617b      	str	r3, [r7, #20]
#endif
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
341990ba:	697b      	ldr	r3, [r7, #20]
341990bc:	2b00      	cmp	r3, #0
341990be:	d104      	bne.n	341990ca <_txe_semaphore_get+0x6a>
    {

        /* Call actual get semaphore function.  */
        status =  _tx_semaphore_get(semaphore_ptr, wait_option);
341990c0:	6839      	ldr	r1, [r7, #0]
341990c2:	6878      	ldr	r0, [r7, #4]
341990c4:	f7fd feb6 	bl	34196e34 <_tx_semaphore_get>
341990c8:	6178      	str	r0, [r7, #20]
    }

    /* Return completion status.  */
    return(status);
341990ca:	697b      	ldr	r3, [r7, #20]
}
341990cc:	4618      	mov	r0, r3
341990ce:	3718      	adds	r7, #24
341990d0:	46bd      	mov	sp, r7
341990d2:	bd80      	pop	{r7, pc}
341990d4:	53454d41 	.word	0x53454d41
341990d8:	341c009c 	.word	0x341c009c
341990dc:	341c2dec 	.word	0x341c2dec
341990e0:	341c2f34 	.word	0x341c2f34

341990e4 <_txe_semaphore_put>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_semaphore_put(TX_SEMAPHORE *semaphore_ptr)
{
341990e4:	b580      	push	{r7, lr}
341990e6:	b084      	sub	sp, #16
341990e8:	af00      	add	r7, sp, #0
341990ea:	6078      	str	r0, [r7, #4]

UINT        status;


    /* Check for an invalid semaphore pointer.  */
    if (semaphore_ptr == TX_NULL)
341990ec:	687b      	ldr	r3, [r7, #4]
341990ee:	2b00      	cmp	r3, #0
341990f0:	d102      	bne.n	341990f8 <_txe_semaphore_put+0x14>
    {

        /* Semaphore pointer is invalid, return appropriate error code.  */
        status =  TX_SEMAPHORE_ERROR;
341990f2:	230c      	movs	r3, #12
341990f4:	60fb      	str	r3, [r7, #12]
341990f6:	e00b      	b.n	34199110 <_txe_semaphore_put+0x2c>
    }

    /* Now check for invalid semaphore ID.  */
    else if (semaphore_ptr -> tx_semaphore_id != TX_SEMAPHORE_ID)
341990f8:	687b      	ldr	r3, [r7, #4]
341990fa:	681b      	ldr	r3, [r3, #0]
341990fc:	4a07      	ldr	r2, [pc, #28]	@ (3419911c <_txe_semaphore_put+0x38>)
341990fe:	4293      	cmp	r3, r2
34199100:	d002      	beq.n	34199108 <_txe_semaphore_put+0x24>
    {

        /* Semaphore pointer is invalid, return appropriate error code.  */
        status =  TX_SEMAPHORE_ERROR;
34199102:	230c      	movs	r3, #12
34199104:	60fb      	str	r3, [r7, #12]
34199106:	e003      	b.n	34199110 <_txe_semaphore_put+0x2c>
    }
    else
    {

        /* Call actual put semaphore function.  */
        status =  _tx_semaphore_put(semaphore_ptr);
34199108:	6878      	ldr	r0, [r7, #4]
3419910a:	f7fd ff25 	bl	34196f58 <_tx_semaphore_put>
3419910e:	60f8      	str	r0, [r7, #12]
    }

    /* Return completion status.  */
    return(status);
34199110:	68fb      	ldr	r3, [r7, #12]
}
34199112:	4618      	mov	r0, r3
34199114:	3710      	adds	r7, #16
34199116:	46bd      	mov	sp, r7
34199118:	bd80      	pop	{r7, pc}
3419911a:	bf00      	nop
3419911c:	53454d41 	.word	0x53454d41

34199120 <_txe_thread_create>:
UINT    _txe_thread_create(TX_THREAD *thread_ptr, CHAR *name_ptr,
                VOID (*entry_function)(ULONG id), ULONG entry_input,
                VOID *stack_start, ULONG stack_size,
                UINT priority, UINT preempt_threshold,
                ULONG time_slice, UINT auto_start, UINT thread_control_block_size)
{
34199120:	b580      	push	{r7, lr}
34199122:	b09a      	sub	sp, #104	@ 0x68
34199124:	af06      	add	r7, sp, #24
34199126:	60f8      	str	r0, [r7, #12]
34199128:	60b9      	str	r1, [r7, #8]
3419912a:	607a      	str	r2, [r7, #4]
3419912c:	603b      	str	r3, [r7, #0]
TX_THREAD       *current_thread;
#endif


    /* Default status to success.  */
    status =  TX_SUCCESS;
3419912e:	2300      	movs	r3, #0
34199130:	64fb      	str	r3, [r7, #76]	@ 0x4c

    /* Check for an invalid thread pointer.  */
    if (thread_ptr == TX_NULL)
34199132:	68fb      	ldr	r3, [r7, #12]
34199134:	2b00      	cmp	r3, #0
34199136:	d102      	bne.n	3419913e <_txe_thread_create+0x1e>
    {

        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
34199138:	230e      	movs	r3, #14
3419913a:	64fb      	str	r3, [r7, #76]	@ 0x4c
3419913c:	e0bb      	b.n	341992b6 <_txe_thread_create+0x196>
    }

    /* Now check for invalid thread control block size.  */
    else if (thread_control_block_size != (sizeof(TX_THREAD)))
3419913e:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
34199140:	2bb0      	cmp	r3, #176	@ 0xb0
34199142:	d002      	beq.n	3419914a <_txe_thread_create+0x2a>
    {

        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
34199144:	230e      	movs	r3, #14
34199146:	64fb      	str	r3, [r7, #76]	@ 0x4c
34199148:	e0b5      	b.n	341992b6 <_txe_thread_create+0x196>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
3419914a:	f3ef 8310 	mrs	r3, PRIMASK
3419914e:	62bb      	str	r3, [r7, #40]	@ 0x28
    return(posture);
34199150:	6abb      	ldr	r3, [r7, #40]	@ 0x28
    int_posture = __get_interrupt_posture();
34199152:	627b      	str	r3, [r7, #36]	@ 0x24
    __asm__ volatile ("CPSID i" : : : "memory");
34199154:	b672      	cpsid	i
    return(int_posture);
34199156:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
    }
    else
    {

        /* Disable interrupts.  */
        TX_DISABLE
34199158:	63fb      	str	r3, [r7, #60]	@ 0x3c

        /* Increment the preempt disable flag.  */
        _tx_thread_preempt_disable++;
3419915a:	4b64      	ldr	r3, [pc, #400]	@ (341992ec <_txe_thread_create+0x1cc>)
3419915c:	681b      	ldr	r3, [r3, #0]
3419915e:	3301      	adds	r3, #1
34199160:	4a62      	ldr	r2, [pc, #392]	@ (341992ec <_txe_thread_create+0x1cc>)
34199162:	6013      	str	r3, [r2, #0]
34199164:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34199166:	62fb      	str	r3, [r7, #44]	@ 0x2c
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34199168:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3419916a:	f383 8810 	msr	PRIMASK, r3
}
3419916e:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Next see if it is already in the created list.  */
        break_flag =   TX_FALSE;
34199170:	2300      	movs	r3, #0
34199172:	64bb      	str	r3, [r7, #72]	@ 0x48
        next_thread =  _tx_thread_created_ptr;
34199174:	4b5e      	ldr	r3, [pc, #376]	@ (341992f0 <_txe_thread_create+0x1d0>)
34199176:	681b      	ldr	r3, [r3, #0]
34199178:	643b      	str	r3, [r7, #64]	@ 0x40
        work_ptr =     TX_VOID_TO_UCHAR_POINTER_CONVERT(stack_start);
3419917a:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
3419917c:	63bb      	str	r3, [r7, #56]	@ 0x38
        work_ptr =     TX_UCHAR_POINTER_ADD(work_ptr, (stack_size - ((ULONG) 1)));
3419917e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
34199180:	3b01      	subs	r3, #1
34199182:	6bba      	ldr	r2, [r7, #56]	@ 0x38
34199184:	4413      	add	r3, r2
34199186:	63bb      	str	r3, [r7, #56]	@ 0x38
        stack_end =    TX_UCHAR_TO_VOID_POINTER_CONVERT(work_ptr);
34199188:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419918a:	637b      	str	r3, [r7, #52]	@ 0x34
        for (i = ((ULONG) 0); i < _tx_thread_created_count; i++)
3419918c:	2300      	movs	r3, #0
3419918e:	647b      	str	r3, [r7, #68]	@ 0x44
34199190:	e02b      	b.n	341991ea <_txe_thread_create+0xca>
        {

            /* Determine if this thread matches the thread in the list.  */
            if (thread_ptr == next_thread)
34199192:	68fa      	ldr	r2, [r7, #12]
34199194:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34199196:	429a      	cmp	r2, r3
34199198:	d101      	bne.n	3419919e <_txe_thread_create+0x7e>
            {

                /* Set the break flag.  */
                break_flag =  TX_TRUE;
3419919a:	2301      	movs	r3, #1
3419919c:	64bb      	str	r3, [r7, #72]	@ 0x48
            }

            /* Determine if we need to break the loop.  */
            if (break_flag == TX_TRUE)
3419919e:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
341991a0:	2b01      	cmp	r3, #1
341991a2:	d028      	beq.n	341991f6 <_txe_thread_create+0xd6>
                /* Yes, break out of the loop.  */
                break;
            }

            /* Check the stack pointer to see if it overlaps with this thread's stack.  */
            if (stack_start >= next_thread -> tx_thread_stack_start)
341991a4:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
341991a6:	68db      	ldr	r3, [r3, #12]
341991a8:	6dba      	ldr	r2, [r7, #88]	@ 0x58
341991aa:	429a      	cmp	r2, r3
341991ac:	d308      	bcc.n	341991c0 <_txe_thread_create+0xa0>
            {

                if (stack_start < next_thread -> tx_thread_stack_end)
341991ae:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
341991b0:	691b      	ldr	r3, [r3, #16]
341991b2:	6dba      	ldr	r2, [r7, #88]	@ 0x58
341991b4:	429a      	cmp	r2, r3
341991b6:	d203      	bcs.n	341991c0 <_txe_thread_create+0xa0>
                {

                    /* This stack overlaps with an existing thread, clear the stack pointer to
                       force a stack error below.  */
                    stack_start =  TX_NULL;
341991b8:	2300      	movs	r3, #0
341991ba:	65bb      	str	r3, [r7, #88]	@ 0x58

                    /* Set the break flag.  */
                    break_flag =  TX_TRUE;
341991bc:	2301      	movs	r3, #1
341991be:	64bb      	str	r3, [r7, #72]	@ 0x48
                }
            }

            /* Check the end of the stack to see if it is inside this thread's stack area as well.  */
            if (stack_end >= next_thread -> tx_thread_stack_start)
341991c0:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
341991c2:	68db      	ldr	r3, [r3, #12]
341991c4:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
341991c6:	429a      	cmp	r2, r3
341991c8:	d308      	bcc.n	341991dc <_txe_thread_create+0xbc>
            {

                if (stack_end < next_thread -> tx_thread_stack_end)
341991ca:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
341991cc:	691b      	ldr	r3, [r3, #16]
341991ce:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
341991d0:	429a      	cmp	r2, r3
341991d2:	d203      	bcs.n	341991dc <_txe_thread_create+0xbc>
                {

                    /* This stack overlaps with an existing thread, clear the stack pointer to
                       force a stack error below.  */
                    stack_start =  TX_NULL;
341991d4:	2300      	movs	r3, #0
341991d6:	65bb      	str	r3, [r7, #88]	@ 0x58

                    /* Set the break flag.  */
                    break_flag =  TX_TRUE;
341991d8:	2301      	movs	r3, #1
341991da:	64bb      	str	r3, [r7, #72]	@ 0x48
                }
            }

            /* Move to the next thread.  */
            next_thread =  next_thread -> tx_thread_created_next;
341991dc:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
341991de:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
341991e2:	643b      	str	r3, [r7, #64]	@ 0x40
        for (i = ((ULONG) 0); i < _tx_thread_created_count; i++)
341991e4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
341991e6:	3301      	adds	r3, #1
341991e8:	647b      	str	r3, [r7, #68]	@ 0x44
341991ea:	4b42      	ldr	r3, [pc, #264]	@ (341992f4 <_txe_thread_create+0x1d4>)
341991ec:	681b      	ldr	r3, [r3, #0]
341991ee:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
341991f0:	429a      	cmp	r2, r3
341991f2:	d3ce      	bcc.n	34199192 <_txe_thread_create+0x72>
341991f4:	e000      	b.n	341991f8 <_txe_thread_create+0xd8>
                break;
341991f6:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
341991f8:	f3ef 8310 	mrs	r3, PRIMASK
341991fc:	61fb      	str	r3, [r7, #28]
    return(posture);
341991fe:	69fb      	ldr	r3, [r7, #28]
    int_posture = __get_interrupt_posture();
34199200:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("CPSID i" : : : "memory");
34199202:	b672      	cpsid	i
    return(int_posture);
34199204:	69bb      	ldr	r3, [r7, #24]
        }

        /* Disable interrupts.  */
        TX_DISABLE
34199206:	63fb      	str	r3, [r7, #60]	@ 0x3c

        /* Decrement the preempt disable flag.  */
        _tx_thread_preempt_disable--;
34199208:	4b38      	ldr	r3, [pc, #224]	@ (341992ec <_txe_thread_create+0x1cc>)
3419920a:	681b      	ldr	r3, [r3, #0]
3419920c:	3b01      	subs	r3, #1
3419920e:	4a37      	ldr	r2, [pc, #220]	@ (341992ec <_txe_thread_create+0x1cc>)
34199210:	6013      	str	r3, [r2, #0]
34199212:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34199214:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34199216:	6a3b      	ldr	r3, [r7, #32]
34199218:	f383 8810 	msr	PRIMASK, r3
}
3419921c:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Check for preemption.  */
        _tx_thread_system_preempt_check();
3419921e:	f7fe faf7 	bl	34197810 <_tx_thread_system_preempt_check>

        /* At this point, check to see if there is a duplicate thread.  */
        if (thread_ptr == next_thread)
34199222:	68fa      	ldr	r2, [r7, #12]
34199224:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34199226:	429a      	cmp	r2, r3
34199228:	d102      	bne.n	34199230 <_txe_thread_create+0x110>
        {

            /* Thread is already created, return appropriate error code.  */
            status =  TX_THREAD_ERROR;
3419922a:	230e      	movs	r3, #14
3419922c:	64fb      	str	r3, [r7, #76]	@ 0x4c
3419922e:	e042      	b.n	341992b6 <_txe_thread_create+0x196>
        }

        /* Check for invalid starting address of stack.  */
        else if (stack_start == TX_NULL)
34199230:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
34199232:	2b00      	cmp	r3, #0
34199234:	d102      	bne.n	3419923c <_txe_thread_create+0x11c>
        {

            /* Invalid stack or entry point, return appropriate error code.  */
            status =  TX_PTR_ERROR;
34199236:	2303      	movs	r3, #3
34199238:	64fb      	str	r3, [r7, #76]	@ 0x4c
3419923a:	e03c      	b.n	341992b6 <_txe_thread_create+0x196>
        }

        /* Check for invalid thread entry point.  */
        else if (entry_function == TX_NULL)
3419923c:	687b      	ldr	r3, [r7, #4]
3419923e:	2b00      	cmp	r3, #0
34199240:	d102      	bne.n	34199248 <_txe_thread_create+0x128>
        {

            /* Invalid stack or entry point, return appropriate error code.  */
            status =  TX_PTR_ERROR;
34199242:	2303      	movs	r3, #3
34199244:	64fb      	str	r3, [r7, #76]	@ 0x4c
34199246:	e036      	b.n	341992b6 <_txe_thread_create+0x196>
        }

        /* Check the stack size.  */
        else if (stack_size < ((ULONG) TX_MINIMUM_STACK))
34199248:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3419924a:	2bc7      	cmp	r3, #199	@ 0xc7
3419924c:	d802      	bhi.n	34199254 <_txe_thread_create+0x134>
        {

            /* Stack is not big enough, return appropriate error code.  */
            status =  TX_SIZE_ERROR;
3419924e:	2305      	movs	r3, #5
34199250:	64fb      	str	r3, [r7, #76]	@ 0x4c
34199252:	e030      	b.n	341992b6 <_txe_thread_create+0x196>
        }

        /* Check the priority specified.  */
        else if (priority >= ((UINT) TX_MAX_PRIORITIES))
34199254:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
34199256:	2b1f      	cmp	r3, #31
34199258:	d902      	bls.n	34199260 <_txe_thread_create+0x140>
        {

            /* Invalid priority selected, return appropriate error code.  */
            status =  TX_PRIORITY_ERROR;
3419925a:	230f      	movs	r3, #15
3419925c:	64fb      	str	r3, [r7, #76]	@ 0x4c
3419925e:	e02a      	b.n	341992b6 <_txe_thread_create+0x196>
        }

        /* Check preemption threshold. */
        else if (preempt_threshold > priority)
34199260:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
34199262:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
34199264:	429a      	cmp	r2, r3
34199266:	d902      	bls.n	3419926e <_txe_thread_create+0x14e>
        {

            /* Invalid preempt threshold, return appropriate error code.  */
            status =  TX_THRESH_ERROR;
34199268:	2318      	movs	r3, #24
3419926a:	64fb      	str	r3, [r7, #76]	@ 0x4c
3419926c:	e023      	b.n	341992b6 <_txe_thread_create+0x196>
        }

        /* Check the start selection.  */
        else if (auto_start > TX_AUTO_START)
3419926e:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
34199270:	2b01      	cmp	r3, #1
34199272:	d902      	bls.n	3419927a <_txe_thread_create+0x15a>
        {

            /* Invalid auto start selection, return appropriate error code.  */
            status =  TX_START_ERROR;
34199274:	2310      	movs	r3, #16
34199276:	64fb      	str	r3, [r7, #76]	@ 0x4c
34199278:	e01d      	b.n	341992b6 <_txe_thread_create+0x196>
        {

#ifndef TX_TIMER_PROCESS_IN_ISR

            /* Pickup thread pointer.  */
            TX_THREAD_GET_CURRENT(current_thread)
3419927a:	4b1f      	ldr	r3, [pc, #124]	@ (341992f8 <_txe_thread_create+0x1d8>)
3419927c:	681b      	ldr	r3, [r3, #0]
3419927e:	633b      	str	r3, [r7, #48]	@ 0x30

            /* Check for invalid caller of this function.  First check for a calling thread.  */
            if (current_thread == &_tx_timer_thread)
34199280:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34199282:	4a1e      	ldr	r2, [pc, #120]	@ (341992fc <_txe_thread_create+0x1dc>)
34199284:	4293      	cmp	r3, r2
34199286:	d101      	bne.n	3419928c <_txe_thread_create+0x16c>
            {

                /* Invalid caller of this function, return appropriate error code.  */
                status =  TX_CALLER_ERROR;
34199288:	2313      	movs	r3, #19
3419928a:	64fb      	str	r3, [r7, #76]	@ 0x4c
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
3419928c:	f3ef 8305 	mrs	r3, IPSR
34199290:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
34199292:	697a      	ldr	r2, [r7, #20]
            }
#endif

            /* Check for interrupt call.  */
            if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
34199294:	4b1a      	ldr	r3, [pc, #104]	@ (34199300 <_txe_thread_create+0x1e0>)
34199296:	681b      	ldr	r3, [r3, #0]
34199298:	4313      	orrs	r3, r2
3419929a:	2b00      	cmp	r3, #0
3419929c:	d00b      	beq.n	341992b6 <_txe_thread_create+0x196>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
3419929e:	f3ef 8305 	mrs	r3, IPSR
341992a2:	613b      	str	r3, [r7, #16]
    return(ipsr_value);
341992a4:	693a      	ldr	r2, [r7, #16]
            {

                /* Now, make sure the call is from an interrupt and not initialization.  */
                if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
341992a6:	4b16      	ldr	r3, [pc, #88]	@ (34199300 <_txe_thread_create+0x1e0>)
341992a8:	681b      	ldr	r3, [r3, #0]
341992aa:	4313      	orrs	r3, r2
341992ac:	f1b3 3ff0 	cmp.w	r3, #4042322160	@ 0xf0f0f0f0
341992b0:	d201      	bcs.n	341992b6 <_txe_thread_create+0x196>
                {

                    /* Invalid caller of this function, return appropriate error code.  */
                    status =  TX_CALLER_ERROR;
341992b2:	2313      	movs	r3, #19
341992b4:	64fb      	str	r3, [r7, #76]	@ 0x4c
            }
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
341992b6:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
341992b8:	2b00      	cmp	r3, #0
341992ba:	d112      	bne.n	341992e2 <_txe_thread_create+0x1c2>
    {

        /* Call actual thread create function.  */
        status =  _tx_thread_create(thread_ptr, name_ptr, entry_function, entry_input,
341992bc:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
341992be:	9305      	str	r3, [sp, #20]
341992c0:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
341992c2:	9304      	str	r3, [sp, #16]
341992c4:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
341992c6:	9303      	str	r3, [sp, #12]
341992c8:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
341992ca:	9302      	str	r3, [sp, #8]
341992cc:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
341992ce:	9301      	str	r3, [sp, #4]
341992d0:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
341992d2:	9300      	str	r3, [sp, #0]
341992d4:	683b      	ldr	r3, [r7, #0]
341992d6:	687a      	ldr	r2, [r7, #4]
341992d8:	68b9      	ldr	r1, [r7, #8]
341992da:	68f8      	ldr	r0, [r7, #12]
341992dc:	f7fd fe94 	bl	34197008 <_tx_thread_create>
341992e0:	64f8      	str	r0, [r7, #76]	@ 0x4c
                        stack_start, stack_size, priority, preempt_threshold,
                        time_slice, auto_start);
    }

    /* Return completion status.  */
    return(status);
341992e2:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
}
341992e4:	4618      	mov	r0, r3
341992e6:	3750      	adds	r7, #80	@ 0x50
341992e8:	46bd      	mov	sp, r7
341992ea:	bd80      	pop	{r7, pc}
341992ec:	341c2e84 	.word	0x341c2e84
341992f0:	341c2df4 	.word	0x341c2df4
341992f4:	341c2df8 	.word	0x341c2df8
341992f8:	341c2dec 	.word	0x341c2dec
341992fc:	341c2f34 	.word	0x341c2f34
34199300:	341c009c 	.word	0x341c009c

34199304 <_txe_thread_delete>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_thread_delete(TX_THREAD *thread_ptr)
{
34199304:	b580      	push	{r7, lr}
34199306:	b084      	sub	sp, #16
34199308:	af00      	add	r7, sp, #0
3419930a:	6078      	str	r0, [r7, #4]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
3419930c:	f3ef 8305 	mrs	r3, IPSR
34199310:	60bb      	str	r3, [r7, #8]
    return(ipsr_value);
34199312:	68ba      	ldr	r2, [r7, #8]

UINT        status;


    /* Check for invalid caller of this function.  */
    if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
34199314:	4b0f      	ldr	r3, [pc, #60]	@ (34199354 <_txe_thread_delete+0x50>)
34199316:	681b      	ldr	r3, [r3, #0]
34199318:	4313      	orrs	r3, r2
3419931a:	2b00      	cmp	r3, #0
3419931c:	d002      	beq.n	34199324 <_txe_thread_delete+0x20>
    {

        /* Invalid caller of this function, return appropriate error code.  */
        status =  TX_CALLER_ERROR;
3419931e:	2313      	movs	r3, #19
34199320:	60fb      	str	r3, [r7, #12]
34199322:	e011      	b.n	34199348 <_txe_thread_delete+0x44>
    }

    /* Check for an invalid thread pointer.  */
    else if (thread_ptr == TX_NULL)
34199324:	687b      	ldr	r3, [r7, #4]
34199326:	2b00      	cmp	r3, #0
34199328:	d102      	bne.n	34199330 <_txe_thread_delete+0x2c>
    {

        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
3419932a:	230e      	movs	r3, #14
3419932c:	60fb      	str	r3, [r7, #12]
3419932e:	e00b      	b.n	34199348 <_txe_thread_delete+0x44>
    }

    /* Now check for invalid thread ID.  */
    else if (thread_ptr -> tx_thread_id != TX_THREAD_ID)
34199330:	687b      	ldr	r3, [r7, #4]
34199332:	681b      	ldr	r3, [r3, #0]
34199334:	4a08      	ldr	r2, [pc, #32]	@ (34199358 <_txe_thread_delete+0x54>)
34199336:	4293      	cmp	r3, r2
34199338:	d002      	beq.n	34199340 <_txe_thread_delete+0x3c>
    {

        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
3419933a:	230e      	movs	r3, #14
3419933c:	60fb      	str	r3, [r7, #12]
3419933e:	e003      	b.n	34199348 <_txe_thread_delete+0x44>
    }
    else
    {

        /* Call actual thread delete function.  */
        status =  _tx_thread_delete(thread_ptr);
34199340:	6878      	ldr	r0, [r7, #4]
34199342:	f7fd ff57 	bl	341971f4 <_tx_thread_delete>
34199346:	60f8      	str	r0, [r7, #12]
    }

    /* Return completion status.  */
    return(status);
34199348:	68fb      	ldr	r3, [r7, #12]
}
3419934a:	4618      	mov	r0, r3
3419934c:	3710      	adds	r7, #16
3419934e:	46bd      	mov	sp, r7
34199350:	bd80      	pop	{r7, pc}
34199352:	bf00      	nop
34199354:	341c009c 	.word	0x341c009c
34199358:	54485244 	.word	0x54485244

3419935c <_txe_thread_info_get>:
/*                                                                        */
/**************************************************************************/
UINT  _txe_thread_info_get(TX_THREAD *thread_ptr, CHAR **name, UINT *state, ULONG *run_count,
                UINT *priority, UINT *preemption_threshold, ULONG *time_slice,
                TX_THREAD **next_thread, TX_THREAD **next_suspended_thread)
{
3419935c:	b580      	push	{r7, lr}
3419935e:	b08c      	sub	sp, #48	@ 0x30
34199360:	af06      	add	r7, sp, #24
34199362:	60f8      	str	r0, [r7, #12]
34199364:	60b9      	str	r1, [r7, #8]
34199366:	607a      	str	r2, [r7, #4]
34199368:	603b      	str	r3, [r7, #0]

UINT    status;


    /* Check for an invalid thread pointer.  */
    if (thread_ptr == TX_NULL)
3419936a:	68fb      	ldr	r3, [r7, #12]
3419936c:	2b00      	cmp	r3, #0
3419936e:	d102      	bne.n	34199376 <_txe_thread_info_get+0x1a>
    {

        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
34199370:	230e      	movs	r3, #14
34199372:	617b      	str	r3, [r7, #20]
34199374:	e018      	b.n	341993a8 <_txe_thread_info_get+0x4c>
    }

    /* Now check for invalid thread ID.  */
    else if (thread_ptr -> tx_thread_id != TX_THREAD_ID)
34199376:	68fb      	ldr	r3, [r7, #12]
34199378:	681b      	ldr	r3, [r3, #0]
3419937a:	4a0e      	ldr	r2, [pc, #56]	@ (341993b4 <_txe_thread_info_get+0x58>)
3419937c:	4293      	cmp	r3, r2
3419937e:	d002      	beq.n	34199386 <_txe_thread_info_get+0x2a>
    {

        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
34199380:	230e      	movs	r3, #14
34199382:	617b      	str	r3, [r7, #20]
34199384:	e010      	b.n	341993a8 <_txe_thread_info_get+0x4c>
    }
    else
    {

        /* Call the actual thread information get service.  */
        status =  _tx_thread_info_get(thread_ptr, name, state, run_count, priority, preemption_threshold,
34199386:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34199388:	9304      	str	r3, [sp, #16]
3419938a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3419938c:	9303      	str	r3, [sp, #12]
3419938e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34199390:	9302      	str	r3, [sp, #8]
34199392:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34199394:	9301      	str	r3, [sp, #4]
34199396:	6a3b      	ldr	r3, [r7, #32]
34199398:	9300      	str	r3, [sp, #0]
3419939a:	683b      	ldr	r3, [r7, #0]
3419939c:	687a      	ldr	r2, [r7, #4]
3419939e:	68b9      	ldr	r1, [r7, #8]
341993a0:	68f8      	ldr	r0, [r7, #12]
341993a2:	f7fd ff9f 	bl	341972e4 <_tx_thread_info_get>
341993a6:	6178      	str	r0, [r7, #20]
                            time_slice, next_thread, next_suspended_thread);
    }

    /* Return completion status.  */
    return(status);
341993a8:	697b      	ldr	r3, [r7, #20]
}
341993aa:	4618      	mov	r0, r3
341993ac:	3718      	adds	r7, #24
341993ae:	46bd      	mov	sp, r7
341993b0:	bd80      	pop	{r7, pc}
341993b2:	bf00      	nop
341993b4:	54485244 	.word	0x54485244

341993b8 <_txe_thread_relinquish>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _txe_thread_relinquish(VOID)
{
341993b8:	b580      	push	{r7, lr}
341993ba:	b082      	sub	sp, #8
341993bc:	af00      	add	r7, sp, #0

TX_THREAD   *current_thread;


    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(current_thread)
341993be:	4b0a      	ldr	r3, [pc, #40]	@ (341993e8 <_txe_thread_relinquish+0x30>)
341993c0:	681b      	ldr	r3, [r3, #0]
341993c2:	607b      	str	r3, [r7, #4]

    /* Make sure a thread is executing.  */
    if (current_thread != TX_NULL)
341993c4:	687b      	ldr	r3, [r7, #4]
341993c6:	2b00      	cmp	r3, #0
341993c8:	d00a      	beq.n	341993e0 <_txe_thread_relinquish+0x28>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
341993ca:	f3ef 8305 	mrs	r3, IPSR
341993ce:	603b      	str	r3, [r7, #0]
    return(ipsr_value);
341993d0:	683a      	ldr	r2, [r7, #0]
    {

        /* Now make sure the call is not from an ISR or Initialization.  */
        if (TX_THREAD_GET_SYSTEM_STATE() == ((ULONG) 0))
341993d2:	4b06      	ldr	r3, [pc, #24]	@ (341993ec <_txe_thread_relinquish+0x34>)
341993d4:	681b      	ldr	r3, [r3, #0]
341993d6:	4313      	orrs	r3, r2
341993d8:	2b00      	cmp	r3, #0
341993da:	d101      	bne.n	341993e0 <_txe_thread_relinquish+0x28>
        {

            /* Okay to call the real relinquish function.  */
            _tx_thread_relinquish();
341993dc:	f7fe f816 	bl	3419740c <_tx_thread_relinquish>
        }
    }
}
341993e0:	bf00      	nop
341993e2:	3708      	adds	r7, #8
341993e4:	46bd      	mov	sp, r7
341993e6:	bd80      	pop	{r7, pc}
341993e8:	341c2dec 	.word	0x341c2dec
341993ec:	341c009c 	.word	0x341c009c

341993f0 <_txe_thread_resume>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_thread_resume(TX_THREAD *thread_ptr)
{
341993f0:	b580      	push	{r7, lr}
341993f2:	b084      	sub	sp, #16
341993f4:	af00      	add	r7, sp, #0
341993f6:	6078      	str	r0, [r7, #4]

UINT    status;


    /* Check for an invalid thread pointer.  */
    if (thread_ptr == TX_NULL)
341993f8:	687b      	ldr	r3, [r7, #4]
341993fa:	2b00      	cmp	r3, #0
341993fc:	d102      	bne.n	34199404 <_txe_thread_resume+0x14>
    {

        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
341993fe:	230e      	movs	r3, #14
34199400:	60fb      	str	r3, [r7, #12]
34199402:	e00b      	b.n	3419941c <_txe_thread_resume+0x2c>
    }

    /* Now check for invalid thread ID.  */
    else if (thread_ptr -> tx_thread_id != TX_THREAD_ID)
34199404:	687b      	ldr	r3, [r7, #4]
34199406:	681b      	ldr	r3, [r3, #0]
34199408:	4a07      	ldr	r2, [pc, #28]	@ (34199428 <_txe_thread_resume+0x38>)
3419940a:	4293      	cmp	r3, r2
3419940c:	d002      	beq.n	34199414 <_txe_thread_resume+0x24>
    {

        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
3419940e:	230e      	movs	r3, #14
34199410:	60fb      	str	r3, [r7, #12]
34199412:	e003      	b.n	3419941c <_txe_thread_resume+0x2c>
    }
    else
    {

        /* Call actual thread resume function.  */
        status =  _tx_thread_resume(thread_ptr);
34199414:	6878      	ldr	r0, [r7, #4]
34199416:	f7fe f85f 	bl	341974d8 <_tx_thread_resume>
3419941a:	60f8      	str	r0, [r7, #12]
    }

    /* Return completion status.  */
    return(status);
3419941c:	68fb      	ldr	r3, [r7, #12]
}
3419941e:	4618      	mov	r0, r3
34199420:	3710      	adds	r7, #16
34199422:	46bd      	mov	sp, r7
34199424:	bd80      	pop	{r7, pc}
34199426:	bf00      	nop
34199428:	54485244 	.word	0x54485244

3419942c <_txe_thread_suspend>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_thread_suspend(TX_THREAD *thread_ptr)
{
3419942c:	b580      	push	{r7, lr}
3419942e:	b084      	sub	sp, #16
34199430:	af00      	add	r7, sp, #0
34199432:	6078      	str	r0, [r7, #4]

UINT    status;


    /* Check for an invalid thread pointer.  */
    if (thread_ptr == TX_NULL)
34199434:	687b      	ldr	r3, [r7, #4]
34199436:	2b00      	cmp	r3, #0
34199438:	d102      	bne.n	34199440 <_txe_thread_suspend+0x14>
    {

        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
3419943a:	230e      	movs	r3, #14
3419943c:	60fb      	str	r3, [r7, #12]
3419943e:	e00b      	b.n	34199458 <_txe_thread_suspend+0x2c>
    }

    /* Now check for invalid thread ID.  */
    else if (thread_ptr -> tx_thread_id != TX_THREAD_ID)
34199440:	687b      	ldr	r3, [r7, #4]
34199442:	681b      	ldr	r3, [r3, #0]
34199444:	4a07      	ldr	r2, [pc, #28]	@ (34199464 <_txe_thread_suspend+0x38>)
34199446:	4293      	cmp	r3, r2
34199448:	d002      	beq.n	34199450 <_txe_thread_suspend+0x24>
    {

        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
3419944a:	230e      	movs	r3, #14
3419944c:	60fb      	str	r3, [r7, #12]
3419944e:	e003      	b.n	34199458 <_txe_thread_suspend+0x2c>
    }
    else
    {

        /* Call actual thread suspend function.  */
        status =  _tx_thread_suspend(thread_ptr);
34199450:	6878      	ldr	r0, [r7, #4]
34199452:	f7fe f96d 	bl	34197730 <_tx_thread_suspend>
34199456:	60f8      	str	r0, [r7, #12]
    }

    /* Return completion status.  */
    return(status);
34199458:	68fb      	ldr	r3, [r7, #12]
}
3419945a:	4618      	mov	r0, r3
3419945c:	3710      	adds	r7, #16
3419945e:	46bd      	mov	sp, r7
34199460:	bd80      	pop	{r7, pc}
34199462:	bf00      	nop
34199464:	54485244 	.word	0x54485244

34199468 <_txe_thread_terminate>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_thread_terminate(TX_THREAD *thread_ptr)
{
34199468:	b580      	push	{r7, lr}
3419946a:	b084      	sub	sp, #16
3419946c:	af00      	add	r7, sp, #0
3419946e:	6078      	str	r0, [r7, #4]

UINT        status;


    /* Check for an invalid thread pointer.  */
    if (thread_ptr == TX_NULL)
34199470:	687b      	ldr	r3, [r7, #4]
34199472:	2b00      	cmp	r3, #0
34199474:	d102      	bne.n	3419947c <_txe_thread_terminate+0x14>
    {

        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
34199476:	230e      	movs	r3, #14
34199478:	60fb      	str	r3, [r7, #12]
3419947a:	e017      	b.n	341994ac <_txe_thread_terminate+0x44>
    }

    /* Now check for invalid thread ID.  */
    else if (thread_ptr -> tx_thread_id != TX_THREAD_ID)
3419947c:	687b      	ldr	r3, [r7, #4]
3419947e:	681b      	ldr	r3, [r3, #0]
34199480:	4a0d      	ldr	r2, [pc, #52]	@ (341994b8 <_txe_thread_terminate+0x50>)
34199482:	4293      	cmp	r3, r2
34199484:	d002      	beq.n	3419948c <_txe_thread_terminate+0x24>
    {

        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
34199486:	230e      	movs	r3, #14
34199488:	60fb      	str	r3, [r7, #12]
3419948a:	e00f      	b.n	341994ac <_txe_thread_terminate+0x44>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
3419948c:	f3ef 8305 	mrs	r3, IPSR
34199490:	60bb      	str	r3, [r7, #8]
    return(ipsr_value);
34199492:	68ba      	ldr	r2, [r7, #8]
    }

    /* Check for invalid caller of this function.  */
    else if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
34199494:	4b09      	ldr	r3, [pc, #36]	@ (341994bc <_txe_thread_terminate+0x54>)
34199496:	681b      	ldr	r3, [r3, #0]
34199498:	4313      	orrs	r3, r2
3419949a:	2b00      	cmp	r3, #0
3419949c:	d002      	beq.n	341994a4 <_txe_thread_terminate+0x3c>
    {

        /* Invalid caller of this function, return appropriate error code.  */
        status =  TX_CALLER_ERROR;
3419949e:	2313      	movs	r3, #19
341994a0:	60fb      	str	r3, [r7, #12]
341994a2:	e003      	b.n	341994ac <_txe_thread_terminate+0x44>
    }
    else
    {

        /* Call actual thread terminate function.  */
        status =  _tx_thread_terminate(thread_ptr);
341994a4:	6878      	ldr	r0, [r7, #4]
341994a6:	f7fe fc05 	bl	34197cb4 <_tx_thread_terminate>
341994aa:	60f8      	str	r0, [r7, #12]
    }

    /* Return completion status.  */
    return(status);
341994ac:	68fb      	ldr	r3, [r7, #12]
}
341994ae:	4618      	mov	r0, r3
341994b0:	3710      	adds	r7, #16
341994b2:	46bd      	mov	sp, r7
341994b4:	bd80      	pop	{r7, pc}
341994b6:	bf00      	nop
341994b8:	54485244 	.word	0x54485244
341994bc:	341c009c 	.word	0x341c009c

341994c0 <_ux_system_error_handler>:
/*  09-30-2020     Chaoqiong Xiao           Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID   _ux_system_error_handler(UINT system_level, UINT system_context, UINT error_code)
{
341994c0:	b580      	push	{r7, lr}
341994c2:	b084      	sub	sp, #16
341994c4:	af00      	add	r7, sp, #0
341994c6:	60f8      	str	r0, [r7, #12]
341994c8:	60b9      	str	r1, [r7, #8]
341994ca:	607a      	str	r2, [r7, #4]

    /* Save the last system error code.  */
    _ux_system -> ux_system_last_error =  error_code;
341994cc:	4b0c      	ldr	r3, [pc, #48]	@ (34199500 <_ux_system_error_handler+0x40>)
341994ce:	681b      	ldr	r3, [r3, #0]
341994d0:	687a      	ldr	r2, [r7, #4]
341994d2:	641a      	str	r2, [r3, #64]	@ 0x40
 
    /* Increment the total number of system errors.  */
    _ux_system -> ux_system_error_count++;
341994d4:	4b0a      	ldr	r3, [pc, #40]	@ (34199500 <_ux_system_error_handler+0x40>)
341994d6:	681b      	ldr	r3, [r3, #0]
341994d8:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
341994da:	3201      	adds	r2, #1
341994dc:	645a      	str	r2, [r3, #68]	@ 0x44

    /* Is there an application call back function to call ? */
    if (_ux_system -> ux_system_error_callback_function != UX_NULL)
341994de:	4b08      	ldr	r3, [pc, #32]	@ (34199500 <_ux_system_error_handler+0x40>)
341994e0:	681b      	ldr	r3, [r3, #0]
341994e2:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
341994e4:	2b00      	cmp	r3, #0
341994e6:	d006      	beq.n	341994f6 <_ux_system_error_handler+0x36>
    {    

        /* The callback function is defined, call it.  */
        _ux_system -> ux_system_error_callback_function(system_level, system_context, error_code);
341994e8:	4b05      	ldr	r3, [pc, #20]	@ (34199500 <_ux_system_error_handler+0x40>)
341994ea:	681b      	ldr	r3, [r3, #0]
341994ec:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
341994ee:	687a      	ldr	r2, [r7, #4]
341994f0:	68b9      	ldr	r1, [r7, #8]
341994f2:	68f8      	ldr	r0, [r7, #12]
341994f4:	4798      	blx	r3
    }
}
341994f6:	bf00      	nop
341994f8:	3710      	adds	r7, #16
341994fa:	46bd      	mov	sp, r7
341994fc:	bd80      	pop	{r7, pc}
341994fe:	bf00      	nop
34199500:	341c33f4 	.word	0x341c33f4

34199504 <_ux_system_initialize>:
/*                                            resulting in version 6.3.0  */
/*                                                                        */
/**************************************************************************/
UINT  _ux_system_initialize(VOID *regular_memory_pool_start, ULONG regular_memory_size,
                            VOID *cache_safe_memory_pool_start, ULONG cache_safe_memory_size)
{
34199504:	b580      	push	{r7, lr}
34199506:	b08a      	sub	sp, #40	@ 0x28
34199508:	af00      	add	r7, sp, #0
3419950a:	60f8      	str	r0, [r7, #12]
3419950c:	60b9      	str	r1, [r7, #8]
3419950e:	607a      	str	r2, [r7, #4]
34199510:	603b      	str	r3, [r7, #0]
UINT                status;
#endif
ULONG               pool_size;

    /* Check if the regular memory pool is valid.  */
    if ((regular_memory_pool_start == UX_NULL) || (regular_memory_size == 0))
34199512:	68fb      	ldr	r3, [r7, #12]
34199514:	2b00      	cmp	r3, #0
34199516:	d002      	beq.n	3419951e <_ux_system_initialize+0x1a>
34199518:	68bb      	ldr	r3, [r7, #8]
3419951a:	2b00      	cmp	r3, #0
3419951c:	d101      	bne.n	34199522 <_ux_system_initialize+0x1e>
        return(UX_INVALID_PARAMETER);
3419951e:	23fa      	movs	r3, #250	@ 0xfa
34199520:	e08a      	b.n	34199638 <_ux_system_initialize+0x134>

    /* Reset memory block */
    _ux_utility_memory_set(regular_memory_pool_start, 0, regular_memory_size); /* Use case of memset is verified. */
34199522:	68ba      	ldr	r2, [r7, #8]
34199524:	2100      	movs	r1, #0
34199526:	68f8      	ldr	r0, [r7, #12]
34199528:	f000 fc5e 	bl	34199de8 <_ux_utility_memory_set>

    /* Set the _ux_system structure at the start of our regular memory */
    _ux_system =  (UX_SYSTEM *) regular_memory_pool_start;
3419952c:	4a44      	ldr	r2, [pc, #272]	@ (34199640 <_ux_system_initialize+0x13c>)
3419952e:	68fb      	ldr	r3, [r7, #12]
34199530:	6013      	str	r3, [r2, #0]

    /* Add to the memory offset the size of the allocated block.  */
    memory_pool_offset = sizeof(UX_SYSTEM);
34199532:	234c      	movs	r3, #76	@ 0x4c
34199534:	627b      	str	r3, [r7, #36]	@ 0x24
#endif

#ifndef UX_HOST_SIDE_ONLY

    /* Set the _ux_system_slave structure.  */
    _ux_system_slave =  (UX_SYSTEM_SLAVE *) (((UCHAR *) regular_memory_pool_start) + memory_pool_offset);
34199536:	68fa      	ldr	r2, [r7, #12]
34199538:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419953a:	4413      	add	r3, r2
3419953c:	4a41      	ldr	r2, [pc, #260]	@ (34199644 <_ux_system_initialize+0x140>)
3419953e:	6013      	str	r3, [r2, #0]

    /* Add to the memory offset the size of the allocated block.  */
    memory_pool_offset += (ULONG)sizeof(UX_SYSTEM_SLAVE);
34199540:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34199542:	f503 73c2 	add.w	r3, r3, #388	@ 0x184
34199546:	627b      	str	r3, [r7, #36]	@ 0x24
    /* Add to the memory offset the size of the allocated block.  */
    memory_pool_offset += (ULONG)sizeof(UX_SYSTEM_OTG);
#endif

    /* Set the regular memory pool structure.  */
    _ux_system -> ux_system_memory_byte_pool[UX_MEMORY_BYTE_POOL_REGULAR] = (UX_MEMORY_BYTE_POOL *) (((UCHAR *) regular_memory_pool_start) + memory_pool_offset);
34199548:	4b3d      	ldr	r3, [pc, #244]	@ (34199640 <_ux_system_initialize+0x13c>)
3419954a:	681b      	ldr	r3, [r3, #0]
3419954c:	68f9      	ldr	r1, [r7, #12]
3419954e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
34199550:	440a      	add	r2, r1
34199552:	601a      	str	r2, [r3, #0]

    /* Add to the memory offset the size of the allocated block.  */
    memory_pool_offset += (ULONG)sizeof(UX_MEMORY_BYTE_POOL);
34199554:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34199556:	3314      	adds	r3, #20
34199558:	627b      	str	r3, [r7, #36]	@ 0x24

    /* Check if the cache save memory pool is valid.  */
    if ((cache_safe_memory_pool_start != UX_NULL) && (cache_safe_memory_size != 0))
3419955a:	687b      	ldr	r3, [r7, #4]
3419955c:	2b00      	cmp	r3, #0
3419955e:	d00c      	beq.n	3419957a <_ux_system_initialize+0x76>
34199560:	683b      	ldr	r3, [r7, #0]
34199562:	2b00      	cmp	r3, #0
34199564:	d009      	beq.n	3419957a <_ux_system_initialize+0x76>
    {

        /* Set the cache safe memory pool structure.  */
        _ux_system -> ux_system_memory_byte_pool[UX_MEMORY_BYTE_POOL_CACHE_SAFE] = (UX_MEMORY_BYTE_POOL *) (((UCHAR *) regular_memory_pool_start) + memory_pool_offset);
34199566:	4b36      	ldr	r3, [pc, #216]	@ (34199640 <_ux_system_initialize+0x13c>)
34199568:	681b      	ldr	r3, [r3, #0]
3419956a:	68f9      	ldr	r1, [r7, #12]
3419956c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
3419956e:	440a      	add	r2, r1
34199570:	605a      	str	r2, [r3, #4]

        /* Add to the memory offset the size of the allocated block.  */
        memory_pool_offset += (ULONG)sizeof(UX_MEMORY_BYTE_POOL);
34199572:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34199574:	3314      	adds	r3, #20
34199576:	627b      	str	r3, [r7, #36]	@ 0x24
34199578:	e005      	b.n	34199586 <_ux_system_initialize+0x82>
    }
    else
    {

        /* Set the cache safe memory pool structure to regular pool. */
        _ux_system -> ux_system_memory_byte_pool[UX_MEMORY_BYTE_POOL_CACHE_SAFE] = _ux_system -> ux_system_memory_byte_pool[UX_MEMORY_BYTE_POOL_REGULAR];
3419957a:	4b31      	ldr	r3, [pc, #196]	@ (34199640 <_ux_system_initialize+0x13c>)
3419957c:	681a      	ldr	r2, [r3, #0]
3419957e:	4b30      	ldr	r3, [pc, #192]	@ (34199640 <_ux_system_initialize+0x13c>)
34199580:	681b      	ldr	r3, [r3, #0]
34199582:	6812      	ldr	r2, [r2, #0]
34199584:	605a      	str	r2, [r3, #4]
    }

    /* Make sure the regular memory pool is aligned properly */
    int_memory_pool_start = (ALIGN_TYPE) (((UCHAR *) regular_memory_pool_start) + memory_pool_offset);
34199586:	68fa      	ldr	r2, [r7, #12]
34199588:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419958a:	4413      	add	r3, r2
3419958c:	623b      	str	r3, [r7, #32]
    int_memory_pool_start += UX_ALIGN_MIN;
3419958e:	6a3b      	ldr	r3, [r7, #32]
34199590:	3307      	adds	r3, #7
34199592:	623b      	str	r3, [r7, #32]
    int_memory_pool_start &= ~((ALIGN_TYPE)UX_ALIGN_MIN);
34199594:	6a3b      	ldr	r3, [r7, #32]
34199596:	f023 0307 	bic.w	r3, r3, #7
3419959a:	623b      	str	r3, [r7, #32]

    /* Set the end of the regular memory pool.  */
    regular_memory_pool_end =  (void *) (((UCHAR *) regular_memory_pool_start) + regular_memory_size);
3419959c:	68fa      	ldr	r2, [r7, #12]
3419959e:	68bb      	ldr	r3, [r7, #8]
341995a0:	4413      	add	r3, r2
341995a2:	61fb      	str	r3, [r7, #28]

    /* Check if we have memory available.  */
    if (int_memory_pool_start >= (ALIGN_TYPE)regular_memory_pool_end)
341995a4:	69fb      	ldr	r3, [r7, #28]
341995a6:	6a3a      	ldr	r2, [r7, #32]
341995a8:	429a      	cmp	r2, r3
341995aa:	d301      	bcc.n	341995b0 <_ux_system_initialize+0xac>
    {

        /* No memory available.  */
        return(UX_MEMORY_INSUFFICIENT);
341995ac:	2312      	movs	r3, #18
341995ae:	e043      	b.n	34199638 <_ux_system_initialize+0x134>
    }

    /* get the regular memory pool size.  */
    pool_size = (ULONG) (((ALIGN_TYPE) regular_memory_pool_end) - int_memory_pool_start);
341995b0:	69fa      	ldr	r2, [r7, #28]
341995b2:	6a3b      	ldr	r3, [r7, #32]
341995b4:	1ad3      	subs	r3, r2, r3
341995b6:	61bb      	str	r3, [r7, #24]

    /* Create the regular memory pool.  */
    _ux_utility_memory_byte_pool_create(_ux_system -> ux_system_memory_byte_pool[UX_MEMORY_BYTE_POOL_REGULAR],
341995b8:	4b21      	ldr	r3, [pc, #132]	@ (34199640 <_ux_system_initialize+0x13c>)
341995ba:	681b      	ldr	r3, [r3, #0]
341995bc:	681b      	ldr	r3, [r3, #0]
341995be:	6a39      	ldr	r1, [r7, #32]
341995c0:	69ba      	ldr	r2, [r7, #24]
341995c2:	4618      	mov	r0, r3
341995c4:	f000 fa82 	bl	34199acc <_ux_utility_memory_byte_pool_create>
                                        (UX_MEMORY_BYTE_POOL *)int_memory_pool_start,
                                        pool_size);

    /* Check the definition of the cache safe pool. If the application or controller do not require any cache safe memory,
       define the cached safe memory region as the regular memory region.  */
    if ((cache_safe_memory_pool_start != UX_NULL) && (cache_safe_memory_size != 0))
341995c8:	687b      	ldr	r3, [r7, #4]
341995ca:	2b00      	cmp	r3, #0
341995cc:	d026      	beq.n	3419961c <_ux_system_initialize+0x118>
341995ce:	683b      	ldr	r3, [r7, #0]
341995d0:	2b00      	cmp	r3, #0
341995d2:	d023      	beq.n	3419961c <_ux_system_initialize+0x118>
    {

        /* Reset this memory block */
        _ux_utility_memory_set(cache_safe_memory_pool_start, 0, cache_safe_memory_size); /* Use case of memset is verified. */
341995d4:	683a      	ldr	r2, [r7, #0]
341995d6:	2100      	movs	r1, #0
341995d8:	6878      	ldr	r0, [r7, #4]
341995da:	f000 fc05 	bl	34199de8 <_ux_utility_memory_set>

        /* Make sure the cache safe memory pool is aligned properly */
        int_memory_pool_start =   (ALIGN_TYPE) cache_safe_memory_pool_start;
341995de:	687b      	ldr	r3, [r7, #4]
341995e0:	623b      	str	r3, [r7, #32]
        int_memory_pool_start +=  UX_ALIGN_MIN;
341995e2:	6a3b      	ldr	r3, [r7, #32]
341995e4:	3307      	adds	r3, #7
341995e6:	623b      	str	r3, [r7, #32]
        int_memory_pool_start &=  ~((ALIGN_TYPE)UX_ALIGN_MIN);
341995e8:	6a3b      	ldr	r3, [r7, #32]
341995ea:	f023 0307 	bic.w	r3, r3, #7
341995ee:	623b      	str	r3, [r7, #32]

        cache_safe_memory_pool_end =  (void *) (((UCHAR *) cache_safe_memory_pool_start) + cache_safe_memory_size);
341995f0:	687a      	ldr	r2, [r7, #4]
341995f2:	683b      	ldr	r3, [r7, #0]
341995f4:	4413      	add	r3, r2
341995f6:	617b      	str	r3, [r7, #20]

        /* Check if we have memory available.  */
        if (int_memory_pool_start >= (ALIGN_TYPE) cache_safe_memory_pool_end)
341995f8:	697b      	ldr	r3, [r7, #20]
341995fa:	6a3a      	ldr	r2, [r7, #32]
341995fc:	429a      	cmp	r2, r3
341995fe:	d301      	bcc.n	34199604 <_ux_system_initialize+0x100>
        {

            /* No memory available.  */
            return(UX_MEMORY_INSUFFICIENT);
34199600:	2312      	movs	r3, #18
34199602:	e019      	b.n	34199638 <_ux_system_initialize+0x134>
        }

        pool_size = (ULONG) (((ALIGN_TYPE) cache_safe_memory_pool_end) - int_memory_pool_start);
34199604:	697a      	ldr	r2, [r7, #20]
34199606:	6a3b      	ldr	r3, [r7, #32]
34199608:	1ad3      	subs	r3, r2, r3
3419960a:	61bb      	str	r3, [r7, #24]

        _ux_utility_memory_byte_pool_create(_ux_system -> ux_system_memory_byte_pool[UX_MEMORY_BYTE_POOL_CACHE_SAFE],
3419960c:	4b0c      	ldr	r3, [pc, #48]	@ (34199640 <_ux_system_initialize+0x13c>)
3419960e:	681b      	ldr	r3, [r3, #0]
34199610:	685b      	ldr	r3, [r3, #4]
34199612:	6a39      	ldr	r1, [r7, #32]
34199614:	69ba      	ldr	r2, [r7, #24]
34199616:	4618      	mov	r0, r3
34199618:	f000 fa58 	bl	34199acc <_ux_utility_memory_byte_pool_create>
#endif

#if !defined(UX_STANDALONE)

    /* Create the Mutex object used by USBX to control critical sections.  */
    status =  _ux_system_mutex_create(&_ux_system -> ux_system_mutex, "ux_system_mutex");
3419961c:	4b08      	ldr	r3, [pc, #32]	@ (34199640 <_ux_system_initialize+0x13c>)
3419961e:	681b      	ldr	r3, [r3, #0]
34199620:	330c      	adds	r3, #12
34199622:	4909      	ldr	r1, [pc, #36]	@ (34199648 <_ux_system_initialize+0x144>)
34199624:	4618      	mov	r0, r3
34199626:	f000 fbf9 	bl	34199e1c <_ux_utility_mutex_create>
3419962a:	6138      	str	r0, [r7, #16]
    if(status != UX_SUCCESS)
3419962c:	693b      	ldr	r3, [r7, #16]
3419962e:	2b00      	cmp	r3, #0
34199630:	d001      	beq.n	34199636 <_ux_system_initialize+0x132>
        return(UX_MUTEX_ERROR);
34199632:	2317      	movs	r3, #23
34199634:	e000      	b.n	34199638 <_ux_system_initialize+0x134>
#endif

    return(UX_SUCCESS);
34199636:	2300      	movs	r3, #0
}
34199638:	4618      	mov	r0, r3
3419963a:	3728      	adds	r7, #40	@ 0x28
3419963c:	46bd      	mov	sp, r7
3419963e:	bd80      	pop	{r7, pc}
34199640:	341c33f4 	.word	0x341c33f4
34199644:	341c33f8 	.word	0x341c33f8
34199648:	3419e304 	.word	0x3419e304

3419964c <_uxe_system_initialize>:
/*  10-31-2023     Chaoqiong Xiao           Initial Version 6.3.0         */
/*                                                                        */
/**************************************************************************/
UINT  _uxe_system_initialize(VOID *regular_memory_pool_start, ULONG regular_memory_size,
                            VOID *cache_safe_memory_pool_start, ULONG cache_safe_memory_size)
{
3419964c:	b580      	push	{r7, lr}
3419964e:	b084      	sub	sp, #16
34199650:	af00      	add	r7, sp, #0
34199652:	60f8      	str	r0, [r7, #12]
34199654:	60b9      	str	r1, [r7, #8]
34199656:	607a      	str	r2, [r7, #4]
34199658:	603b      	str	r3, [r7, #0]
    UX_ASSERT((_ux_utility_descriptor_parse_size(_ux_system_usb_2_0_extension_descriptor_structure, UX_USB_2_0_EXTENSION_DESCRIPTOR_ENTRIES, 0x3u)) == sizeof(UX_USB_2_0_EXTENSION_DESCRIPTOR));
    UX_ASSERT((_ux_utility_descriptor_parse_size(_ux_system_container_id_descriptor_structure, UX_CONTAINER_ID_DESCRIPTOR_ENTRIES, 0x3u)) == sizeof(UX_CONTAINER_ID_DESCRIPTOR));


    /* Sanity check.  */
    if ((regular_memory_pool_start == UX_NULL) || (regular_memory_size == 0))
3419965a:	68fb      	ldr	r3, [r7, #12]
3419965c:	2b00      	cmp	r3, #0
3419965e:	d002      	beq.n	34199666 <_uxe_system_initialize+0x1a>
34199660:	68bb      	ldr	r3, [r7, #8]
34199662:	2b00      	cmp	r3, #0
34199664:	d101      	bne.n	3419966a <_uxe_system_initialize+0x1e>
            return(UX_INVALID_PARAMETER);
34199666:	23fa      	movs	r3, #250	@ 0xfa
34199668:	e006      	b.n	34199678 <_uxe_system_initialize+0x2c>

    /* Invoke system initialization function.  */
    return(_ux_system_initialize(regular_memory_pool_start, regular_memory_size,
3419966a:	683b      	ldr	r3, [r7, #0]
3419966c:	687a      	ldr	r2, [r7, #4]
3419966e:	68b9      	ldr	r1, [r7, #8]
34199670:	68f8      	ldr	r0, [r7, #12]
34199672:	f7ff ff47 	bl	34199504 <_ux_system_initialize>
34199676:	4603      	mov	r3, r0
                                 cache_safe_memory_pool_start, cache_safe_memory_size));
}
34199678:	4618      	mov	r0, r3
3419967a:	3710      	adds	r7, #16
3419967c:	46bd      	mov	sp, r7
3419967e:	bd80      	pop	{r7, pc}

34199680 <_ux_utility_delay_ms>:
/*                                            added standalone support,   */
/*                                            resulting in version 6.1.10 */
/*                                                                        */
/**************************************************************************/
VOID  _ux_utility_delay_ms(ULONG ms_wait)
{
34199680:	b580      	push	{r7, lr}
34199682:	b084      	sub	sp, #16
34199684:	af00      	add	r7, sp, #0
34199686:	6078      	str	r0, [r7, #4]
    while(_ux_utility_time_elapsed(ticks, _ux_utility_time_get()) <
            UX_MS_TO_TICK_NON_ZERO(ms_wait));
#else

    /* translate ms into ticks. */
    ticks = (ULONG)(ms_wait * UX_PERIODIC_RATE) / 1000;
34199688:	687b      	ldr	r3, [r7, #4]
3419968a:	2264      	movs	r2, #100	@ 0x64
3419968c:	fb02 f303 	mul.w	r3, r2, r3
34199690:	4a07      	ldr	r2, [pc, #28]	@ (341996b0 <_ux_utility_delay_ms+0x30>)
34199692:	fba2 2303 	umull	r2, r3, r2, r3
34199696:	099b      	lsrs	r3, r3, #6
34199698:	60fb      	str	r3, [r7, #12]
    
    /* For safety add 1 to ticks.  */
    ticks++;
3419969a:	68fb      	ldr	r3, [r7, #12]
3419969c:	3301      	adds	r3, #1
3419969e:	60fb      	str	r3, [r7, #12]

    /* Call ThreadX sleep function.  */
    tx_thread_sleep(ticks);
341996a0:	68f8      	ldr	r0, [r7, #12]
341996a2:	f7fd ffc5 	bl	34197630 <_tx_thread_sleep>
#endif

    /* Return completion status.  */
    return;
341996a6:	bf00      	nop
}
341996a8:	3710      	adds	r7, #16
341996aa:	46bd      	mov	sp, r7
341996ac:	bd80      	pop	{r7, pc}
341996ae:	bf00      	nop
341996b0:	10624dd3 	.word	0x10624dd3

341996b4 <_ux_utility_descriptor_parse>:
/*                                            resulting in version 6.3.0  */
/*                                                                        */
/**************************************************************************/
VOID  _ux_utility_descriptor_parse(UCHAR * raw_descriptor, UCHAR * descriptor_structure,
                        UINT descriptor_entries, UCHAR * descriptor)
{
341996b4:	b580      	push	{r7, lr}
341996b6:	b084      	sub	sp, #16
341996b8:	af00      	add	r7, sp, #0
341996ba:	60f8      	str	r0, [r7, #12]
341996bc:	60b9      	str	r1, [r7, #8]
341996be:	607a      	str	r2, [r7, #4]
341996c0:	603b      	str	r3, [r7, #0]

    /* Loop on all the entries in this descriptor.  */
    while(descriptor_entries--)
341996c2:	e041      	b.n	34199748 <_ux_utility_descriptor_parse+0x94>
    {

        /* Get the length of that component.  */
        switch(*descriptor_structure++)
341996c4:	68bb      	ldr	r3, [r7, #8]
341996c6:	1c5a      	adds	r2, r3, #1
341996c8:	60ba      	str	r2, [r7, #8]
341996ca:	781b      	ldrb	r3, [r3, #0]
341996cc:	2b02      	cmp	r3, #2
341996ce:	d01e      	beq.n	3419970e <_ux_utility_descriptor_parse+0x5a>
341996d0:	2b04      	cmp	r3, #4
341996d2:	d12f      	bne.n	34199734 <_ux_utility_descriptor_parse+0x80>
        /* Check the size then build the component from the source and
           insert it into the target descriptor.  */
        case 4:

            /* Padding zeros so address is aligned.  */
            while((ALIGN_TYPE) descriptor & 3u)
341996d4:	e004      	b.n	341996e0 <_ux_utility_descriptor_parse+0x2c>
                *descriptor++ =  0;
341996d6:	683b      	ldr	r3, [r7, #0]
341996d8:	1c5a      	adds	r2, r3, #1
341996da:	603a      	str	r2, [r7, #0]
341996dc:	2200      	movs	r2, #0
341996de:	701a      	strb	r2, [r3, #0]
            while((ALIGN_TYPE) descriptor & 3u)
341996e0:	683b      	ldr	r3, [r7, #0]
341996e2:	f003 0303 	and.w	r3, r3, #3
341996e6:	2b00      	cmp	r3, #0
341996e8:	d1f5      	bne.n	341996d6 <_ux_utility_descriptor_parse+0x22>

            /* Save the DW.  */
            *((ULONG *) descriptor) =  _ux_utility_long_get(raw_descriptor);
341996ea:	68f8      	ldr	r0, [r7, #12]
341996ec:	f000 f835 	bl	3419975a <_ux_utility_long_get>
341996f0:	4602      	mov	r2, r0
341996f2:	683b      	ldr	r3, [r7, #0]
341996f4:	601a      	str	r2, [r3, #0]
            raw_descriptor +=  4;
341996f6:	68fb      	ldr	r3, [r7, #12]
341996f8:	3304      	adds	r3, #4
341996fa:	60fb      	str	r3, [r7, #12]
            descriptor += 4;
341996fc:	683b      	ldr	r3, [r7, #0]
341996fe:	3304      	adds	r3, #4
34199700:	603b      	str	r3, [r7, #0]
            break;
34199702:	e021      	b.n	34199748 <_ux_utility_descriptor_parse+0x94>

        case 2:

            /* Padding zeros so address is aligned.  */
            while((ALIGN_TYPE) descriptor & 1u)
                *descriptor++ =  0;
34199704:	683b      	ldr	r3, [r7, #0]
34199706:	1c5a      	adds	r2, r3, #1
34199708:	603a      	str	r2, [r7, #0]
3419970a:	2200      	movs	r2, #0
3419970c:	701a      	strb	r2, [r3, #0]
            while((ALIGN_TYPE) descriptor & 1u)
3419970e:	683b      	ldr	r3, [r7, #0]
34199710:	f003 0301 	and.w	r3, r3, #1
34199714:	2b00      	cmp	r3, #0
34199716:	d1f5      	bne.n	34199704 <_ux_utility_descriptor_parse+0x50>

            /* Save the word.  */
            *((USHORT *) descriptor) = (USHORT) _ux_utility_short_get(raw_descriptor);
34199718:	68f8      	ldr	r0, [r7, #12]
3419971a:	f000 fc26 	bl	34199f6a <_ux_utility_short_get>
3419971e:	4603      	mov	r3, r0
34199720:	b29a      	uxth	r2, r3
34199722:	683b      	ldr	r3, [r7, #0]
34199724:	801a      	strh	r2, [r3, #0]
            raw_descriptor += 2;
34199726:	68fb      	ldr	r3, [r7, #12]
34199728:	3302      	adds	r3, #2
3419972a:	60fb      	str	r3, [r7, #12]
            descriptor += 2;
3419972c:	683b      	ldr	r3, [r7, #0]
3419972e:	3302      	adds	r3, #2
34199730:	603b      	str	r3, [r7, #0]
            break;
34199732:	e009      	b.n	34199748 <_ux_utility_descriptor_parse+0x94>

        default:

            /* Save the byte.  */
            *((UCHAR *) descriptor) =  (UCHAR) *raw_descriptor;
34199734:	68fb      	ldr	r3, [r7, #12]
34199736:	781a      	ldrb	r2, [r3, #0]
34199738:	683b      	ldr	r3, [r7, #0]
3419973a:	701a      	strb	r2, [r3, #0]
            raw_descriptor++;
3419973c:	68fb      	ldr	r3, [r7, #12]
3419973e:	3301      	adds	r3, #1
34199740:	60fb      	str	r3, [r7, #12]
            descriptor ++;
34199742:	683b      	ldr	r3, [r7, #0]
34199744:	3301      	adds	r3, #1
34199746:	603b      	str	r3, [r7, #0]
    while(descriptor_entries--)
34199748:	687b      	ldr	r3, [r7, #4]
3419974a:	1e5a      	subs	r2, r3, #1
3419974c:	607a      	str	r2, [r7, #4]
3419974e:	2b00      	cmp	r3, #0
34199750:	d1b8      	bne.n	341996c4 <_ux_utility_descriptor_parse+0x10>
        }
    }

    /* Return to caller.  */
    return;
34199752:	bf00      	nop
}
34199754:	3710      	adds	r7, #16
34199756:	46bd      	mov	sp, r7
34199758:	bd80      	pop	{r7, pc}

3419975a <_ux_utility_long_get>:
/*  09-30-2020     Chaoqiong Xiao           Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
ULONG  _ux_utility_long_get(UCHAR * address)
{
3419975a:	b480      	push	{r7}
3419975c:	b085      	sub	sp, #20
3419975e:	af00      	add	r7, sp, #0
34199760:	6078      	str	r0, [r7, #4]
ULONG    value;


    /* In order to make this function endian agnostic and memory alignment
       independent, we read a byte at a time from the address.  */
    value =   (ULONG) *address++;
34199762:	687b      	ldr	r3, [r7, #4]
34199764:	1c5a      	adds	r2, r3, #1
34199766:	607a      	str	r2, [r7, #4]
34199768:	781b      	ldrb	r3, [r3, #0]
3419976a:	60fb      	str	r3, [r7, #12]
    value |=  (ULONG)*address++ << 8;
3419976c:	687b      	ldr	r3, [r7, #4]
3419976e:	1c5a      	adds	r2, r3, #1
34199770:	607a      	str	r2, [r7, #4]
34199772:	781b      	ldrb	r3, [r3, #0]
34199774:	021b      	lsls	r3, r3, #8
34199776:	68fa      	ldr	r2, [r7, #12]
34199778:	4313      	orrs	r3, r2
3419977a:	60fb      	str	r3, [r7, #12]
    value |=  (ULONG)*address++ << 16;
3419977c:	687b      	ldr	r3, [r7, #4]
3419977e:	1c5a      	adds	r2, r3, #1
34199780:	607a      	str	r2, [r7, #4]
34199782:	781b      	ldrb	r3, [r3, #0]
34199784:	041b      	lsls	r3, r3, #16
34199786:	68fa      	ldr	r2, [r7, #12]
34199788:	4313      	orrs	r3, r2
3419978a:	60fb      	str	r3, [r7, #12]
    value |=  (ULONG)*address << 24;
3419978c:	687b      	ldr	r3, [r7, #4]
3419978e:	781b      	ldrb	r3, [r3, #0]
34199790:	061b      	lsls	r3, r3, #24
34199792:	68fa      	ldr	r2, [r7, #12]
34199794:	4313      	orrs	r3, r2
34199796:	60fb      	str	r3, [r7, #12]

    /* Return 32-bit value.  */
    return(value);
34199798:	68fb      	ldr	r3, [r7, #12]
}
3419979a:	4618      	mov	r0, r3
3419979c:	3714      	adds	r7, #20
3419979e:	46bd      	mov	sp, r7
341997a0:	f85d 7b04 	ldr.w	r7, [sp], #4
341997a4:	4770      	bx	lr

341997a6 <_ux_utility_long_get_big_endian>:
/*  09-30-2020     Chaoqiong Xiao           Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
ULONG  _ux_utility_long_get_big_endian(UCHAR * address)
{
341997a6:	b480      	push	{r7}
341997a8:	b085      	sub	sp, #20
341997aa:	af00      	add	r7, sp, #0
341997ac:	6078      	str	r0, [r7, #4]

ULONG  value;


    /* We read a byte at a time from the address.  */
    value =  (ULONG) ((*address++) << 24);
341997ae:	687b      	ldr	r3, [r7, #4]
341997b0:	1c5a      	adds	r2, r3, #1
341997b2:	607a      	str	r2, [r7, #4]
341997b4:	781b      	ldrb	r3, [r3, #0]
341997b6:	061b      	lsls	r3, r3, #24
341997b8:	60fb      	str	r3, [r7, #12]
    value |=  (ULONG) ((*address++) << 16);
341997ba:	687b      	ldr	r3, [r7, #4]
341997bc:	1c5a      	adds	r2, r3, #1
341997be:	607a      	str	r2, [r7, #4]
341997c0:	781b      	ldrb	r3, [r3, #0]
341997c2:	041b      	lsls	r3, r3, #16
341997c4:	68fa      	ldr	r2, [r7, #12]
341997c6:	4313      	orrs	r3, r2
341997c8:	60fb      	str	r3, [r7, #12]
    value |=  (ULONG) ((*address++) << 8);
341997ca:	687b      	ldr	r3, [r7, #4]
341997cc:	1c5a      	adds	r2, r3, #1
341997ce:	607a      	str	r2, [r7, #4]
341997d0:	781b      	ldrb	r3, [r3, #0]
341997d2:	021b      	lsls	r3, r3, #8
341997d4:	68fa      	ldr	r2, [r7, #12]
341997d6:	4313      	orrs	r3, r2
341997d8:	60fb      	str	r3, [r7, #12]
    value |=  (ULONG) *address;
341997da:	687b      	ldr	r3, [r7, #4]
341997dc:	781b      	ldrb	r3, [r3, #0]
341997de:	461a      	mov	r2, r3
341997e0:	68fb      	ldr	r3, [r7, #12]
341997e2:	4313      	orrs	r3, r2
341997e4:	60fb      	str	r3, [r7, #12]

    /* Return 32-bit value.  */
    return(value);
341997e6:	68fb      	ldr	r3, [r7, #12]
}
341997e8:	4618      	mov	r0, r3
341997ea:	3714      	adds	r7, #20
341997ec:	46bd      	mov	sp, r7
341997ee:	f85d 7b04 	ldr.w	r7, [sp], #4
341997f2:	4770      	bx	lr

341997f4 <_ux_utility_long_put>:
/*  09-30-2020     Chaoqiong Xiao           Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _ux_utility_long_put(UCHAR * address, ULONG value)
{
341997f4:	b480      	push	{r7}
341997f6:	b083      	sub	sp, #12
341997f8:	af00      	add	r7, sp, #0
341997fa:	6078      	str	r0, [r7, #4]
341997fc:	6039      	str	r1, [r7, #0]

    /* In order to make this function endian agnostic and memory alignment
       independent, we write a byte at a time from the address.  */
    *address++ =  (UCHAR) (value & 0xff);
341997fe:	687b      	ldr	r3, [r7, #4]
34199800:	1c5a      	adds	r2, r3, #1
34199802:	607a      	str	r2, [r7, #4]
34199804:	683a      	ldr	r2, [r7, #0]
34199806:	b2d2      	uxtb	r2, r2
34199808:	701a      	strb	r2, [r3, #0]
    *address++ =  (UCHAR) ((value >> 8) & 0xff);
3419980a:	683b      	ldr	r3, [r7, #0]
3419980c:	0a19      	lsrs	r1, r3, #8
3419980e:	687b      	ldr	r3, [r7, #4]
34199810:	1c5a      	adds	r2, r3, #1
34199812:	607a      	str	r2, [r7, #4]
34199814:	b2ca      	uxtb	r2, r1
34199816:	701a      	strb	r2, [r3, #0]
    *address++ =  (UCHAR) ((value >> 16) & 0xff);
34199818:	683b      	ldr	r3, [r7, #0]
3419981a:	0c19      	lsrs	r1, r3, #16
3419981c:	687b      	ldr	r3, [r7, #4]
3419981e:	1c5a      	adds	r2, r3, #1
34199820:	607a      	str	r2, [r7, #4]
34199822:	b2ca      	uxtb	r2, r1
34199824:	701a      	strb	r2, [r3, #0]
    *address =    (UCHAR) ((value >> 24) & 0xff);
34199826:	683b      	ldr	r3, [r7, #0]
34199828:	0e1b      	lsrs	r3, r3, #24
3419982a:	b2da      	uxtb	r2, r3
3419982c:	687b      	ldr	r3, [r7, #4]
3419982e:	701a      	strb	r2, [r3, #0]

    /* Return to caller.  */
    return;
34199830:	bf00      	nop
}
34199832:	370c      	adds	r7, #12
34199834:	46bd      	mov	sp, r7
34199836:	f85d 7b04 	ldr.w	r7, [sp], #4
3419983a:	4770      	bx	lr

3419983c <_ux_utility_long_put_big_endian>:
/*  09-30-2020     Chaoqiong Xiao           Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _ux_utility_long_put_big_endian(UCHAR * address, ULONG value)
{
3419983c:	b480      	push	{r7}
3419983e:	b085      	sub	sp, #20
34199840:	af00      	add	r7, sp, #0
34199842:	6078      	str	r0, [r7, #4]
34199844:	6039      	str	r1, [r7, #0]

ULONG   low_word_value;
ULONG   high_word_value;

    /* First we swap the value words.  */
    low_word_value =  value >> 16;
34199846:	683b      	ldr	r3, [r7, #0]
34199848:	0c1b      	lsrs	r3, r3, #16
3419984a:	60fb      	str	r3, [r7, #12]
    high_word_value =  value << 16;
3419984c:	683b      	ldr	r3, [r7, #0]
3419984e:	041b      	lsls	r3, r3, #16
34199850:	60bb      	str	r3, [r7, #8]
    value =  high_word_value | low_word_value;
34199852:	68ba      	ldr	r2, [r7, #8]
34199854:	68fb      	ldr	r3, [r7, #12]
34199856:	4313      	orrs	r3, r2
34199858:	603b      	str	r3, [r7, #0]

    /* In order to make this function endian agnostic and memory alignment
       independent, we write a byte at a time from the address.  */
    *address++ =  (UCHAR) ((value >> 8) & 0xff);
3419985a:	683b      	ldr	r3, [r7, #0]
3419985c:	0a19      	lsrs	r1, r3, #8
3419985e:	687b      	ldr	r3, [r7, #4]
34199860:	1c5a      	adds	r2, r3, #1
34199862:	607a      	str	r2, [r7, #4]
34199864:	b2ca      	uxtb	r2, r1
34199866:	701a      	strb	r2, [r3, #0]
    *address++ =  (UCHAR) (value & 0xff);
34199868:	687b      	ldr	r3, [r7, #4]
3419986a:	1c5a      	adds	r2, r3, #1
3419986c:	607a      	str	r2, [r7, #4]
3419986e:	683a      	ldr	r2, [r7, #0]
34199870:	b2d2      	uxtb	r2, r2
34199872:	701a      	strb	r2, [r3, #0]
    *address++ =  (UCHAR) ((value >> 24 ) & 0xff);
34199874:	683b      	ldr	r3, [r7, #0]
34199876:	0e19      	lsrs	r1, r3, #24
34199878:	687b      	ldr	r3, [r7, #4]
3419987a:	1c5a      	adds	r2, r3, #1
3419987c:	607a      	str	r2, [r7, #4]
3419987e:	b2ca      	uxtb	r2, r1
34199880:	701a      	strb	r2, [r3, #0]
    *address   =  (UCHAR) ((value >> 16) & 0xff);
34199882:	683b      	ldr	r3, [r7, #0]
34199884:	0c1b      	lsrs	r3, r3, #16
34199886:	b2da      	uxtb	r2, r3
34199888:	687b      	ldr	r3, [r7, #4]
3419988a:	701a      	strb	r2, [r3, #0]

    /* Return to caller.  */
    return;
3419988c:	bf00      	nop
}
3419988e:	3714      	adds	r7, #20
34199890:	46bd      	mov	sp, r7
34199892:	f85d 7b04 	ldr.w	r7, [sp], #4
34199896:	4770      	bx	lr

34199898 <_ux_utility_memory_allocate>:
/*                                            resulting in version 6.3.0  */
/*                                                                        */
/**************************************************************************/
VOID  *_ux_utility_memory_allocate(ULONG memory_alignment, ULONG memory_cache_flag,
                                   ULONG memory_size_requested)
{
34199898:	b580      	push	{r7, lr}
3419989a:	b08e      	sub	sp, #56	@ 0x38
3419989c:	af00      	add	r7, sp, #0
3419989e:	60f8      	str	r0, [r7, #12]
341998a0:	60b9      	str	r1, [r7, #8]
341998a2:	607a      	str	r2, [r7, #4]
#ifdef UX_ENABLE_MEMORY_STATISTICS
UINT                index;
#endif

    /* Get the pool ptr */
    if (memory_cache_flag == UX_REGULAR_MEMORY)
341998a4:	68bb      	ldr	r3, [r7, #8]
341998a6:	2b00      	cmp	r3, #0
341998a8:	d104      	bne.n	341998b4 <_ux_utility_memory_allocate+0x1c>
    {
        pool_ptr = _ux_system -> ux_system_memory_byte_pool[UX_MEMORY_BYTE_POOL_REGULAR];
341998aa:	4b73      	ldr	r3, [pc, #460]	@ (34199a78 <_ux_utility_memory_allocate+0x1e0>)
341998ac:	681b      	ldr	r3, [r3, #0]
341998ae:	681b      	ldr	r3, [r3, #0]
341998b0:	637b      	str	r3, [r7, #52]	@ 0x34
341998b2:	e009      	b.n	341998c8 <_ux_utility_memory_allocate+0x30>
    }
    else if (memory_cache_flag == UX_CACHE_SAFE_MEMORY)
341998b4:	68bb      	ldr	r3, [r7, #8]
341998b6:	2b01      	cmp	r3, #1
341998b8:	d104      	bne.n	341998c4 <_ux_utility_memory_allocate+0x2c>
    {
        pool_ptr = _ux_system -> ux_system_memory_byte_pool[UX_MEMORY_BYTE_POOL_CACHE_SAFE];
341998ba:	4b6f      	ldr	r3, [pc, #444]	@ (34199a78 <_ux_utility_memory_allocate+0x1e0>)
341998bc:	681b      	ldr	r3, [r3, #0]
341998be:	685b      	ldr	r3, [r3, #4]
341998c0:	637b      	str	r3, [r7, #52]	@ 0x34
341998c2:	e001      	b.n	341998c8 <_ux_utility_memory_allocate+0x30>
    }
    else
    {
        return(UX_NULL);
341998c4:	2300      	movs	r3, #0
341998c6:	e0d2      	b.n	34199a6e <_ux_utility_memory_allocate+0x1d6>
    }

    /* Check if pool_ptr is NX_NULL */
    if (pool_ptr == UX_NULL)
341998c8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
341998ca:	2b00      	cmp	r3, #0
341998cc:	d101      	bne.n	341998d2 <_ux_utility_memory_allocate+0x3a>
    {
        return(UX_NULL);
341998ce:	2300      	movs	r3, #0
341998d0:	e0cd      	b.n	34199a6e <_ux_utility_memory_allocate+0x1d6>
    }

    /* Check if the memory size requested is 0.  */
    if (memory_size_requested == 0)
341998d2:	687b      	ldr	r3, [r7, #4]
341998d4:	2b00      	cmp	r3, #0
341998d6:	d101      	bne.n	341998dc <_ux_utility_memory_allocate+0x44>
    {
        return(UX_NULL);
341998d8:	2300      	movs	r3, #0
341998da:	e0c8      	b.n	34199a6e <_ux_utility_memory_allocate+0x1d6>
    }

    /* Get the mutex as this is a critical section.  */
    _ux_system_mutex_on(&_ux_system -> ux_system_mutex);
341998dc:	4b66      	ldr	r3, [pc, #408]	@ (34199a78 <_ux_utility_memory_allocate+0x1e0>)
341998de:	681b      	ldr	r3, [r3, #0]
341998e0:	330c      	adds	r3, #12
341998e2:	4618      	mov	r0, r3
341998e4:	f000 fabe 	bl	34199e64 <_ux_utility_mutex_on>
    }

#else

    /* Check if safe alignment requested, in this case switch to UX_NO_ALIGN.  */
    if (memory_alignment == UX_SAFE_ALIGN)
341998e8:	68fb      	ldr	r3, [r7, #12]
341998ea:	f1b3 3fff 	cmp.w	r3, #4294967295
341998ee:	d101      	bne.n	341998f4 <_ux_utility_memory_allocate+0x5c>
        memory_alignment = UX_NO_ALIGN;
341998f0:	2300      	movs	r3, #0
341998f2:	60fb      	str	r3, [r7, #12]

#endif

    /* Ensure the alignment meats the minimum.  */
    if (memory_alignment < UX_ALIGN_MIN)
341998f4:	68fb      	ldr	r3, [r7, #12]
341998f6:	2b06      	cmp	r3, #6
341998f8:	d801      	bhi.n	341998fe <_ux_utility_memory_allocate+0x66>
        memory_alignment =  UX_ALIGN_MIN;
341998fa:	2307      	movs	r3, #7
341998fc:	60fb      	str	r3, [r7, #12]
       now is that the memory block might not be a size that is a multiple of 8, so we need
       to add the amount of memory required such that the memory buffer after the block has
       the correct alignment. For example, if the memory block has a size of 12, then we need
       to make sure it is placed on an 8-byte alignment that is after a 8-byte alignment so
       that the memory right after the memory block is 8-byte aligned (16).  */
    memory_size_requested =  (memory_size_requested + UX_ALIGN_MIN) & (~(ULONG)UX_ALIGN_MIN);
341998fe:	687b      	ldr	r3, [r7, #4]
34199900:	3307      	adds	r3, #7
34199902:	f023 0307 	bic.w	r3, r3, #7
34199906:	607b      	str	r3, [r7, #4]
    memory_size_requested += (((ULONG)(UX_MEMORY_BLOCK_HEADER_SIZE + UX_ALIGN_MIN) & (~(ULONG)UX_ALIGN_MIN)) - (ULONG)UX_MEMORY_BLOCK_HEADER_SIZE);

    if (memory_alignment <= UX_ALIGN_MIN)
34199908:	68fb      	ldr	r3, [r7, #12]
3419990a:	2b07      	cmp	r3, #7
3419990c:	d805      	bhi.n	3419991a <_ux_utility_memory_allocate+0x82>
        current_ptr = _ux_utility_memory_byte_pool_search(pool_ptr, memory_size_requested);
3419990e:	6879      	ldr	r1, [r7, #4]
34199910:	6b78      	ldr	r0, [r7, #52]	@ 0x34
34199912:	f000 f92b 	bl	34199b6c <_ux_utility_memory_byte_pool_search>
34199916:	6338      	str	r0, [r7, #48]	@ 0x30
34199918:	e007      	b.n	3419992a <_ux_utility_memory_allocate+0x92>
    else
        current_ptr = _ux_utility_memory_byte_pool_search(pool_ptr, memory_size_requested + memory_alignment);
3419991a:	687a      	ldr	r2, [r7, #4]
3419991c:	68fb      	ldr	r3, [r7, #12]
3419991e:	4413      	add	r3, r2
34199920:	4619      	mov	r1, r3
34199922:	6b78      	ldr	r0, [r7, #52]	@ 0x34
34199924:	f000 f922 	bl	34199b6c <_ux_utility_memory_byte_pool_search>
34199928:	6338      	str	r0, [r7, #48]	@ 0x30

    /* Check if we found a memory block.  */
    if (current_ptr == UX_NULL)
3419992a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3419992c:	2b00      	cmp	r3, #0
3419992e:	d10c      	bne.n	3419994a <_ux_utility_memory_allocate+0xb2>
    {

        /* We could not find a memory block.  */
        _ux_system_mutex_off(&_ux_system -> ux_system_mutex);
34199930:	4b51      	ldr	r3, [pc, #324]	@ (34199a78 <_ux_utility_memory_allocate+0x1e0>)
34199932:	681b      	ldr	r3, [r3, #0]
34199934:	330c      	adds	r3, #12
34199936:	4618      	mov	r0, r3
34199938:	f000 fa89 	bl	34199e4e <_ux_utility_mutex_off>

        UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_MEMORY_INSUFFICIENT, memory_size_requested, 0, 0, UX_TRACE_ERRORS, 0, 0)

        /* Error trap. */
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_UTILITY, UX_MEMORY_INSUFFICIENT);
3419993c:	2212      	movs	r2, #18
3419993e:	2108      	movs	r1, #8
34199940:	2002      	movs	r0, #2
34199942:	f7ff fdbd 	bl	341994c0 <_ux_system_error_handler>

        return(UX_NULL);
34199946:	2300      	movs	r3, #0
34199948:	e091      	b.n	34199a6e <_ux_utility_memory_allocate+0x1d6>
    }

    /* Pickup the next block's pointer.  */
    this_block_link_ptr =  UX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(current_ptr);
3419994a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3419994c:	62bb      	str	r3, [r7, #40]	@ 0x28
    next_ptr =             *this_block_link_ptr;
3419994e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34199950:	681b      	ldr	r3, [r3, #0]
34199952:	627b      	str	r3, [r7, #36]	@ 0x24

    /* Calculate the number of bytes available in this block.  */
    available_bytes =   UX_UCHAR_POINTER_DIF(next_ptr, current_ptr);
34199954:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
34199956:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34199958:	1ad3      	subs	r3, r2, r3
3419995a:	62fb      	str	r3, [r7, #44]	@ 0x2c
    available_bytes =   available_bytes - UX_MEMORY_BLOCK_HEADER_SIZE;
3419995c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3419995e:	3b08      	subs	r3, #8
34199960:	62fb      	str	r3, [r7, #44]	@ 0x2c

    /* Get the memory buffer for this block.  */
    int_memory_buffer = (ALIGN_TYPE) (UX_UCHAR_POINTER_ADD(current_ptr, UX_MEMORY_BLOCK_HEADER_SIZE));
34199962:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34199964:	3308      	adds	r3, #8
34199966:	623b      	str	r3, [r7, #32]

    /* In case we are not aligned  */
    if ((int_memory_buffer & memory_alignment) != 0)
34199968:	6a3a      	ldr	r2, [r7, #32]
3419996a:	68fb      	ldr	r3, [r7, #12]
3419996c:	4013      	ands	r3, r2
3419996e:	2b00      	cmp	r3, #0
34199970:	d02f      	beq.n	341999d2 <_ux_utility_memory_allocate+0x13a>
    {

        /* No, we need to align the memory buffer.  */
        int_memory_buffer += (ALIGN_TYPE)UX_MEMORY_BLOCK_HEADER_SIZE;
34199972:	6a3b      	ldr	r3, [r7, #32]
34199974:	3308      	adds	r3, #8
34199976:	623b      	str	r3, [r7, #32]
        int_memory_buffer += memory_alignment;
34199978:	6a3a      	ldr	r2, [r7, #32]
3419997a:	68fb      	ldr	r3, [r7, #12]
3419997c:	4413      	add	r3, r2
3419997e:	623b      	str	r3, [r7, #32]
        int_memory_buffer &=  ~((ALIGN_TYPE) memory_alignment);
34199980:	68fb      	ldr	r3, [r7, #12]
34199982:	43db      	mvns	r3, r3
34199984:	6a3a      	ldr	r2, [r7, #32]
34199986:	4013      	ands	r3, r2
34199988:	623b      	str	r3, [r7, #32]
        int_memory_buffer -= (ALIGN_TYPE)UX_MEMORY_BLOCK_HEADER_SIZE;
3419998a:	6a3b      	ldr	r3, [r7, #32]
3419998c:	3b08      	subs	r3, #8
3419998e:	623b      	str	r3, [r7, #32]

        /* Setup the new free block.  */
        next_ptr = (UCHAR *)int_memory_buffer;
34199990:	6a3b      	ldr	r3, [r7, #32]
34199992:	627b      	str	r3, [r7, #36]	@ 0x24

        /* Setup the new free block.  */
        next_block_link_ptr =   UX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(next_ptr);
34199994:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34199996:	61fb      	str	r3, [r7, #28]
        *next_block_link_ptr =  *this_block_link_ptr;
34199998:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419999a:	681a      	ldr	r2, [r3, #0]
3419999c:	69fb      	ldr	r3, [r7, #28]
3419999e:	601a      	str	r2, [r3, #0]
        work_ptr =              UX_UCHAR_POINTER_ADD(next_ptr, (sizeof(UCHAR *)));
341999a0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
341999a2:	3304      	adds	r3, #4
341999a4:	61bb      	str	r3, [r7, #24]
        free_ptr =              UX_UCHAR_TO_ALIGN_TYPE_POINTER_CONVERT(work_ptr);
341999a6:	69bb      	ldr	r3, [r7, #24]
341999a8:	617b      	str	r3, [r7, #20]
        *free_ptr =             UX_BYTE_BLOCK_FREE;
341999aa:	697b      	ldr	r3, [r7, #20]
341999ac:	4a33      	ldr	r2, [pc, #204]	@ (34199a7c <_ux_utility_memory_allocate+0x1e4>)
341999ae:	601a      	str	r2, [r3, #0]

        /* Increase the total fragment counter.  */
        pool_ptr -> ux_byte_pool_fragments++;
341999b0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
341999b2:	685b      	ldr	r3, [r3, #4]
341999b4:	1c5a      	adds	r2, r3, #1
341999b6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
341999b8:	605a      	str	r2, [r3, #4]

        /* Update the current pointer to point at the newly created block.  */
        *this_block_link_ptr =  next_ptr;
341999ba:	6abb      	ldr	r3, [r7, #40]	@ 0x28
341999bc:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
341999be:	601a      	str	r2, [r3, #0]

        /* Calculate the available bytes.  */
        available_bytes -=  UX_UCHAR_POINTER_DIF(next_ptr, current_ptr);
341999c0:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
341999c2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
341999c4:	1ad3      	subs	r3, r2, r3
341999c6:	461a      	mov	r2, r3
341999c8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
341999ca:	1a9b      	subs	r3, r3, r2
341999cc:	62fb      	str	r3, [r7, #44]	@ 0x2c

        /* Set Current pointer to the aligned memory buffer.  */
        current_ptr = next_ptr;
341999ce:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
341999d0:	633b      	str	r3, [r7, #48]	@ 0x30
    }

    /* Now we are aligned, determine if we need to split this block.  */
    if ((available_bytes - memory_size_requested) >= ((ULONG) UX_BYTE_BLOCK_MIN))
341999d2:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
341999d4:	687b      	ldr	r3, [r7, #4]
341999d6:	1ad3      	subs	r3, r2, r3
341999d8:	2b13      	cmp	r3, #19
341999da:	d91e      	bls.n	34199a1a <_ux_utility_memory_allocate+0x182>
    {

        /* Split the block.  */
        next_ptr =  UX_UCHAR_POINTER_ADD(current_ptr, (memory_size_requested + UX_MEMORY_BLOCK_HEADER_SIZE));
341999dc:	687b      	ldr	r3, [r7, #4]
341999de:	3308      	adds	r3, #8
341999e0:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
341999e2:	4413      	add	r3, r2
341999e4:	627b      	str	r3, [r7, #36]	@ 0x24

        /* Setup the new free block.  */
        next_block_link_ptr =   UX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(next_ptr);
341999e6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
341999e8:	61fb      	str	r3, [r7, #28]
        this_block_link_ptr =   UX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(current_ptr);
341999ea:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
341999ec:	62bb      	str	r3, [r7, #40]	@ 0x28
        *next_block_link_ptr =  *this_block_link_ptr;
341999ee:	6abb      	ldr	r3, [r7, #40]	@ 0x28
341999f0:	681a      	ldr	r2, [r3, #0]
341999f2:	69fb      	ldr	r3, [r7, #28]
341999f4:	601a      	str	r2, [r3, #0]
        work_ptr =              UX_UCHAR_POINTER_ADD(next_ptr, (sizeof(UCHAR *)));
341999f6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
341999f8:	3304      	adds	r3, #4
341999fa:	61bb      	str	r3, [r7, #24]
        free_ptr =              UX_UCHAR_TO_ALIGN_TYPE_POINTER_CONVERT(work_ptr);
341999fc:	69bb      	ldr	r3, [r7, #24]
341999fe:	617b      	str	r3, [r7, #20]
        *free_ptr =             UX_BYTE_BLOCK_FREE;
34199a00:	697b      	ldr	r3, [r7, #20]
34199a02:	4a1e      	ldr	r2, [pc, #120]	@ (34199a7c <_ux_utility_memory_allocate+0x1e4>)
34199a04:	601a      	str	r2, [r3, #0]

        /* Increase the total fragment counter.  */
        pool_ptr -> ux_byte_pool_fragments++;
34199a06:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34199a08:	685b      	ldr	r3, [r3, #4]
34199a0a:	1c5a      	adds	r2, r3, #1
34199a0c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34199a0e:	605a      	str	r2, [r3, #4]

        /* Update the current pointer to point at the newly created block.  */
        *this_block_link_ptr =  next_ptr;
34199a10:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34199a12:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
34199a14:	601a      	str	r2, [r3, #0]

        /* Set available equal to memory size for subsequent calculation.  */
        available_bytes =  memory_size_requested;
34199a16:	687b      	ldr	r3, [r7, #4]
34199a18:	62fb      	str	r3, [r7, #44]	@ 0x2c
    }

    /* In any case, mark the current block as allocated.  */
    work_ptr =              UX_UCHAR_POINTER_ADD(current_ptr, (sizeof(UCHAR *)));
34199a1a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34199a1c:	3304      	adds	r3, #4
34199a1e:	61bb      	str	r3, [r7, #24]
    this_block_link_ptr =   UX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(work_ptr);
34199a20:	69bb      	ldr	r3, [r7, #24]
34199a22:	62bb      	str	r3, [r7, #40]	@ 0x28
    *this_block_link_ptr =  UX_BYTE_POOL_TO_UCHAR_POINTER_CONVERT(pool_ptr);
34199a24:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34199a26:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
34199a28:	601a      	str	r2, [r3, #0]

    /* Reduce the number of available bytes in the pool.  */
    pool_ptr -> ux_byte_pool_available =  pool_ptr -> ux_byte_pool_available - (available_bytes + UX_MEMORY_BLOCK_HEADER_SIZE);
34199a2a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34199a2c:	681a      	ldr	r2, [r3, #0]
34199a2e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34199a30:	1ad3      	subs	r3, r2, r3
34199a32:	f1a3 0208 	sub.w	r2, r3, #8
34199a36:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34199a38:	601a      	str	r2, [r3, #0]

    /* Determine if the search pointer needs to be updated. This is only done
        if the search pointer matches the block to be returned.  */
    if (current_ptr == pool_ptr -> ux_byte_pool_search)
34199a3a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34199a3c:	689b      	ldr	r3, [r3, #8]
34199a3e:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
34199a40:	429a      	cmp	r2, r3
34199a42:	d105      	bne.n	34199a50 <_ux_utility_memory_allocate+0x1b8>
    {

        /* Yes, update the search pointer to the next block.  */
        this_block_link_ptr =   UX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(current_ptr);
34199a44:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34199a46:	62bb      	str	r3, [r7, #40]	@ 0x28
        pool_ptr -> ux_byte_pool_search =  *this_block_link_ptr;
34199a48:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34199a4a:	681a      	ldr	r2, [r3, #0]
34199a4c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34199a4e:	609a      	str	r2, [r3, #8]
    }

    /* Adjust the pointer for the application.  */
    work_ptr =  UX_UCHAR_POINTER_ADD(current_ptr, UX_MEMORY_BLOCK_HEADER_SIZE);
34199a50:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34199a52:	3308      	adds	r3, #8
34199a54:	61bb      	str	r3, [r7, #24]

    /* Clear the memory block.  */
    _ux_utility_memory_set(work_ptr, 0, available_bytes); /* Use case of memset is verified. */
34199a56:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
34199a58:	2100      	movs	r1, #0
34199a5a:	69b8      	ldr	r0, [r7, #24]
34199a5c:	f000 f9c4 	bl	34199de8 <_ux_utility_memory_set>
    if (_ux_system -> ux_system_memory_byte_pool[index] -> ux_byte_pool_min_free > _ux_system -> ux_system_memory_byte_pool[index] -> ux_byte_pool_available)
        _ux_system -> ux_system_memory_byte_pool[index] -> ux_byte_pool_min_free = _ux_system -> ux_system_memory_byte_pool[index] -> ux_byte_pool_available;
#endif

    /* Release the protection.  */
    _ux_system_mutex_off(&_ux_system -> ux_system_mutex);
34199a60:	4b05      	ldr	r3, [pc, #20]	@ (34199a78 <_ux_utility_memory_allocate+0x1e0>)
34199a62:	681b      	ldr	r3, [r3, #0]
34199a64:	330c      	adds	r3, #12
34199a66:	4618      	mov	r0, r3
34199a68:	f000 f9f1 	bl	34199e4e <_ux_utility_mutex_off>

    return(work_ptr);
34199a6c:	69bb      	ldr	r3, [r7, #24]
}
34199a6e:	4618      	mov	r0, r3
34199a70:	3738      	adds	r7, #56	@ 0x38
34199a72:	46bd      	mov	sp, r7
34199a74:	bd80      	pop	{r7, pc}
34199a76:	bf00      	nop
34199a78:	341c33f4 	.word	0x341c33f4
34199a7c:	ffffeeee 	.word	0xffffeeee

34199a80 <_ux_utility_memory_allocate_mulc_safe>:
/*  09-30-2020     Chaoqiong Xiao           Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID* _ux_utility_memory_allocate_mulc_safe(ULONG align,ULONG cache,ULONG size_mul_v,ULONG size_mul_c)
{
34199a80:	b580      	push	{r7, lr}
34199a82:	b084      	sub	sp, #16
34199a84:	af00      	add	r7, sp, #0
34199a86:	60f8      	str	r0, [r7, #12]
34199a88:	60b9      	str	r1, [r7, #8]
34199a8a:	607a      	str	r2, [r7, #4]
34199a8c:	603b      	str	r3, [r7, #0]
    return UX_UTILITY_MEMORY_ALLOCATE_MULC_SAFE(align, cache, size_mul_v, size_mul_c);
34199a8e:	683b      	ldr	r3, [r7, #0]
34199a90:	2b00      	cmp	r3, #0
34199a92:	d00a      	beq.n	34199aaa <_ux_utility_memory_allocate_mulc_safe+0x2a>
34199a94:	2100      	movs	r1, #0
34199a96:	687a      	ldr	r2, [r7, #4]
34199a98:	683b      	ldr	r3, [r7, #0]
34199a9a:	fba3 2302 	umull	r2, r3, r3, r2
34199a9e:	2b00      	cmp	r3, #0
34199aa0:	d000      	beq.n	34199aa4 <_ux_utility_memory_allocate_mulc_safe+0x24>
34199aa2:	2101      	movs	r1, #1
34199aa4:	460b      	mov	r3, r1
34199aa6:	2b00      	cmp	r3, #0
34199aa8:	d10a      	bne.n	34199ac0 <_ux_utility_memory_allocate_mulc_safe+0x40>
34199aaa:	687b      	ldr	r3, [r7, #4]
34199aac:	683a      	ldr	r2, [r7, #0]
34199aae:	fb02 f303 	mul.w	r3, r2, r3
34199ab2:	461a      	mov	r2, r3
34199ab4:	68b9      	ldr	r1, [r7, #8]
34199ab6:	68f8      	ldr	r0, [r7, #12]
34199ab8:	f7ff feee 	bl	34199898 <_ux_utility_memory_allocate>
34199abc:	4603      	mov	r3, r0
34199abe:	e000      	b.n	34199ac2 <_ux_utility_memory_allocate_mulc_safe+0x42>
34199ac0:	2300      	movs	r3, #0
}
34199ac2:	4618      	mov	r0, r3
34199ac4:	3710      	adds	r7, #16
34199ac6:	46bd      	mov	sp, r7
34199ac8:	bd80      	pop	{r7, pc}
	...

34199acc <_ux_utility_memory_byte_pool_create>:
/*                                                                        */
/*  10-31-2023     Yajun Xia                Initial Version 6.3.0         */
/*                                                                        */
/**************************************************************************/
UINT  _ux_utility_memory_byte_pool_create(UX_MEMORY_BYTE_POOL *pool_ptr, VOID *pool_start, ULONG pool_size)
{
34199acc:	b580      	push	{r7, lr}
34199ace:	b088      	sub	sp, #32
34199ad0:	af00      	add	r7, sp, #0
34199ad2:	60f8      	str	r0, [r7, #12]
34199ad4:	60b9      	str	r1, [r7, #8]
34199ad6:	607a      	str	r2, [r7, #4]
UCHAR               *temp_ptr;
ALIGN_TYPE          *free_ptr;


    /* Initialize the byte pool control block to all zeros.  */
    _ux_utility_memory_set((UCHAR *)pool_ptr, 0, sizeof(UX_MEMORY_BYTE_POOL)); /* Use case of memset is verified. */
34199ad8:	2214      	movs	r2, #20
34199ada:	2100      	movs	r1, #0
34199adc:	68f8      	ldr	r0, [r7, #12]
34199ade:	f000 f983 	bl	34199de8 <_ux_utility_memory_set>

    /* Round the pool size down to something that is evenly divisible by
       an ULONG.  */
    pool_size =   (pool_size/(sizeof(ALIGN_TYPE))) * (sizeof(ALIGN_TYPE));
34199ae2:	687b      	ldr	r3, [r7, #4]
34199ae4:	f023 0303 	bic.w	r3, r3, #3
34199ae8:	607b      	str	r3, [r7, #4]

    /* Save the start and size of the pool.  */
    pool_ptr -> ux_byte_pool_start =   UX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
34199aea:	68fb      	ldr	r3, [r7, #12]
34199aec:	68ba      	ldr	r2, [r7, #8]
34199aee:	60da      	str	r2, [r3, #12]
    pool_ptr -> ux_byte_pool_size =    pool_size;
34199af0:	68fb      	ldr	r3, [r7, #12]
34199af2:	687a      	ldr	r2, [r7, #4]
34199af4:	611a      	str	r2, [r3, #16]
    pool_ptr -> ux_byte_pool_search =  UX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
34199af6:	68fb      	ldr	r3, [r7, #12]
34199af8:	68ba      	ldr	r2, [r7, #8]
34199afa:	609a      	str	r2, [r3, #8]

    /* Initially, the pool will have two blocks.  One large block at the
       beginning that is available and a small allocated block at the end
       of the pool that is there just for the algorithm.  Be sure to count
       the available block's header in the available bytes count.  */
    pool_ptr -> ux_byte_pool_available =   pool_size - ((sizeof(VOID *)) + (sizeof(ALIGN_TYPE)));
34199afc:	687b      	ldr	r3, [r7, #4]
34199afe:	f1a3 0208 	sub.w	r2, r3, #8
34199b02:	68fb      	ldr	r3, [r7, #12]
34199b04:	601a      	str	r2, [r3, #0]
    pool_ptr -> ux_byte_pool_fragments =   ((UINT) 2);
34199b06:	68fb      	ldr	r3, [r7, #12]
34199b08:	2202      	movs	r2, #2
34199b0a:	605a      	str	r2, [r3, #4]
    /* Each block contains a "next" pointer that points to the next block in the pool followed by a ALIGN_TYPE
       field that contains either the constant UX_BYTE_BLOCK_FREE (if the block is free) or a pointer to the
       owning pool (if the block is allocated).  */

    /* Calculate the end of the pool's memory area.  */
    block_ptr =  UX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
34199b0c:	68bb      	ldr	r3, [r7, #8]
34199b0e:	61fb      	str	r3, [r7, #28]
    block_ptr =  UX_UCHAR_POINTER_ADD(block_ptr, pool_size);
34199b10:	69fa      	ldr	r2, [r7, #28]
34199b12:	687b      	ldr	r3, [r7, #4]
34199b14:	4413      	add	r3, r2
34199b16:	61fb      	str	r3, [r7, #28]

    /* Backup the end of the pool pointer and build the pre-allocated block.  */
    block_ptr =  UX_UCHAR_POINTER_SUB(block_ptr, (sizeof(ALIGN_TYPE)));
34199b18:	69fb      	ldr	r3, [r7, #28]
34199b1a:	3b04      	subs	r3, #4
34199b1c:	61fb      	str	r3, [r7, #28]

    /* Cast the pool pointer into a ULONG.  */
    temp_ptr =             UX_BYTE_POOL_TO_UCHAR_POINTER_CONVERT(pool_ptr);
34199b1e:	68fb      	ldr	r3, [r7, #12]
34199b20:	61bb      	str	r3, [r7, #24]
    block_indirect_ptr =   UX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(block_ptr);
34199b22:	69fb      	ldr	r3, [r7, #28]
34199b24:	617b      	str	r3, [r7, #20]
    *block_indirect_ptr =  temp_ptr;
34199b26:	697b      	ldr	r3, [r7, #20]
34199b28:	69ba      	ldr	r2, [r7, #24]
34199b2a:	601a      	str	r2, [r3, #0]

    block_ptr =            UX_UCHAR_POINTER_SUB(block_ptr, (sizeof(UCHAR *)));
34199b2c:	69fb      	ldr	r3, [r7, #28]
34199b2e:	3b04      	subs	r3, #4
34199b30:	61fb      	str	r3, [r7, #28]
    block_indirect_ptr =   UX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(block_ptr);
34199b32:	69fb      	ldr	r3, [r7, #28]
34199b34:	617b      	str	r3, [r7, #20]
    *block_indirect_ptr =  UX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
34199b36:	697b      	ldr	r3, [r7, #20]
34199b38:	68ba      	ldr	r2, [r7, #8]
34199b3a:	601a      	str	r2, [r3, #0]

    /* Now setup the large available block in the pool.  */
    temp_ptr =             UX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
34199b3c:	68bb      	ldr	r3, [r7, #8]
34199b3e:	61bb      	str	r3, [r7, #24]
    block_indirect_ptr =   UX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(temp_ptr);
34199b40:	69bb      	ldr	r3, [r7, #24]
34199b42:	617b      	str	r3, [r7, #20]
    *block_indirect_ptr =  block_ptr;
34199b44:	697b      	ldr	r3, [r7, #20]
34199b46:	69fa      	ldr	r2, [r7, #28]
34199b48:	601a      	str	r2, [r3, #0]
    block_ptr =            UX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
34199b4a:	68bb      	ldr	r3, [r7, #8]
34199b4c:	61fb      	str	r3, [r7, #28]
    block_ptr =            UX_UCHAR_POINTER_ADD(block_ptr, (sizeof(UCHAR *)));
34199b4e:	69fb      	ldr	r3, [r7, #28]
34199b50:	3304      	adds	r3, #4
34199b52:	61fb      	str	r3, [r7, #28]
    free_ptr =             UX_UCHAR_TO_ALIGN_TYPE_POINTER_CONVERT(block_ptr);
34199b54:	69fb      	ldr	r3, [r7, #28]
34199b56:	613b      	str	r3, [r7, #16]
    *free_ptr =            UX_BYTE_BLOCK_FREE;
34199b58:	693b      	ldr	r3, [r7, #16]
34199b5a:	4a03      	ldr	r2, [pc, #12]	@ (34199b68 <_ux_utility_memory_byte_pool_create+0x9c>)
34199b5c:	601a      	str	r2, [r3, #0]

    /* Return UX_SUCCESS.  */
    return(UX_SUCCESS);
34199b5e:	2300      	movs	r3, #0
}
34199b60:	4618      	mov	r0, r3
34199b62:	3720      	adds	r7, #32
34199b64:	46bd      	mov	sp, r7
34199b66:	bd80      	pop	{r7, pc}
34199b68:	ffffeeee 	.word	0xffffeeee

34199b6c <_ux_utility_memory_byte_pool_search>:
/*                                                                        */
/*  10-31-2023     Yajun Xia                Initial Version 6.3.0         */
/*                                                                        */
/**************************************************************************/
UCHAR  *_ux_utility_memory_byte_pool_search(UX_MEMORY_BYTE_POOL *pool_ptr, ULONG memory_size)
{
34199b6c:	b480      	push	{r7}
34199b6e:	b08d      	sub	sp, #52	@ 0x34
34199b70:	af00      	add	r7, sp, #0
34199b72:	6078      	str	r0, [r7, #4]
34199b74:	6039      	str	r1, [r7, #0]
UCHAR               *next_ptr;
UCHAR               **this_block_link_ptr;
UCHAR               **next_block_link_ptr;
ULONG               available_bytes;
UINT                examine_blocks;
UINT                first_free_block_found =  UX_FALSE;
34199b76:	2300      	movs	r3, #0
34199b78:	623b      	str	r3, [r7, #32]
UCHAR               *work_ptr;
ULONG               total_theoretical_available;

    /* First, determine if there are enough bytes in the pool.  */
    /* Theoretical bytes available = free bytes + ((fragments-2) * overhead of each block) */
    total_theoretical_available = pool_ptr -> ux_byte_pool_available + ((pool_ptr -> ux_byte_pool_fragments - 2) * UX_MEMORY_BLOCK_HEADER_SIZE);
34199b7a:	687b      	ldr	r3, [r7, #4]
34199b7c:	681a      	ldr	r2, [r3, #0]
34199b7e:	687b      	ldr	r3, [r7, #4]
34199b80:	685b      	ldr	r3, [r3, #4]
34199b82:	3b02      	subs	r3, #2
34199b84:	00db      	lsls	r3, r3, #3
34199b86:	4413      	add	r3, r2
34199b88:	61fb      	str	r3, [r7, #28]
    if (memory_size >= total_theoretical_available)
34199b8a:	683a      	ldr	r2, [r7, #0]
34199b8c:	69fb      	ldr	r3, [r7, #28]
34199b8e:	429a      	cmp	r2, r3
34199b90:	d301      	bcc.n	34199b96 <_ux_utility_memory_byte_pool_search+0x2a>
    {

        /* Not enough memory, return a NULL pointer.  */
        return(UX_NULL);
34199b92:	2300      	movs	r3, #0
34199b94:	e07d      	b.n	34199c92 <_ux_utility_memory_byte_pool_search+0x126>
    }

    /* Check if the search pointer is valid.  */
    if ((pool_ptr -> ux_byte_pool_search < pool_ptr -> ux_byte_pool_start) ||
34199b96:	687b      	ldr	r3, [r7, #4]
34199b98:	689a      	ldr	r2, [r3, #8]
34199b9a:	687b      	ldr	r3, [r7, #4]
34199b9c:	68db      	ldr	r3, [r3, #12]
34199b9e:	429a      	cmp	r2, r3
34199ba0:	d308      	bcc.n	34199bb4 <_ux_utility_memory_byte_pool_search+0x48>
        (pool_ptr -> ux_byte_pool_search > pool_ptr -> ux_byte_pool_start + pool_ptr -> ux_byte_pool_size))
34199ba2:	687b      	ldr	r3, [r7, #4]
34199ba4:	689a      	ldr	r2, [r3, #8]
34199ba6:	687b      	ldr	r3, [r7, #4]
34199ba8:	68d9      	ldr	r1, [r3, #12]
34199baa:	687b      	ldr	r3, [r7, #4]
34199bac:	691b      	ldr	r3, [r3, #16]
34199bae:	440b      	add	r3, r1
    if ((pool_ptr -> ux_byte_pool_search < pool_ptr -> ux_byte_pool_start) ||
34199bb0:	429a      	cmp	r2, r3
34199bb2:	d901      	bls.n	34199bb8 <_ux_utility_memory_byte_pool_search+0x4c>
    {

        /* Return a NULL pointer.  */
        return(UX_NULL);
34199bb4:	2300      	movs	r3, #0
34199bb6:	e06c      	b.n	34199c92 <_ux_utility_memory_byte_pool_search+0x126>
    }

    /* Walk through the memory pool in search for a large enough block.  */
    current_ptr =      pool_ptr -> ux_byte_pool_search;
34199bb8:	687b      	ldr	r3, [r7, #4]
34199bba:	689b      	ldr	r3, [r3, #8]
34199bbc:	62fb      	str	r3, [r7, #44]	@ 0x2c
    examine_blocks =   pool_ptr -> ux_byte_pool_fragments + ((UINT) 1);
34199bbe:	687b      	ldr	r3, [r7, #4]
34199bc0:	685b      	ldr	r3, [r3, #4]
34199bc2:	3301      	adds	r3, #1
34199bc4:	627b      	str	r3, [r7, #36]	@ 0x24
    available_bytes =  ((ULONG) 0);
34199bc6:	2300      	movs	r3, #0
34199bc8:	62bb      	str	r3, [r7, #40]	@ 0x28
    do
    {
        /* Check to see if this block is free.  */
        work_ptr =  UX_UCHAR_POINTER_ADD(current_ptr, (sizeof(UCHAR *)));
34199bca:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34199bcc:	3304      	adds	r3, #4
34199bce:	61bb      	str	r3, [r7, #24]
        free_ptr =  UX_UCHAR_TO_ALIGN_TYPE_POINTER_CONVERT(work_ptr);
34199bd0:	69bb      	ldr	r3, [r7, #24]
34199bd2:	617b      	str	r3, [r7, #20]
        if ((*free_ptr) == UX_BYTE_BLOCK_FREE)
34199bd4:	697b      	ldr	r3, [r7, #20]
34199bd6:	681b      	ldr	r3, [r3, #0]
34199bd8:	4a31      	ldr	r2, [pc, #196]	@ (34199ca0 <_ux_utility_memory_byte_pool_search+0x134>)
34199bda:	4293      	cmp	r3, r2
34199bdc:	d143      	bne.n	34199c66 <_ux_utility_memory_byte_pool_search+0xfa>
        {

            /* Determine if this is the first free block.  */
            if (first_free_block_found == UX_FALSE)
34199bde:	6a3b      	ldr	r3, [r7, #32]
34199be0:	2b00      	cmp	r3, #0
34199be2:	d104      	bne.n	34199bee <_ux_utility_memory_byte_pool_search+0x82>
            {
                /* This is the first free block.  */
                pool_ptr->ux_byte_pool_search =  current_ptr;
34199be4:	687b      	ldr	r3, [r7, #4]
34199be6:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
34199be8:	609a      	str	r2, [r3, #8]

                /* Set the flag to indicate we have found the first free
                    block.  */
                first_free_block_found =  UX_TRUE;
34199bea:	2301      	movs	r3, #1
34199bec:	623b      	str	r3, [r7, #32]
            }

            /* Block is free, see if it is large enough.  */

            /* Pickup the next block's pointer.  */
            this_block_link_ptr =  UX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(current_ptr);
34199bee:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34199bf0:	613b      	str	r3, [r7, #16]
            next_ptr =             *this_block_link_ptr;
34199bf2:	693b      	ldr	r3, [r7, #16]
34199bf4:	681b      	ldr	r3, [r3, #0]
34199bf6:	60fb      	str	r3, [r7, #12]

            /* Calculate the number of bytes available in this block.  */
            available_bytes =   UX_UCHAR_POINTER_DIF(next_ptr, current_ptr);
34199bf8:	68fa      	ldr	r2, [r7, #12]
34199bfa:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34199bfc:	1ad3      	subs	r3, r2, r3
34199bfe:	62bb      	str	r3, [r7, #40]	@ 0x28
            available_bytes =   available_bytes - UX_MEMORY_BLOCK_HEADER_SIZE;
34199c00:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34199c02:	3b08      	subs	r3, #8
34199c04:	62bb      	str	r3, [r7, #40]	@ 0x28

            /* If this is large enough, we are done because our first-fit algorithm
                has been satisfied!  */
            if (available_bytes >= memory_size)
34199c06:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34199c08:	683b      	ldr	r3, [r7, #0]
34199c0a:	429a      	cmp	r2, r3
34199c0c:	d23a      	bcs.n	34199c84 <_ux_utility_memory_byte_pool_search+0x118>
            }
            else
            {

                /* Clear the available bytes variable.  */
                available_bytes =  ((ULONG) 0);
34199c0e:	2300      	movs	r3, #0
34199c10:	62bb      	str	r3, [r7, #40]	@ 0x28

                /* Not enough memory, check to see if the neighbor is
                    free and can be merged.  */
                work_ptr =  UX_UCHAR_POINTER_ADD(next_ptr, (sizeof(UCHAR *)));
34199c12:	68fb      	ldr	r3, [r7, #12]
34199c14:	3304      	adds	r3, #4
34199c16:	61bb      	str	r3, [r7, #24]
                free_ptr =  UX_UCHAR_TO_ALIGN_TYPE_POINTER_CONVERT(work_ptr);
34199c18:	69bb      	ldr	r3, [r7, #24]
34199c1a:	617b      	str	r3, [r7, #20]
                if ((*free_ptr) == UX_BYTE_BLOCK_FREE)
34199c1c:	697b      	ldr	r3, [r7, #20]
34199c1e:	681b      	ldr	r3, [r3, #0]
34199c20:	4a1f      	ldr	r2, [pc, #124]	@ (34199ca0 <_ux_utility_memory_byte_pool_search+0x134>)
34199c22:	4293      	cmp	r3, r2
34199c24:	d113      	bne.n	34199c4e <_ux_utility_memory_byte_pool_search+0xe2>
                {

                    /* Yes, neighbor block can be merged!  This is quickly accomplished
                        by updating the current block with the next blocks pointer.  */
                    next_block_link_ptr =  UX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(next_ptr);
34199c26:	68fb      	ldr	r3, [r7, #12]
34199c28:	60bb      	str	r3, [r7, #8]
                    *this_block_link_ptr =  *next_block_link_ptr;
34199c2a:	68bb      	ldr	r3, [r7, #8]
34199c2c:	681a      	ldr	r2, [r3, #0]
34199c2e:	693b      	ldr	r3, [r7, #16]
34199c30:	601a      	str	r2, [r3, #0]

                    /* Reduce the fragment total.  We don't need to increase the bytes
                        available because all free headers are also included in the available
                        count.  */
                    pool_ptr -> ux_byte_pool_fragments--;
34199c32:	687b      	ldr	r3, [r7, #4]
34199c34:	685b      	ldr	r3, [r3, #4]
34199c36:	1e5a      	subs	r2, r3, #1
34199c38:	687b      	ldr	r3, [r7, #4]
34199c3a:	605a      	str	r2, [r3, #4]

                    /* See if the search pointer is affected.  */
                    if (pool_ptr -> ux_byte_pool_search ==  next_ptr)
34199c3c:	687b      	ldr	r3, [r7, #4]
34199c3e:	689b      	ldr	r3, [r3, #8]
34199c40:	68fa      	ldr	r2, [r7, #12]
34199c42:	429a      	cmp	r2, r3
34199c44:	d114      	bne.n	34199c70 <_ux_utility_memory_byte_pool_search+0x104>
                    {
                        /* Yes, update the search pointer.   */
                        pool_ptr -> ux_byte_pool_search =  current_ptr;
34199c46:	687b      	ldr	r3, [r7, #4]
34199c48:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
34199c4a:	609a      	str	r2, [r3, #8]
34199c4c:	e010      	b.n	34199c70 <_ux_utility_memory_byte_pool_search+0x104>
                    }
                }
                else
                {
                    /* Neighbor is not free so we can skip over it!  */
                    next_block_link_ptr =  UX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(next_ptr);
34199c4e:	68fb      	ldr	r3, [r7, #12]
34199c50:	60bb      	str	r3, [r7, #8]
                    current_ptr =  *next_block_link_ptr;
34199c52:	68bb      	ldr	r3, [r7, #8]
34199c54:	681b      	ldr	r3, [r3, #0]
34199c56:	62fb      	str	r3, [r7, #44]	@ 0x2c

                    /* Decrement the examined block count to account for this one.  */
                    if (examine_blocks != ((UINT) 0))
34199c58:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34199c5a:	2b00      	cmp	r3, #0
34199c5c:	d008      	beq.n	34199c70 <_ux_utility_memory_byte_pool_search+0x104>
                    {
                        examine_blocks--;
34199c5e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34199c60:	3b01      	subs	r3, #1
34199c62:	627b      	str	r3, [r7, #36]	@ 0x24
34199c64:	e004      	b.n	34199c70 <_ux_utility_memory_byte_pool_search+0x104>
        }
        else
        {

            /* Block is not free, move to next block.  */
            this_block_link_ptr =  UX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(current_ptr);
34199c66:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34199c68:	613b      	str	r3, [r7, #16]
            current_ptr =  *this_block_link_ptr;
34199c6a:	693b      	ldr	r3, [r7, #16]
34199c6c:	681b      	ldr	r3, [r3, #0]
34199c6e:	62fb      	str	r3, [r7, #44]	@ 0x2c
        }

        /* Another block has been searched... decrement counter.  */
        if (examine_blocks != ((UINT) 0))
34199c70:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34199c72:	2b00      	cmp	r3, #0
34199c74:	d002      	beq.n	34199c7c <_ux_utility_memory_byte_pool_search+0x110>
        {

            examine_blocks--;
34199c76:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34199c78:	3b01      	subs	r3, #1
34199c7a:	627b      	str	r3, [r7, #36]	@ 0x24
        }

    } while(examine_blocks != ((UINT) 0));
34199c7c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34199c7e:	2b00      	cmp	r3, #0
34199c80:	d1a3      	bne.n	34199bca <_ux_utility_memory_byte_pool_search+0x5e>
34199c82:	e000      	b.n	34199c86 <_ux_utility_memory_byte_pool_search+0x11a>
                break;
34199c84:	bf00      	nop

    /* If a block was found, just return. */
    if (available_bytes == ((ULONG) 0))
34199c86:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34199c88:	2b00      	cmp	r3, #0
34199c8a:	d101      	bne.n	34199c90 <_ux_utility_memory_byte_pool_search+0x124>
    {
        return(UX_NULL);
34199c8c:	2300      	movs	r3, #0
34199c8e:	e000      	b.n	34199c92 <_ux_utility_memory_byte_pool_search+0x126>
    }

    /* Return the search pointer.  */
    return(current_ptr);
34199c90:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
}
34199c92:	4618      	mov	r0, r3
34199c94:	3734      	adds	r7, #52	@ 0x34
34199c96:	46bd      	mov	sp, r7
34199c98:	f85d 7b04 	ldr.w	r7, [sp], #4
34199c9c:	4770      	bx	lr
34199c9e:	bf00      	nop
34199ca0:	ffffeeee 	.word	0xffffeeee

34199ca4 <_ux_utility_memory_copy>:
/*  09-30-2020     Chaoqiong Xiao           Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _ux_utility_memory_copy(VOID *memory_destination, VOID *memory_source, ULONG length)
{
34199ca4:	b480      	push	{r7}
34199ca6:	b087      	sub	sp, #28
34199ca8:	af00      	add	r7, sp, #0
34199caa:	60f8      	str	r0, [r7, #12]
34199cac:	60b9      	str	r1, [r7, #8]
34199cae:	607a      	str	r2, [r7, #4]

UCHAR *   source;
UCHAR *   destination;

    /* Setup byte oriented source and destination pointers.  */
    source =  (UCHAR *) memory_source;
34199cb0:	68bb      	ldr	r3, [r7, #8]
34199cb2:	617b      	str	r3, [r7, #20]
    destination =  (UCHAR *) memory_destination;
34199cb4:	68fb      	ldr	r3, [r7, #12]
34199cb6:	613b      	str	r3, [r7, #16]

    /* Loop to perform the copy.  */
    while(length--)
34199cb8:	e007      	b.n	34199cca <_ux_utility_memory_copy+0x26>
    {

        /* Copy one byte.  */
        *destination++ =  *source++;
34199cba:	697a      	ldr	r2, [r7, #20]
34199cbc:	1c53      	adds	r3, r2, #1
34199cbe:	617b      	str	r3, [r7, #20]
34199cc0:	693b      	ldr	r3, [r7, #16]
34199cc2:	1c59      	adds	r1, r3, #1
34199cc4:	6139      	str	r1, [r7, #16]
34199cc6:	7812      	ldrb	r2, [r2, #0]
34199cc8:	701a      	strb	r2, [r3, #0]
    while(length--)
34199cca:	687b      	ldr	r3, [r7, #4]
34199ccc:	1e5a      	subs	r2, r3, #1
34199cce:	607a      	str	r2, [r7, #4]
34199cd0:	2b00      	cmp	r3, #0
34199cd2:	d1f2      	bne.n	34199cba <_ux_utility_memory_copy+0x16>
    }

    /* Return to caller.  */
    return; 
34199cd4:	bf00      	nop
}
34199cd6:	371c      	adds	r7, #28
34199cd8:	46bd      	mov	sp, r7
34199cda:	f85d 7b04 	ldr.w	r7, [sp], #4
34199cde:	4770      	bx	lr

34199ce0 <_ux_utility_memory_free>:
/*                                            refined memory management,  */
/*                                            resulting in version 6.3.0  */
/*                                                                        */
/**************************************************************************/
VOID  _ux_utility_memory_free(VOID *memory)
{
34199ce0:	b580      	push	{r7, lr}
34199ce2:	b08a      	sub	sp, #40	@ 0x28
34199ce4:	af00      	add	r7, sp, #0
34199ce6:	6078      	str	r0, [r7, #4]
#ifdef UX_ENABLE_MEMORY_STATISTICS
UINT                index;
#endif

    /* Get the mutex as this is a critical section.  */
    _ux_system_mutex_on(&_ux_system -> ux_system_mutex);
34199ce8:	4b3d      	ldr	r3, [pc, #244]	@ (34199de0 <_ux_utility_memory_free+0x100>)
34199cea:	681b      	ldr	r3, [r3, #0]
34199cec:	330c      	adds	r3, #12
34199cee:	4618      	mov	r0, r3
34199cf0:	f000 f8b8 	bl	34199e64 <_ux_utility_mutex_on>
        return;
    }
#endif

    /* Set the pool pointer to NULL.  */
    pool_ptr =  UX_NULL;
34199cf4:	2300      	movs	r3, #0
34199cf6:	627b      	str	r3, [r7, #36]	@ 0x24

    /* Determine if the memory pointer is valid.  */
    work_ptr =  UX_VOID_TO_UCHAR_POINTER_CONVERT(memory);
34199cf8:	687b      	ldr	r3, [r7, #4]
34199cfa:	623b      	str	r3, [r7, #32]
    if (work_ptr != UX_NULL)
34199cfc:	6a3b      	ldr	r3, [r7, #32]
34199cfe:	2b00      	cmp	r3, #0
34199d00:	d03b      	beq.n	34199d7a <_ux_utility_memory_free+0x9a>
    {

        /* Back off the memory pointer to pickup its header.  */
        work_ptr =  UX_UCHAR_POINTER_SUB(work_ptr, UX_MEMORY_BLOCK_HEADER_SIZE);
34199d02:	6a3b      	ldr	r3, [r7, #32]
34199d04:	3b08      	subs	r3, #8
34199d06:	623b      	str	r3, [r7, #32]

        /* There is a pointer, pickup the pool pointer address.  */
        temp_ptr =  UX_UCHAR_POINTER_ADD(work_ptr, (sizeof(UCHAR *)));
34199d08:	6a3b      	ldr	r3, [r7, #32]
34199d0a:	3304      	adds	r3, #4
34199d0c:	61fb      	str	r3, [r7, #28]
        free_ptr =  UX_UCHAR_TO_ALIGN_TYPE_POINTER_CONVERT(temp_ptr);
34199d0e:	69fb      	ldr	r3, [r7, #28]
34199d10:	61bb      	str	r3, [r7, #24]
        if ((*free_ptr) != UX_BYTE_BLOCK_FREE)
34199d12:	69bb      	ldr	r3, [r7, #24]
34199d14:	681b      	ldr	r3, [r3, #0]
34199d16:	4a33      	ldr	r2, [pc, #204]	@ (34199de4 <_ux_utility_memory_free+0x104>)
34199d18:	4293      	cmp	r3, r2
34199d1a:	d022      	beq.n	34199d62 <_ux_utility_memory_free+0x82>
        {

            /* Pickup the pool pointer.  */
            temp_ptr =  UX_UCHAR_POINTER_ADD(work_ptr, (sizeof(UCHAR *)));
34199d1c:	6a3b      	ldr	r3, [r7, #32]
34199d1e:	3304      	adds	r3, #4
34199d20:	61fb      	str	r3, [r7, #28]
            byte_pool_ptr = UX_UCHAR_TO_INDIRECT_BYTE_POOL_POINTER(temp_ptr);
34199d22:	69fb      	ldr	r3, [r7, #28]
34199d24:	617b      	str	r3, [r7, #20]
            pool_ptr = *byte_pool_ptr;
34199d26:	697b      	ldr	r3, [r7, #20]
34199d28:	681b      	ldr	r3, [r3, #0]
34199d2a:	627b      	str	r3, [r7, #36]	@ 0x24

            /* See if we have a valid pool pointer.  */
            if ((pool_ptr == UX_NULL) ||
34199d2c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34199d2e:	2b00      	cmp	r3, #0
34199d30:	d00b      	beq.n	34199d4a <_ux_utility_memory_free+0x6a>
                ((pool_ptr != _ux_system -> ux_system_memory_byte_pool[UX_MEMORY_BYTE_POOL_REGULAR]) &&
34199d32:	4b2b      	ldr	r3, [pc, #172]	@ (34199de0 <_ux_utility_memory_free+0x100>)
34199d34:	681b      	ldr	r3, [r3, #0]
34199d36:	681b      	ldr	r3, [r3, #0]
            if ((pool_ptr == UX_NULL) ||
34199d38:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
34199d3a:	429a      	cmp	r2, r3
34199d3c:	d029      	beq.n	34199d92 <_ux_utility_memory_free+0xb2>
                (pool_ptr != _ux_system -> ux_system_memory_byte_pool[UX_MEMORY_BYTE_POOL_CACHE_SAFE])))
34199d3e:	4b28      	ldr	r3, [pc, #160]	@ (34199de0 <_ux_utility_memory_free+0x100>)
34199d40:	681b      	ldr	r3, [r3, #0]
34199d42:	685b      	ldr	r3, [r3, #4]
                ((pool_ptr != _ux_system -> ux_system_memory_byte_pool[UX_MEMORY_BYTE_POOL_REGULAR]) &&
34199d44:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
34199d46:	429a      	cmp	r2, r3
34199d48:	d023      	beq.n	34199d92 <_ux_utility_memory_free+0xb2>
            {

                /* Release the protection.  */
                _ux_system_mutex_off(&_ux_system -> ux_system_mutex);
34199d4a:	4b25      	ldr	r3, [pc, #148]	@ (34199de0 <_ux_utility_memory_free+0x100>)
34199d4c:	681b      	ldr	r3, [r3, #0]
34199d4e:	330c      	adds	r3, #12
34199d50:	4618      	mov	r0, r3
34199d52:	f000 f87c 	bl	34199e4e <_ux_utility_mutex_off>

                /* Error trap: maybe double free/memory issue here!  */
                _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD,
34199d56:	2219      	movs	r2, #25
34199d58:	2108      	movs	r1, #8
34199d5a:	2002      	movs	r0, #2
34199d5c:	f7ff fbb0 	bl	341994c0 <_ux_system_error_handler>
                                         UX_SYSTEM_CONTEXT_UTILITY, UX_MEMORY_CORRUPTED);

                /* Return to caller.  */
                return;
34199d60:	e03b      	b.n	34199dda <_ux_utility_memory_free+0xfa>
            }
        }
        else
        {
            /* Release the protection.  */
            _ux_system_mutex_off(&_ux_system -> ux_system_mutex);
34199d62:	4b1f      	ldr	r3, [pc, #124]	@ (34199de0 <_ux_utility_memory_free+0x100>)
34199d64:	681b      	ldr	r3, [r3, #0]
34199d66:	330c      	adds	r3, #12
34199d68:	4618      	mov	r0, r3
34199d6a:	f000 f870 	bl	34199e4e <_ux_utility_mutex_off>

            /* Error trap: maybe double free/memory issue here!  */
            _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD,
34199d6e:	2219      	movs	r2, #25
34199d70:	2108      	movs	r1, #8
34199d72:	2002      	movs	r0, #2
34199d74:	f7ff fba4 	bl	341994c0 <_ux_system_error_handler>
                                     UX_SYSTEM_CONTEXT_UTILITY, UX_MEMORY_CORRUPTED);

            /* Return to caller.  */
            return;
34199d78:	e02f      	b.n	34199dda <_ux_utility_memory_free+0xfa>
    }
    else
    {

        /* Release the protection.  */
        _ux_system_mutex_off(&_ux_system -> ux_system_mutex);
34199d7a:	4b19      	ldr	r3, [pc, #100]	@ (34199de0 <_ux_utility_memory_free+0x100>)
34199d7c:	681b      	ldr	r3, [r3, #0]
34199d7e:	330c      	adds	r3, #12
34199d80:	4618      	mov	r0, r3
34199d82:	f000 f864 	bl	34199e4e <_ux_utility_mutex_off>

        /* Error trap: maybe double free/bad flow here!  */
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD,
34199d86:	2219      	movs	r2, #25
34199d88:	2108      	movs	r1, #8
34199d8a:	2002      	movs	r0, #2
34199d8c:	f7ff fb98 	bl	341994c0 <_ux_system_error_handler>
                                    UX_SYSTEM_CONTEXT_UTILITY, UX_MEMORY_CORRUPTED);

        /* Return to caller.  */
        return;
34199d90:	e023      	b.n	34199dda <_ux_utility_memory_free+0xfa>
    }

    /* At this point, we know that the pool pointer is valid.  */

    /* Release the memory.  */
    temp_ptr =   UX_UCHAR_POINTER_ADD(work_ptr, (sizeof(UCHAR *)));
34199d92:	6a3b      	ldr	r3, [r7, #32]
34199d94:	3304      	adds	r3, #4
34199d96:	61fb      	str	r3, [r7, #28]
    free_ptr =   UX_UCHAR_TO_ALIGN_TYPE_POINTER_CONVERT(temp_ptr);
34199d98:	69fb      	ldr	r3, [r7, #28]
34199d9a:	61bb      	str	r3, [r7, #24]
    *free_ptr =  UX_BYTE_BLOCK_FREE;
34199d9c:	69bb      	ldr	r3, [r7, #24]
34199d9e:	4a11      	ldr	r2, [pc, #68]	@ (34199de4 <_ux_utility_memory_free+0x104>)
34199da0:	601a      	str	r2, [r3, #0]

    /* Update the number of available bytes in the pool.  */
    block_link_ptr =  UX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(work_ptr);
34199da2:	6a3b      	ldr	r3, [r7, #32]
34199da4:	613b      	str	r3, [r7, #16]
    next_block_ptr =  *block_link_ptr;
34199da6:	693b      	ldr	r3, [r7, #16]
34199da8:	681b      	ldr	r3, [r3, #0]
34199daa:	60fb      	str	r3, [r7, #12]
    pool_ptr -> ux_byte_pool_available =
        pool_ptr -> ux_byte_pool_available + UX_UCHAR_POINTER_DIF(next_block_ptr, work_ptr);
34199dac:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34199dae:	681b      	ldr	r3, [r3, #0]
34199db0:	68f9      	ldr	r1, [r7, #12]
34199db2:	6a3a      	ldr	r2, [r7, #32]
34199db4:	1a8a      	subs	r2, r1, r2
34199db6:	441a      	add	r2, r3
    pool_ptr -> ux_byte_pool_available =
34199db8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34199dba:	601a      	str	r2, [r3, #0]

    /* Determine if the free block is prior to current search pointer.  */
    if (work_ptr < (pool_ptr -> ux_byte_pool_search))
34199dbc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34199dbe:	689b      	ldr	r3, [r3, #8]
34199dc0:	6a3a      	ldr	r2, [r7, #32]
34199dc2:	429a      	cmp	r2, r3
34199dc4:	d202      	bcs.n	34199dcc <_ux_utility_memory_free+0xec>
    {

        /* Yes, update the search pointer to the released block.  */
        pool_ptr -> ux_byte_pool_search =  work_ptr;
34199dc6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34199dc8:	6a3a      	ldr	r2, [r7, #32]
34199dca:	609a      	str	r2, [r3, #8]
    _ux_system -> ux_system_memory_byte_pool[index] -> ux_byte_pool_alloc_count --;
    _ux_system -> ux_system_memory_byte_pool[index] -> ux_byte_pool_alloc_total -= UX_UCHAR_POINTER_DIF(next_block_ptr, work_ptr);
#endif

    /* Release the protection.  */
    _ux_system_mutex_off(&_ux_system -> ux_system_mutex);
34199dcc:	4b04      	ldr	r3, [pc, #16]	@ (34199de0 <_ux_utility_memory_free+0x100>)
34199dce:	681b      	ldr	r3, [r3, #0]
34199dd0:	330c      	adds	r3, #12
34199dd2:	4618      	mov	r0, r3
34199dd4:	f000 f83b 	bl	34199e4e <_ux_utility_mutex_off>

    /* Return to caller.  */
    return;
34199dd8:	bf00      	nop
}
34199dda:	3728      	adds	r7, #40	@ 0x28
34199ddc:	46bd      	mov	sp, r7
34199dde:	bd80      	pop	{r7, pc}
34199de0:	341c33f4 	.word	0x341c33f4
34199de4:	ffffeeee 	.word	0xffffeeee

34199de8 <_ux_utility_memory_set>:
/*  09-30-2020     Chaoqiong Xiao           Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _ux_utility_memory_set(VOID *destination, UCHAR value, ULONG length)
{
34199de8:	b480      	push	{r7}
34199dea:	b087      	sub	sp, #28
34199dec:	af00      	add	r7, sp, #0
34199dee:	60f8      	str	r0, [r7, #12]
34199df0:	460b      	mov	r3, r1
34199df2:	607a      	str	r2, [r7, #4]
34199df4:	72fb      	strb	r3, [r7, #11]

UCHAR *    work_ptr;


    /* Setup the working pointer */
    work_ptr =  (UCHAR *) destination;
34199df6:	68fb      	ldr	r3, [r7, #12]
34199df8:	617b      	str	r3, [r7, #20]

    /* Loop to set the memory.  */
    while(length--)
34199dfa:	e004      	b.n	34199e06 <_ux_utility_memory_set+0x1e>
    {

        /* Set a byte.  */
        *work_ptr++ =  value;
34199dfc:	697b      	ldr	r3, [r7, #20]
34199dfe:	1c5a      	adds	r2, r3, #1
34199e00:	617a      	str	r2, [r7, #20]
34199e02:	7afa      	ldrb	r2, [r7, #11]
34199e04:	701a      	strb	r2, [r3, #0]
    while(length--)
34199e06:	687b      	ldr	r3, [r7, #4]
34199e08:	1e5a      	subs	r2, r3, #1
34199e0a:	607a      	str	r2, [r7, #4]
34199e0c:	2b00      	cmp	r3, #0
34199e0e:	d1f5      	bne.n	34199dfc <_ux_utility_memory_set+0x14>
    }

    /* Return to caller.  */
    return; 
34199e10:	bf00      	nop
}
34199e12:	371c      	adds	r7, #28
34199e14:	46bd      	mov	sp, r7
34199e16:	f85d 7b04 	ldr.w	r7, [sp], #4
34199e1a:	4770      	bx	lr

34199e1c <_ux_utility_mutex_create>:
/*                                            off in standalone build,    */
/*                                            resulting in version 6.1.11 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_utility_mutex_create(UX_MUTEX *mutex, CHAR *mutex_name)
{
34199e1c:	b580      	push	{r7, lr}
34199e1e:	b084      	sub	sp, #16
34199e20:	af00      	add	r7, sp, #0
34199e22:	6078      	str	r0, [r7, #4]
34199e24:	6039      	str	r1, [r7, #0]

UINT    status;


    /* Call ThreadX to create the Mutex object.  */
    status =  tx_mutex_create(mutex, (CHAR *) mutex_name, TX_NO_INHERIT);   
34199e26:	2334      	movs	r3, #52	@ 0x34
34199e28:	2200      	movs	r2, #0
34199e2a:	6839      	ldr	r1, [r7, #0]
34199e2c:	6878      	ldr	r0, [r7, #4]
34199e2e:	f7fe fdcd 	bl	341989cc <_txe_mutex_create>
34199e32:	60f8      	str	r0, [r7, #12]

    /* Check for status.  */
    if (status != UX_SUCCESS)
34199e34:	68fb      	ldr	r3, [r7, #12]
34199e36:	2b00      	cmp	r3, #0
34199e38:	d004      	beq.n	34199e44 <_ux_utility_mutex_create+0x28>
    {

        /* Error trap. */
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_UTILITY, status);
34199e3a:	68fa      	ldr	r2, [r7, #12]
34199e3c:	2108      	movs	r1, #8
34199e3e:	2002      	movs	r0, #2
34199e40:	f7ff fb3e 	bl	341994c0 <_ux_system_error_handler>
        /* If trace is enabled, insert this event into the trace buffer.  */
        UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_MUTEX_ERROR, mutex, 0, 0, UX_TRACE_ERRORS, 0, 0)

    }
    /* Return completion status.  */
    return(status);
34199e44:	68fb      	ldr	r3, [r7, #12]
}
34199e46:	4618      	mov	r0, r3
34199e48:	3710      	adds	r7, #16
34199e4a:	46bd      	mov	sp, r7
34199e4c:	bd80      	pop	{r7, pc}

34199e4e <_ux_utility_mutex_off>:
/*                                            off in standalone build,    */
/*                                            resulting in version 6.1.11 */
/*                                                                        */
/**************************************************************************/
VOID  _ux_utility_mutex_off(UX_MUTEX *mutex)
{
34199e4e:	b580      	push	{r7, lr}
34199e50:	b082      	sub	sp, #8
34199e52:	af00      	add	r7, sp, #0
34199e54:	6078      	str	r0, [r7, #4]

    /* Call ThreadX to release protection.  */
    tx_mutex_put(mutex);
34199e56:	6878      	ldr	r0, [r7, #4]
34199e58:	f7fe feb0 	bl	34198bbc <_txe_mutex_put>

    /* Return to caller.  */
    return;
34199e5c:	bf00      	nop
}
34199e5e:	3708      	adds	r7, #8
34199e60:	46bd      	mov	sp, r7
34199e62:	bd80      	pop	{r7, pc}

34199e64 <_ux_utility_mutex_on>:
/*                                            off in standalone build,    */
/*                                            resulting in version 6.1.11 */
/*                                                                        */
/**************************************************************************/
VOID  _ux_utility_mutex_on(UX_MUTEX *mutex)
{
34199e64:	b580      	push	{r7, lr}
34199e66:	b084      	sub	sp, #16
34199e68:	af00      	add	r7, sp, #0
34199e6a:	6078      	str	r0, [r7, #4]

UINT    status;

    /* Call ThreadX to get system mutex.  */
    status =  tx_mutex_get(mutex, TX_WAIT_FOREVER);
34199e6c:	f04f 31ff 	mov.w	r1, #4294967295
34199e70:	6878      	ldr	r0, [r7, #4]
34199e72:	f7fe fe49 	bl	34198b08 <_txe_mutex_get>
34199e76:	60f8      	str	r0, [r7, #12]

    /* Check for status.  */
    if (status != UX_SUCCESS)
34199e78:	68fb      	ldr	r3, [r7, #12]
34199e7a:	2b00      	cmp	r3, #0
34199e7c:	d005      	beq.n	34199e8a <_ux_utility_mutex_on+0x26>
    {

        /* Error trap. */
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_UTILITY, status);
34199e7e:	68fa      	ldr	r2, [r7, #12]
34199e80:	2108      	movs	r1, #8
34199e82:	2002      	movs	r0, #2
34199e84:	f7ff fb1c 	bl	341994c0 <_ux_system_error_handler>
    }

    /* Return to caller.  */
    return;
34199e88:	bf00      	nop
34199e8a:	bf00      	nop
}
34199e8c:	3710      	adds	r7, #16
34199e8e:	46bd      	mov	sp, r7
34199e90:	bd80      	pop	{r7, pc}

34199e92 <_ux_utility_semaphore_create>:
/*                                            off in standalone build,    */
/*                                            resulting in version 6.1.11 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_utility_semaphore_create(UX_SEMAPHORE *semaphore, CHAR *semaphore_name, UINT initial_count)
{
34199e92:	b580      	push	{r7, lr}
34199e94:	b086      	sub	sp, #24
34199e96:	af00      	add	r7, sp, #0
34199e98:	60f8      	str	r0, [r7, #12]
34199e9a:	60b9      	str	r1, [r7, #8]
34199e9c:	607a      	str	r2, [r7, #4]

UINT    status;

    /* Call ThreadX to create the semaphore.  */
    status =  tx_semaphore_create(semaphore, (CHAR *) semaphore_name, initial_count);
34199e9e:	231c      	movs	r3, #28
34199ea0:	687a      	ldr	r2, [r7, #4]
34199ea2:	68b9      	ldr	r1, [r7, #8]
34199ea4:	68f8      	ldr	r0, [r7, #12]
34199ea6:	f7ff f807 	bl	34198eb8 <_txe_semaphore_create>
34199eaa:	6178      	str	r0, [r7, #20]

    /* Check for status.  */
    if (status != UX_SUCCESS)
34199eac:	697b      	ldr	r3, [r7, #20]
34199eae:	2b00      	cmp	r3, #0
34199eb0:	d004      	beq.n	34199ebc <_ux_utility_semaphore_create+0x2a>
    {

        /* Error trap. */
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_UTILITY, status);
34199eb2:	697a      	ldr	r2, [r7, #20]
34199eb4:	2108      	movs	r1, #8
34199eb6:	2002      	movs	r0, #2
34199eb8:	f7ff fb02 	bl	341994c0 <_ux_system_error_handler>
        UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_SEMAPHORE_ERROR, semaphore, 0, 0, UX_TRACE_ERRORS, 0, 0)

    }

    /* Return completion status.  */
    return(status);
34199ebc:	697b      	ldr	r3, [r7, #20]
}
34199ebe:	4618      	mov	r0, r3
34199ec0:	3718      	adds	r7, #24
34199ec2:	46bd      	mov	sp, r7
34199ec4:	bd80      	pop	{r7, pc}

34199ec6 <_ux_utility_semaphore_delete>:
/*                                            off in standalone build,    */
/*                                            resulting in version 6.1.11 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_utility_semaphore_delete(UX_SEMAPHORE *semaphore)
{
34199ec6:	b580      	push	{r7, lr}
34199ec8:	b084      	sub	sp, #16
34199eca:	af00      	add	r7, sp, #0
34199ecc:	6078      	str	r0, [r7, #4]

UINT    status;

    /* Call ThreadX Semaphore delete function.  */
    status =  tx_semaphore_delete(semaphore);
34199ece:	6878      	ldr	r0, [r7, #4]
34199ed0:	f7ff f888 	bl	34198fe4 <_txe_semaphore_delete>
34199ed4:	60f8      	str	r0, [r7, #12]

    /* Return completion status.  */
    return(status);
34199ed6:	68fb      	ldr	r3, [r7, #12]
}
34199ed8:	4618      	mov	r0, r3
34199eda:	3710      	adds	r7, #16
34199edc:	46bd      	mov	sp, r7
34199ede:	bd80      	pop	{r7, pc}

34199ee0 <_ux_utility_semaphore_get>:
/*                                            off in standalone build,    */
/*                                            resulting in version 6.1.11 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_utility_semaphore_get(UX_SEMAPHORE *semaphore, ULONG semaphore_signal)
{
34199ee0:	b580      	push	{r7, lr}
34199ee2:	b092      	sub	sp, #72	@ 0x48
34199ee4:	af06      	add	r7, sp, #24
34199ee6:	6078      	str	r0, [r7, #4]
34199ee8:	6039      	str	r1, [r7, #0]
ULONG       time_slice;
UX_THREAD   *next_thread;
UX_THREAD   *suspended_thread;

    /* Call TX to know my own tread.  */
    my_thread = tx_thread_identify();
34199eea:	f7fd f9dd 	bl	341972a8 <_tx_thread_identify>
34199eee:	62f8      	str	r0, [r7, #44]	@ 0x2c

    /* Retrieve information about the previously created thread "my_thread." */
    tx_thread_info_get(my_thread, &name, &state, &run_count,
34199ef0:	f107 001c 	add.w	r0, r7, #28
34199ef4:	f107 0220 	add.w	r2, r7, #32
34199ef8:	f107 0124 	add.w	r1, r7, #36	@ 0x24
34199efc:	f107 0308 	add.w	r3, r7, #8
34199f00:	9304      	str	r3, [sp, #16]
34199f02:	f107 030c 	add.w	r3, r7, #12
34199f06:	9303      	str	r3, [sp, #12]
34199f08:	f107 0310 	add.w	r3, r7, #16
34199f0c:	9302      	str	r3, [sp, #8]
34199f0e:	f107 0314 	add.w	r3, r7, #20
34199f12:	9301      	str	r3, [sp, #4]
34199f14:	f107 0318 	add.w	r3, r7, #24
34199f18:	9300      	str	r3, [sp, #0]
34199f1a:	4603      	mov	r3, r0
34199f1c:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
34199f1e:	f7ff fa1d 	bl	3419935c <_txe_thread_info_get>
                       &priority, &preemption_threshold,
                       &time_slice, &next_thread,&suspended_thread);

    /* Is this the lowest priority thread in the system trying to use TX services ? */
    if (priority > _ux_system -> ux_system_thread_lowest_priority)
34199f22:	4b0a      	ldr	r3, [pc, #40]	@ (34199f4c <_ux_utility_semaphore_get+0x6c>)
34199f24:	681b      	ldr	r3, [r3, #0]
34199f26:	689a      	ldr	r2, [r3, #8]
34199f28:	69bb      	ldr	r3, [r7, #24]
34199f2a:	429a      	cmp	r2, r3
34199f2c:	d203      	bcs.n	34199f36 <_ux_utility_semaphore_get+0x56>
    {

        /* We need to remember this thread priority.  */
        _ux_system -> ux_system_thread_lowest_priority = priority;
34199f2e:	4b07      	ldr	r3, [pc, #28]	@ (34199f4c <_ux_utility_semaphore_get+0x6c>)
34199f30:	681b      	ldr	r3, [r3, #0]
34199f32:	69ba      	ldr	r2, [r7, #24]
34199f34:	609a      	str	r2, [r3, #8]
        
    }

    /* Get ThreadX semaphore instance.  */
    status =  tx_semaphore_get(semaphore, semaphore_signal);
34199f36:	6839      	ldr	r1, [r7, #0]
34199f38:	6878      	ldr	r0, [r7, #4]
34199f3a:	f7ff f891 	bl	34199060 <_txe_semaphore_get>
34199f3e:	62b8      	str	r0, [r7, #40]	@ 0x28

    /* Return completion status.  */
    return(status);
34199f40:	6abb      	ldr	r3, [r7, #40]	@ 0x28
}
34199f42:	4618      	mov	r0, r3
34199f44:	3730      	adds	r7, #48	@ 0x30
34199f46:	46bd      	mov	sp, r7
34199f48:	bd80      	pop	{r7, pc}
34199f4a:	bf00      	nop
34199f4c:	341c33f4 	.word	0x341c33f4

34199f50 <_ux_utility_semaphore_put>:
/*                                            off in standalone build,    */
/*                                            resulting in version 6.1.11 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_utility_semaphore_put(UX_SEMAPHORE *semaphore)
{
34199f50:	b580      	push	{r7, lr}
34199f52:	b084      	sub	sp, #16
34199f54:	af00      	add	r7, sp, #0
34199f56:	6078      	str	r0, [r7, #4]

UINT    status;

    /* Put a ThreadX semaphore.  */
    status =  tx_semaphore_put(semaphore);
34199f58:	6878      	ldr	r0, [r7, #4]
34199f5a:	f7ff f8c3 	bl	341990e4 <_txe_semaphore_put>
34199f5e:	60f8      	str	r0, [r7, #12]

    /* Return completion status.  */
    return(status);
34199f60:	68fb      	ldr	r3, [r7, #12]
}
34199f62:	4618      	mov	r0, r3
34199f64:	3710      	adds	r7, #16
34199f66:	46bd      	mov	sp, r7
34199f68:	bd80      	pop	{r7, pc}

34199f6a <_ux_utility_short_get>:
/*  09-30-2020     Chaoqiong Xiao           Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
ULONG  _ux_utility_short_get(UCHAR * address)
{
34199f6a:	b480      	push	{r7}
34199f6c:	b085      	sub	sp, #20
34199f6e:	af00      	add	r7, sp, #0
34199f70:	6078      	str	r0, [r7, #4]
USHORT   value;


    /* In order to make this function endian agnostic and memory alignment
       independent, we read a byte at a time from the address.  */
    value =  (USHORT) *address++;
34199f72:	687b      	ldr	r3, [r7, #4]
34199f74:	1c5a      	adds	r2, r3, #1
34199f76:	607a      	str	r2, [r7, #4]
34199f78:	781b      	ldrb	r3, [r3, #0]
34199f7a:	81fb      	strh	r3, [r7, #14]
    value |=  (USHORT)(*address << 8);
34199f7c:	687b      	ldr	r3, [r7, #4]
34199f7e:	781b      	ldrb	r3, [r3, #0]
34199f80:	021b      	lsls	r3, r3, #8
34199f82:	b29a      	uxth	r2, r3
34199f84:	89fb      	ldrh	r3, [r7, #14]
34199f86:	4313      	orrs	r3, r2
34199f88:	81fb      	strh	r3, [r7, #14]

    /* Return to caller.  */
    return((ULONG) value);
34199f8a:	89fb      	ldrh	r3, [r7, #14]
}
34199f8c:	4618      	mov	r0, r3
34199f8e:	3714      	adds	r7, #20
34199f90:	46bd      	mov	sp, r7
34199f92:	f85d 7b04 	ldr.w	r7, [sp], #4
34199f96:	4770      	bx	lr

34199f98 <_ux_utility_short_get_big_endian>:
/*  09-30-2020     Chaoqiong Xiao           Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
ULONG   _ux_utility_short_get_big_endian(UCHAR * address)
{
34199f98:	b480      	push	{r7}
34199f9a:	b085      	sub	sp, #20
34199f9c:	af00      	add	r7, sp, #0
34199f9e:	6078      	str	r0, [r7, #4]

USHORT  value;

    /* We read a byte at a time from the address.  */
    value =  (USHORT)((*address++) << 8);
34199fa0:	687b      	ldr	r3, [r7, #4]
34199fa2:	1c5a      	adds	r2, r3, #1
34199fa4:	607a      	str	r2, [r7, #4]
34199fa6:	781b      	ldrb	r3, [r3, #0]
34199fa8:	021b      	lsls	r3, r3, #8
34199faa:	81fb      	strh	r3, [r7, #14]
    value =  (USHORT)(value | *address);
34199fac:	687b      	ldr	r3, [r7, #4]
34199fae:	781b      	ldrb	r3, [r3, #0]
34199fb0:	461a      	mov	r2, r3
34199fb2:	89fb      	ldrh	r3, [r7, #14]
34199fb4:	4313      	orrs	r3, r2
34199fb6:	81fb      	strh	r3, [r7, #14]

    /* Return 16-bit value.  */
    return((ULONG) value);
34199fb8:	89fb      	ldrh	r3, [r7, #14]
}
34199fba:	4618      	mov	r0, r3
34199fbc:	3714      	adds	r7, #20
34199fbe:	46bd      	mov	sp, r7
34199fc0:	f85d 7b04 	ldr.w	r7, [sp], #4
34199fc4:	4770      	bx	lr

34199fc6 <_ux_utility_short_put_big_endian>:
/*  09-30-2020     Chaoqiong Xiao           Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _ux_utility_short_put_big_endian(UCHAR * address, USHORT value)
{
34199fc6:	b480      	push	{r7}
34199fc8:	b085      	sub	sp, #20
34199fca:	af00      	add	r7, sp, #0
34199fcc:	6078      	str	r0, [r7, #4]
34199fce:	460b      	mov	r3, r1
34199fd0:	807b      	strh	r3, [r7, #2]
USHORT  low_byte_value;
USHORT  high_byte_value;

    
    /* First we swap the value bytes. */
    low_byte_value =  value >> 8;
34199fd2:	887b      	ldrh	r3, [r7, #2]
34199fd4:	0a1b      	lsrs	r3, r3, #8
34199fd6:	81fb      	strh	r3, [r7, #14]
    high_byte_value =  (USHORT)(value<< 8);
34199fd8:	887b      	ldrh	r3, [r7, #2]
34199fda:	021b      	lsls	r3, r3, #8
34199fdc:	81bb      	strh	r3, [r7, #12]
    value =  high_byte_value | low_byte_value;
34199fde:	89ba      	ldrh	r2, [r7, #12]
34199fe0:	89fb      	ldrh	r3, [r7, #14]
34199fe2:	4313      	orrs	r3, r2
34199fe4:	807b      	strh	r3, [r7, #2]

    /* In order to make this function endian agnostic and memory alignment
       independent, we write a byte at a time from the address.  */
    *address++ =  (UCHAR) (value & 0xff);
34199fe6:	687b      	ldr	r3, [r7, #4]
34199fe8:	1c5a      	adds	r2, r3, #1
34199fea:	607a      	str	r2, [r7, #4]
34199fec:	887a      	ldrh	r2, [r7, #2]
34199fee:	b2d2      	uxtb	r2, r2
34199ff0:	701a      	strb	r2, [r3, #0]
    *address=     (UCHAR) ((value >> 8) & 0xff);
34199ff2:	887b      	ldrh	r3, [r7, #2]
34199ff4:	0a1b      	lsrs	r3, r3, #8
34199ff6:	b29b      	uxth	r3, r3
34199ff8:	b2da      	uxtb	r2, r3
34199ffa:	687b      	ldr	r3, [r7, #4]
34199ffc:	701a      	strb	r2, [r3, #0]

    /* Return to caller. */
    return;
34199ffe:	bf00      	nop
}
3419a000:	3714      	adds	r7, #20
3419a002:	46bd      	mov	sp, r7
3419a004:	f85d 7b04 	ldr.w	r7, [sp], #4
3419a008:	4770      	bx	lr

3419a00a <_ux_utility_string_length_check>:
/*  07-29-2022     Chaoqiong Xiao           Modified comment(s),          */
/*                                            resulting in version 6.1.12 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_utility_string_length_check(UCHAR *string, UINT *string_length_ptr, UINT max_string_length)
{
3419a00a:	b580      	push	{r7, lr}
3419a00c:	b086      	sub	sp, #24
3419a00e:	af00      	add	r7, sp, #0
3419a010:	60f8      	str	r0, [r7, #12]
3419a012:	60b9      	str	r1, [r7, #8]
3419a014:	607a      	str	r2, [r7, #4]

UINT    string_length;


    if (string == UX_NULL)
3419a016:	68fb      	ldr	r3, [r7, #12]
3419a018:	2b00      	cmp	r3, #0
3419a01a:	d101      	bne.n	3419a020 <_ux_utility_string_length_check+0x16>
        return(UX_ERROR);
3419a01c:	23ff      	movs	r3, #255	@ 0xff
3419a01e:	e01d      	b.n	3419a05c <_ux_utility_string_length_check+0x52>

    string_length = 0;
3419a020:	2300      	movs	r3, #0
3419a022:	617b      	str	r3, [r7, #20]

    while (1)
    {

        if (string[string_length] == '\0')
3419a024:	68fa      	ldr	r2, [r7, #12]
3419a026:	697b      	ldr	r3, [r7, #20]
3419a028:	4413      	add	r3, r2
3419a02a:	781b      	ldrb	r3, [r3, #0]
3419a02c:	2b00      	cmp	r3, #0
3419a02e:	d00d      	beq.n	3419a04c <_ux_utility_string_length_check+0x42>
            break;

        string_length++;
3419a030:	697b      	ldr	r3, [r7, #20]
3419a032:	3301      	adds	r3, #1
3419a034:	617b      	str	r3, [r7, #20]
        if (string_length > max_string_length)
3419a036:	697a      	ldr	r2, [r7, #20]
3419a038:	687b      	ldr	r3, [r7, #4]
3419a03a:	429a      	cmp	r2, r3
3419a03c:	d9f2      	bls.n	3419a024 <_ux_utility_string_length_check+0x1a>
        {

            /* Error trap. */
            _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_UTILITY, UX_ERROR);
3419a03e:	22ff      	movs	r2, #255	@ 0xff
3419a040:	2108      	movs	r1, #8
3419a042:	2002      	movs	r0, #2
3419a044:	f7ff fa3c 	bl	341994c0 <_ux_system_error_handler>

            return(UX_ERROR);
3419a048:	23ff      	movs	r3, #255	@ 0xff
3419a04a:	e007      	b.n	3419a05c <_ux_utility_string_length_check+0x52>
            break;
3419a04c:	bf00      	nop
        }
    }

    if (string_length_ptr)
3419a04e:	68bb      	ldr	r3, [r7, #8]
3419a050:	2b00      	cmp	r3, #0
3419a052:	d002      	beq.n	3419a05a <_ux_utility_string_length_check+0x50>
        *string_length_ptr = string_length;
3419a054:	68bb      	ldr	r3, [r7, #8]
3419a056:	697a      	ldr	r2, [r7, #20]
3419a058:	601a      	str	r2, [r3, #0]

    return(UX_SUCCESS); 
3419a05a:	2300      	movs	r3, #0
}
3419a05c:	4618      	mov	r0, r3
3419a05e:	3718      	adds	r7, #24
3419a060:	46bd      	mov	sp, r7
3419a062:	bd80      	pop	{r7, pc}

3419a064 <_ux_utility_thread_create>:
UINT  _ux_utility_thread_create(UX_THREAD *thread_ptr, CHAR *name, 
                VOID (*entry_function)(ULONG), ULONG entry_input,
                VOID *stack_start, ULONG stack_size, 
                UINT priority, UINT preempt_threshold,
                ULONG time_slice, UINT auto_start)
{
3419a064:	b580      	push	{r7, lr}
3419a066:	b08e      	sub	sp, #56	@ 0x38
3419a068:	af08      	add	r7, sp, #32
3419a06a:	60f8      	str	r0, [r7, #12]
3419a06c:	60b9      	str	r1, [r7, #8]
3419a06e:	607a      	str	r2, [r7, #4]
3419a070:	603b      	str	r3, [r7, #0]

UINT    status;


    /* Call ThreadX to create USBX thread.  */
    status =  tx_thread_create(thread_ptr,name,entry_function,entry_input,
3419a072:	23b0      	movs	r3, #176	@ 0xb0
3419a074:	9306      	str	r3, [sp, #24]
3419a076:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
3419a078:	9305      	str	r3, [sp, #20]
3419a07a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3419a07c:	9304      	str	r3, [sp, #16]
3419a07e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3419a080:	9303      	str	r3, [sp, #12]
3419a082:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419a084:	9302      	str	r3, [sp, #8]
3419a086:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419a088:	9301      	str	r3, [sp, #4]
3419a08a:	6a3b      	ldr	r3, [r7, #32]
3419a08c:	9300      	str	r3, [sp, #0]
3419a08e:	683b      	ldr	r3, [r7, #0]
3419a090:	687a      	ldr	r2, [r7, #4]
3419a092:	68b9      	ldr	r1, [r7, #8]
3419a094:	68f8      	ldr	r0, [r7, #12]
3419a096:	f7ff f843 	bl	34199120 <_txe_thread_create>
3419a09a:	6178      	str	r0, [r7, #20]
                    stack_start,stack_size, priority,preempt_threshold,time_slice,auto_start);

    /* Check for status.  */
    if (status != UX_SUCCESS)
3419a09c:	697b      	ldr	r3, [r7, #20]
3419a09e:	2b00      	cmp	r3, #0
3419a0a0:	d004      	beq.n	3419a0ac <_ux_utility_thread_create+0x48>
    {

        /* Error trap. */
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_UTILITY, status);
3419a0a2:	697a      	ldr	r2, [r7, #20]
3419a0a4:	2108      	movs	r1, #8
3419a0a6:	2002      	movs	r0, #2
3419a0a8:	f7ff fa0a 	bl	341994c0 <_ux_system_error_handler>
        /* If trace is enabled, insert this event into the trace buffer.  */
        UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_THREAD_ERROR, thread_ptr, 0, 0, UX_TRACE_ERRORS, 0, 0)

    }
    /* Return completion status.  */
    return(status);
3419a0ac:	697b      	ldr	r3, [r7, #20]
}
3419a0ae:	4618      	mov	r0, r3
3419a0b0:	3718      	adds	r7, #24
3419a0b2:	46bd      	mov	sp, r7
3419a0b4:	bd80      	pop	{r7, pc}

3419a0b6 <_ux_utility_thread_delete>:
/*                                            off in standalone build,    */
/*                                            resulting in version 6.1.11 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_utility_thread_delete(UX_THREAD *thread_ptr)
{
3419a0b6:	b580      	push	{r7, lr}
3419a0b8:	b084      	sub	sp, #16
3419a0ba:	af00      	add	r7, sp, #0
3419a0bc:	6078      	str	r0, [r7, #4]

UINT    status;


    /* Call ThreadX to terminate the USBX thread.  */
    tx_thread_terminate(thread_ptr);
3419a0be:	6878      	ldr	r0, [r7, #4]
3419a0c0:	f7ff f9d2 	bl	34199468 <_txe_thread_terminate>

    /* Call ThreadX to delete the USBX thread.  */
    status =  tx_thread_delete(thread_ptr);
3419a0c4:	6878      	ldr	r0, [r7, #4]
3419a0c6:	f7ff f91d 	bl	34199304 <_txe_thread_delete>
3419a0ca:	60f8      	str	r0, [r7, #12]

    /* Return completion status.  */
    return(status);
3419a0cc:	68fb      	ldr	r3, [r7, #12]
}
3419a0ce:	4618      	mov	r0, r3
3419a0d0:	3710      	adds	r7, #16
3419a0d2:	46bd      	mov	sp, r7
3419a0d4:	bd80      	pop	{r7, pc}

3419a0d6 <_ux_utility_thread_relinquish>:
/*                                            off in standalone build,    */
/*                                            resulting in version 6.1.11 */
/*                                                                        */
/**************************************************************************/
VOID  _ux_utility_thread_relinquish(VOID)
{
3419a0d6:	b580      	push	{r7, lr}
3419a0d8:	af00      	add	r7, sp, #0

    /* Call ThreadX to relinquish a USBX thread.  */
    tx_thread_relinquish();
3419a0da:	f7ff f96d 	bl	341993b8 <_txe_thread_relinquish>

}
3419a0de:	bf00      	nop
3419a0e0:	bd80      	pop	{r7, pc}

3419a0e2 <_ux_utility_thread_resume>:
/*                                            off in standalone build,    */
/*                                            resulting in version 6.1.11 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_utility_thread_resume(UX_THREAD *thread_ptr)
{
3419a0e2:	b580      	push	{r7, lr}
3419a0e4:	b084      	sub	sp, #16
3419a0e6:	af00      	add	r7, sp, #0
3419a0e8:	6078      	str	r0, [r7, #4]

UINT    status;


    /* Call ThreadX to resume USBX thread.  */
    status =  tx_thread_resume(thread_ptr);
3419a0ea:	6878      	ldr	r0, [r7, #4]
3419a0ec:	f7ff f980 	bl	341993f0 <_txe_thread_resume>
3419a0f0:	60f8      	str	r0, [r7, #12]

    /* Return completion status.  */
    return(status);
3419a0f2:	68fb      	ldr	r3, [r7, #12]
}
3419a0f4:	4618      	mov	r0, r3
3419a0f6:	3710      	adds	r7, #16
3419a0f8:	46bd      	mov	sp, r7
3419a0fa:	bd80      	pop	{r7, pc}

3419a0fc <_ux_utility_thread_suspend>:
/*                                            off in standalone build,    */
/*                                            resulting in version 6.1.11 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_utility_thread_suspend(UX_THREAD *thread_ptr)
{
3419a0fc:	b580      	push	{r7, lr}
3419a0fe:	b084      	sub	sp, #16
3419a100:	af00      	add	r7, sp, #0
3419a102:	6078      	str	r0, [r7, #4]

UINT    status;


    /* Call ThreadX to suspend USBX thread.  */
    status =  tx_thread_suspend(thread_ptr);
3419a104:	6878      	ldr	r0, [r7, #4]
3419a106:	f7ff f991 	bl	3419942c <_txe_thread_suspend>
3419a10a:	60f8      	str	r0, [r7, #12]

    /* Return completion status.  */
    return(status);
3419a10c:	68fb      	ldr	r3, [r7, #12]
}
3419a10e:	4618      	mov	r0, r3
3419a110:	3710      	adds	r7, #16
3419a112:	46bd      	mov	sp, r7
3419a114:	bd80      	pop	{r7, pc}
	...

3419a118 <_ux_device_stack_alternate_setting_get>:
/*                                            names conflict C++ keyword, */
/*                                            resulting in version 6.1.12 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_stack_alternate_setting_get(ULONG interface_value)
{
3419a118:	b580      	push	{r7, lr}
3419a11a:	b088      	sub	sp, #32
3419a11c:	af00      	add	r7, sp, #0
3419a11e:	6078      	str	r0, [r7, #4]
                                
    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_STACK_ALTERNATE_SETTING_GET, interface_value, 0, 0, 0, UX_TRACE_DEVICE_STACK_EVENTS, 0, 0)

    /* Get the pointer to the device.  */
    device =  &_ux_system_slave -> ux_system_slave_device;
3419a120:	4b1b      	ldr	r3, [pc, #108]	@ (3419a190 <_ux_device_stack_alternate_setting_get+0x78>)
3419a122:	681b      	ldr	r3, [r3, #0]
3419a124:	3320      	adds	r3, #32
3419a126:	61bb      	str	r3, [r7, #24]

    /* If the device was in the configured state, there may be interfaces
       attached to the configuration.  */
    if (device -> ux_slave_device_state == UX_DEVICE_CONFIGURED)
3419a128:	69bb      	ldr	r3, [r7, #24]
3419a12a:	681b      	ldr	r3, [r3, #0]
3419a12c:	2b03      	cmp	r3, #3
3419a12e:	d129      	bne.n	3419a184 <_ux_device_stack_alternate_setting_get+0x6c>
    {

        /* Obtain the pointer to the first interface attached.  */
        interface_ptr =  device -> ux_slave_device_first_interface;
3419a130:	69bb      	ldr	r3, [r7, #24]
3419a132:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
3419a136:	61fb      	str	r3, [r7, #28]

#if !defined(UX_DEVICE_INITIALIZE_FRAMEWORK_SCAN_DISABLE) || UX_MAX_DEVICE_INTERFACES > 1
        /* Start parsing each interface.  */
        while (interface_ptr != UX_NULL)
3419a138:	e021      	b.n	3419a17e <_ux_device_stack_alternate_setting_get+0x66>
        if (interface_ptr != UX_NULL)
#endif
        {

            /* Check if this is the interface we have an inquiry for.  */
            if (interface_ptr -> ux_slave_interface_descriptor.bInterfaceNumber == interface_value)
3419a13a:	69fb      	ldr	r3, [r7, #28]
3419a13c:	7b9b      	ldrb	r3, [r3, #14]
3419a13e:	461a      	mov	r2, r3
3419a140:	687b      	ldr	r3, [r7, #4]
3419a142:	4293      	cmp	r3, r2
3419a144:	d118      	bne.n	3419a178 <_ux_device_stack_alternate_setting_get+0x60>
            {

                /* Get the control endpoint of the device.  */                
                endpoint =  &device -> ux_slave_device_control_endpoint;
3419a146:	69bb      	ldr	r3, [r7, #24]
3419a148:	3318      	adds	r3, #24
3419a14a:	617b      	str	r3, [r7, #20]

                /* Get the pointer to the transfer request associated with the endpoint.  */
                transfer_request =  &endpoint -> ux_slave_endpoint_transfer_request;
3419a14c:	697b      	ldr	r3, [r7, #20]
3419a14e:	3320      	adds	r3, #32
3419a150:	613b      	str	r3, [r7, #16]

                /* Set the value of the alternate setting in the buffer.  */
                *transfer_request -> ux_slave_transfer_request_data_pointer =
3419a152:	693b      	ldr	r3, [r7, #16]
3419a154:	68db      	ldr	r3, [r3, #12]
                            (UCHAR) interface_ptr -> ux_slave_interface_descriptor.bAlternateSetting;
3419a156:	69fa      	ldr	r2, [r7, #28]
3419a158:	7bd2      	ldrb	r2, [r2, #15]
                *transfer_request -> ux_slave_transfer_request_data_pointer =
3419a15a:	701a      	strb	r2, [r3, #0]

                /* Setup the length appropriately.  */
                transfer_request -> ux_slave_transfer_request_requested_length =  1;
3419a15c:	693b      	ldr	r3, [r7, #16]
3419a15e:	2201      	movs	r2, #1
3419a160:	615a      	str	r2, [r3, #20]

                /* Set the phase of the transfer to data out.  */
                transfer_request -> ux_slave_transfer_request_phase =  UX_TRANSFER_PHASE_DATA_OUT;
3419a162:	693b      	ldr	r3, [r7, #16]
3419a164:	2203      	movs	r2, #3
3419a166:	629a      	str	r2, [r3, #40]	@ 0x28

                /* Send the descriptor with the appropriate length to the host.  */
                status =  _ux_device_stack_transfer_request(transfer_request, 1, 1);
3419a168:	2201      	movs	r2, #1
3419a16a:	2101      	movs	r1, #1
3419a16c:	6938      	ldr	r0, [r7, #16]
3419a16e:	f001 fcc9 	bl	3419bb04 <_ux_device_stack_transfer_request>
3419a172:	60f8      	str	r0, [r7, #12]

                /* Return the function status.  */
                return(status);
3419a174:	68fb      	ldr	r3, [r7, #12]
3419a176:	e006      	b.n	3419a186 <_ux_device_stack_alternate_setting_get+0x6e>
            }

#if !defined(UX_DEVICE_INITIALIZE_FRAMEWORK_SCAN_DISABLE) || UX_MAX_DEVICE_INTERFACES > 1
            /* Get the next interface.  */
            interface_ptr =  interface_ptr -> ux_slave_interface_next_interface;
3419a178:	69fb      	ldr	r3, [r7, #28]
3419a17a:	699b      	ldr	r3, [r3, #24]
3419a17c:	61fb      	str	r3, [r7, #28]
        while (interface_ptr != UX_NULL)
3419a17e:	69fb      	ldr	r3, [r7, #28]
3419a180:	2b00      	cmp	r3, #0
3419a182:	d1da      	bne.n	3419a13a <_ux_device_stack_alternate_setting_get+0x22>
#endif
        }
    }

    /* Return error completion. */
    return(UX_ERROR);
3419a184:	23ff      	movs	r3, #255	@ 0xff
}
3419a186:	4618      	mov	r0, r3
3419a188:	3720      	adds	r7, #32
3419a18a:	46bd      	mov	sp, r7
3419a18c:	bd80      	pop	{r7, pc}
3419a18e:	bf00      	nop
3419a190:	341c33f8 	.word	0x341c33f8

3419a194 <_ux_device_stack_alternate_setting_set>:
/*                                            names conflict C++ keyword, */
/*                                            resulting in version 6.1.12 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_stack_alternate_setting_set(ULONG interface_value, ULONG alternate_setting_value)
{
3419a194:	b580      	push	{r7, lr}
3419a196:	b0a4      	sub	sp, #144	@ 0x90
3419a198:	af00      	add	r7, sp, #0
3419a19a:	6078      	str	r0, [r7, #4]
3419a19c:	6039      	str	r1, [r7, #0]

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_STACK_ALTERNATE_SETTING_SET, interface_value, alternate_setting_value, 0, 0, UX_TRACE_DEVICE_STACK_EVENTS, 0, 0)

    /* Get the pointer to the device. */
    device =  &_ux_system_slave -> ux_system_slave_device;
3419a19e:	4bb5      	ldr	r3, [pc, #724]	@ (3419a474 <_ux_device_stack_alternate_setting_set+0x2e0>)
3419a1a0:	681b      	ldr	r3, [r3, #0]
3419a1a2:	3320      	adds	r3, #32
3419a1a4:	673b      	str	r3, [r7, #112]	@ 0x70

    /* Protocol error must be reported when it's unconfigured */
    if (device -> ux_slave_device_state != UX_DEVICE_CONFIGURED)
3419a1a6:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
3419a1a8:	681b      	ldr	r3, [r3, #0]
3419a1aa:	2b03      	cmp	r3, #3
3419a1ac:	d001      	beq.n	3419a1b2 <_ux_device_stack_alternate_setting_set+0x1e>
        return(UX_FUNCTION_NOT_SUPPORTED);
3419a1ae:	2354      	movs	r3, #84	@ 0x54
3419a1b0:	e1ef      	b.n	3419a592 <_ux_device_stack_alternate_setting_set+0x3fe>

    /* Find the current interface.  */
    interface_ptr =  device -> ux_slave_device_first_interface;
3419a1b2:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
3419a1b4:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
3419a1b8:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c

#if !defined(UX_DEVICE_INITIALIZE_FRAMEWORK_SCAN_DISABLE) || UX_MAX_DEVICE_INTERFACES > 1
    /* Scan all interfaces if any. */
    while (interface_ptr != UX_NULL)
3419a1bc:	e00b      	b.n	3419a1d6 <_ux_device_stack_alternate_setting_set+0x42>
    {

        if (interface_ptr -> ux_slave_interface_descriptor.bInterfaceNumber == interface_value)
3419a1be:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
3419a1c2:	7b9b      	ldrb	r3, [r3, #14]
3419a1c4:	461a      	mov	r2, r3
3419a1c6:	687b      	ldr	r3, [r7, #4]
3419a1c8:	4293      	cmp	r3, r2
3419a1ca:	d009      	beq.n	3419a1e0 <_ux_device_stack_alternate_setting_set+0x4c>
            break;
        else
            interface_ptr =  interface_ptr -> ux_slave_interface_next_interface;
3419a1cc:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
3419a1d0:	699b      	ldr	r3, [r3, #24]
3419a1d2:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
    while (interface_ptr != UX_NULL)
3419a1d6:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
3419a1da:	2b00      	cmp	r3, #0
3419a1dc:	d1ef      	bne.n	3419a1be <_ux_device_stack_alternate_setting_set+0x2a>
3419a1de:	e000      	b.n	3419a1e2 <_ux_device_stack_alternate_setting_set+0x4e>
            break;
3419a1e0:	bf00      	nop
        interface_ptr = UX_NULL;
#endif

    /* We must have found the interface pointer for the interface value
       requested by the caller.  */
    if (interface_ptr == UX_NULL)
3419a1e2:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
3419a1e6:	2b00      	cmp	r3, #0
3419a1e8:	d106      	bne.n	3419a1f8 <_ux_device_stack_alternate_setting_set+0x64>
    {

        /* Error trap. */
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_CLASS, UX_INTERFACE_HANDLE_UNKNOWN);
3419a1ea:	2252      	movs	r2, #82	@ 0x52
3419a1ec:	2107      	movs	r1, #7
3419a1ee:	2002      	movs	r0, #2
3419a1f0:	f7ff f966 	bl	341994c0 <_ux_system_error_handler>

        /* If trace is enabled, insert this event into the trace buffer.  */
        UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_INTERFACE_HANDLE_UNKNOWN, interface_ptr, 0, 0, UX_TRACE_ERRORS, 0, 0)

        return(UX_INTERFACE_HANDLE_UNKNOWN);
3419a1f4:	2352      	movs	r3, #82	@ 0x52
3419a1f6:	e1cc      	b.n	3419a592 <_ux_device_stack_alternate_setting_set+0x3fe>
    }

    /* If the host is requesting a change of alternate setting to the current one,
       we do not need to do any work.  */
    if (interface_ptr -> ux_slave_interface_descriptor.bAlternateSetting == alternate_setting_value)
3419a1f8:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
3419a1fc:	7bdb      	ldrb	r3, [r3, #15]
3419a1fe:	461a      	mov	r2, r3
3419a200:	683b      	ldr	r3, [r7, #0]
3419a202:	4293      	cmp	r3, r2
3419a204:	d101      	bne.n	3419a20a <_ux_device_stack_alternate_setting_set+0x76>
        return(UX_SUCCESS);       
3419a206:	2300      	movs	r3, #0
3419a208:	e1c3      	b.n	3419a592 <_ux_device_stack_alternate_setting_set+0x3fe>

    return(UX_FUNCTION_NOT_SUPPORTED);
#else

    /* Get the pointer to the DCD. */
    dcd =  &_ux_system_slave->ux_system_slave_dcd;
3419a20a:	4b9a      	ldr	r3, [pc, #616]	@ (3419a474 <_ux_device_stack_alternate_setting_set+0x2e0>)
3419a20c:	681b      	ldr	r3, [r3, #0]
3419a20e:	66fb      	str	r3, [r7, #108]	@ 0x6c

    /* We may have multiple configurations!  */
    device_framework =  _ux_system_slave -> ux_system_slave_device_framework;
3419a210:	4b98      	ldr	r3, [pc, #608]	@ (3419a474 <_ux_device_stack_alternate_setting_set+0x2e0>)
3419a212:	681b      	ldr	r3, [r3, #0]
3419a214:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3419a218:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
    device_framework_length =  _ux_system_slave -> ux_system_slave_device_framework_length;
3419a21c:	4b95      	ldr	r3, [pc, #596]	@ (3419a474 <_ux_device_stack_alternate_setting_set+0x2e0>)
3419a21e:	681b      	ldr	r3, [r3, #0]
3419a220:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3419a224:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84

    /* Parse the device framework and locate a configuration descriptor. */
    while (device_framework_length != 0)
3419a228:	e1ad      	b.n	3419a586 <_ux_device_stack_alternate_setting_set+0x3f2>
    {

        /* Get the length of the current descriptor.  */
        descriptor_length =  (ULONG) *device_framework;
3419a22a:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
3419a22e:	781b      	ldrb	r3, [r3, #0]
3419a230:	66bb      	str	r3, [r7, #104]	@ 0x68

        /* And its length.  */
        descriptor_type =*  (device_framework + 1);
3419a232:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
3419a236:	785b      	ldrb	r3, [r3, #1]
3419a238:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
                
        /* Check if this is a configuration descriptor. */
        if (descriptor_type == UX_CONFIGURATION_DESCRIPTOR_ITEM)
3419a23c:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
3419a240:	2b02      	cmp	r3, #2
3419a242:	f040 8194 	bne.w	3419a56e <_ux_device_stack_alternate_setting_set+0x3da>
        {

            /* Parse the descriptor in something more readable. */
            _ux_utility_descriptor_parse(device_framework,
3419a246:	f107 0344 	add.w	r3, r7, #68	@ 0x44
3419a24a:	2208      	movs	r2, #8
3419a24c:	498a      	ldr	r1, [pc, #552]	@ (3419a478 <_ux_device_stack_alternate_setting_set+0x2e4>)
3419a24e:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
3419a252:	f7ff fa2f 	bl	341996b4 <_ux_utility_descriptor_parse>
                        _ux_system_configuration_descriptor_structure,
                        UX_CONFIGURATION_DESCRIPTOR_ENTRIES,
                        (UCHAR *) &configuration_descriptor);

            /* Now we need to check the configuration value.  */
            if (configuration_descriptor.bConfigurationValue == device -> ux_slave_device_configuration_selected)
3419a256:	f897 3049 	ldrb.w	r3, [r7, #73]	@ 0x49
3419a25a:	461a      	mov	r2, r3
3419a25c:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
3419a25e:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
3419a262:	429a      	cmp	r2, r3
3419a264:	f040 8183 	bne.w	3419a56e <_ux_device_stack_alternate_setting_set+0x3da>
            {

                /* Limit the search in current configuration descriptor. */
                device_framework_length = configuration_descriptor.wTotalLength;
3419a268:	f8b7 3046 	ldrh.w	r3, [r7, #70]	@ 0x46
3419a26c:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84

                /* We have found the configuration value that was selected by the host   
                   We need to scan all the interface descriptors following this
                   configuration descriptor and locate the interface for which the alternate
                   setting must be changed. */
                while (device_framework_length != 0)
3419a270:	e177      	b.n	3419a562 <_ux_device_stack_alternate_setting_set+0x3ce>
                {

                    /* Get the length of the current descriptor.  */
                    descriptor_length =  (ULONG) *device_framework;
3419a272:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
3419a276:	781b      	ldrb	r3, [r3, #0]
3419a278:	66bb      	str	r3, [r7, #104]	@ 0x68

                    /* And its type.  */
                    descriptor_type = *(device_framework + 1); 
3419a27a:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
3419a27e:	785b      	ldrb	r3, [r3, #1]
3419a280:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
                
                    /* Check if this is an interface descriptor. */
                    if (descriptor_type == UX_INTERFACE_DESCRIPTOR_ITEM)
3419a284:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
3419a288:	2b04      	cmp	r3, #4
3419a28a:	f040 815e 	bne.w	3419a54a <_ux_device_stack_alternate_setting_set+0x3b6>
                    {

                        /* Parse the descriptor in something more readable. */
                        _ux_utility_descriptor_parse(device_framework,
3419a28e:	f107 0338 	add.w	r3, r7, #56	@ 0x38
3419a292:	2209      	movs	r2, #9
3419a294:	4979      	ldr	r1, [pc, #484]	@ (3419a47c <_ux_device_stack_alternate_setting_set+0x2e8>)
3419a296:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
3419a29a:	f7ff fa0b 	bl	341996b4 <_ux_utility_descriptor_parse>
                                    _ux_system_interface_descriptor_structure,
                                    UX_INTERFACE_DESCRIPTOR_ENTRIES,
                                    (UCHAR *) &interface_descriptor);

                        /* Check if this is the interface we are searching. */
                        if (interface_descriptor.bInterfaceNumber == interface_value &&
3419a29e:	f897 303a 	ldrb.w	r3, [r7, #58]	@ 0x3a
3419a2a2:	461a      	mov	r2, r3
3419a2a4:	687b      	ldr	r3, [r7, #4]
3419a2a6:	4293      	cmp	r3, r2
3419a2a8:	f040 814f 	bne.w	3419a54a <_ux_device_stack_alternate_setting_set+0x3b6>
                            interface_descriptor.bAlternateSetting == alternate_setting_value)
3419a2ac:	f897 303b 	ldrb.w	r3, [r7, #59]	@ 0x3b
3419a2b0:	461a      	mov	r2, r3
                        if (interface_descriptor.bInterfaceNumber == interface_value &&
3419a2b2:	683b      	ldr	r3, [r7, #0]
3419a2b4:	4293      	cmp	r3, r2
3419a2b6:	f040 8148 	bne.w	3419a54a <_ux_device_stack_alternate_setting_set+0x3b6>
                        {

                            /* We have found the right interface and alternate setting. Before
                               we mount all the endpoints for this interface, we need to
                               unmount the endpoints associated with the previous alternate setting.  */
                            endpoint =  interface_ptr -> ux_slave_interface_first_endpoint;
3419a2ba:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
3419a2be:	69db      	ldr	r3, [r3, #28]
3419a2c0:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
                            while (endpoint != UX_NULL)
3419a2c4:	e026      	b.n	3419a314 <_ux_device_stack_alternate_setting_set+0x180>
                            {

                                /* Abort any pending transfer.  */
                                _ux_device_stack_transfer_all_request_abort(endpoint, UX_TRANSFER_BUS_RESET);
3419a2c6:	2126      	movs	r1, #38	@ 0x26
3419a2c8:	f8d7 0080 	ldr.w	r0, [r7, #128]	@ 0x80
3419a2cc:	f001 fc08 	bl	3419bae0 <_ux_device_stack_transfer_all_request_abort>

                                /* The device controller must be called to destroy the endpoint.  */
                                dcd -> ux_slave_dcd_function(dcd, UX_DCD_DESTROY_ENDPOINT, (VOID *) endpoint);
3419a2d0:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3419a2d2:	699b      	ldr	r3, [r3, #24]
3419a2d4:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
3419a2d8:	210f      	movs	r1, #15
3419a2da:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
3419a2dc:	4798      	blx	r3

                                /* Get the next endpoint.  */
                                next_endpoint =  endpoint -> ux_slave_endpoint_next_endpoint;
3419a2de:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3419a2e2:	695b      	ldr	r3, [r3, #20]
3419a2e4:	653b      	str	r3, [r7, #80]	@ 0x50
                
                                /* Free the endpoint.  */
                                endpoint -> ux_slave_endpoint_status =  UX_UNUSED;
3419a2e6:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3419a2ea:	2200      	movs	r2, #0
3419a2ec:	601a      	str	r2, [r3, #0]
                        
                                /* Make sure the endpoint instance is now cleaned up.  */
                                endpoint -> ux_slave_endpoint_state =  0;
3419a2ee:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3419a2f2:	2200      	movs	r2, #0
3419a2f4:	605a      	str	r2, [r3, #4]
                                endpoint -> ux_slave_endpoint_next_endpoint =  UX_NULL;
3419a2f6:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3419a2fa:	2200      	movs	r2, #0
3419a2fc:	615a      	str	r2, [r3, #20]
                                endpoint -> ux_slave_endpoint_interface =  UX_NULL;
3419a2fe:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3419a302:	2200      	movs	r2, #0
3419a304:	619a      	str	r2, [r3, #24]
                                endpoint -> ux_slave_endpoint_device =  UX_NULL;
3419a306:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3419a30a:	2200      	movs	r2, #0
3419a30c:	61da      	str	r2, [r3, #28]
                                                        
                                /* Now we refresh the endpoint pointer.  */
                                endpoint =  next_endpoint;
3419a30e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
3419a310:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
                            while (endpoint != UX_NULL)
3419a314:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3419a318:	2b00      	cmp	r3, #0
3419a31a:	d1d4      	bne.n	3419a2c6 <_ux_device_stack_alternate_setting_set+0x132>
                            }

                            /* Now clear the interface endpoint entry.  */
                            interface_ptr -> ux_slave_interface_first_endpoint = UX_NULL;
3419a31c:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
3419a320:	2200      	movs	r2, #0
3419a322:	61da      	str	r2, [r3, #28]

                            /* Point beyond the interface descriptor.  */
                            device_framework_length -=  (ULONG) *device_framework;
3419a324:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
3419a328:	781b      	ldrb	r3, [r3, #0]
3419a32a:	461a      	mov	r2, r3
3419a32c:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
3419a330:	1a9b      	subs	r3, r3, r2
3419a332:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
                            device_framework +=  (ULONG) *device_framework;
3419a336:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
3419a33a:	781b      	ldrb	r3, [r3, #0]
3419a33c:	461a      	mov	r2, r3
3419a33e:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
3419a342:	4413      	add	r3, r2
3419a344:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
                        
                            /* Parse the device framework and locate endpoint descriptor(s).  */
                            while (device_framework_length != 0)
3419a348:	e0c9      	b.n	3419a4de <_ux_device_stack_alternate_setting_set+0x34a>
                            {
                        
                                /* Get the length of the current descriptor.  */
                                descriptor_length =  (ULONG) *device_framework;
3419a34a:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
3419a34e:	781b      	ldrb	r3, [r3, #0]
3419a350:	66bb      	str	r3, [r7, #104]	@ 0x68
                        
                                /* And its type.  */
                                descriptor_type =  *(device_framework + 1);
3419a352:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
3419a356:	785b      	ldrb	r3, [r3, #1]
3419a358:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
                                        
                                /* Check if this is an endpoint descriptor.  */
                                switch(descriptor_type)
3419a35c:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
3419a360:	2b05      	cmp	r3, #5
3419a362:	d009      	beq.n	3419a378 <_ux_device_stack_alternate_setting_set+0x1e4>
3419a364:	2b05      	cmp	r3, #5
3419a366:	f300 80ad 	bgt.w	3419a4c4 <_ux_device_stack_alternate_setting_set+0x330>
3419a36a:	2b02      	cmp	r3, #2
3419a36c:	f000 80a6 	beq.w	3419a4bc <_ux_device_stack_alternate_setting_set+0x328>
3419a370:	2b04      	cmp	r3, #4
3419a372:	f000 80a3 	beq.w	3419a4bc <_ux_device_stack_alternate_setting_set+0x328>


                                default:
                                
                                    /* We have found another descriptor embedded in the interface. Ignore it.  */
                                    break;
3419a376:	e0a5      	b.n	3419a4c4 <_ux_device_stack_alternate_setting_set+0x330>
                                    endpoint = device -> ux_slave_device_endpoints_pool;
3419a378:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
3419a37a:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
3419a37e:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
                                    endpoints_pool_number = device -> ux_slave_device_endpoints_pool_number;
3419a382:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
3419a384:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3419a388:	67bb      	str	r3, [r7, #120]	@ 0x78
                                    while (endpoints_pool_number != 0)
3419a38a:	e011      	b.n	3419a3b0 <_ux_device_stack_alternate_setting_set+0x21c>
                                        if (endpoint ->    ux_slave_endpoint_status == UX_UNUSED)
3419a38c:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3419a390:	681b      	ldr	r3, [r3, #0]
3419a392:	2b00      	cmp	r3, #0
3419a394:	d104      	bne.n	3419a3a0 <_ux_device_stack_alternate_setting_set+0x20c>
                                            endpoint ->    ux_slave_endpoint_status = UX_USED;
3419a396:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3419a39a:	2201      	movs	r2, #1
3419a39c:	601a      	str	r2, [r3, #0]
                                            break;
3419a39e:	e00a      	b.n	3419a3b6 <_ux_device_stack_alternate_setting_set+0x222>
                                        endpoint++;
3419a3a0:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3419a3a4:	3380      	adds	r3, #128	@ 0x80
3419a3a6:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
                                       endpoints_pool_number--; 
3419a3aa:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
3419a3ac:	3b01      	subs	r3, #1
3419a3ae:	67bb      	str	r3, [r7, #120]	@ 0x78
                                    while (endpoints_pool_number != 0)
3419a3b0:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
3419a3b2:	2b00      	cmp	r3, #0
3419a3b4:	d1ea      	bne.n	3419a38c <_ux_device_stack_alternate_setting_set+0x1f8>
                                    if (endpoints_pool_number == 0)
3419a3b6:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
3419a3b8:	2b00      	cmp	r3, #0
3419a3ba:	d101      	bne.n	3419a3c0 <_ux_device_stack_alternate_setting_set+0x22c>
                                        return(UX_MEMORY_INSUFFICIENT);
3419a3bc:	2312      	movs	r3, #18
3419a3be:	e0e8      	b.n	3419a592 <_ux_device_stack_alternate_setting_set+0x3fe>
                                                    (UCHAR *) &endpoint -> ux_slave_endpoint_descriptor);
3419a3c0:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3419a3c4:	330c      	adds	r3, #12
                                    _ux_utility_descriptor_parse(device_framework,
3419a3c6:	2206      	movs	r2, #6
3419a3c8:	492d      	ldr	r1, [pc, #180]	@ (3419a480 <_ux_device_stack_alternate_setting_set+0x2ec>)
3419a3ca:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
3419a3ce:	f7ff f971 	bl	341996b4 <_ux_utility_descriptor_parse>
                                    transfer_request =  &endpoint -> ux_slave_endpoint_transfer_request;
3419a3d2:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3419a3d6:	3320      	adds	r3, #32
3419a3d8:	65bb      	str	r3, [r7, #88]	@ 0x58
                                            endpoint -> ux_slave_endpoint_descriptor.wMaxPacketSize &
3419a3da:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3419a3de:	8a1b      	ldrh	r3, [r3, #16]
                                    max_transfer_length =
3419a3e0:	f3c3 030a 	ubfx	r3, r3, #0, #11
3419a3e4:	677b      	str	r3, [r7, #116]	@ 0x74
                                    if ((_ux_system_slave -> ux_system_slave_speed == UX_HIGH_SPEED_DEVICE) &&
3419a3e6:	4b23      	ldr	r3, [pc, #140]	@ (3419a474 <_ux_device_stack_alternate_setting_set+0x2e0>)
3419a3e8:	681b      	ldr	r3, [r3, #0]
3419a3ea:	f8d3 3154 	ldr.w	r3, [r3, #340]	@ 0x154
3419a3ee:	2b02      	cmp	r3, #2
3419a3f0:	d11a      	bne.n	3419a428 <_ux_device_stack_alternate_setting_set+0x294>
                                        (endpoint -> ux_slave_endpoint_descriptor.bmAttributes & 0x1u))
3419a3f2:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3419a3f6:	7bdb      	ldrb	r3, [r3, #15]
3419a3f8:	f003 0301 	and.w	r3, r3, #1
                                    if ((_ux_system_slave -> ux_system_slave_speed == UX_HIGH_SPEED_DEVICE) &&
3419a3fc:	2b00      	cmp	r3, #0
3419a3fe:	d013      	beq.n	3419a428 <_ux_device_stack_alternate_setting_set+0x294>
                                        n_trans = endpoint -> ux_slave_endpoint_descriptor.wMaxPacketSize &
3419a400:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3419a404:	8a1b      	ldrh	r3, [r3, #16]
3419a406:	f403 53c0 	and.w	r3, r3, #6144	@ 0x1800
3419a40a:	657b      	str	r3, [r7, #84]	@ 0x54
                                        if (n_trans)
3419a40c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3419a40e:	2b00      	cmp	r3, #0
3419a410:	d00a      	beq.n	3419a428 <_ux_device_stack_alternate_setting_set+0x294>
                                            n_trans >>= UX_MAX_NUMBER_OF_TRANSACTIONS_SHIFT;
3419a412:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3419a414:	0adb      	lsrs	r3, r3, #11
3419a416:	657b      	str	r3, [r7, #84]	@ 0x54
                                            n_trans ++;
3419a418:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3419a41a:	3301      	adds	r3, #1
3419a41c:	657b      	str	r3, [r7, #84]	@ 0x54
                                            max_transfer_length *= n_trans;
3419a41e:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
3419a420:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
3419a422:	fb02 f303 	mul.w	r3, r2, r3
3419a426:	677b      	str	r3, [r7, #116]	@ 0x74
                                    transfer_request -> ux_slave_transfer_request_transfer_length = max_transfer_length;
3419a428:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
3419a42a:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
3419a42c:	621a      	str	r2, [r3, #32]
                                    transfer_request -> ux_slave_transfer_request_endpoint =  endpoint;
3419a42e:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
3419a430:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
3419a434:	609a      	str	r2, [r3, #8]
                                    transfer_request -> ux_slave_transfer_request_timeout = UX_WAIT_FOREVER;
3419a436:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
3419a438:	f04f 32ff 	mov.w	r2, #4294967295
3419a43c:	64da      	str	r2, [r3, #76]	@ 0x4c
                                    endpoint -> ux_slave_endpoint_interface =  interface_ptr;
3419a43e:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3419a442:	f8d7 208c 	ldr.w	r2, [r7, #140]	@ 0x8c
3419a446:	619a      	str	r2, [r3, #24]
                                    endpoint -> ux_slave_endpoint_device =  device;
3419a448:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3419a44c:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
3419a44e:	61da      	str	r2, [r3, #28]
                                    status =  dcd -> ux_slave_dcd_function(dcd, UX_DCD_CREATE_ENDPOINT, (VOID *) endpoint); 
3419a450:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3419a452:	699b      	ldr	r3, [r3, #24]
3419a454:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
3419a458:	210e      	movs	r1, #14
3419a45a:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
3419a45c:	4798      	blx	r3
3419a45e:	65f8      	str	r0, [r7, #92]	@ 0x5c
                                    if (status != UX_SUCCESS)
3419a460:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3419a462:	2b00      	cmp	r3, #0
3419a464:	d00e      	beq.n	3419a484 <_ux_device_stack_alternate_setting_set+0x2f0>
                                        endpoint -> ux_slave_endpoint_status = UX_UNUSED;
3419a466:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3419a46a:	2200      	movs	r2, #0
3419a46c:	601a      	str	r2, [r3, #0]
                                        return(status);
3419a46e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3419a470:	e08f      	b.n	3419a592 <_ux_device_stack_alternate_setting_set+0x3fe>
3419a472:	bf00      	nop
3419a474:	341c33f8 	.word	0x341c33f8
3419a478:	341c00b8 	.word	0x341c00b8
3419a47c:	341c00c0 	.word	0x341c00c0
3419a480:	341c00a0 	.word	0x341c00a0
                                    if (interface_ptr -> ux_slave_interface_first_endpoint == UX_NULL)
3419a484:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
3419a488:	69db      	ldr	r3, [r3, #28]
3419a48a:	2b00      	cmp	r3, #0
3419a48c:	d105      	bne.n	3419a49a <_ux_device_stack_alternate_setting_set+0x306>
                                        interface_ptr -> ux_slave_interface_first_endpoint =  endpoint;
3419a48e:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
3419a492:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
3419a496:	61da      	str	r2, [r3, #28]
                                    break;
3419a498:	e015      	b.n	3419a4c6 <_ux_device_stack_alternate_setting_set+0x332>
                                        endpoint_link =  interface_ptr -> ux_slave_interface_first_endpoint;
3419a49a:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
3419a49e:	69db      	ldr	r3, [r3, #28]
3419a4a0:	67fb      	str	r3, [r7, #124]	@ 0x7c
                                        while (endpoint_link -> ux_slave_endpoint_next_endpoint != UX_NULL)
3419a4a2:	e002      	b.n	3419a4aa <_ux_device_stack_alternate_setting_set+0x316>
                                            endpoint_link =  endpoint_link -> ux_slave_endpoint_next_endpoint;
3419a4a4:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
3419a4a6:	695b      	ldr	r3, [r3, #20]
3419a4a8:	67fb      	str	r3, [r7, #124]	@ 0x7c
                                        while (endpoint_link -> ux_slave_endpoint_next_endpoint != UX_NULL)
3419a4aa:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
3419a4ac:	695b      	ldr	r3, [r3, #20]
3419a4ae:	2b00      	cmp	r3, #0
3419a4b0:	d1f8      	bne.n	3419a4a4 <_ux_device_stack_alternate_setting_set+0x310>
                                        endpoint_link -> ux_slave_endpoint_next_endpoint =  endpoint;
3419a4b2:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
3419a4b4:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
3419a4b8:	615a      	str	r2, [r3, #20]
                                    break;
3419a4ba:	e004      	b.n	3419a4c6 <_ux_device_stack_alternate_setting_set+0x332>
                                    device_framework_length =  descriptor_length;
3419a4bc:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3419a4be:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
                                    break;
3419a4c2:	e000      	b.n	3419a4c6 <_ux_device_stack_alternate_setting_set+0x332>
                                    break;
3419a4c4:	bf00      	nop
                                }
                        
                                /* Adjust what is left of the device framework.  */
                                device_framework_length -=  descriptor_length;
3419a4c6:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
3419a4ca:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3419a4cc:	1ad3      	subs	r3, r2, r3
3419a4ce:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
                        
                                /* Point to the next descriptor.  */
                                device_framework +=  descriptor_length;
3419a4d2:	f8d7 2088 	ldr.w	r2, [r7, #136]	@ 0x88
3419a4d6:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3419a4d8:	4413      	add	r3, r2
3419a4da:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
                            while (device_framework_length != 0)
3419a4de:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
3419a4e2:	2b00      	cmp	r3, #0
3419a4e4:	f47f af31 	bne.w	3419a34a <_ux_device_stack_alternate_setting_set+0x1b6>
                            }

                            /* The interface descriptor in the current class must be changed to the new alternate setting.  */
                            _ux_utility_memory_copy(&interface_ptr -> ux_slave_interface_descriptor, &interface_descriptor, sizeof(UX_INTERFACE_DESCRIPTOR)); /* Use case of memcpy is verified. */
3419a4e8:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
3419a4ec:	330c      	adds	r3, #12
3419a4ee:	f107 0138 	add.w	r1, r7, #56	@ 0x38
3419a4f2:	220c      	movs	r2, #12
3419a4f4:	4618      	mov	r0, r3
3419a4f6:	f7ff fbd5 	bl	34199ca4 <_ux_utility_memory_copy>
                            
                            /* Get the class for the interface.  */
                            class_ptr =  _ux_system_slave -> ux_system_slave_interface_class_array[interface_ptr -> ux_slave_interface_descriptor.bInterfaceNumber];
3419a4fa:	4b28      	ldr	r3, [pc, #160]	@ (3419a59c <_ux_device_stack_alternate_setting_set+0x408>)
3419a4fc:	681a      	ldr	r2, [r3, #0]
3419a4fe:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
3419a502:	7b9b      	ldrb	r3, [r3, #14]
3419a504:	3344      	adds	r3, #68	@ 0x44
3419a506:	009b      	lsls	r3, r3, #2
3419a508:	4413      	add	r3, r2
3419a50a:	685b      	ldr	r3, [r3, #4]
3419a50c:	663b      	str	r3, [r7, #96]	@ 0x60

                            /* Check if class driver is available. */
                            if (class_ptr == UX_NULL || class_ptr -> ux_slave_class_status == UX_UNUSED)
3419a50e:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3419a510:	2b00      	cmp	r3, #0
3419a512:	d003      	beq.n	3419a51c <_ux_device_stack_alternate_setting_set+0x388>
3419a514:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3419a516:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3419a518:	2b00      	cmp	r3, #0
3419a51a:	d101      	bne.n	3419a520 <_ux_device_stack_alternate_setting_set+0x38c>
                            {

                                return (UX_NO_CLASS_MATCH);
3419a51c:	2357      	movs	r3, #87	@ 0x57
3419a51e:	e038      	b.n	3419a592 <_ux_device_stack_alternate_setting_set+0x3fe>
                            }
                        
                            /* The interface attached to this configuration must be changed at the class
                               level.  */
                            class_command.ux_slave_class_command_request   =    UX_SLAVE_CLASS_COMMAND_CHANGE;
3419a520:	2306      	movs	r3, #6
3419a522:	60fb      	str	r3, [r7, #12]
                            class_command.ux_slave_class_command_interface =   (VOID *) interface_ptr;
3419a524:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
3419a528:	617b      	str	r3, [r7, #20]

                            /* And store it.  */
                            class_command.ux_slave_class_command_class_ptr =  class_ptr;
3419a52a:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3419a52c:	62fb      	str	r3, [r7, #44]	@ 0x2c
                            
                            /* We can now memorize the interface pointer associated with this class.  */
                            class_ptr -> ux_slave_class_interface = interface_ptr;
3419a52e:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3419a530:	f8d7 208c 	ldr.w	r2, [r7, #140]	@ 0x8c
3419a534:	f8c3 2110 	str.w	r2, [r3, #272]	@ 0x110
                            
                            /* We have found a potential candidate. Call this registered class entry function to change the alternate setting.  */
                            status = class_ptr -> ux_slave_class_entry_function(&class_command);
3419a538:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3419a53a:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3419a53c:	f107 020c 	add.w	r2, r7, #12
3419a540:	4610      	mov	r0, r2
3419a542:	4798      	blx	r3
3419a544:	65f8      	str	r0, [r7, #92]	@ 0x5c

                            /* We are done here.  */
                            return(status); 
3419a546:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3419a548:	e023      	b.n	3419a592 <_ux_device_stack_alternate_setting_set+0x3fe>
                        }
                    }               

                    /* Adjust what is left of the device framework.  */
                    device_framework_length -=  descriptor_length;
3419a54a:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
3419a54e:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3419a550:	1ad3      	subs	r3, r2, r3
3419a552:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84

                    /* Point to the next descriptor.  */
                    device_framework +=  descriptor_length;
3419a556:	f8d7 2088 	ldr.w	r2, [r7, #136]	@ 0x88
3419a55a:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3419a55c:	4413      	add	r3, r2
3419a55e:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
                while (device_framework_length != 0)
3419a562:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
3419a566:	2b00      	cmp	r3, #0
3419a568:	f47f ae83 	bne.w	3419a272 <_ux_device_stack_alternate_setting_set+0xde>
                }

                /* In case alter setting not found, report protocol error. */
                break;
3419a56c:	e010      	b.n	3419a590 <_ux_device_stack_alternate_setting_set+0x3fc>
            }
        }

        /* Adjust what is left of the device framework.  */
        device_framework_length -=  descriptor_length;
3419a56e:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
3419a572:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3419a574:	1ad3      	subs	r3, r2, r3
3419a576:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84

        /* Point to the next descriptor.  */
        device_framework +=  descriptor_length;
3419a57a:	f8d7 2088 	ldr.w	r2, [r7, #136]	@ 0x88
3419a57e:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3419a580:	4413      	add	r3, r2
3419a582:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
    while (device_framework_length != 0)
3419a586:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
3419a58a:	2b00      	cmp	r3, #0
3419a58c:	f47f ae4d 	bne.w	3419a22a <_ux_device_stack_alternate_setting_set+0x96>
    }

    /* Return error completion.  */
    return(UX_ERROR);
3419a590:	23ff      	movs	r3, #255	@ 0xff
#endif
}
3419a592:	4618      	mov	r0, r3
3419a594:	3790      	adds	r7, #144	@ 0x90
3419a596:	46bd      	mov	sp, r7
3419a598:	bd80      	pop	{r7, pc}
3419a59a:	bf00      	nop
3419a59c:	341c33f8 	.word	0x341c33f8

3419a5a0 <_ux_device_stack_class_register>:
UINT  _ux_device_stack_class_register(UCHAR *class_name,
                        UINT (*class_entry_function)(struct UX_SLAVE_CLASS_COMMAND_STRUCT *),
                        ULONG configuration_number,
                        ULONG interface_number,
                        VOID *parameter)
{
3419a5a0:	b580      	push	{r7, lr}
3419a5a2:	b092      	sub	sp, #72	@ 0x48
3419a5a4:	af00      	add	r7, sp, #0
3419a5a6:	60f8      	str	r0, [r7, #12]
3419a5a8:	60b9      	str	r1, [r7, #8]
3419a5aa:	607a      	str	r2, [r7, #4]
3419a5ac:	603b      	str	r3, [r7, #0]

UX_SLAVE_CLASS              *class_inst;
UINT                        status;
UX_SLAVE_CLASS_COMMAND      command;
UINT                        class_name_length =  0;
3419a5ae:	2300      	movs	r3, #0
3419a5b0:	613b      	str	r3, [r7, #16]
ULONG                       class_index;
#endif


    /* Get the length of the class name (exclude null-terminator).  */
    status =  _ux_utility_string_length_check(class_name, &class_name_length, UX_MAX_CLASS_NAME_LENGTH);
3419a5b2:	f107 0310 	add.w	r3, r7, #16
3419a5b6:	223f      	movs	r2, #63	@ 0x3f
3419a5b8:	4619      	mov	r1, r3
3419a5ba:	68f8      	ldr	r0, [r7, #12]
3419a5bc:	f7ff fd25 	bl	3419a00a <_ux_utility_string_length_check>
3419a5c0:	6478      	str	r0, [r7, #68]	@ 0x44
    if (status)
3419a5c2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3419a5c4:	2b00      	cmp	r3, #0
3419a5c6:	d001      	beq.n	3419a5cc <_ux_device_stack_class_register+0x2c>
        return(status);
3419a5c8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3419a5ca:	e035      	b.n	3419a638 <_ux_device_stack_class_register+0x98>

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_STACK_CLASS_REGISTER, class_name, interface_number, parameter, 0, UX_TRACE_DEVICE_STACK_EVENTS, 0, 0)

    /* Get first class.  */
    class_inst =  _ux_system_slave -> ux_system_slave_class_array;
3419a5cc:	4b1c      	ldr	r3, [pc, #112]	@ (3419a640 <_ux_device_stack_class_register+0xa0>)
3419a5ce:	681b      	ldr	r3, [r3, #0]
3419a5d0:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
3419a5d4:	643b      	str	r3, [r7, #64]	@ 0x40
    for (class_index = 0; class_index < _ux_system_slave -> ux_system_slave_max_class; class_index++)
    {
#endif

        /* Check if this class is already used.  */
        if (class_inst -> ux_slave_class_status == UX_UNUSED)
3419a5d6:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419a5d8:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3419a5da:	2b00      	cmp	r3, #0
3419a5dc:	d12b      	bne.n	3419a636 <_ux_device_stack_class_register+0x96>

#if defined(UX_NAME_REFERENCED_BY_POINTER)
            class_inst -> ux_slave_class_name = (const UCHAR *)class_name;
#else
            /* We have found a free container for the class. Copy the name (with null-terminator).  */
            _ux_utility_memory_copy(class_inst -> ux_slave_class_name, class_name, class_name_length + 1); /* Use case of memcpy is verified. */
3419a5de:	6c38      	ldr	r0, [r7, #64]	@ 0x40
3419a5e0:	693b      	ldr	r3, [r7, #16]
3419a5e2:	3301      	adds	r3, #1
3419a5e4:	461a      	mov	r2, r3
3419a5e6:	68f9      	ldr	r1, [r7, #12]
3419a5e8:	f7ff fb5c 	bl	34199ca4 <_ux_utility_memory_copy>
#endif
            
            /* Memorize the entry function of this class.  */
            class_inst -> ux_slave_class_entry_function =  class_entry_function;
3419a5ec:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419a5ee:	68ba      	ldr	r2, [r7, #8]
3419a5f0:	645a      	str	r2, [r3, #68]	@ 0x44

            /* Memorize the pointer to the application parameter.  */
            class_inst -> ux_slave_class_interface_parameter =  parameter;
3419a5f2:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419a5f4:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
3419a5f6:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
            
            /* Memorize the configuration number on which this instance will be called.  */
            class_inst -> ux_slave_class_configuration_number =  configuration_number;
3419a5fa:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419a5fc:	687a      	ldr	r2, [r7, #4]
3419a5fe:	f8c3 210c 	str.w	r2, [r3, #268]	@ 0x10c
            
            /* Memorize the interface number on which this instance will be called.  */
            class_inst -> ux_slave_class_interface_number =  interface_number;
3419a602:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419a604:	683a      	ldr	r2, [r7, #0]
3419a606:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108
            
            /* Build all the fields of the Class Command to initialize the class.  */
            command.ux_slave_class_command_request    =  UX_SLAVE_CLASS_COMMAND_INITIALIZE;
3419a60a:	2305      	movs	r3, #5
3419a60c:	617b      	str	r3, [r7, #20]
            command.ux_slave_class_command_parameter  =  parameter;
3419a60e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
3419a610:	63bb      	str	r3, [r7, #56]	@ 0x38
            command.ux_slave_class_command_class_ptr  =  class_inst;
3419a612:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419a614:	637b      	str	r3, [r7, #52]	@ 0x34

            /* Call the class initialization routine.  */
            status = class_entry_function(&command);
3419a616:	f107 0214 	add.w	r2, r7, #20
3419a61a:	68bb      	ldr	r3, [r7, #8]
3419a61c:	4610      	mov	r0, r2
3419a61e:	4798      	blx	r3
3419a620:	6478      	str	r0, [r7, #68]	@ 0x44
            
            /* Check the status.  */
            if (status != UX_SUCCESS)
3419a622:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3419a624:	2b00      	cmp	r3, #0
3419a626:	d001      	beq.n	3419a62c <_ux_device_stack_class_register+0x8c>
                return(status);
3419a628:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3419a62a:	e005      	b.n	3419a638 <_ux_device_stack_class_register+0x98>
            
            /* Make this class used now.  */
            class_inst -> ux_slave_class_status = UX_USED;
3419a62c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419a62e:	2201      	movs	r2, #1
3419a630:	641a      	str	r2, [r3, #64]	@ 0x40

            /* Return successful completion.  */
            return(UX_SUCCESS);
3419a632:	2300      	movs	r3, #0
3419a634:	e000      	b.n	3419a638 <_ux_device_stack_class_register+0x98>
        class_inst ++;
    }    
#endif

    /* No more entries in the class table.  */
    return(UX_MEMORY_INSUFFICIENT);
3419a636:	2312      	movs	r3, #18
}
3419a638:	4618      	mov	r0, r3
3419a63a:	3748      	adds	r7, #72	@ 0x48
3419a63c:	46bd      	mov	sp, r7
3419a63e:	bd80      	pop	{r7, pc}
3419a640:	341c33f8 	.word	0x341c33f8

3419a644 <_ux_device_stack_clear_feature>:
/*                                            names conflict C++ keyword, */
/*                                            resulting in version 6.1.12 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_stack_clear_feature(ULONG request_type, ULONG request_value, ULONG request_index)
{
3419a644:	b580      	push	{r7, lr}
3419a646:	b08a      	sub	sp, #40	@ 0x28
3419a648:	af00      	add	r7, sp, #0
3419a64a:	60f8      	str	r0, [r7, #12]
3419a64c:	60b9      	str	r1, [r7, #8]
3419a64e:	607a      	str	r2, [r7, #4]

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_STACK_CLEAR_FEATURE, request_type, request_value, request_index, 0, UX_TRACE_DEVICE_STACK_EVENTS, 0, 0)

    /* Get the pointer to the DCD.  */
    dcd =  &_ux_system_slave -> ux_system_slave_dcd;
3419a650:	4b2b      	ldr	r3, [pc, #172]	@ (3419a700 <_ux_device_stack_clear_feature+0xbc>)
3419a652:	681b      	ldr	r3, [r3, #0]
3419a654:	61fb      	str	r3, [r7, #28]

    /* Get the pointer to the device.  */
    device =  &_ux_system_slave -> ux_system_slave_device;
3419a656:	4b2a      	ldr	r3, [pc, #168]	@ (3419a700 <_ux_device_stack_clear_feature+0xbc>)
3419a658:	681b      	ldr	r3, [r3, #0]
3419a65a:	3320      	adds	r3, #32
3419a65c:	61bb      	str	r3, [r7, #24]

    /* Get the control endpoint for the device.  */
    endpoint =  &device -> ux_slave_device_control_endpoint;
3419a65e:	69bb      	ldr	r3, [r7, #24]
3419a660:	3318      	adds	r3, #24
3419a662:	617b      	str	r3, [r7, #20]

    /* The request can be for either the device or the endpoint.  */
    switch (request_type & UX_REQUEST_TARGET)
3419a664:	68fb      	ldr	r3, [r7, #12]
3419a666:	f003 0303 	and.w	r3, r3, #3
3419a66a:	2b00      	cmp	r3, #0
3419a66c:	d002      	beq.n	3419a674 <_ux_device_stack_clear_feature+0x30>
3419a66e:	2b02      	cmp	r3, #2
3419a670:	d011      	beq.n	3419a696 <_ux_device_stack_clear_feature+0x52>
3419a672:	e036      	b.n	3419a6e2 <_ux_device_stack_clear_feature+0x9e>
    {
    
    case UX_REQUEST_TARGET_DEVICE:

        /* Check if we have a DEVICE_REMOTE_WAKEUP Feature.  */
        if (request_value == UX_REQUEST_FEATURE_DEVICE_REMOTE_WAKEUP)
3419a674:	68bb      	ldr	r3, [r7, #8]
3419a676:	2b01      	cmp	r3, #1
3419a678:	d13b      	bne.n	3419a6f2 <_ux_device_stack_clear_feature+0xae>
        {

            /* Check if we have the capability. */
            if (_ux_system_slave -> ux_system_slave_remote_wakeup_capability)
3419a67a:	4b21      	ldr	r3, [pc, #132]	@ (3419a700 <_ux_device_stack_clear_feature+0xbc>)
3419a67c:	681b      	ldr	r3, [r3, #0]
3419a67e:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
3419a682:	2b00      	cmp	r3, #0
3419a684:	d005      	beq.n	3419a692 <_ux_device_stack_clear_feature+0x4e>
            {

                /* Disable the feature. */
                _ux_system_slave -> ux_system_slave_remote_wakeup_enabled = UX_FALSE;
3419a686:	4b1e      	ldr	r3, [pc, #120]	@ (3419a700 <_ux_device_stack_clear_feature+0xbc>)
3419a688:	681b      	ldr	r3, [r3, #0]
3419a68a:	2200      	movs	r2, #0
3419a68c:	f8c3 2160 	str.w	r2, [r3, #352]	@ 0x160

                /* Protocol error. */
                return (UX_FUNCTION_NOT_SUPPORTED);
        }

        break;
3419a690:	e02f      	b.n	3419a6f2 <_ux_device_stack_clear_feature+0xae>
                return (UX_FUNCTION_NOT_SUPPORTED);
3419a692:	2354      	movs	r3, #84	@ 0x54
3419a694:	e02f      	b.n	3419a6f6 <_ux_device_stack_clear_feature+0xb2>
    case UX_REQUEST_TARGET_ENDPOINT:

        /* The only clear feature for endpoint is ENDPOINT_STALL. This clears
           the endpoint of the stall situation and resets its data toggle. 
           We need to find the endpoint through the interface(s). */
        interface_ptr =  device -> ux_slave_device_first_interface;
3419a696:	69bb      	ldr	r3, [r7, #24]
3419a698:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
3419a69c:	627b      	str	r3, [r7, #36]	@ 0x24

#if !defined(UX_DEVICE_INITIALIZE_FRAMEWORK_SCAN_DISABLE) || UX_MAX_DEVICE_INTERFACES > 1
        while (interface_ptr != UX_NULL)
3419a69e:	e01d      	b.n	3419a6dc <_ux_device_stack_clear_feature+0x98>
        {
#endif

            /* Get the first endpoint for this interface.  */
            endpoint_target =  interface_ptr -> ux_slave_interface_first_endpoint;
3419a6a0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419a6a2:	69db      	ldr	r3, [r3, #28]
3419a6a4:	623b      	str	r3, [r7, #32]
                
            /* Parse all the endpoints.  */
            while (endpoint_target != UX_NULL)
3419a6a6:	e013      	b.n	3419a6d0 <_ux_device_stack_clear_feature+0x8c>
            {

                /* Check the endpoint index.  */
                if (endpoint_target -> ux_slave_endpoint_descriptor.bEndpointAddress == request_index)
3419a6a8:	6a3b      	ldr	r3, [r7, #32]
3419a6aa:	7b9b      	ldrb	r3, [r3, #14]
3419a6ac:	461a      	mov	r2, r3
3419a6ae:	687b      	ldr	r3, [r7, #4]
3419a6b0:	4293      	cmp	r3, r2
3419a6b2:	d10a      	bne.n	3419a6ca <_ux_device_stack_clear_feature+0x86>
                {

                    /* Reset the endpoint.  */
                    dcd -> ux_slave_dcd_function(dcd, UX_DCD_RESET_ENDPOINT, endpoint_target);
3419a6b4:	69fb      	ldr	r3, [r7, #28]
3419a6b6:	699b      	ldr	r3, [r3, #24]
3419a6b8:	6a3a      	ldr	r2, [r7, #32]
3419a6ba:	2110      	movs	r1, #16
3419a6bc:	69f8      	ldr	r0, [r7, #28]
3419a6be:	4798      	blx	r3
                    
                    /* Mark its state now.  */
                    endpoint_target -> ux_slave_endpoint_state = UX_ENDPOINT_RESET;
3419a6c0:	6a3b      	ldr	r3, [r7, #32]
3419a6c2:	2200      	movs	r2, #0
3419a6c4:	605a      	str	r2, [r3, #4]

                    /* Return the function status.  */
                    return(UX_SUCCESS);
3419a6c6:	2300      	movs	r3, #0
3419a6c8:	e015      	b.n	3419a6f6 <_ux_device_stack_clear_feature+0xb2>
                }

                /* Next endpoint.  */
                endpoint_target =  endpoint_target -> ux_slave_endpoint_next_endpoint;
3419a6ca:	6a3b      	ldr	r3, [r7, #32]
3419a6cc:	695b      	ldr	r3, [r3, #20]
3419a6ce:	623b      	str	r3, [r7, #32]
            while (endpoint_target != UX_NULL)
3419a6d0:	6a3b      	ldr	r3, [r7, #32]
3419a6d2:	2b00      	cmp	r3, #0
3419a6d4:	d1e8      	bne.n	3419a6a8 <_ux_device_stack_clear_feature+0x64>
            }

#if !defined(UX_DEVICE_INITIALIZE_FRAMEWORK_SCAN_DISABLE) || UX_MAX_DEVICE_INTERFACES > 1
            /* Next interface.  */
            interface_ptr =  interface_ptr -> ux_slave_interface_next_interface;
3419a6d6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419a6d8:	699b      	ldr	r3, [r3, #24]
3419a6da:	627b      	str	r3, [r7, #36]	@ 0x24
        while (interface_ptr != UX_NULL)
3419a6dc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419a6de:	2b00      	cmp	r3, #0
3419a6e0:	d1de      	bne.n	3419a6a0 <_ux_device_stack_clear_feature+0x5c>

    /* We get here when the endpoint is wrong. Should not happen though.  */
    default:
        
        /* We stall the command.  */
        dcd -> ux_slave_dcd_function(dcd, UX_DCD_STALL_ENDPOINT, endpoint);
3419a6e2:	69fb      	ldr	r3, [r7, #28]
3419a6e4:	699b      	ldr	r3, [r3, #24]
3419a6e6:	697a      	ldr	r2, [r7, #20]
3419a6e8:	2114      	movs	r1, #20
3419a6ea:	69f8      	ldr	r0, [r7, #28]
3419a6ec:	4798      	blx	r3
    
        /* No more work to do here.  The command failed but the upper layer does not depend on it.  */
        return(UX_SUCCESS);            
3419a6ee:	2300      	movs	r3, #0
3419a6f0:	e001      	b.n	3419a6f6 <_ux_device_stack_clear_feature+0xb2>
        break;
3419a6f2:	bf00      	nop
    }

    /* Return the function status.  */
    return(UX_SUCCESS);
3419a6f4:	2300      	movs	r3, #0
}
3419a6f6:	4618      	mov	r0, r3
3419a6f8:	3728      	adds	r7, #40	@ 0x28
3419a6fa:	46bd      	mov	sp, r7
3419a6fc:	bd80      	pop	{r7, pc}
3419a6fe:	bf00      	nop
3419a700:	341c33f8 	.word	0x341c33f8

3419a704 <_ux_device_stack_configuration_get>:
/*  09-30-2020     Chaoqiong Xiao           Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_stack_configuration_get(VOID)
{
3419a704:	b580      	push	{r7, lr}
3419a706:	b084      	sub	sp, #16
3419a708:	af00      	add	r7, sp, #0
UX_SLAVE_DEVICE         *device;
UX_SLAVE_ENDPOINT       *endpoint;
UINT                    status;

    /* Get the pointer to the device.  */
    device =  &_ux_system_slave -> ux_system_slave_device;
3419a70a:	4b0f      	ldr	r3, [pc, #60]	@ (3419a748 <_ux_device_stack_configuration_get+0x44>)
3419a70c:	681b      	ldr	r3, [r3, #0]
3419a70e:	3320      	adds	r3, #32
3419a710:	60fb      	str	r3, [r7, #12]

    /* Get the control endpoint for the device.  */
    endpoint =  &device -> ux_slave_device_control_endpoint;
3419a712:	68fb      	ldr	r3, [r7, #12]
3419a714:	3318      	adds	r3, #24
3419a716:	60bb      	str	r3, [r7, #8]

    /* Get the pointer to the transfer request associated with the endpoint.  */
    transfer_request =  &endpoint -> ux_slave_endpoint_transfer_request;
3419a718:	68bb      	ldr	r3, [r7, #8]
3419a71a:	3320      	adds	r3, #32
3419a71c:	607b      	str	r3, [r7, #4]

    /* Set the value of the configuration in the buffer.  */
    *transfer_request -> ux_slave_transfer_request_data_pointer =
                (UCHAR) device -> ux_slave_device_configuration_selected;
3419a71e:	68fb      	ldr	r3, [r7, #12]
3419a720:	f8d3 2098 	ldr.w	r2, [r3, #152]	@ 0x98
    *transfer_request -> ux_slave_transfer_request_data_pointer =
3419a724:	687b      	ldr	r3, [r7, #4]
3419a726:	68db      	ldr	r3, [r3, #12]
                (UCHAR) device -> ux_slave_device_configuration_selected;
3419a728:	b2d2      	uxtb	r2, r2
    *transfer_request -> ux_slave_transfer_request_data_pointer =
3419a72a:	701a      	strb	r2, [r3, #0]

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_STACK_CONFIGURATION_GET, device -> ux_slave_device_configuration_selected, 0, 0, 0, UX_TRACE_DEVICE_STACK_EVENTS, 0, 0)

    /* Set the phase of the transfer to data out.  */
    transfer_request -> ux_slave_transfer_request_phase =  UX_TRANSFER_PHASE_DATA_OUT;
3419a72c:	687b      	ldr	r3, [r7, #4]
3419a72e:	2203      	movs	r2, #3
3419a730:	629a      	str	r2, [r3, #40]	@ 0x28

    /* Send the descriptor with the appropriate length to the host.  */
    status =  _ux_device_stack_transfer_request(transfer_request, 1, 1);
3419a732:	2201      	movs	r2, #1
3419a734:	2101      	movs	r1, #1
3419a736:	6878      	ldr	r0, [r7, #4]
3419a738:	f001 f9e4 	bl	3419bb04 <_ux_device_stack_transfer_request>
3419a73c:	6038      	str	r0, [r7, #0]

    /* Return the function status.  */
    return(status);
3419a73e:	683b      	ldr	r3, [r7, #0]
}
3419a740:	4618      	mov	r0, r3
3419a742:	3710      	adds	r7, #16
3419a744:	46bd      	mov	sp, r7
3419a746:	bd80      	pop	{r7, pc}
3419a748:	341c33f8 	.word	0x341c33f8

3419a74c <_ux_device_stack_configuration_set>:
/*                                            names conflict C++ keyword, */
/*                                            resulting in version 6.1.12 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_stack_configuration_set(ULONG configuration_value)
{
3419a74c:	b580      	push	{r7, lr}
3419a74e:	b0a0      	sub	sp, #128	@ 0x80
3419a750:	af00      	add	r7, sp, #0
3419a752:	6078      	str	r0, [r7, #4]
UX_SLAVE_DCD                    *dcd;
UCHAR *                         device_framework;
ULONG                           device_framework_length;
ULONG                           descriptor_length;
UCHAR                           descriptor_type;
UX_CONFIGURATION_DESCRIPTOR     configuration_descriptor = { 0 };
3419a754:	f107 0340 	add.w	r3, r7, #64	@ 0x40
3419a758:	2200      	movs	r2, #0
3419a75a:	601a      	str	r2, [r3, #0]
3419a75c:	605a      	str	r2, [r3, #4]
3419a75e:	609a      	str	r2, [r3, #8]
UX_SLAVE_INTERFACE              *interface_ptr; 
#if !defined(UX_DEVICE_INITIALIZE_FRAMEWORK_SCAN_DISABLE) || UX_MAX_DEVICE_INTERFACES > 1
UX_SLAVE_INTERFACE              *next_interface; 
#endif
UX_SLAVE_CLASS                  *class_inst;
UX_SLAVE_CLASS                  *current_class =  UX_NULL;
3419a760:	2300      	movs	r3, #0
3419a762:	673b      	str	r3, [r7, #112]	@ 0x70
UX_SLAVE_CLASS_COMMAND          class_command;
UX_SLAVE_DEVICE                 *device;
ULONG                           iad_flag;
ULONG                           iad_first_interface =  0;
3419a764:	2300      	movs	r3, #0
3419a766:	66bb      	str	r3, [r7, #104]	@ 0x68
ULONG                           iad_number_interfaces =  0;
3419a768:	2300      	movs	r3, #0
3419a76a:	667b      	str	r3, [r7, #100]	@ 0x64

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_STACK_CONFIGURATION_SET, configuration_value, 0, 0, 0, UX_TRACE_DEVICE_STACK_EVENTS, 0, 0)

    /* Get the pointer to the DCD.  */
    dcd =  &_ux_system_slave -> ux_system_slave_dcd;
3419a76c:	4b84      	ldr	r3, [pc, #528]	@ (3419a980 <_ux_device_stack_configuration_set+0x234>)
3419a76e:	681b      	ldr	r3, [r3, #0]
3419a770:	663b      	str	r3, [r7, #96]	@ 0x60

    /* Get the pointer to the device.  */
    device =  &_ux_system_slave -> ux_system_slave_device;
3419a772:	4b83      	ldr	r3, [pc, #524]	@ (3419a980 <_ux_device_stack_configuration_set+0x234>)
3419a774:	681b      	ldr	r3, [r3, #0]
3419a776:	3320      	adds	r3, #32
3419a778:	65fb      	str	r3, [r7, #92]	@ 0x5c
    
    /* Reset the IAD flag.  */
    iad_flag =  UX_FALSE;
3419a77a:	2300      	movs	r3, #0
3419a77c:	66fb      	str	r3, [r7, #108]	@ 0x6c

    /* If the configuration value is already selected, keep it.  */
    if (device -> ux_slave_device_configuration_selected == configuration_value)
3419a77e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3419a780:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
3419a784:	687a      	ldr	r2, [r7, #4]
3419a786:	429a      	cmp	r2, r3
3419a788:	d101      	bne.n	3419a78e <_ux_device_stack_configuration_set+0x42>
        return(UX_SUCCESS);
3419a78a:	2300      	movs	r3, #0
3419a78c:	e139      	b.n	3419aa02 <_ux_device_stack_configuration_set+0x2b6>

    /* We may have multiple configurations !, the index will tell us what
       configuration descriptor we need to return.  */
    device_framework = _ux_system_slave -> ux_system_slave_device_framework;
3419a78e:	4b7c      	ldr	r3, [pc, #496]	@ (3419a980 <_ux_device_stack_configuration_set+0x234>)
3419a790:	681b      	ldr	r3, [r3, #0]
3419a792:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3419a796:	67fb      	str	r3, [r7, #124]	@ 0x7c
    device_framework_length =  _ux_system_slave -> ux_system_slave_device_framework_length;
3419a798:	4b79      	ldr	r3, [pc, #484]	@ (3419a980 <_ux_device_stack_configuration_set+0x234>)
3419a79a:	681b      	ldr	r3, [r3, #0]
3419a79c:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3419a7a0:	67bb      	str	r3, [r7, #120]	@ 0x78

    /* Parse the device framework and locate a configuration descriptor.  */
    while (device_framework_length != 0)
3419a7a2:	e01f      	b.n	3419a7e4 <_ux_device_stack_configuration_set+0x98>
    {
        /* Get the length of the current descriptor.  */
        descriptor_length =  (ULONG) *device_framework;
3419a7a4:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
3419a7a6:	781b      	ldrb	r3, [r3, #0]
3419a7a8:	65bb      	str	r3, [r7, #88]	@ 0x58

        /* And its type.  */
        descriptor_type =  *(device_framework + 1);
3419a7aa:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
3419a7ac:	785b      	ldrb	r3, [r3, #1]
3419a7ae:	f887 3057 	strb.w	r3, [r7, #87]	@ 0x57

        /* Check if this is a configuration descriptor.  */
        if (descriptor_type == UX_CONFIGURATION_DESCRIPTOR_ITEM)
3419a7b2:	f897 3057 	ldrb.w	r3, [r7, #87]	@ 0x57
3419a7b6:	2b02      	cmp	r3, #2
3419a7b8:	d10c      	bne.n	3419a7d4 <_ux_device_stack_configuration_set+0x88>
        {
            /* Parse the descriptor in something more readable.  */
            _ux_utility_descriptor_parse(device_framework,
3419a7ba:	f107 0340 	add.w	r3, r7, #64	@ 0x40
3419a7be:	2208      	movs	r2, #8
3419a7c0:	4970      	ldr	r1, [pc, #448]	@ (3419a984 <_ux_device_stack_configuration_set+0x238>)
3419a7c2:	6ff8      	ldr	r0, [r7, #124]	@ 0x7c
3419a7c4:	f7fe ff76 	bl	341996b4 <_ux_utility_descriptor_parse>
                        UX_CONFIGURATION_DESCRIPTOR_ENTRIES,
                        (UCHAR *) &configuration_descriptor);

            /* Now we need to check the configuration value. It has
               to be the same as the one specified in the setup function.  */
            if (configuration_descriptor.bConfigurationValue == configuration_value)
3419a7c8:	f897 3045 	ldrb.w	r3, [r7, #69]	@ 0x45
3419a7cc:	461a      	mov	r2, r3
3419a7ce:	687b      	ldr	r3, [r7, #4]
3419a7d0:	4293      	cmp	r3, r2
3419a7d2:	d00b      	beq.n	3419a7ec <_ux_device_stack_configuration_set+0xa0>
                /* The configuration is found. */
                break;
        }

        /* Adjust what is left of the device framework.  */
        device_framework_length -= descriptor_length;
3419a7d4:	6fba      	ldr	r2, [r7, #120]	@ 0x78
3419a7d6:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
3419a7d8:	1ad3      	subs	r3, r2, r3
3419a7da:	67bb      	str	r3, [r7, #120]	@ 0x78
        /* Point to the next descriptor.  */
        device_framework += descriptor_length;
3419a7dc:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
3419a7de:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
3419a7e0:	4413      	add	r3, r2
3419a7e2:	67fb      	str	r3, [r7, #124]	@ 0x7c
    while (device_framework_length != 0)
3419a7e4:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
3419a7e6:	2b00      	cmp	r3, #0
3419a7e8:	d1dc      	bne.n	3419a7a4 <_ux_device_stack_configuration_set+0x58>
3419a7ea:	e000      	b.n	3419a7ee <_ux_device_stack_configuration_set+0xa2>
                break;
3419a7ec:	bf00      	nop
    }

    /* Configuration not found. */
    if (device_framework_length == 0 && configuration_value != 0)
3419a7ee:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
3419a7f0:	2b00      	cmp	r3, #0
3419a7f2:	d104      	bne.n	3419a7fe <_ux_device_stack_configuration_set+0xb2>
3419a7f4:	687b      	ldr	r3, [r7, #4]
3419a7f6:	2b00      	cmp	r3, #0
3419a7f8:	d001      	beq.n	3419a7fe <_ux_device_stack_configuration_set+0xb2>
        return(UX_ERROR);
3419a7fa:	23ff      	movs	r3, #255	@ 0xff
3419a7fc:	e101      	b.n	3419aa02 <_ux_device_stack_configuration_set+0x2b6>

    /* We unmount the configuration if there is previous configuration selected. */
    if (device -> ux_slave_device_configuration_selected)
3419a7fe:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3419a800:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
3419a804:	2b00      	cmp	r3, #0
3419a806:	d021      	beq.n	3419a84c <_ux_device_stack_configuration_set+0x100>
    {

        /* Get the pointer to the first interface.  */
        interface_ptr =  device -> ux_slave_device_first_interface;
3419a808:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3419a80a:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
3419a80e:	677b      	str	r3, [r7, #116]	@ 0x74

#if !defined(UX_DEVICE_INITIALIZE_FRAMEWORK_SCAN_DISABLE) || UX_MAX_DEVICE_INTERFACES > 1
        /* Deactivate all the interfaces if any.  */
        while (interface_ptr != UX_NULL)
3419a810:	e019      	b.n	3419a846 <_ux_device_stack_configuration_set+0xfa>
        {
#endif
            /* Build all the fields of the Class Command.  */
            class_command.ux_slave_class_command_request =   UX_SLAVE_CLASS_COMMAND_DEACTIVATE;
3419a812:	2303      	movs	r3, #3
3419a814:	60bb      	str	r3, [r7, #8]
            class_command.ux_slave_class_command_interface =  (VOID *) interface_ptr;
3419a816:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
3419a818:	613b      	str	r3, [r7, #16]

            /* Get the pointer to the class container of this interface.  */
            class_inst =  interface_ptr -> ux_slave_interface_class;
3419a81a:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
3419a81c:	685b      	ldr	r3, [r3, #4]
3419a81e:	653b      	str	r3, [r7, #80]	@ 0x50

            /* Store the class container. */
            class_command.ux_slave_class_command_class_ptr =  class_inst;
3419a820:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
3419a822:	62bb      	str	r3, [r7, #40]	@ 0x28

            /* If there is a class container for this instance, deactivate it.  */
            if (class_inst != UX_NULL)
3419a824:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
3419a826:	2b00      	cmp	r3, #0
3419a828:	d005      	beq.n	3419a836 <_ux_device_stack_configuration_set+0xea>

                /* Call the class with the DEACTIVATE signal.  */
                class_inst -> ux_slave_class_entry_function(&class_command);
3419a82a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
3419a82c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3419a82e:	f107 0208 	add.w	r2, r7, #8
3419a832:	4610      	mov	r0, r2
3419a834:	4798      	blx	r3

#if !defined(UX_DEVICE_INITIALIZE_FRAMEWORK_SCAN_DISABLE) || UX_MAX_DEVICE_INTERFACES > 1
            /* Get the next interface.  */
            next_interface =  interface_ptr -> ux_slave_interface_next_interface;
3419a836:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
3419a838:	699b      	ldr	r3, [r3, #24]
3419a83a:	64fb      	str	r3, [r7, #76]	@ 0x4c
#endif

            /* Remove the interface and all endpoints associated with it.  */
            _ux_device_stack_interface_delete(interface_ptr);
3419a83c:	6f78      	ldr	r0, [r7, #116]	@ 0x74
3419a83e:	f000 ff0d 	bl	3419b65c <_ux_device_stack_interface_delete>

#if !defined(UX_DEVICE_INITIALIZE_FRAMEWORK_SCAN_DISABLE) || UX_MAX_DEVICE_INTERFACES > 1
            /* Now we refresh the interface pointer.  */
            interface_ptr =  next_interface;
3419a842:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3419a844:	677b      	str	r3, [r7, #116]	@ 0x74
        while (interface_ptr != UX_NULL)
3419a846:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
3419a848:	2b00      	cmp	r3, #0
3419a84a:	d1e2      	bne.n	3419a812 <_ux_device_stack_configuration_set+0xc6>
#endif

    }

    /* No configuration is selected.  */
    device -> ux_slave_device_configuration_selected =  0;
3419a84c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3419a84e:	2200      	movs	r2, #0
3419a850:	f8c3 2098 	str.w	r2, [r3, #152]	@ 0x98

    /* Mark the device as attached now. */
    device -> ux_slave_device_state =  UX_DEVICE_ATTACHED;
3419a854:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3419a856:	2201      	movs	r2, #1
3419a858:	601a      	str	r2, [r3, #0]

    /* The DCD needs to update the device state too.  */
    dcd -> ux_slave_dcd_function(dcd, UX_DCD_CHANGE_STATE, (VOID *) UX_DEVICE_ATTACHED);
3419a85a:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3419a85c:	699b      	ldr	r3, [r3, #24]
3419a85e:	2201      	movs	r2, #1
3419a860:	2113      	movs	r1, #19
3419a862:	6e38      	ldr	r0, [r7, #96]	@ 0x60
3419a864:	4798      	blx	r3

    /* If the host tries to unconfigure, we are done. */
    if (configuration_value == 0)
3419a866:	687b      	ldr	r3, [r7, #4]
3419a868:	2b00      	cmp	r3, #0
3419a86a:	d101      	bne.n	3419a870 <_ux_device_stack_configuration_set+0x124>
        return(UX_SUCCESS);
3419a86c:	2300      	movs	r3, #0
3419a86e:	e0c8      	b.n	3419aa02 <_ux_device_stack_configuration_set+0x2b6>

    /* Memorize the configuration selected.  */
    device -> ux_slave_device_configuration_selected =  configuration_value;
3419a870:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3419a872:	687a      	ldr	r2, [r7, #4]
3419a874:	f8c3 2098 	str.w	r2, [r3, #152]	@ 0x98
    /* We have found the configuration value requested by the host.
       Create the configuration descriptor and attach it to the device.  */
    _ux_utility_descriptor_parse(device_framework,
                _ux_system_configuration_descriptor_structure,
                UX_CONFIGURATION_DESCRIPTOR_ENTRIES,
                (UCHAR *) &device -> ux_slave_device_configuration_descriptor);
3419a878:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3419a87a:	339c      	adds	r3, #156	@ 0x9c
    _ux_utility_descriptor_parse(device_framework,
3419a87c:	2208      	movs	r2, #8
3419a87e:	4941      	ldr	r1, [pc, #260]	@ (3419a984 <_ux_device_stack_configuration_set+0x238>)
3419a880:	6ff8      	ldr	r0, [r7, #124]	@ 0x7c
3419a882:	f7fe ff17 	bl	341996b4 <_ux_utility_descriptor_parse>

    /* Configuration character D6 is for Self-powered */
    _ux_system_slave -> ux_system_slave_power_state = (configuration_descriptor.bmAttributes & 0x40) ? UX_DEVICE_SELF_POWERED : UX_DEVICE_BUS_POWERED;
3419a886:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
3419a88a:	f003 0340 	and.w	r3, r3, #64	@ 0x40
3419a88e:	2b00      	cmp	r3, #0
3419a890:	d001      	beq.n	3419a896 <_ux_device_stack_configuration_set+0x14a>
3419a892:	2202      	movs	r2, #2
3419a894:	e000      	b.n	3419a898 <_ux_device_stack_configuration_set+0x14c>
3419a896:	2201      	movs	r2, #1
3419a898:	4b39      	ldr	r3, [pc, #228]	@ (3419a980 <_ux_device_stack_configuration_set+0x234>)
3419a89a:	681b      	ldr	r3, [r3, #0]
3419a89c:	f8c3 2158 	str.w	r2, [r3, #344]	@ 0x158

    /* Configuration character D5 is for Remote Wakeup */
    _ux_system_slave -> ux_system_slave_remote_wakeup_capability = (configuration_descriptor.bmAttributes & 0x20) ? UX_TRUE : UX_FALSE;
3419a8a0:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
3419a8a4:	115b      	asrs	r3, r3, #5
3419a8a6:	461a      	mov	r2, r3
3419a8a8:	4b35      	ldr	r3, [pc, #212]	@ (3419a980 <_ux_device_stack_configuration_set+0x234>)
3419a8aa:	681b      	ldr	r3, [r3, #0]
3419a8ac:	f002 0201 	and.w	r2, r2, #1
3419a8b0:	f8c3 215c 	str.w	r2, [r3, #348]	@ 0x15c

    /* Search only in current configuration */
    device_framework_length =  configuration_descriptor.wTotalLength;
3419a8b4:	f8b7 3042 	ldrh.w	r3, [r7, #66]	@ 0x42
3419a8b8:	67bb      	str	r3, [r7, #120]	@ 0x78

    /*  We need to scan all the interface descriptors following this
        configuration descriptor and enable all endpoints associated
        with the default alternate setting of each interface.  */
    while (device_framework_length != 0)
3419a8ba:	e094      	b.n	3419a9e6 <_ux_device_stack_configuration_set+0x29a>
    {

        /* Get the length of the current descriptor.  */
        descriptor_length =  (ULONG) *device_framework;
3419a8bc:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
3419a8be:	781b      	ldrb	r3, [r3, #0]
3419a8c0:	65bb      	str	r3, [r7, #88]	@ 0x58

        /* And its type.  */
        descriptor_type =  *(device_framework + 1);
3419a8c2:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
3419a8c4:	785b      	ldrb	r3, [r3, #1]
3419a8c6:	f887 3057 	strb.w	r3, [r7, #87]	@ 0x57

        /* Check if this is an interface association descriptor.  */
        if(descriptor_type == UX_INTERFACE_ASSOCIATION_DESCRIPTOR_ITEM)
3419a8ca:	f897 3057 	ldrb.w	r3, [r7, #87]	@ 0x57
3419a8ce:	2b0b      	cmp	r3, #11
3419a8d0:	d109      	bne.n	3419a8e6 <_ux_device_stack_configuration_set+0x19a>
        {

            /* Set the IAD flag.  */
            iad_flag = UX_TRUE;
3419a8d2:	2301      	movs	r3, #1
3419a8d4:	66fb      	str	r3, [r7, #108]	@ 0x6c

            /* Get the first interface we have in the IAD. */
            iad_first_interface = (ULONG)  *(device_framework + 2);
3419a8d6:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
3419a8d8:	3302      	adds	r3, #2
3419a8da:	781b      	ldrb	r3, [r3, #0]
3419a8dc:	66bb      	str	r3, [r7, #104]	@ 0x68

            /* Get the number of interfaces we have in the IAD. */
            iad_number_interfaces = (ULONG)  *(device_framework + 3);
3419a8de:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
3419a8e0:	3303      	adds	r3, #3
3419a8e2:	781b      	ldrb	r3, [r3, #0]
3419a8e4:	667b      	str	r3, [r7, #100]	@ 0x64
        }

        /* Check if this is an interface descriptor.  */
        if(descriptor_type == UX_INTERFACE_DESCRIPTOR_ITEM)
3419a8e6:	f897 3057 	ldrb.w	r3, [r7, #87]	@ 0x57
3419a8ea:	2b04      	cmp	r3, #4
3419a8ec:	d173      	bne.n	3419a9d6 <_ux_device_stack_configuration_set+0x28a>
        {

            /* Parse the descriptor in something more readable.  */
            _ux_utility_descriptor_parse(device_framework,
3419a8ee:	f107 0334 	add.w	r3, r7, #52	@ 0x34
3419a8f2:	2209      	movs	r2, #9
3419a8f4:	4924      	ldr	r1, [pc, #144]	@ (3419a988 <_ux_device_stack_configuration_set+0x23c>)
3419a8f6:	6ff8      	ldr	r0, [r7, #124]	@ 0x7c
3419a8f8:	f7fe fedc 	bl	341996b4 <_ux_utility_descriptor_parse>
                        UX_INTERFACE_DESCRIPTOR_ENTRIES,
                        (UCHAR *) &interface_descriptor);

            /* If the alternate setting is 0 for this interface, we need to
               memorize its class association and start it.  */
            if (interface_descriptor.bAlternateSetting == 0)
3419a8fc:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
3419a900:	2b00      	cmp	r3, #0
3419a902:	d168      	bne.n	3419a9d6 <_ux_device_stack_configuration_set+0x28a>
            {

                /* Are we in a IAD scenario ? */
                if (iad_flag == UX_TRUE)
3419a904:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3419a906:	2b01      	cmp	r3, #1
3419a908:	d140      	bne.n	3419a98c <_ux_device_stack_configuration_set+0x240>
                {

                    /* Check if this is the first interface from the IAD. In this case,
                       we need to match a class to this interface.  */
                    if (interface_descriptor.bInterfaceNumber == iad_first_interface)
3419a90a:	f897 3036 	ldrb.w	r3, [r7, #54]	@ 0x36
3419a90e:	461a      	mov	r2, r3
3419a910:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3419a912:	4293      	cmp	r3, r2
3419a914:	d122      	bne.n	3419a95c <_ux_device_stack_configuration_set+0x210>
                    {

                        /* First interface. Scan the list of classes to find a match.  */
                        class_inst =  _ux_system_slave -> ux_system_slave_class_array;
3419a916:	4b1a      	ldr	r3, [pc, #104]	@ (3419a980 <_ux_device_stack_configuration_set+0x234>)
3419a918:	681b      	ldr	r3, [r3, #0]
3419a91a:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
3419a91e:	653b      	str	r3, [r7, #80]	@ 0x50
                        for (class_index = 0; class_index < _ux_system_slave -> ux_system_slave_max_class; class_index++)
                        {
#endif

                            /* Check if this class driver is used.  */
                            if (class_inst -> ux_slave_class_status == UX_USED)
3419a920:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
3419a922:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3419a924:	2b01      	cmp	r3, #1
3419a926:	d122      	bne.n	3419a96e <_ux_device_stack_configuration_set+0x222>
                            {

                                /* Check if this is the same interface for the same configuration. */
                                if ((interface_descriptor.bInterfaceNumber == class_inst -> ux_slave_class_interface_number) &&
3419a928:	f897 3036 	ldrb.w	r3, [r7, #54]	@ 0x36
3419a92c:	461a      	mov	r2, r3
3419a92e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
3419a930:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
3419a934:	429a      	cmp	r2, r3
3419a936:	d11a      	bne.n	3419a96e <_ux_device_stack_configuration_set+0x222>
                                    (configuration_value == class_inst -> ux_slave_class_configuration_number))
3419a938:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
3419a93a:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
                                if ((interface_descriptor.bInterfaceNumber == class_inst -> ux_slave_class_interface_number) &&
3419a93e:	687a      	ldr	r2, [r7, #4]
3419a940:	429a      	cmp	r2, r3
3419a942:	d114      	bne.n	3419a96e <_ux_device_stack_configuration_set+0x222>
                                {

                                    /* Memorize the class in the class/interface array.  */
                                    _ux_system_slave -> ux_system_slave_interface_class_array[interface_descriptor.bInterfaceNumber] = class_inst;
3419a944:	4b0e      	ldr	r3, [pc, #56]	@ (3419a980 <_ux_device_stack_configuration_set+0x234>)
3419a946:	681a      	ldr	r2, [r3, #0]
3419a948:	f897 3036 	ldrb.w	r3, [r7, #54]	@ 0x36
3419a94c:	3344      	adds	r3, #68	@ 0x44
3419a94e:	009b      	lsls	r3, r3, #2
3419a950:	4413      	add	r3, r2
3419a952:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
3419a954:	605a      	str	r2, [r3, #4]

                                    /* And again as the current class.  */
                                    current_class = class_inst;
3419a956:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
3419a958:	673b      	str	r3, [r7, #112]	@ 0x70
3419a95a:	e008      	b.n	3419a96e <_ux_device_stack_configuration_set+0x222>
#endif
                    }
                    else

                        /* Memorize the class in the class/interface array.  We use the current class. */
                        _ux_system_slave -> ux_system_slave_interface_class_array[interface_descriptor.bInterfaceNumber] = current_class;
3419a95c:	4b08      	ldr	r3, [pc, #32]	@ (3419a980 <_ux_device_stack_configuration_set+0x234>)
3419a95e:	681a      	ldr	r2, [r3, #0]
3419a960:	f897 3036 	ldrb.w	r3, [r7, #54]	@ 0x36
3419a964:	3344      	adds	r3, #68	@ 0x44
3419a966:	009b      	lsls	r3, r3, #2
3419a968:	4413      	add	r3, r2
3419a96a:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
3419a96c:	605a      	str	r2, [r3, #4]

                    /* Decrement the number of interfaces found in the same IAD.  */
                    iad_number_interfaces--;
3419a96e:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3419a970:	3b01      	subs	r3, #1
3419a972:	667b      	str	r3, [r7, #100]	@ 0x64

                    /* If none are left, get out of the IAD state machine.  */
                    if (iad_number_interfaces == 0)
3419a974:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3419a976:	2b00      	cmp	r3, #0
3419a978:	d128      	bne.n	3419a9cc <_ux_device_stack_configuration_set+0x280>

                        /* We have exhausted the interfaces within the IAD.  */
                        iad_flag = UX_FALSE;
3419a97a:	2300      	movs	r3, #0
3419a97c:	66fb      	str	r3, [r7, #108]	@ 0x6c
3419a97e:	e025      	b.n	3419a9cc <_ux_device_stack_configuration_set+0x280>
3419a980:	341c33f8 	.word	0x341c33f8
3419a984:	341c00b8 	.word	0x341c00b8
3419a988:	341c00c0 	.word	0x341c00c0
                }
                else
                {

                    /* First interface. Scan the list of classes to find a match.  */
                    class_inst =  _ux_system_slave -> ux_system_slave_class_array;
3419a98c:	4b1f      	ldr	r3, [pc, #124]	@ (3419aa0c <_ux_device_stack_configuration_set+0x2c0>)
3419a98e:	681b      	ldr	r3, [r3, #0]
3419a990:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
3419a994:	653b      	str	r3, [r7, #80]	@ 0x50
                    for (class_index = 0; class_index < _ux_system_slave -> ux_system_slave_max_class; class_index++)
                    {
#endif

                        /* Check if this class driver is used.  */
                        if (class_inst -> ux_slave_class_status == UX_USED)
3419a996:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
3419a998:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3419a99a:	2b01      	cmp	r3, #1
3419a99c:	d116      	bne.n	3419a9cc <_ux_device_stack_configuration_set+0x280>
                        {

                            /* Check if this is the same interface for the same configuration. */
                            if ((interface_descriptor.bInterfaceNumber == class_inst -> ux_slave_class_interface_number) &&
3419a99e:	f897 3036 	ldrb.w	r3, [r7, #54]	@ 0x36
3419a9a2:	461a      	mov	r2, r3
3419a9a4:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
3419a9a6:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
3419a9aa:	429a      	cmp	r2, r3
3419a9ac:	d10e      	bne.n	3419a9cc <_ux_device_stack_configuration_set+0x280>
                                    (configuration_value == class_inst -> ux_slave_class_configuration_number))
3419a9ae:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
3419a9b0:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
                            if ((interface_descriptor.bInterfaceNumber == class_inst -> ux_slave_class_interface_number) &&
3419a9b4:	687a      	ldr	r2, [r7, #4]
3419a9b6:	429a      	cmp	r2, r3
3419a9b8:	d108      	bne.n	3419a9cc <_ux_device_stack_configuration_set+0x280>
                            {

                                /* Memorize the class in the class/interface array.  */
                                _ux_system_slave -> ux_system_slave_interface_class_array[interface_descriptor.bInterfaceNumber] = class_inst;
3419a9ba:	4b14      	ldr	r3, [pc, #80]	@ (3419aa0c <_ux_device_stack_configuration_set+0x2c0>)
3419a9bc:	681a      	ldr	r2, [r3, #0]
3419a9be:	f897 3036 	ldrb.w	r3, [r7, #54]	@ 0x36
3419a9c2:	3344      	adds	r3, #68	@ 0x44
3419a9c4:	009b      	lsls	r3, r3, #2
3419a9c6:	4413      	add	r3, r2
3419a9c8:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
3419a9ca:	605a      	str	r2, [r3, #4]
                    }
#endif
                }

                /* Set the interface.  */
                _ux_device_stack_interface_set(device_framework, device_framework_length, 0);
3419a9cc:	2200      	movs	r2, #0
3419a9ce:	6fb9      	ldr	r1, [r7, #120]	@ 0x78
3419a9d0:	6ff8      	ldr	r0, [r7, #124]	@ 0x7c
3419a9d2:	f000 fe8b 	bl	3419b6ec <_ux_device_stack_interface_set>
            }
        }

        /* Adjust what is left of the device framework.  */
        device_framework_length -=  descriptor_length;
3419a9d6:	6fba      	ldr	r2, [r7, #120]	@ 0x78
3419a9d8:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
3419a9da:	1ad3      	subs	r3, r2, r3
3419a9dc:	67bb      	str	r3, [r7, #120]	@ 0x78

        /* Point to the next descriptor.  */
        device_framework +=  descriptor_length;
3419a9de:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
3419a9e0:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
3419a9e2:	4413      	add	r3, r2
3419a9e4:	67fb      	str	r3, [r7, #124]	@ 0x7c
    while (device_framework_length != 0)
3419a9e6:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
3419a9e8:	2b00      	cmp	r3, #0
3419a9ea:	f47f af67 	bne.w	3419a8bc <_ux_device_stack_configuration_set+0x170>
    }

    /* Mark the device as configured now. */
    device -> ux_slave_device_state =  UX_DEVICE_CONFIGURED;
3419a9ee:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3419a9f0:	2203      	movs	r2, #3
3419a9f2:	601a      	str	r2, [r3, #0]

    /* The DCD needs to update the device state too.  */
    dcd -> ux_slave_dcd_function(dcd, UX_DCD_CHANGE_STATE, (VOID *) UX_DEVICE_CONFIGURED);
3419a9f4:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3419a9f6:	699b      	ldr	r3, [r3, #24]
3419a9f8:	2203      	movs	r2, #3
3419a9fa:	2113      	movs	r1, #19
3419a9fc:	6e38      	ldr	r0, [r7, #96]	@ 0x60
3419a9fe:	4798      	blx	r3

    /* Configuration mounted. */
    return(UX_SUCCESS);
3419aa00:	2300      	movs	r3, #0
}
3419aa02:	4618      	mov	r0, r3
3419aa04:	3780      	adds	r7, #128	@ 0x80
3419aa06:	46bd      	mov	sp, r7
3419aa08:	bd80      	pop	{r7, pc}
3419aa0a:	bf00      	nop
3419aa0c:	341c33f8 	.word	0x341c33f8

3419aa10 <_ux_device_stack_control_request_process>:
/*                                            process with print class,   */
/*                                            resulting in version 6.3.0  */
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_stack_control_request_process(UX_SLAVE_TRANSFER *transfer_request)
{
3419aa10:	b590      	push	{r4, r7, lr}
3419aa12:	b09d      	sub	sp, #116	@ 0x74
3419aa14:	af02      	add	r7, sp, #8
3419aa16:	6078      	str	r0, [r7, #4]
ULONG                       request;
ULONG                       request_value;
ULONG                       request_index;
ULONG                       request_length;
ULONG                       class_index;
UINT                        status =  UX_ERROR;
3419aa18:	23ff      	movs	r3, #255	@ 0xff
3419aa1a:	65fb      	str	r3, [r7, #92]	@ 0x5c
UX_SLAVE_ENDPOINT           *endpoint;
ULONG                       application_data_length;

    /* Get the pointer to the DCD.  */
    dcd =  &_ux_system_slave -> ux_system_slave_dcd;
3419aa1c:	4b9c      	ldr	r3, [pc, #624]	@ (3419ac90 <_ux_device_stack_control_request_process+0x280>)
3419aa1e:	681b      	ldr	r3, [r3, #0]
3419aa20:	65bb      	str	r3, [r7, #88]	@ 0x58

    /* Get the pointer to the device.  */
    device =  &_ux_system_slave -> ux_system_slave_device;
3419aa22:	4b9b      	ldr	r3, [pc, #620]	@ (3419ac90 <_ux_device_stack_control_request_process+0x280>)
3419aa24:	681b      	ldr	r3, [r3, #0]
3419aa26:	3320      	adds	r3, #32
3419aa28:	657b      	str	r3, [r7, #84]	@ 0x54

    /* Ensure that the Setup request has been received correctly.  */
    if (transfer_request -> ux_slave_transfer_request_completion_code == UX_SUCCESS)
3419aa2a:	687b      	ldr	r3, [r7, #4]
3419aa2c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3419aa2e:	2b00      	cmp	r3, #0
3419aa30:	f040 813b 	bne.w	3419acaa <_ux_device_stack_control_request_process+0x29a>
    {

        /* Seems so far, the Setup request is valid. Extract all fields of
           the request.  */
        request_type   =   *transfer_request -> ux_slave_transfer_request_setup;
3419aa34:	687b      	ldr	r3, [r7, #4]
3419aa36:	f893 3054 	ldrb.w	r3, [r3, #84]	@ 0x54
3419aa3a:	667b      	str	r3, [r7, #100]	@ 0x64
        request        =   *(transfer_request -> ux_slave_transfer_request_setup + UX_SETUP_REQUEST);
3419aa3c:	687b      	ldr	r3, [r7, #4]
3419aa3e:	f893 3055 	ldrb.w	r3, [r3, #85]	@ 0x55
3419aa42:	653b      	str	r3, [r7, #80]	@ 0x50
        request_value  =   _ux_utility_short_get(transfer_request -> ux_slave_transfer_request_setup + UX_SETUP_VALUE);
3419aa44:	687b      	ldr	r3, [r7, #4]
3419aa46:	3354      	adds	r3, #84	@ 0x54
3419aa48:	3302      	adds	r3, #2
3419aa4a:	4618      	mov	r0, r3
3419aa4c:	f7ff fa8d 	bl	34199f6a <_ux_utility_short_get>
3419aa50:	64f8      	str	r0, [r7, #76]	@ 0x4c
        request_index  =   _ux_utility_short_get(transfer_request -> ux_slave_transfer_request_setup + UX_SETUP_INDEX);
3419aa52:	687b      	ldr	r3, [r7, #4]
3419aa54:	3354      	adds	r3, #84	@ 0x54
3419aa56:	3304      	adds	r3, #4
3419aa58:	4618      	mov	r0, r3
3419aa5a:	f7ff fa86 	bl	34199f6a <_ux_utility_short_get>
3419aa5e:	64b8      	str	r0, [r7, #72]	@ 0x48
        request_length =   _ux_utility_short_get(transfer_request -> ux_slave_transfer_request_setup + UX_SETUP_LENGTH);
3419aa60:	687b      	ldr	r3, [r7, #4]
3419aa62:	3354      	adds	r3, #84	@ 0x54
3419aa64:	3306      	adds	r3, #6
3419aa66:	4618      	mov	r0, r3
3419aa68:	f7ff fa7f 	bl	34199f6a <_ux_utility_short_get>
3419aa6c:	6478      	str	r0, [r7, #68]	@ 0x44

        /* Filter for GET_DESCRIPTOR/SET_DESCRIPTOR commands. If the descriptor to be returned is not a standard descriptor,
           treat the command as a CLASS command.  */
        if ((request == UX_GET_DESCRIPTOR || request == UX_SET_DESCRIPTOR) && (((request_value >> 8) & UX_REQUEST_TYPE) != UX_REQUEST_TYPE_STANDARD))
3419aa6e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
3419aa70:	2b06      	cmp	r3, #6
3419aa72:	d002      	beq.n	3419aa7a <_ux_device_stack_control_request_process+0x6a>
3419aa74:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
3419aa76:	2b07      	cmp	r3, #7
3419aa78:	d10d      	bne.n	3419aa96 <_ux_device_stack_control_request_process+0x86>
3419aa7a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3419aa7c:	0a1b      	lsrs	r3, r3, #8
3419aa7e:	f003 0360 	and.w	r3, r3, #96	@ 0x60
3419aa82:	2b00      	cmp	r3, #0
3419aa84:	d007      	beq.n	3419aa96 <_ux_device_stack_control_request_process+0x86>
        {        

            /* This request is to be handled by the class layer.  */
            request_type &=  (UINT)~UX_REQUEST_TYPE;
3419aa86:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3419aa88:	f023 0360 	bic.w	r3, r3, #96	@ 0x60
3419aa8c:	667b      	str	r3, [r7, #100]	@ 0x64
            request_type |= UX_REQUEST_TYPE_CLASS;
3419aa8e:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3419aa90:	f043 0320 	orr.w	r3, r3, #32
3419aa94:	667b      	str	r3, [r7, #100]	@ 0x64
        }                   

        /* Check if there is a vendor registered function at the application layer.  If the request
           is VENDOR and the request match, pass the request to the application.  */
        if ((request_type & UX_REQUEST_TYPE) == UX_REQUEST_TYPE_VENDOR)
3419aa96:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3419aa98:	f003 0360 	and.w	r3, r3, #96	@ 0x60
3419aa9c:	2b40      	cmp	r3, #64	@ 0x40
3419aa9e:	d13a      	bne.n	3419ab16 <_ux_device_stack_control_request_process+0x106>
        {

            /* Check the request demanded and compare it to the application registered one.  */
            if (_ux_system_slave -> ux_system_slave_device_vendor_request_function != UX_NULL &&
3419aaa0:	4b7b      	ldr	r3, [pc, #492]	@ (3419ac90 <_ux_device_stack_control_request_process+0x280>)
3419aaa2:	681b      	ldr	r3, [r3, #0]
3419aaa4:	f8d3 3180 	ldr.w	r3, [r3, #384]	@ 0x180
3419aaa8:	2b00      	cmp	r3, #0
3419aaaa:	d034      	beq.n	3419ab16 <_ux_device_stack_control_request_process+0x106>
                request == _ux_system_slave -> ux_system_slave_device_vendor_request)
3419aaac:	4b78      	ldr	r3, [pc, #480]	@ (3419ac90 <_ux_device_stack_control_request_process+0x280>)
3419aaae:	681b      	ldr	r3, [r3, #0]
3419aab0:	f8d3 317c 	ldr.w	r3, [r3, #380]	@ 0x17c
            if (_ux_system_slave -> ux_system_slave_device_vendor_request_function != UX_NULL &&
3419aab4:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
3419aab6:	429a      	cmp	r2, r3
3419aab8:	d12d      	bne.n	3419ab16 <_ux_device_stack_control_request_process+0x106>
            {

                /* This is a Microsoft extended function. It happens before the device is configured. 
                   The request is passed to the application directly.  */
                application_data_length = UX_SLAVE_REQUEST_CONTROL_MAX_LENGTH;
3419aaba:	f44f 7380 	mov.w	r3, #256	@ 0x100
3419aabe:	60fb      	str	r3, [r7, #12]
                status = _ux_system_slave -> ux_system_slave_device_vendor_request_function(request, request_value, 
3419aac0:	4b73      	ldr	r3, [pc, #460]	@ (3419ac90 <_ux_device_stack_control_request_process+0x280>)
3419aac2:	681b      	ldr	r3, [r3, #0]
3419aac4:	f8d3 4180 	ldr.w	r4, [r3, #384]	@ 0x180
3419aac8:	687b      	ldr	r3, [r7, #4]
3419aaca:	68db      	ldr	r3, [r3, #12]
3419aacc:	f107 020c 	add.w	r2, r7, #12
3419aad0:	9201      	str	r2, [sp, #4]
3419aad2:	9300      	str	r3, [sp, #0]
3419aad4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3419aad6:	6cba      	ldr	r2, [r7, #72]	@ 0x48
3419aad8:	6cf9      	ldr	r1, [r7, #76]	@ 0x4c
3419aada:	6d38      	ldr	r0, [r7, #80]	@ 0x50
3419aadc:	47a0      	blx	r4
3419aade:	65f8      	str	r0, [r7, #92]	@ 0x5c
                                                                                            request_index, request_length, 
                                                                                            transfer_request -> ux_slave_transfer_request_data_pointer,
                                                                                            &application_data_length);

                /* Check the status from the application.  */
                if (status == UX_SUCCESS)
3419aae0:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3419aae2:	2b00      	cmp	r3, #0
3419aae4:	d110      	bne.n	3419ab08 <_ux_device_stack_control_request_process+0xf8>
                {
                
                    /* Get the control endpoint associated with the device.  */
                    endpoint =  &device -> ux_slave_device_control_endpoint;
3419aae6:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3419aae8:	3318      	adds	r3, #24
3419aaea:	643b      	str	r3, [r7, #64]	@ 0x40
    
                    /* Get the pointer to the transfer request associated with the control endpoint.  */
                    transfer_request =  &endpoint -> ux_slave_endpoint_transfer_request;
3419aaec:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419aaee:	3320      	adds	r3, #32
3419aaf0:	607b      	str	r3, [r7, #4]
    
                    /* Set the direction to OUT.  */
                    transfer_request -> ux_slave_transfer_request_phase =  UX_TRANSFER_PHASE_DATA_OUT;
3419aaf2:	687b      	ldr	r3, [r7, #4]
3419aaf4:	2203      	movs	r2, #3
3419aaf6:	629a      	str	r2, [r3, #40]	@ 0x28

                    /* Perform the data transfer.  */
                    _ux_device_stack_transfer_request(transfer_request, application_data_length, request_length);
3419aaf8:	68fb      	ldr	r3, [r7, #12]
3419aafa:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
3419aafc:	4619      	mov	r1, r3
3419aafe:	6878      	ldr	r0, [r7, #4]
3419ab00:	f001 f800 	bl	3419bb04 <_ux_device_stack_transfer_request>

                    /* We are done here.  */
                    return(UX_SUCCESS);
3419ab04:	2300      	movs	r3, #0
3419ab06:	e0d1      	b.n	3419acac <_ux_device_stack_control_request_process+0x29c>
                }
                else
                {

                    /* The application did not like the vendor command format, stall the control endpoint.  */
                    _ux_device_stack_endpoint_stall(&device -> ux_slave_device_control_endpoint);
3419ab08:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3419ab0a:	3318      	adds	r3, #24
3419ab0c:	4618      	mov	r0, r3
3419ab0e:	f000 fb47 	bl	3419b1a0 <_ux_device_stack_endpoint_stall>
                    
                    /* We are done here.  */
                    return(UX_SUCCESS);
3419ab12:	2300      	movs	r3, #0
3419ab14:	e0ca      	b.n	3419acac <_ux_device_stack_control_request_process+0x29c>
            }
        }

        /* Check the destination of the request. If the request is of type CLASS or VENDOR_SPECIFIC,
           the function has to be passed to the class layer.  */
        if (((request_type & UX_REQUEST_TYPE) == UX_REQUEST_TYPE_CLASS) ||
3419ab16:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3419ab18:	f003 0360 	and.w	r3, r3, #96	@ 0x60
3419ab1c:	2b20      	cmp	r3, #32
3419ab1e:	d004      	beq.n	3419ab2a <_ux_device_stack_control_request_process+0x11a>
            ((request_type & UX_REQUEST_TYPE) == UX_REQUEST_TYPE_VENDOR))
3419ab20:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3419ab22:	f003 0360 	and.w	r3, r3, #96	@ 0x60
        if (((request_type & UX_REQUEST_TYPE) == UX_REQUEST_TYPE_CLASS) ||
3419ab26:	2b40      	cmp	r3, #64	@ 0x40
3419ab28:	d14f      	bne.n	3419abca <_ux_device_stack_control_request_process+0x1ba>
        {

            /* Build all the fields of the Class Command.  */
            class_command.ux_slave_class_command_request =  UX_SLAVE_CLASS_COMMAND_REQUEST;
3419ab2a:	2304      	movs	r3, #4
3419ab2c:	613b      	str	r3, [r7, #16]

            /* We need to find which class this request is for.  */
            for (class_index = 0; class_index < UX_MAX_SLAVE_INTERFACES; class_index ++)
3419ab2e:	2300      	movs	r3, #0
3419ab30:	663b      	str	r3, [r7, #96]	@ 0x60
3419ab32:	e03b      	b.n	3419abac <_ux_device_stack_control_request_process+0x19c>
            {

                /* Get the class for the interface.  */
                class_ptr =  _ux_system_slave -> ux_system_slave_interface_class_array[class_index];
3419ab34:	4b56      	ldr	r3, [pc, #344]	@ (3419ac90 <_ux_device_stack_control_request_process+0x280>)
3419ab36:	681a      	ldr	r2, [r3, #0]
3419ab38:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3419ab3a:	3344      	adds	r3, #68	@ 0x44
3419ab3c:	009b      	lsls	r3, r3, #2
3419ab3e:	4413      	add	r3, r2
3419ab40:	685b      	ldr	r3, [r3, #4]
3419ab42:	63fb      	str	r3, [r7, #60]	@ 0x3c

                /* If class is not ready, try next.  */
                if (class_ptr == UX_NULL)
3419ab44:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3419ab46:	2b00      	cmp	r3, #0
3419ab48:	d02a      	beq.n	3419aba0 <_ux_device_stack_control_request_process+0x190>
                    continue;

                /* Is the request target to an interface?  */
                if ((request_type & UX_REQUEST_TARGET) == UX_REQUEST_TARGET_INTERFACE)
3419ab4a:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3419ab4c:	f003 0303 	and.w	r3, r3, #3
3419ab50:	2b01      	cmp	r3, #1
3419ab52:	d118      	bne.n	3419ab86 <_ux_device_stack_control_request_process+0x176>
                       the request index, we should go to the next one.  */
                    /* For printer class (0x07) GET_DEVICE_ID (0x00) the high byte of 
                       wIndex is interface index (for recommended index sequence the interface
                       number is same as interface index inside configuration).
                     */
                    if ((request_type == 0xA1) && (request == 0x00) &&
3419ab54:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3419ab56:	2ba1      	cmp	r3, #161	@ 0xa1
3419ab58:	d110      	bne.n	3419ab7c <_ux_device_stack_control_request_process+0x16c>
3419ab5a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
3419ab5c:	2b00      	cmp	r3, #0
3419ab5e:	d10d      	bne.n	3419ab7c <_ux_device_stack_control_request_process+0x16c>
                        (class_ptr -> ux_slave_class_interface -> ux_slave_interface_descriptor.bInterfaceClass == 0x07))
3419ab60:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3419ab62:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
3419ab66:	7c5b      	ldrb	r3, [r3, #17]
                    if ((request_type == 0xA1) && (request == 0x00) &&
3419ab68:	2b07      	cmp	r3, #7
3419ab6a:	d107      	bne.n	3419ab7c <_ux_device_stack_control_request_process+0x16c>
                    {

                        /* Check wIndex high byte.  */
                        if(*(transfer_request -> ux_slave_transfer_request_setup + UX_SETUP_INDEX + 1) != class_index)
3419ab6c:	687b      	ldr	r3, [r7, #4]
3419ab6e:	f893 3059 	ldrb.w	r3, [r3, #89]	@ 0x59
3419ab72:	461a      	mov	r2, r3
3419ab74:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3419ab76:	4293      	cmp	r3, r2
3419ab78:	d005      	beq.n	3419ab86 <_ux_device_stack_control_request_process+0x176>
                            continue;
3419ab7a:	e014      	b.n	3419aba6 <_ux_device_stack_control_request_process+0x196>
                    }
                    else
                    {

                        /* Check wIndex low.  */
                        if ((request_index & 0xFF) != class_index)
3419ab7c:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3419ab7e:	b2db      	uxtb	r3, r3
3419ab80:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
3419ab82:	429a      	cmp	r2, r3
3419ab84:	d10e      	bne.n	3419aba4 <_ux_device_stack_control_request_process+0x194>
                            continue;
                    }
                }

                /* Memorize the class in the command.  */
                class_command.ux_slave_class_command_class_ptr = class_ptr;
3419ab86:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3419ab88:	633b      	str	r3, [r7, #48]	@ 0x30

                /* We have found a potential candidate. Call this registered class entry function.  */
                status = class_ptr -> ux_slave_class_entry_function(&class_command);
3419ab8a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3419ab8c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3419ab8e:	f107 0210 	add.w	r2, r7, #16
3419ab92:	4610      	mov	r0, r2
3419ab94:	4798      	blx	r3
3419ab96:	65f8      	str	r0, [r7, #92]	@ 0x5c

                /* The status simply tells us if the registered class handled the 
                   command - if there was an issue processing the command, it would've 
                   stalled the control endpoint, notifying the host (and not us).  */
                if (status == UX_SUCCESS)
3419ab98:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3419ab9a:	2b00      	cmp	r3, #0
3419ab9c:	d00a      	beq.n	3419abb4 <_ux_device_stack_control_request_process+0x1a4>
3419ab9e:	e002      	b.n	3419aba6 <_ux_device_stack_control_request_process+0x196>
                    continue;
3419aba0:	bf00      	nop
3419aba2:	e000      	b.n	3419aba6 <_ux_device_stack_control_request_process+0x196>
                            continue;
3419aba4:	bf00      	nop
            for (class_index = 0; class_index < UX_MAX_SLAVE_INTERFACES; class_index ++)
3419aba6:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3419aba8:	3301      	adds	r3, #1
3419abaa:	663b      	str	r3, [r7, #96]	@ 0x60
3419abac:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3419abae:	2b0f      	cmp	r3, #15
3419abb0:	d9c0      	bls.n	3419ab34 <_ux_device_stack_control_request_process+0x124>
3419abb2:	e000      	b.n	3419abb6 <_ux_device_stack_control_request_process+0x1a6>

                    /* We are done, break the loop!  */
                    break;
3419abb4:	bf00      	nop

                /* Not handled, try next.  */
            }

            /* If no class handled the command, then we have an error here.  */
            if (status != UX_SUCCESS)
3419abb6:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3419abb8:	2b00      	cmp	r3, #0
3419abba:	d004      	beq.n	3419abc6 <_ux_device_stack_control_request_process+0x1b6>

                /* We stall the command (request not supported).  */
                _ux_device_stack_endpoint_stall(&device -> ux_slave_device_control_endpoint);
3419abbc:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3419abbe:	3318      	adds	r3, #24
3419abc0:	4618      	mov	r0, r3
3419abc2:	f000 faed 	bl	3419b1a0 <_ux_device_stack_endpoint_stall>

            /* We are done for class/vendor request.  */
            return(status);
3419abc6:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3419abc8:	e070      	b.n	3419acac <_ux_device_stack_control_request_process+0x29c>
        }

        /* At this point, the request must be a standard request that the device stack should handle.  */
        switch (request)
3419abca:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
3419abcc:	2b0c      	cmp	r3, #12
3419abce:	d861      	bhi.n	3419ac94 <_ux_device_stack_control_request_process+0x284>
3419abd0:	a201      	add	r2, pc, #4	@ (adr r2, 3419abd8 <_ux_device_stack_control_request_process+0x1c8>)
3419abd2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3419abd6:	bf00      	nop
3419abd8:	3419ac0d 	.word	0x3419ac0d
3419abdc:	3419ac1b 	.word	0x3419ac1b
3419abe0:	3419ac95 	.word	0x3419ac95
3419abe4:	3419ac29 	.word	0x3419ac29
3419abe8:	3419ac95 	.word	0x3419ac95
3419abec:	3419ac37 	.word	0x3419ac37
3419abf0:	3419ac4d 	.word	0x3419ac4d
3419abf4:	3419ac5b 	.word	0x3419ac5b
3419abf8:	3419ac61 	.word	0x3419ac61
3419abfc:	3419ac69 	.word	0x3419ac69
3419ac00:	3419ac73 	.word	0x3419ac73
3419ac04:	3419ac7d 	.word	0x3419ac7d
3419ac08:	3419ac89 	.word	0x3419ac89
        {

        case UX_GET_STATUS:

            status =  _ux_device_stack_get_status(request_type, request_index, request_length);
3419ac0c:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
3419ac0e:	6cb9      	ldr	r1, [r7, #72]	@ 0x48
3419ac10:	6e78      	ldr	r0, [r7, #100]	@ 0x64
3419ac12:	f000 fafd 	bl	3419b210 <_ux_device_stack_get_status>
3419ac16:	65f8      	str	r0, [r7, #92]	@ 0x5c
            break;
3419ac18:	e03f      	b.n	3419ac9a <_ux_device_stack_control_request_process+0x28a>

        case UX_CLEAR_FEATURE:

            status =  _ux_device_stack_clear_feature(request_type, request_value, request_index);
3419ac1a:	6cba      	ldr	r2, [r7, #72]	@ 0x48
3419ac1c:	6cf9      	ldr	r1, [r7, #76]	@ 0x4c
3419ac1e:	6e78      	ldr	r0, [r7, #100]	@ 0x64
3419ac20:	f7ff fd10 	bl	3419a644 <_ux_device_stack_clear_feature>
3419ac24:	65f8      	str	r0, [r7, #92]	@ 0x5c
            break;
3419ac26:	e038      	b.n	3419ac9a <_ux_device_stack_control_request_process+0x28a>

        case UX_SET_FEATURE:

            status =  _ux_device_stack_set_feature(request_type, request_value, request_index);
3419ac28:	6cba      	ldr	r2, [r7, #72]	@ 0x48
3419ac2a:	6cf9      	ldr	r1, [r7, #76]	@ 0x4c
3419ac2c:	6e78      	ldr	r0, [r7, #100]	@ 0x64
3419ac2e:	f000 fec1 	bl	3419b9b4 <_ux_device_stack_set_feature>
3419ac32:	65f8      	str	r0, [r7, #92]	@ 0x5c
            break;
3419ac34:	e031      	b.n	3419ac9a <_ux_device_stack_control_request_process+0x28a>

        case UX_SET_ADDRESS:
        
            /* Memorize the address. Some controllers memorize the address here. Some don't.  */
            dcd -> ux_slave_dcd_device_address =  request_value;
3419ac36:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
3419ac38:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
3419ac3a:	615a      	str	r2, [r3, #20]

            /* Force the new address.  */
            status =  dcd -> ux_slave_dcd_function(dcd, UX_DCD_SET_DEVICE_ADDRESS, (VOID *) (ALIGN_TYPE) request_value);
3419ac3c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
3419ac3e:	699b      	ldr	r3, [r3, #24]
3419ac40:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
3419ac42:	2111      	movs	r1, #17
3419ac44:	6db8      	ldr	r0, [r7, #88]	@ 0x58
3419ac46:	4798      	blx	r3
3419ac48:	65f8      	str	r0, [r7, #92]	@ 0x5c
            break;
3419ac4a:	e026      	b.n	3419ac9a <_ux_device_stack_control_request_process+0x28a>

        case UX_GET_DESCRIPTOR:

            status =  _ux_device_stack_descriptor_send(request_value, request_index, request_length);
3419ac4c:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
3419ac4e:	6cb9      	ldr	r1, [r7, #72]	@ 0x48
3419ac50:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
3419ac52:	f000 f82f 	bl	3419acb4 <_ux_device_stack_descriptor_send>
3419ac56:	65f8      	str	r0, [r7, #92]	@ 0x5c
            break;
3419ac58:	e01f      	b.n	3419ac9a <_ux_device_stack_control_request_process+0x28a>

        case UX_SET_DESCRIPTOR:

            status = UX_FUNCTION_NOT_SUPPORTED;
3419ac5a:	2354      	movs	r3, #84	@ 0x54
3419ac5c:	65fb      	str	r3, [r7, #92]	@ 0x5c
            break;
3419ac5e:	e01c      	b.n	3419ac9a <_ux_device_stack_control_request_process+0x28a>

        case UX_GET_CONFIGURATION:

            status =  _ux_device_stack_configuration_get();
3419ac60:	f7ff fd50 	bl	3419a704 <_ux_device_stack_configuration_get>
3419ac64:	65f8      	str	r0, [r7, #92]	@ 0x5c
            break;
3419ac66:	e018      	b.n	3419ac9a <_ux_device_stack_control_request_process+0x28a>

        case UX_SET_CONFIGURATION:

            status =  _ux_device_stack_configuration_set(request_value);
3419ac68:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
3419ac6a:	f7ff fd6f 	bl	3419a74c <_ux_device_stack_configuration_set>
3419ac6e:	65f8      	str	r0, [r7, #92]	@ 0x5c
            break;
3419ac70:	e013      	b.n	3419ac9a <_ux_device_stack_control_request_process+0x28a>

        case UX_GET_INTERFACE:

            status =  _ux_device_stack_alternate_setting_get(request_index);
3419ac72:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
3419ac74:	f7ff fa50 	bl	3419a118 <_ux_device_stack_alternate_setting_get>
3419ac78:	65f8      	str	r0, [r7, #92]	@ 0x5c
            break;
3419ac7a:	e00e      	b.n	3419ac9a <_ux_device_stack_control_request_process+0x28a>
                
        case UX_SET_INTERFACE:

            status =  _ux_device_stack_alternate_setting_set(request_index,request_value);
3419ac7c:	6cf9      	ldr	r1, [r7, #76]	@ 0x4c
3419ac7e:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
3419ac80:	f7ff fa88 	bl	3419a194 <_ux_device_stack_alternate_setting_set>
3419ac84:	65f8      	str	r0, [r7, #92]	@ 0x5c
            break;
3419ac86:	e008      	b.n	3419ac9a <_ux_device_stack_control_request_process+0x28a>
                

        case UX_SYNCH_FRAME:

            status = UX_SUCCESS;
3419ac88:	2300      	movs	r3, #0
3419ac8a:	65fb      	str	r3, [r7, #92]	@ 0x5c
            break;
3419ac8c:	e005      	b.n	3419ac9a <_ux_device_stack_control_request_process+0x28a>
3419ac8e:	bf00      	nop
3419ac90:	341c33f8 	.word	0x341c33f8

        default :

            status = UX_FUNCTION_NOT_SUPPORTED;
3419ac94:	2354      	movs	r3, #84	@ 0x54
3419ac96:	65fb      	str	r3, [r7, #92]	@ 0x5c
            break;
3419ac98:	bf00      	nop
        }

        if (status != UX_SUCCESS)
3419ac9a:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3419ac9c:	2b00      	cmp	r3, #0
3419ac9e:	d004      	beq.n	3419acaa <_ux_device_stack_control_request_process+0x29a>

            /* Stall the control endpoint to issue protocol error. */
            _ux_device_stack_endpoint_stall(&device -> ux_slave_device_control_endpoint);
3419aca0:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3419aca2:	3318      	adds	r3, #24
3419aca4:	4618      	mov	r0, r3
3419aca6:	f000 fa7b 	bl	3419b1a0 <_ux_device_stack_endpoint_stall>
    }

    /* Return the function status.  */
    return(status);
3419acaa:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
}
3419acac:	4618      	mov	r0, r3
3419acae:	376c      	adds	r7, #108	@ 0x6c
3419acb0:	46bd      	mov	sp, r7
3419acb2:	bd90      	pop	{r4, r7, pc}

3419acb4 <_ux_device_stack_descriptor_send>:
/*                                            requests with zero wIndex,  */
/*                                            resulting in version 6.3.0  */
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_stack_descriptor_send(ULONG descriptor_type, ULONG request_index, ULONG host_length)
{
3419acb4:	b580      	push	{r7, lr}
3419acb6:	b09a      	sub	sp, #104	@ 0x68
3419acb8:	af00      	add	r7, sp, #0
3419acba:	60f8      	str	r0, [r7, #12]
3419acbc:	60b9      	str	r1, [r7, #8]
3419acbe:	607a      	str	r2, [r7, #4]
UX_SLAVE_ENDPOINT               *endpoint;
UCHAR                           *device_framework;
UCHAR                           *device_framework_end;
ULONG                           device_framework_length;
ULONG                           descriptor_length;
ULONG                           target_descriptor_length = 0;
3419acc0:	2300      	movs	r3, #0
3419acc2:	657b      	str	r3, [r7, #84]	@ 0x54
UINT                            status =  UX_ERROR;
3419acc4:	23ff      	movs	r3, #255	@ 0xff
3419acc6:	653b      	str	r3, [r7, #80]	@ 0x50

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_STACK_DESCRIPTOR_SEND, descriptor_type, request_index, 0, 0, UX_TRACE_DEVICE_STACK_EVENTS, 0, 0)

    /* Get the pointer to the DCD.  */
    dcd =  &_ux_system_slave -> ux_system_slave_dcd;
3419acc8:	4b98      	ldr	r3, [pc, #608]	@ (3419af2c <_ux_device_stack_descriptor_send+0x278>)
3419acca:	681b      	ldr	r3, [r3, #0]
3419accc:	63fb      	str	r3, [r7, #60]	@ 0x3c

    /* Get the pointer to the device.  */
    device =  &_ux_system_slave -> ux_system_slave_device;
3419acce:	4b97      	ldr	r3, [pc, #604]	@ (3419af2c <_ux_device_stack_descriptor_send+0x278>)
3419acd0:	681b      	ldr	r3, [r3, #0]
3419acd2:	3320      	adds	r3, #32
3419acd4:	63bb      	str	r3, [r7, #56]	@ 0x38

    /* Get the control endpoint associated with the device.  */
    endpoint =  &device -> ux_slave_device_control_endpoint;
3419acd6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419acd8:	3318      	adds	r3, #24
3419acda:	637b      	str	r3, [r7, #52]	@ 0x34

    /* Get the pointer to the transfer request associated with the endpoint.  */
    transfer_request =  &endpoint -> ux_slave_endpoint_transfer_request;
3419acdc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
3419acde:	3320      	adds	r3, #32
3419ace0:	633b      	str	r3, [r7, #48]	@ 0x30

    /* Set the direction to OUT.  */
    transfer_request -> ux_slave_transfer_request_phase =  UX_TRANSFER_PHASE_DATA_OUT;
3419ace2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3419ace4:	2203      	movs	r2, #3
3419ace6:	629a      	str	r2, [r3, #40]	@ 0x28

    /* Isolate the descriptor index.  */
    descriptor_index =  descriptor_type & 0xff;
3419ace8:	68fb      	ldr	r3, [r7, #12]
3419acea:	b2db      	uxtb	r3, r3
3419acec:	62fb      	str	r3, [r7, #44]	@ 0x2c

    /* Reset the parsed index.  */
    parsed_descriptor_index =  0;
3419acee:	2300      	movs	r3, #0
3419acf0:	667b      	str	r3, [r7, #100]	@ 0x64

    /* Shift the descriptor type in the low byte field.  */
    descriptor_type =  (UCHAR) ((descriptor_type >> 8) & 0xff);
3419acf2:	68fb      	ldr	r3, [r7, #12]
3419acf4:	0a1b      	lsrs	r3, r3, #8
3419acf6:	b2db      	uxtb	r3, r3
3419acf8:	60fb      	str	r3, [r7, #12]

    /* Default descriptor length is host length.  */
    length =  host_length;
3419acfa:	687b      	ldr	r3, [r7, #4]
3419acfc:	64fb      	str	r3, [r7, #76]	@ 0x4c

    /* What type of descriptor do we need to return?  */
    switch (descriptor_type)
3419acfe:	68fb      	ldr	r3, [r7, #12]
3419ad00:	3b01      	subs	r3, #1
3419ad02:	2b0e      	cmp	r3, #14
3419ad04:	f200 81e0 	bhi.w	3419b0c8 <_ux_device_stack_descriptor_send+0x414>
3419ad08:	a201      	add	r2, pc, #4	@ (adr r2, 3419ad10 <_ux_device_stack_descriptor_send+0x5c>)
3419ad0a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3419ad0e:	bf00      	nop
3419ad10:	3419ad4d 	.word	0x3419ad4d
3419ad14:	3419ade1 	.word	0x3419ade1
3419ad18:	3419aefd 	.word	0x3419aefd
3419ad1c:	3419b0c9 	.word	0x3419b0c9
3419ad20:	3419b0c9 	.word	0x3419b0c9
3419ad24:	3419ad57 	.word	0x3419ad57
3419ad28:	3419ade1 	.word	0x3419ade1
3419ad2c:	3419b0c9 	.word	0x3419b0c9
3419ad30:	3419ad67 	.word	0x3419ad67
3419ad34:	3419b0c9 	.word	0x3419b0c9
3419ad38:	3419b0c9 	.word	0x3419b0c9
3419ad3c:	3419b0c9 	.word	0x3419b0c9
3419ad40:	3419b0c9 	.word	0x3419b0c9
3419ad44:	3419b0c9 	.word	0x3419b0c9
3419ad48:	3419ade1 	.word	0x3419ade1
    {

    case UX_DEVICE_DESCRIPTOR_ITEM:

		/* Setup device descriptor length.  */
        if (host_length > UX_DEVICE_DESCRIPTOR_LENGTH)
3419ad4c:	687b      	ldr	r3, [r7, #4]
3419ad4e:	2b12      	cmp	r3, #18
3419ad50:	d901      	bls.n	3419ad56 <_ux_device_stack_descriptor_send+0xa2>
            length =  UX_DEVICE_DESCRIPTOR_LENGTH;
3419ad52:	2312      	movs	r3, #18
3419ad54:	64fb      	str	r3, [r7, #76]	@ 0x4c

        /* Fall through.  */
    case UX_DEVICE_QUALIFIER_DESCRIPTOR_ITEM:

        /* Setup qualifier descriptor length.  */
        if (descriptor_type == UX_DEVICE_QUALIFIER_DESCRIPTOR_ITEM &&
3419ad56:	68fb      	ldr	r3, [r7, #12]
3419ad58:	2b06      	cmp	r3, #6
3419ad5a:	d104      	bne.n	3419ad66 <_ux_device_stack_descriptor_send+0xb2>
3419ad5c:	687b      	ldr	r3, [r7, #4]
3419ad5e:	2b0a      	cmp	r3, #10
3419ad60:	d901      	bls.n	3419ad66 <_ux_device_stack_descriptor_send+0xb2>
            host_length > UX_DEVICE_QUALIFIER_DESCRIPTOR_LENGTH)
            length =  UX_DEVICE_QUALIFIER_DESCRIPTOR_LENGTH;
3419ad62:	230a      	movs	r3, #10
3419ad64:	64fb      	str	r3, [r7, #76]	@ 0x4c

        /* Fall through.  */
    case UX_OTG_DESCRIPTOR_ITEM:

        /* Setup OTG descriptor length.  */
        if (descriptor_type == UX_OTG_DESCRIPTOR_ITEM &&
3419ad66:	68fb      	ldr	r3, [r7, #12]
3419ad68:	2b09      	cmp	r3, #9
3419ad6a:	d104      	bne.n	3419ad76 <_ux_device_stack_descriptor_send+0xc2>
3419ad6c:	687b      	ldr	r3, [r7, #4]
3419ad6e:	2b05      	cmp	r3, #5
3419ad70:	d901      	bls.n	3419ad76 <_ux_device_stack_descriptor_send+0xc2>
            host_length > UX_OTG_DESCRIPTOR_LENGTH)
            length =  UX_OTG_DESCRIPTOR_LENGTH;
3419ad72:	2305      	movs	r3, #5
3419ad74:	64fb      	str	r3, [r7, #76]	@ 0x4c

        /* We may or may not have a device qualifier descriptor.  */
        device_framework =  _ux_system_slave -> ux_system_slave_device_framework;
3419ad76:	4b6d      	ldr	r3, [pc, #436]	@ (3419af2c <_ux_device_stack_descriptor_send+0x278>)
3419ad78:	681b      	ldr	r3, [r3, #0]
3419ad7a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3419ad7e:	663b      	str	r3, [r7, #96]	@ 0x60
        device_framework_length =  _ux_system_slave -> ux_system_slave_device_framework_length;
3419ad80:	4b6a      	ldr	r3, [pc, #424]	@ (3419af2c <_ux_device_stack_descriptor_send+0x278>)
3419ad82:	681b      	ldr	r3, [r3, #0]
3419ad84:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3419ad88:	65bb      	str	r3, [r7, #88]	@ 0x58
        device_framework_end = device_framework + device_framework_length;
3419ad8a:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
3419ad8c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
3419ad8e:	4413      	add	r3, r2
3419ad90:	65fb      	str	r3, [r7, #92]	@ 0x5c

        /* Parse the device framework and locate a device qualifier descriptor.  */
        while (device_framework < device_framework_end)
3419ad92:	e020      	b.n	3419add6 <_ux_device_stack_descriptor_send+0x122>
        {

            /* Get descriptor length.  */
            descriptor_length =  (ULONG) *device_framework;
3419ad94:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3419ad96:	781b      	ldrb	r3, [r3, #0]
3419ad98:	627b      	str	r3, [r7, #36]	@ 0x24

            /* Check if this is a descriptor expected.  */
            if (*(device_framework + 1) == descriptor_type)
3419ad9a:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3419ad9c:	3301      	adds	r3, #1
3419ad9e:	781b      	ldrb	r3, [r3, #0]
3419ada0:	461a      	mov	r2, r3
3419ada2:	68fb      	ldr	r3, [r7, #12]
3419ada4:	4293      	cmp	r3, r2
3419ada6:	d10e      	bne.n	3419adc6 <_ux_device_stack_descriptor_send+0x112>
            {

                /* Copy the device descriptor into the transfer request memory.  */
                _ux_utility_memory_copy(transfer_request -> ux_slave_transfer_request_data_pointer,
3419ada8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3419adaa:	68db      	ldr	r3, [r3, #12]
3419adac:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
3419adae:	6e39      	ldr	r1, [r7, #96]	@ 0x60
3419adb0:	4618      	mov	r0, r3
3419adb2:	f7fe ff77 	bl	34199ca4 <_ux_utility_memory_copy>
                                                device_framework, length); /* Use case of memcpy is verified. */

                /* Perform the data transfer.  */
                status =  _ux_device_stack_transfer_request(transfer_request, length, host_length);
3419adb6:	687a      	ldr	r2, [r7, #4]
3419adb8:	6cf9      	ldr	r1, [r7, #76]	@ 0x4c
3419adba:	6b38      	ldr	r0, [r7, #48]	@ 0x30
3419adbc:	f000 fea2 	bl	3419bb04 <_ux_device_stack_transfer_request>
3419adc0:	6538      	str	r0, [r7, #80]	@ 0x50
                break;
3419adc2:	bf00      	nop
            device_framework_length -=  descriptor_length;

            /* Point to the next descriptor.  */
            device_framework +=  descriptor_length;
        }
        break;
3419adc4:	e18b      	b.n	3419b0de <_ux_device_stack_descriptor_send+0x42a>
            device_framework_length -=  descriptor_length;
3419adc6:	6dba      	ldr	r2, [r7, #88]	@ 0x58
3419adc8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419adca:	1ad3      	subs	r3, r2, r3
3419adcc:	65bb      	str	r3, [r7, #88]	@ 0x58
            device_framework +=  descriptor_length;
3419adce:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
3419add0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419add2:	4413      	add	r3, r2
3419add4:	663b      	str	r3, [r7, #96]	@ 0x60
        while (device_framework < device_framework_end)
3419add6:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
3419add8:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3419adda:	429a      	cmp	r2, r3
3419addc:	d3da      	bcc.n	3419ad94 <_ux_device_stack_descriptor_send+0xe0>
        break;
3419adde:	e17e      	b.n	3419b0de <_ux_device_stack_descriptor_send+0x42a>
#endif
    case UX_OTHER_SPEED_DESCRIPTOR_ITEM:
        /* Fall through.  */
    case UX_CONFIGURATION_DESCRIPTOR_ITEM:

        if (descriptor_type == UX_OTHER_SPEED_DESCRIPTOR_ITEM)
3419ade0:	68fb      	ldr	r3, [r7, #12]
3419ade2:	2b07      	cmp	r3, #7
3419ade4:	d10e      	bne.n	3419ae04 <_ux_device_stack_descriptor_send+0x150>
        {

            /* This request is used by the host to find out the capability of this device
            if it was running at full speed. The behavior is the same as in a GET_CONFIGURATIOn descriptor
            but we do not use the current device framework but rather the full speed framework. */
            device_framework =  _ux_system_slave -> ux_system_slave_device_framework_full_speed;
3419ade6:	4b51      	ldr	r3, [pc, #324]	@ (3419af2c <_ux_device_stack_descriptor_send+0x278>)
3419ade8:	681b      	ldr	r3, [r3, #0]
3419adea:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
3419adee:	663b      	str	r3, [r7, #96]	@ 0x60
            device_framework_length =  _ux_system_slave -> ux_system_slave_device_framework_length_full_speed;
3419adf0:	4b4e      	ldr	r3, [pc, #312]	@ (3419af2c <_ux_device_stack_descriptor_send+0x278>)
3419adf2:	681b      	ldr	r3, [r3, #0]
3419adf4:	f8d3 30ec 	ldr.w	r3, [r3, #236]	@ 0xec
3419adf8:	65bb      	str	r3, [r7, #88]	@ 0x58
            device_framework_end = device_framework + device_framework_length;
3419adfa:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
3419adfc:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
3419adfe:	4413      	add	r3, r2
3419ae00:	65fb      	str	r3, [r7, #92]	@ 0x5c
3419ae02:	e045      	b.n	3419ae90 <_ux_device_stack_descriptor_send+0x1dc>
        else
        {

            /* We may have multiple configurations !, the index will tell us what
            configuration descriptor we need to return.  */
            device_framework =  _ux_system_slave -> ux_system_slave_device_framework;
3419ae04:	4b49      	ldr	r3, [pc, #292]	@ (3419af2c <_ux_device_stack_descriptor_send+0x278>)
3419ae06:	681b      	ldr	r3, [r3, #0]
3419ae08:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3419ae0c:	663b      	str	r3, [r7, #96]	@ 0x60
            device_framework_length =  _ux_system_slave -> ux_system_slave_device_framework_length;
3419ae0e:	4b47      	ldr	r3, [pc, #284]	@ (3419af2c <_ux_device_stack_descriptor_send+0x278>)
3419ae10:	681b      	ldr	r3, [r3, #0]
3419ae12:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3419ae16:	65bb      	str	r3, [r7, #88]	@ 0x58
            device_framework_end = device_framework + device_framework_length;
3419ae18:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
3419ae1a:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
3419ae1c:	4413      	add	r3, r2
3419ae1e:	65fb      	str	r3, [r7, #92]	@ 0x5c
        }

        /* Parse the device framework and locate a configuration descriptor.  */
        while (device_framework < device_framework_end)
3419ae20:	e036      	b.n	3419ae90 <_ux_device_stack_descriptor_send+0x1dc>
        {

            /* Get descriptor length. */
            descriptor_length =  (ULONG) *device_framework;
3419ae22:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3419ae24:	781b      	ldrb	r3, [r3, #0]
3419ae26:	627b      	str	r3, [r7, #36]	@ 0x24

#ifndef UX_BOS_SUPPORT_DISABLE

            /* Check if we are finding BOS descriptor.  */
            if (descriptor_type == UX_BOS_DESCRIPTOR_ITEM)
3419ae28:	68fb      	ldr	r3, [r7, #12]
3419ae2a:	2b0f      	cmp	r3, #15
3419ae2c:	d110      	bne.n	3419ae50 <_ux_device_stack_descriptor_send+0x19c>
            {
                if (*(device_framework + 1) == UX_BOS_DESCRIPTOR_ITEM)
3419ae2e:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3419ae30:	3301      	adds	r3, #1
3419ae32:	781b      	ldrb	r3, [r3, #0]
3419ae34:	2b0f      	cmp	r3, #15
3419ae36:	d123      	bne.n	3419ae80 <_ux_device_stack_descriptor_send+0x1cc>
                {

                    /* Parse the BOS descriptor.  */
                    _ux_utility_descriptor_parse(device_framework,
3419ae38:	f107 0310 	add.w	r3, r7, #16
3419ae3c:	2204      	movs	r2, #4
3419ae3e:	493c      	ldr	r1, [pc, #240]	@ (3419af30 <_ux_device_stack_descriptor_send+0x27c>)
3419ae40:	6e38      	ldr	r0, [r7, #96]	@ 0x60
3419ae42:	f7fe fc37 	bl	341996b4 <_ux_utility_descriptor_parse>
                                _ux_system_bos_descriptor_structure,
                                UX_BOS_DESCRIPTOR_ENTRIES,
                                (UCHAR *) &bos_descriptor);

                    /* Get the length of entire BOS descriptor.  */
                    target_descriptor_length = bos_descriptor.wTotalLength;
3419ae46:	8a7b      	ldrh	r3, [r7, #18]
3419ae48:	657b      	str	r3, [r7, #84]	@ 0x54

                    /* Descriptor is found.  */
                    status = UX_SUCCESS;
3419ae4a:	2300      	movs	r3, #0
3419ae4c:	653b      	str	r3, [r7, #80]	@ 0x50
                    break;
3419ae4e:	e023      	b.n	3419ae98 <_ux_device_stack_descriptor_send+0x1e4>

                /* Check if this is a configuration descriptor.  We are cheating here. Instead of creating
                a OTHER SPEED descriptor, we simply scan the configuration descriptor for the Full Speed
                framework and return this configuration after we manually changed the configuration descriptor
                item into a Other Speed Descriptor. */
                if (*(device_framework + 1) == UX_CONFIGURATION_DESCRIPTOR_ITEM)
3419ae50:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3419ae52:	3301      	adds	r3, #1
3419ae54:	781b      	ldrb	r3, [r3, #0]
3419ae56:	2b02      	cmp	r3, #2
3419ae58:	d112      	bne.n	3419ae80 <_ux_device_stack_descriptor_send+0x1cc>
                {

                    /* Check the index. It must be the same as the one requested.  */
                    if (parsed_descriptor_index == descriptor_index)
3419ae5a:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
3419ae5c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3419ae5e:	429a      	cmp	r2, r3
3419ae60:	d10b      	bne.n	3419ae7a <_ux_device_stack_descriptor_send+0x1c6>
                    {

                        /* Parse the configuration descriptor. */
                        _ux_utility_descriptor_parse(device_framework,
3419ae62:	f107 0318 	add.w	r3, r7, #24
3419ae66:	2208      	movs	r2, #8
3419ae68:	4932      	ldr	r1, [pc, #200]	@ (3419af34 <_ux_device_stack_descriptor_send+0x280>)
3419ae6a:	6e38      	ldr	r0, [r7, #96]	@ 0x60
3419ae6c:	f7fe fc22 	bl	341996b4 <_ux_utility_descriptor_parse>
                                    _ux_system_configuration_descriptor_structure,
                                    UX_CONFIGURATION_DESCRIPTOR_ENTRIES,
                                    (UCHAR *) &configuration_descriptor);

                        /* Get the length of entire configuration descriptor.  */
                        target_descriptor_length = configuration_descriptor.wTotalLength;
3419ae70:	8b7b      	ldrh	r3, [r7, #26]
3419ae72:	657b      	str	r3, [r7, #84]	@ 0x54

                        /* Descriptor is found.  */
                        status = UX_SUCCESS;
3419ae74:	2300      	movs	r3, #0
3419ae76:	653b      	str	r3, [r7, #80]	@ 0x50
                        break;
3419ae78:	e00e      	b.n	3419ae98 <_ux_device_stack_descriptor_send+0x1e4>
                    }
                    else
                    {

                        /* There may be more configuration descriptors in this framework.  */
                        parsed_descriptor_index++;
3419ae7a:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3419ae7c:	3301      	adds	r3, #1
3419ae7e:	667b      	str	r3, [r7, #100]	@ 0x64
                    }
                }
            }

            /* Adjust what is left of the device framework.  */
            device_framework_length -=  descriptor_length;
3419ae80:	6dba      	ldr	r2, [r7, #88]	@ 0x58
3419ae82:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419ae84:	1ad3      	subs	r3, r2, r3
3419ae86:	65bb      	str	r3, [r7, #88]	@ 0x58

            /* Point to the next descriptor.  */
            device_framework +=  descriptor_length;
3419ae88:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
3419ae8a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419ae8c:	4413      	add	r3, r2
3419ae8e:	663b      	str	r3, [r7, #96]	@ 0x60
        while (device_framework < device_framework_end)
3419ae90:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
3419ae92:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3419ae94:	429a      	cmp	r2, r3
3419ae96:	d3c4      	bcc.n	3419ae22 <_ux_device_stack_descriptor_send+0x16e>
        }

        /* Send the descriptor.  */
        if (status == UX_SUCCESS)
3419ae98:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
3419ae9a:	2b00      	cmp	r3, #0
3419ae9c:	f040 811c 	bne.w	3419b0d8 <_ux_device_stack_descriptor_send+0x424>
        {

            /* Ensure the host does not demand a length beyond our descriptor (Windows does that)
                and do not return more than what is allowed.  */
            if (target_descriptor_length < host_length)
3419aea0:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
3419aea2:	687b      	ldr	r3, [r7, #4]
3419aea4:	429a      	cmp	r2, r3
3419aea6:	d202      	bcs.n	3419aeae <_ux_device_stack_descriptor_send+0x1fa>
                length =  target_descriptor_length;
3419aea8:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3419aeaa:	64fb      	str	r3, [r7, #76]	@ 0x4c
3419aeac:	e001      	b.n	3419aeb2 <_ux_device_stack_descriptor_send+0x1fe>
            else
                length =  host_length;
3419aeae:	687b      	ldr	r3, [r7, #4]
3419aeb0:	64fb      	str	r3, [r7, #76]	@ 0x4c

            /* Check buffer length, since total descriptors length may exceed buffer...  */
            if (length > UX_SLAVE_REQUEST_CONTROL_MAX_LENGTH)
3419aeb2:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3419aeb4:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3419aeb8:	d90c      	bls.n	3419aed4 <_ux_device_stack_descriptor_send+0x220>
            {
                /* Error trap. */
                _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_DEVICE_STACK, UX_MEMORY_INSUFFICIENT);
3419aeba:	2212      	movs	r2, #18
3419aebc:	2109      	movs	r1, #9
3419aebe:	2002      	movs	r0, #2
3419aec0:	f7fe fafe 	bl	341994c0 <_ux_system_error_handler>

                /* If trace is enabled, insert this event into the trace buffer.  */
                UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_MEMORY_INSUFFICIENT, device, 0, 0, UX_TRACE_ERRORS, 0, 0)

                /* Stall the endpoint.  */
                status =  dcd -> ux_slave_dcd_function(dcd, UX_DCD_STALL_ENDPOINT, endpoint);
3419aec4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3419aec6:	699b      	ldr	r3, [r3, #24]
3419aec8:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
3419aeca:	2114      	movs	r1, #20
3419aecc:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
3419aece:	4798      	blx	r3
3419aed0:	6538      	str	r0, [r7, #80]	@ 0x50
                break;
3419aed2:	e104      	b.n	3419b0de <_ux_device_stack_descriptor_send+0x42a>
            }

            /* Copy the device descriptor into the transfer request memory.  */
            _ux_utility_memory_copy(transfer_request -> ux_slave_transfer_request_data_pointer,
3419aed4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3419aed6:	68db      	ldr	r3, [r3, #12]
3419aed8:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
3419aeda:	6e39      	ldr	r1, [r7, #96]	@ 0x60
3419aedc:	4618      	mov	r0, r3
3419aede:	f7fe fee1 	bl	34199ca4 <_ux_utility_memory_copy>
                                device_framework, length); /* Use case of memcpy is verified. */

            /* Now we need to hack the found descriptor because this request expect a requested
                descriptor type instead of the regular descriptor.  */
            *(transfer_request -> ux_slave_transfer_request_data_pointer + 1) = (UCHAR)descriptor_type;
3419aee2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3419aee4:	68db      	ldr	r3, [r3, #12]
3419aee6:	3301      	adds	r3, #1
3419aee8:	68fa      	ldr	r2, [r7, #12]
3419aeea:	b2d2      	uxtb	r2, r2
3419aeec:	701a      	strb	r2, [r3, #0]

            /* We can return the configuration descriptor.  */
            status =  _ux_device_stack_transfer_request(transfer_request, length, host_length);
3419aeee:	687a      	ldr	r2, [r7, #4]
3419aef0:	6cf9      	ldr	r1, [r7, #76]	@ 0x4c
3419aef2:	6b38      	ldr	r0, [r7, #48]	@ 0x30
3419aef4:	f000 fe06 	bl	3419bb04 <_ux_device_stack_transfer_request>
3419aef8:	6538      	str	r0, [r7, #80]	@ 0x50
        }
        break;
3419aefa:	e0ed      	b.n	3419b0d8 <_ux_device_stack_descriptor_send+0x424>

    case UX_STRING_DESCRIPTOR_ITEM:

        /* We need to filter for the index 0 which is the language ID string.  */
        if (descriptor_index == 0)
3419aefc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3419aefe:	2b00      	cmp	r3, #0
3419af00:	d14f      	bne.n	3419afa2 <_ux_device_stack_descriptor_send+0x2ee>
        {

            /* We need to check request buffer size in case it's possible exceed. */
            if (_ux_system_slave -> ux_system_slave_language_id_framework_length + 2 > UX_SLAVE_REQUEST_CONTROL_MAX_LENGTH)
3419af02:	4b0a      	ldr	r3, [pc, #40]	@ (3419af2c <_ux_device_stack_descriptor_send+0x278>)
3419af04:	681b      	ldr	r3, [r3, #0]
3419af06:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
3419af0a:	3302      	adds	r3, #2
3419af0c:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3419af10:	d912      	bls.n	3419af38 <_ux_device_stack_descriptor_send+0x284>
            {

                /* Error trap. */
                _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_DEVICE_STACK, UX_MEMORY_INSUFFICIENT);
3419af12:	2212      	movs	r2, #18
3419af14:	2109      	movs	r1, #9
3419af16:	2002      	movs	r0, #2
3419af18:	f7fe fad2 	bl	341994c0 <_ux_system_error_handler>

                /* If trace is enabled, insert this event into the trace buffer.  */
                UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_MEMORY_INSUFFICIENT, device, 0, 0, UX_TRACE_ERRORS, 0, 0)

                /* Stall the endpoint.  */
                status =  dcd -> ux_slave_dcd_function(dcd, UX_DCD_STALL_ENDPOINT, endpoint);
3419af1c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3419af1e:	699b      	ldr	r3, [r3, #24]
3419af20:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
3419af22:	2114      	movs	r1, #20
3419af24:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
3419af26:	4798      	blx	r3
3419af28:	6538      	str	r0, [r7, #80]	@ 0x50
                break;
3419af2a:	e0d8      	b.n	3419b0de <_ux_device_stack_descriptor_send+0x42a>
3419af2c:	341c33f8 	.word	0x341c33f8
3419af30:	341c00cc 	.word	0x341c00cc
3419af34:	341c00b8 	.word	0x341c00b8
            }

            /* We have a request to send back the language ID list. Use the transfer request buffer.  */
            string_memory =  transfer_request -> ux_slave_transfer_request_data_pointer;
3419af38:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3419af3a:	68db      	ldr	r3, [r3, #12]
3419af3c:	62bb      	str	r3, [r7, #40]	@ 0x28

            /* Store the total length of the response.  */
            *string_memory =  (UCHAR)(_ux_system_slave -> ux_system_slave_language_id_framework_length + 2);
3419af3e:	4b6a      	ldr	r3, [pc, #424]	@ (3419b0e8 <_ux_device_stack_descriptor_send+0x434>)
3419af40:	681b      	ldr	r3, [r3, #0]
3419af42:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
3419af46:	b2db      	uxtb	r3, r3
3419af48:	3302      	adds	r3, #2
3419af4a:	b2da      	uxtb	r2, r3
3419af4c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419af4e:	701a      	strb	r2, [r3, #0]

            /* Store the descriptor type.  */
            *(string_memory +1) =  UX_STRING_DESCRIPTOR_ITEM;
3419af50:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419af52:	3301      	adds	r3, #1
3419af54:	2203      	movs	r2, #3
3419af56:	701a      	strb	r2, [r3, #0]

            /* Store the language ID into the buffer.  */
            _ux_utility_memory_copy(string_memory+2, _ux_system_slave -> ux_system_slave_language_id_framework,
3419af58:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419af5a:	1c98      	adds	r0, r3, #2
3419af5c:	4b62      	ldr	r3, [pc, #392]	@ (3419b0e8 <_ux_device_stack_descriptor_send+0x434>)
3419af5e:	681b      	ldr	r3, [r3, #0]
3419af60:	f8d3 1100 	ldr.w	r1, [r3, #256]	@ 0x100
                                                        _ux_system_slave -> ux_system_slave_language_id_framework_length); /* Use case of memcpy is verified. */
3419af64:	4b60      	ldr	r3, [pc, #384]	@ (3419b0e8 <_ux_device_stack_descriptor_send+0x434>)
3419af66:	681b      	ldr	r3, [r3, #0]
            _ux_utility_memory_copy(string_memory+2, _ux_system_slave -> ux_system_slave_language_id_framework,
3419af68:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
3419af6c:	461a      	mov	r2, r3
3419af6e:	f7fe fe99 	bl	34199ca4 <_ux_utility_memory_copy>

            /* Filter the length asked/required.  */
            if (host_length > _ux_system_slave -> ux_system_slave_language_id_framework_length + 2)
3419af72:	4b5d      	ldr	r3, [pc, #372]	@ (3419b0e8 <_ux_device_stack_descriptor_send+0x434>)
3419af74:	681b      	ldr	r3, [r3, #0]
3419af76:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
3419af7a:	3302      	adds	r3, #2
3419af7c:	687a      	ldr	r2, [r7, #4]
3419af7e:	429a      	cmp	r2, r3
3419af80:	d906      	bls.n	3419af90 <_ux_device_stack_descriptor_send+0x2dc>
                length =  _ux_system_slave -> ux_system_slave_language_id_framework_length + 2;
3419af82:	4b59      	ldr	r3, [pc, #356]	@ (3419b0e8 <_ux_device_stack_descriptor_send+0x434>)
3419af84:	681b      	ldr	r3, [r3, #0]
3419af86:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
3419af8a:	3302      	adds	r3, #2
3419af8c:	64fb      	str	r3, [r7, #76]	@ 0x4c
3419af8e:	e001      	b.n	3419af94 <_ux_device_stack_descriptor_send+0x2e0>
            else
                length =  host_length;
3419af90:	687b      	ldr	r3, [r7, #4]
3419af92:	64fb      	str	r3, [r7, #76]	@ 0x4c

            /* We can return the string language ID descriptor.  */
            status =  _ux_device_stack_transfer_request(transfer_request, length, host_length);
3419af94:	687a      	ldr	r2, [r7, #4]
3419af96:	6cf9      	ldr	r1, [r7, #76]	@ 0x4c
3419af98:	6b38      	ldr	r0, [r7, #48]	@ 0x30
3419af9a:	f000 fdb3 	bl	3419bb04 <_ux_device_stack_transfer_request>
3419af9e:	6538      	str	r0, [r7, #80]	@ 0x50
                /* Could not find the required string index. Stall the endpoint.  */
                dcd -> ux_slave_dcd_function(dcd, UX_DCD_STALL_ENDPOINT, endpoint);
                return(UX_ERROR);
            }
        }
        break;
3419afa0:	e09c      	b.n	3419b0dc <_ux_device_stack_descriptor_send+0x428>
            string_framework =  _ux_system_slave -> ux_system_slave_string_framework;
3419afa2:	4b51      	ldr	r3, [pc, #324]	@ (3419b0e8 <_ux_device_stack_descriptor_send+0x434>)
3419afa4:	681b      	ldr	r3, [r3, #0]
3419afa6:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3419afaa:	64bb      	str	r3, [r7, #72]	@ 0x48
            string_framework_length =  _ux_system_slave -> ux_system_slave_string_framework_length;
3419afac:	4b4e      	ldr	r3, [pc, #312]	@ (3419b0e8 <_ux_device_stack_descriptor_send+0x434>)
3419afae:	681b      	ldr	r3, [r3, #0]
3419afb0:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3419afb4:	647b      	str	r3, [r7, #68]	@ 0x44
            while (string_framework_length != 0)
3419afb6:	e079      	b.n	3419b0ac <_ux_device_stack_descriptor_send+0x3f8>
                if (_ux_utility_short_get(string_framework) == request_index)
3419afb8:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
3419afba:	f7fe ffd6 	bl	34199f6a <_ux_utility_short_get>
3419afbe:	4602      	mov	r2, r0
3419afc0:	68bb      	ldr	r3, [r7, #8]
3419afc2:	4293      	cmp	r3, r2
3419afc4:	d163      	bne.n	3419b08e <_ux_device_stack_descriptor_send+0x3da>
                    if (*(string_framework + 2) == descriptor_index)
3419afc6:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3419afc8:	3302      	adds	r3, #2
3419afca:	781b      	ldrb	r3, [r3, #0]
3419afcc:	461a      	mov	r2, r3
3419afce:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3419afd0:	4293      	cmp	r3, r2
3419afd2:	d15c      	bne.n	3419b08e <_ux_device_stack_descriptor_send+0x3da>
                        if (((*(string_framework + 3)*2) + 2) > UX_SLAVE_REQUEST_CONTROL_MAX_LENGTH)
3419afd4:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3419afd6:	3303      	adds	r3, #3
3419afd8:	781b      	ldrb	r3, [r3, #0]
3419afda:	3301      	adds	r3, #1
3419afdc:	005b      	lsls	r3, r3, #1
3419afde:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3419afe2:	dd0c      	ble.n	3419affe <_ux_device_stack_descriptor_send+0x34a>
                            _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_DEVICE_STACK, UX_MEMORY_INSUFFICIENT);
3419afe4:	2212      	movs	r2, #18
3419afe6:	2109      	movs	r1, #9
3419afe8:	2002      	movs	r0, #2
3419afea:	f7fe fa69 	bl	341994c0 <_ux_system_error_handler>
                            status =  dcd -> ux_slave_dcd_function(dcd, UX_DCD_STALL_ENDPOINT, endpoint);
3419afee:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3419aff0:	699b      	ldr	r3, [r3, #24]
3419aff2:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
3419aff4:	2114      	movs	r1, #20
3419aff6:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
3419aff8:	4798      	blx	r3
3419affa:	6538      	str	r0, [r7, #80]	@ 0x50
                            break;
3419affc:	e059      	b.n	3419b0b2 <_ux_device_stack_descriptor_send+0x3fe>
                        string_memory =  transfer_request -> ux_slave_transfer_request_data_pointer;
3419affe:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3419b000:	68db      	ldr	r3, [r3, #12]
3419b002:	62bb      	str	r3, [r7, #40]	@ 0x28
                        *string_memory =  (UCHAR)((*(string_framework + 3)*2) + 2);
3419b004:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3419b006:	3303      	adds	r3, #3
3419b008:	781b      	ldrb	r3, [r3, #0]
3419b00a:	3301      	adds	r3, #1
3419b00c:	b2db      	uxtb	r3, r3
3419b00e:	005b      	lsls	r3, r3, #1
3419b010:	b2da      	uxtb	r2, r3
3419b012:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419b014:	701a      	strb	r2, [r3, #0]
                        *(string_memory + 1) =  UX_STRING_DESCRIPTOR_ITEM;
3419b016:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419b018:	3301      	adds	r3, #1
3419b01a:	2203      	movs	r2, #3
3419b01c:	701a      	strb	r2, [r3, #0]
                        for (string_length = 0; string_length <  *(string_framework + 3) ; string_length ++)
3419b01e:	2300      	movs	r3, #0
3419b020:	643b      	str	r3, [r7, #64]	@ 0x40
3419b022:	e014      	b.n	3419b04e <_ux_device_stack_descriptor_send+0x39a>
                            *(string_memory + 2 + (string_length * 2)) =  *(string_framework + 4 + string_length);
3419b024:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419b026:	3304      	adds	r3, #4
3419b028:	6cba      	ldr	r2, [r7, #72]	@ 0x48
3419b02a:	441a      	add	r2, r3
3419b02c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419b02e:	3301      	adds	r3, #1
3419b030:	005b      	lsls	r3, r3, #1
3419b032:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3419b034:	440b      	add	r3, r1
3419b036:	7812      	ldrb	r2, [r2, #0]
3419b038:	701a      	strb	r2, [r3, #0]
                            *(string_memory + 2 + (string_length * 2) + 1) =  0;
3419b03a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419b03c:	005b      	lsls	r3, r3, #1
3419b03e:	3303      	adds	r3, #3
3419b040:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3419b042:	4413      	add	r3, r2
3419b044:	2200      	movs	r2, #0
3419b046:	701a      	strb	r2, [r3, #0]
                        for (string_length = 0; string_length <  *(string_framework + 3) ; string_length ++)
3419b048:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419b04a:	3301      	adds	r3, #1
3419b04c:	643b      	str	r3, [r7, #64]	@ 0x40
3419b04e:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3419b050:	3303      	adds	r3, #3
3419b052:	781b      	ldrb	r3, [r3, #0]
3419b054:	461a      	mov	r2, r3
3419b056:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419b058:	4293      	cmp	r3, r2
3419b05a:	d3e3      	bcc.n	3419b024 <_ux_device_stack_descriptor_send+0x370>
                        if (host_length > (UINT)((*(string_framework + 3)*2) + 2))
3419b05c:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3419b05e:	3303      	adds	r3, #3
3419b060:	781b      	ldrb	r3, [r3, #0]
3419b062:	3301      	adds	r3, #1
3419b064:	005b      	lsls	r3, r3, #1
3419b066:	461a      	mov	r2, r3
3419b068:	687b      	ldr	r3, [r7, #4]
3419b06a:	4293      	cmp	r3, r2
3419b06c:	d906      	bls.n	3419b07c <_ux_device_stack_descriptor_send+0x3c8>
                            length =  (ULONG)((*(string_framework + 3)*2) + 2);
3419b06e:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3419b070:	3303      	adds	r3, #3
3419b072:	781b      	ldrb	r3, [r3, #0]
3419b074:	3301      	adds	r3, #1
3419b076:	005b      	lsls	r3, r3, #1
3419b078:	64fb      	str	r3, [r7, #76]	@ 0x4c
3419b07a:	e001      	b.n	3419b080 <_ux_device_stack_descriptor_send+0x3cc>
                            length =  host_length;
3419b07c:	687b      	ldr	r3, [r7, #4]
3419b07e:	64fb      	str	r3, [r7, #76]	@ 0x4c
                        status =  _ux_device_stack_transfer_request(transfer_request, length, host_length);
3419b080:	687a      	ldr	r2, [r7, #4]
3419b082:	6cf9      	ldr	r1, [r7, #76]	@ 0x4c
3419b084:	6b38      	ldr	r0, [r7, #48]	@ 0x30
3419b086:	f000 fd3d 	bl	3419bb04 <_ux_device_stack_transfer_request>
3419b08a:	6538      	str	r0, [r7, #80]	@ 0x50
                        break;
3419b08c:	e011      	b.n	3419b0b2 <_ux_device_stack_descriptor_send+0x3fe>
                string_framework_length -=  (ULONG) *(string_framework + 3) + 4;
3419b08e:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3419b090:	3303      	adds	r3, #3
3419b092:	781b      	ldrb	r3, [r3, #0]
3419b094:	461a      	mov	r2, r3
3419b096:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3419b098:	1a9b      	subs	r3, r3, r2
3419b09a:	3b04      	subs	r3, #4
3419b09c:	647b      	str	r3, [r7, #68]	@ 0x44
                string_framework +=  (ULONG) *(string_framework + 3) + 4;
3419b09e:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3419b0a0:	3303      	adds	r3, #3
3419b0a2:	781b      	ldrb	r3, [r3, #0]
3419b0a4:	3304      	adds	r3, #4
3419b0a6:	6cba      	ldr	r2, [r7, #72]	@ 0x48
3419b0a8:	4413      	add	r3, r2
3419b0aa:	64bb      	str	r3, [r7, #72]	@ 0x48
            while (string_framework_length != 0)
3419b0ac:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3419b0ae:	2b00      	cmp	r3, #0
3419b0b0:	d182      	bne.n	3419afb8 <_ux_device_stack_descriptor_send+0x304>
            if (string_framework_length == 0)
3419b0b2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3419b0b4:	2b00      	cmp	r3, #0
3419b0b6:	d111      	bne.n	3419b0dc <_ux_device_stack_descriptor_send+0x428>
                dcd -> ux_slave_dcd_function(dcd, UX_DCD_STALL_ENDPOINT, endpoint);
3419b0b8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3419b0ba:	699b      	ldr	r3, [r3, #24]
3419b0bc:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
3419b0be:	2114      	movs	r1, #20
3419b0c0:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
3419b0c2:	4798      	blx	r3
                return(UX_ERROR);
3419b0c4:	23ff      	movs	r3, #255	@ 0xff
3419b0c6:	e00b      	b.n	3419b0e0 <_ux_device_stack_descriptor_send+0x42c>

    default:

        /* Stall the endpoint.  */
        dcd -> ux_slave_dcd_function(dcd, UX_DCD_STALL_ENDPOINT, endpoint);
3419b0c8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3419b0ca:	699b      	ldr	r3, [r3, #24]
3419b0cc:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
3419b0ce:	2114      	movs	r1, #20
3419b0d0:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
3419b0d2:	4798      	blx	r3
        return(UX_ERROR);
3419b0d4:	23ff      	movs	r3, #255	@ 0xff
3419b0d6:	e003      	b.n	3419b0e0 <_ux_device_stack_descriptor_send+0x42c>
        break;
3419b0d8:	bf00      	nop
3419b0da:	e000      	b.n	3419b0de <_ux_device_stack_descriptor_send+0x42a>
        break;
3419b0dc:	bf00      	nop
    }

    /* Return the status to the caller.  */
    return(status);
3419b0de:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
}
3419b0e0:	4618      	mov	r0, r3
3419b0e2:	3768      	adds	r7, #104	@ 0x68
3419b0e4:	46bd      	mov	sp, r7
3419b0e6:	bd80      	pop	{r7, pc}
3419b0e8:	341c33f8 	.word	0x341c33f8

3419b0ec <_ux_device_stack_disconnect>:
/*                                            names conflict C++ keyword, */
/*                                            resulting in version 6.1.12 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_stack_disconnect(VOID)
{
3419b0ec:	b580      	push	{r7, lr}
3419b0ee:	b092      	sub	sp, #72	@ 0x48
3419b0f0:	af00      	add	r7, sp, #0
#if !defined(UX_DEVICE_INITIALIZE_FRAMEWORK_SCAN_DISABLE) || UX_MAX_DEVICE_INTERFACES > 1
UX_SLAVE_INTERFACE          *next_interface; 
#endif
UX_SLAVE_CLASS              *class_ptr;
UX_SLAVE_CLASS_COMMAND      class_command;
UINT                        status = UX_ERROR;
3419b0f2:	23ff      	movs	r3, #255	@ 0xff
3419b0f4:	643b      	str	r3, [r7, #64]	@ 0x40
                        
    /* Get the pointer to the DCD.  */
    dcd =  &_ux_system_slave -> ux_system_slave_dcd;
3419b0f6:	4b29      	ldr	r3, [pc, #164]	@ (3419b19c <_ux_device_stack_disconnect+0xb0>)
3419b0f8:	681b      	ldr	r3, [r3, #0]
3419b0fa:	63fb      	str	r3, [r7, #60]	@ 0x3c

    /* Get the pointer to the device.  */
    device =  &_ux_system_slave -> ux_system_slave_device;
3419b0fc:	4b27      	ldr	r3, [pc, #156]	@ (3419b19c <_ux_device_stack_disconnect+0xb0>)
3419b0fe:	681b      	ldr	r3, [r3, #0]
3419b100:	3320      	adds	r3, #32
3419b102:	63bb      	str	r3, [r7, #56]	@ 0x38
    /* If trace is enabled, register this object.  */
    UX_TRACE_OBJECT_UNREGISTER(device);

    /* If the device was in the configured state, there may be interfaces
       attached to the configuration.  */
    if (device -> ux_slave_device_state == UX_DEVICE_CONFIGURED)
3419b104:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419b106:	681b      	ldr	r3, [r3, #0]
3419b108:	2b03      	cmp	r3, #3
3419b10a:	d123      	bne.n	3419b154 <_ux_device_stack_disconnect+0x68>
    {
        /* Get the pointer to the first interface.  */
        interface_ptr =  device -> ux_slave_device_first_interface;
3419b10c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419b10e:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
3419b112:	647b      	str	r3, [r7, #68]	@ 0x44

#if !defined(UX_DEVICE_INITIALIZE_FRAMEWORK_SCAN_DISABLE) || UX_MAX_DEVICE_INTERFACES > 1
        /* Parse all the interfaces if any.  */
        while (interface_ptr != UX_NULL)
3419b114:	e018      	b.n	3419b148 <_ux_device_stack_disconnect+0x5c>
        {
#endif

            /* Build all the fields of the Class Command.  */
            class_command.ux_slave_class_command_request =   UX_SLAVE_CLASS_COMMAND_DEACTIVATE;
3419b116:	2303      	movs	r3, #3
3419b118:	607b      	str	r3, [r7, #4]
            class_command.ux_slave_class_command_interface =  (VOID *) interface_ptr;
3419b11a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3419b11c:	60fb      	str	r3, [r7, #12]

            /* Get the pointer to the class container of this interface.  */
            class_ptr =  interface_ptr -> ux_slave_interface_class;
3419b11e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3419b120:	685b      	ldr	r3, [r3, #4]
3419b122:	637b      	str	r3, [r7, #52]	@ 0x34
            
            /* Store the class container. */
            class_command.ux_slave_class_command_class_ptr =  class_ptr;
3419b124:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
3419b126:	627b      	str	r3, [r7, #36]	@ 0x24

            /* If there is a class container for this instance, deactivate it.  */
            if (class_ptr != UX_NULL)
3419b128:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
3419b12a:	2b00      	cmp	r3, #0
3419b12c:	d004      	beq.n	3419b138 <_ux_device_stack_disconnect+0x4c>
            
                /* Call the class with the DEACTIVATE signal.  */
                class_ptr -> ux_slave_class_entry_function(&class_command);
3419b12e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
3419b130:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3419b132:	1d3a      	adds	r2, r7, #4
3419b134:	4610      	mov	r0, r2
3419b136:	4798      	blx	r3

#if !defined(UX_DEVICE_INITIALIZE_FRAMEWORK_SCAN_DISABLE) || UX_MAX_DEVICE_INTERFACES > 1
            /* Get the next interface.  */
            next_interface =  interface_ptr -> ux_slave_interface_next_interface;
3419b138:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3419b13a:	699b      	ldr	r3, [r3, #24]
3419b13c:	633b      	str	r3, [r7, #48]	@ 0x30
#endif

            /* Remove the interface and all endpoints associated with it.  */
            _ux_device_stack_interface_delete(interface_ptr);
3419b13e:	6c78      	ldr	r0, [r7, #68]	@ 0x44
3419b140:	f000 fa8c 	bl	3419b65c <_ux_device_stack_interface_delete>

#if !defined(UX_DEVICE_INITIALIZE_FRAMEWORK_SCAN_DISABLE) || UX_MAX_DEVICE_INTERFACES > 1
            /* Now we refresh the interface pointer.  */
            interface_ptr =  next_interface;
3419b144:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3419b146:	647b      	str	r3, [r7, #68]	@ 0x44
        while (interface_ptr != UX_NULL)
3419b148:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3419b14a:	2b00      	cmp	r3, #0
3419b14c:	d1e3      	bne.n	3419b116 <_ux_device_stack_disconnect+0x2a>
        }
#endif

        /* Mark the device as attached now.  */
        device -> ux_slave_device_state =  UX_DEVICE_ATTACHED;
3419b14e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419b150:	2201      	movs	r2, #1
3419b152:	601a      	str	r2, [r3, #0]
    }

    /* If the device was attached, we need to destroy the control endpoint.  */
    if (device -> ux_slave_device_state == UX_DEVICE_ATTACHED)
3419b154:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419b156:	681b      	ldr	r3, [r3, #0]
3419b158:	2b01      	cmp	r3, #1
3419b15a:	d107      	bne.n	3419b16c <_ux_device_stack_disconnect+0x80>

        /* Now we can destroy the default control endpoint.  */
        status =  dcd -> ux_slave_dcd_function(dcd, UX_DCD_DESTROY_ENDPOINT,
3419b15c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3419b15e:	699b      	ldr	r3, [r3, #24]
                                (VOID *) &device -> ux_slave_device_control_endpoint);
3419b160:	6bba      	ldr	r2, [r7, #56]	@ 0x38
3419b162:	3218      	adds	r2, #24
        status =  dcd -> ux_slave_dcd_function(dcd, UX_DCD_DESTROY_ENDPOINT,
3419b164:	210f      	movs	r1, #15
3419b166:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
3419b168:	4798      	blx	r3
3419b16a:	6438      	str	r0, [r7, #64]	@ 0x40

    /* We are reverting to configuration 0.  */
    device -> ux_slave_device_configuration_selected =  0;
3419b16c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419b16e:	2200      	movs	r2, #0
3419b170:	f8c3 2098 	str.w	r2, [r3, #152]	@ 0x98

    /* Set the device to be non attached.  */
    device -> ux_slave_device_state =  UX_DEVICE_RESET;
3419b174:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419b176:	2200      	movs	r2, #0
3419b178:	601a      	str	r2, [r3, #0]

    /* Check the status change callback.  */
    if(_ux_system_slave -> ux_system_slave_change_function != UX_NULL)
3419b17a:	4b08      	ldr	r3, [pc, #32]	@ (3419b19c <_ux_device_stack_disconnect+0xb0>)
3419b17c:	681b      	ldr	r3, [r3, #0]
3419b17e:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
3419b182:	2b00      	cmp	r3, #0
3419b184:	d005      	beq.n	3419b192 <_ux_device_stack_disconnect+0xa6>
    {

        /* Inform the application if a callback function was programmed.  */
        _ux_system_slave -> ux_system_slave_change_function(UX_DEVICE_REMOVED);
3419b186:	4b05      	ldr	r3, [pc, #20]	@ (3419b19c <_ux_device_stack_disconnect+0xb0>)
3419b188:	681b      	ldr	r3, [r3, #0]
3419b18a:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
3419b18e:	200a      	movs	r0, #10
3419b190:	4798      	blx	r3
    }

    /* Return the status to the caller.  */
    return(status);
3419b192:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
}
3419b194:	4618      	mov	r0, r3
3419b196:	3748      	adds	r7, #72	@ 0x48
3419b198:	46bd      	mov	sp, r7
3419b19a:	bd80      	pop	{r7, pc}
3419b19c:	341c33f8 	.word	0x341c33f8

3419b1a0 <_ux_device_stack_endpoint_stall>:
/*                                            added standalone support,   */
/*                                            resulting in version 6.1.10 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_stack_endpoint_stall(UX_SLAVE_ENDPOINT *endpoint)
{
3419b1a0:	b580      	push	{r7, lr}
3419b1a2:	b088      	sub	sp, #32
3419b1a4:	af00      	add	r7, sp, #0
3419b1a6:	6078      	str	r0, [r7, #4]

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_STACK_ENDPOINT_STALL, endpoint, 0, 0, 0, UX_TRACE_DEVICE_STACK_EVENTS, 0, 0)

    /* Get the pointer to the DCD.  */
    dcd =  &_ux_system_slave -> ux_system_slave_dcd;
3419b1a8:	4b18      	ldr	r3, [pc, #96]	@ (3419b20c <_ux_device_stack_endpoint_stall+0x6c>)
3419b1aa:	681b      	ldr	r3, [r3, #0]
3419b1ac:	61bb      	str	r3, [r7, #24]

    /* Assume device is in an invalid state here in order to reduce code in following 
       section where interrupts are disabled.  */
    status =  UX_ERROR;
3419b1ae:	23ff      	movs	r3, #255	@ 0xff
3419b1b0:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
3419b1b2:	f3ef 8310 	mrs	r3, PRIMASK
3419b1b6:	613b      	str	r3, [r7, #16]
    return(posture);
3419b1b8:	693b      	ldr	r3, [r7, #16]
    int_posture = __get_interrupt_posture();
3419b1ba:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("CPSID i" : : : "memory");
3419b1bc:	b672      	cpsid	i
    return(int_posture);
3419b1be:	68fb      	ldr	r3, [r7, #12]

    /* Ensure we don't change the endpoint's state after disconnection routine
       resets it.  */
    UX_DISABLE
3419b1c0:	617b      	str	r3, [r7, #20]

    /* Check if the device is in a valid state; as soon as the device is out 
       of the RESET state, transfers occur and thus endpoints may be stalled. */
    if (_ux_system_slave -> ux_system_slave_device.ux_slave_device_state != UX_DEVICE_RESET &&
3419b1c2:	4b12      	ldr	r3, [pc, #72]	@ (3419b20c <_ux_device_stack_endpoint_stall+0x6c>)
3419b1c4:	681b      	ldr	r3, [r3, #0]
3419b1c6:	6a1b      	ldr	r3, [r3, #32]
3419b1c8:	2b00      	cmp	r3, #0
3419b1ca:	d013      	beq.n	3419b1f4 <_ux_device_stack_endpoint_stall+0x54>
        endpoint -> ux_slave_endpoint_state != UX_ENDPOINT_HALTED)
3419b1cc:	687b      	ldr	r3, [r7, #4]
3419b1ce:	685b      	ldr	r3, [r3, #4]
    if (_ux_system_slave -> ux_system_slave_device.ux_slave_device_state != UX_DEVICE_RESET &&
3419b1d0:	2b02      	cmp	r3, #2
3419b1d2:	d00f      	beq.n	3419b1f4 <_ux_device_stack_endpoint_stall+0x54>
    {

        /* Stall the endpoint.  */
        status =  dcd -> ux_slave_dcd_function(dcd, UX_DCD_STALL_ENDPOINT, endpoint);
3419b1d4:	69bb      	ldr	r3, [r7, #24]
3419b1d6:	699b      	ldr	r3, [r3, #24]
3419b1d8:	687a      	ldr	r2, [r7, #4]
3419b1da:	2114      	movs	r1, #20
3419b1dc:	69b8      	ldr	r0, [r7, #24]
3419b1de:	4798      	blx	r3
3419b1e0:	61f8      	str	r0, [r7, #28]

        /* Mark the endpoint state.  */
        if ((endpoint -> ux_slave_endpoint_descriptor.bmAttributes & UX_MASK_ENDPOINT_TYPE) !=
3419b1e2:	687b      	ldr	r3, [r7, #4]
3419b1e4:	7bdb      	ldrb	r3, [r3, #15]
3419b1e6:	f003 0303 	and.w	r3, r3, #3
3419b1ea:	2b00      	cmp	r3, #0
3419b1ec:	d002      	beq.n	3419b1f4 <_ux_device_stack_endpoint_stall+0x54>
            UX_CONTROL_ENDPOINT)
            endpoint -> ux_slave_endpoint_state =  UX_ENDPOINT_HALTED;
3419b1ee:	687b      	ldr	r3, [r7, #4]
3419b1f0:	2202      	movs	r2, #2
3419b1f2:	605a      	str	r2, [r3, #4]
3419b1f4:	697b      	ldr	r3, [r7, #20]
3419b1f6:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
3419b1f8:	68bb      	ldr	r3, [r7, #8]
3419b1fa:	f383 8810 	msr	PRIMASK, r3
}
3419b1fe:	bf00      	nop

    /* Restore interrupts.  */
    UX_RESTORE

    /* Return completion status.  */
    return(status);       
3419b200:	69fb      	ldr	r3, [r7, #28]
}
3419b202:	4618      	mov	r0, r3
3419b204:	3720      	adds	r7, #32
3419b206:	46bd      	mov	sp, r7
3419b208:	bd80      	pop	{r7, pc}
3419b20a:	bf00      	nop
3419b20c:	341c33f8 	.word	0x341c33f8

3419b210 <_ux_device_stack_get_status>:
/*                                            supported bi-dir-endpoints, */
/*                                            resulting in version 6.1.6  */
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_stack_get_status(ULONG request_type, ULONG request_index, ULONG request_length)
{
3419b210:	b580      	push	{r7, lr}
3419b212:	b08a      	sub	sp, #40	@ 0x28
3419b214:	af00      	add	r7, sp, #0
3419b216:	60f8      	str	r0, [r7, #12]
3419b218:	60b9      	str	r1, [r7, #8]
3419b21a:	607a      	str	r2, [r7, #4]

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_STACK_GET_STATUS, request_type, request_index, request_length, 0, UX_TRACE_DEVICE_STACK_EVENTS, 0, 0)

    /* Get the pointer to the DCD.  */
    dcd =  &_ux_system_slave -> ux_system_slave_dcd;
3419b21c:	4b39      	ldr	r3, [pc, #228]	@ (3419b304 <_ux_device_stack_get_status+0xf4>)
3419b21e:	681b      	ldr	r3, [r3, #0]
3419b220:	623b      	str	r3, [r7, #32]

    /* Get the pointer to the device.  */
    device =  &_ux_system_slave -> ux_system_slave_device;
3419b222:	4b38      	ldr	r3, [pc, #224]	@ (3419b304 <_ux_device_stack_get_status+0xf4>)
3419b224:	681b      	ldr	r3, [r3, #0]
3419b226:	3320      	adds	r3, #32
3419b228:	61fb      	str	r3, [r7, #28]

    /* Get the control endpoint for the device.  */
    endpoint =  &device -> ux_slave_device_control_endpoint;
3419b22a:	69fb      	ldr	r3, [r7, #28]
3419b22c:	3318      	adds	r3, #24
3419b22e:	61bb      	str	r3, [r7, #24]

    /* Get the pointer to the transfer request associated with the endpoint.  */
    transfer_request =  &endpoint -> ux_slave_endpoint_transfer_request;
3419b230:	69bb      	ldr	r3, [r7, #24]
3419b232:	3320      	adds	r3, #32
3419b234:	617b      	str	r3, [r7, #20]

    /* Reset the status buffer.  */
    *transfer_request -> ux_slave_transfer_request_data_pointer =  0;
3419b236:	697b      	ldr	r3, [r7, #20]
3419b238:	68db      	ldr	r3, [r3, #12]
3419b23a:	2200      	movs	r2, #0
3419b23c:	701a      	strb	r2, [r3, #0]
    *(transfer_request -> ux_slave_transfer_request_data_pointer + 1) =  0;
3419b23e:	697b      	ldr	r3, [r7, #20]
3419b240:	68db      	ldr	r3, [r3, #12]
3419b242:	3301      	adds	r3, #1
3419b244:	2200      	movs	r2, #0
3419b246:	701a      	strb	r2, [r3, #0]
    
    /* The default length for GET_STATUS is 2, except for OTG get Status.  */
    data_length = 2;
3419b248:	2302      	movs	r3, #2
3419b24a:	627b      	str	r3, [r7, #36]	@ 0x24
    
    /* The status can be for either the device or the endpoint.  */
    switch (request_type & UX_REQUEST_TARGET)
3419b24c:	68fb      	ldr	r3, [r7, #12]
3419b24e:	f003 0303 	and.w	r3, r3, #3
3419b252:	2b00      	cmp	r3, #0
3419b254:	d002      	beq.n	3419b25c <_ux_device_stack_get_status+0x4c>
3419b256:	2b02      	cmp	r3, #2
3419b258:	d021      	beq.n	3419b29e <_ux_device_stack_get_status+0x8e>
3419b25a:	e03a      	b.n	3419b2d2 <_ux_device_stack_get_status+0xc2>
    
    case UX_REQUEST_TARGET_DEVICE:

        /* When the device is probed, it is either for the power/remote capabilities or OTG role swap.  
           We differentiate with the Windex, 0 or OTG status Selector.  */
        if (request_index == UX_OTG_STATUS_SELECTOR)
3419b25c:	68bb      	ldr	r3, [r7, #8]
3419b25e:	f5b3 4f70 	cmp.w	r3, #61440	@ 0xf000
3419b262:	d102      	bne.n	3419b26a <_ux_device_stack_get_status+0x5a>
        {

            /* Set the data length to 1.  */
            data_length = 1;
3419b264:	2301      	movs	r3, #1
3419b266:	627b      	str	r3, [r7, #36]	@ 0x24

            if (_ux_system_slave -> ux_system_slave_remote_wakeup_enabled)
                *transfer_request -> ux_slave_transfer_request_data_pointer |=  2;
        }
        
        break;
3419b268:	e03b      	b.n	3419b2e2 <_ux_device_stack_get_status+0xd2>
            if (_ux_system_slave -> ux_system_slave_power_state == UX_DEVICE_SELF_POWERED)
3419b26a:	4b26      	ldr	r3, [pc, #152]	@ (3419b304 <_ux_device_stack_get_status+0xf4>)
3419b26c:	681b      	ldr	r3, [r3, #0]
3419b26e:	f8d3 3158 	ldr.w	r3, [r3, #344]	@ 0x158
3419b272:	2b02      	cmp	r3, #2
3419b274:	d103      	bne.n	3419b27e <_ux_device_stack_get_status+0x6e>
                *transfer_request -> ux_slave_transfer_request_data_pointer =  1;
3419b276:	697b      	ldr	r3, [r7, #20]
3419b278:	68db      	ldr	r3, [r3, #12]
3419b27a:	2201      	movs	r2, #1
3419b27c:	701a      	strb	r2, [r3, #0]
            if (_ux_system_slave -> ux_system_slave_remote_wakeup_enabled)
3419b27e:	4b21      	ldr	r3, [pc, #132]	@ (3419b304 <_ux_device_stack_get_status+0xf4>)
3419b280:	681b      	ldr	r3, [r3, #0]
3419b282:	f8d3 3160 	ldr.w	r3, [r3, #352]	@ 0x160
3419b286:	2b00      	cmp	r3, #0
3419b288:	d02b      	beq.n	3419b2e2 <_ux_device_stack_get_status+0xd2>
                *transfer_request -> ux_slave_transfer_request_data_pointer |=  2;
3419b28a:	697b      	ldr	r3, [r7, #20]
3419b28c:	68db      	ldr	r3, [r3, #12]
3419b28e:	781a      	ldrb	r2, [r3, #0]
3419b290:	697b      	ldr	r3, [r7, #20]
3419b292:	68db      	ldr	r3, [r3, #12]
3419b294:	f042 0202 	orr.w	r2, r2, #2
3419b298:	b2d2      	uxtb	r2, r2
3419b29a:	701a      	strb	r2, [r3, #0]
        break;
3419b29c:	e021      	b.n	3419b2e2 <_ux_device_stack_get_status+0xd2>
        status =  dcd -> ux_slave_dcd_function(dcd, UX_DCD_ENDPOINT_STATUS, (VOID *)(ALIGN_TYPE)(request_index & (UINT)~UX_ENDPOINT_DIRECTION));
#else

        /* This feature returns the halt state of a specific endpoint.  The endpoint address
           is used to retrieve the endpoint container.  */
        status =  dcd -> ux_slave_dcd_function(dcd, UX_DCD_ENDPOINT_STATUS, (VOID *)(ALIGN_TYPE)(request_index));
3419b29e:	6a3b      	ldr	r3, [r7, #32]
3419b2a0:	699b      	ldr	r3, [r3, #24]
3419b2a2:	68ba      	ldr	r2, [r7, #8]
3419b2a4:	2115      	movs	r1, #21
3419b2a6:	6a38      	ldr	r0, [r7, #32]
3419b2a8:	4798      	blx	r3
3419b2aa:	6138      	str	r0, [r7, #16]
#endif

        /* Check the status. We may have a unknown endpoint.  */
        if (status != UX_ERROR)
3419b2ac:	693b      	ldr	r3, [r7, #16]
3419b2ae:	2bff      	cmp	r3, #255	@ 0xff
3419b2b0:	d007      	beq.n	3419b2c2 <_ux_device_stack_get_status+0xb2>
        {

            if (status == UX_TRUE)
3419b2b2:	693b      	ldr	r3, [r7, #16]
3419b2b4:	2b01      	cmp	r3, #1
3419b2b6:	d116      	bne.n	3419b2e6 <_ux_device_stack_get_status+0xd6>
                *transfer_request -> ux_slave_transfer_request_data_pointer =  1;
3419b2b8:	697b      	ldr	r3, [r7, #20]
3419b2ba:	68db      	ldr	r3, [r3, #12]
3419b2bc:	2201      	movs	r2, #1
3419b2be:	701a      	strb	r2, [r3, #0]
            dcd -> ux_slave_dcd_function(dcd, UX_DCD_STALL_ENDPOINT, endpoint);
    
            /* No more work to do here.  The command failed but the upper layer does not depend on it.  */
            return(UX_SUCCESS);            
        }
        break;
3419b2c0:	e011      	b.n	3419b2e6 <_ux_device_stack_get_status+0xd6>
            dcd -> ux_slave_dcd_function(dcd, UX_DCD_STALL_ENDPOINT, endpoint);
3419b2c2:	6a3b      	ldr	r3, [r7, #32]
3419b2c4:	699b      	ldr	r3, [r3, #24]
3419b2c6:	69ba      	ldr	r2, [r7, #24]
3419b2c8:	2114      	movs	r1, #20
3419b2ca:	6a38      	ldr	r0, [r7, #32]
3419b2cc:	4798      	blx	r3
            return(UX_SUCCESS);            
3419b2ce:	2300      	movs	r3, #0
3419b2d0:	e014      	b.n	3419b2fc <_ux_device_stack_get_status+0xec>

    default:
        
        /* We stall the command.  */
        dcd -> ux_slave_dcd_function(dcd, UX_DCD_STALL_ENDPOINT, endpoint);
3419b2d2:	6a3b      	ldr	r3, [r7, #32]
3419b2d4:	699b      	ldr	r3, [r3, #24]
3419b2d6:	69ba      	ldr	r2, [r7, #24]
3419b2d8:	2114      	movs	r1, #20
3419b2da:	6a38      	ldr	r0, [r7, #32]
3419b2dc:	4798      	blx	r3
    
        /* No more work to do here.  The command failed but the upper layer does not depend on it.  */
        return(UX_SUCCESS);            
3419b2de:	2300      	movs	r3, #0
3419b2e0:	e00c      	b.n	3419b2fc <_ux_device_stack_get_status+0xec>
        break;
3419b2e2:	bf00      	nop
3419b2e4:	e000      	b.n	3419b2e8 <_ux_device_stack_get_status+0xd8>
        break;
3419b2e6:	bf00      	nop
    }
    
    /* Set the phase of the transfer to data out.  */
    transfer_request -> ux_slave_transfer_request_phase =  UX_TRANSFER_PHASE_DATA_OUT;
3419b2e8:	697b      	ldr	r3, [r7, #20]
3419b2ea:	2203      	movs	r2, #3
3419b2ec:	629a      	str	r2, [r3, #40]	@ 0x28

    /* Send the descriptor with the appropriate length to the host.  */
    status =  _ux_device_stack_transfer_request(transfer_request, data_length, data_length);
3419b2ee:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
3419b2f0:	6a79      	ldr	r1, [r7, #36]	@ 0x24
3419b2f2:	6978      	ldr	r0, [r7, #20]
3419b2f4:	f000 fc06 	bl	3419bb04 <_ux_device_stack_transfer_request>
3419b2f8:	6138      	str	r0, [r7, #16]

    /* Return the function status.  */
    return(status);
3419b2fa:	693b      	ldr	r3, [r7, #16]
}
3419b2fc:	4618      	mov	r0, r3
3419b2fe:	3728      	adds	r7, #40	@ 0x28
3419b300:	46bd      	mov	sp, r7
3419b302:	bd80      	pop	{r7, pc}
3419b304:	341c33f8 	.word	0x341c33f8

3419b308 <_ux_device_stack_initialize>:
UINT  _ux_device_stack_initialize(UCHAR * device_framework_high_speed, ULONG device_framework_length_high_speed,
                                  UCHAR * device_framework_full_speed, ULONG device_framework_length_full_speed,
                                  UCHAR * string_framework, ULONG string_framework_length,
                                  UCHAR * language_id_framework, ULONG language_id_framework_length,
                                  UINT (*ux_system_slave_change_function)(ULONG))
{
3419b308:	b580      	push	{r7, lr}
3419b30a:	b094      	sub	sp, #80	@ 0x50
3419b30c:	af00      	add	r7, sp, #0
3419b30e:	60f8      	str	r0, [r7, #12]
3419b310:	60b9      	str	r1, [r7, #8]
3419b312:	607a      	str	r2, [r7, #4]
3419b314:	603b      	str	r3, [r7, #0]

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_STACK_INITIALIZE, 0, 0, 0, 0, UX_TRACE_DEVICE_STACK_EVENTS, 0, 0)

    /* Get the pointer to the device. */
    device =  &_ux_system_slave -> ux_system_slave_device;
3419b316:	4b9a      	ldr	r3, [pc, #616]	@ (3419b580 <_ux_device_stack_initialize+0x278>)
3419b318:	681b      	ldr	r3, [r3, #0]
3419b31a:	3320      	adds	r3, #32
3419b31c:	627b      	str	r3, [r7, #36]	@ 0x24

    /* Store the high speed device framework address and length in the project structure.  */
    _ux_system_slave -> ux_system_slave_device_framework_high_speed =             device_framework_high_speed;
3419b31e:	4b98      	ldr	r3, [pc, #608]	@ (3419b580 <_ux_device_stack_initialize+0x278>)
3419b320:	681b      	ldr	r3, [r3, #0]
3419b322:	68fa      	ldr	r2, [r7, #12]
3419b324:	f8c3 20f0 	str.w	r2, [r3, #240]	@ 0xf0
    _ux_system_slave -> ux_system_slave_device_framework_length_high_speed =      device_framework_length_high_speed;
3419b328:	4b95      	ldr	r3, [pc, #596]	@ (3419b580 <_ux_device_stack_initialize+0x278>)
3419b32a:	681b      	ldr	r3, [r3, #0]
3419b32c:	68ba      	ldr	r2, [r7, #8]
3419b32e:	f8c3 20f4 	str.w	r2, [r3, #244]	@ 0xf4

    /* Store the string framework address and length in the project structure.  */
    _ux_system_slave -> ux_system_slave_device_framework_full_speed =             device_framework_full_speed;
3419b332:	4b93      	ldr	r3, [pc, #588]	@ (3419b580 <_ux_device_stack_initialize+0x278>)
3419b334:	681b      	ldr	r3, [r3, #0]
3419b336:	687a      	ldr	r2, [r7, #4]
3419b338:	f8c3 20e8 	str.w	r2, [r3, #232]	@ 0xe8
    _ux_system_slave -> ux_system_slave_device_framework_length_full_speed =      device_framework_length_full_speed;
3419b33c:	4b90      	ldr	r3, [pc, #576]	@ (3419b580 <_ux_device_stack_initialize+0x278>)
3419b33e:	681b      	ldr	r3, [r3, #0]
3419b340:	683a      	ldr	r2, [r7, #0]
3419b342:	f8c3 20ec 	str.w	r2, [r3, #236]	@ 0xec

    /* Store the string framework address and length in the project structure.  */
    _ux_system_slave -> ux_system_slave_string_framework =                         string_framework;
3419b346:	4b8e      	ldr	r3, [pc, #568]	@ (3419b580 <_ux_device_stack_initialize+0x278>)
3419b348:	681b      	ldr	r3, [r3, #0]
3419b34a:	6dba      	ldr	r2, [r7, #88]	@ 0x58
3419b34c:	f8c3 20f8 	str.w	r2, [r3, #248]	@ 0xf8
    _ux_system_slave -> ux_system_slave_string_framework_length =                  string_framework_length;
3419b350:	4b8b      	ldr	r3, [pc, #556]	@ (3419b580 <_ux_device_stack_initialize+0x278>)
3419b352:	681b      	ldr	r3, [r3, #0]
3419b354:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
3419b356:	f8c3 20fc 	str.w	r2, [r3, #252]	@ 0xfc

    /* Store the language ID list in the project structure.  */
    _ux_system_slave -> ux_system_slave_language_id_framework =                 language_id_framework;
3419b35a:	4b89      	ldr	r3, [pc, #548]	@ (3419b580 <_ux_device_stack_initialize+0x278>)
3419b35c:	681b      	ldr	r3, [r3, #0]
3419b35e:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
3419b360:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
    _ux_system_slave -> ux_system_slave_language_id_framework_length =          language_id_framework_length;
3419b364:	4b86      	ldr	r3, [pc, #536]	@ (3419b580 <_ux_device_stack_initialize+0x278>)
3419b366:	681b      	ldr	r3, [r3, #0]
3419b368:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
3419b36a:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

    /* Store the max number of slave class drivers in the project structure.  */
    UX_SYSTEM_DEVICE_MAX_CLASS_SET(UX_MAX_SLAVE_CLASS_DRIVER);
    
    /* Store the device state change function callback.  */
    _ux_system_slave -> ux_system_slave_change_function =  ux_system_slave_change_function;
3419b36e:	4b84      	ldr	r3, [pc, #528]	@ (3419b580 <_ux_device_stack_initialize+0x278>)
3419b370:	681b      	ldr	r3, [r3, #0]
3419b372:	6eba      	ldr	r2, [r7, #104]	@ 0x68
3419b374:	f8c3 2178 	str.w	r2, [r3, #376]	@ 0x178

    /* Allocate memory for the classes.
     * sizeof(UX_SLAVE_CLASS) * UX_MAX_SLAVE_CLASS_DRIVER) overflow is checked
     * outside of the function.
     */
    memory =  _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, sizeof(UX_SLAVE_CLASS) * UX_MAX_SLAVE_CLASS_DRIVER);
3419b378:	f44f 728a 	mov.w	r2, #276	@ 0x114
3419b37c:	2100      	movs	r1, #0
3419b37e:	2000      	movs	r0, #0
3419b380:	f7fe fa8a 	bl	34199898 <_ux_utility_memory_allocate>
3419b384:	6238      	str	r0, [r7, #32]
    if (memory == UX_NULL)
3419b386:	6a3b      	ldr	r3, [r7, #32]
3419b388:	2b00      	cmp	r3, #0
3419b38a:	d101      	bne.n	3419b390 <_ux_device_stack_initialize+0x88>
        return(UX_MEMORY_INSUFFICIENT);
3419b38c:	2312      	movs	r3, #18
3419b38e:	e15d      	b.n	3419b64c <_ux_device_stack_initialize+0x344>
    
    /* Save this memory allocation in the USBX project.  */
    _ux_system_slave -> ux_system_slave_class_array =  (UX_SLAVE_CLASS *) ((void *) memory);
3419b390:	4b7b      	ldr	r3, [pc, #492]	@ (3419b580 <_ux_device_stack_initialize+0x278>)
3419b392:	681b      	ldr	r3, [r3, #0]
3419b394:	6a3a      	ldr	r2, [r7, #32]
3419b396:	f8c3 2110 	str.w	r2, [r3, #272]	@ 0x110

    /* Allocate some memory for the Control Endpoint.  First get the address of the transfer request for the 
       control endpoint. */
    transfer_request =  &device -> ux_slave_device_control_endpoint.ux_slave_endpoint_transfer_request;
3419b39a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419b39c:	3338      	adds	r3, #56	@ 0x38
3419b39e:	61fb      	str	r3, [r7, #28]

    /* Acquire a buffer for the size of the endpoint.  */
    transfer_request -> ux_slave_transfer_request_data_pointer =
          _ux_utility_memory_allocate(UX_NO_ALIGN, UX_CACHE_SAFE_MEMORY, UX_SLAVE_REQUEST_CONTROL_MAX_LENGTH);
3419b3a0:	f44f 7280 	mov.w	r2, #256	@ 0x100
3419b3a4:	2101      	movs	r1, #1
3419b3a6:	2000      	movs	r0, #0
3419b3a8:	f7fe fa76 	bl	34199898 <_ux_utility_memory_allocate>
3419b3ac:	4602      	mov	r2, r0
    transfer_request -> ux_slave_transfer_request_data_pointer =
3419b3ae:	69fb      	ldr	r3, [r7, #28]
3419b3b0:	60da      	str	r2, [r3, #12]

    /* Ensure we have enough memory.  */
    if (transfer_request -> ux_slave_transfer_request_data_pointer == UX_NULL)
3419b3b2:	69fb      	ldr	r3, [r7, #28]
3419b3b4:	68db      	ldr	r3, [r3, #12]
3419b3b6:	2b00      	cmp	r3, #0
3419b3b8:	d102      	bne.n	3419b3c0 <_ux_device_stack_initialize+0xb8>
        status = UX_MEMORY_INSUFFICIENT;
3419b3ba:	2312      	movs	r3, #18
3419b3bc:	64bb      	str	r3, [r7, #72]	@ 0x48
3419b3be:	e001      	b.n	3419b3c4 <_ux_device_stack_initialize+0xbc>
    else
        status = UX_SUCCESS;
3419b3c0:	2300      	movs	r3, #0
3419b3c2:	64bb      	str	r3, [r7, #72]	@ 0x48
    interfaces_found = UX_MAX_SLAVE_INTERFACES;
    endpoints_found = UX_MAX_DEVICE_ENDPOINTS;
#else

    /* Reset all values we are using during the scanning of the framework.  */
    interfaces_found                   =  0;
3419b3c4:	2300      	movs	r3, #0
3419b3c6:	647b      	str	r3, [r7, #68]	@ 0x44
    endpoints_found                    =  0;
3419b3c8:	2300      	movs	r3, #0
3419b3ca:	643b      	str	r3, [r7, #64]	@ 0x40
    max_interface_number               =  0;
3419b3cc:	2300      	movs	r3, #0
3419b3ce:	63fb      	str	r3, [r7, #60]	@ 0x3c

    /* Go on to scan interfaces if no error.  */
    if (status == UX_SUCCESS)
3419b3d0:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3419b3d2:	2b00      	cmp	r3, #0
3419b3d4:	f040 8090 	bne.w	3419b4f8 <_ux_device_stack_initialize+0x1f0>
    {

        /* We need to determine the maximum number of interfaces and endpoints declared in the device framework.  
        This mechanism requires that both framework behave the same way regarding the number of interfaces
        and endpoints.  */
        device_framework        =  _ux_system_slave -> ux_system_slave_device_framework_full_speed;
3419b3d8:	4b69      	ldr	r3, [pc, #420]	@ (3419b580 <_ux_device_stack_initialize+0x278>)
3419b3da:	681b      	ldr	r3, [r3, #0]
3419b3dc:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
3419b3e0:	62fb      	str	r3, [r7, #44]	@ 0x2c
        device_framework_length =  _ux_system_slave -> ux_system_slave_device_framework_length_full_speed;
3419b3e2:	4b67      	ldr	r3, [pc, #412]	@ (3419b580 <_ux_device_stack_initialize+0x278>)
3419b3e4:	681b      	ldr	r3, [r3, #0]
3419b3e6:	f8d3 30ec 	ldr.w	r3, [r3, #236]	@ 0xec
3419b3ea:	62bb      	str	r3, [r7, #40]	@ 0x28

        /* Reset all values we are using during the scanning of the framework.  */
        local_interfaces_found             =  0;
3419b3ec:	2300      	movs	r3, #0
3419b3ee:	63bb      	str	r3, [r7, #56]	@ 0x38
        local_endpoints_found              =  0;
3419b3f0:	2300      	movs	r3, #0
3419b3f2:	637b      	str	r3, [r7, #52]	@ 0x34
        endpoints_in_interface_found       =  0;
3419b3f4:	2300      	movs	r3, #0
3419b3f6:	633b      	str	r3, [r7, #48]	@ 0x30

        /* Parse the device framework and locate interfaces and endpoint descriptor(s).  */
        while (device_framework_length != 0)
3419b3f8:	e054      	b.n	3419b4a4 <_ux_device_stack_initialize+0x19c>
        {

            /* Get the length of this descriptor.  */
            descriptor_length =  (ULONG) *device_framework;
3419b3fa:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3419b3fc:	781b      	ldrb	r3, [r3, #0]
3419b3fe:	61bb      	str	r3, [r7, #24]
        
            /* And its type.  */
            descriptor_type =  *(device_framework + 1);
3419b400:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3419b402:	785b      	ldrb	r3, [r3, #1]
3419b404:	75fb      	strb	r3, [r7, #23]
                    
            /* Check if this is an endpoint descriptor.  */
            switch(descriptor_type)
3419b406:	7dfb      	ldrb	r3, [r7, #23]
3419b408:	2b02      	cmp	r3, #2
3419b40a:	d029      	beq.n	3419b460 <_ux_device_stack_initialize+0x158>
3419b40c:	2b04      	cmp	r3, #4
3419b40e:	d13e      	bne.n	3419b48e <_ux_device_stack_initialize+0x186>

            case UX_INTERFACE_DESCRIPTOR_ITEM:

                /* Check if this is alternate setting 0. If not, do not add another interface found.  
                If this is alternate setting 0, reset the endpoints count for this interface.  */
                if (*(device_framework + 3) == 0)
3419b410:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3419b412:	3303      	adds	r3, #3
3419b414:	781b      	ldrb	r3, [r3, #0]
3419b416:	2b00      	cmp	r3, #0
3419b418:	d10b      	bne.n	3419b432 <_ux_device_stack_initialize+0x12a>
                {

                    /* Add the cumulated number of endpoints in the previous interface.  */
                    local_endpoints_found += endpoints_in_interface_found;
3419b41a:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
3419b41c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3419b41e:	4413      	add	r3, r2
3419b420:	637b      	str	r3, [r7, #52]	@ 0x34

                    /* Read the number of endpoints for this alternate setting.  */
                    endpoints_in_interface_found = (ULONG) *(device_framework + 4);
3419b422:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3419b424:	3304      	adds	r3, #4
3419b426:	781b      	ldrb	r3, [r3, #0]
3419b428:	633b      	str	r3, [r7, #48]	@ 0x30
                    
                    /* Increment the number of interfaces found in the current configuration.  */
                    local_interfaces_found++;
3419b42a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419b42c:	3301      	adds	r3, #1
3419b42e:	63bb      	str	r3, [r7, #56]	@ 0x38
3419b430:	e00a      	b.n	3419b448 <_ux_device_stack_initialize+0x140>
                }                
                else
                {

                    /* Compare the number of endpoints found in this non 0 alternate setting.  */
                    if (endpoints_in_interface_found < (ULONG) *(device_framework + 4))
3419b432:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3419b434:	3304      	adds	r3, #4
3419b436:	781b      	ldrb	r3, [r3, #0]
3419b438:	461a      	mov	r2, r3
3419b43a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3419b43c:	4293      	cmp	r3, r2
3419b43e:	d203      	bcs.n	3419b448 <_ux_device_stack_initialize+0x140>
                    
                        /* Adjust the number of maximum endpoints in this interface.  */
                        endpoints_in_interface_found = (ULONG) *(device_framework + 4);
3419b440:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3419b442:	3304      	adds	r3, #4
3419b444:	781b      	ldrb	r3, [r3, #0]
3419b446:	633b      	str	r3, [r7, #48]	@ 0x30
                }

                /* Check and update max interface number.  */
                if (*(device_framework + 2) > max_interface_number)
3419b448:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3419b44a:	3302      	adds	r3, #2
3419b44c:	781b      	ldrb	r3, [r3, #0]
3419b44e:	461a      	mov	r2, r3
3419b450:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3419b452:	4293      	cmp	r3, r2
3419b454:	d21d      	bcs.n	3419b492 <_ux_device_stack_initialize+0x18a>
                    max_interface_number = *(device_framework + 2);
3419b456:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3419b458:	3302      	adds	r3, #2
3419b45a:	781b      	ldrb	r3, [r3, #0]
3419b45c:	63fb      	str	r3, [r7, #60]	@ 0x3c

                break;
3419b45e:	e018      	b.n	3419b492 <_ux_device_stack_initialize+0x18a>

            case UX_CONFIGURATION_DESCRIPTOR_ITEM:

                /* Check if the number of interfaces found in this configuration is the maximum so far. */
                if (local_interfaces_found > interfaces_found)
3419b460:	6bba      	ldr	r2, [r7, #56]	@ 0x38
3419b462:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3419b464:	429a      	cmp	r2, r3
3419b466:	d901      	bls.n	3419b46c <_ux_device_stack_initialize+0x164>
                    
                    /* We need to adjust the number of maximum interfaces.  */
                    interfaces_found =  local_interfaces_found;
3419b468:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419b46a:	647b      	str	r3, [r7, #68]	@ 0x44

                /* We have a new configuration. We need to reset the number of local interfaces. */
                local_interfaces_found =  0;
3419b46c:	2300      	movs	r3, #0
3419b46e:	63bb      	str	r3, [r7, #56]	@ 0x38

                /* Add the cumulated number of endpoints in the previous interface.  */
                local_endpoints_found += endpoints_in_interface_found;
3419b470:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
3419b472:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3419b474:	4413      	add	r3, r2
3419b476:	637b      	str	r3, [r7, #52]	@ 0x34

                /* Check if the number of endpoints found in the previous configuration is the maximum so far. */
                if (local_endpoints_found > endpoints_found)
3419b478:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
3419b47a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419b47c:	429a      	cmp	r2, r3
3419b47e:	d901      	bls.n	3419b484 <_ux_device_stack_initialize+0x17c>
                    
                    /* We need to adjust the number of maximum endpoints.  */
                    endpoints_found =  local_endpoints_found;
3419b480:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
3419b482:	643b      	str	r3, [r7, #64]	@ 0x40

                /* We have a new configuration. We need to reset the number of local endpoints. */
                local_endpoints_found         =  0;
3419b484:	2300      	movs	r3, #0
3419b486:	637b      	str	r3, [r7, #52]	@ 0x34
                endpoints_in_interface_found  =  0;
3419b488:	2300      	movs	r3, #0
3419b48a:	633b      	str	r3, [r7, #48]	@ 0x30

                break;
3419b48c:	e002      	b.n	3419b494 <_ux_device_stack_initialize+0x18c>

            default:
                break;
3419b48e:	bf00      	nop
3419b490:	e000      	b.n	3419b494 <_ux_device_stack_initialize+0x18c>
                break;
3419b492:	bf00      	nop
            }

            /* Adjust what is left of the device framework.  */
            device_framework_length -=  descriptor_length;
3419b494:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3419b496:	69bb      	ldr	r3, [r7, #24]
3419b498:	1ad3      	subs	r3, r2, r3
3419b49a:	62bb      	str	r3, [r7, #40]	@ 0x28

            /* Point to the next descriptor.  */
            device_framework +=  descriptor_length;
3419b49c:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
3419b49e:	69bb      	ldr	r3, [r7, #24]
3419b4a0:	4413      	add	r3, r2
3419b4a2:	62fb      	str	r3, [r7, #44]	@ 0x2c
        while (device_framework_length != 0)
3419b4a4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419b4a6:	2b00      	cmp	r3, #0
3419b4a8:	d1a7      	bne.n	3419b3fa <_ux_device_stack_initialize+0xf2>
        }
        
        /* Add the cumulated number of endpoints in the previous interface.  */
        local_endpoints_found += endpoints_in_interface_found;
3419b4aa:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
3419b4ac:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3419b4ae:	4413      	add	r3, r2
3419b4b0:	637b      	str	r3, [r7, #52]	@ 0x34

        /* Check if the number of endpoints found in the previous interface is the maximum so far. */
        if (local_endpoints_found > endpoints_found)
3419b4b2:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
3419b4b4:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419b4b6:	429a      	cmp	r2, r3
3419b4b8:	d901      	bls.n	3419b4be <_ux_device_stack_initialize+0x1b6>
                    
            /* We need to adjust the number of maximum endpoints.  */
            endpoints_found =  local_endpoints_found;
3419b4ba:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
3419b4bc:	643b      	str	r3, [r7, #64]	@ 0x40


        /* Check if the number of interfaces found in this configuration is the maximum so far. */
        if (local_interfaces_found > interfaces_found)
3419b4be:	6bba      	ldr	r2, [r7, #56]	@ 0x38
3419b4c0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3419b4c2:	429a      	cmp	r2, r3
3419b4c4:	d901      	bls.n	3419b4ca <_ux_device_stack_initialize+0x1c2>
            
            /* We need to adjust the number of maximum interfaces.  */
            interfaces_found =  local_interfaces_found;
3419b4c6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419b4c8:	647b      	str	r3, [r7, #68]	@ 0x44

        /* We do a sanity check on the finding. At least there must be one interface but endpoints are
        not necessary.  */
        if (interfaces_found == 0)
3419b4ca:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3419b4cc:	2b00      	cmp	r3, #0
3419b4ce:	d106      	bne.n	3419b4de <_ux_device_stack_initialize+0x1d6>
        {

            /* Error trap. */
            _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_INIT, UX_DESCRIPTOR_CORRUPTED);
3419b4d0:	2242      	movs	r2, #66	@ 0x42
3419b4d2:	2103      	movs	r1, #3
3419b4d4:	2002      	movs	r0, #2
3419b4d6:	f7fd fff3 	bl	341994c0 <_ux_system_error_handler>

            /* If trace is enabled, insert this event into the trace buffer.  */
            UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_DESCRIPTOR_CORRUPTED, device_framework, 0, 0, UX_TRACE_ERRORS, 0, 0)

            status = UX_DESCRIPTOR_CORRUPTED;
3419b4da:	2342      	movs	r3, #66	@ 0x42
3419b4dc:	64bb      	str	r3, [r7, #72]	@ 0x48
        }

        /* We do a sanity check on the finding. Max interface number should not exceed limit.  */
        if (status == UX_SUCCESS &&
3419b4de:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3419b4e0:	2b00      	cmp	r3, #0
3419b4e2:	d109      	bne.n	3419b4f8 <_ux_device_stack_initialize+0x1f0>
3419b4e4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3419b4e6:	2b0f      	cmp	r3, #15
3419b4e8:	d906      	bls.n	3419b4f8 <_ux_device_stack_initialize+0x1f0>
            max_interface_number >= UX_MAX_SLAVE_INTERFACES)
        {

            /* Error trap. */
            _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_INIT, UX_MEMORY_INSUFFICIENT);
3419b4ea:	2212      	movs	r2, #18
3419b4ec:	2103      	movs	r1, #3
3419b4ee:	2002      	movs	r0, #2
3419b4f0:	f7fd ffe6 	bl	341994c0 <_ux_system_error_handler>

            /* If trace is enabled, insert this event into the trace buffer.  */
            UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_MEMORY_INSUFFICIENT, device_framework, 0, 0, UX_TRACE_ERRORS, 0, 0)

            status = UX_MEMORY_INSUFFICIENT;
3419b4f4:	2312      	movs	r3, #18
3419b4f6:	64bb      	str	r3, [r7, #72]	@ 0x48
        }
    }
#endif

    /* Go on to allocate interfaces pool if no error.  */
    if (status == UX_SUCCESS)
3419b4f8:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3419b4fa:	2b00      	cmp	r3, #0
3419b4fc:	d118      	bne.n	3419b530 <_ux_device_stack_initialize+0x228>
    {

        /* Memorize both pool sizes.  */
        device -> ux_slave_device_interfaces_pool_number = interfaces_found;
3419b4fe:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419b500:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
3419b502:	f8c3 20b0 	str.w	r2, [r3, #176]	@ 0xb0
        device -> ux_slave_device_endpoints_pool_number  = endpoints_found;
3419b506:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419b508:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
3419b50a:	f8c3 20b8 	str.w	r2, [r3, #184]	@ 0xb8

        /* We assign a pool for the interfaces.  */
        interfaces_pool =  _ux_utility_memory_allocate_mulc_safe(UX_NO_ALIGN, UX_REGULAR_MEMORY, interfaces_found, sizeof(UX_SLAVE_INTERFACE));
3419b50e:	2320      	movs	r3, #32
3419b510:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
3419b512:	2100      	movs	r1, #0
3419b514:	2000      	movs	r0, #0
3419b516:	f7fe fab3 	bl	34199a80 <_ux_utility_memory_allocate_mulc_safe>
3419b51a:	6138      	str	r0, [r7, #16]
        if (interfaces_pool == UX_NULL)
3419b51c:	693b      	ldr	r3, [r7, #16]
3419b51e:	2b00      	cmp	r3, #0
3419b520:	d102      	bne.n	3419b528 <_ux_device_stack_initialize+0x220>
            status = UX_MEMORY_INSUFFICIENT;
3419b522:	2312      	movs	r3, #18
3419b524:	64bb      	str	r3, [r7, #72]	@ 0x48
3419b526:	e003      	b.n	3419b530 <_ux_device_stack_initialize+0x228>
        else

            /* Save the interface pool address in the device container.  */
            device -> ux_slave_device_interfaces_pool =  interfaces_pool;
3419b528:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419b52a:	693a      	ldr	r2, [r7, #16]
3419b52c:	f8c3 20ac 	str.w	r2, [r3, #172]	@ 0xac
    }

    /* Do we need an endpoint pool ?  */
    if (endpoints_found != 0 && status == UX_SUCCESS)
3419b530:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419b532:	2b00      	cmp	r3, #0
3419b534:	d042      	beq.n	3419b5bc <_ux_device_stack_initialize+0x2b4>
3419b536:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3419b538:	2b00      	cmp	r3, #0
3419b53a:	d13f      	bne.n	3419b5bc <_ux_device_stack_initialize+0x2b4>
    {

        /* We assign a pool for the endpoints.  */
        endpoints_pool =  _ux_utility_memory_allocate_mulc_safe(UX_NO_ALIGN, UX_REGULAR_MEMORY, endpoints_found, sizeof(UX_SLAVE_ENDPOINT));
3419b53c:	2380      	movs	r3, #128	@ 0x80
3419b53e:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
3419b540:	2100      	movs	r1, #0
3419b542:	2000      	movs	r0, #0
3419b544:	f7fe fa9c 	bl	34199a80 <_ux_utility_memory_allocate_mulc_safe>
3419b548:	64f8      	str	r0, [r7, #76]	@ 0x4c
        if (endpoints_pool == UX_NULL)
3419b54a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3419b54c:	2b00      	cmp	r3, #0
3419b54e:	d102      	bne.n	3419b556 <_ux_device_stack_initialize+0x24e>
            status = UX_MEMORY_INSUFFICIENT;
3419b550:	2312      	movs	r3, #18
3419b552:	64bb      	str	r3, [r7, #72]	@ 0x48
        if (endpoints_pool == UX_NULL)
3419b554:	e034      	b.n	3419b5c0 <_ux_device_stack_initialize+0x2b8>
        else
        {

            /* Save the endpoint pool address in the device container.  */
            device -> ux_slave_device_endpoints_pool =  endpoints_pool;
3419b556:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419b558:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
3419b55a:	f8c3 20b4 	str.w	r2, [r3, #180]	@ 0xb4

            /* We need to assign a transfer buffer to each endpoint. Each endpoint is assigned the
            maximum buffer size.  We also assign the semaphore used by the endpoint to synchronize transfer
            completion. */
            while (endpoints_pool < (device -> ux_slave_device_endpoints_pool + endpoints_found))
3419b55e:	e022      	b.n	3419b5a6 <_ux_device_stack_initialize+0x29e>

#if UX_DEVICE_ENDPOINT_BUFFER_OWNER == 0

                /* Obtain some memory.  */
                endpoints_pool -> ux_slave_endpoint_transfer_request.ux_slave_transfer_request_data_pointer = 
                                _ux_utility_memory_allocate(UX_NO_ALIGN, UX_CACHE_SAFE_MEMORY, UX_SLAVE_REQUEST_DATA_MAX_LENGTH);
3419b560:	f44f 6280 	mov.w	r2, #1024	@ 0x400
3419b564:	2101      	movs	r1, #1
3419b566:	2000      	movs	r0, #0
3419b568:	f7fe f996 	bl	34199898 <_ux_utility_memory_allocate>
3419b56c:	4602      	mov	r2, r0
                endpoints_pool -> ux_slave_endpoint_transfer_request.ux_slave_transfer_request_data_pointer = 
3419b56e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3419b570:	62da      	str	r2, [r3, #44]	@ 0x2c

                /* Ensure we could allocate memory.  */
                if (endpoints_pool -> ux_slave_endpoint_transfer_request.ux_slave_transfer_request_data_pointer == UX_NULL)
3419b572:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3419b574:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3419b576:	2b00      	cmp	r3, #0
3419b578:	d104      	bne.n	3419b584 <_ux_device_stack_initialize+0x27c>
                {
                    status = UX_MEMORY_INSUFFICIENT;
3419b57a:	2312      	movs	r3, #18
3419b57c:	64bb      	str	r3, [r7, #72]	@ 0x48
                    break;
3419b57e:	e01c      	b.n	3419b5ba <_ux_device_stack_initialize+0x2b2>
3419b580:	341c33f8 	.word	0x341c33f8
                }
#endif

                /* Create the semaphore for the endpoint.  */
                status =  _ux_device_semaphore_create(&endpoints_pool -> ux_slave_endpoint_transfer_request.ux_slave_transfer_request_semaphore,
3419b584:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3419b586:	3350      	adds	r3, #80	@ 0x50
3419b588:	2200      	movs	r2, #0
3419b58a:	4932      	ldr	r1, [pc, #200]	@ (3419b654 <_ux_device_stack_initialize+0x34c>)
3419b58c:	4618      	mov	r0, r3
3419b58e:	f7fe fc80 	bl	34199e92 <_ux_utility_semaphore_create>
3419b592:	64b8      	str	r0, [r7, #72]	@ 0x48
                                                    "ux_transfer_request_semaphore", 0);

                /* Check completion status.  */
                if (status != UX_SUCCESS)
3419b594:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3419b596:	2b00      	cmp	r3, #0
3419b598:	d002      	beq.n	3419b5a0 <_ux_device_stack_initialize+0x298>
                {
                    status = UX_SEMAPHORE_ERROR;
3419b59a:	2315      	movs	r3, #21
3419b59c:	64bb      	str	r3, [r7, #72]	@ 0x48
                    break;
3419b59e:	e00c      	b.n	3419b5ba <_ux_device_stack_initialize+0x2b2>
                }
        
                /* Next endpoint.  */
                endpoints_pool++;
3419b5a0:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3419b5a2:	3380      	adds	r3, #128	@ 0x80
3419b5a4:	64fb      	str	r3, [r7, #76]	@ 0x4c
            while (endpoints_pool < (device -> ux_slave_device_endpoints_pool + endpoints_found))
3419b5a6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419b5a8:	f8d3 20b4 	ldr.w	r2, [r3, #180]	@ 0xb4
3419b5ac:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419b5ae:	01db      	lsls	r3, r3, #7
3419b5b0:	4413      	add	r3, r2
3419b5b2:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
3419b5b4:	429a      	cmp	r2, r3
3419b5b6:	d3d3      	bcc.n	3419b560 <_ux_device_stack_initialize+0x258>
        if (endpoints_pool == UX_NULL)
3419b5b8:	e002      	b.n	3419b5c0 <_ux_device_stack_initialize+0x2b8>
3419b5ba:	e001      	b.n	3419b5c0 <_ux_device_stack_initialize+0x2b8>
            }
        }
    }
    else
        endpoints_pool = UX_NULL;
3419b5bc:	2300      	movs	r3, #0
3419b5be:	64fb      	str	r3, [r7, #76]	@ 0x4c

    /* Return successful completion.  */
    if (status == UX_SUCCESS)
3419b5c0:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3419b5c2:	2b00      	cmp	r3, #0
3419b5c4:	d101      	bne.n	3419b5ca <_ux_device_stack_initialize+0x2c2>
        return(UX_SUCCESS);
3419b5c6:	2300      	movs	r3, #0
3419b5c8:	e040      	b.n	3419b64c <_ux_device_stack_initialize+0x344>
    
    /* Free resources when there is error.  */

    /* Free device -> ux_slave_device_endpoints_pool.  */
    if (endpoints_pool)
3419b5ca:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3419b5cc:	2b00      	cmp	r3, #0
3419b5ce:	d021      	beq.n	3419b614 <_ux_device_stack_initialize+0x30c>
    {

        /* In error cases creating endpoint resources, endpoints_pool is endpoint that failed.
         * Previously allocated things should be freed.  */
        while(endpoints_pool >= device -> ux_slave_device_endpoints_pool)
3419b5d0:	e014      	b.n	3419b5fc <_ux_device_stack_initialize+0x2f4>
        {

            /* Delete ux_slave_transfer_request_semaphore.  */
            if (_ux_device_semaphore_created(&endpoints_pool -> ux_slave_endpoint_transfer_request.ux_slave_transfer_request_semaphore))
3419b5d2:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3419b5d4:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
3419b5d6:	2b00      	cmp	r3, #0
3419b5d8:	d004      	beq.n	3419b5e4 <_ux_device_stack_initialize+0x2dc>
                _ux_device_semaphore_delete(&endpoints_pool -> ux_slave_endpoint_transfer_request.ux_slave_transfer_request_semaphore);
3419b5da:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3419b5dc:	3350      	adds	r3, #80	@ 0x50
3419b5de:	4618      	mov	r0, r3
3419b5e0:	f7fe fc71 	bl	34199ec6 <_ux_utility_semaphore_delete>

#if UX_DEVICE_ENDPOINT_BUFFER_OWNER == 0

            /* Free ux_slave_transfer_request_data_pointer buffer.  */
            if (endpoints_pool -> ux_slave_endpoint_transfer_request.ux_slave_transfer_request_data_pointer)
3419b5e4:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3419b5e6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3419b5e8:	2b00      	cmp	r3, #0
3419b5ea:	d004      	beq.n	3419b5f6 <_ux_device_stack_initialize+0x2ee>
                _ux_utility_memory_free(endpoints_pool -> ux_slave_endpoint_transfer_request.ux_slave_transfer_request_data_pointer);
3419b5ec:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3419b5ee:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3419b5f0:	4618      	mov	r0, r3
3419b5f2:	f7fe fb75 	bl	34199ce0 <_ux_utility_memory_free>
#endif

            /* Move to previous endpoint.  */
            endpoints_pool --;
3419b5f6:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3419b5f8:	3b80      	subs	r3, #128	@ 0x80
3419b5fa:	64fb      	str	r3, [r7, #76]	@ 0x4c
        while(endpoints_pool >= device -> ux_slave_device_endpoints_pool)
3419b5fc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419b5fe:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
3419b602:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
3419b604:	429a      	cmp	r2, r3
3419b606:	d2e4      	bcs.n	3419b5d2 <_ux_device_stack_initialize+0x2ca>
        }

        _ux_utility_memory_free(device -> ux_slave_device_endpoints_pool);
3419b608:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419b60a:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
3419b60e:	4618      	mov	r0, r3
3419b610:	f7fe fb66 	bl	34199ce0 <_ux_utility_memory_free>
    }

    /* Free device -> ux_slave_device_interfaces_pool.  */
    if (device -> ux_slave_device_interfaces_pool)
3419b614:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419b616:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
3419b61a:	2b00      	cmp	r3, #0
3419b61c:	d005      	beq.n	3419b62a <_ux_device_stack_initialize+0x322>
        _ux_utility_memory_free(device -> ux_slave_device_interfaces_pool);
3419b61e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419b620:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
3419b624:	4618      	mov	r0, r3
3419b626:	f7fe fb5b 	bl	34199ce0 <_ux_utility_memory_free>

    /* Free device -> ux_slave_device_control_endpoint.ux_slave_endpoint_transfer_request.ux_slave_transfer_request_data_pointer.  */
    if (device -> ux_slave_device_control_endpoint.ux_slave_endpoint_transfer_request.ux_slave_transfer_request_data_pointer)
3419b62a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419b62c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3419b62e:	2b00      	cmp	r3, #0
3419b630:	d004      	beq.n	3419b63c <_ux_device_stack_initialize+0x334>
        _ux_utility_memory_free(device -> ux_slave_device_control_endpoint.ux_slave_endpoint_transfer_request.ux_slave_transfer_request_data_pointer);
3419b632:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419b634:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3419b636:	4618      	mov	r0, r3
3419b638:	f7fe fb52 	bl	34199ce0 <_ux_utility_memory_free>

    /* Free _ux_system_slave -> ux_system_slave_class_array.  */
    _ux_utility_memory_free(_ux_system_slave -> ux_system_slave_class_array);
3419b63c:	4b06      	ldr	r3, [pc, #24]	@ (3419b658 <_ux_device_stack_initialize+0x350>)
3419b63e:	681b      	ldr	r3, [r3, #0]
3419b640:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
3419b644:	4618      	mov	r0, r3
3419b646:	f7fe fb4b 	bl	34199ce0 <_ux_utility_memory_free>

    /* Return completion status.  */
    return(status);
3419b64a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
}
3419b64c:	4618      	mov	r0, r3
3419b64e:	3750      	adds	r7, #80	@ 0x50
3419b650:	46bd      	mov	sp, r7
3419b652:	bd80      	pop	{r7, pc}
3419b654:	3419e314 	.word	0x3419e314
3419b658:	341c33f8 	.word	0x341c33f8

3419b65c <_ux_device_stack_interface_delete>:
/*                                            names conflict C++ keyword, */
/*                                            resulting in version 6.1.12 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_stack_interface_delete(UX_SLAVE_INTERFACE *interface_ptr)
{
3419b65c:	b580      	push	{r7, lr}
3419b65e:	b086      	sub	sp, #24
3419b660:	af00      	add	r7, sp, #0
3419b662:	6078      	str	r0, [r7, #4]

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_STACK_INTERFACE_DELETE, interface_ptr, 0, 0, 0, UX_TRACE_DEVICE_STACK_EVENTS, 0, 0)

    /* Get the pointer to the device.  */
    device =  &_ux_system_slave -> ux_system_slave_device;
3419b664:	4b20      	ldr	r3, [pc, #128]	@ (3419b6e8 <_ux_device_stack_interface_delete+0x8c>)
3419b666:	681b      	ldr	r3, [r3, #0]
3419b668:	3320      	adds	r3, #32
3419b66a:	613b      	str	r3, [r7, #16]

    /* Find the first endpoints associated with this interface.  */    
    next_endpoint =  interface_ptr -> ux_slave_interface_first_endpoint;        
3419b66c:	687b      	ldr	r3, [r7, #4]
3419b66e:	69db      	ldr	r3, [r3, #28]
3419b670:	617b      	str	r3, [r7, #20]
    
    /* Parse all the endpoints.  */    
    while (next_endpoint != UX_NULL)
3419b672:	e01c      	b.n	3419b6ae <_ux_device_stack_interface_delete+0x52>
    {

        /* Save this endpoint.  */
        endpoint =  next_endpoint;
3419b674:	697b      	ldr	r3, [r7, #20]
3419b676:	60fb      	str	r3, [r7, #12]
        
        /* Find the next endpoint.  */
        next_endpoint =  endpoint -> ux_slave_endpoint_next_endpoint;
3419b678:	68fb      	ldr	r3, [r7, #12]
3419b67a:	695b      	ldr	r3, [r3, #20]
3419b67c:	617b      	str	r3, [r7, #20]
        
        /* Get the pointer to the DCD.  */
        dcd =  &_ux_system_slave->ux_system_slave_dcd;
3419b67e:	4b1a      	ldr	r3, [pc, #104]	@ (3419b6e8 <_ux_device_stack_interface_delete+0x8c>)
3419b680:	681b      	ldr	r3, [r3, #0]
3419b682:	60bb      	str	r3, [r7, #8]

        /* The endpoint must be destroyed.  */
        dcd -> ux_slave_dcd_function(dcd, UX_DCD_DESTROY_ENDPOINT, endpoint);
3419b684:	68bb      	ldr	r3, [r7, #8]
3419b686:	699b      	ldr	r3, [r3, #24]
3419b688:	68fa      	ldr	r2, [r7, #12]
3419b68a:	210f      	movs	r1, #15
3419b68c:	68b8      	ldr	r0, [r7, #8]
3419b68e:	4798      	blx	r3

        /* Free the endpoint.  */
        endpoint -> ux_slave_endpoint_status =  UX_UNUSED;
3419b690:	68fb      	ldr	r3, [r7, #12]
3419b692:	2200      	movs	r2, #0
3419b694:	601a      	str	r2, [r3, #0]

        /* Make sure the endpoint instance is now cleaned up.  */
        endpoint -> ux_slave_endpoint_state =  0;
3419b696:	68fb      	ldr	r3, [r7, #12]
3419b698:	2200      	movs	r2, #0
3419b69a:	605a      	str	r2, [r3, #4]
        endpoint -> ux_slave_endpoint_next_endpoint =  UX_NULL;
3419b69c:	68fb      	ldr	r3, [r7, #12]
3419b69e:	2200      	movs	r2, #0
3419b6a0:	615a      	str	r2, [r3, #20]
        endpoint -> ux_slave_endpoint_interface =  UX_NULL;
3419b6a2:	68fb      	ldr	r3, [r7, #12]
3419b6a4:	2200      	movs	r2, #0
3419b6a6:	619a      	str	r2, [r3, #24]
        endpoint -> ux_slave_endpoint_device =  UX_NULL;
3419b6a8:	68fb      	ldr	r3, [r7, #12]
3419b6aa:	2200      	movs	r2, #0
3419b6ac:	61da      	str	r2, [r3, #28]
    while (next_endpoint != UX_NULL)
3419b6ae:	697b      	ldr	r3, [r7, #20]
3419b6b0:	2b00      	cmp	r3, #0
3419b6b2:	d1df      	bne.n	3419b674 <_ux_device_stack_interface_delete+0x18>
    }        

    /* It's always from first one (to delete).  */
    /* Rebuild the first link.  */
    device -> ux_slave_device_first_interface =  interface_ptr -> ux_slave_interface_next_interface;
3419b6b4:	687b      	ldr	r3, [r7, #4]
3419b6b6:	699a      	ldr	r2, [r3, #24]
3419b6b8:	693b      	ldr	r3, [r7, #16]
3419b6ba:	f8c3 20a8 	str.w	r2, [r3, #168]	@ 0xa8

    /* The interface is removed from the link, its memory must be cleaned and returned to the pool.  */
    interface_ptr -> ux_slave_interface_class          =  UX_NULL;
3419b6be:	687b      	ldr	r3, [r7, #4]
3419b6c0:	2200      	movs	r2, #0
3419b6c2:	605a      	str	r2, [r3, #4]
    interface_ptr -> ux_slave_interface_class_instance =  UX_NULL;
3419b6c4:	687b      	ldr	r3, [r7, #4]
3419b6c6:	2200      	movs	r2, #0
3419b6c8:	609a      	str	r2, [r3, #8]
    interface_ptr -> ux_slave_interface_next_interface =  UX_NULL;
3419b6ca:	687b      	ldr	r3, [r7, #4]
3419b6cc:	2200      	movs	r2, #0
3419b6ce:	619a      	str	r2, [r3, #24]
    interface_ptr -> ux_slave_interface_first_endpoint =  UX_NULL;
3419b6d0:	687b      	ldr	r3, [r7, #4]
3419b6d2:	2200      	movs	r2, #0
3419b6d4:	61da      	str	r2, [r3, #28]
    interface_ptr -> ux_slave_interface_status         =  UX_UNUSED;
3419b6d6:	687b      	ldr	r3, [r7, #4]
3419b6d8:	2200      	movs	r2, #0
3419b6da:	601a      	str	r2, [r3, #0]

    /* Return successful completion.  */    
    return(UX_SUCCESS);       
3419b6dc:	2300      	movs	r3, #0
}
3419b6de:	4618      	mov	r0, r3
3419b6e0:	3718      	adds	r7, #24
3419b6e2:	46bd      	mov	sp, r7
3419b6e4:	bd80      	pop	{r7, pc}
3419b6e6:	bf00      	nop
3419b6e8:	341c33f8 	.word	0x341c33f8

3419b6ec <_ux_device_stack_interface_set>:
/*                                            resulting in version 6.1.12 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_stack_interface_set(UCHAR * device_framework, ULONG device_framework_length,
                                                    ULONG alternate_setting_value)
{
3419b6ec:	b580      	push	{r7, lr}
3419b6ee:	b092      	sub	sp, #72	@ 0x48
3419b6f0:	af00      	add	r7, sp, #0
3419b6f2:	60f8      	str	r0, [r7, #12]
3419b6f4:	60b9      	str	r1, [r7, #8]
3419b6f6:	607a      	str	r2, [r7, #4]

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_STACK_INTERFACE_SET, alternate_setting_value, 0, 0, 0, UX_TRACE_DEVICE_STACK_EVENTS, 0, 0)

    /* Get the pointer to the DCD.  */
    dcd =  &_ux_system_slave -> ux_system_slave_dcd;
3419b6f8:	4b82      	ldr	r3, [pc, #520]	@ (3419b904 <_ux_device_stack_interface_set+0x218>)
3419b6fa:	681b      	ldr	r3, [r3, #0]
3419b6fc:	62bb      	str	r3, [r7, #40]	@ 0x28

    /* Get the pointer to the device.  */
    device =  &_ux_system_slave -> ux_system_slave_device;
3419b6fe:	4b81      	ldr	r3, [pc, #516]	@ (3419b904 <_ux_device_stack_interface_set+0x218>)
3419b700:	681b      	ldr	r3, [r3, #0]
3419b702:	3320      	adds	r3, #32
3419b704:	627b      	str	r3, [r7, #36]	@ 0x24

    /* Find a free interface in the pool and hook it to the 
       existing interface.  */
    interface_ptr = device -> ux_slave_device_interfaces_pool;
3419b706:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419b708:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
3419b70c:	647b      	str	r3, [r7, #68]	@ 0x44

#if !defined(UX_DEVICE_INITIALIZE_FRAMEWORK_SCAN_DISABLE) || UX_MAX_DEVICE_INTERFACES > 1
    interfaces_pool_number = device -> ux_slave_device_interfaces_pool_number;
3419b70e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419b710:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
3419b714:	63fb      	str	r3, [r7, #60]	@ 0x3c
    while (interfaces_pool_number != 0)
3419b716:	e009      	b.n	3419b72c <_ux_device_stack_interface_set+0x40>
    {
        /* Check if this interface is free.  */
        if (interface_ptr -> ux_slave_interface_status == UX_UNUSED)
3419b718:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3419b71a:	681b      	ldr	r3, [r3, #0]
3419b71c:	2b00      	cmp	r3, #0
3419b71e:	d009      	beq.n	3419b734 <_ux_device_stack_interface_set+0x48>
            break;
    
        /* Try the next interface.  */
        interface_ptr++;
3419b720:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3419b722:	3320      	adds	r3, #32
3419b724:	647b      	str	r3, [r7, #68]	@ 0x44
        
        /* Decrement the number of interfaces left to scan in the pool.  */
        interfaces_pool_number--;
3419b726:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3419b728:	3b01      	subs	r3, #1
3419b72a:	63fb      	str	r3, [r7, #60]	@ 0x3c
    while (interfaces_pool_number != 0)
3419b72c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3419b72e:	2b00      	cmp	r3, #0
3419b730:	d1f2      	bne.n	3419b718 <_ux_device_stack_interface_set+0x2c>
3419b732:	e000      	b.n	3419b736 <_ux_device_stack_interface_set+0x4a>
            break;
3419b734:	bf00      	nop
    }

    /* Did we find a free interface ?  */
    if (interfaces_pool_number == 0)
3419b736:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3419b738:	2b00      	cmp	r3, #0
3419b73a:	d101      	bne.n	3419b740 <_ux_device_stack_interface_set+0x54>
        return(UX_MEMORY_INSUFFICIENT);
3419b73c:	2312      	movs	r3, #18
3419b73e:	e0dd      	b.n	3419b8fc <_ux_device_stack_interface_set+0x210>
        return(UX_MEMORY_INSUFFICIENT);
    
#endif

    /* Mark this interface as used now.  */
    interface_ptr -> ux_slave_interface_status = UX_USED;
3419b740:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3419b742:	2201      	movs	r2, #1
3419b744:	601a      	str	r2, [r3, #0]

    /* Parse the descriptor in something more readable.  */
    _ux_utility_descriptor_parse(device_framework,
                _ux_system_interface_descriptor_structure,
                UX_INTERFACE_DESCRIPTOR_ENTRIES,
                (UCHAR *) &interface_ptr -> ux_slave_interface_descriptor);
3419b746:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3419b748:	330c      	adds	r3, #12
    _ux_utility_descriptor_parse(device_framework,
3419b74a:	2209      	movs	r2, #9
3419b74c:	496e      	ldr	r1, [pc, #440]	@ (3419b908 <_ux_device_stack_interface_set+0x21c>)
3419b74e:	68f8      	ldr	r0, [r7, #12]
3419b750:	f7fd ffb0 	bl	341996b4 <_ux_utility_descriptor_parse>

#if !defined(UX_DEVICE_INITIALIZE_FRAMEWORK_SCAN_DISABLE) || UX_MAX_DEVICE_INTERFACES > 1

    /* Attach this interface to the end of the interface chain.  */
    if (device -> ux_slave_device_first_interface == UX_NULL)
3419b754:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419b756:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
3419b75a:	2b00      	cmp	r3, #0
3419b75c:	d104      	bne.n	3419b768 <_ux_device_stack_interface_set+0x7c>
    {

        device -> ux_slave_device_first_interface =  interface_ptr;
3419b75e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419b760:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
3419b762:	f8c3 20a8 	str.w	r2, [r3, #168]	@ 0xa8
3419b766:	e00e      	b.n	3419b786 <_ux_device_stack_interface_set+0x9a>
    }
    else
    {
        /* Multiple interfaces exist, so find the end of the chain.  */
        interface_link =  device -> ux_slave_device_first_interface;
3419b768:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419b76a:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
3419b76e:	643b      	str	r3, [r7, #64]	@ 0x40
        while (interface_link -> ux_slave_interface_next_interface != UX_NULL)
3419b770:	e002      	b.n	3419b778 <_ux_device_stack_interface_set+0x8c>
            interface_link =  interface_link -> ux_slave_interface_next_interface;
3419b772:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419b774:	699b      	ldr	r3, [r3, #24]
3419b776:	643b      	str	r3, [r7, #64]	@ 0x40
        while (interface_link -> ux_slave_interface_next_interface != UX_NULL)
3419b778:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419b77a:	699b      	ldr	r3, [r3, #24]
3419b77c:	2b00      	cmp	r3, #0
3419b77e:	d1f8      	bne.n	3419b772 <_ux_device_stack_interface_set+0x86>
        interface_link -> ux_slave_interface_next_interface =  interface_ptr;
3419b780:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419b782:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
3419b784:	619a      	str	r2, [r3, #24]
    /* It must be very first one.  */
    device -> ux_slave_device_first_interface = interface_ptr;
#endif

    /* Point beyond the interface descriptor.  */
    device_framework_length -=  (ULONG) *device_framework;
3419b786:	68fb      	ldr	r3, [r7, #12]
3419b788:	781b      	ldrb	r3, [r3, #0]
3419b78a:	461a      	mov	r2, r3
3419b78c:	68bb      	ldr	r3, [r7, #8]
3419b78e:	1a9b      	subs	r3, r3, r2
3419b790:	60bb      	str	r3, [r7, #8]
    device_framework +=  (ULONG) *device_framework;
3419b792:	68fb      	ldr	r3, [r7, #12]
3419b794:	781b      	ldrb	r3, [r3, #0]
3419b796:	461a      	mov	r2, r3
3419b798:	68fb      	ldr	r3, [r7, #12]
3419b79a:	4413      	add	r3, r2
3419b79c:	60fb      	str	r3, [r7, #12]

    /* Parse the device framework and locate endpoint descriptor(s).  */
    while (device_framework_length != 0)
3419b79e:	e0a4      	b.n	3419b8ea <_ux_device_stack_interface_set+0x1fe>
    {

        /* Get the length of the current descriptor.  */
        descriptor_length =  (ULONG) *device_framework;
3419b7a0:	68fb      	ldr	r3, [r7, #12]
3419b7a2:	781b      	ldrb	r3, [r3, #0]
3419b7a4:	61fb      	str	r3, [r7, #28]

        /* And its type.  */
        descriptor_type =  *(device_framework + 1);
3419b7a6:	68fb      	ldr	r3, [r7, #12]
3419b7a8:	785b      	ldrb	r3, [r3, #1]
3419b7aa:	76fb      	strb	r3, [r7, #27]
                
        /* Check if this is an endpoint descriptor.  */
        switch(descriptor_type)
3419b7ac:	7efb      	ldrb	r3, [r7, #27]
3419b7ae:	2b05      	cmp	r3, #5
3419b7b0:	d009      	beq.n	3419b7c6 <_ux_device_stack_interface_set+0xda>
3419b7b2:	2b05      	cmp	r3, #5
3419b7b4:	f300 8090 	bgt.w	3419b8d8 <_ux_device_stack_interface_set+0x1ec>
3419b7b8:	2b02      	cmp	r3, #2
3419b7ba:	f000 8087 	beq.w	3419b8cc <_ux_device_stack_interface_set+0x1e0>
3419b7be:	2b04      	cmp	r3, #4
3419b7c0:	f000 8084 	beq.w	3419b8cc <_ux_device_stack_interface_set+0x1e0>

            /* Return the status to the caller.  */
            return(status);

        default:
            break;
3419b7c4:	e088      	b.n	3419b8d8 <_ux_device_stack_interface_set+0x1ec>
            endpoint = device -> ux_slave_device_endpoints_pool;
3419b7c6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419b7c8:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
3419b7cc:	63bb      	str	r3, [r7, #56]	@ 0x38
            endpoints_pool_number = device -> ux_slave_device_endpoints_pool_number;
3419b7ce:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419b7d0:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3419b7d4:	633b      	str	r3, [r7, #48]	@ 0x30
            while (endpoints_pool_number != 0)
3419b7d6:	e00d      	b.n	3419b7f4 <_ux_device_stack_interface_set+0x108>
                if (endpoint ->    ux_slave_endpoint_status == UX_UNUSED)
3419b7d8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419b7da:	681b      	ldr	r3, [r3, #0]
3419b7dc:	2b00      	cmp	r3, #0
3419b7de:	d103      	bne.n	3419b7e8 <_ux_device_stack_interface_set+0xfc>
                    endpoint ->    ux_slave_endpoint_status = UX_USED;
3419b7e0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419b7e2:	2201      	movs	r2, #1
3419b7e4:	601a      	str	r2, [r3, #0]
                    break;
3419b7e6:	e008      	b.n	3419b7fa <_ux_device_stack_interface_set+0x10e>
                endpoint++;
3419b7e8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419b7ea:	3380      	adds	r3, #128	@ 0x80
3419b7ec:	63bb      	str	r3, [r7, #56]	@ 0x38
               endpoints_pool_number--; 
3419b7ee:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3419b7f0:	3b01      	subs	r3, #1
3419b7f2:	633b      	str	r3, [r7, #48]	@ 0x30
            while (endpoints_pool_number != 0)
3419b7f4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3419b7f6:	2b00      	cmp	r3, #0
3419b7f8:	d1ee      	bne.n	3419b7d8 <_ux_device_stack_interface_set+0xec>
            if (endpoints_pool_number == 0)
3419b7fa:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3419b7fc:	2b00      	cmp	r3, #0
3419b7fe:	d101      	bne.n	3419b804 <_ux_device_stack_interface_set+0x118>
                return(UX_MEMORY_INSUFFICIENT);
3419b800:	2312      	movs	r3, #18
3419b802:	e07b      	b.n	3419b8fc <_ux_device_stack_interface_set+0x210>
                            (UCHAR *) &endpoint -> ux_slave_endpoint_descriptor);
3419b804:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419b806:	330c      	adds	r3, #12
            _ux_utility_descriptor_parse(device_framework,
3419b808:	2206      	movs	r2, #6
3419b80a:	4940      	ldr	r1, [pc, #256]	@ (3419b90c <_ux_device_stack_interface_set+0x220>)
3419b80c:	68f8      	ldr	r0, [r7, #12]
3419b80e:	f7fd ff51 	bl	341996b4 <_ux_utility_descriptor_parse>
            transfer_request =  &endpoint -> ux_slave_endpoint_transfer_request;
3419b812:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419b814:	3320      	adds	r3, #32
3419b816:	617b      	str	r3, [r7, #20]
                    endpoint -> ux_slave_endpoint_descriptor.wMaxPacketSize &
3419b818:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419b81a:	8a1b      	ldrh	r3, [r3, #16]
            max_transfer_length =
3419b81c:	f3c3 030a 	ubfx	r3, r3, #0, #11
3419b820:	62fb      	str	r3, [r7, #44]	@ 0x2c
            if ((_ux_system_slave -> ux_system_slave_speed == UX_HIGH_SPEED_DEVICE) &&
3419b822:	4b38      	ldr	r3, [pc, #224]	@ (3419b904 <_ux_device_stack_interface_set+0x218>)
3419b824:	681b      	ldr	r3, [r3, #0]
3419b826:	f8d3 3154 	ldr.w	r3, [r3, #340]	@ 0x154
3419b82a:	2b02      	cmp	r3, #2
3419b82c:	d118      	bne.n	3419b860 <_ux_device_stack_interface_set+0x174>
                (endpoint -> ux_slave_endpoint_descriptor.bmAttributes & 0x1u))
3419b82e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419b830:	7bdb      	ldrb	r3, [r3, #15]
3419b832:	f003 0301 	and.w	r3, r3, #1
            if ((_ux_system_slave -> ux_system_slave_speed == UX_HIGH_SPEED_DEVICE) &&
3419b836:	2b00      	cmp	r3, #0
3419b838:	d012      	beq.n	3419b860 <_ux_device_stack_interface_set+0x174>
                n_trans = endpoint -> ux_slave_endpoint_descriptor.wMaxPacketSize &
3419b83a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419b83c:	8a1b      	ldrh	r3, [r3, #16]
3419b83e:	f403 53c0 	and.w	r3, r3, #6144	@ 0x1800
3419b842:	613b      	str	r3, [r7, #16]
                if (n_trans)
3419b844:	693b      	ldr	r3, [r7, #16]
3419b846:	2b00      	cmp	r3, #0
3419b848:	d00a      	beq.n	3419b860 <_ux_device_stack_interface_set+0x174>
                    n_trans >>= UX_MAX_NUMBER_OF_TRANSACTIONS_SHIFT;
3419b84a:	693b      	ldr	r3, [r7, #16]
3419b84c:	0adb      	lsrs	r3, r3, #11
3419b84e:	613b      	str	r3, [r7, #16]
                    n_trans ++;
3419b850:	693b      	ldr	r3, [r7, #16]
3419b852:	3301      	adds	r3, #1
3419b854:	613b      	str	r3, [r7, #16]
                    max_transfer_length *= n_trans;
3419b856:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3419b858:	693a      	ldr	r2, [r7, #16]
3419b85a:	fb02 f303 	mul.w	r3, r2, r3
3419b85e:	62fb      	str	r3, [r7, #44]	@ 0x2c
            transfer_request -> ux_slave_transfer_request_transfer_length = max_transfer_length;
3419b860:	697b      	ldr	r3, [r7, #20]
3419b862:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
3419b864:	621a      	str	r2, [r3, #32]
            transfer_request -> ux_slave_transfer_request_endpoint =  endpoint;
3419b866:	697b      	ldr	r3, [r7, #20]
3419b868:	6bba      	ldr	r2, [r7, #56]	@ 0x38
3419b86a:	609a      	str	r2, [r3, #8]
            transfer_request -> ux_slave_transfer_request_timeout = UX_WAIT_FOREVER;
3419b86c:	697b      	ldr	r3, [r7, #20]
3419b86e:	f04f 32ff 	mov.w	r2, #4294967295
3419b872:	64da      	str	r2, [r3, #76]	@ 0x4c
            endpoint -> ux_slave_endpoint_interface =  interface_ptr;
3419b874:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419b876:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
3419b878:	619a      	str	r2, [r3, #24]
            endpoint -> ux_slave_endpoint_device =  device;
3419b87a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419b87c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
3419b87e:	61da      	str	r2, [r3, #28]
            status =  dcd -> ux_slave_dcd_function(dcd, UX_DCD_CREATE_ENDPOINT, (VOID *) endpoint); 
3419b880:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419b882:	699b      	ldr	r3, [r3, #24]
3419b884:	6bba      	ldr	r2, [r7, #56]	@ 0x38
3419b886:	210e      	movs	r1, #14
3419b888:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
3419b88a:	4798      	blx	r3
3419b88c:	6238      	str	r0, [r7, #32]
            if (status != UX_SUCCESS)
3419b88e:	6a3b      	ldr	r3, [r7, #32]
3419b890:	2b00      	cmp	r3, #0
3419b892:	d004      	beq.n	3419b89e <_ux_device_stack_interface_set+0x1b2>
                endpoint -> ux_slave_endpoint_status = UX_UNUSED;
3419b894:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419b896:	2200      	movs	r2, #0
3419b898:	601a      	str	r2, [r3, #0]
                return(status);
3419b89a:	6a3b      	ldr	r3, [r7, #32]
3419b89c:	e02e      	b.n	3419b8fc <_ux_device_stack_interface_set+0x210>
            if (interface_ptr -> ux_slave_interface_first_endpoint == UX_NULL)
3419b89e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3419b8a0:	69db      	ldr	r3, [r3, #28]
3419b8a2:	2b00      	cmp	r3, #0
3419b8a4:	d103      	bne.n	3419b8ae <_ux_device_stack_interface_set+0x1c2>
                interface_ptr -> ux_slave_interface_first_endpoint =  endpoint;
3419b8a6:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3419b8a8:	6bba      	ldr	r2, [r7, #56]	@ 0x38
3419b8aa:	61da      	str	r2, [r3, #28]
            break;
3419b8ac:	e015      	b.n	3419b8da <_ux_device_stack_interface_set+0x1ee>
                endpoint_link =  interface_ptr -> ux_slave_interface_first_endpoint;
3419b8ae:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3419b8b0:	69db      	ldr	r3, [r3, #28]
3419b8b2:	637b      	str	r3, [r7, #52]	@ 0x34
                while (endpoint_link -> ux_slave_endpoint_next_endpoint != UX_NULL)
3419b8b4:	e002      	b.n	3419b8bc <_ux_device_stack_interface_set+0x1d0>
                    endpoint_link =  endpoint_link -> ux_slave_endpoint_next_endpoint;
3419b8b6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
3419b8b8:	695b      	ldr	r3, [r3, #20]
3419b8ba:	637b      	str	r3, [r7, #52]	@ 0x34
                while (endpoint_link -> ux_slave_endpoint_next_endpoint != UX_NULL)
3419b8bc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
3419b8be:	695b      	ldr	r3, [r3, #20]
3419b8c0:	2b00      	cmp	r3, #0
3419b8c2:	d1f8      	bne.n	3419b8b6 <_ux_device_stack_interface_set+0x1ca>
                endpoint_link -> ux_slave_endpoint_next_endpoint =  endpoint;
3419b8c4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
3419b8c6:	6bba      	ldr	r2, [r7, #56]	@ 0x38
3419b8c8:	615a      	str	r2, [r3, #20]
            break;
3419b8ca:	e006      	b.n	3419b8da <_ux_device_stack_interface_set+0x1ee>
            status =  _ux_device_stack_interface_start(interface_ptr);
3419b8cc:	6c78      	ldr	r0, [r7, #68]	@ 0x44
3419b8ce:	f000 f81f 	bl	3419b910 <_ux_device_stack_interface_start>
3419b8d2:	6238      	str	r0, [r7, #32]
            return(status);
3419b8d4:	6a3b      	ldr	r3, [r7, #32]
3419b8d6:	e011      	b.n	3419b8fc <_ux_device_stack_interface_set+0x210>
            break;
3419b8d8:	bf00      	nop
        }

        /* Adjust what is left of the device framework.  */
        device_framework_length -=  descriptor_length;
3419b8da:	68ba      	ldr	r2, [r7, #8]
3419b8dc:	69fb      	ldr	r3, [r7, #28]
3419b8de:	1ad3      	subs	r3, r2, r3
3419b8e0:	60bb      	str	r3, [r7, #8]

        /* Point to the next descriptor.  */
        device_framework +=  descriptor_length;
3419b8e2:	68fa      	ldr	r2, [r7, #12]
3419b8e4:	69fb      	ldr	r3, [r7, #28]
3419b8e6:	4413      	add	r3, r2
3419b8e8:	60fb      	str	r3, [r7, #12]
    while (device_framework_length != 0)
3419b8ea:	68bb      	ldr	r3, [r7, #8]
3419b8ec:	2b00      	cmp	r3, #0
3419b8ee:	f47f af57 	bne.w	3419b7a0 <_ux_device_stack_interface_set+0xb4>
    }

    /* The interface attached to this configuration must be started at the class
       level.  */
    status =  _ux_device_stack_interface_start(interface_ptr);
3419b8f2:	6c78      	ldr	r0, [r7, #68]	@ 0x44
3419b8f4:	f000 f80c 	bl	3419b910 <_ux_device_stack_interface_start>
3419b8f8:	6238      	str	r0, [r7, #32]

    /* Return the status to the caller.  */
    return(status);
3419b8fa:	6a3b      	ldr	r3, [r7, #32]
}
3419b8fc:	4618      	mov	r0, r3
3419b8fe:	3748      	adds	r7, #72	@ 0x48
3419b900:	46bd      	mov	sp, r7
3419b902:	bd80      	pop	{r7, pc}
3419b904:	341c33f8 	.word	0x341c33f8
3419b908:	341c00c0 	.word	0x341c00c0
3419b90c:	341c00a0 	.word	0x341c00a0

3419b910 <_ux_device_stack_interface_start>:
/*                                            names conflict C++ keyword, */
/*                                            resulting in version 6.1.12 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_stack_interface_start(UX_SLAVE_INTERFACE *interface_ptr)
{
3419b910:	b580      	push	{r7, lr}
3419b912:	b090      	sub	sp, #64	@ 0x40
3419b914:	af00      	add	r7, sp, #0
3419b916:	6078      	str	r0, [r7, #4]
UINT                        status;
UX_SLAVE_CLASS_COMMAND      class_command;


    /* Get the class for the interface.  */
    class_ptr =  _ux_system_slave -> ux_system_slave_interface_class_array[interface_ptr -> ux_slave_interface_descriptor.bInterfaceNumber];
3419b918:	4b25      	ldr	r3, [pc, #148]	@ (3419b9b0 <_ux_device_stack_interface_start+0xa0>)
3419b91a:	681a      	ldr	r2, [r3, #0]
3419b91c:	687b      	ldr	r3, [r7, #4]
3419b91e:	7b9b      	ldrb	r3, [r3, #14]
3419b920:	3344      	adds	r3, #68	@ 0x44
3419b922:	009b      	lsls	r3, r3, #2
3419b924:	4413      	add	r3, r2
3419b926:	685b      	ldr	r3, [r3, #4]
3419b928:	63fb      	str	r3, [r7, #60]	@ 0x3c

    /* Check if class driver is available. */
    if (class_ptr == UX_NULL)
3419b92a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3419b92c:	2b00      	cmp	r3, #0
3419b92e:	d101      	bne.n	3419b934 <_ux_device_stack_interface_start+0x24>

        /* There is no class driver supported. */
        return (UX_NO_CLASS_MATCH);
3419b930:	2357      	movs	r3, #87	@ 0x57
3419b932:	e038      	b.n	3419b9a6 <_ux_device_stack_interface_start+0x96>

    /* Get the pointer to the device.  */
    device =  &_ux_system_slave -> ux_system_slave_device;
3419b934:	4b1e      	ldr	r3, [pc, #120]	@ (3419b9b0 <_ux_device_stack_interface_start+0xa0>)
3419b936:	681b      	ldr	r3, [r3, #0]
3419b938:	3320      	adds	r3, #32
3419b93a:	63bb      	str	r3, [r7, #56]	@ 0x38

    /* Build all the fields of the Class Command.  */
    class_command.ux_slave_class_command_request   =    UX_SLAVE_CLASS_COMMAND_QUERY;
3419b93c:	2301      	movs	r3, #1
3419b93e:	60bb      	str	r3, [r7, #8]
    class_command.ux_slave_class_command_interface =   (VOID *)interface_ptr;
3419b940:	687b      	ldr	r3, [r7, #4]
3419b942:	613b      	str	r3, [r7, #16]
    class_command.ux_slave_class_command_class     =   interface_ptr -> ux_slave_interface_descriptor.bInterfaceClass;
3419b944:	687b      	ldr	r3, [r7, #4]
3419b946:	7c5b      	ldrb	r3, [r3, #17]
3419b948:	61fb      	str	r3, [r7, #28]
    class_command.ux_slave_class_command_subclass  =   interface_ptr -> ux_slave_interface_descriptor.bInterfaceSubClass;
3419b94a:	687b      	ldr	r3, [r7, #4]
3419b94c:	7c9b      	ldrb	r3, [r3, #18]
3419b94e:	623b      	str	r3, [r7, #32]
    class_command.ux_slave_class_command_protocol  =   interface_ptr -> ux_slave_interface_descriptor.bInterfaceProtocol;
3419b950:	687b      	ldr	r3, [r7, #4]
3419b952:	7cdb      	ldrb	r3, [r3, #19]
3419b954:	627b      	str	r3, [r7, #36]	@ 0x24
    class_command.ux_slave_class_command_vid       =   device -> ux_slave_device_descriptor.idVendor;
3419b956:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419b958:	899b      	ldrh	r3, [r3, #12]
3419b95a:	61bb      	str	r3, [r7, #24]
    class_command.ux_slave_class_command_pid       =   device -> ux_slave_device_descriptor.idProduct;
3419b95c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419b95e:	89db      	ldrh	r3, [r3, #14]
3419b960:	617b      	str	r3, [r7, #20]

    /* We can now memorize the interface pointer associated with this class.  */
    class_ptr -> ux_slave_class_interface = interface_ptr;
3419b962:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3419b964:	687a      	ldr	r2, [r7, #4]
3419b966:	f8c3 2110 	str.w	r2, [r3, #272]	@ 0x110
    
    /* We have found a potential candidate. Call this registered class entry function.  */
    status = class_ptr -> ux_slave_class_entry_function(&class_command);
3419b96a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3419b96c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3419b96e:	f107 0208 	add.w	r2, r7, #8
3419b972:	4610      	mov	r0, r2
3419b974:	4798      	blx	r3
3419b976:	6378      	str	r0, [r7, #52]	@ 0x34

    /* The status tells us if the registered class wants to own this class.  */
    if (status == UX_SUCCESS)
3419b978:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
3419b97a:	2b00      	cmp	r3, #0
3419b97c:	d112      	bne.n	3419b9a4 <_ux_device_stack_interface_start+0x94>
    {

        /* Store the class container. */
        class_command.ux_slave_class_command_class_ptr =  class_ptr;
3419b97e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3419b980:	62bb      	str	r3, [r7, #40]	@ 0x28
        
        /* Store the command.  */
        class_command.ux_slave_class_command_request =  UX_SLAVE_CLASS_COMMAND_ACTIVATE;
3419b982:	2302      	movs	r3, #2
3419b984:	60bb      	str	r3, [r7, #8]
        
        /* Activate the class.  */
        status = class_ptr -> ux_slave_class_entry_function(&class_command);
3419b986:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3419b988:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3419b98a:	f107 0208 	add.w	r2, r7, #8
3419b98e:	4610      	mov	r0, r2
3419b990:	4798      	blx	r3
3419b992:	6378      	str	r0, [r7, #52]	@ 0x34

        /* If the class was successfully activated, set the class for the interface.  */
        if(status == UX_SUCCESS)
3419b994:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
3419b996:	2b00      	cmp	r3, #0
3419b998:	d102      	bne.n	3419b9a0 <_ux_device_stack_interface_start+0x90>
            interface_ptr -> ux_slave_interface_class =  class_ptr;
3419b99a:	687b      	ldr	r3, [r7, #4]
3419b99c:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
3419b99e:	605a      	str	r2, [r3, #4]

        return(status); 
3419b9a0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
3419b9a2:	e000      	b.n	3419b9a6 <_ux_device_stack_interface_start+0x96>
    }

    /* There is no driver who want to own this class!  */
    return(UX_NO_CLASS_MATCH);
3419b9a4:	2357      	movs	r3, #87	@ 0x57
}
3419b9a6:	4618      	mov	r0, r3
3419b9a8:	3740      	adds	r7, #64	@ 0x40
3419b9aa:	46bd      	mov	sp, r7
3419b9ac:	bd80      	pop	{r7, pc}
3419b9ae:	bf00      	nop
3419b9b0:	341c33f8 	.word	0x341c33f8

3419b9b4 <_ux_device_stack_set_feature>:
/*                                            names conflict C++ keyword, */
/*                                            resulting in version 6.1.12 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_stack_set_feature(ULONG request_type, ULONG request_value, ULONG request_index)
{
3419b9b4:	b580      	push	{r7, lr}
3419b9b6:	b08a      	sub	sp, #40	@ 0x28
3419b9b8:	af00      	add	r7, sp, #0
3419b9ba:	60f8      	str	r0, [r7, #12]
3419b9bc:	60b9      	str	r1, [r7, #8]
3419b9be:	607a      	str	r2, [r7, #4]

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_STACK_SET_FEATURE, request_value, request_index, 0, 0, UX_TRACE_DEVICE_STACK_EVENTS, 0, 0)

    /* Get the pointer to the DCD.  */
    dcd =  &_ux_system_slave -> ux_system_slave_dcd;
3419b9c0:	4b29      	ldr	r3, [pc, #164]	@ (3419ba68 <_ux_device_stack_set_feature+0xb4>)
3419b9c2:	681b      	ldr	r3, [r3, #0]
3419b9c4:	61fb      	str	r3, [r7, #28]

    /* Get the pointer to the device.  */
    device =  &_ux_system_slave -> ux_system_slave_device;
3419b9c6:	4b28      	ldr	r3, [pc, #160]	@ (3419ba68 <_ux_device_stack_set_feature+0xb4>)
3419b9c8:	681b      	ldr	r3, [r3, #0]
3419b9ca:	3320      	adds	r3, #32
3419b9cc:	61bb      	str	r3, [r7, #24]

    /* Get the control endpoint for the device.  */
    endpoint =  &device -> ux_slave_device_control_endpoint;
3419b9ce:	69bb      	ldr	r3, [r7, #24]
3419b9d0:	3318      	adds	r3, #24
3419b9d2:	617b      	str	r3, [r7, #20]

    /* The feature can be for either the device or the endpoint.  */
    switch (request_type & UX_REQUEST_TARGET)
3419b9d4:	68fb      	ldr	r3, [r7, #12]
3419b9d6:	f003 0303 	and.w	r3, r3, #3
3419b9da:	2b00      	cmp	r3, #0
3419b9dc:	d002      	beq.n	3419b9e4 <_ux_device_stack_set_feature+0x30>
3419b9de:	2b02      	cmp	r3, #2
3419b9e0:	d014      	beq.n	3419ba0c <_ux_device_stack_set_feature+0x58>
3419b9e2:	e036      	b.n	3419ba52 <_ux_device_stack_set_feature+0x9e>
    {
    
    case UX_REQUEST_TARGET_DEVICE:

        /* Check if we have a DEVICE_REMOTE_WAKEUP Feature.  */
        if (request_value == UX_REQUEST_FEATURE_DEVICE_REMOTE_WAKEUP)
3419b9e4:	68bb      	ldr	r3, [r7, #8]
3419b9e6:	2b01      	cmp	r3, #1
3419b9e8:	d10e      	bne.n	3419ba08 <_ux_device_stack_set_feature+0x54>
        {

            /* Check if we have the capability. */
            if (_ux_system_slave -> ux_system_slave_remote_wakeup_capability)
3419b9ea:	4b1f      	ldr	r3, [pc, #124]	@ (3419ba68 <_ux_device_stack_set_feature+0xb4>)
3419b9ec:	681b      	ldr	r3, [r3, #0]
3419b9ee:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
3419b9f2:	2b00      	cmp	r3, #0
3419b9f4:	d006      	beq.n	3419ba04 <_ux_device_stack_set_feature+0x50>
            {

                /* Enable the feature. */
                _ux_system_slave -> ux_system_slave_remote_wakeup_enabled = UX_TRUE;
3419b9f6:	4b1c      	ldr	r3, [pc, #112]	@ (3419ba68 <_ux_device_stack_set_feature+0xb4>)
3419b9f8:	681b      	ldr	r3, [r3, #0]
3419b9fa:	2201      	movs	r2, #1
3419b9fc:	f8c3 2160 	str.w	r2, [r3, #352]	@ 0x160

                /* OK. */
                return (UX_SUCCESS);
3419ba00:	2300      	movs	r3, #0
3419ba02:	e02d      	b.n	3419ba60 <_ux_device_stack_set_feature+0xac>
            }
            else

                /* Protocol error. */
                return (UX_FUNCTION_NOT_SUPPORTED);
3419ba04:	2354      	movs	r3, #84	@ 0x54
3419ba06:	e02b      	b.n	3419ba60 <_ux_device_stack_set_feature+0xac>
            return(UX_SUCCESS);
        }
#endif

        /* Request value not supported.  */
        return(UX_FUNCTION_NOT_SUPPORTED);
3419ba08:	2354      	movs	r3, #84	@ 0x54
3419ba0a:	e029      	b.n	3419ba60 <_ux_device_stack_set_feature+0xac>
    case UX_REQUEST_TARGET_ENDPOINT:

        /* The only set feature for endpoint is ENDPOINT_STALL. This forces
           the endpoint to the stall situation.
           We need to find the endpoint through the interface(s). */
        interface_ptr =  device -> ux_slave_device_first_interface;
3419ba0c:	69bb      	ldr	r3, [r7, #24]
3419ba0e:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
3419ba12:	627b      	str	r3, [r7, #36]	@ 0x24

#if !defined(UX_DEVICE_INITIALIZE_FRAMEWORK_SCAN_DISABLE) || UX_MAX_DEVICE_INTERFACES > 1
        while (interface_ptr != UX_NULL)
3419ba14:	e01a      	b.n	3419ba4c <_ux_device_stack_set_feature+0x98>
        {
#endif
            /* Get the first endpoint for this interface.  */
            endpoint_target =  interface_ptr -> ux_slave_interface_first_endpoint;
3419ba16:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419ba18:	69db      	ldr	r3, [r3, #28]
3419ba1a:	623b      	str	r3, [r7, #32]
                
            /* Parse all the endpoints.  */
            while (endpoint_target != UX_NULL)
3419ba1c:	e010      	b.n	3419ba40 <_ux_device_stack_set_feature+0x8c>
            {

                /* Check the endpoint index.  */
                if (endpoint_target -> ux_slave_endpoint_descriptor.bEndpointAddress == request_index)
3419ba1e:	6a3b      	ldr	r3, [r7, #32]
3419ba20:	7b9b      	ldrb	r3, [r3, #14]
3419ba22:	461a      	mov	r2, r3
3419ba24:	687b      	ldr	r3, [r7, #4]
3419ba26:	4293      	cmp	r3, r2
3419ba28:	d107      	bne.n	3419ba3a <_ux_device_stack_set_feature+0x86>
                {

                    /* Stall the endpoint.  */
                    dcd -> ux_slave_dcd_function(dcd, UX_DCD_STALL_ENDPOINT, endpoint_target);
3419ba2a:	69fb      	ldr	r3, [r7, #28]
3419ba2c:	699b      	ldr	r3, [r3, #24]
3419ba2e:	6a3a      	ldr	r2, [r7, #32]
3419ba30:	2114      	movs	r1, #20
3419ba32:	69f8      	ldr	r0, [r7, #28]
3419ba34:	4798      	blx	r3

                    /* Return the function status.  */
                    return(UX_SUCCESS);
3419ba36:	2300      	movs	r3, #0
3419ba38:	e012      	b.n	3419ba60 <_ux_device_stack_set_feature+0xac>
                }

                /* Next endpoint.  */
                endpoint_target =  endpoint_target -> ux_slave_endpoint_next_endpoint;
3419ba3a:	6a3b      	ldr	r3, [r7, #32]
3419ba3c:	695b      	ldr	r3, [r3, #20]
3419ba3e:	623b      	str	r3, [r7, #32]
            while (endpoint_target != UX_NULL)
3419ba40:	6a3b      	ldr	r3, [r7, #32]
3419ba42:	2b00      	cmp	r3, #0
3419ba44:	d1eb      	bne.n	3419ba1e <_ux_device_stack_set_feature+0x6a>
            }

#if !defined(UX_DEVICE_INITIALIZE_FRAMEWORK_SCAN_DISABLE) || UX_MAX_DEVICE_INTERFACES > 1
            /* Next interface.  */
            interface_ptr =  interface_ptr -> ux_slave_interface_next_interface;
3419ba46:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419ba48:	699b      	ldr	r3, [r3, #24]
3419ba4a:	627b      	str	r3, [r7, #36]	@ 0x24
        while (interface_ptr != UX_NULL)
3419ba4c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419ba4e:	2b00      	cmp	r3, #0
3419ba50:	d1e1      	bne.n	3419ba16 <_ux_device_stack_set_feature+0x62>
        /* Intentionally fall through into the default case. */
        /* fall through */
    default:
        
        /* We stall the command.  */
        dcd -> ux_slave_dcd_function(dcd, UX_DCD_STALL_ENDPOINT, endpoint);
3419ba52:	69fb      	ldr	r3, [r7, #28]
3419ba54:	699b      	ldr	r3, [r3, #24]
3419ba56:	697a      	ldr	r2, [r7, #20]
3419ba58:	2114      	movs	r1, #20
3419ba5a:	69f8      	ldr	r0, [r7, #28]
3419ba5c:	4798      	blx	r3
    
        /* No more work to do here.  The command failed but the upper layer does not depend on it.  */
        return(UX_SUCCESS);            
3419ba5e:	2300      	movs	r3, #0
    }
}
3419ba60:	4618      	mov	r0, r3
3419ba62:	3728      	adds	r7, #40	@ 0x28
3419ba64:	46bd      	mov	sp, r7
3419ba66:	bd80      	pop	{r7, pc}
3419ba68:	341c33f8 	.word	0x341c33f8

3419ba6c <_ux_device_stack_transfer_abort>:
/*                                            assigned aborting code,     */
/*                                            resulting in version 6.1.10 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_stack_transfer_abort(UX_SLAVE_TRANSFER *transfer_request, ULONG completion_code)
{
3419ba6c:	b580      	push	{r7, lr}
3419ba6e:	b088      	sub	sp, #32
3419ba70:	af00      	add	r7, sp, #0
3419ba72:	6078      	str	r0, [r7, #4]
3419ba74:	6039      	str	r1, [r7, #0]

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_STACK_TRANSFER_ABORT, transfer_request, completion_code, 0, 0, UX_TRACE_DEVICE_STACK_EVENTS, 0, 0)

    /* Get the pointer to the DCD.  */
    dcd =  &_ux_system_slave -> ux_system_slave_dcd;
3419ba76:	4b19      	ldr	r3, [pc, #100]	@ (3419badc <_ux_device_stack_transfer_abort+0x70>)
3419ba78:	681b      	ldr	r3, [r3, #0]
3419ba7a:	61fb      	str	r3, [r7, #28]

    /* Sets the completion code due to bus reset.  */
    transfer_request -> ux_slave_transfer_request_completion_code = completion_code;
3419ba7c:	687b      	ldr	r3, [r7, #4]
3419ba7e:	683a      	ldr	r2, [r7, #0]
3419ba80:	625a      	str	r2, [r3, #36]	@ 0x24
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
3419ba82:	f3ef 8310 	mrs	r3, PRIMASK
3419ba86:	617b      	str	r3, [r7, #20]
    return(posture);
3419ba88:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
3419ba8a:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
3419ba8c:	b672      	cpsid	i
    return(int_posture);
3419ba8e:	693b      	ldr	r3, [r7, #16]

    /* Ensure we're not preempted by the transfer completion ISR.  */
    UX_DISABLE
3419ba90:	61bb      	str	r3, [r7, #24]

    /* It's possible the transfer already completed. Ensure it hasn't before doing the abort.  */
    if (transfer_request -> ux_slave_transfer_request_status == UX_TRANSFER_STATUS_PENDING)
3419ba92:	687b      	ldr	r3, [r7, #4]
3419ba94:	681b      	ldr	r3, [r3, #0]
3419ba96:	2b01      	cmp	r3, #1
3419ba98:	d114      	bne.n	3419bac4 <_ux_device_stack_transfer_abort+0x58>
    {

        /* Call the DCD if necessary for cleaning up the pending transfer.  */
        dcd -> ux_slave_dcd_function(dcd, UX_DCD_TRANSFER_ABORT, (VOID *) transfer_request);
3419ba9a:	69fb      	ldr	r3, [r7, #28]
3419ba9c:	699b      	ldr	r3, [r3, #24]
3419ba9e:	687a      	ldr	r2, [r7, #4]
3419baa0:	210d      	movs	r1, #13
3419baa2:	69f8      	ldr	r0, [r7, #28]
3419baa4:	4798      	blx	r3
3419baa6:	69bb      	ldr	r3, [r7, #24]
3419baa8:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
3419baaa:	68fb      	ldr	r3, [r7, #12]
3419baac:	f383 8810 	msr	PRIMASK, r3
}
3419bab0:	bf00      	nop

        /* We need to set the completion code for the transfer to aborted. Note
           that the transfer request function cannot simultaneously modify this 
           because if the transfer was pending, then the transfer's thread is 
           currently waiting for it to complete.  */
        transfer_request -> ux_slave_transfer_request_status =  UX_TRANSFER_STATUS_ABORT;
3419bab2:	687b      	ldr	r3, [r7, #4]
3419bab4:	2204      	movs	r2, #4
3419bab6:	601a      	str	r2, [r3, #0]

        /* Wake up the device driver who is waiting on the semaphore.  */
        _ux_device_semaphore_put(&transfer_request -> ux_slave_transfer_request_semaphore);
3419bab8:	687b      	ldr	r3, [r7, #4]
3419baba:	3330      	adds	r3, #48	@ 0x30
3419babc:	4618      	mov	r0, r3
3419babe:	f7fe fa47 	bl	34199f50 <_ux_utility_semaphore_put>
3419bac2:	e005      	b.n	3419bad0 <_ux_device_stack_transfer_abort+0x64>
3419bac4:	69bb      	ldr	r3, [r7, #24]
3419bac6:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
3419bac8:	68bb      	ldr	r3, [r7, #8]
3419baca:	f383 8810 	msr	PRIMASK, r3
}
3419bace:	bf00      	nop
        /* Restore interrupts.  */
        UX_RESTORE
    }

    /* This function never fails.  */
    return(UX_SUCCESS);       
3419bad0:	2300      	movs	r3, #0
}
3419bad2:	4618      	mov	r0, r3
3419bad4:	3720      	adds	r7, #32
3419bad6:	46bd      	mov	sp, r7
3419bad8:	bd80      	pop	{r7, pc}
3419bada:	bf00      	nop
3419badc:	341c33f8 	.word	0x341c33f8

3419bae0 <_ux_device_stack_transfer_all_request_abort>:
/*  09-30-2020     Chaoqiong Xiao           Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_stack_transfer_all_request_abort(UX_SLAVE_ENDPOINT *endpoint, ULONG completion_code)
{
3419bae0:	b580      	push	{r7, lr}
3419bae2:	b084      	sub	sp, #16
3419bae4:	af00      	add	r7, sp, #0
3419bae6:	6078      	str	r0, [r7, #4]
3419bae8:	6039      	str	r1, [r7, #0]

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_STACK_TRANSFER_ALL_REQUEST_ABORT, endpoint, completion_code, 0, 0, UX_TRACE_DEVICE_STACK_EVENTS, 0, 0)

    /* Get the transfer request for this endpoint.  */
    transfer_request =  &endpoint -> ux_slave_endpoint_transfer_request;
3419baea:	687b      	ldr	r3, [r7, #4]
3419baec:	3320      	adds	r3, #32
3419baee:	60fb      	str	r3, [r7, #12]
    
    /* Abort this request.  */
    _ux_device_stack_transfer_abort(transfer_request, completion_code);
3419baf0:	6839      	ldr	r1, [r7, #0]
3419baf2:	68f8      	ldr	r0, [r7, #12]
3419baf4:	f7ff ffba 	bl	3419ba6c <_ux_device_stack_transfer_abort>

    /* Return successful completion.  */
    return(UX_SUCCESS);
3419baf8:	2300      	movs	r3, #0
}
3419bafa:	4618      	mov	r0, r3
3419bafc:	3710      	adds	r7, #16
3419bafe:	46bd      	mov	sp, r7
3419bb00:	bd80      	pop	{r7, pc}
	...

3419bb04 <_ux_device_stack_transfer_request>:
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_stack_transfer_request(UX_SLAVE_TRANSFER *transfer_request, 
                                            ULONG slave_length, 
                                            ULONG host_length)
{
3419bb04:	b580      	push	{r7, lr}
3419bb06:	b08e      	sub	sp, #56	@ 0x38
3419bb08:	af00      	add	r7, sp, #0
3419bb0a:	60f8      	str	r0, [r7, #12]
3419bb0c:	60b9      	str	r1, [r7, #8]
3419bb0e:	607a      	str	r2, [r7, #4]
UX_SLAVE_ENDPOINT       *endpoint;
ULONG                   device_state;


    /* Do we have to skip this transfer?  */
    if (transfer_request -> ux_slave_transfer_request_status_phase_ignore == UX_TRUE)
3419bb10:	68fb      	ldr	r3, [r7, #12]
3419bb12:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
3419bb14:	2b01      	cmp	r3, #1
3419bb16:	d101      	bne.n	3419bb1c <_ux_device_stack_transfer_request+0x18>
        return(UX_SUCCESS);
3419bb18:	2300      	movs	r3, #0
3419bb1a:	e077      	b.n	3419bc0c <_ux_device_stack_transfer_request+0x108>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
3419bb1c:	f3ef 8310 	mrs	r3, PRIMASK
3419bb20:	623b      	str	r3, [r7, #32]
    return(posture);
3419bb22:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
3419bb24:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
3419bb26:	b672      	cpsid	i
    return(int_posture);
3419bb28:	69fb      	ldr	r3, [r7, #28]

    /* Disable interrupts to prevent the disconnection ISR from preempting us
       while we check the device state and set the transfer status.  */
    UX_DISABLE
3419bb2a:	637b      	str	r3, [r7, #52]	@ 0x34

    /* Get the device state.  */
    device_state =  _ux_system_slave -> ux_system_slave_device.ux_slave_device_state;
3419bb2c:	4b39      	ldr	r3, [pc, #228]	@ (3419bc14 <_ux_device_stack_transfer_request+0x110>)
3419bb2e:	681b      	ldr	r3, [r3, #0]
3419bb30:	6a1b      	ldr	r3, [r3, #32]
3419bb32:	633b      	str	r3, [r7, #48]	@ 0x30

    /* We can only transfer when the device is ATTACHED, ADDRESSED OR CONFIGURED.  */
    if ((device_state == UX_DEVICE_ATTACHED) || (device_state == UX_DEVICE_ADDRESSED)
3419bb34:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3419bb36:	2b01      	cmp	r3, #1
3419bb38:	d005      	beq.n	3419bb46 <_ux_device_stack_transfer_request+0x42>
3419bb3a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3419bb3c:	2b02      	cmp	r3, #2
3419bb3e:	d002      	beq.n	3419bb46 <_ux_device_stack_transfer_request+0x42>
            || (device_state == UX_DEVICE_CONFIGURED))
3419bb40:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3419bb42:	2b03      	cmp	r3, #3
3419bb44:	d115      	bne.n	3419bb72 <_ux_device_stack_transfer_request+0x6e>

        /* Set the transfer to pending.  */
        transfer_request -> ux_slave_transfer_request_status =  UX_TRANSFER_STATUS_PENDING; 
3419bb46:	68fb      	ldr	r3, [r7, #12]
3419bb48:	2201      	movs	r2, #1
3419bb4a:	601a      	str	r2, [r3, #0]
3419bb4c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
3419bb4e:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
3419bb50:	69bb      	ldr	r3, [r7, #24]
3419bb52:	f383 8810 	msr	PRIMASK, r3
}
3419bb56:	bf00      	nop
                    
    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_STACK_TRANSFER_REQUEST, transfer_request, 0, 0, 0, UX_TRACE_DEVICE_STACK_EVENTS, 0, 0)

    /* Get the pointer to the DCD.  */
    dcd =  &_ux_system_slave -> ux_system_slave_dcd;
3419bb58:	4b2e      	ldr	r3, [pc, #184]	@ (3419bc14 <_ux_device_stack_transfer_request+0x110>)
3419bb5a:	681b      	ldr	r3, [r3, #0]
3419bb5c:	62fb      	str	r3, [r7, #44]	@ 0x2c

    /* Get the endpoint associated with this transaction.  */
    endpoint =  transfer_request -> ux_slave_transfer_request_endpoint;
3419bb5e:	68fb      	ldr	r3, [r7, #12]
3419bb60:	689b      	ldr	r3, [r3, #8]
3419bb62:	62bb      	str	r3, [r7, #40]	@ 0x28
    
    /* If the endpoint is non Control, check the endpoint direction and set the data phase direction.  */
    if ((endpoint -> ux_slave_endpoint_descriptor.bmAttributes & UX_MASK_ENDPOINT_TYPE) != UX_CONTROL_ENDPOINT)
3419bb64:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419bb66:	7bdb      	ldrb	r3, [r3, #15]
3419bb68:	f003 0303 	and.w	r3, r3, #3
3419bb6c:	2b00      	cmp	r3, #0
3419bb6e:	d10b      	bne.n	3419bb88 <_ux_device_stack_transfer_request+0x84>
3419bb70:	e01a      	b.n	3419bba8 <_ux_device_stack_transfer_request+0xa4>
3419bb72:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
3419bb74:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
3419bb76:	697b      	ldr	r3, [r7, #20]
3419bb78:	f383 8810 	msr	PRIMASK, r3
}
3419bb7c:	bf00      	nop
        return(UX_TRANSFER_NOT_READY);
3419bb7e:	2325      	movs	r3, #37	@ 0x25
3419bb80:	e044      	b.n	3419bc0c <_ux_device_stack_transfer_request+0x108>
        /* Check if the endpoint is STALLED. In this case, we must refuse the transaction until the endpoint
           has been reset by the host.  */
        while (endpoint -> ux_slave_endpoint_state == UX_ENDPOINT_HALTED)

            /* Wait for 100ms for endpoint to be reset by a CLEAR_FEATURE command.  */
            _ux_utility_delay_ms(100);
3419bb82:	2064      	movs	r0, #100	@ 0x64
3419bb84:	f7fd fd7c 	bl	34199680 <_ux_utility_delay_ms>
        while (endpoint -> ux_slave_endpoint_state == UX_ENDPOINT_HALTED)
3419bb88:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419bb8a:	685b      	ldr	r3, [r3, #4]
3419bb8c:	2b02      	cmp	r3, #2
3419bb8e:	d0f8      	beq.n	3419bb82 <_ux_device_stack_transfer_request+0x7e>

        /* Isolate the direction from the endpoint address.  */
        if ((endpoint -> ux_slave_endpoint_descriptor.bEndpointAddress & UX_ENDPOINT_DIRECTION) == UX_ENDPOINT_IN)
3419bb90:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419bb92:	7b9b      	ldrb	r3, [r3, #14]
3419bb94:	b25b      	sxtb	r3, r3
3419bb96:	2b00      	cmp	r3, #0
3419bb98:	da03      	bge.n	3419bba2 <_ux_device_stack_transfer_request+0x9e>
            transfer_request -> ux_slave_transfer_request_phase =  UX_TRANSFER_PHASE_DATA_OUT;
3419bb9a:	68fb      	ldr	r3, [r7, #12]
3419bb9c:	2203      	movs	r2, #3
3419bb9e:	629a      	str	r2, [r3, #40]	@ 0x28
3419bba0:	e002      	b.n	3419bba8 <_ux_device_stack_transfer_request+0xa4>
        else    
            transfer_request -> ux_slave_transfer_request_phase =  UX_TRANSFER_PHASE_DATA_IN;
3419bba2:	68fb      	ldr	r3, [r7, #12]
3419bba4:	2202      	movs	r2, #2
3419bba6:	629a      	str	r2, [r3, #40]	@ 0x28

    /* See if we need to force a zero length packet at the end of the transfer. 
       This happens on a DATA IN and when the host requested length is not met
       and the last packet is on a boundary. If slave_length is zero, then it is 
       a explicit ZLP request, no need to force ZLP.  */
    if ((transfer_request -> ux_slave_transfer_request_phase ==  UX_TRANSFER_PHASE_DATA_OUT) &&
3419bba8:	68fb      	ldr	r3, [r7, #12]
3419bbaa:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3419bbac:	2b03      	cmp	r3, #3
3419bbae:	d115      	bne.n	3419bbdc <_ux_device_stack_transfer_request+0xd8>
3419bbb0:	68bb      	ldr	r3, [r7, #8]
3419bbb2:	2b00      	cmp	r3, #0
3419bbb4:	d012      	beq.n	3419bbdc <_ux_device_stack_transfer_request+0xd8>
        (slave_length != 0) && (host_length != slave_length) && 
3419bbb6:	687a      	ldr	r2, [r7, #4]
3419bbb8:	68bb      	ldr	r3, [r7, #8]
3419bbba:	429a      	cmp	r2, r3
3419bbbc:	d00e      	beq.n	3419bbdc <_ux_device_stack_transfer_request+0xd8>
        (slave_length % endpoint -> ux_slave_endpoint_descriptor.wMaxPacketSize) == 0)
3419bbbe:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419bbc0:	8a1b      	ldrh	r3, [r3, #16]
3419bbc2:	461a      	mov	r2, r3
3419bbc4:	68bb      	ldr	r3, [r7, #8]
3419bbc6:	fbb3 f1f2 	udiv	r1, r3, r2
3419bbca:	fb01 f202 	mul.w	r2, r1, r2
3419bbce:	1a9b      	subs	r3, r3, r2
        (slave_length != 0) && (host_length != slave_length) && 
3419bbd0:	2b00      	cmp	r3, #0
3419bbd2:	d103      	bne.n	3419bbdc <_ux_device_stack_transfer_request+0xd8>
    {

        /* If so force Zero Length Packet.  */
        transfer_request -> ux_slave_transfer_request_force_zlp =  UX_TRUE;
3419bbd4:	68fb      	ldr	r3, [r7, #12]
3419bbd6:	2201      	movs	r2, #1
3419bbd8:	651a      	str	r2, [r3, #80]	@ 0x50
3419bbda:	e002      	b.n	3419bbe2 <_ux_device_stack_transfer_request+0xde>
    }
    else
    {

        /* Condition is not met, do not force a Zero Length Packet.  */
        transfer_request -> ux_slave_transfer_request_force_zlp =  UX_FALSE;
3419bbdc:	68fb      	ldr	r3, [r7, #12]
3419bbde:	2200      	movs	r2, #0
3419bbe0:	651a      	str	r2, [r3, #80]	@ 0x50
    }

    /* Reset the number of bytes sent/received.  */
    transfer_request -> ux_slave_transfer_request_actual_length =  0;
3419bbe2:	68fb      	ldr	r3, [r7, #12]
3419bbe4:	2200      	movs	r2, #0
3419bbe6:	619a      	str	r2, [r3, #24]

    /* Determine how many bytes to send in this transaction.  We keep track of the original
        length and have a working length.  */
    transfer_request -> ux_slave_transfer_request_requested_length =    slave_length;
3419bbe8:	68fb      	ldr	r3, [r7, #12]
3419bbea:	68ba      	ldr	r2, [r7, #8]
3419bbec:	615a      	str	r2, [r3, #20]
    transfer_request -> ux_slave_transfer_request_in_transfer_length =  slave_length;
3419bbee:	68fb      	ldr	r3, [r7, #12]
3419bbf0:	68ba      	ldr	r2, [r7, #8]
3419bbf2:	61da      	str	r2, [r3, #28]

    /* Save the buffer pointer.  */
    transfer_request -> ux_slave_transfer_request_current_data_pointer =  
                            transfer_request -> ux_slave_transfer_request_data_pointer;
3419bbf4:	68fb      	ldr	r3, [r7, #12]
3419bbf6:	68da      	ldr	r2, [r3, #12]
    transfer_request -> ux_slave_transfer_request_current_data_pointer =  
3419bbf8:	68fb      	ldr	r3, [r7, #12]
3419bbfa:	611a      	str	r2, [r3, #16]

    /* Call the DCD driver transfer function.   */
    status =  dcd -> ux_slave_dcd_function(dcd, UX_DCD_TRANSFER_REQUEST, transfer_request);
3419bbfc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3419bbfe:	699b      	ldr	r3, [r3, #24]
3419bc00:	68fa      	ldr	r2, [r7, #12]
3419bc02:	210c      	movs	r1, #12
3419bc04:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
3419bc06:	4798      	blx	r3
3419bc08:	6278      	str	r0, [r7, #36]	@ 0x24

    /* And return the status.  */
    return(status);
3419bc0a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24

#endif
}
3419bc0c:	4618      	mov	r0, r3
3419bc0e:	3738      	adds	r7, #56	@ 0x38
3419bc10:	46bd      	mov	sp, r7
3419bc12:	bd80      	pop	{r7, pc}
3419bc14:	341c33f8 	.word	0x341c33f8

3419bc18 <_ux_device_class_storage_activate>:
/*                                            endpoint buffer in classes, */
/*                                            resulting in version 6.3.0  */
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_class_storage_activate(UX_SLAVE_CLASS_COMMAND *command)
{
3419bc18:	b580      	push	{r7, lr}
3419bc1a:	b086      	sub	sp, #24
3419bc1c:	af00      	add	r7, sp, #0
3419bc1e:	6078      	str	r0, [r7, #4]
                                          
UINT                                    status = UX_SUCCESS;
3419bc20:	2300      	movs	r3, #0
3419bc22:	617b      	str	r3, [r7, #20]
UX_SLAVE_ENDPOINT                       *endpoint;
#endif


    /* Get the class container.  */
    class_ptr =  command -> ux_slave_class_command_class_ptr;
3419bc24:	687b      	ldr	r3, [r7, #4]
3419bc26:	6a1b      	ldr	r3, [r3, #32]
3419bc28:	613b      	str	r3, [r7, #16]

    /* Get the class instance in the container.  */
    storage = (UX_SLAVE_CLASS_STORAGE *)class_ptr -> ux_slave_class_instance;
3419bc2a:	693b      	ldr	r3, [r7, #16]
3419bc2c:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3419bc2e:	60fb      	str	r3, [r7, #12]

    /* Get the interface that owns this instance.  */
    interface_ptr =  (UX_SLAVE_INTERFACE  *) command -> ux_slave_class_command_interface;
3419bc30:	687b      	ldr	r3, [r7, #4]
3419bc32:	689b      	ldr	r3, [r3, #8]
3419bc34:	60bb      	str	r3, [r7, #8]
    
    /* Store the class instance into the interface.  */
    interface_ptr -> ux_slave_interface_class_instance =  (VOID *)storage;
3419bc36:	68bb      	ldr	r3, [r7, #8]
3419bc38:	68fa      	ldr	r2, [r7, #12]
3419bc3a:	609a      	str	r2, [r3, #8]
         
    /* Now the opposite, store the interface in the class instance.  */
    storage -> ux_slave_class_storage_interface =  interface_ptr;
3419bc3c:	68fb      	ldr	r3, [r7, #12]
3419bc3e:	68ba      	ldr	r2, [r7, #8]
3419bc40:	601a      	str	r2, [r3, #0]

#if !defined(UX_DEVICE_STANDALONE)

    /* Resume thread.  */
    _ux_device_thread_resume(&class_ptr -> ux_slave_class_thread); 
3419bc42:	693b      	ldr	r3, [r7, #16]
3419bc44:	3350      	adds	r3, #80	@ 0x50
3419bc46:	4618      	mov	r0, r3
3419bc48:	f7fe fa4b 	bl	3419a0e2 <_ux_utility_thread_resume>

    status = UX_SUCCESS;
#endif

    /* If there is a activate function call it.  */
    if (storage -> ux_slave_class_storage_instance_activate != UX_NULL)
3419bc4c:	68fb      	ldr	r3, [r7, #12]
3419bc4e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3419bc50:	2b00      	cmp	r3, #0
3419bc52:	d003      	beq.n	3419bc5c <_ux_device_class_storage_activate+0x44>
    {        
        /* Invoke the application.  */
        storage -> ux_slave_class_storage_instance_activate(storage);
3419bc54:	68fb      	ldr	r3, [r7, #12]
3419bc56:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3419bc58:	68f8      	ldr	r0, [r7, #12]
3419bc5a:	4798      	blx	r3

    /* If trace is enabled, register this object.  */
    UX_TRACE_OBJECT_REGISTER(UX_TRACE_DEVICE_OBJECT_TYPE_INTERFACE, storage, 0, 0, 0)

    /* Return completion status.  */
    return(status);
3419bc5c:	697b      	ldr	r3, [r7, #20]
}
3419bc5e:	4618      	mov	r0, r3
3419bc60:	3718      	adds	r7, #24
3419bc62:	46bd      	mov	sp, r7
3419bc64:	bd80      	pop	{r7, pc}
	...

3419bc68 <_ux_device_class_storage_control_request>:
/*                                            names conflict C++ keyword, */
/*                                            resulting in version 6.1.12 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_class_storage_control_request(UX_SLAVE_CLASS_COMMAND *command)
{
3419bc68:	b580      	push	{r7, lr}
3419bc6a:	b08c      	sub	sp, #48	@ 0x30
3419bc6c:	af00      	add	r7, sp, #0
3419bc6e:	6078      	str	r0, [r7, #4]
UX_SLAVE_ENDPOINT           *endpoint_in;
UX_SLAVE_ENDPOINT           *endpoint_out;


    /* Get the pointer to the device.  */
    device =  &_ux_system_slave -> ux_system_slave_device;
3419bc70:	4b38      	ldr	r3, [pc, #224]	@ (3419bd54 <_ux_device_class_storage_control_request+0xec>)
3419bc72:	681b      	ldr	r3, [r3, #0]
3419bc74:	3320      	adds	r3, #32
3419bc76:	627b      	str	r3, [r7, #36]	@ 0x24

    /* Get the pointer to the transfer request associated with the control endpoint.  */
    transfer_request =  &device -> ux_slave_device_control_endpoint.ux_slave_endpoint_transfer_request;
3419bc78:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419bc7a:	3338      	adds	r3, #56	@ 0x38
3419bc7c:	623b      	str	r3, [r7, #32]
    
    /* Extract the request type from the SETUP packet..   */
    request =  *(transfer_request -> ux_slave_transfer_request_setup + UX_SETUP_REQUEST);
3419bc7e:	6a3b      	ldr	r3, [r7, #32]
3419bc80:	f893 3055 	ldrb.w	r3, [r3, #85]	@ 0x55
3419bc84:	61fb      	str	r3, [r7, #28]
    request_value = _ux_utility_short_get(transfer_request -> ux_slave_transfer_request_setup + UX_SETUP_VALUE);
3419bc86:	6a3b      	ldr	r3, [r7, #32]
3419bc88:	3354      	adds	r3, #84	@ 0x54
3419bc8a:	3302      	adds	r3, #2
3419bc8c:	4618      	mov	r0, r3
3419bc8e:	f7fe f96c 	bl	34199f6a <_ux_utility_short_get>
3419bc92:	61b8      	str	r0, [r7, #24]
    request_length = _ux_utility_short_get(transfer_request -> ux_slave_transfer_request_setup + UX_SETUP_LENGTH);
3419bc94:	6a3b      	ldr	r3, [r7, #32]
3419bc96:	3354      	adds	r3, #84	@ 0x54
3419bc98:	3306      	adds	r3, #6
3419bc9a:	4618      	mov	r0, r3
3419bc9c:	f7fe f965 	bl	34199f6a <_ux_utility_short_get>
3419bca0:	6178      	str	r0, [r7, #20]

    /* Check if wValue is valid.  */
    if (request_value != 0)
3419bca2:	69bb      	ldr	r3, [r7, #24]
3419bca4:	2b00      	cmp	r3, #0
3419bca6:	d001      	beq.n	3419bcac <_ux_device_class_storage_control_request+0x44>
        return(UX_ERROR);
3419bca8:	23ff      	movs	r3, #255	@ 0xff
3419bcaa:	e04f      	b.n	3419bd4c <_ux_device_class_storage_control_request+0xe4>

    /* Get the class container.  */
    class_ptr =  command -> ux_slave_class_command_class_ptr;
3419bcac:	687b      	ldr	r3, [r7, #4]
3419bcae:	6a1b      	ldr	r3, [r3, #32]
3419bcb0:	613b      	str	r3, [r7, #16]
    
    /* Get the storage instance from this class container.  */
    storage =  (UX_SLAVE_CLASS_STORAGE *) class_ptr -> ux_slave_class_instance;
3419bcb2:	693b      	ldr	r3, [r7, #16]
3419bcb4:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3419bcb6:	60fb      	str	r3, [r7, #12]

    /* Here we proceed only the standard request we know of at the device level.  */
    switch (request)
3419bcb8:	69fb      	ldr	r3, [r7, #28]
3419bcba:	2bfe      	cmp	r3, #254	@ 0xfe
3419bcbc:	d02d      	beq.n	3419bd1a <_ux_device_class_storage_control_request+0xb2>
3419bcbe:	69fb      	ldr	r3, [r7, #28]
3419bcc0:	2bff      	cmp	r3, #255	@ 0xff
3419bcc2:	d140      	bne.n	3419bd46 <_ux_device_class_storage_control_request+0xde>
    {

    case UX_SLAVE_CLASS_STORAGE_RESET:

        /* Check if wLength is valid.  */
        if (request_length != 0)
3419bcc4:	697b      	ldr	r3, [r7, #20]
3419bcc6:	2b00      	cmp	r3, #0
3419bcc8:	d001      	beq.n	3419bcce <_ux_device_class_storage_control_request+0x66>
            return(UX_ERROR);
3419bcca:	23ff      	movs	r3, #255	@ 0xff
3419bccc:	e03e      	b.n	3419bd4c <_ux_device_class_storage_control_request+0xe4>
        endpoint_in = storage -> ux_device_class_storage_ep_in;
        endpoint_out = storage -> ux_device_class_storage_ep_out;
#else

        /* We need the interface to the class.  */
        interface_ptr =  storage -> ux_slave_class_storage_interface;
3419bcce:	68fb      	ldr	r3, [r7, #12]
3419bcd0:	681b      	ldr	r3, [r3, #0]
3419bcd2:	60bb      	str	r3, [r7, #8]

        /* Locate the endpoints.  */
        endpoint_in =  interface_ptr -> ux_slave_interface_first_endpoint;
3419bcd4:	68bb      	ldr	r3, [r7, #8]
3419bcd6:	69db      	ldr	r3, [r3, #28]
3419bcd8:	62fb      	str	r3, [r7, #44]	@ 0x2c
        
        /* Check the endpoint direction, if IN we have the correct endpoint.  */
        if ((endpoint_in -> ux_slave_endpoint_descriptor.bEndpointAddress & UX_ENDPOINT_DIRECTION) != UX_ENDPOINT_IN)
3419bcda:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3419bcdc:	7b9b      	ldrb	r3, [r3, #14]
3419bcde:	b25b      	sxtb	r3, r3
3419bce0:	2b00      	cmp	r3, #0
3419bce2:	db05      	blt.n	3419bcf0 <_ux_device_class_storage_control_request+0x88>
        {

            /* Wrong direction, we found the OUT endpoint first.  */
            endpoint_out =  endpoint_in;
3419bce4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3419bce6:	62bb      	str	r3, [r7, #40]	@ 0x28
                
            /* So the next endpoint has to be the IN endpoint.  */
            endpoint_in =  endpoint_out -> ux_slave_endpoint_next_endpoint;
3419bce8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419bcea:	695b      	ldr	r3, [r3, #20]
3419bcec:	62fb      	str	r3, [r7, #44]	@ 0x2c
3419bcee:	e002      	b.n	3419bcf6 <_ux_device_class_storage_control_request+0x8e>
        }
        else
        {

            /* We found the endpoint IN first, so next endpoint is OUT.  */
            endpoint_out =  endpoint_in -> ux_slave_endpoint_next_endpoint;
3419bcf0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3419bcf2:	695b      	ldr	r3, [r3, #20]
3419bcf4:	62bb      	str	r3, [r7, #40]	@ 0x28
        }
#endif

        /* First cancel any transfer on the endpoint OUT, from the host.  */
        transfer_request =  &endpoint_out -> ux_slave_endpoint_transfer_request;
3419bcf6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419bcf8:	3320      	adds	r3, #32
3419bcfa:	623b      	str	r3, [r7, #32]
        _ux_device_stack_transfer_abort(transfer_request, UX_TRANSFER_APPLICATION_RESET);
3419bcfc:	2128      	movs	r1, #40	@ 0x28
3419bcfe:	6a38      	ldr	r0, [r7, #32]
3419bd00:	f7ff feb4 	bl	3419ba6c <_ux_device_stack_transfer_abort>

        /* Then cancel any transfer on the endpoint IN, from the host.  */
        transfer_request =  &endpoint_in -> ux_slave_endpoint_transfer_request;
3419bd04:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3419bd06:	3320      	adds	r3, #32
3419bd08:	623b      	str	r3, [r7, #32]
        _ux_device_stack_transfer_abort(transfer_request, UX_TRANSFER_APPLICATION_RESET);
3419bd0a:	2128      	movs	r1, #40	@ 0x28
3419bd0c:	6a38      	ldr	r0, [r7, #32]
3419bd0e:	f7ff fead 	bl	3419ba6c <_ux_device_stack_transfer_abort>

        /* Reset phase error.  */
        storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_PASSED;
3419bd12:	68fb      	ldr	r3, [r7, #12]
3419bd14:	2200      	movs	r2, #0
3419bd16:	651a      	str	r2, [r3, #80]	@ 0x50

        break;
3419bd18:	e017      	b.n	3419bd4a <_ux_device_class_storage_control_request+0xe2>

    case UX_SLAVE_CLASS_STORAGE_GET_MAX_LUN:

        /* Check if wLength is valid.  */
        if (request_length < 1)
3419bd1a:	697b      	ldr	r3, [r7, #20]
3419bd1c:	2b00      	cmp	r3, #0
3419bd1e:	d101      	bne.n	3419bd24 <_ux_device_class_storage_control_request+0xbc>
            return(UX_ERROR);
3419bd20:	23ff      	movs	r3, #255	@ 0xff
3419bd22:	e013      	b.n	3419bd4c <_ux_device_class_storage_control_request+0xe4>

        /* Set the value of the number of LUN in the buffer. The max number of LUN is the
           number of declared LUN - 1.  */
        *transfer_request -> ux_slave_transfer_request_data_pointer =  (UCHAR)(storage -> ux_slave_class_storage_number_lun -1);
3419bd24:	68fb      	ldr	r3, [r7, #12]
3419bd26:	685b      	ldr	r3, [r3, #4]
3419bd28:	b2da      	uxtb	r2, r3
3419bd2a:	6a3b      	ldr	r3, [r7, #32]
3419bd2c:	68db      	ldr	r3, [r3, #12]
3419bd2e:	3a01      	subs	r2, #1
3419bd30:	b2d2      	uxtb	r2, r2
3419bd32:	701a      	strb	r2, [r3, #0]

        /* Set the phase of the transfer to data out.  */
        transfer_request -> ux_slave_transfer_request_phase =  UX_TRANSFER_PHASE_DATA_OUT;
3419bd34:	6a3b      	ldr	r3, [r7, #32]
3419bd36:	2203      	movs	r2, #3
3419bd38:	629a      	str	r2, [r3, #40]	@ 0x28

        /* We can return the LUN number.  */
        _ux_device_stack_transfer_request(transfer_request, 1, 1);
3419bd3a:	2201      	movs	r2, #1
3419bd3c:	2101      	movs	r1, #1
3419bd3e:	6a38      	ldr	r0, [r7, #32]
3419bd40:	f7ff fee0 	bl	3419bb04 <_ux_device_stack_transfer_request>
        break;
3419bd44:	e001      	b.n	3419bd4a <_ux_device_class_storage_control_request+0xe2>

    default:

        /* Unknown function. It's not handled.  */
        return(UX_ERROR);
3419bd46:	23ff      	movs	r3, #255	@ 0xff
3419bd48:	e000      	b.n	3419bd4c <_ux_device_class_storage_control_request+0xe4>
    }

    /* It's handled.  */
    return(UX_SUCCESS);
3419bd4a:	2300      	movs	r3, #0
}
3419bd4c:	4618      	mov	r0, r3
3419bd4e:	3730      	adds	r7, #48	@ 0x30
3419bd50:	46bd      	mov	sp, r7
3419bd52:	bd80      	pop	{r7, pc}
3419bd54:	341c33f8 	.word	0x341c33f8

3419bd58 <_ux_device_class_storage_csw_send>:
/*                                            resulting in version 6.3.0  */
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_class_storage_csw_send(UX_SLAVE_CLASS_STORAGE *storage, ULONG lun, 
                                UX_SLAVE_ENDPOINT *endpoint_in, UCHAR csw_status)
{
3419bd58:	b580      	push	{r7, lr}
3419bd5a:	b088      	sub	sp, #32
3419bd5c:	af00      	add	r7, sp, #0
3419bd5e:	60f8      	str	r0, [r7, #12]
3419bd60:	60b9      	str	r1, [r7, #8]
3419bd62:	607a      	str	r2, [r7, #4]
3419bd64:	70fb      	strb	r3, [r7, #3]

UINT                    status = UX_SUCCESS;
3419bd66:	2300      	movs	r3, #0
3419bd68:	61fb      	str	r3, [r7, #28]
    storage -> ux_device_class_storage_ep_in -> ux_slave_endpoint_transfer_request.
            ux_slave_transfer_request_data_pointer = storage -> ux_device_class_storage_buffer[1];
#endif

    /* If CSW skipped, just return.  */
    if (UX_DEVICE_CLASS_STORAGE_CSW_SKIP(&storage -> ux_slave_class_storage_csw_status))
3419bd6a:	68fb      	ldr	r3, [r7, #12]
3419bd6c:	3350      	adds	r3, #80	@ 0x50
3419bd6e:	3303      	adds	r3, #3
3419bd70:	781b      	ldrb	r3, [r3, #0]
3419bd72:	2b00      	cmp	r3, #0
3419bd74:	d001      	beq.n	3419bd7a <_ux_device_class_storage_csw_send+0x22>
        return(UX_SUCCESS);
3419bd76:	2300      	movs	r3, #0
3419bd78:	e02c      	b.n	3419bdd4 <_ux_device_class_storage_csw_send+0x7c>

    /* Obtain the pointer to the transfer request.  */
    transfer_request =  &endpoint_in -> ux_slave_endpoint_transfer_request;
3419bd7a:	687b      	ldr	r3, [r7, #4]
3419bd7c:	3320      	adds	r3, #32
3419bd7e:	61bb      	str	r3, [r7, #24]

    /* Get CSW buffer pointer.  */
    csw_buffer = transfer_request -> ux_slave_transfer_request_data_pointer;
3419bd80:	69bb      	ldr	r3, [r7, #24]
3419bd82:	68db      	ldr	r3, [r3, #12]
3419bd84:	617b      	str	r3, [r7, #20]

    /* Ensure it is cleaned.  */
    _ux_utility_memory_set(csw_buffer, 0, UX_SLAVE_CLASS_STORAGE_CSW_LENGTH); /* Use case of memset is verified. */
3419bd86:	220d      	movs	r2, #13
3419bd88:	2100      	movs	r1, #0
3419bd8a:	6978      	ldr	r0, [r7, #20]
3419bd8c:	f7fe f82c 	bl	34199de8 <_ux_utility_memory_set>

    /* Store the signature of the CSW.  */
    _ux_utility_long_put(&csw_buffer[UX_SLAVE_CLASS_STORAGE_CSW_SIGNATURE], UX_SLAVE_CLASS_STORAGE_CSW_SIGNATURE_MASK);
3419bd90:	4912      	ldr	r1, [pc, #72]	@ (3419bddc <_ux_device_class_storage_csw_send+0x84>)
3419bd92:	6978      	ldr	r0, [r7, #20]
3419bd94:	f7fd fd2e 	bl	341997f4 <_ux_utility_long_put>

    /* Store the SCSI tag from the CBW.  */
    _ux_utility_long_put(&csw_buffer[UX_SLAVE_CLASS_STORAGE_CSW_TAG], storage -> ux_slave_class_storage_scsi_tag);
3419bd98:	697b      	ldr	r3, [r7, #20]
3419bd9a:	1d1a      	adds	r2, r3, #4
3419bd9c:	68fb      	ldr	r3, [r7, #12]
3419bd9e:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3419bda0:	4619      	mov	r1, r3
3419bda2:	4610      	mov	r0, r2
3419bda4:	f7fd fd26 	bl	341997f4 <_ux_utility_long_put>

    /* Store the dCSWDataResidue.  */
    _ux_utility_long_put(&csw_buffer[UX_SLAVE_CLASS_STORAGE_CSW_DATA_RESIDUE], storage -> ux_slave_class_storage_csw_residue);
3419bda8:	697b      	ldr	r3, [r7, #20]
3419bdaa:	f103 0208 	add.w	r2, r3, #8
3419bdae:	68fb      	ldr	r3, [r7, #12]
3419bdb0:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3419bdb2:	4619      	mov	r1, r3
3419bdb4:	4610      	mov	r0, r2
3419bdb6:	f7fd fd1d 	bl	341997f4 <_ux_utility_long_put>

    /* Store the status of the previous operation.  */
    csw_buffer[UX_SLAVE_CLASS_STORAGE_CSW_STATUS] = (UCHAR)storage -> ux_slave_class_storage_csw_status;
3419bdba:	68fb      	ldr	r3, [r7, #12]
3419bdbc:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
3419bdbe:	697b      	ldr	r3, [r7, #20]
3419bdc0:	330c      	adds	r3, #12
3419bdc2:	b2d2      	uxtb	r2, r2
3419bdc4:	701a      	strb	r2, [r3, #0]

    /* We may be in a special state machine condition where the endpoint is stalled waiting for
       a CLEAR_FEATURE.  We will wait until the host clears the endpoint.  
       The transfer_request function does that.  */
    /* Send the CSW back to the host.  */
    status =  _ux_device_stack_transfer_request(transfer_request, UX_SLAVE_CLASS_STORAGE_CSW_LENGTH, 
3419bdc6:	220d      	movs	r2, #13
3419bdc8:	210d      	movs	r1, #13
3419bdca:	69b8      	ldr	r0, [r7, #24]
3419bdcc:	f7ff fe9a 	bl	3419bb04 <_ux_device_stack_transfer_request>
3419bdd0:	61f8      	str	r0, [r7, #28]
                                    UX_SLAVE_CLASS_STORAGE_CSW_LENGTH);
#endif

    /* Return completion status.  */
    return(status);
3419bdd2:	69fb      	ldr	r3, [r7, #28]
}
3419bdd4:	4618      	mov	r0, r3
3419bdd6:	3720      	adds	r7, #32
3419bdd8:	46bd      	mov	sp, r7
3419bdda:	bd80      	pop	{r7, pc}
3419bddc:	53425355 	.word	0x53425355

3419bde0 <_ux_device_class_storage_deactivate>:
/*                                            names conflict C++ keyword, */
/*                                            resulting in version 6.1.12 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_class_storage_deactivate(UX_SLAVE_CLASS_COMMAND *command)
{
3419bde0:	b580      	push	{r7, lr}
3419bde2:	b086      	sub	sp, #24
3419bde4:	af00      	add	r7, sp, #0
3419bde6:	6078      	str	r0, [r7, #4]
UX_SLAVE_ENDPOINT           *endpoint_in;
UX_SLAVE_ENDPOINT           *endpoint_out;
UX_SLAVE_CLASS              *class_ptr;

    /* Get the class container.  */
    class_ptr =  command -> ux_slave_class_command_class_ptr;
3419bde8:	687b      	ldr	r3, [r7, #4]
3419bdea:	6a1b      	ldr	r3, [r3, #32]
3419bdec:	60fb      	str	r3, [r7, #12]

    /* Get the class instance in the container.  */
    storage = (UX_SLAVE_CLASS_STORAGE *)class_ptr -> ux_slave_class_instance;
3419bdee:	68fb      	ldr	r3, [r7, #12]
3419bdf0:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3419bdf2:	60bb      	str	r3, [r7, #8]
    endpoint_in -> ux_slave_endpoint_transfer_request.ux_slave_transfer_request_data_pointer =
                                storage -> ux_device_class_storage_buffer[1];
#else

    /* Locate the endpoints.  */
    endpoint_in =  storage -> ux_slave_class_storage_interface -> ux_slave_interface_first_endpoint;
3419bdf4:	68bb      	ldr	r3, [r7, #8]
3419bdf6:	681b      	ldr	r3, [r3, #0]
3419bdf8:	69db      	ldr	r3, [r3, #28]
3419bdfa:	617b      	str	r3, [r7, #20]
    
    /* Check the endpoint direction, if IN we have the correct endpoint.  */
    if ((endpoint_in -> ux_slave_endpoint_descriptor.bEndpointAddress & UX_ENDPOINT_DIRECTION) != UX_ENDPOINT_IN)
3419bdfc:	697b      	ldr	r3, [r7, #20]
3419bdfe:	7b9b      	ldrb	r3, [r3, #14]
3419be00:	b25b      	sxtb	r3, r3
3419be02:	2b00      	cmp	r3, #0
3419be04:	db05      	blt.n	3419be12 <_ux_device_class_storage_deactivate+0x32>
    {

        /* Wrong direction, we found the OUT endpoint first.  */
        endpoint_out =  endpoint_in;
3419be06:	697b      	ldr	r3, [r7, #20]
3419be08:	613b      	str	r3, [r7, #16]
            
        /* So the next endpoint has to be the IN endpoint.  */
        endpoint_in =  endpoint_out -> ux_slave_endpoint_next_endpoint;
3419be0a:	693b      	ldr	r3, [r7, #16]
3419be0c:	695b      	ldr	r3, [r3, #20]
3419be0e:	617b      	str	r3, [r7, #20]
3419be10:	e002      	b.n	3419be18 <_ux_device_class_storage_deactivate+0x38>
    }
    else
    {

        /* We found the endpoint IN first, so next endpoint is OUT.  */
        endpoint_out =  endpoint_in -> ux_slave_endpoint_next_endpoint;
3419be12:	697b      	ldr	r3, [r7, #20]
3419be14:	695b      	ldr	r3, [r3, #20]
3419be16:	613b      	str	r3, [r7, #16]
    }
        
    /* Terminate the transactions pending on the endpoints.  */
    _ux_device_stack_transfer_all_request_abort(endpoint_in, UX_TRANSFER_BUS_RESET);
3419be18:	2126      	movs	r1, #38	@ 0x26
3419be1a:	6978      	ldr	r0, [r7, #20]
3419be1c:	f7ff fe60 	bl	3419bae0 <_ux_device_stack_transfer_all_request_abort>
    _ux_device_stack_transfer_all_request_abort(endpoint_out, UX_TRANSFER_BUS_RESET);
3419be20:	2126      	movs	r1, #38	@ 0x26
3419be22:	6938      	ldr	r0, [r7, #16]
3419be24:	f7ff fe5c 	bl	3419bae0 <_ux_device_stack_transfer_all_request_abort>
#endif

    /* If there is a deactivate function call it.  */
    if (storage -> ux_slave_class_storage_instance_deactivate != UX_NULL)
3419be28:	68bb      	ldr	r3, [r7, #8]
3419be2a:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
3419be2c:	2b00      	cmp	r3, #0
3419be2e:	d003      	beq.n	3419be38 <_ux_device_class_storage_deactivate+0x58>
    {

        /* Invoke the application.  */
        storage -> ux_slave_class_storage_instance_deactivate(storage);
3419be30:	68bb      	ldr	r3, [r7, #8]
3419be32:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
3419be34:	68b8      	ldr	r0, [r7, #8]
3419be36:	4798      	blx	r3

    /* If trace is enabled, register this object.  */
    UX_TRACE_OBJECT_UNREGISTER(storage);

    /* Return completion status.  */
    return(UX_SUCCESS);
3419be38:	2300      	movs	r3, #0
}
3419be3a:	4618      	mov	r0, r3
3419be3c:	3718      	adds	r7, #24
3419be3e:	46bd      	mov	sp, r7
3419be40:	bd80      	pop	{r7, pc}
	...

3419be44 <_ux_device_class_storage_entry>:
/*                                            added error checks support, */
/*                                            resulting in version 6.3.0  */
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_class_storage_entry(UX_SLAVE_CLASS_COMMAND *command)
{
3419be44:	b580      	push	{r7, lr}
3419be46:	b084      	sub	sp, #16
3419be48:	af00      	add	r7, sp, #0
3419be4a:	6078      	str	r0, [r7, #4]
UINT        status;


    /* The command request will tell us we need to do here, either a enumeration
       query, an activation or a deactivation.  */
    switch (command -> ux_slave_class_command_request)
3419be4c:	687b      	ldr	r3, [r7, #4]
3419be4e:	681b      	ldr	r3, [r3, #0]
3419be50:	3b01      	subs	r3, #1
3419be52:	2b06      	cmp	r3, #6
3419be54:	d836      	bhi.n	3419bec4 <_ux_device_class_storage_entry+0x80>
3419be56:	a201      	add	r2, pc, #4	@ (adr r2, 3419be5c <_ux_device_class_storage_entry+0x18>)
3419be58:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3419be5c:	3419be91 	.word	0x3419be91
3419be60:	3419bea1 	.word	0x3419bea1
3419be64:	3419bead 	.word	0x3419bead
3419be68:	3419beb9 	.word	0x3419beb9
3419be6c:	3419be79 	.word	0x3419be79
3419be70:	3419bec5 	.word	0x3419bec5
3419be74:	3419be85 	.word	0x3419be85

        /* Call the init function of the Storage class.  */
#if defined(UX_DEVICE_CLASS_STORAGE_ENABLE_ERROR_CHECKING)
        status =  _uxe_device_class_storage_initialize(command);
#else
        status =  _ux_device_class_storage_initialize(command);
3419be78:	6878      	ldr	r0, [r7, #4]
3419be7a:	f000 f84b 	bl	3419bf14 <_ux_device_class_storage_initialize>
3419be7e:	60f8      	str	r0, [r7, #12]
#endif
        
        /* Return the completion status.  */
        return(status);
3419be80:	68fb      	ldr	r3, [r7, #12]
3419be82:	e025      	b.n	3419bed0 <_ux_device_class_storage_entry+0x8c>
        
    case UX_SLAVE_CLASS_COMMAND_UNINITIALIZE:

        /* Call the init function of the Storage class.  */
        status =  _ux_device_class_storage_uninitialize(command);
3419be84:	6878      	ldr	r0, [r7, #4]
3419be86:	f001 f90d 	bl	3419d0a4 <_ux_device_class_storage_uninitialize>
3419be8a:	60f8      	str	r0, [r7, #12]
        
        /* Return the completion status.  */
        return(status);
3419be8c:	68fb      	ldr	r3, [r7, #12]
3419be8e:	e01f      	b.n	3419bed0 <_ux_device_class_storage_entry+0x8c>
        

    case UX_SLAVE_CLASS_COMMAND_QUERY:

        /* Check the CLASS definition in the interface descriptor. */
        if (command -> ux_slave_class_command_class == UX_SLAVE_CLASS_STORAGE_CLASS)
3419be90:	687b      	ldr	r3, [r7, #4]
3419be92:	695b      	ldr	r3, [r3, #20]
3419be94:	2b08      	cmp	r3, #8
3419be96:	d101      	bne.n	3419be9c <_ux_device_class_storage_entry+0x58>
            return(UX_SUCCESS);
3419be98:	2300      	movs	r3, #0
3419be9a:	e019      	b.n	3419bed0 <_ux_device_class_storage_entry+0x8c>
        else
            return(UX_NO_CLASS_MATCH);
3419be9c:	2357      	movs	r3, #87	@ 0x57
3419be9e:	e017      	b.n	3419bed0 <_ux_device_class_storage_entry+0x8c>
    case UX_SLAVE_CLASS_COMMAND_ACTIVATE:

        /* The activate command is used when the host has sent a SET_CONFIGURATION command
           and this interface has to be mounted. Both Bulk endpoints have to be mounted
           and the storage thread needs to be activated.  */
        status =  _ux_device_class_storage_activate(command);
3419bea0:	6878      	ldr	r0, [r7, #4]
3419bea2:	f7ff feb9 	bl	3419bc18 <_ux_device_class_storage_activate>
3419bea6:	60f8      	str	r0, [r7, #12]

        /* Return the completion status.  */
        return(status);
3419bea8:	68fb      	ldr	r3, [r7, #12]
3419beaa:	e011      	b.n	3419bed0 <_ux_device_class_storage_entry+0x8c>

    case UX_SLAVE_CLASS_COMMAND_DEACTIVATE:

        /* The deactivate command is used when the device has been extracted.
           The device endpoints have to be dismounted and the storage thread canceled.  */
        status =  _ux_device_class_storage_deactivate(command);
3419beac:	6878      	ldr	r0, [r7, #4]
3419beae:	f7ff ff97 	bl	3419bde0 <_ux_device_class_storage_deactivate>
3419beb2:	60f8      	str	r0, [r7, #12]
        
        /* Return the completion status.  */
        return(status);
3419beb4:	68fb      	ldr	r3, [r7, #12]
3419beb6:	e00b      	b.n	3419bed0 <_ux_device_class_storage_entry+0x8c>

    case UX_SLAVE_CLASS_COMMAND_REQUEST:

        /* The request command is used when the host sends a command on the control endpoint.  */
        status = _ux_device_class_storage_control_request(command);
3419beb8:	6878      	ldr	r0, [r7, #4]
3419beba:	f7ff fed5 	bl	3419bc68 <_ux_device_class_storage_control_request>
3419bebe:	60f8      	str	r0, [r7, #12]

        /* Return the completion status.  */
        return(status);
3419bec0:	68fb      	ldr	r3, [r7, #12]
3419bec2:	e005      	b.n	3419bed0 <_ux_device_class_storage_entry+0x8c>

    default: 

        /* Error trap. */
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_CLASS, UX_FUNCTION_NOT_SUPPORTED);
3419bec4:	2254      	movs	r2, #84	@ 0x54
3419bec6:	2107      	movs	r1, #7
3419bec8:	2002      	movs	r0, #2
3419beca:	f7fd faf9 	bl	341994c0 <_ux_system_error_handler>

        /* If trace is enabled, insert this event into the trace buffer.  */
        UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_FUNCTION_NOT_SUPPORTED, 0, 0, 0, UX_TRACE_ERRORS, 0, 0)

        /* Return an error.  */
        return(UX_FUNCTION_NOT_SUPPORTED);
3419bece:	2354      	movs	r3, #84	@ 0x54
    }   
}
3419bed0:	4618      	mov	r0, r3
3419bed2:	3710      	adds	r7, #16
3419bed4:	46bd      	mov	sp, r7
3419bed6:	bd80      	pop	{r7, pc}

3419bed8 <_ux_device_class_storage_format>:
/*                                            resulting in version 6.1.10 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_class_storage_format(UX_SLAVE_CLASS_STORAGE *storage, ULONG lun, UX_SLAVE_ENDPOINT *endpoint_in,
                                            UX_SLAVE_ENDPOINT *endpoint_out, UCHAR *cbwcb)
{
3419bed8:	b580      	push	{r7, lr}
3419beda:	b084      	sub	sp, #16
3419bedc:	af00      	add	r7, sp, #0
3419bede:	60f8      	str	r0, [r7, #12]
3419bee0:	60b9      	str	r1, [r7, #8]
3419bee2:	607a      	str	r2, [r7, #4]
3419bee4:	603b      	str	r3, [r7, #0]

#if !defined(UX_DEVICE_STANDALONE)

    /* This command is not yet supported. So Stall the endpoint. We stall the
       OUT endpoint because we expect the host to send parameters.  */
    _ux_device_stack_endpoint_stall(endpoint_out);
3419bee6:	6838      	ldr	r0, [r7, #0]
3419bee8:	f7ff f95a 	bl	3419b1a0 <_ux_device_stack_endpoint_stall>

    UX_PARAMETER_NOT_USED(endpoint_out);
#endif

    /* And update the REQUEST_SENSE codes.  */
    storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_request_sense_status =
3419beec:	68f9      	ldr	r1, [r7, #12]
3419beee:	68ba      	ldr	r2, [r7, #8]
3419bef0:	4613      	mov	r3, r2
3419bef2:	00db      	lsls	r3, r3, #3
3419bef4:	1a9b      	subs	r3, r3, r2
3419bef6:	00db      	lsls	r3, r3, #3
3419bef8:	440b      	add	r3, r1
3419befa:	3320      	adds	r3, #32
3419befc:	4a04      	ldr	r2, [pc, #16]	@ (3419bf10 <_ux_device_class_storage_format+0x38>)
3419befe:	601a      	str	r2, [r3, #0]
                                               UX_DEVICE_CLASS_STORAGE_SENSE_STATUS(0x05,0x26,0x01);

    /* Now we set the CSW with failure.  */
    storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_FAILED;
3419bf00:	68fb      	ldr	r3, [r7, #12]
3419bf02:	2201      	movs	r2, #1
3419bf04:	651a      	str	r2, [r3, #80]	@ 0x50

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_FUNCTION_NOT_SUPPORTED, 0, 0, 0, UX_TRACE_ERRORS, 0, 0)

    /* Return not supported error.  */
    return(UX_FUNCTION_NOT_SUPPORTED);
3419bf06:	2354      	movs	r3, #84	@ 0x54
}
3419bf08:	4618      	mov	r0, r3
3419bf0a:	3710      	adds	r7, #16
3419bf0c:	46bd      	mov	sp, r7
3419bf0e:	bd80      	pop	{r7, pc}
3419bf10:	00012605 	.word	0x00012605

3419bf14 <_ux_device_class_storage_initialize>:
/*                                            endpoint buffer in classes, */
/*                                            resulting in version 6.3.0  */
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_class_storage_initialize(UX_SLAVE_CLASS_COMMAND *command)
{
3419bf14:	b580      	push	{r7, lr}
3419bf16:	b08e      	sub	sp, #56	@ 0x38
3419bf18:	af06      	add	r7, sp, #24
3419bf1a:	6078      	str	r0, [r7, #4]

UINT                                    status = UX_SUCCESS;
3419bf1c:	2300      	movs	r3, #0
3419bf1e:	61fb      	str	r3, [r7, #28]
UX_SLAVE_CLASS                          *class_inst;
ULONG                                   lun_index;


    /* Get the pointer to the application parameters for the storage class.  */
    storage_parameter =  command -> ux_slave_class_command_parameter;
3419bf20:	687b      	ldr	r3, [r7, #4]
3419bf22:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3419bf24:	617b      	str	r3, [r7, #20]

    /* Ensure the number of LUN declared by the caller does not exceed the
       max number allowed for LUN storage.  */
    if (storage_parameter -> ux_slave_class_storage_parameter_number_lun > UX_MAX_SLAVE_LUN)
3419bf26:	697b      	ldr	r3, [r7, #20]
3419bf28:	689b      	ldr	r3, [r3, #8]
3419bf2a:	2b01      	cmp	r3, #1
3419bf2c:	d901      	bls.n	3419bf32 <_ux_device_class_storage_initialize+0x1e>
        return UX_ERROR;
3419bf2e:	23ff      	movs	r3, #255	@ 0xff
3419bf30:	e16b      	b.n	3419c20a <_ux_device_class_storage_initialize+0x2f6>

    /* Get the class container.  */
    class_inst =  command -> ux_slave_class_command_class_ptr;
3419bf32:	687b      	ldr	r3, [r7, #4]
3419bf34:	6a1b      	ldr	r3, [r3, #32]
3419bf36:	613b      	str	r3, [r7, #16]

    /* Create an instance of the device storage class.  */
    storage =  _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, sizeof(UX_SLAVE_CLASS_STORAGE));
3419bf38:	226c      	movs	r2, #108	@ 0x6c
3419bf3a:	2100      	movs	r1, #0
3419bf3c:	2000      	movs	r0, #0
3419bf3e:	f7fd fcab 	bl	34199898 <_ux_utility_memory_allocate>
3419bf42:	60f8      	str	r0, [r7, #12]

    /* Check for successful allocation.  */
    if (storage == UX_NULL)
3419bf44:	68fb      	ldr	r3, [r7, #12]
3419bf46:	2b00      	cmp	r3, #0
3419bf48:	d101      	bne.n	3419bf4e <_ux_device_class_storage_initialize+0x3a>
        return(UX_MEMORY_INSUFFICIENT);
3419bf4a:	2312      	movs	r3, #18
3419bf4c:	e15d      	b.n	3419c20a <_ux_device_class_storage_initialize+0x2f6>
    /* Allocate bulk endpoint buffer.  */
    UX_ASSERT(!UX_DEVICE_CLASS_STORAGE_ENDPOINT_BUFFER_SIZE_CALC_OVERFLOW);
    storage -> ux_device_class_storage_endpoint_buffer = _ux_utility_memory_allocate(UX_NO_ALIGN,
                UX_CACHE_SAFE_MEMORY, UX_DEVICE_CLASS_STORAGE_ENDPOINT_BUFFER_SIZE);
#else
    status = UX_SUCCESS;
3419bf4e:	2300      	movs	r3, #0
3419bf50:	61fb      	str	r3, [r7, #28]
#endif

#if !defined(UX_DEVICE_STANDALONE)

    /* Allocate some memory for the thread stack. */
    if (status == UX_SUCCESS)
3419bf52:	69fb      	ldr	r3, [r7, #28]
3419bf54:	2b00      	cmp	r3, #0
3419bf56:	d12a      	bne.n	3419bfae <_ux_device_class_storage_initialize+0x9a>
    {
        class_inst -> ux_slave_class_thread_stack = _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, UX_THREAD_STACK_SIZE);
3419bf58:	f44f 6280 	mov.w	r2, #1024	@ 0x400
3419bf5c:	2100      	movs	r1, #0
3419bf5e:	2000      	movs	r0, #0
3419bf60:	f7fd fc9a 	bl	34199898 <_ux_utility_memory_allocate>
3419bf64:	4602      	mov	r2, r0
3419bf66:	693b      	ldr	r3, [r7, #16]
3419bf68:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

        /* If it's OK, create thread.  */
        if (class_inst -> ux_slave_class_thread_stack != UX_NULL)
3419bf6c:	693b      	ldr	r3, [r7, #16]
3419bf6e:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
3419bf72:	2b00      	cmp	r3, #0
3419bf74:	d019      	beq.n	3419bfaa <_ux_device_class_storage_initialize+0x96>

            /* This instance needs to be running in a different thread. So start
            a new thread. We pass a pointer to the class to the new thread.  This thread
            does not start until we have a instance of the class. */
            status =  _ux_device_thread_create(&class_inst -> ux_slave_class_thread, "ux_slave_storage_thread",
3419bf76:	693b      	ldr	r3, [r7, #16]
3419bf78:	f103 0050 	add.w	r0, r3, #80	@ 0x50
3419bf7c:	693a      	ldr	r2, [r7, #16]
3419bf7e:	693b      	ldr	r3, [r7, #16]
3419bf80:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
3419bf84:	2100      	movs	r1, #0
3419bf86:	9105      	str	r1, [sp, #20]
3419bf88:	2100      	movs	r1, #0
3419bf8a:	9104      	str	r1, [sp, #16]
3419bf8c:	2114      	movs	r1, #20
3419bf8e:	9103      	str	r1, [sp, #12]
3419bf90:	2114      	movs	r1, #20
3419bf92:	9102      	str	r1, [sp, #8]
3419bf94:	f44f 6180 	mov.w	r1, #1024	@ 0x400
3419bf98:	9101      	str	r1, [sp, #4]
3419bf9a:	9300      	str	r3, [sp, #0]
3419bf9c:	4613      	mov	r3, r2
3419bf9e:	4a9d      	ldr	r2, [pc, #628]	@ (3419c214 <_ux_device_class_storage_initialize+0x300>)
3419bfa0:	499d      	ldr	r1, [pc, #628]	@ (3419c218 <_ux_device_class_storage_initialize+0x304>)
3419bfa2:	f7fe f85f 	bl	3419a064 <_ux_utility_thread_create>
3419bfa6:	61f8      	str	r0, [r7, #28]
3419bfa8:	e001      	b.n	3419bfae <_ux_device_class_storage_initialize+0x9a>
                        _ux_device_class_storage_thread,
                        (ULONG) (ALIGN_TYPE) class_inst, (VOID *) class_inst -> ux_slave_class_thread_stack,
                        UX_THREAD_STACK_SIZE, UX_THREAD_PRIORITY_CLASS,
                        UX_THREAD_PRIORITY_CLASS, UX_NO_TIME_SLICE, UX_DONT_START);
        else
            status = UX_MEMORY_INSUFFICIENT;
3419bfaa:	2312      	movs	r3, #18
3419bfac:	61fb      	str	r3, [r7, #28]
    /* Save tasks run entry.  */
    class_inst -> ux_slave_class_task_function = _ux_device_class_storage_tasks_run;
#endif

    /* If thread resources allocated, go on.  */
    if (status == UX_SUCCESS)
3419bfae:	69fb      	ldr	r3, [r7, #28]
3419bfb0:	2b00      	cmp	r3, #0
3419bfb2:	f040 811b 	bne.w	3419c1ec <_ux_device_class_storage_initialize+0x2d8>
    {

        UX_THREAD_EXTENSION_PTR_SET(&(class_inst -> ux_slave_class_thread), class_inst)

        /* Store the number of LUN declared.  */
        storage -> ux_slave_class_storage_number_lun = storage_parameter -> ux_slave_class_storage_parameter_number_lun;
3419bfb6:	697b      	ldr	r3, [r7, #20]
3419bfb8:	689a      	ldr	r2, [r3, #8]
3419bfba:	68fb      	ldr	r3, [r7, #12]
3419bfbc:	605a      	str	r2, [r3, #4]

        /* Copy each individual LUN parameters.  */
        for (lun_index = 0; lun_index < storage -> ux_slave_class_storage_number_lun; lun_index++)
3419bfbe:	2300      	movs	r3, #0
3419bfc0:	61bb      	str	r3, [r7, #24]
3419bfc2:	e0c8      	b.n	3419c156 <_ux_device_class_storage_initialize+0x242>
        {

            /* Check block length size. */
            if (storage_parameter -> ux_slave_class_storage_parameter_lun[lun_index].ux_slave_class_storage_media_block_length > UX_SLAVE_CLASS_STORAGE_BUFFER_SIZE)
3419bfc4:	6979      	ldr	r1, [r7, #20]
3419bfc6:	69ba      	ldr	r2, [r7, #24]
3419bfc8:	4613      	mov	r3, r2
3419bfca:	00db      	lsls	r3, r3, #3
3419bfcc:	1a9b      	subs	r3, r3, r2
3419bfce:	00db      	lsls	r3, r3, #3
3419bfd0:	440b      	add	r3, r1
3419bfd2:	3310      	adds	r3, #16
3419bfd4:	681b      	ldr	r3, [r3, #0]
3419bfd6:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
3419bfda:	d902      	bls.n	3419bfe2 <_ux_device_class_storage_initialize+0xce>
            {
                /* Cannot proceed.  */
                status = (UX_MEMORY_INSUFFICIENT);
3419bfdc:	2312      	movs	r3, #18
3419bfde:	61fb      	str	r3, [r7, #28]
                break;
3419bfe0:	e0bf      	b.n	3419c162 <_ux_device_class_storage_initialize+0x24e>
            }

            /* Store all the application parameter information about the media.  */
            storage -> ux_slave_class_storage_lun[lun_index].ux_slave_class_storage_media_last_lba       = storage_parameter -> ux_slave_class_storage_parameter_lun[lun_index].ux_slave_class_storage_media_last_lba;
3419bfe2:	6979      	ldr	r1, [r7, #20]
3419bfe4:	69ba      	ldr	r2, [r7, #24]
3419bfe6:	4613      	mov	r3, r2
3419bfe8:	00db      	lsls	r3, r3, #3
3419bfea:	1a9b      	subs	r3, r3, r2
3419bfec:	00db      	lsls	r3, r3, #3
3419bfee:	440b      	add	r3, r1
3419bff0:	330c      	adds	r3, #12
3419bff2:	6819      	ldr	r1, [r3, #0]
3419bff4:	68f8      	ldr	r0, [r7, #12]
3419bff6:	69ba      	ldr	r2, [r7, #24]
3419bff8:	4613      	mov	r3, r2
3419bffa:	00db      	lsls	r3, r3, #3
3419bffc:	1a9b      	subs	r3, r3, r2
3419bffe:	00db      	lsls	r3, r3, #3
3419c000:	4403      	add	r3, r0
3419c002:	3308      	adds	r3, #8
3419c004:	6019      	str	r1, [r3, #0]
            storage -> ux_slave_class_storage_lun[lun_index].ux_slave_class_storage_media_block_length   = storage_parameter -> ux_slave_class_storage_parameter_lun[lun_index].ux_slave_class_storage_media_block_length;
3419c006:	6979      	ldr	r1, [r7, #20]
3419c008:	69ba      	ldr	r2, [r7, #24]
3419c00a:	4613      	mov	r3, r2
3419c00c:	00db      	lsls	r3, r3, #3
3419c00e:	1a9b      	subs	r3, r3, r2
3419c010:	00db      	lsls	r3, r3, #3
3419c012:	440b      	add	r3, r1
3419c014:	3310      	adds	r3, #16
3419c016:	6819      	ldr	r1, [r3, #0]
3419c018:	68f8      	ldr	r0, [r7, #12]
3419c01a:	69ba      	ldr	r2, [r7, #24]
3419c01c:	4613      	mov	r3, r2
3419c01e:	00db      	lsls	r3, r3, #3
3419c020:	1a9b      	subs	r3, r3, r2
3419c022:	00db      	lsls	r3, r3, #3
3419c024:	4403      	add	r3, r0
3419c026:	330c      	adds	r3, #12
3419c028:	6019      	str	r1, [r3, #0]
            storage -> ux_slave_class_storage_lun[lun_index].ux_slave_class_storage_media_type           = storage_parameter -> ux_slave_class_storage_parameter_lun[lun_index].ux_slave_class_storage_media_type;
3419c02a:	6979      	ldr	r1, [r7, #20]
3419c02c:	69ba      	ldr	r2, [r7, #24]
3419c02e:	4613      	mov	r3, r2
3419c030:	00db      	lsls	r3, r3, #3
3419c032:	1a9b      	subs	r3, r3, r2
3419c034:	00db      	lsls	r3, r3, #3
3419c036:	440b      	add	r3, r1
3419c038:	3314      	adds	r3, #20
3419c03a:	6819      	ldr	r1, [r3, #0]
3419c03c:	68f8      	ldr	r0, [r7, #12]
3419c03e:	69ba      	ldr	r2, [r7, #24]
3419c040:	4613      	mov	r3, r2
3419c042:	00db      	lsls	r3, r3, #3
3419c044:	1a9b      	subs	r3, r3, r2
3419c046:	00db      	lsls	r3, r3, #3
3419c048:	4403      	add	r3, r0
3419c04a:	3310      	adds	r3, #16
3419c04c:	6019      	str	r1, [r3, #0]
            storage -> ux_slave_class_storage_lun[lun_index].ux_slave_class_storage_media_removable_flag = storage_parameter -> ux_slave_class_storage_parameter_lun[lun_index].ux_slave_class_storage_media_removable_flag;
3419c04e:	6979      	ldr	r1, [r7, #20]
3419c050:	69ba      	ldr	r2, [r7, #24]
3419c052:	4613      	mov	r3, r2
3419c054:	00db      	lsls	r3, r3, #3
3419c056:	1a9b      	subs	r3, r3, r2
3419c058:	00db      	lsls	r3, r3, #3
3419c05a:	440b      	add	r3, r1
3419c05c:	3318      	adds	r3, #24
3419c05e:	6819      	ldr	r1, [r3, #0]
3419c060:	68f8      	ldr	r0, [r7, #12]
3419c062:	69ba      	ldr	r2, [r7, #24]
3419c064:	4613      	mov	r3, r2
3419c066:	00db      	lsls	r3, r3, #3
3419c068:	1a9b      	subs	r3, r3, r2
3419c06a:	00db      	lsls	r3, r3, #3
3419c06c:	4403      	add	r3, r0
3419c06e:	3314      	adds	r3, #20
3419c070:	6019      	str	r1, [r3, #0]
            storage -> ux_slave_class_storage_lun[lun_index].ux_slave_class_storage_media_read_only_flag = storage_parameter -> ux_slave_class_storage_parameter_lun[lun_index].ux_slave_class_storage_media_read_only_flag;
3419c072:	6979      	ldr	r1, [r7, #20]
3419c074:	69ba      	ldr	r2, [r7, #24]
3419c076:	4613      	mov	r3, r2
3419c078:	00db      	lsls	r3, r3, #3
3419c07a:	1a9b      	subs	r3, r3, r2
3419c07c:	00db      	lsls	r3, r3, #3
3419c07e:	440b      	add	r3, r1
3419c080:	331c      	adds	r3, #28
3419c082:	6819      	ldr	r1, [r3, #0]
3419c084:	68f8      	ldr	r0, [r7, #12]
3419c086:	69ba      	ldr	r2, [r7, #24]
3419c088:	4613      	mov	r3, r2
3419c08a:	00db      	lsls	r3, r3, #3
3419c08c:	1a9b      	subs	r3, r3, r2
3419c08e:	00db      	lsls	r3, r3, #3
3419c090:	4403      	add	r3, r0
3419c092:	3318      	adds	r3, #24
3419c094:	6019      	str	r1, [r3, #0]
            storage -> ux_slave_class_storage_lun[lun_index].ux_slave_class_storage_media_read           = storage_parameter -> ux_slave_class_storage_parameter_lun[lun_index].ux_slave_class_storage_media_read;
3419c096:	6979      	ldr	r1, [r7, #20]
3419c098:	69ba      	ldr	r2, [r7, #24]
3419c09a:	4613      	mov	r3, r2
3419c09c:	00db      	lsls	r3, r3, #3
3419c09e:	1a9b      	subs	r3, r3, r2
3419c0a0:	00db      	lsls	r3, r3, #3
3419c0a2:	440b      	add	r3, r1
3419c0a4:	3330      	adds	r3, #48	@ 0x30
3419c0a6:	6819      	ldr	r1, [r3, #0]
3419c0a8:	68f8      	ldr	r0, [r7, #12]
3419c0aa:	69ba      	ldr	r2, [r7, #24]
3419c0ac:	4613      	mov	r3, r2
3419c0ae:	00db      	lsls	r3, r3, #3
3419c0b0:	1a9b      	subs	r3, r3, r2
3419c0b2:	00db      	lsls	r3, r3, #3
3419c0b4:	4403      	add	r3, r0
3419c0b6:	332c      	adds	r3, #44	@ 0x2c
3419c0b8:	6019      	str	r1, [r3, #0]
            storage -> ux_slave_class_storage_lun[lun_index].ux_slave_class_storage_media_flush          = storage_parameter -> ux_slave_class_storage_parameter_lun[lun_index].ux_slave_class_storage_media_flush;
3419c0ba:	6979      	ldr	r1, [r7, #20]
3419c0bc:	69ba      	ldr	r2, [r7, #24]
3419c0be:	4613      	mov	r3, r2
3419c0c0:	00db      	lsls	r3, r3, #3
3419c0c2:	1a9b      	subs	r3, r3, r2
3419c0c4:	00db      	lsls	r3, r3, #3
3419c0c6:	440b      	add	r3, r1
3419c0c8:	3338      	adds	r3, #56	@ 0x38
3419c0ca:	6819      	ldr	r1, [r3, #0]
3419c0cc:	68f8      	ldr	r0, [r7, #12]
3419c0ce:	69ba      	ldr	r2, [r7, #24]
3419c0d0:	4613      	mov	r3, r2
3419c0d2:	00db      	lsls	r3, r3, #3
3419c0d4:	1a9b      	subs	r3, r3, r2
3419c0d6:	00db      	lsls	r3, r3, #3
3419c0d8:	4403      	add	r3, r0
3419c0da:	3334      	adds	r3, #52	@ 0x34
3419c0dc:	6019      	str	r1, [r3, #0]
            storage -> ux_slave_class_storage_lun[lun_index].ux_slave_class_storage_media_write          = storage_parameter -> ux_slave_class_storage_parameter_lun[lun_index].ux_slave_class_storage_media_write;
3419c0de:	6979      	ldr	r1, [r7, #20]
3419c0e0:	69ba      	ldr	r2, [r7, #24]
3419c0e2:	4613      	mov	r3, r2
3419c0e4:	00db      	lsls	r3, r3, #3
3419c0e6:	1a9b      	subs	r3, r3, r2
3419c0e8:	00db      	lsls	r3, r3, #3
3419c0ea:	440b      	add	r3, r1
3419c0ec:	3334      	adds	r3, #52	@ 0x34
3419c0ee:	6819      	ldr	r1, [r3, #0]
3419c0f0:	68f8      	ldr	r0, [r7, #12]
3419c0f2:	69ba      	ldr	r2, [r7, #24]
3419c0f4:	4613      	mov	r3, r2
3419c0f6:	00db      	lsls	r3, r3, #3
3419c0f8:	1a9b      	subs	r3, r3, r2
3419c0fa:	00db      	lsls	r3, r3, #3
3419c0fc:	4403      	add	r3, r0
3419c0fe:	3330      	adds	r3, #48	@ 0x30
3419c100:	6019      	str	r1, [r3, #0]
            storage -> ux_slave_class_storage_lun[lun_index].ux_slave_class_storage_media_status         = storage_parameter -> ux_slave_class_storage_parameter_lun[lun_index].ux_slave_class_storage_media_status;
3419c102:	6979      	ldr	r1, [r7, #20]
3419c104:	69bb      	ldr	r3, [r7, #24]
3419c106:	1c5a      	adds	r2, r3, #1
3419c108:	4613      	mov	r3, r2
3419c10a:	00db      	lsls	r3, r3, #3
3419c10c:	1a9b      	subs	r3, r3, r2
3419c10e:	00db      	lsls	r3, r3, #3
3419c110:	440b      	add	r3, r1
3419c112:	3304      	adds	r3, #4
3419c114:	6819      	ldr	r1, [r3, #0]
3419c116:	68f8      	ldr	r0, [r7, #12]
3419c118:	69bb      	ldr	r3, [r7, #24]
3419c11a:	1c5a      	adds	r2, r3, #1
3419c11c:	4613      	mov	r3, r2
3419c11e:	00db      	lsls	r3, r3, #3
3419c120:	1a9b      	subs	r3, r3, r2
3419c122:	00db      	lsls	r3, r3, #3
3419c124:	4403      	add	r3, r0
3419c126:	6019      	str	r1, [r3, #0]
            storage -> ux_slave_class_storage_lun[lun_index].ux_slave_class_storage_media_notification   = storage_parameter -> ux_slave_class_storage_parameter_lun[lun_index].ux_slave_class_storage_media_notification;
3419c128:	6979      	ldr	r1, [r7, #20]
3419c12a:	69bb      	ldr	r3, [r7, #24]
3419c12c:	1c5a      	adds	r2, r3, #1
3419c12e:	4613      	mov	r3, r2
3419c130:	00db      	lsls	r3, r3, #3
3419c132:	1a9b      	subs	r3, r3, r2
3419c134:	00db      	lsls	r3, r3, #3
3419c136:	440b      	add	r3, r1
3419c138:	3308      	adds	r3, #8
3419c13a:	6819      	ldr	r1, [r3, #0]
3419c13c:	68f8      	ldr	r0, [r7, #12]
3419c13e:	69bb      	ldr	r3, [r7, #24]
3419c140:	1c5a      	adds	r2, r3, #1
3419c142:	4613      	mov	r3, r2
3419c144:	00db      	lsls	r3, r3, #3
3419c146:	1a9b      	subs	r3, r3, r2
3419c148:	00db      	lsls	r3, r3, #3
3419c14a:	4403      	add	r3, r0
3419c14c:	3304      	adds	r3, #4
3419c14e:	6019      	str	r1, [r3, #0]
        for (lun_index = 0; lun_index < storage -> ux_slave_class_storage_number_lun; lun_index++)
3419c150:	69bb      	ldr	r3, [r7, #24]
3419c152:	3301      	adds	r3, #1
3419c154:	61bb      	str	r3, [r7, #24]
3419c156:	68fb      	ldr	r3, [r7, #12]
3419c158:	685b      	ldr	r3, [r3, #4]
3419c15a:	69ba      	ldr	r2, [r7, #24]
3419c15c:	429a      	cmp	r2, r3
3419c15e:	f4ff af31 	bcc.w	3419bfc4 <_ux_device_class_storage_initialize+0xb0>
        }

        /* If it's OK, complete it.  */
        if (status == UX_SUCCESS)
3419c162:	69fb      	ldr	r3, [r7, #28]
3419c164:	2b00      	cmp	r3, #0
3419c166:	d13c      	bne.n	3419c1e2 <_ux_device_class_storage_initialize+0x2ce>
        {

            /* Store the start and stop signals if needed by the application.  */
            storage -> ux_slave_class_storage_instance_activate = storage_parameter -> ux_slave_class_storage_instance_activate;
3419c168:	697b      	ldr	r3, [r7, #20]
3419c16a:	681a      	ldr	r2, [r3, #0]
3419c16c:	68fb      	ldr	r3, [r7, #12]
3419c16e:	655a      	str	r2, [r3, #84]	@ 0x54
            storage -> ux_slave_class_storage_instance_deactivate = storage_parameter -> ux_slave_class_storage_instance_deactivate;
3419c170:	697b      	ldr	r3, [r7, #20]
3419c172:	685a      	ldr	r2, [r3, #4]
3419c174:	68fb      	ldr	r3, [r7, #12]
3419c176:	659a      	str	r2, [r3, #88]	@ 0x58

            /* Store the vendor id, product id, product revision and product serial.  */
            if (storage_parameter -> ux_slave_class_storage_parameter_vendor_id)
3419c178:	697b      	ldr	r3, [r7, #20]
3419c17a:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3419c17c:	2b00      	cmp	r3, #0
3419c17e:	d004      	beq.n	3419c18a <_ux_device_class_storage_initialize+0x276>
                storage -> ux_slave_class_storage_vendor_id = storage_parameter -> ux_slave_class_storage_parameter_vendor_id;
3419c180:	697b      	ldr	r3, [r7, #20]
3419c182:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
3419c184:	68fb      	ldr	r3, [r7, #12]
3419c186:	65da      	str	r2, [r3, #92]	@ 0x5c
3419c188:	e002      	b.n	3419c190 <_ux_device_class_storage_initialize+0x27c>
            else
                storage -> ux_slave_class_storage_vendor_id = _ux_system_slave_class_storage_vendor_id;
3419c18a:	68fb      	ldr	r3, [r7, #12]
3419c18c:	4a23      	ldr	r2, [pc, #140]	@ (3419c21c <_ux_device_class_storage_initialize+0x308>)
3419c18e:	65da      	str	r2, [r3, #92]	@ 0x5c

            if (storage_parameter -> ux_slave_class_storage_parameter_product_id)
3419c190:	697b      	ldr	r3, [r7, #20]
3419c192:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3419c194:	2b00      	cmp	r3, #0
3419c196:	d004      	beq.n	3419c1a2 <_ux_device_class_storage_initialize+0x28e>
                storage -> ux_slave_class_storage_product_id = storage_parameter -> ux_slave_class_storage_parameter_product_id;
3419c198:	697b      	ldr	r3, [r7, #20]
3419c19a:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3419c19c:	68fb      	ldr	r3, [r7, #12]
3419c19e:	661a      	str	r2, [r3, #96]	@ 0x60
3419c1a0:	e002      	b.n	3419c1a8 <_ux_device_class_storage_initialize+0x294>
            else
                storage -> ux_slave_class_storage_product_id = _ux_system_slave_class_storage_product_id;
3419c1a2:	68fb      	ldr	r3, [r7, #12]
3419c1a4:	4a1e      	ldr	r2, [pc, #120]	@ (3419c220 <_ux_device_class_storage_initialize+0x30c>)
3419c1a6:	661a      	str	r2, [r3, #96]	@ 0x60

            if (storage_parameter -> ux_slave_class_storage_parameter_product_rev)
3419c1a8:	697b      	ldr	r3, [r7, #20]
3419c1aa:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3419c1ac:	2b00      	cmp	r3, #0
3419c1ae:	d004      	beq.n	3419c1ba <_ux_device_class_storage_initialize+0x2a6>
                storage -> ux_slave_class_storage_product_rev = storage_parameter -> ux_slave_class_storage_parameter_product_rev;
3419c1b0:	697b      	ldr	r3, [r7, #20]
3419c1b2:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
3419c1b4:	68fb      	ldr	r3, [r7, #12]
3419c1b6:	665a      	str	r2, [r3, #100]	@ 0x64
3419c1b8:	e002      	b.n	3419c1c0 <_ux_device_class_storage_initialize+0x2ac>
            else
                storage -> ux_slave_class_storage_product_rev = _ux_system_slave_class_storage_product_rev;
3419c1ba:	68fb      	ldr	r3, [r7, #12]
3419c1bc:	4a19      	ldr	r2, [pc, #100]	@ (3419c224 <_ux_device_class_storage_initialize+0x310>)
3419c1be:	665a      	str	r2, [r3, #100]	@ 0x64

            if (storage_parameter -> ux_slave_class_storage_parameter_product_serial)
3419c1c0:	697b      	ldr	r3, [r7, #20]
3419c1c2:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
3419c1c4:	2b00      	cmp	r3, #0
3419c1c6:	d004      	beq.n	3419c1d2 <_ux_device_class_storage_initialize+0x2be>
                storage -> ux_slave_class_storage_product_serial = storage_parameter -> ux_slave_class_storage_parameter_product_serial;
3419c1c8:	697b      	ldr	r3, [r7, #20]
3419c1ca:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
3419c1cc:	68fb      	ldr	r3, [r7, #12]
3419c1ce:	669a      	str	r2, [r3, #104]	@ 0x68
3419c1d0:	e002      	b.n	3419c1d8 <_ux_device_class_storage_initialize+0x2c4>
            else
                storage -> ux_slave_class_storage_product_serial = _ux_system_slave_class_storage_product_serial;
3419c1d2:	68fb      	ldr	r3, [r7, #12]
3419c1d4:	4a14      	ldr	r2, [pc, #80]	@ (3419c228 <_ux_device_class_storage_initialize+0x314>)
3419c1d6:	669a      	str	r2, [r3, #104]	@ 0x68

            /* Save the address of the STORAGE instance inside the STORAGE container.  */
            class_inst -> ux_slave_class_instance = (VOID *) storage;
3419c1d8:	693b      	ldr	r3, [r7, #16]
3419c1da:	68fa      	ldr	r2, [r7, #12]
3419c1dc:	649a      	str	r2, [r3, #72]	@ 0x48

            return(UX_SUCCESS);
3419c1de:	2300      	movs	r3, #0
3419c1e0:	e013      	b.n	3419c20a <_ux_device_class_storage_initialize+0x2f6>
        }

        /* Free thread resources.  */
        _ux_device_thread_delete(&class_inst -> ux_slave_class_thread);
3419c1e2:	693b      	ldr	r3, [r7, #16]
3419c1e4:	3350      	adds	r3, #80	@ 0x50
3419c1e6:	4618      	mov	r0, r3
3419c1e8:	f7fd ff65 	bl	3419a0b6 <_ux_utility_thread_delete>
    }

#if !defined(UX_DEVICE_STANDALONE)
    if (class_inst -> ux_slave_class_thread_stack != UX_NULL)
3419c1ec:	693b      	ldr	r3, [r7, #16]
3419c1ee:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
3419c1f2:	2b00      	cmp	r3, #0
3419c1f4:	d005      	beq.n	3419c202 <_ux_device_class_storage_initialize+0x2ee>
        _ux_utility_memory_free(&class_inst -> ux_slave_class_thread_stack);
3419c1f6:	693b      	ldr	r3, [r7, #16]
3419c1f8:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3419c1fc:	4618      	mov	r0, r3
3419c1fe:	f7fd fd6f 	bl	34199ce0 <_ux_utility_memory_free>
    if (storage -> ux_device_class_storage_endpoint_buffer != UX_NULL)
        _ux_utility_memory_free(storage -> ux_device_class_storage_endpoint_buffer);
#endif

    /* Free instance.  */
    _ux_utility_memory_free(storage);
3419c202:	68f8      	ldr	r0, [r7, #12]
3419c204:	f7fd fd6c 	bl	34199ce0 <_ux_utility_memory_free>

    /* Return completion status.  */
    return(status);
3419c208:	69fb      	ldr	r3, [r7, #28]
}
3419c20a:	4618      	mov	r0, r3
3419c20c:	3720      	adds	r7, #32
3419c20e:	46bd      	mov	sp, r7
3419c210:	bd80      	pop	{r7, pc}
3419c212:	bf00      	nop
3419c214:	3419cc01 	.word	0x3419cc01
3419c218:	3419e334 	.word	0x3419e334
3419c21c:	341c00e8 	.word	0x341c00e8
3419c220:	341c00f4 	.word	0x341c00f4
3419c224:	341c0108 	.word	0x341c0108
3419c228:	341c0110 	.word	0x341c0110

3419c22c <_ux_device_class_storage_inquiry>:
/*                                            resulting in version 6.3.0  */
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_class_storage_inquiry(UX_SLAVE_CLASS_STORAGE *storage, ULONG lun, UX_SLAVE_ENDPOINT *endpoint_in,
                                            UX_SLAVE_ENDPOINT *endpoint_out, UCHAR * cbwcb)
{
3419c22c:	b580      	push	{r7, lr}
3419c22e:	b08a      	sub	sp, #40	@ 0x28
3419c230:	af00      	add	r7, sp, #0
3419c232:	60f8      	str	r0, [r7, #12]
3419c234:	60b9      	str	r1, [r7, #8]
3419c236:	607a      	str	r2, [r7, #4]
3419c238:	603b      	str	r3, [r7, #0]

UINT                    status = UX_SUCCESS;
3419c23a:	2300      	movs	r3, #0
3419c23c:	627b      	str	r3, [r7, #36]	@ 0x24
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_CLASS_STORAGE_INQUIRY, storage, lun, 0, 0, UX_TRACE_DEVICE_CLASS_EVENTS, 0, 0)

#if !defined(UX_DEVICE_STANDALONE)

    /* Check direction.  */
    if (storage -> ux_slave_class_storage_host_length &&
3419c23e:	68fb      	ldr	r3, [r7, #12]
3419c240:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3419c242:	2b00      	cmp	r3, #0
3419c244:	d00d      	beq.n	3419c262 <_ux_device_class_storage_inquiry+0x36>
        (storage -> ux_slave_class_storage_cbw_flags & 0x80) == 0)
3419c246:	68fb      	ldr	r3, [r7, #12]
3419c248:	f893 3044 	ldrb.w	r3, [r3, #68]	@ 0x44
3419c24c:	b25b      	sxtb	r3, r3
    if (storage -> ux_slave_class_storage_host_length &&
3419c24e:	2b00      	cmp	r3, #0
3419c250:	db07      	blt.n	3419c262 <_ux_device_class_storage_inquiry+0x36>
    {
        _ux_device_stack_endpoint_stall(endpoint_out);
3419c252:	6838      	ldr	r0, [r7, #0]
3419c254:	f7fe ffa4 	bl	3419b1a0 <_ux_device_stack_endpoint_stall>
        storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_PHASE_ERROR;
3419c258:	68fb      	ldr	r3, [r7, #12]
3419c25a:	2202      	movs	r2, #2
3419c25c:	651a      	str	r2, [r3, #80]	@ 0x50
        return(UX_ERROR);
3419c25e:	23ff      	movs	r3, #255	@ 0xff
3419c260:	e0c7      	b.n	3419c3f2 <_ux_device_class_storage_inquiry+0x1c6>
    }
#endif

    /* From the SCSI Inquiry payload, get the page code.  */
    inquiry_page_code =  *(cbwcb + UX_SLAVE_CLASS_STORAGE_INQUIRY_PAGE_CODE);
3419c262:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3419c264:	789b      	ldrb	r3, [r3, #2]
3419c266:	77fb      	strb	r3, [r7, #31]
    
    /* And the length to be returned. */
    inquiry_length =  storage -> ux_slave_class_storage_host_length;
3419c268:	68fb      	ldr	r3, [r7, #12]
3419c26a:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3419c26c:	623b      	str	r3, [r7, #32]

    /* Obtain the pointer to the transfer request.  */
    transfer_request =  &endpoint_in -> ux_slave_endpoint_transfer_request;
3419c26e:	687b      	ldr	r3, [r7, #4]
3419c270:	3320      	adds	r3, #32
3419c272:	61bb      	str	r3, [r7, #24]

    /* Obtain inquiry buffer pointer.  */
    inquiry_buffer = transfer_request -> ux_slave_transfer_request_data_pointer;
3419c274:	69bb      	ldr	r3, [r7, #24]
3419c276:	68db      	ldr	r3, [r3, #12]
3419c278:	617b      	str	r3, [r7, #20]

    /* Ensure the data buffer is cleaned.  */
    _ux_utility_memory_set(inquiry_buffer, 0, UX_SLAVE_CLASS_STORAGE_INQUIRY_RESPONSE_LENGTH); /* Use case of memset is verified. */
3419c27a:	2224      	movs	r2, #36	@ 0x24
3419c27c:	2100      	movs	r1, #0
3419c27e:	6978      	ldr	r0, [r7, #20]
3419c280:	f7fd fdb2 	bl	34199de8 <_ux_utility_memory_set>

    /* Check for the maximum length to be returned. */
    if (inquiry_length > UX_SLAVE_CLASS_STORAGE_INQUIRY_RESPONSE_LENGTH)
3419c284:	6a3b      	ldr	r3, [r7, #32]
3419c286:	2b24      	cmp	r3, #36	@ 0x24
3419c288:	d901      	bls.n	3419c28e <_ux_device_class_storage_inquiry+0x62>
        inquiry_length = UX_SLAVE_CLASS_STORAGE_INQUIRY_RESPONSE_LENGTH;
3419c28a:	2324      	movs	r3, #36	@ 0x24
3419c28c:	623b      	str	r3, [r7, #32]

    /* Default CSW to passed.  */
    storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_PASSED;
3419c28e:	68fb      	ldr	r3, [r7, #12]
3419c290:	2200      	movs	r2, #0
3419c292:	651a      	str	r2, [r3, #80]	@ 0x50

    /* Ensure we know about the page code.  */
    switch (inquiry_page_code)
3419c294:	7ffb      	ldrb	r3, [r7, #31]
3419c296:	2b00      	cmp	r3, #0
3419c298:	d002      	beq.n	3419c2a0 <_ux_device_class_storage_inquiry+0x74>
3419c29a:	2b80      	cmp	r3, #128	@ 0x80
3419c29c:	d05d      	beq.n	3419c35a <_ux_device_class_storage_inquiry+0x12e>
3419c29e:	e078      	b.n	3419c392 <_ux_device_class_storage_inquiry+0x166>
    {

    case UX_SLAVE_CLASS_STORAGE_INQUIRY_PAGE_CODE_STANDARD:
            
        /* Store the product type.  */
        inquiry_buffer[UX_SLAVE_CLASS_STORAGE_INQUIRY_RESPONSE_PERIPHERAL_TYPE] =  (UCHAR)storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_type;
3419c2a0:	68f9      	ldr	r1, [r7, #12]
3419c2a2:	68ba      	ldr	r2, [r7, #8]
3419c2a4:	4613      	mov	r3, r2
3419c2a6:	00db      	lsls	r3, r3, #3
3419c2a8:	1a9b      	subs	r3, r3, r2
3419c2aa:	00db      	lsls	r3, r3, #3
3419c2ac:	440b      	add	r3, r1
3419c2ae:	3310      	adds	r3, #16
3419c2b0:	681b      	ldr	r3, [r3, #0]
3419c2b2:	b2da      	uxtb	r2, r3
3419c2b4:	697b      	ldr	r3, [r7, #20]
3419c2b6:	701a      	strb	r2, [r3, #0]

        /* Store the Media Removable bit.  */
        inquiry_buffer[UX_SLAVE_CLASS_STORAGE_INQUIRY_RESPONSE_REMOVABLE_MEDIA] =  (UCHAR)storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_removable_flag;
3419c2b8:	68f9      	ldr	r1, [r7, #12]
3419c2ba:	68ba      	ldr	r2, [r7, #8]
3419c2bc:	4613      	mov	r3, r2
3419c2be:	00db      	lsls	r3, r3, #3
3419c2c0:	1a9b      	subs	r3, r3, r2
3419c2c2:	00db      	lsls	r3, r3, #3
3419c2c4:	440b      	add	r3, r1
3419c2c6:	3314      	adds	r3, #20
3419c2c8:	681a      	ldr	r2, [r3, #0]
3419c2ca:	697b      	ldr	r3, [r7, #20]
3419c2cc:	3301      	adds	r3, #1
3419c2ce:	b2d2      	uxtb	r2, r2
3419c2d0:	701a      	strb	r2, [r3, #0]

        /* Store the Data Format bit.  */
        if (storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_type == UX_SLAVE_CLASS_STORAGE_MEDIA_CDROM)
3419c2d2:	68f9      	ldr	r1, [r7, #12]
3419c2d4:	68ba      	ldr	r2, [r7, #8]
3419c2d6:	4613      	mov	r3, r2
3419c2d8:	00db      	lsls	r3, r3, #3
3419c2da:	1a9b      	subs	r3, r3, r2
3419c2dc:	00db      	lsls	r3, r3, #3
3419c2de:	440b      	add	r3, r1
3419c2e0:	3310      	adds	r3, #16
3419c2e2:	681b      	ldr	r3, [r3, #0]
3419c2e4:	2b05      	cmp	r3, #5
3419c2e6:	d104      	bne.n	3419c2f2 <_ux_device_class_storage_inquiry+0xc6>
            inquiry_buffer[UX_SLAVE_CLASS_STORAGE_INQUIRY_RESPONSE_DATA_FORMAT] =  0x32;
3419c2e8:	697b      	ldr	r3, [r7, #20]
3419c2ea:	3303      	adds	r3, #3
3419c2ec:	2232      	movs	r2, #50	@ 0x32
3419c2ee:	701a      	strb	r2, [r3, #0]
3419c2f0:	e003      	b.n	3419c2fa <_ux_device_class_storage_inquiry+0xce>
        else
            inquiry_buffer[UX_SLAVE_CLASS_STORAGE_INQUIRY_RESPONSE_DATA_FORMAT] =  0x00;
3419c2f2:	697b      	ldr	r3, [r7, #20]
3419c2f4:	3303      	adds	r3, #3
3419c2f6:	2200      	movs	r2, #0
3419c2f8:	701a      	strb	r2, [r3, #0]

        /* Store the length of the response.  There is a hack here. For CD-ROM, the data lg is fixed to 0x5B !  */
        if (storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_type != UX_SLAVE_CLASS_STORAGE_MEDIA_CDROM)
3419c2fa:	68f9      	ldr	r1, [r7, #12]
3419c2fc:	68ba      	ldr	r2, [r7, #8]
3419c2fe:	4613      	mov	r3, r2
3419c300:	00db      	lsls	r3, r3, #3
3419c302:	1a9b      	subs	r3, r3, r2
3419c304:	00db      	lsls	r3, r3, #3
3419c306:	440b      	add	r3, r1
3419c308:	3310      	adds	r3, #16
3419c30a:	681b      	ldr	r3, [r3, #0]
3419c30c:	2b05      	cmp	r3, #5
3419c30e:	d004      	beq.n	3419c31a <_ux_device_class_storage_inquiry+0xee>
            inquiry_buffer[UX_SLAVE_CLASS_STORAGE_INQUIRY_RESPONSE_ADDITIONAL_LENGTH] =  UX_SLAVE_CLASS_STORAGE_INQUIRY_RESPONSE_LENGTH;
3419c310:	697b      	ldr	r3, [r7, #20]
3419c312:	3304      	adds	r3, #4
3419c314:	2224      	movs	r2, #36	@ 0x24
3419c316:	701a      	strb	r2, [r3, #0]
3419c318:	e003      	b.n	3419c322 <_ux_device_class_storage_inquiry+0xf6>
        else            
            inquiry_buffer[UX_SLAVE_CLASS_STORAGE_INQUIRY_RESPONSE_ADDITIONAL_LENGTH] =  UX_SLAVE_CLASS_STORAGE_INQUIRY_RESPONSE_LENGTH_CD_ROM;
3419c31a:	697b      	ldr	r3, [r7, #20]
3419c31c:	3304      	adds	r3, #4
3419c31e:	225b      	movs	r2, #91	@ 0x5b
3419c320:	701a      	strb	r2, [r3, #0]

        /* Fill in the storage vendor ID.  */
        _ux_utility_memory_copy(inquiry_buffer + UX_SLAVE_CLASS_STORAGE_INQUIRY_RESPONSE_VENDOR_INFORMATION,
3419c322:	697b      	ldr	r3, [r7, #20]
3419c324:	f103 0008 	add.w	r0, r3, #8
                                                                    storage -> ux_slave_class_storage_vendor_id, 8); /* Use case of memcpy is verified. */
3419c328:	68fb      	ldr	r3, [r7, #12]
3419c32a:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
        _ux_utility_memory_copy(inquiry_buffer + UX_SLAVE_CLASS_STORAGE_INQUIRY_RESPONSE_VENDOR_INFORMATION,
3419c32c:	2208      	movs	r2, #8
3419c32e:	4619      	mov	r1, r3
3419c330:	f7fd fcb8 	bl	34199ca4 <_ux_utility_memory_copy>

        /* Fill in the product vendor ID.  */
        _ux_utility_memory_copy(inquiry_buffer + UX_SLAVE_CLASS_STORAGE_INQUIRY_RESPONSE_PRODUCT_ID,
3419c334:	697b      	ldr	r3, [r7, #20]
3419c336:	f103 0010 	add.w	r0, r3, #16
                                                                    storage -> ux_slave_class_storage_product_id, 16); /* Use case of memcpy is verified. */
3419c33a:	68fb      	ldr	r3, [r7, #12]
3419c33c:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
        _ux_utility_memory_copy(inquiry_buffer + UX_SLAVE_CLASS_STORAGE_INQUIRY_RESPONSE_PRODUCT_ID,
3419c33e:	2210      	movs	r2, #16
3419c340:	4619      	mov	r1, r3
3419c342:	f7fd fcaf 	bl	34199ca4 <_ux_utility_memory_copy>

        /* Fill in the product revision number.  */
        _ux_utility_memory_copy(inquiry_buffer + UX_SLAVE_CLASS_STORAGE_INQUIRY_RESPONSE_PRODUCT_REVISION,
3419c346:	697b      	ldr	r3, [r7, #20]
3419c348:	f103 0020 	add.w	r0, r3, #32
                                                                    storage -> ux_slave_class_storage_product_rev, 4); /* Use case of memcpy is verified. */
3419c34c:	68fb      	ldr	r3, [r7, #12]
3419c34e:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
        _ux_utility_memory_copy(inquiry_buffer + UX_SLAVE_CLASS_STORAGE_INQUIRY_RESPONSE_PRODUCT_REVISION,
3419c350:	2204      	movs	r2, #4
3419c352:	4619      	mov	r1, r3
3419c354:	f7fd fca6 	bl	34199ca4 <_ux_utility_memory_copy>

        break;
3419c358:	e02f      	b.n	3419c3ba <_ux_device_class_storage_inquiry+0x18e>

    case UX_SLAVE_CLASS_STORAGE_INQUIRY_PAGE_CODE_SERIAL:

        /* Initialize the page code in response buffer.  */
        _ux_utility_short_put_big_endian(transfer_request -> ux_slave_transfer_request_data_pointer, UX_SLAVE_CLASS_STORAGE_INQUIRY_PAGE_CODE_SERIAL);
3419c35a:	69bb      	ldr	r3, [r7, #24]
3419c35c:	68db      	ldr	r3, [r3, #12]
3419c35e:	2180      	movs	r1, #128	@ 0x80
3419c360:	4618      	mov	r0, r3
3419c362:	f7fd fe30 	bl	34199fc6 <_ux_utility_short_put_big_endian>

        /* Initialize the length of the serial number in response buffer.  */
        _ux_utility_short_put_big_endian(transfer_request -> ux_slave_transfer_request_data_pointer + 2, 20);
3419c366:	69bb      	ldr	r3, [r7, #24]
3419c368:	68db      	ldr	r3, [r3, #12]
3419c36a:	3302      	adds	r3, #2
3419c36c:	2114      	movs	r1, #20
3419c36e:	4618      	mov	r0, r3
3419c370:	f7fd fe29 	bl	34199fc6 <_ux_utility_short_put_big_endian>

        /* Copy the serial number buffer into the transfer request memory.  */
        _ux_utility_memory_copy(transfer_request -> ux_slave_transfer_request_data_pointer + 4, storage -> ux_slave_class_storage_product_serial, 20); /* Use case of memcpy is verified. */
3419c374:	69bb      	ldr	r3, [r7, #24]
3419c376:	68db      	ldr	r3, [r3, #12]
3419c378:	1d18      	adds	r0, r3, #4
3419c37a:	68fb      	ldr	r3, [r7, #12]
3419c37c:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
3419c37e:	2214      	movs	r2, #20
3419c380:	4619      	mov	r1, r3
3419c382:	f7fd fc8f 	bl	34199ca4 <_ux_utility_memory_copy>

        /* Send a data payload with the inquiry response buffer.  */
        if (inquiry_length > 24)
3419c386:	6a3b      	ldr	r3, [r7, #32]
3419c388:	2b18      	cmp	r3, #24
3419c38a:	d915      	bls.n	3419c3b8 <_ux_device_class_storage_inquiry+0x18c>
            inquiry_length = 24;
3419c38c:	2318      	movs	r3, #24
3419c38e:	623b      	str	r3, [r7, #32]
    
        break;
3419c390:	e012      	b.n	3419c3b8 <_ux_device_class_storage_inquiry+0x18c>

    default:

#if !defined(UX_DEVICE_STANDALONE)
        /* The page code is not supported.  */
        _ux_device_stack_endpoint_stall(endpoint_in);
3419c392:	6878      	ldr	r0, [r7, #4]
3419c394:	f7fe ff04 	bl	3419b1a0 <_ux_device_stack_endpoint_stall>
#endif

        /* And update the REQUEST_SENSE codes.  */
        storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_request_sense_status =
3419c398:	68f9      	ldr	r1, [r7, #12]
3419c39a:	68ba      	ldr	r2, [r7, #8]
3419c39c:	4613      	mov	r3, r2
3419c39e:	00db      	lsls	r3, r3, #3
3419c3a0:	1a9b      	subs	r3, r3, r2
3419c3a2:	00db      	lsls	r3, r3, #3
3419c3a4:	440b      	add	r3, r1
3419c3a6:	3320      	adds	r3, #32
3419c3a8:	4a14      	ldr	r2, [pc, #80]	@ (3419c3fc <_ux_device_class_storage_inquiry+0x1d0>)
3419c3aa:	601a      	str	r2, [r3, #0]
                                               UX_DEVICE_CLASS_STORAGE_SENSE_STATUS(0x05,0x26,0x01);

        /* Now we set the CSW with failure.  */
        storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_FAILED;
3419c3ac:	68fb      	ldr	r3, [r7, #12]
3419c3ae:	2201      	movs	r2, #1
3419c3b0:	651a      	str	r2, [r3, #80]	@ 0x50

        /* Return error.  */
        status =  UX_ERROR;
3419c3b2:	23ff      	movs	r3, #255	@ 0xff
3419c3b4:	627b      	str	r3, [r7, #36]	@ 0x24

        break;            
3419c3b6:	e000      	b.n	3419c3ba <_ux_device_class_storage_inquiry+0x18e>
        break;
3419c3b8:	bf00      	nop
    }    

    /* Error cases.  */
    if (status != UX_SUCCESS)
3419c3ba:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419c3bc:	2b00      	cmp	r3, #0
3419c3be:	d001      	beq.n	3419c3c4 <_ux_device_class_storage_inquiry+0x198>
        return(status);
3419c3c0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419c3c2:	e016      	b.n	3419c3f2 <_ux_device_class_storage_inquiry+0x1c6>
    storage -> ux_device_class_storage_data_count = 0;

#else

    /* Send a data payload with the inquiry response buffer.  */
    if (inquiry_length)
3419c3c4:	6a3b      	ldr	r3, [r7, #32]
3419c3c6:	2b00      	cmp	r3, #0
3419c3c8:	d004      	beq.n	3419c3d4 <_ux_device_class_storage_inquiry+0x1a8>
        _ux_device_stack_transfer_request(transfer_request, inquiry_length, inquiry_length);
3419c3ca:	6a3a      	ldr	r2, [r7, #32]
3419c3cc:	6a39      	ldr	r1, [r7, #32]
3419c3ce:	69b8      	ldr	r0, [r7, #24]
3419c3d0:	f7ff fb98 	bl	3419bb04 <_ux_device_stack_transfer_request>

    /* Check length.  */
    if (storage -> ux_slave_class_storage_host_length != inquiry_length)
3419c3d4:	68fb      	ldr	r3, [r7, #12]
3419c3d6:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3419c3d8:	6a3a      	ldr	r2, [r7, #32]
3419c3da:	429a      	cmp	r2, r3
3419c3dc:	d008      	beq.n	3419c3f0 <_ux_device_class_storage_inquiry+0x1c4>
    {
        storage -> ux_slave_class_storage_csw_residue = storage -> ux_slave_class_storage_host_length - inquiry_length;
3419c3de:	68fb      	ldr	r3, [r7, #12]
3419c3e0:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
3419c3e2:	6a3b      	ldr	r3, [r7, #32]
3419c3e4:	1ad2      	subs	r2, r2, r3
3419c3e6:	68fb      	ldr	r3, [r7, #12]
3419c3e8:	64da      	str	r2, [r3, #76]	@ 0x4c
        _ux_device_stack_endpoint_stall(endpoint_in);
3419c3ea:	6878      	ldr	r0, [r7, #4]
3419c3ec:	f7fe fed8 	bl	3419b1a0 <_ux_device_stack_endpoint_stall>
    }
#endif

    /* Return completion status.  */
    return(status);
3419c3f0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
3419c3f2:	4618      	mov	r0, r3
3419c3f4:	3728      	adds	r7, #40	@ 0x28
3419c3f6:	46bd      	mov	sp, r7
3419c3f8:	bd80      	pop	{r7, pc}
3419c3fa:	bf00      	nop
3419c3fc:	00012605 	.word	0x00012605

3419c400 <_ux_device_class_storage_mode_select>:
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_class_storage_mode_select(UX_SLAVE_CLASS_STORAGE *storage, ULONG lun, 
                                            UX_SLAVE_ENDPOINT *endpoint_in,
                                            UX_SLAVE_ENDPOINT *endpoint_out, UCHAR * cbwcb)
{
3419c400:	b580      	push	{r7, lr}
3419c402:	b084      	sub	sp, #16
3419c404:	af00      	add	r7, sp, #0
3419c406:	60f8      	str	r0, [r7, #12]
3419c408:	60b9      	str	r1, [r7, #8]
3419c40a:	607a      	str	r2, [r7, #4]
3419c40c:	603b      	str	r3, [r7, #0]

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_CLASS_STORAGE_MODE_SELECT, storage, lun, 0, 0, UX_TRACE_DEVICE_CLASS_EVENTS, 0, 0)

    /* This command is not yet supported. So Stall the endpoint.  */
    if (storage -> ux_slave_class_storage_host_length)
3419c40e:	68fb      	ldr	r3, [r7, #12]
3419c410:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3419c412:	2b00      	cmp	r3, #0
3419c414:	d006      	beq.n	3419c424 <_ux_device_class_storage_mode_select+0x24>
    {

#if !defined(UX_DEVICE_STANDALONE)
        _ux_device_stack_endpoint_stall(endpoint_out);
3419c416:	6838      	ldr	r0, [r7, #0]
3419c418:	f7fe fec2 	bl	3419b1a0 <_ux_device_stack_endpoint_stall>
#else
        UX_PARAMETER_NOT_USED(endpoint_out);
#endif

        storage -> ux_slave_class_storage_csw_residue = storage -> ux_slave_class_storage_host_length;
3419c41c:	68fb      	ldr	r3, [r7, #12]
3419c41e:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
3419c420:	68fb      	ldr	r3, [r7, #12]
3419c422:	64da      	str	r2, [r3, #76]	@ 0x4c
    }

    /* And update the REQUEST_SENSE codes.  */
    storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_request_sense_status =
3419c424:	68f9      	ldr	r1, [r7, #12]
3419c426:	68ba      	ldr	r2, [r7, #8]
3419c428:	4613      	mov	r3, r2
3419c42a:	00db      	lsls	r3, r3, #3
3419c42c:	1a9b      	subs	r3, r3, r2
3419c42e:	00db      	lsls	r3, r3, #3
3419c430:	440b      	add	r3, r1
3419c432:	3320      	adds	r3, #32
3419c434:	4a07      	ldr	r2, [pc, #28]	@ (3419c454 <_ux_device_class_storage_mode_select+0x54>)
3419c436:	601a      	str	r2, [r3, #0]
                                            UX_DEVICE_CLASS_STORAGE_SENSE_STATUS(0x05,0x26,0x01);

    /* Now we set the CSW with failure.  */
    storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_FAILED;
3419c438:	68fb      	ldr	r3, [r7, #12]
3419c43a:	2201      	movs	r2, #1
3419c43c:	651a      	str	r2, [r3, #80]	@ 0x50

    /* Error trap. */
    _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_CLASS, UX_FUNCTION_NOT_SUPPORTED);
3419c43e:	2254      	movs	r2, #84	@ 0x54
3419c440:	2107      	movs	r1, #7
3419c442:	2002      	movs	r0, #2
3419c444:	f7fd f83c 	bl	341994c0 <_ux_system_error_handler>

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_FUNCTION_NOT_SUPPORTED, 0, 0, 0, UX_TRACE_ERRORS, 0, 0)

    /* Return not supported error!  */
    return(UX_FUNCTION_NOT_SUPPORTED);
3419c448:	2354      	movs	r3, #84	@ 0x54
}    
3419c44a:	4618      	mov	r0, r3
3419c44c:	3710      	adds	r7, #16
3419c44e:	46bd      	mov	sp, r7
3419c450:	bd80      	pop	{r7, pc}
3419c452:	bf00      	nop
3419c454:	00012605 	.word	0x00012605

3419c458 <_ux_device_class_storage_mode_sense>:
UINT  _ux_device_class_storage_mode_sense(UX_SLAVE_CLASS_STORAGE *storage, 
                      ULONG               lun, 
                      UX_SLAVE_ENDPOINT   *endpoint_in,
                      UX_SLAVE_ENDPOINT   *endpoint_out, 
                      UCHAR               *cbwcb)
{
3419c458:	b580      	push	{r7, lr}
3419c45a:	b090      	sub	sp, #64	@ 0x40
3419c45c:	af00      	add	r7, sp, #0
3419c45e:	60f8      	str	r0, [r7, #12]
3419c460:	60b9      	str	r1, [r7, #8]
3419c462:	607a      	str	r2, [r7, #4]
3419c464:	603b      	str	r3, [r7, #0]

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_CLASS_STORAGE_MODE_SENSE, storage, lun, 0, 0, UX_TRACE_DEVICE_CLASS_EVENTS, 0, 0)

    /* Obtain the pointer to the transfer request.  */
    transfer_request =  &endpoint_in -> ux_slave_endpoint_transfer_request;
3419c466:	687b      	ldr	r3, [r7, #4]
3419c468:	3320      	adds	r3, #32
3419c46a:	627b      	str	r3, [r7, #36]	@ 0x24

    /* Get the command format : we have 1a and 5a.  */
    mode_sense_command =  (ULONG) *(cbwcb + UX_SLAVE_CLASS_STORAGE_MODE_SENSE_OPERATION);
3419c46c:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3419c46e:	781b      	ldrb	r3, [r3, #0]
3419c470:	623b      	str	r3, [r7, #32]
    
    /* Extract the notification from the cbwcb.  */
    page_code =  (ULONG) *(cbwcb + UX_SLAVE_CLASS_STORAGE_MODE_SENSE_PC_PAGE_CODE);
3419c472:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3419c474:	3302      	adds	r3, #2
3419c476:	781b      	ldrb	r3, [r3, #0]
3419c478:	61fb      	str	r3, [r7, #28]

    /* Check the command.  */
    if (mode_sense_command == UX_SLAVE_CLASS_STORAGE_SCSI_MODE_SENSE_SHORT)
3419c47a:	6a3b      	ldr	r3, [r7, #32]
3419c47c:	2b1a      	cmp	r3, #26
3419c47e:	d108      	bne.n	3419c492 <_ux_device_class_storage_mode_sense+0x3a>
    {

        /* Extract the length to be returned by the cbwcb.  */
        mode_sense_reply_length =  (ULONG) *(cbwcb + UX_SLAVE_CLASS_STORAGE_MODE_SENSE_ALLOCATION_LENGTH_6);
3419c480:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3419c482:	3304      	adds	r3, #4
3419c484:	781b      	ldrb	r3, [r3, #0]
3419c486:	63fb      	str	r3, [r7, #60]	@ 0x3c
        flags_index = UX_SLAVE_CLASS_STORAGE_MODE_SENSE_PARAMETER_FLAGS_6;
3419c488:	2302      	movs	r3, #2
3419c48a:	633b      	str	r3, [r7, #48]	@ 0x30
        response_header_length = UX_SLAVE_CLASS_STORAGE_MODE_SENSE_PARAMETER_HEADER_LENGTH_6;
3419c48c:	2304      	movs	r3, #4
3419c48e:	637b      	str	r3, [r7, #52]	@ 0x34
3419c490:	e009      	b.n	3419c4a6 <_ux_device_class_storage_mode_sense+0x4e>

    else
    {

        /* Extract the length to be returned by the cbwcb.  */
        mode_sense_reply_length =  _ux_utility_short_get_big_endian(cbwcb + UX_SLAVE_CLASS_STORAGE_MODE_SENSE_ALLOCATION_LENGTH_10);
3419c492:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3419c494:	3307      	adds	r3, #7
3419c496:	4618      	mov	r0, r3
3419c498:	f7fd fd7e 	bl	34199f98 <_ux_utility_short_get_big_endian>
3419c49c:	63f8      	str	r0, [r7, #60]	@ 0x3c
        flags_index = UX_SLAVE_CLASS_STORAGE_MODE_SENSE_PARAMETER_FLAGS_10;
3419c49e:	2303      	movs	r3, #3
3419c4a0:	633b      	str	r3, [r7, #48]	@ 0x30
        response_header_length = UX_SLAVE_CLASS_STORAGE_MODE_SENSE_PARAMETER_HEADER_LENGTH_10;
3419c4a2:	2308      	movs	r3, #8
3419c4a4:	637b      	str	r3, [r7, #52]	@ 0x34
    }

    /* Ensure reply not exceed storage buffer.  */
    if (mode_sense_reply_length > UX_SLAVE_CLASS_STORAGE_BUFFER_SIZE)
3419c4a6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3419c4a8:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
3419c4ac:	d902      	bls.n	3419c4b4 <_ux_device_class_storage_mode_sense+0x5c>
        mode_sense_reply_length = UX_SLAVE_CLASS_STORAGE_BUFFER_SIZE;
3419c4ae:	f44f 6380 	mov.w	r3, #1024	@ 0x400
3419c4b2:	63fb      	str	r3, [r7, #60]	@ 0x3c

    /* Ensure memory buffer cleaned.  */
    _ux_utility_memory_set(transfer_request -> ux_slave_transfer_request_data_pointer, 0, mode_sense_reply_length); /* Use case of memset is verified. */
3419c4b4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419c4b6:	68db      	ldr	r3, [r3, #12]
3419c4b8:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
3419c4ba:	2100      	movs	r1, #0
3419c4bc:	4618      	mov	r0, r3
3419c4be:	f7fd fc93 	bl	34199de8 <_ux_utility_memory_set>

    /* Establish READ ONLY flag.  */
    if (storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_read_only_flag == UX_TRUE)
3419c4c2:	68f9      	ldr	r1, [r7, #12]
3419c4c4:	68ba      	ldr	r2, [r7, #8]
3419c4c6:	4613      	mov	r3, r2
3419c4c8:	00db      	lsls	r3, r3, #3
3419c4ca:	1a9b      	subs	r3, r3, r2
3419c4cc:	00db      	lsls	r3, r3, #3
3419c4ce:	440b      	add	r3, r1
3419c4d0:	3318      	adds	r3, #24
3419c4d2:	681b      	ldr	r3, [r3, #0]
3419c4d4:	2b01      	cmp	r3, #1
3419c4d6:	d103      	bne.n	3419c4e0 <_ux_device_class_storage_mode_sense+0x88>
    
        /* This device is Read Only.  */
        read_only_flag = UX_SLAVE_CLASS_STORAGE_MODE_SENSE_PARAMETER_FLAG_WP;
3419c4d8:	2380      	movs	r3, #128	@ 0x80
3419c4da:	f887 303b 	strb.w	r3, [r7, #59]	@ 0x3b
3419c4de:	e002      	b.n	3419c4e6 <_ux_device_class_storage_mode_sense+0x8e>
    
    else
    
        /* This device can be written to.  */
        read_only_flag = 0;        
3419c4e0:	2300      	movs	r3, #0
3419c4e2:	f887 303b 	strb.w	r3, [r7, #59]	@ 0x3b

    /* Build response based on expected page codes.  */

    /* Initialize length and page pointer.  */
    mode_data_length = response_header_length;
3419c4e6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
3419c4e8:	62fb      	str	r3, [r7, #44]	@ 0x2c
    page_pointer = transfer_request -> ux_slave_transfer_request_data_pointer + response_header_length;
3419c4ea:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419c4ec:	68da      	ldr	r2, [r3, #12]
3419c4ee:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
3419c4f0:	4413      	add	r3, r2
3419c4f2:	62bb      	str	r3, [r7, #40]	@ 0x28
        page_pointer += page_length;
    }
#endif

    /* Caching mode page is returned if cache flush callback implemented.  */
    if (storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_flush != UX_NULL &&
3419c4f4:	68f9      	ldr	r1, [r7, #12]
3419c4f6:	68ba      	ldr	r2, [r7, #8]
3419c4f8:	4613      	mov	r3, r2
3419c4fa:	00db      	lsls	r3, r3, #3
3419c4fc:	1a9b      	subs	r3, r3, r2
3419c4fe:	00db      	lsls	r3, r3, #3
3419c500:	440b      	add	r3, r1
3419c502:	3334      	adds	r3, #52	@ 0x34
3419c504:	681b      	ldr	r3, [r3, #0]
3419c506:	2b00      	cmp	r3, #0
3419c508:	d01f      	beq.n	3419c54a <_ux_device_class_storage_mode_sense+0xf2>
3419c50a:	69fb      	ldr	r3, [r7, #28]
3419c50c:	2b08      	cmp	r3, #8
3419c50e:	d002      	beq.n	3419c516 <_ux_device_class_storage_mode_sense+0xbe>
        (page_code == UX_SLAVE_CLASS_STORAGE_PAGE_CODE_CACHE ||
3419c510:	69fb      	ldr	r3, [r7, #28]
3419c512:	2b3f      	cmp	r3, #63	@ 0x3f
3419c514:	d119      	bne.n	3419c54a <_ux_device_class_storage_mode_sense+0xf2>
        page_code == UX_SLAVE_CLASS_STORAGE_PAGE_CODE_ALL))
    {
        page_length = USBX_DEVICE_CLASS_STORAGE_MODE_SENSE_PAGE_CACHE_LENGTH;
3419c516:	2314      	movs	r3, #20
3419c518:	61bb      	str	r3, [r7, #24]

        /* Store page code.  */
        *(page_pointer) = UX_SLAVE_CLASS_STORAGE_PAGE_CODE_CACHE;
3419c51a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419c51c:	2208      	movs	r2, #8
3419c51e:	701a      	strb	r2, [r3, #0]

        /* Store the length of the page data.  */
        *(page_pointer + UX_SLAVE_CLASS_STORAGE_CACHING_MODE_PAGE_LENGTH) =
3419c520:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419c522:	3301      	adds	r3, #1
3419c524:	2212      	movs	r2, #18
3419c526:	701a      	strb	r2, [r3, #0]
                            UX_SLAVE_CLASS_STORAGE_CACHING_MODE_PAGE_PAGE_LENGTH;

        /* Set the Write Cache Enabled (WCE) bit.  */
        *(page_pointer + UX_SLAVE_CLASS_STORAGE_CACHING_MODE_PAGE_FLAGS) |=
3419c528:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419c52a:	3302      	adds	r3, #2
3419c52c:	781a      	ldrb	r2, [r3, #0]
3419c52e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419c530:	3302      	adds	r3, #2
3419c532:	f042 0204 	orr.w	r2, r2, #4
3419c536:	b2d2      	uxtb	r2, r2
3419c538:	701a      	strb	r2, [r3, #0]
                            UX_SLAVE_CLASS_STORAGE_CACHING_MODE_PAGE_FLAG_WCE;

        mode_data_length += page_length;
3419c53a:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
3419c53c:	69bb      	ldr	r3, [r7, #24]
3419c53e:	4413      	add	r3, r2
3419c540:	62fb      	str	r3, [r7, #44]	@ 0x2c
        page_pointer += page_length;
3419c542:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3419c544:	69bb      	ldr	r3, [r7, #24]
3419c546:	4413      	add	r3, r2
3419c548:	62bb      	str	r3, [r7, #40]	@ 0x28
    }

    /* Informational Exceptions Control mode page.  */
    if (page_code == UX_SLAVE_CLASS_STORAGE_PAGE_CODE_IEC ||
3419c54a:	69fb      	ldr	r3, [r7, #28]
3419c54c:	2b1c      	cmp	r3, #28
3419c54e:	d002      	beq.n	3419c556 <_ux_device_class_storage_mode_sense+0xfe>
3419c550:	69fb      	ldr	r3, [r7, #28]
3419c552:	2b3f      	cmp	r3, #63	@ 0x3f
3419c554:	d10c      	bne.n	3419c570 <_ux_device_class_storage_mode_sense+0x118>
        page_code == UX_SLAVE_CLASS_STORAGE_PAGE_CODE_ALL)
    {
        page_length = USBX_DEVICE_CLASS_STORAGE_MODE_SENSE_PAGE_IEC_LENGTH;
3419c556:	230c      	movs	r3, #12
3419c558:	61bb      	str	r3, [r7, #24]

        /* Store page code.  */
        *(page_pointer) = UX_SLAVE_CLASS_STORAGE_PAGE_CODE_IEC;
3419c55a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419c55c:	221c      	movs	r2, #28
3419c55e:	701a      	strb	r2, [r3, #0]

        /* Store the length of the page data.  */
        *(page_pointer + 1) = UX_SLAVE_CLASS_STORAGE_IEC_MODE_PAGE_PAGE_LENGTH;
3419c560:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419c562:	3301      	adds	r3, #1
3419c564:	220a      	movs	r2, #10
3419c566:	701a      	strb	r2, [r3, #0]

        mode_data_length += page_length;
3419c568:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
3419c56a:	69bb      	ldr	r3, [r7, #24]
3419c56c:	4413      	add	r3, r2
3419c56e:	62fb      	str	r3, [r7, #44]	@ 0x2c
    }

    /* Put the payload length in the header.  */
    if (mode_sense_command == UX_SLAVE_CLASS_STORAGE_SCSI_MODE_SENSE_SHORT)
3419c570:	6a3b      	ldr	r3, [r7, #32]
3419c572:	2b1a      	cmp	r3, #26
3419c574:	d105      	bne.n	3419c582 <_ux_device_class_storage_mode_sense+0x12a>
        * transfer_request -> ux_slave_transfer_request_data_pointer = (UCHAR)(mode_data_length);
3419c576:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419c578:	68db      	ldr	r3, [r3, #12]
3419c57a:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
3419c57c:	b2d2      	uxtb	r2, r2
3419c57e:	701a      	strb	r2, [r3, #0]
3419c580:	e007      	b.n	3419c592 <_ux_device_class_storage_mode_sense+0x13a>
    else
        _ux_utility_short_put_big_endian(transfer_request -> ux_slave_transfer_request_data_pointer, (USHORT)mode_data_length);
3419c582:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419c584:	68db      	ldr	r3, [r3, #12]
3419c586:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
3419c588:	b292      	uxth	r2, r2
3419c58a:	4611      	mov	r1, r2
3419c58c:	4618      	mov	r0, r3
3419c58e:	f7fd fd1a 	bl	34199fc6 <_ux_utility_short_put_big_endian>

    /* Store the write protection flag.  */
    *(transfer_request -> ux_slave_transfer_request_data_pointer + flags_index) = read_only_flag;
3419c592:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419c594:	68da      	ldr	r2, [r3, #12]
3419c596:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3419c598:	4413      	add	r3, r2
3419c59a:	f897 203b 	ldrb.w	r2, [r7, #59]	@ 0x3b
3419c59e:	701a      	strb	r2, [r3, #0]
    storage -> ux_device_class_storage_data_count = 0;

#else

    /* Send a payload with the response buffer.  */
    _ux_device_stack_transfer_request(transfer_request, mode_sense_reply_length, mode_sense_reply_length); 
3419c5a0:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
3419c5a2:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
3419c5a4:	6a78      	ldr	r0, [r7, #36]	@ 0x24
3419c5a6:	f7ff faad 	bl	3419bb04 <_ux_device_stack_transfer_request>
#endif

    /* Now we set the CSW with success.  */
    storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_PASSED;
3419c5aa:	68fb      	ldr	r3, [r7, #12]
3419c5ac:	2200      	movs	r2, #0
3419c5ae:	651a      	str	r2, [r3, #80]	@ 0x50
    status = UX_SUCCESS;
3419c5b0:	2300      	movs	r3, #0
3419c5b2:	617b      	str	r3, [r7, #20]

    /* Return completion status.  */
    return(status);
3419c5b4:	697b      	ldr	r3, [r7, #20]
}
3419c5b6:	4618      	mov	r0, r3
3419c5b8:	3740      	adds	r7, #64	@ 0x40
3419c5ba:	46bd      	mov	sp, r7
3419c5bc:	bd80      	pop	{r7, pc}

3419c5be <_ux_device_class_storage_prevent_allow_media_removal>:
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_class_storage_prevent_allow_media_removal(UX_SLAVE_CLASS_STORAGE *storage, ULONG lun, 
                                            UX_SLAVE_ENDPOINT *endpoint_in,
                                            UX_SLAVE_ENDPOINT *endpoint_out, UCHAR * cbwcb)
{
3419c5be:	b480      	push	{r7}
3419c5c0:	b085      	sub	sp, #20
3419c5c2:	af00      	add	r7, sp, #0
3419c5c4:	60f8      	str	r0, [r7, #12]
3419c5c6:	60b9      	str	r1, [r7, #8]
3419c5c8:	607a      	str	r2, [r7, #4]
3419c5ca:	603b      	str	r3, [r7, #0]

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_CLASS_STORAGE_PREVENT_ALLOW_MEDIA_REMOVAL, storage, lun, 0, 0, UX_TRACE_DEVICE_CLASS_EVENTS, 0, 0)

    /* We set the CSW with success.  */
    storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_PASSED;
3419c5cc:	68fb      	ldr	r3, [r7, #12]
3419c5ce:	2200      	movs	r2, #0
3419c5d0:	651a      	str	r2, [r3, #80]	@ 0x50

    /* Return successful completion.  */
    return(UX_SUCCESS);
3419c5d2:	2300      	movs	r3, #0
}
3419c5d4:	4618      	mov	r0, r3
3419c5d6:	3714      	adds	r7, #20
3419c5d8:	46bd      	mov	sp, r7
3419c5da:	f85d 7b04 	ldr.w	r7, [sp], #4
3419c5de:	4770      	bx	lr

3419c5e0 <_ux_device_class_storage_read>:
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_class_storage_read(UX_SLAVE_CLASS_STORAGE *storage, ULONG lun, 
                                            UX_SLAVE_ENDPOINT *endpoint_in,
                                            UX_SLAVE_ENDPOINT *endpoint_out, UCHAR * cbwcb, UCHAR scsi_command)
{
3419c5e0:	b590      	push	{r4, r7, lr}
3419c5e2:	b091      	sub	sp, #68	@ 0x44
3419c5e4:	af02      	add	r7, sp, #8
3419c5e6:	60f8      	str	r0, [r7, #12]
3419c5e8:	60b9      	str	r1, [r7, #8]
3419c5ea:	607a      	str	r2, [r7, #4]
3419c5ec:	603b      	str	r3, [r7, #0]


    UX_PARAMETER_NOT_USED(endpoint_out);

    /* Get the LBA from the CBWCB.  */
    lba =  _ux_utility_long_get_big_endian(cbwcb + UX_SLAVE_CLASS_STORAGE_READ_LBA);
3419c5ee:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3419c5f0:	3302      	adds	r3, #2
3419c5f2:	4618      	mov	r0, r3
3419c5f4:	f7fd f8d7 	bl	341997a6 <_ux_utility_long_get_big_endian>
3419c5f8:	6378      	str	r0, [r7, #52]	@ 0x34

    /* The type of commands will tell us the width of the field containing the number
       of sectors to read.  */
    if (scsi_command == UX_SLAVE_CLASS_STORAGE_SCSI_READ16)
3419c5fa:	f897 304c 	ldrb.w	r3, [r7, #76]	@ 0x4c
3419c5fe:	2b28      	cmp	r3, #40	@ 0x28
3419c600:	d106      	bne.n	3419c610 <_ux_device_class_storage_read+0x30>

        /* Get the number of blocks from the CBWCB in 16 bits.  */
        total_number_blocks =  _ux_utility_short_get_big_endian(cbwcb + UX_SLAVE_CLASS_STORAGE_READ_TRANSFER_LENGTH_16);
3419c602:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3419c604:	3307      	adds	r3, #7
3419c606:	4618      	mov	r0, r3
3419c608:	f7fd fcc6 	bl	34199f98 <_ux_utility_short_get_big_endian>
3419c60c:	6338      	str	r0, [r7, #48]	@ 0x30
3419c60e:	e005      	b.n	3419c61c <_ux_device_class_storage_read+0x3c>

    else        

        /* Get the number of blocks from the CBWCB in 32 bits.  */
        total_number_blocks =  _ux_utility_long_get_big_endian(cbwcb + UX_SLAVE_CLASS_STORAGE_READ_TRANSFER_LENGTH_32);
3419c610:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3419c612:	3306      	adds	r3, #6
3419c614:	4618      	mov	r0, r3
3419c616:	f7fd f8c6 	bl	341997a6 <_ux_utility_long_get_big_endian>
3419c61a:	6338      	str	r0, [r7, #48]	@ 0x30

    /* Obtain the pointer to the transfer request.  */
    transfer_request =  &endpoint_in -> ux_slave_endpoint_transfer_request;
3419c61c:	687b      	ldr	r3, [r7, #4]
3419c61e:	3320      	adds	r3, #32
3419c620:	623b      	str	r3, [r7, #32]

    /* Compute the total length to transfer and how much remains.  */
    total_length =  total_number_blocks * storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_block_length;
3419c622:	68f9      	ldr	r1, [r7, #12]
3419c624:	68ba      	ldr	r2, [r7, #8]
3419c626:	4613      	mov	r3, r2
3419c628:	00db      	lsls	r3, r3, #3
3419c62a:	1a9b      	subs	r3, r3, r2
3419c62c:	00db      	lsls	r3, r3, #3
3419c62e:	440b      	add	r3, r1
3419c630:	330c      	adds	r3, #12
3419c632:	681a      	ldr	r2, [r3, #0]
3419c634:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3419c636:	fb02 f303 	mul.w	r3, r2, r3
3419c63a:	62fb      	str	r3, [r7, #44]	@ 0x2c

    /* Default CSW to failed.  */
    storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_FAILED;
3419c63c:	68fb      	ldr	r3, [r7, #12]
3419c63e:	2201      	movs	r2, #1
3419c640:	651a      	str	r2, [r3, #80]	@ 0x50
#else

    /* Check transfer length.  */

    /* Case (7).  Host length < device length.  */
    if (total_length > storage -> ux_slave_class_storage_host_length)
3419c642:	68fb      	ldr	r3, [r7, #12]
3419c644:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3419c646:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
3419c648:	429a      	cmp	r2, r3
3419c64a:	d907      	bls.n	3419c65c <_ux_device_class_storage_read+0x7c>
    {
        _ux_device_stack_endpoint_stall(endpoint_in);
3419c64c:	6878      	ldr	r0, [r7, #4]
3419c64e:	f7fe fda7 	bl	3419b1a0 <_ux_device_stack_endpoint_stall>
        storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_PHASE_ERROR;
3419c652:	68fb      	ldr	r3, [r7, #12]
3419c654:	2202      	movs	r2, #2
3419c656:	651a      	str	r2, [r3, #80]	@ 0x50
        return(UX_ERROR);
3419c658:	23ff      	movs	r3, #255	@ 0xff
3419c65a:	e0c9      	b.n	3419c7f0 <_ux_device_class_storage_read+0x210>
    }

    /* Case (8). Hi <> Do.  */
    if ((storage -> ux_slave_class_storage_cbw_flags & 0x80) == 0)
3419c65c:	68fb      	ldr	r3, [r7, #12]
3419c65e:	f893 3044 	ldrb.w	r3, [r3, #68]	@ 0x44
3419c662:	b25b      	sxtb	r3, r3
3419c664:	2b00      	cmp	r3, #0
3419c666:	db07      	blt.n	3419c678 <_ux_device_class_storage_read+0x98>
    {
        _ux_device_stack_endpoint_stall(endpoint_out);
3419c668:	6838      	ldr	r0, [r7, #0]
3419c66a:	f7fe fd99 	bl	3419b1a0 <_ux_device_stack_endpoint_stall>
        storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_PHASE_ERROR;
3419c66e:	68fb      	ldr	r3, [r7, #12]
3419c670:	2202      	movs	r2, #2
3419c672:	651a      	str	r2, [r3, #80]	@ 0x50
        return(UX_ERROR);
3419c674:	23ff      	movs	r3, #255	@ 0xff
3419c676:	e0bb      	b.n	3419c7f0 <_ux_device_class_storage_read+0x210>
    }

    /* It may take several transfers to send the requested data.  */
    done_length = 0;
3419c678:	2300      	movs	r3, #0
3419c67a:	627b      	str	r3, [r7, #36]	@ 0x24
    while (total_number_blocks)
3419c67c:	e0a2      	b.n	3419c7c4 <_ux_device_class_storage_read+0x1e4>
    {

        /* Obtain the status of the device.  */
        status =  storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_status(storage, lun, 
3419c67e:	68f9      	ldr	r1, [r7, #12]
3419c680:	68bb      	ldr	r3, [r7, #8]
3419c682:	1c5a      	adds	r2, r3, #1
3419c684:	4613      	mov	r3, r2
3419c686:	00db      	lsls	r3, r3, #3
3419c688:	1a9b      	subs	r3, r3, r2
3419c68a:	00db      	lsls	r3, r3, #3
3419c68c:	440b      	add	r3, r1
3419c68e:	681c      	ldr	r4, [r3, #0]
3419c690:	68f9      	ldr	r1, [r7, #12]
3419c692:	68ba      	ldr	r2, [r7, #8]
3419c694:	4613      	mov	r3, r2
3419c696:	00db      	lsls	r3, r3, #3
3419c698:	1a9b      	subs	r3, r3, r2
3419c69a:	00db      	lsls	r3, r3, #3
3419c69c:	440b      	add	r3, r1
3419c69e:	331c      	adds	r3, #28
3419c6a0:	681a      	ldr	r2, [r3, #0]
3419c6a2:	f107 0314 	add.w	r3, r7, #20
3419c6a6:	68b9      	ldr	r1, [r7, #8]
3419c6a8:	68f8      	ldr	r0, [r7, #12]
3419c6aa:	47a0      	blx	r4
3419c6ac:	61f8      	str	r0, [r7, #28]
                                    storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_id, &media_status);
    
        /* Update the request sense.  */
        storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_request_sense_status = media_status;
3419c6ae:	6979      	ldr	r1, [r7, #20]
3419c6b0:	68f8      	ldr	r0, [r7, #12]
3419c6b2:	68ba      	ldr	r2, [r7, #8]
3419c6b4:	4613      	mov	r3, r2
3419c6b6:	00db      	lsls	r3, r3, #3
3419c6b8:	1a9b      	subs	r3, r3, r2
3419c6ba:	00db      	lsls	r3, r3, #3
3419c6bc:	4403      	add	r3, r0
3419c6be:	3320      	adds	r3, #32
3419c6c0:	6019      	str	r1, [r3, #0]
    
        /* If there is a problem, return a failed command.  */
        if (status != UX_SUCCESS)
3419c6c2:	69fb      	ldr	r3, [r7, #28]
3419c6c4:	2b00      	cmp	r3, #0
3419c6c6:	d00a      	beq.n	3419c6de <_ux_device_class_storage_read+0xfe>
        {
    
            /* We have a problem, media status error. Return a bad completion and wait for the
               REQUEST_SENSE command.  */
            _ux_device_stack_endpoint_stall(endpoint_in);
3419c6c8:	6878      	ldr	r0, [r7, #4]
3419c6ca:	f7fe fd69 	bl	3419b1a0 <_ux_device_stack_endpoint_stall>

            /* Update residue.  */
            storage -> ux_slave_class_storage_csw_residue = storage -> ux_slave_class_storage_host_length - done_length;
3419c6ce:	68fb      	ldr	r3, [r7, #12]
3419c6d0:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
3419c6d2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419c6d4:	1ad2      	subs	r2, r2, r3
3419c6d6:	68fb      	ldr	r3, [r7, #12]
3419c6d8:	64da      	str	r2, [r3, #76]	@ 0x4c
    
            /* Return an error.  */
            return(UX_ERROR);
3419c6da:	23ff      	movs	r3, #255	@ 0xff
3419c6dc:	e088      	b.n	3419c7f0 <_ux_device_class_storage_read+0x210>
        }

        /* How much can we send in this transfer?  */
        if (total_length > UX_SLAVE_CLASS_STORAGE_BUFFER_SIZE)
3419c6de:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3419c6e0:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
3419c6e4:	d903      	bls.n	3419c6ee <_ux_device_class_storage_read+0x10e>

            /* Compute the transfer length based on the maximum allowed.  */
            transfer_length =  UX_SLAVE_CLASS_STORAGE_BUFFER_SIZE;
3419c6e6:	f44f 6380 	mov.w	r3, #1024	@ 0x400
3419c6ea:	62bb      	str	r3, [r7, #40]	@ 0x28
3419c6ec:	e001      	b.n	3419c6f2 <_ux_device_class_storage_read+0x112>
            
        else

            /* Compute the transfer length based on what is left to transfer.  */
            transfer_length =  total_length;
3419c6ee:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3419c6f0:	62bb      	str	r3, [r7, #40]	@ 0x28

        /* Compute the number of blocks to transfer.  */
        number_blocks = transfer_length / storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_block_length;
3419c6f2:	68f9      	ldr	r1, [r7, #12]
3419c6f4:	68ba      	ldr	r2, [r7, #8]
3419c6f6:	4613      	mov	r3, r2
3419c6f8:	00db      	lsls	r3, r3, #3
3419c6fa:	1a9b      	subs	r3, r3, r2
3419c6fc:	00db      	lsls	r3, r3, #3
3419c6fe:	440b      	add	r3, r1
3419c700:	330c      	adds	r3, #12
3419c702:	681b      	ldr	r3, [r3, #0]
3419c704:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3419c706:	fbb2 f3f3 	udiv	r3, r2, r3
3419c70a:	61bb      	str	r3, [r7, #24]
        /* If trace is enabled, insert this event into the trace buffer.  */
        UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_CLASS_STORAGE_READ, storage, lun, transfer_request -> ux_slave_transfer_request_data_pointer, 
                                number_blocks, UX_TRACE_DEVICE_CLASS_EVENTS, 0, 0)

        /* Execute the read command from the local media.  */
        status =  storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_read(storage, lun, 
3419c70c:	68f9      	ldr	r1, [r7, #12]
3419c70e:	68ba      	ldr	r2, [r7, #8]
3419c710:	4613      	mov	r3, r2
3419c712:	00db      	lsls	r3, r3, #3
3419c714:	1a9b      	subs	r3, r3, r2
3419c716:	00db      	lsls	r3, r3, #3
3419c718:	440b      	add	r3, r1
3419c71a:	332c      	adds	r3, #44	@ 0x2c
3419c71c:	681c      	ldr	r4, [r3, #0]
3419c71e:	6a3b      	ldr	r3, [r7, #32]
3419c720:	68da      	ldr	r2, [r3, #12]
3419c722:	f107 0314 	add.w	r3, r7, #20
3419c726:	9301      	str	r3, [sp, #4]
3419c728:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
3419c72a:	9300      	str	r3, [sp, #0]
3419c72c:	69bb      	ldr	r3, [r7, #24]
3419c72e:	68b9      	ldr	r1, [r7, #8]
3419c730:	68f8      	ldr	r0, [r7, #12]
3419c732:	47a0      	blx	r4
3419c734:	61f8      	str	r0, [r7, #28]
                                                    transfer_request -> ux_slave_transfer_request_data_pointer, number_blocks, lba, &media_status); 

        /* If there is a problem, return a failed command.  */
        if (status != UX_SUCCESS)
3419c736:	69fb      	ldr	r3, [r7, #28]
3419c738:	2b00      	cmp	r3, #0
3419c73a:	d014      	beq.n	3419c766 <_ux_device_class_storage_read+0x186>
        {
    
            /* We have a problem, request error. Return a bad completion and wait for the
               REQUEST_SENSE command.  */
            _ux_device_stack_endpoint_stall(endpoint_in);
3419c73c:	6878      	ldr	r0, [r7, #4]
3419c73e:	f7fe fd2f 	bl	3419b1a0 <_ux_device_stack_endpoint_stall>
    
            /* Update residue.  */
            storage -> ux_slave_class_storage_csw_residue = storage -> ux_slave_class_storage_host_length - done_length;
3419c742:	68fb      	ldr	r3, [r7, #12]
3419c744:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
3419c746:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419c748:	1ad2      	subs	r2, r2, r3
3419c74a:	68fb      	ldr	r3, [r7, #12]
3419c74c:	64da      	str	r2, [r3, #76]	@ 0x4c

            /* And update the REQUEST_SENSE codes.  */
            storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_request_sense_status = media_status;
3419c74e:	6979      	ldr	r1, [r7, #20]
3419c750:	68f8      	ldr	r0, [r7, #12]
3419c752:	68ba      	ldr	r2, [r7, #8]
3419c754:	4613      	mov	r3, r2
3419c756:	00db      	lsls	r3, r3, #3
3419c758:	1a9b      	subs	r3, r3, r2
3419c75a:	00db      	lsls	r3, r3, #3
3419c75c:	4403      	add	r3, r0
3419c75e:	3320      	adds	r3, #32
3419c760:	6019      	str	r1, [r3, #0]
    
            /* Return an error.  */
            return(UX_ERROR);
3419c762:	23ff      	movs	r3, #255	@ 0xff
3419c764:	e044      	b.n	3419c7f0 <_ux_device_class_storage_read+0x210>
        }

        /* Sends the data payload back to the caller.  */
        status =  _ux_device_stack_transfer_request(transfer_request, transfer_length, transfer_length);
3419c766:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3419c768:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3419c76a:	6a38      	ldr	r0, [r7, #32]
3419c76c:	f7ff f9ca 	bl	3419bb04 <_ux_device_stack_transfer_request>
3419c770:	61f8      	str	r0, [r7, #28]

        /* Check the status.  */
        if(status != UX_SUCCESS)
3419c772:	69fb      	ldr	r3, [r7, #28]
3419c774:	2b00      	cmp	r3, #0
3419c776:	d015      	beq.n	3419c7a4 <_ux_device_class_storage_read+0x1c4>
        {

            /* We have a problem, request error. Return a bad completion and wait for the
               REQUEST_SENSE command.  */
            _ux_device_stack_endpoint_stall(endpoint_in);
3419c778:	6878      	ldr	r0, [r7, #4]
3419c77a:	f7fe fd11 	bl	3419b1a0 <_ux_device_stack_endpoint_stall>
    
            /* Update residue.  */
            storage -> ux_slave_class_storage_csw_residue = storage -> ux_slave_class_storage_host_length - done_length;
3419c77e:	68fb      	ldr	r3, [r7, #12]
3419c780:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
3419c782:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419c784:	1ad2      	subs	r2, r2, r3
3419c786:	68fb      	ldr	r3, [r7, #12]
3419c788:	64da      	str	r2, [r3, #76]	@ 0x4c

            /* Update the REQUEST_SENSE codes.  */
            storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_request_sense_status =
3419c78a:	68f9      	ldr	r1, [r7, #12]
3419c78c:	68ba      	ldr	r2, [r7, #8]
3419c78e:	4613      	mov	r3, r2
3419c790:	00db      	lsls	r3, r3, #3
3419c792:	1a9b      	subs	r3, r3, r2
3419c794:	00db      	lsls	r3, r3, #3
3419c796:	440b      	add	r3, r1
3419c798:	3320      	adds	r3, #32
3419c79a:	f245 4202 	movw	r2, #21506	@ 0x5402
3419c79e:	601a      	str	r2, [r3, #0]
                                                UX_DEVICE_CLASS_STORAGE_SENSE_STATUS(0x02,0x54,0x00);

            /* Return an error.  */
            return(UX_ERROR);
3419c7a0:	23ff      	movs	r3, #255	@ 0xff
3419c7a2:	e025      	b.n	3419c7f0 <_ux_device_class_storage_read+0x210>

        }

        /* Update the LBA address.  */
        lba += number_blocks;
3419c7a4:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
3419c7a6:	69bb      	ldr	r3, [r7, #24]
3419c7a8:	4413      	add	r3, r2
3419c7aa:	637b      	str	r3, [r7, #52]	@ 0x34
        
        /* Update the length to remain.  */
        total_length -= transfer_length;        
3419c7ac:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
3419c7ae:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419c7b0:	1ad3      	subs	r3, r2, r3
3419c7b2:	62fb      	str	r3, [r7, #44]	@ 0x2c
        done_length += transfer_length;
3419c7b4:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
3419c7b6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419c7b8:	4413      	add	r3, r2
3419c7ba:	627b      	str	r3, [r7, #36]	@ 0x24
        
        /* Update the number of blocks to read.  */
        total_number_blocks -= number_blocks;
3419c7bc:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
3419c7be:	69bb      	ldr	r3, [r7, #24]
3419c7c0:	1ad3      	subs	r3, r2, r3
3419c7c2:	633b      	str	r3, [r7, #48]	@ 0x30
    while (total_number_blocks)
3419c7c4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3419c7c6:	2b00      	cmp	r3, #0
3419c7c8:	f47f af59 	bne.w	3419c67e <_ux_device_class_storage_read+0x9e>
    }

    /* Case (4), (5). Host length too large.  */
    if (storage -> ux_slave_class_storage_host_length > done_length)
3419c7cc:	68fb      	ldr	r3, [r7, #12]
3419c7ce:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3419c7d0:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
3419c7d2:	429a      	cmp	r2, r3
3419c7d4:	d208      	bcs.n	3419c7e8 <_ux_device_class_storage_read+0x208>
    {

        /* Stall Bulk-In.  */
        _ux_device_stack_endpoint_stall(endpoint_in);
3419c7d6:	6878      	ldr	r0, [r7, #4]
3419c7d8:	f7fe fce2 	bl	3419b1a0 <_ux_device_stack_endpoint_stall>

        /* Update residure.  */
        storage -> ux_slave_class_storage_csw_residue = storage -> ux_slave_class_storage_host_length - done_length;
3419c7dc:	68fb      	ldr	r3, [r7, #12]
3419c7de:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
3419c7e0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419c7e2:	1ad2      	subs	r2, r2, r3
3419c7e4:	68fb      	ldr	r3, [r7, #12]
3419c7e6:	64da      	str	r2, [r3, #76]	@ 0x4c
    }

#endif /* else defined(UX_DEVICE_STANDALONE) */

    /* Now we set the CSW with success.  */
    storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_PASSED;
3419c7e8:	68fb      	ldr	r3, [r7, #12]
3419c7ea:	2200      	movs	r2, #0
3419c7ec:	651a      	str	r2, [r3, #80]	@ 0x50

    /* Return completion status.  */
    return(UX_SUCCESS);
3419c7ee:	2300      	movs	r3, #0
}
3419c7f0:	4618      	mov	r0, r3
3419c7f2:	373c      	adds	r7, #60	@ 0x3c
3419c7f4:	46bd      	mov	sp, r7
3419c7f6:	bd90      	pop	{r4, r7, pc}

3419c7f8 <_ux_device_class_storage_read_capacity>:
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_class_storage_read_capacity(UX_SLAVE_CLASS_STORAGE *storage, ULONG lun,
                                            UX_SLAVE_ENDPOINT *endpoint_in,
                                            UX_SLAVE_ENDPOINT *endpoint_out, UCHAR * cbwcb)
{
3419c7f8:	b590      	push	{r4, r7, lr}
3419c7fa:	b089      	sub	sp, #36	@ 0x24
3419c7fc:	af00      	add	r7, sp, #0
3419c7fe:	60f8      	str	r0, [r7, #12]
3419c800:	60b9      	str	r1, [r7, #8]
3419c802:	607a      	str	r2, [r7, #4]
3419c804:	603b      	str	r3, [r7, #0]

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_CLASS_STORAGE_READ_CAPACITY, storage, lun, 0, 0, UX_TRACE_DEVICE_CLASS_EVENTS, 0, 0)

    /* Obtain the status of the device.  */
    status =  storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_status(storage, lun, 
3419c806:	68f9      	ldr	r1, [r7, #12]
3419c808:	68bb      	ldr	r3, [r7, #8]
3419c80a:	1c5a      	adds	r2, r3, #1
3419c80c:	4613      	mov	r3, r2
3419c80e:	00db      	lsls	r3, r3, #3
3419c810:	1a9b      	subs	r3, r3, r2
3419c812:	00db      	lsls	r3, r3, #3
3419c814:	440b      	add	r3, r1
3419c816:	681c      	ldr	r4, [r3, #0]
3419c818:	68f9      	ldr	r1, [r7, #12]
3419c81a:	68ba      	ldr	r2, [r7, #8]
3419c81c:	4613      	mov	r3, r2
3419c81e:	00db      	lsls	r3, r3, #3
3419c820:	1a9b      	subs	r3, r3, r2
3419c822:	00db      	lsls	r3, r3, #3
3419c824:	440b      	add	r3, r1
3419c826:	331c      	adds	r3, #28
3419c828:	681a      	ldr	r2, [r3, #0]
3419c82a:	f107 0310 	add.w	r3, r7, #16
3419c82e:	68b9      	ldr	r1, [r7, #8]
3419c830:	68f8      	ldr	r0, [r7, #12]
3419c832:	47a0      	blx	r4
3419c834:	61f8      	str	r0, [r7, #28]
                                storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_id, &media_status);

    /* Update the request sense.  */
    storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_request_sense_status = media_status;
3419c836:	6939      	ldr	r1, [r7, #16]
3419c838:	68f8      	ldr	r0, [r7, #12]
3419c83a:	68ba      	ldr	r2, [r7, #8]
3419c83c:	4613      	mov	r3, r2
3419c83e:	00db      	lsls	r3, r3, #3
3419c840:	1a9b      	subs	r3, r3, r2
3419c842:	00db      	lsls	r3, r3, #3
3419c844:	4403      	add	r3, r0
3419c846:	3320      	adds	r3, #32
3419c848:	6019      	str	r1, [r3, #0]

    /* Check the status for error.  */
    if (status != UX_SUCCESS)
3419c84a:	69fb      	ldr	r3, [r7, #28]
3419c84c:	2b00      	cmp	r3, #0
3419c84e:	d008      	beq.n	3419c862 <_ux_device_class_storage_read_capacity+0x6a>
    {

#if !defined(UX_DEVICE_STANDALONE)

        /* We need to STALL the IN endpoint.  The endpoint will be reset by the host.  */
        _ux_device_stack_endpoint_stall(endpoint_in);
3419c850:	6878      	ldr	r0, [r7, #4]
3419c852:	f7fe fca5 	bl	3419b1a0 <_ux_device_stack_endpoint_stall>
#endif

        /* Now we set the CSW with Error.  */
        storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_FAILED;
3419c856:	68fb      	ldr	r3, [r7, #12]
3419c858:	2201      	movs	r2, #1
3419c85a:	651a      	str	r2, [r3, #80]	@ 0x50
        status = UX_SUCCESS;
3419c85c:	2300      	movs	r3, #0
3419c85e:	61fb      	str	r3, [r7, #28]
3419c860:	e02f      	b.n	3419c8c2 <_ux_device_class_storage_read_capacity+0xca>
    }
    else
    {
    
        /* Obtain the pointer to the transfer request.  */
        transfer_request =  &endpoint_in -> ux_slave_endpoint_transfer_request;
3419c862:	687b      	ldr	r3, [r7, #4]
3419c864:	3320      	adds	r3, #32
3419c866:	61bb      	str	r3, [r7, #24]

        /* Obtain read capacity response buffer.  */
        read_capacity_buffer = transfer_request -> ux_slave_transfer_request_data_pointer;
3419c868:	69bb      	ldr	r3, [r7, #24]
3419c86a:	68db      	ldr	r3, [r3, #12]
3419c86c:	617b      	str	r3, [r7, #20]
    
        /* Ensure it is cleaned.  */
        _ux_utility_memory_set(read_capacity_buffer, 0, UX_SLAVE_CLASS_STORAGE_READ_CAPACITY_RESPONSE_LENGTH); /* Use case of memcpy is verified. */
3419c86e:	2208      	movs	r2, #8
3419c870:	2100      	movs	r1, #0
3419c872:	6978      	ldr	r0, [r7, #20]
3419c874:	f7fd fab8 	bl	34199de8 <_ux_utility_memory_set>
    
        /* Insert the last LBA address in the response.  */
        _ux_utility_long_put_big_endian(&read_capacity_buffer[UX_SLAVE_CLASS_STORAGE_READ_CAPACITY_RESPONSE_LAST_LBA],
3419c878:	68f9      	ldr	r1, [r7, #12]
3419c87a:	68ba      	ldr	r2, [r7, #8]
3419c87c:	4613      	mov	r3, r2
3419c87e:	00db      	lsls	r3, r3, #3
3419c880:	1a9b      	subs	r3, r3, r2
3419c882:	00db      	lsls	r3, r3, #3
3419c884:	440b      	add	r3, r1
3419c886:	3308      	adds	r3, #8
3419c888:	681b      	ldr	r3, [r3, #0]
3419c88a:	4619      	mov	r1, r3
3419c88c:	6978      	ldr	r0, [r7, #20]
3419c88e:	f7fc ffd5 	bl	3419983c <_ux_utility_long_put_big_endian>
                                        storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_last_lba);
    
        /* Insert the block length in the response.  */
        _ux_utility_long_put_big_endian(&read_capacity_buffer[UX_SLAVE_CLASS_STORAGE_READ_CAPACITY_RESPONSE_BLOCK_SIZE],
3419c892:	697b      	ldr	r3, [r7, #20]
3419c894:	1d18      	adds	r0, r3, #4
3419c896:	68f9      	ldr	r1, [r7, #12]
3419c898:	68ba      	ldr	r2, [r7, #8]
3419c89a:	4613      	mov	r3, r2
3419c89c:	00db      	lsls	r3, r3, #3
3419c89e:	1a9b      	subs	r3, r3, r2
3419c8a0:	00db      	lsls	r3, r3, #3
3419c8a2:	440b      	add	r3, r1
3419c8a4:	330c      	adds	r3, #12
3419c8a6:	681b      	ldr	r3, [r3, #0]
3419c8a8:	4619      	mov	r1, r3
3419c8aa:	f7fc ffc7 	bl	3419983c <_ux_utility_long_put_big_endian>
        UX_SLAVE_TRANSFER_STATE_RESET(storage -> ux_device_class_storage_transfer);

#else

        /* Send a data payload with the read_capacity response buffer.  */
        _ux_device_stack_transfer_request(transfer_request, 
3419c8ae:	2208      	movs	r2, #8
3419c8b0:	2108      	movs	r1, #8
3419c8b2:	69b8      	ldr	r0, [r7, #24]
3419c8b4:	f7ff f926 	bl	3419bb04 <_ux_device_stack_transfer_request>
                                      UX_SLAVE_CLASS_STORAGE_READ_CAPACITY_RESPONSE_LENGTH,
                                      UX_SLAVE_CLASS_STORAGE_READ_CAPACITY_RESPONSE_LENGTH);
#endif

        /* Now we set the CSW with success.  */
        storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_PASSED;
3419c8b8:	68fb      	ldr	r3, [r7, #12]
3419c8ba:	2200      	movs	r2, #0
3419c8bc:	651a      	str	r2, [r3, #80]	@ 0x50
        status = UX_SUCCESS;
3419c8be:	2300      	movs	r3, #0
3419c8c0:	61fb      	str	r3, [r7, #28]
    }
        
    /* Return completion status.  */
    return(status);
3419c8c2:	69fb      	ldr	r3, [r7, #28]
}
3419c8c4:	4618      	mov	r0, r3
3419c8c6:	3724      	adds	r7, #36	@ 0x24
3419c8c8:	46bd      	mov	sp, r7
3419c8ca:	bd90      	pop	{r4, r7, pc}

3419c8cc <_ux_device_class_storage_read_format_capacity>:
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_class_storage_read_format_capacity(UX_SLAVE_CLASS_STORAGE *storage, ULONG lun,
                                            UX_SLAVE_ENDPOINT *endpoint_in,
                                            UX_SLAVE_ENDPOINT *endpoint_out, UCHAR * cbwcb)
{
3419c8cc:	b580      	push	{r7, lr}
3419c8ce:	b088      	sub	sp, #32
3419c8d0:	af00      	add	r7, sp, #0
3419c8d2:	60f8      	str	r0, [r7, #12]
3419c8d4:	60b9      	str	r1, [r7, #8]
3419c8d6:	607a      	str	r2, [r7, #4]
3419c8d8:	603b      	str	r3, [r7, #0]

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_CLASS_STORAGE_READ_FORMAT_CAPACITY, storage, lun, 0, 0, UX_TRACE_DEVICE_CLASS_EVENTS, 0, 0)

    /* Obtain the pointer to the transfer request.  */
    transfer_request =  &endpoint_in -> ux_slave_endpoint_transfer_request;
3419c8da:	687b      	ldr	r3, [r7, #4]
3419c8dc:	3320      	adds	r3, #32
3419c8de:	61fb      	str	r3, [r7, #28]

    /* Get read format capacity response buffer.  */
    read_format_capacity_buffer = transfer_request -> ux_slave_transfer_request_data_pointer;
3419c8e0:	69fb      	ldr	r3, [r7, #28]
3419c8e2:	68db      	ldr	r3, [r3, #12]
3419c8e4:	61bb      	str	r3, [r7, #24]

    /* Ensure it is cleaned.  */
    _ux_utility_memory_set(read_format_capacity_buffer, 0, UX_SLAVE_CLASS_STORAGE_READ_FORMAT_CAPACITY_RESPONSE_LENGTH); /* Use case of memset is verified. */
3419c8e6:	220c      	movs	r2, #12
3419c8e8:	2100      	movs	r1, #0
3419c8ea:	69b8      	ldr	r0, [r7, #24]
3419c8ec:	f7fd fa7c 	bl	34199de8 <_ux_utility_memory_set>

    /* Insert the size of the response block.  */
    _ux_utility_long_put_big_endian(&read_format_capacity_buffer[UX_SLAVE_CLASS_STORAGE_READ_FORMAT_CAPACITY_RESPONSE_SIZE], 8);
3419c8f0:	2108      	movs	r1, #8
3419c8f2:	69b8      	ldr	r0, [r7, #24]
3419c8f4:	f7fc ffa2 	bl	3419983c <_ux_utility_long_put_big_endian>

    /* Insert the last LBA address in the response.  */
    _ux_utility_long_put_big_endian(&read_format_capacity_buffer[UX_SLAVE_CLASS_STORAGE_READ_FORMAT_CAPACITY_RESPONSE_LAST_LBA],
3419c8f8:	69bb      	ldr	r3, [r7, #24]
3419c8fa:	1d18      	adds	r0, r3, #4
3419c8fc:	68f9      	ldr	r1, [r7, #12]
3419c8fe:	68ba      	ldr	r2, [r7, #8]
3419c900:	4613      	mov	r3, r2
3419c902:	00db      	lsls	r3, r3, #3
3419c904:	1a9b      	subs	r3, r3, r2
3419c906:	00db      	lsls	r3, r3, #3
3419c908:	440b      	add	r3, r1
3419c90a:	3308      	adds	r3, #8
3419c90c:	681b      	ldr	r3, [r3, #0]
3419c90e:	4619      	mov	r1, r3
3419c910:	f7fc ff94 	bl	3419983c <_ux_utility_long_put_big_endian>
                                    storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_last_lba);

    /* Insert the block length in the response.  This is in 3 bytes. */
    _ux_utility_long_put_big_endian(&read_format_capacity_buffer[UX_SLAVE_CLASS_STORAGE_READ_FORMAT_CAPACITY_RESPONSE_BLOCK_SIZE],
3419c914:	69bb      	ldr	r3, [r7, #24]
3419c916:	f103 0008 	add.w	r0, r3, #8
3419c91a:	68f9      	ldr	r1, [r7, #12]
3419c91c:	68ba      	ldr	r2, [r7, #8]
3419c91e:	4613      	mov	r3, r2
3419c920:	00db      	lsls	r3, r3, #3
3419c922:	1a9b      	subs	r3, r3, r2
3419c924:	00db      	lsls	r3, r3, #3
3419c926:	440b      	add	r3, r1
3419c928:	330c      	adds	r3, #12
3419c92a:	681b      	ldr	r3, [r3, #0]
3419c92c:	4619      	mov	r1, r3
3419c92e:	f7fc ff85 	bl	3419983c <_ux_utility_long_put_big_endian>
                                    storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_block_length);

    /* Insert the response code : always 2.  */
    read_format_capacity_buffer[UX_SLAVE_CLASS_STORAGE_READ_FORMAT_CAPACITY_RESPONSE_DESC_CODE] =  2;    
3419c932:	69bb      	ldr	r3, [r7, #24]
3419c934:	3308      	adds	r3, #8
3419c936:	2202      	movs	r2, #2
3419c938:	701a      	strb	r2, [r3, #0]
    UX_SLAVE_TRANSFER_STATE_RESET(storage -> ux_device_class_storage_transfer);

#else

    /* Send a data payload with the read_capacity response buffer.  */
    _ux_device_stack_transfer_request(transfer_request, 
3419c93a:	220c      	movs	r2, #12
3419c93c:	210c      	movs	r1, #12
3419c93e:	69f8      	ldr	r0, [r7, #28]
3419c940:	f7ff f8e0 	bl	3419bb04 <_ux_device_stack_transfer_request>
                                  UX_SLAVE_CLASS_STORAGE_READ_FORMAT_CAPACITY_RESPONSE_LENGTH,
                                  UX_SLAVE_CLASS_STORAGE_READ_FORMAT_CAPACITY_RESPONSE_LENGTH);
#endif

    /* Now we set the CSW with success.  */
    storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_PASSED;
3419c944:	68fb      	ldr	r3, [r7, #12]
3419c946:	2200      	movs	r2, #0
3419c948:	651a      	str	r2, [r3, #80]	@ 0x50
    status = UX_SUCCESS;
3419c94a:	2300      	movs	r3, #0
3419c94c:	617b      	str	r3, [r7, #20]

    /* Return completion status.  */
    return(status);
3419c94e:	697b      	ldr	r3, [r7, #20]
}
3419c950:	4618      	mov	r0, r3
3419c952:	3720      	adds	r7, #32
3419c954:	46bd      	mov	sp, r7
3419c956:	bd80      	pop	{r7, pc}

3419c958 <_ux_device_class_storage_request_sense>:
/*                                            resulting in version 6.3.0  */
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_class_storage_request_sense(UX_SLAVE_CLASS_STORAGE *storage, ULONG lun, UX_SLAVE_ENDPOINT *endpoint_in,
                                            UX_SLAVE_ENDPOINT *endpoint_out, UCHAR * cbwcb)
{
3419c958:	b580      	push	{r7, lr}
3419c95a:	b08a      	sub	sp, #40	@ 0x28
3419c95c:	af00      	add	r7, sp, #0
3419c95e:	60f8      	str	r0, [r7, #12]
3419c960:	60b9      	str	r1, [r7, #8]
3419c962:	607a      	str	r2, [r7, #4]
3419c964:	603b      	str	r3, [r7, #0]

UINT                    status = UX_SUCCESS;
3419c966:	2300      	movs	r3, #0
3419c968:	623b      	str	r3, [r7, #32]

    /* Build option check.  */
    UX_ASSERT(UX_SLAVE_CLASS_STORAGE_BUFFER_SIZE >= UX_SLAVE_CLASS_STORAGE_REQUEST_SENSE_RESPONSE_LENGTH);

    /* Obtain the pointer to the transfer request.  */
    transfer_request =  &endpoint_in -> ux_slave_endpoint_transfer_request;
3419c96a:	687b      	ldr	r3, [r7, #4]
3419c96c:	3320      	adds	r3, #32
3419c96e:	61fb      	str	r3, [r7, #28]

    /* Get length.  */
    sense_length = storage -> ux_slave_class_storage_host_length;
3419c970:	68fb      	ldr	r3, [r7, #12]
3419c972:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3419c974:	627b      	str	r3, [r7, #36]	@ 0x24
    if (sense_length > UX_SLAVE_CLASS_STORAGE_REQUEST_SENSE_RESPONSE_LENGTH)
3419c976:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419c978:	2b12      	cmp	r3, #18
3419c97a:	d901      	bls.n	3419c980 <_ux_device_class_storage_request_sense+0x28>
        sense_length = UX_SLAVE_CLASS_STORAGE_REQUEST_SENSE_RESPONSE_LENGTH;
3419c97c:	2312      	movs	r3, #18
3419c97e:	627b      	str	r3, [r7, #36]	@ 0x24

    /* Obtain sense buffer.  */
    sense_buffer = transfer_request -> ux_slave_transfer_request_data_pointer;
3419c980:	69fb      	ldr	r3, [r7, #28]
3419c982:	68db      	ldr	r3, [r3, #12]
3419c984:	61bb      	str	r3, [r7, #24]

    /* Ensure it is cleaned.  */
    _ux_utility_memory_set(sense_buffer, 0, sense_length); /* Use case of memset is verified. */
3419c986:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
3419c988:	2100      	movs	r1, #0
3419c98a:	69b8      	ldr	r0, [r7, #24]
3419c98c:	f7fd fa2c 	bl	34199de8 <_ux_utility_memory_set>
    
    /* Initialize the response buffer with the error code.  */
    sense_buffer[UX_SLAVE_CLASS_STORAGE_REQUEST_SENSE_RESPONSE_ERROR_CODE] = 
3419c990:	69bb      	ldr	r3, [r7, #24]
3419c992:	2270      	movs	r2, #112	@ 0x70
3419c994:	701a      	strb	r2, [r3, #0]
                    UX_SLAVE_CLASS_STORAGE_REQUEST_SENSE_RESPONSE_ERROR_CODE_VALUE;

    /* Extract sense key, code, qualifier.  */
    key = UX_DEVICE_CLASS_STORAGE_SENSE_KEY(storage -> ux_slave_class_storage_lun[lun].
3419c996:	68f9      	ldr	r1, [r7, #12]
3419c998:	68ba      	ldr	r2, [r7, #8]
3419c99a:	4613      	mov	r3, r2
3419c99c:	00db      	lsls	r3, r3, #3
3419c99e:	1a9b      	subs	r3, r3, r2
3419c9a0:	00db      	lsls	r3, r3, #3
3419c9a2:	440b      	add	r3, r1
3419c9a4:	3320      	adds	r3, #32
3419c9a6:	681b      	ldr	r3, [r3, #0]
3419c9a8:	75fb      	strb	r3, [r7, #23]
                                            ux_slave_class_storage_request_sense_status);
    code = UX_DEVICE_CLASS_STORAGE_SENSE_CODE(storage -> ux_slave_class_storage_lun[lun].
3419c9aa:	68f9      	ldr	r1, [r7, #12]
3419c9ac:	68ba      	ldr	r2, [r7, #8]
3419c9ae:	4613      	mov	r3, r2
3419c9b0:	00db      	lsls	r3, r3, #3
3419c9b2:	1a9b      	subs	r3, r3, r2
3419c9b4:	00db      	lsls	r3, r3, #3
3419c9b6:	440b      	add	r3, r1
3419c9b8:	3320      	adds	r3, #32
3419c9ba:	681b      	ldr	r3, [r3, #0]
3419c9bc:	0a1b      	lsrs	r3, r3, #8
3419c9be:	75bb      	strb	r3, [r7, #22]
                                            ux_slave_class_storage_request_sense_status);
    qualifier = UX_DEVICE_CLASS_STORAGE_SENSE_QUALIFIER(storage -> ux_slave_class_storage_lun[lun].
3419c9c0:	68f9      	ldr	r1, [r7, #12]
3419c9c2:	68ba      	ldr	r2, [r7, #8]
3419c9c4:	4613      	mov	r3, r2
3419c9c6:	00db      	lsls	r3, r3, #3
3419c9c8:	1a9b      	subs	r3, r3, r2
3419c9ca:	00db      	lsls	r3, r3, #3
3419c9cc:	440b      	add	r3, r1
3419c9ce:	3320      	adds	r3, #32
3419c9d0:	681b      	ldr	r3, [r3, #0]
3419c9d2:	0c1b      	lsrs	r3, r3, #16
3419c9d4:	757b      	strb	r3, [r7, #21]
                                            ux_slave_class_storage_request_sense_status);

    /* Initialize the response buffer with the sense key.  */
    sense_buffer[UX_SLAVE_CLASS_STORAGE_REQUEST_SENSE_RESPONSE_SENSE_KEY] = key;
3419c9d6:	69bb      	ldr	r3, [r7, #24]
3419c9d8:	3302      	adds	r3, #2
3419c9da:	7dfa      	ldrb	r2, [r7, #23]
3419c9dc:	701a      	strb	r2, [r3, #0]

    /* Initialize the response buffer with the code.  */
    sense_buffer[UX_SLAVE_CLASS_STORAGE_REQUEST_SENSE_RESPONSE_CODE] = code;
3419c9de:	69bb      	ldr	r3, [r7, #24]
3419c9e0:	330c      	adds	r3, #12
3419c9e2:	7dba      	ldrb	r2, [r7, #22]
3419c9e4:	701a      	strb	r2, [r3, #0]

    /* Initialize the response buffer with the code qualifier.  */
    sense_buffer[UX_SLAVE_CLASS_STORAGE_REQUEST_SENSE_RESPONSE_CODE_QUALIFIER] = qualifier;
3419c9e6:	69bb      	ldr	r3, [r7, #24]
3419c9e8:	330d      	adds	r3, #13
3419c9ea:	7d7a      	ldrb	r2, [r7, #21]
3419c9ec:	701a      	strb	r2, [r3, #0]
    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_CLASS_STORAGE_REQUEST_SENSE, storage, lun, 
                            key, code, UX_TRACE_DEVICE_CLASS_EVENTS, 0, 0)

    /* Initialize the response buffer with the additional length.  */
    sense_buffer[UX_SLAVE_CLASS_STORAGE_REQUEST_SENSE_RESPONSE_ADD_LENGTH] =  10;
3419c9ee:	69bb      	ldr	r3, [r7, #24]
3419c9f0:	3307      	adds	r3, #7
3419c9f2:	220a      	movs	r2, #10
3419c9f4:	701a      	strb	r2, [r3, #0]
    storage -> ux_device_class_storage_data_count = 0;

#else

    /* Send a data payload with the sense codes.  */
    if (sense_length)
3419c9f6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419c9f8:	2b00      	cmp	r3, #0
3419c9fa:	d004      	beq.n	3419ca06 <_ux_device_class_storage_request_sense+0xae>
        _ux_device_stack_transfer_request(transfer_request, sense_length, sense_length);
3419c9fc:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
3419c9fe:	6a79      	ldr	r1, [r7, #36]	@ 0x24
3419ca00:	69f8      	ldr	r0, [r7, #28]
3419ca02:	f7ff f87f 	bl	3419bb04 <_ux_device_stack_transfer_request>

    /* Check length.  */
    if (storage -> ux_slave_class_storage_host_length != sense_length)
3419ca06:	68fb      	ldr	r3, [r7, #12]
3419ca08:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3419ca0a:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
3419ca0c:	429a      	cmp	r2, r3
3419ca0e:	d005      	beq.n	3419ca1c <_ux_device_class_storage_request_sense+0xc4>
    {
        _ux_device_stack_endpoint_stall(endpoint_in);
3419ca10:	6878      	ldr	r0, [r7, #4]
3419ca12:	f7fe fbc5 	bl	3419b1a0 <_ux_device_stack_endpoint_stall>
        storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_PHASE_ERROR;
3419ca16:	68fb      	ldr	r3, [r7, #12]
3419ca18:	2202      	movs	r2, #2
3419ca1a:	651a      	str	r2, [r3, #80]	@ 0x50
    }
#endif

    /* Return completion status.  */    
    return(status);
3419ca1c:	6a3b      	ldr	r3, [r7, #32]
}
3419ca1e:	4618      	mov	r0, r3
3419ca20:	3728      	adds	r7, #40	@ 0x28
3419ca22:	46bd      	mov	sp, r7
3419ca24:	bd80      	pop	{r7, pc}

3419ca26 <_ux_device_class_storage_start_stop>:
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_class_storage_start_stop(UX_SLAVE_CLASS_STORAGE *storage, ULONG lun, 
                                            UX_SLAVE_ENDPOINT *endpoint_in,
                                            UX_SLAVE_ENDPOINT *endpoint_out, UCHAR * cbwcb)
{
3419ca26:	b480      	push	{r7}
3419ca28:	b085      	sub	sp, #20
3419ca2a:	af00      	add	r7, sp, #0
3419ca2c:	60f8      	str	r0, [r7, #12]
3419ca2e:	60b9      	str	r1, [r7, #8]
3419ca30:	607a      	str	r2, [r7, #4]
3419ca32:	603b      	str	r3, [r7, #0]

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_CLASS_STORAGE_START_STOP, storage, lun, 0, 0, UX_TRACE_DEVICE_CLASS_EVENTS, 0, 0)

    /* We set the CSW with success.  */
    storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_PASSED;
3419ca34:	68fb      	ldr	r3, [r7, #12]
3419ca36:	2200      	movs	r2, #0
3419ca38:	651a      	str	r2, [r3, #80]	@ 0x50

    /* Return successful completion.  */
    return(UX_SUCCESS);
3419ca3a:	2300      	movs	r3, #0
}
3419ca3c:	4618      	mov	r0, r3
3419ca3e:	3714      	adds	r7, #20
3419ca40:	46bd      	mov	sp, r7
3419ca42:	f85d 7b04 	ldr.w	r7, [sp], #4
3419ca46:	4770      	bx	lr

3419ca48 <_ux_device_class_storage_synchronize_cache>:
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_class_storage_synchronize_cache(UX_SLAVE_CLASS_STORAGE *storage, ULONG lun, 
                                                 UX_SLAVE_ENDPOINT *endpoint_in,
                                                 UX_SLAVE_ENDPOINT *endpoint_out, UCHAR *cbwcb, UCHAR scsi_command)
{
3419ca48:	b590      	push	{r4, r7, lr}
3419ca4a:	b08d      	sub	sp, #52	@ 0x34
3419ca4c:	af02      	add	r7, sp, #8
3419ca4e:	60f8      	str	r0, [r7, #12]
3419ca50:	60b9      	str	r1, [r7, #8]
3419ca52:	607a      	str	r2, [r7, #4]
3419ca54:	603b      	str	r3, [r7, #0]

    UX_PARAMETER_NOT_USED(endpoint_out);
    UX_PARAMETER_NOT_USED(scsi_command);

    /* By default status is passed.  */
    storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_PASSED;
3419ca56:	68fb      	ldr	r3, [r7, #12]
3419ca58:	2200      	movs	r2, #0
3419ca5a:	651a      	str	r2, [r3, #80]	@ 0x50

    /* Is there not an implementation?  */
    if (storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_flush == UX_NULL)
3419ca5c:	68f9      	ldr	r1, [r7, #12]
3419ca5e:	68ba      	ldr	r2, [r7, #8]
3419ca60:	4613      	mov	r3, r2
3419ca62:	00db      	lsls	r3, r3, #3
3419ca64:	1a9b      	subs	r3, r3, r2
3419ca66:	00db      	lsls	r3, r3, #3
3419ca68:	440b      	add	r3, r1
3419ca6a:	3334      	adds	r3, #52	@ 0x34
3419ca6c:	681b      	ldr	r3, [r3, #0]
3419ca6e:	2b00      	cmp	r3, #0
3419ca70:	d101      	bne.n	3419ca76 <_ux_device_class_storage_synchronize_cache+0x2e>
    {

        /* This means the application is not using a cache.  */

        /* Return success.  */
        return(UX_SUCCESS);
3419ca72:	2300      	movs	r3, #0
3419ca74:	e07b      	b.n	3419cb6e <_ux_device_class_storage_synchronize_cache+0x126>
    }

    /* Get the LBA and number of blocks from the CBWCB in 16 bits.  */
    lba           =         _ux_utility_long_get_big_endian(cbwcb + UX_SLAVE_CLASS_STORAGE_SYNCHRONIZE_CACHE_LBA);
3419ca76:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419ca78:	3302      	adds	r3, #2
3419ca7a:	4618      	mov	r0, r3
3419ca7c:	f7fc fe93 	bl	341997a6 <_ux_utility_long_get_big_endian>
3419ca80:	6278      	str	r0, [r7, #36]	@ 0x24
    number_blocks = (USHORT)_ux_utility_short_get_big_endian(cbwcb + UX_SLAVE_CLASS_STORAGE_SYNCHRONIZE_CACHE_NUMBER_OF_BLOCKS);
3419ca82:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419ca84:	3307      	adds	r3, #7
3419ca86:	4618      	mov	r0, r3
3419ca88:	f7fd fa86 	bl	34199f98 <_ux_utility_short_get_big_endian>
3419ca8c:	4603      	mov	r3, r0
3419ca8e:	847b      	strh	r3, [r7, #34]	@ 0x22

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_CLASS_STORAGE_SYNCHRONIZE_CACHE, storage, lun, lba, number_blocks, UX_TRACE_DEVICE_CLASS_EVENTS, 0, 0)

    /* Obtain the status of the device.  */
    status =  storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_status(storage, 
3419ca90:	68f9      	ldr	r1, [r7, #12]
3419ca92:	68bb      	ldr	r3, [r7, #8]
3419ca94:	1c5a      	adds	r2, r3, #1
3419ca96:	4613      	mov	r3, r2
3419ca98:	00db      	lsls	r3, r3, #3
3419ca9a:	1a9b      	subs	r3, r3, r2
3419ca9c:	00db      	lsls	r3, r3, #3
3419ca9e:	440b      	add	r3, r1
3419caa0:	681c      	ldr	r4, [r3, #0]
3419caa2:	68f9      	ldr	r1, [r7, #12]
3419caa4:	68ba      	ldr	r2, [r7, #8]
3419caa6:	4613      	mov	r3, r2
3419caa8:	00db      	lsls	r3, r3, #3
3419caaa:	1a9b      	subs	r3, r3, r2
3419caac:	00db      	lsls	r3, r3, #3
3419caae:	440b      	add	r3, r1
3419cab0:	331c      	adds	r3, #28
3419cab2:	681a      	ldr	r2, [r3, #0]
3419cab4:	f107 0314 	add.w	r3, r7, #20
3419cab8:	68b9      	ldr	r1, [r7, #8]
3419caba:	68f8      	ldr	r0, [r7, #12]
3419cabc:	47a0      	blx	r4
3419cabe:	61f8      	str	r0, [r7, #28]
                            lun, storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_id, &media_status);

    /* Update the request sense.  */
    storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_request_sense_status = media_status;
3419cac0:	6979      	ldr	r1, [r7, #20]
3419cac2:	68f8      	ldr	r0, [r7, #12]
3419cac4:	68ba      	ldr	r2, [r7, #8]
3419cac6:	4613      	mov	r3, r2
3419cac8:	00db      	lsls	r3, r3, #3
3419caca:	1a9b      	subs	r3, r3, r2
3419cacc:	00db      	lsls	r3, r3, #3
3419cace:	4403      	add	r3, r0
3419cad0:	3320      	adds	r3, #32
3419cad2:	6019      	str	r1, [r3, #0]

    /* If there is a problem, return a failed command.  */
    if (status != UX_SUCCESS)
3419cad4:	69fb      	ldr	r3, [r7, #28]
3419cad6:	2b00      	cmp	r3, #0
3419cad8:	d007      	beq.n	3419caea <_ux_device_class_storage_synchronize_cache+0xa2>
    {

        /* We have a problem, media status error. Return a bad completion and wait for the
           REQUEST_SENSE command.  */
#if !defined(UX_DEVICE_STANDALONE)
        _ux_device_stack_endpoint_stall(endpoint_in);
3419cada:	6878      	ldr	r0, [r7, #4]
3419cadc:	f7fe fb60 	bl	3419b1a0 <_ux_device_stack_endpoint_stall>
#else
        UX_PARAMETER_NOT_USED(endpoint_in);
        storage -> ux_device_class_storage_cmd_state = UX_DEVICE_CLASS_STORAGE_CMD_ERR;
#endif

        storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_FAILED;
3419cae0:	68fb      	ldr	r3, [r7, #12]
3419cae2:	2201      	movs	r2, #1
3419cae4:	651a      	str	r2, [r3, #80]	@ 0x50

        /* We are done here.  */
        return(UX_ERROR);
3419cae6:	23ff      	movs	r3, #255	@ 0xff
3419cae8:	e041      	b.n	3419cb6e <_ux_device_class_storage_synchronize_cache+0x126>
    storage -> ux_device_class_storage_cmd_n_lb = number_blocks;

#else

    /* Get the flags.  */
    flags =  *(cbwcb + UX_SLAVE_CLASS_STORAGE_SYNCHRONIZE_CACHE_FLAGS);
3419caea:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419caec:	785b      	ldrb	r3, [r3, #1]
3419caee:	76fb      	strb	r3, [r7, #27]

    /* If the immediate bit is set, we return a CSW before flush.  */
    if ((flags & UX_SLAVE_CLASS_STORAGE_SYNCHRONIZE_CACHE_FLAGS_IMMED) != 0)
3419caf0:	7efb      	ldrb	r3, [r7, #27]
3419caf2:	f003 0302 	and.w	r3, r3, #2
3419caf6:	2b00      	cmp	r3, #0
3419caf8:	d005      	beq.n	3419cb06 <_ux_device_class_storage_synchronize_cache+0xbe>
        _ux_device_class_storage_csw_send(storage, lun, endpoint_in, UX_SLAVE_CLASS_STORAGE_CSW_PASSED);
3419cafa:	2300      	movs	r3, #0
3419cafc:	687a      	ldr	r2, [r7, #4]
3419cafe:	68b9      	ldr	r1, [r7, #8]
3419cb00:	68f8      	ldr	r0, [r7, #12]
3419cb02:	f7ff f929 	bl	3419bd58 <_ux_device_class_storage_csw_send>

    /* Send the flush command to the local media.  */
    status =  storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_flush(storage, lun, number_blocks, lba, &media_status);
3419cb06:	68f9      	ldr	r1, [r7, #12]
3419cb08:	68ba      	ldr	r2, [r7, #8]
3419cb0a:	4613      	mov	r3, r2
3419cb0c:	00db      	lsls	r3, r3, #3
3419cb0e:	1a9b      	subs	r3, r3, r2
3419cb10:	00db      	lsls	r3, r3, #3
3419cb12:	440b      	add	r3, r1
3419cb14:	3334      	adds	r3, #52	@ 0x34
3419cb16:	681c      	ldr	r4, [r3, #0]
3419cb18:	8c7a      	ldrh	r2, [r7, #34]	@ 0x22
3419cb1a:	f107 0314 	add.w	r3, r7, #20
3419cb1e:	9300      	str	r3, [sp, #0]
3419cb20:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419cb22:	68b9      	ldr	r1, [r7, #8]
3419cb24:	68f8      	ldr	r0, [r7, #12]
3419cb26:	47a0      	blx	r4
3419cb28:	61f8      	str	r0, [r7, #28]

    /* Update the request sense.  */
    storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_request_sense_status = media_status;
3419cb2a:	6979      	ldr	r1, [r7, #20]
3419cb2c:	68f8      	ldr	r0, [r7, #12]
3419cb2e:	68ba      	ldr	r2, [r7, #8]
3419cb30:	4613      	mov	r3, r2
3419cb32:	00db      	lsls	r3, r3, #3
3419cb34:	1a9b      	subs	r3, r3, r2
3419cb36:	00db      	lsls	r3, r3, #3
3419cb38:	4403      	add	r3, r0
3419cb3a:	3320      	adds	r3, #32
3419cb3c:	6019      	str	r1, [r3, #0]

    /* If the immediate bit is set, we are already done, no matter what local operation status is.  */
    if ((flags & UX_SLAVE_CLASS_STORAGE_SYNCHRONIZE_CACHE_FLAGS_IMMED) != 0)
3419cb3e:	7efb      	ldrb	r3, [r7, #27]
3419cb40:	f003 0302 	and.w	r3, r3, #2
3419cb44:	2b00      	cmp	r3, #0
3419cb46:	d006      	beq.n	3419cb56 <_ux_device_class_storage_synchronize_cache+0x10e>
    {

        /* CSW skipped since already sent in this function.  */
        UX_DEVICE_CLASS_STORAGE_CSW_SKIP(&storage -> ux_slave_class_storage_csw_status) = UX_TRUE;
3419cb48:	68fb      	ldr	r3, [r7, #12]
3419cb4a:	3350      	adds	r3, #80	@ 0x50
3419cb4c:	3303      	adds	r3, #3
3419cb4e:	2201      	movs	r2, #1
3419cb50:	701a      	strb	r2, [r3, #0]
        return(status);
3419cb52:	69fb      	ldr	r3, [r7, #28]
3419cb54:	e00b      	b.n	3419cb6e <_ux_device_class_storage_synchronize_cache+0x126>
    }

    /* If there is a problem, return a failed command.  */
    if (status != UX_SUCCESS)
3419cb56:	69fb      	ldr	r3, [r7, #28]
3419cb58:	2b00      	cmp	r3, #0
3419cb5a:	d007      	beq.n	3419cb6c <_ux_device_class_storage_synchronize_cache+0x124>
    {

        /* We have a problem, request error. Return a bad completion and wait for the
           REQUEST_SENSE command.  */
        _ux_device_stack_endpoint_stall(endpoint_in);
3419cb5c:	6878      	ldr	r0, [r7, #4]
3419cb5e:	f7fe fb1f 	bl	3419b1a0 <_ux_device_stack_endpoint_stall>

        storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_FAILED;
3419cb62:	68fb      	ldr	r3, [r7, #12]
3419cb64:	2201      	movs	r2, #1
3419cb66:	651a      	str	r2, [r3, #80]	@ 0x50

        /* Return an error.  */
        return(UX_ERROR);
3419cb68:	23ff      	movs	r3, #255	@ 0xff
3419cb6a:	e000      	b.n	3419cb6e <_ux_device_class_storage_synchronize_cache+0x126>
    }
#endif

    /* Return completion status.  */
    return(status);
3419cb6c:	69fb      	ldr	r3, [r7, #28]
}
3419cb6e:	4618      	mov	r0, r3
3419cb70:	372c      	adds	r7, #44	@ 0x2c
3419cb72:	46bd      	mov	sp, r7
3419cb74:	bd90      	pop	{r4, r7, pc}

3419cb76 <_ux_device_class_storage_test_ready>:
/*                                            resulting in version 6.1.10 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_class_storage_test_ready(UX_SLAVE_CLASS_STORAGE *storage, ULONG lun, UX_SLAVE_ENDPOINT *endpoint_in,
                                          UX_SLAVE_ENDPOINT *endpoint_out, UCHAR * cbwcb)
{
3419cb76:	b590      	push	{r4, r7, lr}
3419cb78:	b087      	sub	sp, #28
3419cb7a:	af00      	add	r7, sp, #0
3419cb7c:	60f8      	str	r0, [r7, #12]
3419cb7e:	60b9      	str	r1, [r7, #8]
3419cb80:	607a      	str	r2, [r7, #4]
3419cb82:	603b      	str	r3, [r7, #0]

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_CLASS_STORAGE_TEST_READY, storage, lun, 0, 0, UX_TRACE_DEVICE_CLASS_EVENTS, 0, 0)

    /* Obtain the status of the device.  */
    status =  storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_status(storage, lun, 
3419cb84:	68f9      	ldr	r1, [r7, #12]
3419cb86:	68bb      	ldr	r3, [r7, #8]
3419cb88:	1c5a      	adds	r2, r3, #1
3419cb8a:	4613      	mov	r3, r2
3419cb8c:	00db      	lsls	r3, r3, #3
3419cb8e:	1a9b      	subs	r3, r3, r2
3419cb90:	00db      	lsls	r3, r3, #3
3419cb92:	440b      	add	r3, r1
3419cb94:	681c      	ldr	r4, [r3, #0]
3419cb96:	68f9      	ldr	r1, [r7, #12]
3419cb98:	68ba      	ldr	r2, [r7, #8]
3419cb9a:	4613      	mov	r3, r2
3419cb9c:	00db      	lsls	r3, r3, #3
3419cb9e:	1a9b      	subs	r3, r3, r2
3419cba0:	00db      	lsls	r3, r3, #3
3419cba2:	440b      	add	r3, r1
3419cba4:	331c      	adds	r3, #28
3419cba6:	681a      	ldr	r2, [r3, #0]
3419cba8:	f107 0310 	add.w	r3, r7, #16
3419cbac:	68b9      	ldr	r1, [r7, #8]
3419cbae:	68f8      	ldr	r0, [r7, #12]
3419cbb0:	47a0      	blx	r4
3419cbb2:	6178      	str	r0, [r7, #20]
                                storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_id, &media_status);

    /* Set the sense/code/qualifier codes for the REQUEST_SENSE command.  */
    storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_request_sense_status = media_status;
3419cbb4:	6939      	ldr	r1, [r7, #16]
3419cbb6:	68f8      	ldr	r0, [r7, #12]
3419cbb8:	68ba      	ldr	r2, [r7, #8]
3419cbba:	4613      	mov	r3, r2
3419cbbc:	00db      	lsls	r3, r3, #3
3419cbbe:	1a9b      	subs	r3, r3, r2
3419cbc0:	00db      	lsls	r3, r3, #3
3419cbc2:	4403      	add	r3, r0
3419cbc4:	3320      	adds	r3, #32
3419cbc6:	6019      	str	r1, [r3, #0]

    /* Return CSW with success/error.  */
    storage -> ux_slave_class_storage_csw_status = (status == UX_SUCCESS) ?
                            UX_SLAVE_CLASS_STORAGE_CSW_PASSED : UX_SLAVE_CLASS_STORAGE_CSW_FAILED;
3419cbc8:	697b      	ldr	r3, [r7, #20]
3419cbca:	2b00      	cmp	r3, #0
3419cbcc:	bf14      	ite	ne
3419cbce:	2301      	movne	r3, #1
3419cbd0:	2300      	moveq	r3, #0
3419cbd2:	b2db      	uxtb	r3, r3
3419cbd4:	461a      	mov	r2, r3
    storage -> ux_slave_class_storage_csw_status = (status == UX_SUCCESS) ?
3419cbd6:	68fb      	ldr	r3, [r7, #12]
3419cbd8:	651a      	str	r2, [r3, #80]	@ 0x50
    status = UX_SUCCESS;
3419cbda:	2300      	movs	r3, #0
3419cbdc:	617b      	str	r3, [r7, #20]

#if !defined(UX_DEVICE_STANDALONE)

    /* Case (9) Ho > Dn.  */
    if (storage -> ux_slave_class_storage_host_length)
3419cbde:	68fb      	ldr	r3, [r7, #12]
3419cbe0:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3419cbe2:	2b00      	cmp	r3, #0
3419cbe4:	d006      	beq.n	3419cbf4 <_ux_device_class_storage_test_ready+0x7e>
    {
        _ux_device_stack_endpoint_stall(endpoint_out);
3419cbe6:	6838      	ldr	r0, [r7, #0]
3419cbe8:	f7fe fada 	bl	3419b1a0 <_ux_device_stack_endpoint_stall>
        storage -> ux_slave_class_storage_csw_residue = storage -> ux_slave_class_storage_host_length;
3419cbec:	68fb      	ldr	r3, [r7, #12]
3419cbee:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
3419cbf0:	68fb      	ldr	r3, [r7, #12]
3419cbf2:	64da      	str	r2, [r3, #76]	@ 0x4c
    }
#endif

    /* Return completion status.  */
    return(status);
3419cbf4:	697b      	ldr	r3, [r7, #20]
}
3419cbf6:	4618      	mov	r0, r3
3419cbf8:	371c      	adds	r7, #28
3419cbfa:	46bd      	mov	sp, r7
3419cbfc:	bd90      	pop	{r4, r7, pc}
	...

3419cc00 <_ux_device_class_storage_thread>:
/*                                            endpoint buffer in classes, */
/*                                            resulting in version 6.3.0  */
/*                                                                        */
/**************************************************************************/
VOID  _ux_device_class_storage_thread(ULONG storage_class)
{
3419cc00:	b580      	push	{r7, lr}
3419cc02:	b092      	sub	sp, #72	@ 0x48
3419cc04:	af02      	add	r7, sp, #8
3419cc06:	6078      	str	r0, [r7, #4]
    /* This thread runs forever but can be suspended or resumed.  */
    while(1)
    {

        /* Cast properly the storage instance.  */
        UX_THREAD_EXTENSION_PTR_GET(class_ptr, UX_SLAVE_CLASS, storage_class)
3419cc08:	687b      	ldr	r3, [r7, #4]
3419cc0a:	633b      	str	r3, [r7, #48]	@ 0x30
        
        /* Get the storage instance from this class container.  */
        storage =  (UX_SLAVE_CLASS_STORAGE *) class_ptr -> ux_slave_class_instance;
3419cc0c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3419cc0e:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3419cc10:	62fb      	str	r3, [r7, #44]	@ 0x2c
    
        /* Get the pointer to the device.  */
        device =  &_ux_system_slave -> ux_system_slave_device;
3419cc12:	4bb9      	ldr	r3, [pc, #740]	@ (3419cef8 <_ux_device_class_storage_thread+0x2f8>)
3419cc14:	681b      	ldr	r3, [r3, #0]
3419cc16:	3320      	adds	r3, #32
3419cc18:	62bb      	str	r3, [r7, #40]	@ 0x28
        
        /* As long as the device is in the CONFIGURED state.  */
        while (device -> ux_slave_device_state == UX_DEVICE_CONFIGURED)
3419cc1a:	e238      	b.n	3419d08e <_ux_device_class_storage_thread+0x48e>
        { 

            /* We are activated. We need the interface to the class.  */
            interface_ptr =  storage -> ux_slave_class_storage_interface;
3419cc1c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3419cc1e:	681b      	ldr	r3, [r3, #0]
3419cc20:	627b      	str	r3, [r7, #36]	@ 0x24

            /* We assume the worst situation.  */
            status =  UX_ERROR;
3419cc22:	23ff      	movs	r3, #255	@ 0xff
3419cc24:	637b      	str	r3, [r7, #52]	@ 0x34

            /* Locate the endpoints.  */
            endpoint_in =  interface_ptr -> ux_slave_interface_first_endpoint;
3419cc26:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419cc28:	69db      	ldr	r3, [r3, #28]
3419cc2a:	63fb      	str	r3, [r7, #60]	@ 0x3c

            /* Check the endpoint direction, if IN we have the correct endpoint.  */
            if ((endpoint_in -> ux_slave_endpoint_descriptor.bEndpointAddress & UX_ENDPOINT_DIRECTION) != UX_ENDPOINT_IN)
3419cc2c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3419cc2e:	7b9b      	ldrb	r3, [r3, #14]
3419cc30:	b25b      	sxtb	r3, r3
3419cc32:	2b00      	cmp	r3, #0
3419cc34:	db05      	blt.n	3419cc42 <_ux_device_class_storage_thread+0x42>
            {

                /* Wrong direction, we found the OUT endpoint first.  */
                endpoint_out =  endpoint_in;
3419cc36:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3419cc38:	63bb      	str	r3, [r7, #56]	@ 0x38

                /* So the next endpoint has to be the IN endpoint.  */
                endpoint_in =  endpoint_out -> ux_slave_endpoint_next_endpoint;
3419cc3a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419cc3c:	695b      	ldr	r3, [r3, #20]
3419cc3e:	63fb      	str	r3, [r7, #60]	@ 0x3c
3419cc40:	e002      	b.n	3419cc48 <_ux_device_class_storage_thread+0x48>
            }
            else
            {

                /* We found the endpoint IN first, so next endpoint is OUT.  */
                endpoint_out =  endpoint_in -> ux_slave_endpoint_next_endpoint;
3419cc42:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3419cc44:	695b      	ldr	r3, [r3, #20]
3419cc46:	63bb      	str	r3, [r7, #56]	@ 0x38
                    ux_slave_transfer_request_data_pointer =
                            UX_DEVICE_CLASS_STORAGE_BULKIN_BUFFER(storage);
#endif

            /* All SCSI commands are on the endpoint OUT, from the host.  */
            transfer_request =  &endpoint_out -> ux_slave_endpoint_transfer_request;
3419cc48:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419cc4a:	3320      	adds	r3, #32
3419cc4c:	623b      	str	r3, [r7, #32]

            /* Check state, they must be both RESET.  */
            if (endpoint_out -> ux_slave_endpoint_state == UX_ENDPOINT_RESET &&
3419cc4e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419cc50:	685b      	ldr	r3, [r3, #4]
3419cc52:	2b00      	cmp	r3, #0
3419cc54:	d10a      	bne.n	3419cc6c <_ux_device_class_storage_thread+0x6c>
                (UCHAR)storage -> ux_slave_class_storage_csw_status != UX_SLAVE_CLASS_STORAGE_CSW_PHASE_ERROR)
3419cc56:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3419cc58:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
3419cc5a:	b2db      	uxtb	r3, r3
            if (endpoint_out -> ux_slave_endpoint_state == UX_ENDPOINT_RESET &&
3419cc5c:	2b02      	cmp	r3, #2
3419cc5e:	d005      	beq.n	3419cc6c <_ux_device_class_storage_thread+0x6c>
            {

                /* Send the request to the device controller.  */
                status =  _ux_device_stack_transfer_request(transfer_request, 64, 64);
3419cc60:	2240      	movs	r2, #64	@ 0x40
3419cc62:	2140      	movs	r1, #64	@ 0x40
3419cc64:	6a38      	ldr	r0, [r7, #32]
3419cc66:	f7fe ff4d 	bl	3419bb04 <_ux_device_stack_transfer_request>
3419cc6a:	6378      	str	r0, [r7, #52]	@ 0x34

            }                
    
            /* Check the status. Our status is UX_ERROR if one of the endpoint was STALLED. We must wait for the host
               to clear the mess.   */    
            if (status == UX_SUCCESS)
3419cc6c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
3419cc6e:	2b00      	cmp	r3, #0
3419cc70:	f040 81fd 	bne.w	3419d06e <_ux_device_class_storage_thread+0x46e>
            {

                /* Obtain the length of the transaction.  */
                length =  transfer_request -> ux_slave_transfer_request_actual_length;
3419cc74:	6a3b      	ldr	r3, [r7, #32]
3419cc76:	699b      	ldr	r3, [r3, #24]
3419cc78:	61fb      	str	r3, [r7, #28]
                
                /* Obtain the buffer address containing the SCSI command.  */
                scsi_command =  transfer_request -> ux_slave_transfer_request_data_pointer;
3419cc7a:	6a3b      	ldr	r3, [r7, #32]
3419cc7c:	68db      	ldr	r3, [r3, #12]
3419cc7e:	61bb      	str	r3, [r7, #24]
                
                /* Obtain the lun from the CBW.  */
                lun =  (ULONG) *(scsi_command + UX_SLAVE_CLASS_STORAGE_CBW_LUN);
3419cc80:	69bb      	ldr	r3, [r7, #24]
3419cc82:	330d      	adds	r3, #13
3419cc84:	781b      	ldrb	r3, [r3, #0]
3419cc86:	617b      	str	r3, [r7, #20]
                storage -> ux_slave_class_storage_cbw_lun = (UCHAR)lun;
3419cc88:	697b      	ldr	r3, [r7, #20]
3419cc8a:	b2da      	uxtb	r2, r3
3419cc8c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3419cc8e:	f883 2045 	strb.w	r2, [r3, #69]	@ 0x45
                
                /* We have to memorize the SCSI command tag for the CSW phase.  */
                storage -> ux_slave_class_storage_scsi_tag =  _ux_utility_long_get(scsi_command + UX_SLAVE_CLASS_STORAGE_CBW_TAG);
3419cc92:	69bb      	ldr	r3, [r7, #24]
3419cc94:	3304      	adds	r3, #4
3419cc96:	4618      	mov	r0, r3
3419cc98:	f7fc fd5f 	bl	3419975a <_ux_utility_long_get>
3419cc9c:	4602      	mov	r2, r0
3419cc9e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3419cca0:	649a      	str	r2, [r3, #72]	@ 0x48

                /* Get dCBWDataTransferLength: number of bytes to transfer.  */
                storage -> ux_slave_class_storage_host_length = _ux_utility_long_get(scsi_command + UX_SLAVE_CLASS_STORAGE_CBW_DATA_LENGTH);
3419cca2:	69bb      	ldr	r3, [r7, #24]
3419cca4:	3308      	adds	r3, #8
3419cca6:	4618      	mov	r0, r3
3419cca8:	f7fc fd57 	bl	3419975a <_ux_utility_long_get>
3419ccac:	4602      	mov	r2, r0
3419ccae:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3419ccb0:	641a      	str	r2, [r3, #64]	@ 0x40

                /* Save bmCBWFlags.  */
                storage -> ux_slave_class_storage_cbw_flags = *(scsi_command + UX_SLAVE_CLASS_STORAGE_CBW_FLAGS);
3419ccb2:	69bb      	ldr	r3, [r7, #24]
3419ccb4:	7b1a      	ldrb	r2, [r3, #12]
3419ccb6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3419ccb8:	f883 2044 	strb.w	r2, [r3, #68]	@ 0x44

                /* Reset CSW status.  */
                storage -> ux_slave_class_storage_csw_residue = 0;
3419ccbc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3419ccbe:	2200      	movs	r2, #0
3419ccc0:	64da      	str	r2, [r3, #76]	@ 0x4c
                storage -> ux_slave_class_storage_csw_status = 0;
3419ccc2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3419ccc4:	2200      	movs	r2, #0
3419ccc6:	651a      	str	r2, [r3, #80]	@ 0x50

                /* Ensure the LUN number is within our declared values and check the command 
                   content and format. First we make sure we have a complete CBW.  */
                if ((lun < storage -> ux_slave_class_storage_number_lun) && (length == UX_SLAVE_CLASS_STORAGE_CBW_LENGTH))
3419ccc8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3419ccca:	685b      	ldr	r3, [r3, #4]
3419cccc:	697a      	ldr	r2, [r7, #20]
3419ccce:	429a      	cmp	r2, r3
3419ccd0:	f080 81c9 	bcs.w	3419d066 <_ux_device_class_storage_thread+0x466>
3419ccd4:	69fb      	ldr	r3, [r7, #28]
3419ccd6:	2b1f      	cmp	r3, #31
3419ccd8:	f040 81c5 	bne.w	3419d066 <_ux_device_class_storage_thread+0x466>
                {

                    /* The length of the CBW is correct, analyze the header.  */
                    if (_ux_utility_long_get(scsi_command) == UX_SLAVE_CLASS_STORAGE_CBW_SIGNATURE_MASK)
3419ccdc:	69b8      	ldr	r0, [r7, #24]
3419ccde:	f7fc fd3c 	bl	3419975a <_ux_utility_long_get>
3419cce2:	4603      	mov	r3, r0
3419cce4:	4a85      	ldr	r2, [pc, #532]	@ (3419cefc <_ux_device_class_storage_thread+0x2fc>)
3419cce6:	4293      	cmp	r3, r2
3419cce8:	f040 81b9 	bne.w	3419d05e <_ux_device_class_storage_thread+0x45e>
                    {

                        /* Get the length of the CBWCB.  */
                        cbwcb_length =  (ULONG) *(scsi_command + UX_SLAVE_CLASS_STORAGE_CBW_CB_LENGTH);
3419ccec:	69bb      	ldr	r3, [r7, #24]
3419ccee:	330e      	adds	r3, #14
3419ccf0:	781b      	ldrb	r3, [r3, #0]
3419ccf2:	613b      	str	r3, [r7, #16]
    
                        /* Check the length of the CBWCB to ensure there is at least a command.  */
                        if (cbwcb_length != 0)
3419ccf4:	693b      	ldr	r3, [r7, #16]
3419ccf6:	2b00      	cmp	r3, #0
3419ccf8:	f000 81ad 	beq.w	3419d056 <_ux_device_class_storage_thread+0x456>
                        {

                            /* Analyze the command stored in the CBWCB.  */
                            cbw_cb = scsi_command + UX_SLAVE_CLASS_STORAGE_CBW_CB;
3419ccfc:	69bb      	ldr	r3, [r7, #24]
3419ccfe:	330f      	adds	r3, #15
3419cd00:	60fb      	str	r3, [r7, #12]
                            switch (*(cbw_cb))
3419cd02:	68fb      	ldr	r3, [r7, #12]
3419cd04:	781b      	ldrb	r3, [r3, #0]
3419cd06:	2baa      	cmp	r3, #170	@ 0xaa
3419cd08:	f000 8146 	beq.w	3419cf98 <_ux_device_class_storage_thread+0x398>
3419cd0c:	2baa      	cmp	r3, #170	@ 0xaa
3419cd0e:	f300 8165 	bgt.w	3419cfdc <_ux_device_class_storage_thread+0x3dc>
3419cd12:	2b5a      	cmp	r3, #90	@ 0x5a
3419cd14:	f300 80c0 	bgt.w	3419ce98 <_ux_device_class_storage_thread+0x298>
3419cd18:	2b00      	cmp	r3, #0
3419cd1a:	f2c0 815f 	blt.w	3419cfdc <_ux_device_class_storage_thread+0x3dc>
3419cd1e:	2b5a      	cmp	r3, #90	@ 0x5a
3419cd20:	f200 815c 	bhi.w	3419cfdc <_ux_device_class_storage_thread+0x3dc>
3419cd24:	a201      	add	r2, pc, #4	@ (adr r2, 3419cd2c <_ux_device_class_storage_thread+0x12c>)
3419cd26:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3419cd2a:	bf00      	nop
3419cd2c:	3419ce9f 	.word	0x3419ce9f
3419cd30:	3419cfdd 	.word	0x3419cfdd
3419cd34:	3419cfdd 	.word	0x3419cfdd
3419cd38:	3419ceb1 	.word	0x3419ceb1
3419cd3c:	3419cec3 	.word	0x3419cec3
3419cd40:	3419cfdd 	.word	0x3419cfdd
3419cd44:	3419cfdd 	.word	0x3419cfdd
3419cd48:	3419cfdd 	.word	0x3419cfdd
3419cd4c:	3419cfdd 	.word	0x3419cfdd
3419cd50:	3419cfdd 	.word	0x3419cfdd
3419cd54:	3419cfdd 	.word	0x3419cfdd
3419cd58:	3419cfdd 	.word	0x3419cfdd
3419cd5c:	3419cfdd 	.word	0x3419cfdd
3419cd60:	3419cfdd 	.word	0x3419cfdd
3419cd64:	3419cfdd 	.word	0x3419cfdd
3419cd68:	3419cfdd 	.word	0x3419cfdd
3419cd6c:	3419cfdd 	.word	0x3419cfdd
3419cd70:	3419cfdd 	.word	0x3419cfdd
3419cd74:	3419ced5 	.word	0x3419ced5
3419cd78:	3419cfdd 	.word	0x3419cfdd
3419cd7c:	3419cfdd 	.word	0x3419cfdd
3419cd80:	3419cfdd 	.word	0x3419cfdd
3419cd84:	3419cfdd 	.word	0x3419cfdd
3419cd88:	3419cfdd 	.word	0x3419cfdd
3419cd8c:	3419cfdd 	.word	0x3419cfdd
3419cd90:	3419cfdd 	.word	0x3419cfdd
3419cd94:	3419cf5b 	.word	0x3419cf5b
3419cd98:	3419cee7 	.word	0x3419cee7
3419cd9c:	3419cfdd 	.word	0x3419cfdd
3419cda0:	3419cfdd 	.word	0x3419cfdd
3419cda4:	3419cf01 	.word	0x3419cf01
3419cda8:	3419cfdd 	.word	0x3419cfdd
3419cdac:	3419cfdd 	.word	0x3419cfdd
3419cdb0:	3419cfdd 	.word	0x3419cfdd
3419cdb4:	3419cfdd 	.word	0x3419cfdd
3419cdb8:	3419cf13 	.word	0x3419cf13
3419cdbc:	3419cfdd 	.word	0x3419cfdd
3419cdc0:	3419cf25 	.word	0x3419cf25
3419cdc4:	3419cfdd 	.word	0x3419cfdd
3419cdc8:	3419cfdd 	.word	0x3419cfdd
3419cdcc:	3419cf83 	.word	0x3419cf83
3419cdd0:	3419cfdd 	.word	0x3419cfdd
3419cdd4:	3419cfaf 	.word	0x3419cfaf
3419cdd8:	3419cfdd 	.word	0x3419cfdd
3419cddc:	3419cfdd 	.word	0x3419cfdd
3419cde0:	3419cfdd 	.word	0x3419cfdd
3419cde4:	3419cfdd 	.word	0x3419cfdd
3419cde8:	3419cf37 	.word	0x3419cf37
3419cdec:	3419cfdd 	.word	0x3419cfdd
3419cdf0:	3419cfdd 	.word	0x3419cfdd
3419cdf4:	3419cfdd 	.word	0x3419cfdd
3419cdf8:	3419cfdd 	.word	0x3419cfdd
3419cdfc:	3419cfdd 	.word	0x3419cfdd
3419ce00:	3419cfc5 	.word	0x3419cfc5
3419ce04:	3419cfdd 	.word	0x3419cfdd
3419ce08:	3419cfdd 	.word	0x3419cfdd
3419ce0c:	3419cfdd 	.word	0x3419cfdd
3419ce10:	3419cfdd 	.word	0x3419cfdd
3419ce14:	3419cfdd 	.word	0x3419cfdd
3419ce18:	3419cfdd 	.word	0x3419cfdd
3419ce1c:	3419cfdd 	.word	0x3419cfdd
3419ce20:	3419cfdd 	.word	0x3419cfdd
3419ce24:	3419cfdd 	.word	0x3419cfdd
3419ce28:	3419cfdd 	.word	0x3419cfdd
3419ce2c:	3419cfdd 	.word	0x3419cfdd
3419ce30:	3419cfdd 	.word	0x3419cfdd
3419ce34:	3419cfdd 	.word	0x3419cfdd
3419ce38:	3419cfdd 	.word	0x3419cfdd
3419ce3c:	3419cfdd 	.word	0x3419cfdd
3419ce40:	3419cfdd 	.word	0x3419cfdd
3419ce44:	3419cfdd 	.word	0x3419cfdd
3419ce48:	3419cfdd 	.word	0x3419cfdd
3419ce4c:	3419cfdd 	.word	0x3419cfdd
3419ce50:	3419cfdd 	.word	0x3419cfdd
3419ce54:	3419cfdd 	.word	0x3419cfdd
3419ce58:	3419cfdd 	.word	0x3419cfdd
3419ce5c:	3419cfdd 	.word	0x3419cfdd
3419ce60:	3419cfdd 	.word	0x3419cfdd
3419ce64:	3419cfdd 	.word	0x3419cfdd
3419ce68:	3419cfdd 	.word	0x3419cfdd
3419ce6c:	3419cfdd 	.word	0x3419cfdd
3419ce70:	3419cfdd 	.word	0x3419cfdd
3419ce74:	3419cfdd 	.word	0x3419cfdd
3419ce78:	3419cfdd 	.word	0x3419cfdd
3419ce7c:	3419cfdd 	.word	0x3419cfdd
3419ce80:	3419cf49 	.word	0x3419cf49
3419ce84:	3419cfdd 	.word	0x3419cfdd
3419ce88:	3419cfdd 	.word	0x3419cfdd
3419ce8c:	3419cfdd 	.word	0x3419cfdd
3419ce90:	3419cfdd 	.word	0x3419cfdd
3419ce94:	3419cf5b 	.word	0x3419cf5b
3419ce98:	2ba8      	cmp	r3, #168	@ 0xa8
3419ce9a:	d067      	beq.n	3419cf6c <_ux_device_class_storage_thread+0x36c>
3419ce9c:	e09e      	b.n	3419cfdc <_ux_device_class_storage_thread+0x3dc>
                            {

                            case UX_SLAVE_CLASS_STORAGE_SCSI_TEST_READY:

                                _ux_device_class_storage_test_ready(storage, lun, endpoint_in, endpoint_out, cbw_cb);
3419ce9e:	68fb      	ldr	r3, [r7, #12]
3419cea0:	9300      	str	r3, [sp, #0]
3419cea2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419cea4:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
3419cea6:	6979      	ldr	r1, [r7, #20]
3419cea8:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
3419ceaa:	f7ff fe64 	bl	3419cb76 <_ux_device_class_storage_test_ready>
                                break;
3419ceae:	e0c2      	b.n	3419d036 <_ux_device_class_storage_thread+0x436>
                                    
                            case UX_SLAVE_CLASS_STORAGE_SCSI_REQUEST_SENSE:

                                _ux_device_class_storage_request_sense(storage, lun, endpoint_in, endpoint_out, cbw_cb);
3419ceb0:	68fb      	ldr	r3, [r7, #12]
3419ceb2:	9300      	str	r3, [sp, #0]
3419ceb4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419ceb6:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
3419ceb8:	6979      	ldr	r1, [r7, #20]
3419ceba:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
3419cebc:	f7ff fd4c 	bl	3419c958 <_ux_device_class_storage_request_sense>
                                break;
3419cec0:	e0b9      	b.n	3419d036 <_ux_device_class_storage_thread+0x436>
    
                            case UX_SLAVE_CLASS_STORAGE_SCSI_FORMAT:

                                _ux_device_class_storage_format(storage, lun, endpoint_in, endpoint_out, cbw_cb);
3419cec2:	68fb      	ldr	r3, [r7, #12]
3419cec4:	9300      	str	r3, [sp, #0]
3419cec6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419cec8:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
3419ceca:	6979      	ldr	r1, [r7, #20]
3419cecc:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
3419cece:	f7ff f803 	bl	3419bed8 <_ux_device_class_storage_format>
                                break;
3419ced2:	e0b0      	b.n	3419d036 <_ux_device_class_storage_thread+0x436>
    
                            case UX_SLAVE_CLASS_STORAGE_SCSI_INQUIRY:

                                _ux_device_class_storage_inquiry(storage, lun, endpoint_in, endpoint_out, cbw_cb);
3419ced4:	68fb      	ldr	r3, [r7, #12]
3419ced6:	9300      	str	r3, [sp, #0]
3419ced8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419ceda:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
3419cedc:	6979      	ldr	r1, [r7, #20]
3419cede:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
3419cee0:	f7ff f9a4 	bl	3419c22c <_ux_device_class_storage_inquiry>
                                break;
3419cee4:	e0a7      	b.n	3419d036 <_ux_device_class_storage_thread+0x436>
    
                            case UX_SLAVE_CLASS_STORAGE_SCSI_START_STOP:

                                _ux_device_class_storage_start_stop(storage, lun, endpoint_in, endpoint_out, cbw_cb);
3419cee6:	68fb      	ldr	r3, [r7, #12]
3419cee8:	9300      	str	r3, [sp, #0]
3419ceea:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419ceec:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
3419ceee:	6979      	ldr	r1, [r7, #20]
3419cef0:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
3419cef2:	f7ff fd98 	bl	3419ca26 <_ux_device_class_storage_start_stop>
                                break;
3419cef6:	e09e      	b.n	3419d036 <_ux_device_class_storage_thread+0x436>
3419cef8:	341c33f8 	.word	0x341c33f8
3419cefc:	43425355 	.word	0x43425355
                                    
                            case UX_SLAVE_CLASS_STORAGE_SCSI_PREVENT_ALLOW_MEDIA_REMOVAL:

                                _ux_device_class_storage_prevent_allow_media_removal(storage, lun, endpoint_in, endpoint_out, cbw_cb);
3419cf00:	68fb      	ldr	r3, [r7, #12]
3419cf02:	9300      	str	r3, [sp, #0]
3419cf04:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419cf06:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
3419cf08:	6979      	ldr	r1, [r7, #20]
3419cf0a:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
3419cf0c:	f7ff fb57 	bl	3419c5be <_ux_device_class_storage_prevent_allow_media_removal>
                                break;
3419cf10:	e091      	b.n	3419d036 <_ux_device_class_storage_thread+0x436>
    
                            case UX_SLAVE_CLASS_STORAGE_SCSI_READ_FORMAT_CAPACITY:

                                _ux_device_class_storage_read_format_capacity(storage, lun, endpoint_in, endpoint_out, cbw_cb);
3419cf12:	68fb      	ldr	r3, [r7, #12]
3419cf14:	9300      	str	r3, [sp, #0]
3419cf16:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419cf18:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
3419cf1a:	6979      	ldr	r1, [r7, #20]
3419cf1c:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
3419cf1e:	f7ff fcd5 	bl	3419c8cc <_ux_device_class_storage_read_format_capacity>
                                break;
3419cf22:	e088      	b.n	3419d036 <_ux_device_class_storage_thread+0x436>
    
                            case UX_SLAVE_CLASS_STORAGE_SCSI_READ_CAPACITY:

                                _ux_device_class_storage_read_capacity(storage, lun, endpoint_in, endpoint_out, cbw_cb);
3419cf24:	68fb      	ldr	r3, [r7, #12]
3419cf26:	9300      	str	r3, [sp, #0]
3419cf28:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419cf2a:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
3419cf2c:	6979      	ldr	r1, [r7, #20]
3419cf2e:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
3419cf30:	f7ff fc62 	bl	3419c7f8 <_ux_device_class_storage_read_capacity>
                                break;
3419cf34:	e07f      	b.n	3419d036 <_ux_device_class_storage_thread+0x436>
    
                            case UX_SLAVE_CLASS_STORAGE_SCSI_VERIFY:

                                _ux_device_class_storage_verify(storage, lun, endpoint_in, endpoint_out, cbw_cb);
3419cf36:	68fb      	ldr	r3, [r7, #12]
3419cf38:	9300      	str	r3, [sp, #0]
3419cf3a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419cf3c:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
3419cf3e:	6979      	ldr	r1, [r7, #20]
3419cf40:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
3419cf42:	f000 f8cf 	bl	3419d0e4 <_ux_device_class_storage_verify>
                                break;
3419cf46:	e076      	b.n	3419d036 <_ux_device_class_storage_thread+0x436>
    
                            case UX_SLAVE_CLASS_STORAGE_SCSI_MODE_SELECT:

                                _ux_device_class_storage_mode_select(storage, lun, endpoint_in, endpoint_out, cbw_cb);
3419cf48:	68fb      	ldr	r3, [r7, #12]
3419cf4a:	9300      	str	r3, [sp, #0]
3419cf4c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419cf4e:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
3419cf50:	6979      	ldr	r1, [r7, #20]
3419cf52:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
3419cf54:	f7ff fa54 	bl	3419c400 <_ux_device_class_storage_mode_select>
                                break;
3419cf58:	e06d      	b.n	3419d036 <_ux_device_class_storage_thread+0x436>
    
                            case UX_SLAVE_CLASS_STORAGE_SCSI_MODE_SENSE_SHORT:
                            case UX_SLAVE_CLASS_STORAGE_SCSI_MODE_SENSE:

                                _ux_device_class_storage_mode_sense(storage, lun, endpoint_in, endpoint_out, cbw_cb);
3419cf5a:	68fb      	ldr	r3, [r7, #12]
3419cf5c:	9300      	str	r3, [sp, #0]
3419cf5e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419cf60:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
3419cf62:	6979      	ldr	r1, [r7, #20]
3419cf64:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
3419cf66:	f7ff fa77 	bl	3419c458 <_ux_device_class_storage_mode_sense>
                                break;
3419cf6a:	e064      	b.n	3419d036 <_ux_device_class_storage_thread+0x436>
    
                            case UX_SLAVE_CLASS_STORAGE_SCSI_READ32:

                                _ux_device_class_storage_read(storage, lun, endpoint_in, endpoint_out, cbw_cb, 
3419cf6c:	23a8      	movs	r3, #168	@ 0xa8
3419cf6e:	9301      	str	r3, [sp, #4]
3419cf70:	68fb      	ldr	r3, [r7, #12]
3419cf72:	9300      	str	r3, [sp, #0]
3419cf74:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419cf76:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
3419cf78:	6979      	ldr	r1, [r7, #20]
3419cf7a:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
3419cf7c:	f7ff fb30 	bl	3419c5e0 <_ux_device_class_storage_read>
                                                                UX_SLAVE_CLASS_STORAGE_SCSI_READ32);
                                break;
3419cf80:	e059      	b.n	3419d036 <_ux_device_class_storage_thread+0x436>
    
                            case UX_SLAVE_CLASS_STORAGE_SCSI_READ16:

                                _ux_device_class_storage_read(storage, lun, endpoint_in, endpoint_out, cbw_cb, 
3419cf82:	2328      	movs	r3, #40	@ 0x28
3419cf84:	9301      	str	r3, [sp, #4]
3419cf86:	68fb      	ldr	r3, [r7, #12]
3419cf88:	9300      	str	r3, [sp, #0]
3419cf8a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419cf8c:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
3419cf8e:	6979      	ldr	r1, [r7, #20]
3419cf90:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
3419cf92:	f7ff fb25 	bl	3419c5e0 <_ux_device_class_storage_read>
                                                                UX_SLAVE_CLASS_STORAGE_SCSI_READ16);
                                break;
3419cf96:	e04e      	b.n	3419d036 <_ux_device_class_storage_thread+0x436>
    
                            case UX_SLAVE_CLASS_STORAGE_SCSI_WRITE32:

                                _ux_device_class_storage_write(storage, lun, endpoint_in, endpoint_out, cbw_cb,
3419cf98:	23aa      	movs	r3, #170	@ 0xaa
3419cf9a:	9301      	str	r3, [sp, #4]
3419cf9c:	68fb      	ldr	r3, [r7, #12]
3419cf9e:	9300      	str	r3, [sp, #0]
3419cfa0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419cfa2:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
3419cfa4:	6979      	ldr	r1, [r7, #20]
3419cfa6:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
3419cfa8:	f000 f8ad 	bl	3419d106 <_ux_device_class_storage_write>
                                                                UX_SLAVE_CLASS_STORAGE_SCSI_WRITE32);
                                break;
3419cfac:	e043      	b.n	3419d036 <_ux_device_class_storage_thread+0x436>
    
                            case UX_SLAVE_CLASS_STORAGE_SCSI_WRITE16:

                                _ux_device_class_storage_write(storage, lun, endpoint_in, endpoint_out, cbw_cb, 
3419cfae:	232a      	movs	r3, #42	@ 0x2a
3419cfb0:	9301      	str	r3, [sp, #4]
3419cfb2:	68fb      	ldr	r3, [r7, #12]
3419cfb4:	9300      	str	r3, [sp, #0]
3419cfb6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419cfb8:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
3419cfba:	6979      	ldr	r1, [r7, #20]
3419cfbc:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
3419cfbe:	f000 f8a2 	bl	3419d106 <_ux_device_class_storage_write>
                                                                UX_SLAVE_CLASS_STORAGE_SCSI_WRITE16);
                                break;
3419cfc2:	e038      	b.n	3419d036 <_ux_device_class_storage_thread+0x436>

                            case UX_SLAVE_CLASS_STORAGE_SCSI_SYNCHRONIZE_CACHE:

                                _ux_device_class_storage_synchronize_cache(storage, lun, endpoint_in, endpoint_out, cbw_cb, *(cbw_cb));
3419cfc4:	68fb      	ldr	r3, [r7, #12]
3419cfc6:	781b      	ldrb	r3, [r3, #0]
3419cfc8:	9301      	str	r3, [sp, #4]
3419cfca:	68fb      	ldr	r3, [r7, #12]
3419cfcc:	9300      	str	r3, [sp, #0]
3419cfce:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419cfd0:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
3419cfd2:	6979      	ldr	r1, [r7, #20]
3419cfd4:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
3419cfd6:	f7ff fd37 	bl	3419ca48 <_ux_device_class_storage_synchronize_cache>
                                break;
3419cfda:	e02c      	b.n	3419d036 <_ux_device_class_storage_thread+0x436>
                            /* fall through */
                            default:
    
                                /* The command is unknown or unsupported, so we stall the endpoint.  */

                                if (storage -> ux_slave_class_storage_host_length > 0 &&
3419cfdc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3419cfde:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3419cfe0:	2b00      	cmp	r3, #0
3419cfe2:	d009      	beq.n	3419cff8 <_ux_device_class_storage_thread+0x3f8>
                                    ((storage -> ux_slave_class_storage_cbw_flags & 0x80) == 0))
3419cfe4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3419cfe6:	f893 3044 	ldrb.w	r3, [r3, #68]	@ 0x44
3419cfea:	b25b      	sxtb	r3, r3
                                if (storage -> ux_slave_class_storage_host_length > 0 &&
3419cfec:	2b00      	cmp	r3, #0
3419cfee:	db03      	blt.n	3419cff8 <_ux_device_class_storage_thread+0x3f8>

                                    /* Data-Out from host to device, stall OUT.  */
                                    _ux_device_stack_endpoint_stall(endpoint_out);
3419cff0:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
3419cff2:	f7fe f8d5 	bl	3419b1a0 <_ux_device_stack_endpoint_stall>
3419cff6:	e002      	b.n	3419cffe <_ux_device_class_storage_thread+0x3fe>
                                else

                                    /* Data-In from device to host, stall IN.  */
                                    _ux_device_stack_endpoint_stall(endpoint_in);
3419cff8:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
3419cffa:	f7fe f8d1 	bl	3419b1a0 <_ux_device_stack_endpoint_stall>
                                
                                /* Initialize the request sense keys.  */
                                storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_request_sense_status =
3419cffe:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
3419d000:	697a      	ldr	r2, [r7, #20]
3419d002:	4613      	mov	r3, r2
3419d004:	00db      	lsls	r3, r3, #3
3419d006:	1a9b      	subs	r3, r3, r2
3419d008:	00db      	lsls	r3, r3, #3
3419d00a:	440b      	add	r3, r1
3419d00c:	3320      	adds	r3, #32
3419d00e:	f242 0205 	movw	r2, #8197	@ 0x2005
3419d012:	601a      	str	r2, [r3, #0]
                                    UX_DEVICE_CLASS_STORAGE_SENSE_STATUS(UX_SLAVE_CLASS_STORAGE_SENSE_KEY_ILLEGAL_REQUEST,
                                                                         UX_SLAVE_CLASS_STORAGE_ASC_KEY_INVALID_COMMAND,0);

                                /* This is the tricky part of the SCSI state machine. We must send the CSW BUT need to wait
                                   for the endpoint_in to be reset by the host.  */
                                while (device -> ux_slave_device_state == UX_DEVICE_CONFIGURED)
3419d014:	e00a      	b.n	3419d02c <_ux_device_class_storage_thread+0x42c>
                                { 

                                    /* Check the endpoint state.  */
                                    if (endpoint_in -> ux_slave_endpoint_state == UX_ENDPOINT_RESET)
3419d016:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3419d018:	685b      	ldr	r3, [r3, #4]
3419d01a:	2b00      	cmp	r3, #0
3419d01c:	d104      	bne.n	3419d028 <_ux_device_class_storage_thread+0x428>
                                    {

                                        /* Now we set the CSW with failure.  */
                                        storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_FAILED;
3419d01e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3419d020:	2201      	movs	r2, #1
3419d022:	651a      	str	r2, [r3, #80]	@ 0x50
                                        break;
3419d024:	bf00      	nop
                                    else

                                        /* We must therefore wait a while.  */
                                        _ux_device_thread_relinquish();
                                }
                                break;
3419d026:	e005      	b.n	3419d034 <_ux_device_class_storage_thread+0x434>
                                        _ux_device_thread_relinquish();
3419d028:	f7fd f855 	bl	3419a0d6 <_ux_utility_thread_relinquish>
                                while (device -> ux_slave_device_state == UX_DEVICE_CONFIGURED)
3419d02c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419d02e:	681b      	ldr	r3, [r3, #0]
3419d030:	2b03      	cmp	r3, #3
3419d032:	d0f0      	beq.n	3419d016 <_ux_device_class_storage_thread+0x416>
                                break;
3419d034:	bf00      	nop
                            }

                            /* Send CSW if not SYNC_CACHE.  */
                            status = _ux_device_class_storage_csw_send(storage, lun, endpoint_in, 0 /* Don't care */);
3419d036:	2300      	movs	r3, #0
3419d038:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
3419d03a:	6979      	ldr	r1, [r7, #20]
3419d03c:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
3419d03e:	f7fe fe8b 	bl	3419bd58 <_ux_device_class_storage_csw_send>
3419d042:	6378      	str	r0, [r7, #52]	@ 0x34

                            /* Check error code. */
                            if (status != UX_SUCCESS)
3419d044:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
3419d046:	2b00      	cmp	r3, #0
3419d048:	d020      	beq.n	3419d08c <_ux_device_class_storage_thread+0x48c>

                                /* Error trap. */
                                _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_CLASS, status);
3419d04a:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
3419d04c:	2107      	movs	r1, #7
3419d04e:	2002      	movs	r0, #2
3419d050:	f7fc fa36 	bl	341994c0 <_ux_system_error_handler>
                    if (_ux_utility_long_get(scsi_command) == UX_SLAVE_CLASS_STORAGE_CBW_SIGNATURE_MASK)
3419d054:	e01a      	b.n	3419d08c <_ux_device_class_storage_thread+0x48c>
                        }
                        else

                            /* Phase error!  */
                            storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_PHASE_ERROR;
3419d056:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3419d058:	2202      	movs	r2, #2
3419d05a:	651a      	str	r2, [r3, #80]	@ 0x50
                    if (_ux_utility_long_get(scsi_command) == UX_SLAVE_CLASS_STORAGE_CBW_SIGNATURE_MASK)
3419d05c:	e016      	b.n	3419d08c <_ux_device_class_storage_thread+0x48c>
                    }
                    
                    else

                        /* Phase error!  */
                        storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_PHASE_ERROR;
3419d05e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3419d060:	2202      	movs	r2, #2
3419d062:	651a      	str	r2, [r3, #80]	@ 0x50
                    if (_ux_utility_long_get(scsi_command) == UX_SLAVE_CLASS_STORAGE_CBW_SIGNATURE_MASK)
3419d064:	e012      	b.n	3419d08c <_ux_device_class_storage_thread+0x48c>
                }
                else

                    /* Phase error!  */
                    storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_PHASE_ERROR;
3419d066:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3419d068:	2202      	movs	r2, #2
3419d06a:	651a      	str	r2, [r3, #80]	@ 0x50
3419d06c:	e00f      	b.n	3419d08e <_ux_device_class_storage_thread+0x48e>
            }
            else
            {

                if ((UCHAR)storage -> ux_slave_class_storage_csw_status == UX_SLAVE_CLASS_STORAGE_CSW_PHASE_ERROR)
3419d06e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3419d070:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
3419d072:	b2db      	uxtb	r3, r3
3419d074:	2b02      	cmp	r3, #2
3419d076:	d105      	bne.n	3419d084 <_ux_device_class_storage_thread+0x484>
                {

                    /* We should keep the endpoints stalled.  */
                    _ux_device_stack_endpoint_stall(endpoint_out);
3419d078:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
3419d07a:	f7fe f891 	bl	3419b1a0 <_ux_device_stack_endpoint_stall>
                    _ux_device_stack_endpoint_stall(endpoint_in);
3419d07e:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
3419d080:	f7fe f88e 	bl	3419b1a0 <_ux_device_stack_endpoint_stall>
                }

                /* We must therefore wait a while.  */
                _ux_utility_delay_ms(2);
3419d084:	2002      	movs	r0, #2
3419d086:	f7fc fafb 	bl	34199680 <_ux_utility_delay_ms>
3419d08a:	e000      	b.n	3419d08e <_ux_device_class_storage_thread+0x48e>
                    if (_ux_utility_long_get(scsi_command) == UX_SLAVE_CLASS_STORAGE_CBW_SIGNATURE_MASK)
3419d08c:	bf00      	nop
        while (device -> ux_slave_device_state == UX_DEVICE_CONFIGURED)
3419d08e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419d090:	681b      	ldr	r3, [r3, #0]
3419d092:	2b03      	cmp	r3, #3
3419d094:	f43f adc2 	beq.w	3419cc1c <_ux_device_class_storage_thread+0x1c>
            }
        }

        /* We need to suspend ourselves. We will be resumed by the 
           device enumeration module.  */
        _ux_device_thread_suspend(&class_ptr -> ux_slave_class_thread);
3419d098:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3419d09a:	3350      	adds	r3, #80	@ 0x50
3419d09c:	4618      	mov	r0, r3
3419d09e:	f7fd f82d 	bl	3419a0fc <_ux_utility_thread_suspend>
        UX_THREAD_EXTENSION_PTR_GET(class_ptr, UX_SLAVE_CLASS, storage_class)
3419d0a2:	e5b1      	b.n	3419cc08 <_ux_device_class_storage_thread+0x8>

3419d0a4 <_ux_device_class_storage_uninitialize>:
/*                                            endpoint buffer in classes, */
/*                                            resulting in version 6.3.0  */
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_class_storage_uninitialize(UX_SLAVE_CLASS_COMMAND *command)
{
3419d0a4:	b580      	push	{r7, lr}
3419d0a6:	b084      	sub	sp, #16
3419d0a8:	af00      	add	r7, sp, #0
3419d0aa:	6078      	str	r0, [r7, #4]
                                          
UX_SLAVE_CLASS_STORAGE                  *storage;
UX_SLAVE_CLASS                          *class_ptr;

    /* Get the class container.  */
    class_ptr =  command -> ux_slave_class_command_class_ptr;
3419d0ac:	687b      	ldr	r3, [r7, #4]
3419d0ae:	6a1b      	ldr	r3, [r3, #32]
3419d0b0:	60fb      	str	r3, [r7, #12]

    /* Get the class instance in the container.  */
    storage = (UX_SLAVE_CLASS_STORAGE *) class_ptr -> ux_slave_class_instance;
3419d0b2:	68fb      	ldr	r3, [r7, #12]
3419d0b4:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3419d0b6:	60bb      	str	r3, [r7, #8]
    
    /* Sanity check.  */
    if (storage != UX_NULL)
3419d0b8:	68bb      	ldr	r3, [r7, #8]
3419d0ba:	2b00      	cmp	r3, #0
3419d0bc:	d00d      	beq.n	3419d0da <_ux_device_class_storage_uninitialize+0x36>
    {

        /* Remove STORAGE thread.  */
        _ux_device_thread_delete(&class_ptr -> ux_slave_class_thread);
3419d0be:	68fb      	ldr	r3, [r7, #12]
3419d0c0:	3350      	adds	r3, #80	@ 0x50
3419d0c2:	4618      	mov	r0, r3
3419d0c4:	f7fc fff7 	bl	3419a0b6 <_ux_utility_thread_delete>

#if !(defined(UX_DEVICE_STANDALONE) || defined(UX_STANDALONE))    
        /* Remove the thread used by STORAGE.  */
        _ux_utility_memory_free(class_ptr -> ux_slave_class_thread_stack);
3419d0c8:	68fb      	ldr	r3, [r7, #12]
3419d0ca:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
3419d0ce:	4618      	mov	r0, r3
3419d0d0:	f7fc fe06 	bl	34199ce0 <_ux_utility_memory_free>
#if UX_DEVICE_ENDPOINT_BUFFER_OWNER == 1
        _ux_utility_memory_free(storage -> ux_device_class_storage_endpoint_buffer);
#endif

        /* Free the resources.  */
        _ux_utility_memory_free(storage);
3419d0d4:	68b8      	ldr	r0, [r7, #8]
3419d0d6:	f7fc fe03 	bl	34199ce0 <_ux_utility_memory_free>
    }
    
    /* Return completion status.  */
    return(UX_SUCCESS);
3419d0da:	2300      	movs	r3, #0
}
3419d0dc:	4618      	mov	r0, r3
3419d0de:	3710      	adds	r7, #16
3419d0e0:	46bd      	mov	sp, r7
3419d0e2:	bd80      	pop	{r7, pc}

3419d0e4 <_ux_device_class_storage_verify>:
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_class_storage_verify(UX_SLAVE_CLASS_STORAGE *storage, ULONG lun, 
                                      UX_SLAVE_ENDPOINT *endpoint_in,
                                      UX_SLAVE_ENDPOINT *endpoint_out, UCHAR * cbwcb)
{
3419d0e4:	b480      	push	{r7}
3419d0e6:	b085      	sub	sp, #20
3419d0e8:	af00      	add	r7, sp, #0
3419d0ea:	60f8      	str	r0, [r7, #12]
3419d0ec:	60b9      	str	r1, [r7, #8]
3419d0ee:	607a      	str	r2, [r7, #4]
3419d0f0:	603b      	str	r3, [r7, #0]

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_CLASS_STORAGE_VERIFY, storage, lun, 0, 0, UX_TRACE_DEVICE_CLASS_EVENTS, 0, 0)

    /* We set the CSW with success.  */
    storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_PASSED;
3419d0f2:	68fb      	ldr	r3, [r7, #12]
3419d0f4:	2200      	movs	r2, #0
3419d0f6:	651a      	str	r2, [r3, #80]	@ 0x50

    /* Return success!  */
    return(UX_SUCCESS);
3419d0f8:	2300      	movs	r3, #0
}
3419d0fa:	4618      	mov	r0, r3
3419d0fc:	3714      	adds	r7, #20
3419d0fe:	46bd      	mov	sp, r7
3419d100:	f85d 7b04 	ldr.w	r7, [sp], #4
3419d104:	4770      	bx	lr

3419d106 <_ux_device_class_storage_write>:
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_class_storage_write(UX_SLAVE_CLASS_STORAGE *storage, ULONG lun, 
                                    UX_SLAVE_ENDPOINT *endpoint_in,
                                    UX_SLAVE_ENDPOINT *endpoint_out, UCHAR * cbwcb, UCHAR scsi_command)
{
3419d106:	b590      	push	{r4, r7, lr}
3419d108:	b091      	sub	sp, #68	@ 0x44
3419d10a:	af02      	add	r7, sp, #8
3419d10c:	60f8      	str	r0, [r7, #12]
3419d10e:	60b9      	str	r1, [r7, #8]
3419d110:	607a      	str	r2, [r7, #4]
3419d112:	603b      	str	r3, [r7, #0]


    UX_PARAMETER_NOT_USED(endpoint_in);

    /* Get the LBA from the CBWCB.  */
    lba =  _ux_utility_long_get_big_endian(cbwcb + UX_SLAVE_CLASS_STORAGE_WRITE_LBA);
3419d114:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3419d116:	3302      	adds	r3, #2
3419d118:	4618      	mov	r0, r3
3419d11a:	f7fc fb44 	bl	341997a6 <_ux_utility_long_get_big_endian>
3419d11e:	6338      	str	r0, [r7, #48]	@ 0x30
    
    /* The type of commands will tell us the width of the field containing the number
       of sectors to read.   */
    if (scsi_command == UX_SLAVE_CLASS_STORAGE_SCSI_WRITE16)
3419d120:	f897 304c 	ldrb.w	r3, [r7, #76]	@ 0x4c
3419d124:	2b2a      	cmp	r3, #42	@ 0x2a
3419d126:	d106      	bne.n	3419d136 <_ux_device_class_storage_write+0x30>

        /* Get the number of blocks from the CBWCB in 16 bits.  */
        total_number_blocks =  _ux_utility_short_get_big_endian(cbwcb + UX_SLAVE_CLASS_STORAGE_WRITE_TRANSFER_LENGTH_16);
3419d128:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3419d12a:	3307      	adds	r3, #7
3419d12c:	4618      	mov	r0, r3
3419d12e:	f7fc ff33 	bl	34199f98 <_ux_utility_short_get_big_endian>
3419d132:	62f8      	str	r0, [r7, #44]	@ 0x2c
3419d134:	e005      	b.n	3419d142 <_ux_device_class_storage_write+0x3c>

    else        

        /* Get the number of blocks from the CBWCB in 32 bits.  */
        total_number_blocks =  _ux_utility_long_get_big_endian(cbwcb + UX_SLAVE_CLASS_STORAGE_WRITE_TRANSFER_LENGTH_32);
3419d136:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3419d138:	3306      	adds	r3, #6
3419d13a:	4618      	mov	r0, r3
3419d13c:	f7fc fb33 	bl	341997a6 <_ux_utility_long_get_big_endian>
3419d140:	62f8      	str	r0, [r7, #44]	@ 0x2c

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_CLASS_STORAGE_WRITE, storage, lun, lba, total_number_blocks, UX_TRACE_DEVICE_CLASS_EVENTS, 0, 0)

    /* Obtain the pointer to the transfer request.  */
    transfer_request =  &endpoint_out -> ux_slave_endpoint_transfer_request;
3419d142:	683b      	ldr	r3, [r7, #0]
3419d144:	3320      	adds	r3, #32
3419d146:	61fb      	str	r3, [r7, #28]

    /* Obtain the status of the device.  */
    status =  storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_status(storage, 
3419d148:	68f9      	ldr	r1, [r7, #12]
3419d14a:	68bb      	ldr	r3, [r7, #8]
3419d14c:	1c5a      	adds	r2, r3, #1
3419d14e:	4613      	mov	r3, r2
3419d150:	00db      	lsls	r3, r3, #3
3419d152:	1a9b      	subs	r3, r3, r2
3419d154:	00db      	lsls	r3, r3, #3
3419d156:	440b      	add	r3, r1
3419d158:	681c      	ldr	r4, [r3, #0]
3419d15a:	68f9      	ldr	r1, [r7, #12]
3419d15c:	68ba      	ldr	r2, [r7, #8]
3419d15e:	4613      	mov	r3, r2
3419d160:	00db      	lsls	r3, r3, #3
3419d162:	1a9b      	subs	r3, r3, r2
3419d164:	00db      	lsls	r3, r3, #3
3419d166:	440b      	add	r3, r1
3419d168:	331c      	adds	r3, #28
3419d16a:	681a      	ldr	r2, [r3, #0]
3419d16c:	f107 0314 	add.w	r3, r7, #20
3419d170:	68b9      	ldr	r1, [r7, #8]
3419d172:	68f8      	ldr	r0, [r7, #12]
3419d174:	47a0      	blx	r4
3419d176:	6378      	str	r0, [r7, #52]	@ 0x34
                            lun, storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_id, &media_status);
    
    /* Update the request sense.  */
    storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_request_sense_status = media_status;
3419d178:	6979      	ldr	r1, [r7, #20]
3419d17a:	68f8      	ldr	r0, [r7, #12]
3419d17c:	68ba      	ldr	r2, [r7, #8]
3419d17e:	4613      	mov	r3, r2
3419d180:	00db      	lsls	r3, r3, #3
3419d182:	1a9b      	subs	r3, r3, r2
3419d184:	00db      	lsls	r3, r3, #3
3419d186:	4403      	add	r3, r0
3419d188:	3320      	adds	r3, #32
3419d18a:	6019      	str	r1, [r3, #0]

    /* Default CSW to failed.  */
    storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_FAILED;
3419d18c:	68fb      	ldr	r3, [r7, #12]
3419d18e:	2201      	movs	r2, #1
3419d190:	651a      	str	r2, [r3, #80]	@ 0x50

    /* If there is a problem, return a failed command.  */
    if (status != UX_SUCCESS)
3419d192:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
3419d194:	2b00      	cmp	r3, #0
3419d196:	d004      	beq.n	3419d1a2 <_ux_device_class_storage_write+0x9c>
    {

        /* We have a problem, media status error. Return a bad completion and wait for the
           REQUEST_SENSE command.  */
#if !defined(UX_DEVICE_STANDALONE)
        _ux_device_stack_endpoint_stall(endpoint_out);
3419d198:	6838      	ldr	r0, [r7, #0]
3419d19a:	f7fe f801 	bl	3419b1a0 <_ux_device_stack_endpoint_stall>
#endif

        /* We are done here.  */
        return(UX_ERROR);
3419d19e:	23ff      	movs	r3, #255	@ 0xff
3419d1a0:	e0ca      	b.n	3419d338 <_ux_device_class_storage_write+0x232>
    }

    /* Check Read Only flag.  */
    if (storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_read_only_flag == UX_TRUE)
3419d1a2:	68f9      	ldr	r1, [r7, #12]
3419d1a4:	68ba      	ldr	r2, [r7, #8]
3419d1a6:	4613      	mov	r3, r2
3419d1a8:	00db      	lsls	r3, r3, #3
3419d1aa:	1a9b      	subs	r3, r3, r2
3419d1ac:	00db      	lsls	r3, r3, #3
3419d1ae:	440b      	add	r3, r1
3419d1b0:	3318      	adds	r3, #24
3419d1b2:	681b      	ldr	r3, [r3, #0]
3419d1b4:	2b01      	cmp	r3, #1
3419d1b6:	d10f      	bne.n	3419d1d8 <_ux_device_class_storage_write+0xd2>
    {

        /* Update the request sense.  */
        storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_request_sense_status =
3419d1b8:	68f9      	ldr	r1, [r7, #12]
3419d1ba:	68ba      	ldr	r2, [r7, #8]
3419d1bc:	4613      	mov	r3, r2
3419d1be:	00db      	lsls	r3, r3, #3
3419d1c0:	1a9b      	subs	r3, r3, r2
3419d1c2:	00db      	lsls	r3, r3, #3
3419d1c4:	440b      	add	r3, r1
3419d1c6:	3320      	adds	r3, #32
3419d1c8:	f242 7207 	movw	r2, #9991	@ 0x2707
3419d1cc:	601a      	str	r2, [r3, #0]
                                            UX_SLAVE_CLASS_STORAGE_REQUEST_CODE_MEDIA_PROTECTED,0);

        /* We have a problem, cannot write to RO drive. Return a bad completion and wait for the
           REQUEST_SENSE command.  */
#if !defined(UX_DEVICE_STANDALONE)
        _ux_device_stack_endpoint_stall(endpoint_out);
3419d1ce:	6838      	ldr	r0, [r7, #0]
3419d1d0:	f7fd ffe6 	bl	3419b1a0 <_ux_device_stack_endpoint_stall>
#endif

        /* We are done here.  */
        return(UX_ERROR);
3419d1d4:	23ff      	movs	r3, #255	@ 0xff
3419d1d6:	e0af      	b.n	3419d338 <_ux_device_class_storage_write+0x232>
    }

    /* Compute the total length to transfer and how much remains.  */
    total_length =  total_number_blocks * storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_block_length;
3419d1d8:	68f9      	ldr	r1, [r7, #12]
3419d1da:	68ba      	ldr	r2, [r7, #8]
3419d1dc:	4613      	mov	r3, r2
3419d1de:	00db      	lsls	r3, r3, #3
3419d1e0:	1a9b      	subs	r3, r3, r2
3419d1e2:	00db      	lsls	r3, r3, #3
3419d1e4:	440b      	add	r3, r1
3419d1e6:	330c      	adds	r3, #12
3419d1e8:	681a      	ldr	r2, [r3, #0]
3419d1ea:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3419d1ec:	fb02 f303 	mul.w	r3, r2, r3
3419d1f0:	62bb      	str	r3, [r7, #40]	@ 0x28
#else

    /* Check transfer length.  */

    /* Case (3) Hn < Do.  */
    if (total_length > storage -> ux_slave_class_storage_host_length)
3419d1f2:	68fb      	ldr	r3, [r7, #12]
3419d1f4:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3419d1f6:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3419d1f8:	429a      	cmp	r2, r3
3419d1fa:	d907      	bls.n	3419d20c <_ux_device_class_storage_write+0x106>
    {
        _ux_device_stack_endpoint_stall(endpoint_out);
3419d1fc:	6838      	ldr	r0, [r7, #0]
3419d1fe:	f7fd ffcf 	bl	3419b1a0 <_ux_device_stack_endpoint_stall>
        storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_PHASE_ERROR;
3419d202:	68fb      	ldr	r3, [r7, #12]
3419d204:	2202      	movs	r2, #2
3419d206:	651a      	str	r2, [r3, #80]	@ 0x50
        return(UX_ERROR);
3419d208:	23ff      	movs	r3, #255	@ 0xff
3419d20a:	e095      	b.n	3419d338 <_ux_device_class_storage_write+0x232>
    }

    /* Case (8). Hi <> Do.  */
    if ((storage -> ux_slave_class_storage_cbw_flags & 0x80) != 0)
3419d20c:	68fb      	ldr	r3, [r7, #12]
3419d20e:	f893 3044 	ldrb.w	r3, [r3, #68]	@ 0x44
3419d212:	b25b      	sxtb	r3, r3
3419d214:	2b00      	cmp	r3, #0
3419d216:	da07      	bge.n	3419d228 <_ux_device_class_storage_write+0x122>
    {
        _ux_device_stack_endpoint_stall(endpoint_in);
3419d218:	6878      	ldr	r0, [r7, #4]
3419d21a:	f7fd ffc1 	bl	3419b1a0 <_ux_device_stack_endpoint_stall>
        storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_PHASE_ERROR;
3419d21e:	68fb      	ldr	r3, [r7, #12]
3419d220:	2202      	movs	r2, #2
3419d222:	651a      	str	r2, [r3, #80]	@ 0x50
        return(UX_ERROR);
3419d224:	23ff      	movs	r3, #255	@ 0xff
3419d226:	e087      	b.n	3419d338 <_ux_device_class_storage_write+0x232>
    }

    /* Default status to success.  */
    status =  UX_SUCCESS;
3419d228:	2300      	movs	r3, #0
3419d22a:	637b      	str	r3, [r7, #52]	@ 0x34

    /* It may take several transfers to send the requested data.  */
    done_length = 0;
3419d22c:	2300      	movs	r3, #0
3419d22e:	623b      	str	r3, [r7, #32]
    while (total_length)
3419d230:	e06e      	b.n	3419d310 <_ux_device_class_storage_write+0x20a>
    {

        /* How much can we receive in this transfer?  */
        if (total_length > UX_SLAVE_CLASS_STORAGE_BUFFER_SIZE)
3419d232:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419d234:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
3419d238:	d903      	bls.n	3419d242 <_ux_device_class_storage_write+0x13c>
            transfer_length =  UX_SLAVE_CLASS_STORAGE_BUFFER_SIZE;
3419d23a:	f44f 6380 	mov.w	r3, #1024	@ 0x400
3419d23e:	627b      	str	r3, [r7, #36]	@ 0x24
3419d240:	e001      	b.n	3419d246 <_ux_device_class_storage_write+0x140>
        else
            transfer_length =  total_length;
3419d242:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419d244:	627b      	str	r3, [r7, #36]	@ 0x24
        
        /* Get the data payload from the host.  */
        status =  _ux_device_stack_transfer_request(transfer_request, transfer_length, transfer_length);
3419d246:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
3419d248:	6a79      	ldr	r1, [r7, #36]	@ 0x24
3419d24a:	69f8      	ldr	r0, [r7, #28]
3419d24c:	f7fe fc5a 	bl	3419bb04 <_ux_device_stack_transfer_request>
3419d250:	6378      	str	r0, [r7, #52]	@ 0x34
        
        /* Check the status.  */
        if (status != UX_SUCCESS)
3419d252:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
3419d254:	2b00      	cmp	r3, #0
3419d256:	d015      	beq.n	3419d284 <_ux_device_class_storage_write+0x17e>
        {

            /* We have a problem, request error. Return a bad completion and wait for the
               REQUEST_SENSE command.  */
            _ux_device_stack_endpoint_stall(endpoint_out);
3419d258:	6838      	ldr	r0, [r7, #0]
3419d25a:	f7fd ffa1 	bl	3419b1a0 <_ux_device_stack_endpoint_stall>

            /* Update residue.  */
            storage -> ux_slave_class_storage_csw_residue = storage -> ux_slave_class_storage_host_length - done_length;
3419d25e:	68fb      	ldr	r3, [r7, #12]
3419d260:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
3419d262:	6a3b      	ldr	r3, [r7, #32]
3419d264:	1ad2      	subs	r2, r2, r3
3419d266:	68fb      	ldr	r3, [r7, #12]
3419d268:	64da      	str	r2, [r3, #76]	@ 0x4c

            /* And update the REQUEST_SENSE codes.  */
            storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_request_sense_status =
3419d26a:	68f9      	ldr	r1, [r7, #12]
3419d26c:	68ba      	ldr	r2, [r7, #8]
3419d26e:	4613      	mov	r3, r2
3419d270:	00db      	lsls	r3, r3, #3
3419d272:	1a9b      	subs	r3, r3, r2
3419d274:	00db      	lsls	r3, r3, #3
3419d276:	440b      	add	r3, r1
3419d278:	3320      	adds	r3, #32
3419d27a:	f245 4202 	movw	r2, #21506	@ 0x5402
3419d27e:	601a      	str	r2, [r3, #0]
                                                UX_DEVICE_CLASS_STORAGE_SENSE_STATUS(0x02,0x54,0x00);
    
            /* Return an error.  */
            return(UX_ERROR);
3419d280:	23ff      	movs	r3, #255	@ 0xff
3419d282:	e059      	b.n	3419d338 <_ux_device_class_storage_write+0x232>
        }

        /* Compute the number of blocks to transfer.  */
        number_blocks = transfer_length / storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_block_length;
3419d284:	68f9      	ldr	r1, [r7, #12]
3419d286:	68ba      	ldr	r2, [r7, #8]
3419d288:	4613      	mov	r3, r2
3419d28a:	00db      	lsls	r3, r3, #3
3419d28c:	1a9b      	subs	r3, r3, r2
3419d28e:	00db      	lsls	r3, r3, #3
3419d290:	440b      	add	r3, r1
3419d292:	330c      	adds	r3, #12
3419d294:	681b      	ldr	r3, [r3, #0]
3419d296:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
3419d298:	fbb2 f3f3 	udiv	r3, r2, r3
3419d29c:	61bb      	str	r3, [r7, #24]
        
        /* Execute the write command to the local media.  */
        status =  storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_write(storage, lun, transfer_request -> ux_slave_transfer_request_data_pointer, number_blocks, lba, &media_status);
3419d29e:	68f9      	ldr	r1, [r7, #12]
3419d2a0:	68ba      	ldr	r2, [r7, #8]
3419d2a2:	4613      	mov	r3, r2
3419d2a4:	00db      	lsls	r3, r3, #3
3419d2a6:	1a9b      	subs	r3, r3, r2
3419d2a8:	00db      	lsls	r3, r3, #3
3419d2aa:	440b      	add	r3, r1
3419d2ac:	3330      	adds	r3, #48	@ 0x30
3419d2ae:	681c      	ldr	r4, [r3, #0]
3419d2b0:	69fb      	ldr	r3, [r7, #28]
3419d2b2:	68da      	ldr	r2, [r3, #12]
3419d2b4:	f107 0314 	add.w	r3, r7, #20
3419d2b8:	9301      	str	r3, [sp, #4]
3419d2ba:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3419d2bc:	9300      	str	r3, [sp, #0]
3419d2be:	69bb      	ldr	r3, [r7, #24]
3419d2c0:	68b9      	ldr	r1, [r7, #8]
3419d2c2:	68f8      	ldr	r0, [r7, #12]
3419d2c4:	47a0      	blx	r4
3419d2c6:	6378      	str	r0, [r7, #52]	@ 0x34
    
        /* If there is a problem, return a failed command.  */
        if (status != UX_SUCCESS)
3419d2c8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
3419d2ca:	2b00      	cmp	r3, #0
3419d2cc:	d014      	beq.n	3419d2f8 <_ux_device_class_storage_write+0x1f2>
        {
    
            /* We have a problem, request error. Return a bad completion and wait for the
               REQUEST_SENSE command.  */
            _ux_device_stack_endpoint_stall(endpoint_out);
3419d2ce:	6838      	ldr	r0, [r7, #0]
3419d2d0:	f7fd ff66 	bl	3419b1a0 <_ux_device_stack_endpoint_stall>
    
            /* Update residue.  */
            storage -> ux_slave_class_storage_csw_residue = storage -> ux_slave_class_storage_host_length - done_length;
3419d2d4:	68fb      	ldr	r3, [r7, #12]
3419d2d6:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
3419d2d8:	6a3b      	ldr	r3, [r7, #32]
3419d2da:	1ad2      	subs	r2, r2, r3
3419d2dc:	68fb      	ldr	r3, [r7, #12]
3419d2de:	64da      	str	r2, [r3, #76]	@ 0x4c

            /* And update the REQUEST_SENSE codes.  */
            storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_request_sense_status = media_status;
3419d2e0:	6979      	ldr	r1, [r7, #20]
3419d2e2:	68f8      	ldr	r0, [r7, #12]
3419d2e4:	68ba      	ldr	r2, [r7, #8]
3419d2e6:	4613      	mov	r3, r2
3419d2e8:	00db      	lsls	r3, r3, #3
3419d2ea:	1a9b      	subs	r3, r3, r2
3419d2ec:	00db      	lsls	r3, r3, #3
3419d2ee:	4403      	add	r3, r0
3419d2f0:	3320      	adds	r3, #32
3419d2f2:	6019      	str	r1, [r3, #0]
    
            /* Return an error.  */
            return(UX_ERROR);
3419d2f4:	23ff      	movs	r3, #255	@ 0xff
3419d2f6:	e01f      	b.n	3419d338 <_ux_device_class_storage_write+0x232>
        }

        /* Update the lba.  */
        lba += number_blocks;
3419d2f8:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
3419d2fa:	69bb      	ldr	r3, [r7, #24]
3419d2fc:	4413      	add	r3, r2
3419d2fe:	633b      	str	r3, [r7, #48]	@ 0x30
        
        /* Update the length to remain.  */
        total_length -= transfer_length;
3419d300:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3419d302:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419d304:	1ad3      	subs	r3, r2, r3
3419d306:	62bb      	str	r3, [r7, #40]	@ 0x28
        done_length += transfer_length;
3419d308:	6a3a      	ldr	r2, [r7, #32]
3419d30a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419d30c:	4413      	add	r3, r2
3419d30e:	623b      	str	r3, [r7, #32]
    while (total_length)
3419d310:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419d312:	2b00      	cmp	r3, #0
3419d314:	d18d      	bne.n	3419d232 <_ux_device_class_storage_write+0x12c>
    }

    /* Update residue.  */
    storage -> ux_slave_class_storage_csw_residue = storage -> ux_slave_class_storage_host_length - done_length;
3419d316:	68fb      	ldr	r3, [r7, #12]
3419d318:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
3419d31a:	6a3b      	ldr	r3, [r7, #32]
3419d31c:	1ad2      	subs	r2, r2, r3
3419d31e:	68fb      	ldr	r3, [r7, #12]
3419d320:	64da      	str	r2, [r3, #76]	@ 0x4c

    /* Case (9), (11). If host expects more transfer, stall it.  */
    if (storage -> ux_slave_class_storage_csw_residue)
3419d322:	68fb      	ldr	r3, [r7, #12]
3419d324:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3419d326:	2b00      	cmp	r3, #0
3419d328:	d002      	beq.n	3419d330 <_ux_device_class_storage_write+0x22a>
        _ux_device_stack_endpoint_stall(endpoint_out);
3419d32a:	6838      	ldr	r0, [r7, #0]
3419d32c:	f7fd ff38 	bl	3419b1a0 <_ux_device_stack_endpoint_stall>

#endif /* else defined(UX_DEVICE_STANDALONE) */

    /* Now we set the CSW with success.  */
    storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_PASSED;
3419d330:	68fb      	ldr	r3, [r7, #12]
3419d332:	2200      	movs	r2, #0
3419d334:	651a      	str	r2, [r3, #80]	@ 0x50

    /* Return completion status.  */
    return(status);
3419d336:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
}
3419d338:	4618      	mov	r0, r3
3419d33a:	373c      	adds	r7, #60	@ 0x3c
3419d33c:	46bd      	mov	sp, r7
3419d33e:	bd90      	pop	{r4, r7, pc}

3419d340 <_ux_dcd_stm32_setup_in>:
#include "ux_device_stack.h"
#include "ux_utility.h"


static inline void _ux_dcd_stm32_setup_in(UX_DCD_STM32_ED * ed, UX_SLAVE_TRANSFER *transfer_request)
{
3419d340:	b580      	push	{r7, lr}
3419d342:	b082      	sub	sp, #8
3419d344:	af00      	add	r7, sp, #0
3419d346:	6078      	str	r0, [r7, #4]
3419d348:	6039      	str	r1, [r7, #0]

    /* The endpoint is IN.  This is important to memorize the direction for the control endpoint
        in case of a STALL. */
    ed -> ux_dcd_stm32_ed_direction = UX_ENDPOINT_IN;
3419d34a:	687b      	ldr	r3, [r7, #4]
3419d34c:	2280      	movs	r2, #128	@ 0x80
3419d34e:	729a      	strb	r2, [r3, #10]

    /* Set the state to TX.  */
    ed -> ux_dcd_stm32_ed_state = UX_DCD_STM32_ED_STATE_DATA_TX;
3419d350:	687b      	ldr	r3, [r7, #4]
3419d352:	2201      	movs	r2, #1
3419d354:	721a      	strb	r2, [r3, #8]

    /* Call the Control Transfer dispatcher.  */
    _ux_device_stack_control_request_process(transfer_request);
3419d356:	6838      	ldr	r0, [r7, #0]
3419d358:	f7fd fb5a 	bl	3419aa10 <_ux_device_stack_control_request_process>
}
3419d35c:	bf00      	nop
3419d35e:	3708      	adds	r7, #8
3419d360:	46bd      	mov	sp, r7
3419d362:	bd80      	pop	{r7, pc}

3419d364 <_ux_dcd_stm32_setup_out>:

static inline void _ux_dcd_stm32_setup_out(UX_DCD_STM32_ED * ed, UX_SLAVE_TRANSFER *transfer_request,
                                           PCD_HandleTypeDef *hpcd)
{
3419d364:	b580      	push	{r7, lr}
3419d366:	b084      	sub	sp, #16
3419d368:	af00      	add	r7, sp, #0
3419d36a:	60f8      	str	r0, [r7, #12]
3419d36c:	60b9      	str	r1, [r7, #8]
3419d36e:	607a      	str	r2, [r7, #4]

    /* Set the completion code to no error.  */
    transfer_request -> ux_slave_transfer_request_completion_code =  UX_SUCCESS;
3419d370:	68bb      	ldr	r3, [r7, #8]
3419d372:	2200      	movs	r2, #0
3419d374:	625a      	str	r2, [r3, #36]	@ 0x24

    /* The endpoint is IN.  This is important to memorize the direction for the control endpoint
        in case of a STALL. */
    ed -> ux_dcd_stm32_ed_direction = UX_ENDPOINT_IN;
3419d376:	68fb      	ldr	r3, [r7, #12]
3419d378:	2280      	movs	r2, #128	@ 0x80
3419d37a:	729a      	strb	r2, [r3, #10]

    /* We are using a Control endpoint on a OUT transaction and there was a payload.  */
    if (_ux_device_stack_control_request_process(transfer_request) == UX_SUCCESS)
3419d37c:	68b8      	ldr	r0, [r7, #8]
3419d37e:	f7fd fb47 	bl	3419aa10 <_ux_device_stack_control_request_process>
3419d382:	4603      	mov	r3, r0
3419d384:	2b00      	cmp	r3, #0
3419d386:	d108      	bne.n	3419d39a <_ux_dcd_stm32_setup_out+0x36>
    {

        /* Set the state to STATUS phase TX.  */
        ed -> ux_dcd_stm32_ed_state = UX_DCD_STM32_ED_STATE_STATUS_TX;
3419d388:	68fb      	ldr	r3, [r7, #12]
3419d38a:	2203      	movs	r2, #3
3419d38c:	721a      	strb	r2, [r3, #8]

        /* Arm the status transfer.  */
        HAL_PCD_EP_Transmit(hpcd, 0x00U, UX_NULL, 0U);
3419d38e:	2300      	movs	r3, #0
3419d390:	2200      	movs	r2, #0
3419d392:	2100      	movs	r1, #0
3419d394:	6878      	ldr	r0, [r7, #4]
3419d396:	f7eb fe99 	bl	341890cc <HAL_PCD_EP_Transmit>
    }
}
3419d39a:	bf00      	nop
3419d39c:	3710      	adds	r7, #16
3419d39e:	46bd      	mov	sp, r7
3419d3a0:	bd80      	pop	{r7, pc}

3419d3a2 <_ux_dcd_stm32_setup_status>:

static inline void _ux_dcd_stm32_setup_status(UX_DCD_STM32_ED * ed, UX_SLAVE_TRANSFER *transfer_request,
                                              PCD_HandleTypeDef *hpcd)
{
3419d3a2:	b580      	push	{r7, lr}
3419d3a4:	b084      	sub	sp, #16
3419d3a6:	af00      	add	r7, sp, #0
3419d3a8:	60f8      	str	r0, [r7, #12]
3419d3aa:	60b9      	str	r1, [r7, #8]
3419d3ac:	607a      	str	r2, [r7, #4]

    /* The endpoint is IN.  This is important to memorize the direction for the control endpoint
            in case of a STALL. */
    ed -> ux_dcd_stm32_ed_direction = UX_ENDPOINT_IN;
3419d3ae:	68fb      	ldr	r3, [r7, #12]
3419d3b0:	2280      	movs	r2, #128	@ 0x80
3419d3b2:	729a      	strb	r2, [r3, #10]

    /* Call the Control Transfer dispatcher.  */
    if (_ux_device_stack_control_request_process(transfer_request) == UX_SUCCESS)
3419d3b4:	68b8      	ldr	r0, [r7, #8]
3419d3b6:	f7fd fb2b 	bl	3419aa10 <_ux_device_stack_control_request_process>
3419d3ba:	4603      	mov	r3, r0
3419d3bc:	2b00      	cmp	r3, #0
3419d3be:	d108      	bne.n	3419d3d2 <_ux_dcd_stm32_setup_status+0x30>
    {

        /* Set the state to STATUS RX.  */
        ed -> ux_dcd_stm32_ed_state = UX_DCD_STM32_ED_STATE_STATUS_RX;
3419d3c0:	68fb      	ldr	r3, [r7, #12]
3419d3c2:	2204      	movs	r2, #4
3419d3c4:	721a      	strb	r2, [r3, #8]
        HAL_PCD_EP_Transmit(hpcd, 0x00U, UX_NULL, 0U);
3419d3c6:	2300      	movs	r3, #0
3419d3c8:	2200      	movs	r2, #0
3419d3ca:	2100      	movs	r1, #0
3419d3cc:	6878      	ldr	r0, [r7, #4]
3419d3ce:	f7eb fe7d 	bl	341890cc <HAL_PCD_EP_Transmit>
    }
}
3419d3d2:	bf00      	nop
3419d3d4:	3710      	adds	r7, #16
3419d3d6:	46bd      	mov	sp, r7
3419d3d8:	bd80      	pop	{r7, pc}
	...

3419d3dc <HAL_PCD_SetupStageCallback>:
/*                                            added standalone support,   */
/*                                            resulting in version 6.1.10 */
/*                                                                        */
/**************************************************************************/
void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
{
3419d3dc:	b580      	push	{r7, lr}
3419d3de:	b088      	sub	sp, #32
3419d3e0:	af00      	add	r7, sp, #0
3419d3e2:	6078      	str	r0, [r7, #4]
UX_SLAVE_TRANSFER       *transfer_request;
UX_SLAVE_ENDPOINT       *endpoint;


    /* Get the pointer to the DCD.  */
    dcd =  &_ux_system_slave -> ux_system_slave_dcd;
3419d3e4:	4b39      	ldr	r3, [pc, #228]	@ (3419d4cc <HAL_PCD_SetupStageCallback+0xf0>)
3419d3e6:	681b      	ldr	r3, [r3, #0]
3419d3e8:	61fb      	str	r3, [r7, #28]

    /* Get the pointer to the STM32 DCD.  */
    dcd_stm32 = (UX_DCD_STM32 *) dcd -> ux_slave_dcd_controller_hardware;
3419d3ea:	69fb      	ldr	r3, [r7, #28]
3419d3ec:	69db      	ldr	r3, [r3, #28]
3419d3ee:	61bb      	str	r3, [r7, #24]

    /* Fetch the address of the physical endpoint.  */
    ed =  &dcd_stm32 -> ux_dcd_stm32_ed[0];
3419d3f0:	69bb      	ldr	r3, [r7, #24]
3419d3f2:	3304      	adds	r3, #4
3419d3f4:	617b      	str	r3, [r7, #20]

    /* Get the pointer to the transfer request.  */
    transfer_request =  &ed -> ux_dcd_stm32_ed_endpoint -> ux_slave_endpoint_transfer_request;
3419d3f6:	697b      	ldr	r3, [r7, #20]
3419d3f8:	681b      	ldr	r3, [r3, #0]
3419d3fa:	3320      	adds	r3, #32
3419d3fc:	613b      	str	r3, [r7, #16]

    /* Copy setup data to transfer request.  */
    _ux_utility_memory_copy(transfer_request->ux_slave_transfer_request_setup, hpcd -> Setup, UX_SETUP_SIZE);
3419d3fe:	693b      	ldr	r3, [r7, #16]
3419d400:	f103 0054 	add.w	r0, r3, #84	@ 0x54
3419d404:	687b      	ldr	r3, [r7, #4]
3419d406:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
3419d40a:	2208      	movs	r2, #8
3419d40c:	4619      	mov	r1, r3
3419d40e:	f7fc fc49 	bl	34199ca4 <_ux_utility_memory_copy>

    /* Clear the length of the data received.  */
    transfer_request -> ux_slave_transfer_request_actual_length =  0;
3419d412:	693b      	ldr	r3, [r7, #16]
3419d414:	2200      	movs	r2, #0
3419d416:	619a      	str	r2, [r3, #24]

    /* Mark the phase as SETUP.  */
    transfer_request -> ux_slave_transfer_request_type =  UX_TRANSFER_PHASE_SETUP;
3419d418:	693b      	ldr	r3, [r7, #16]
3419d41a:	2201      	movs	r2, #1
3419d41c:	605a      	str	r2, [r3, #4]

    /* Mark the transfer as successful.  */
    transfer_request -> ux_slave_transfer_request_completion_code =  UX_SUCCESS;
3419d41e:	693b      	ldr	r3, [r7, #16]
3419d420:	2200      	movs	r2, #0
3419d422:	625a      	str	r2, [r3, #36]	@ 0x24

    /* Set the status of the endpoint to not stalled.  */
    ed -> ux_dcd_stm32_ed_status &= ~(UX_DCD_STM32_ED_STATUS_STALLED |
3419d424:	697b      	ldr	r3, [r7, #20]
3419d426:	685b      	ldr	r3, [r3, #4]
3419d428:	f023 020e 	bic.w	r2, r3, #14
3419d42c:	697b      	ldr	r3, [r7, #20]
3419d42e:	605a      	str	r2, [r3, #4]
                                      UX_DCD_STM32_ED_STATUS_TRANSFER |
                                      UX_DCD_STM32_ED_STATUS_DONE);

    /* Check if the transaction is IN.  */
    if (*transfer_request -> ux_slave_transfer_request_setup & UX_REQUEST_IN)
3419d430:	693b      	ldr	r3, [r7, #16]
3419d432:	f893 3054 	ldrb.w	r3, [r3, #84]	@ 0x54
3419d436:	b25b      	sxtb	r3, r3
3419d438:	2b00      	cmp	r3, #0
3419d43a:	da04      	bge.n	3419d446 <HAL_PCD_SetupStageCallback+0x6a>
    {
#if defined(UX_DEVICE_STANDALONE)
        ed -> ux_dcd_stm32_ed_status |= UX_DCD_STM32_ED_STATUS_SETUP_IN;
#else
        _ux_dcd_stm32_setup_in(ed, transfer_request);
3419d43c:	6939      	ldr	r1, [r7, #16]
3419d43e:	6978      	ldr	r0, [r7, #20]
3419d440:	f7ff ff7e 	bl	3419d340 <_ux_dcd_stm32_setup_in>
3419d444:	e03e      	b.n	3419d4c4 <HAL_PCD_SetupStageCallback+0xe8>
    else
    {

        /* The endpoint is OUT.  This is important to memorize the direction for the control endpoint
           in case of a STALL. */
        ed -> ux_dcd_stm32_ed_direction  = UX_ENDPOINT_OUT;
3419d446:	697b      	ldr	r3, [r7, #20]
3419d448:	2200      	movs	r2, #0
3419d44a:	729a      	strb	r2, [r3, #10]

        /* We are in a OUT transaction. Check if there is a data payload. If so, wait for the payload
           to be delivered.  */
        if (*(transfer_request -> ux_slave_transfer_request_setup + 6) == 0 &&
3419d44c:	693b      	ldr	r3, [r7, #16]
3419d44e:	f893 305a 	ldrb.w	r3, [r3, #90]	@ 0x5a
3419d452:	2b00      	cmp	r3, #0
3419d454:	d10a      	bne.n	3419d46c <HAL_PCD_SetupStageCallback+0x90>
            *(transfer_request -> ux_slave_transfer_request_setup + 7) == 0)
3419d456:	693b      	ldr	r3, [r7, #16]
3419d458:	f893 305b 	ldrb.w	r3, [r3, #91]	@ 0x5b
        if (*(transfer_request -> ux_slave_transfer_request_setup + 6) == 0 &&
3419d45c:	2b00      	cmp	r3, #0
3419d45e:	d105      	bne.n	3419d46c <HAL_PCD_SetupStageCallback+0x90>
        {
#if defined(UX_DEVICE_STANDALONE)
            ed -> ux_dcd_stm32_ed_status |= UX_DCD_STM32_ED_STATUS_SETUP_STATUS;
#else
            _ux_dcd_stm32_setup_status(ed, transfer_request, hpcd);
3419d460:	687a      	ldr	r2, [r7, #4]
3419d462:	6939      	ldr	r1, [r7, #16]
3419d464:	6978      	ldr	r0, [r7, #20]
3419d466:	f7ff ff9c 	bl	3419d3a2 <_ux_dcd_stm32_setup_status>
3419d46a:	e02b      	b.n	3419d4c4 <HAL_PCD_SetupStageCallback+0xe8>
        }
        else
        {

            /* Get the pointer to the logical endpoint from the transfer request.  */
            endpoint =  transfer_request -> ux_slave_transfer_request_endpoint;
3419d46c:	693b      	ldr	r3, [r7, #16]
3419d46e:	689b      	ldr	r3, [r3, #8]
3419d470:	60fb      	str	r3, [r7, #12]

            /* Get the length we expect from the SETUP packet.  */
            transfer_request -> ux_slave_transfer_request_requested_length = _ux_utility_short_get(transfer_request -> ux_slave_transfer_request_setup + 6);
3419d472:	693b      	ldr	r3, [r7, #16]
3419d474:	3354      	adds	r3, #84	@ 0x54
3419d476:	3306      	adds	r3, #6
3419d478:	4618      	mov	r0, r3
3419d47a:	f7fc fd76 	bl	34199f6a <_ux_utility_short_get>
3419d47e:	4602      	mov	r2, r0
3419d480:	693b      	ldr	r3, [r7, #16]
3419d482:	615a      	str	r2, [r3, #20]

            /* Check if we have enough space for the request.  */
            if (transfer_request -> ux_slave_transfer_request_requested_length > UX_SLAVE_REQUEST_CONTROL_MAX_LENGTH)
3419d484:	693b      	ldr	r3, [r7, #16]
3419d486:	695b      	ldr	r3, [r3, #20]
3419d488:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3419d48c:	d907      	bls.n	3419d49e <HAL_PCD_SetupStageCallback+0xc2>
            {

                /* No space available, stall the endpoint.  */
                _ux_dcd_stm32_endpoint_stall(dcd_stm32, endpoint);
3419d48e:	68f9      	ldr	r1, [r7, #12]
3419d490:	69b8      	ldr	r0, [r7, #24]
3419d492:	f000 fad0 	bl	3419da36 <_ux_dcd_stm32_endpoint_stall>

                /* Next phase is a SETUP.  */
                ed -> ux_dcd_stm32_ed_state =  UX_DCD_STM32_ED_STATE_IDLE;
3419d496:	697b      	ldr	r3, [r7, #20]
3419d498:	2200      	movs	r2, #0
3419d49a:	721a      	strb	r2, [r3, #8]
#if defined(UX_DEVICE_STANDALONE)
                ed -> ux_dcd_stm32_ed_status |= UX_DCD_STM32_ED_STATUS_SETUP_STATUS;
#endif

                /* We are done.  */
                return;
3419d49c:	e012      	b.n	3419d4c4 <HAL_PCD_SetupStageCallback+0xe8>
            }
            else
            {

                /* Reset what we have received so far.  */
                transfer_request -> ux_slave_transfer_request_actual_length =  0;
3419d49e:	693b      	ldr	r3, [r7, #16]
3419d4a0:	2200      	movs	r2, #0
3419d4a2:	619a      	str	r2, [r3, #24]

                /* And reprogram the current buffer address to the beginning of the buffer.  */
                transfer_request -> ux_slave_transfer_request_current_data_pointer =  transfer_request -> ux_slave_transfer_request_data_pointer;
3419d4a4:	693b      	ldr	r3, [r7, #16]
3419d4a6:	68da      	ldr	r2, [r3, #12]
3419d4a8:	693b      	ldr	r3, [r7, #16]
3419d4aa:	611a      	str	r2, [r3, #16]

                /* Receive data.  */
                HAL_PCD_EP_Receive(hpcd,
3419d4ac:	68fb      	ldr	r3, [r7, #12]
3419d4ae:	7b99      	ldrb	r1, [r3, #14]
                            endpoint -> ux_slave_endpoint_descriptor.bEndpointAddress,
                            transfer_request -> ux_slave_transfer_request_current_data_pointer,
3419d4b0:	693b      	ldr	r3, [r7, #16]
3419d4b2:	691a      	ldr	r2, [r3, #16]
                HAL_PCD_EP_Receive(hpcd,
3419d4b4:	693b      	ldr	r3, [r7, #16]
3419d4b6:	695b      	ldr	r3, [r3, #20]
3419d4b8:	6878      	ldr	r0, [r7, #4]
3419d4ba:	f7eb fdb4 	bl	34189026 <HAL_PCD_EP_Receive>
                            transfer_request -> ux_slave_transfer_request_requested_length);

                /* Set the state to RX.  */
                ed -> ux_dcd_stm32_ed_state =  UX_DCD_STM32_ED_STATE_DATA_RX;
3419d4be:	697b      	ldr	r3, [r7, #20]
3419d4c0:	2202      	movs	r2, #2
3419d4c2:	721a      	strb	r2, [r3, #8]
            }
        }
    }
}
3419d4c4:	3720      	adds	r7, #32
3419d4c6:	46bd      	mov	sp, r7
3419d4c8:	bd80      	pop	{r7, pc}
3419d4ca:	bf00      	nop
3419d4cc:	341c33f8 	.word	0x341c33f8

3419d4d0 <HAL_PCD_DataInStageCallback>:
/*                                            fixed transmit ZLP issue,   */
/*                                            resulting in version 6.1.12 */
/*                                                                        */
/**************************************************************************/
void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
3419d4d0:	b580      	push	{r7, lr}
3419d4d2:	b088      	sub	sp, #32
3419d4d4:	af00      	add	r7, sp, #0
3419d4d6:	6078      	str	r0, [r7, #4]
3419d4d8:	460b      	mov	r3, r1
3419d4da:	70fb      	strb	r3, [r7, #3]
ULONG                   transfer_length;
UX_SLAVE_ENDPOINT       *endpoint;


    /* Get the pointer to the DCD.  */
    dcd =  &_ux_system_slave -> ux_system_slave_dcd;
3419d4dc:	4b56      	ldr	r3, [pc, #344]	@ (3419d638 <HAL_PCD_DataInStageCallback+0x168>)
3419d4de:	681b      	ldr	r3, [r3, #0]
3419d4e0:	617b      	str	r3, [r7, #20]

    /* Get the pointer to the STM32 DCD.  */
    dcd_stm32 = (UX_DCD_STM32 *) dcd -> ux_slave_dcd_controller_hardware;
3419d4e2:	697b      	ldr	r3, [r7, #20]
3419d4e4:	69db      	ldr	r3, [r3, #28]
3419d4e6:	613b      	str	r3, [r7, #16]

    /* Fetch the address of the physical endpoint.  */
#if defined(UX_DEVICE_BIDIRECTIONAL_ENDPOINT_SUPPORT)
    if ((epnum & 0xF) != 0)
3419d4e8:	78fb      	ldrb	r3, [r7, #3]
3419d4ea:	f003 030f 	and.w	r3, r3, #15
3419d4ee:	2b00      	cmp	r3, #0
3419d4f0:	d00b      	beq.n	3419d50a <HAL_PCD_DataInStageCallback+0x3a>
        ed =  &dcd_stm32 -> ux_dcd_stm32_ed_in[epnum & 0xF];
3419d4f2:	78fb      	ldrb	r3, [r7, #3]
3419d4f4:	f003 020f 	and.w	r2, r3, #15
3419d4f8:	4613      	mov	r3, r2
3419d4fa:	005b      	lsls	r3, r3, #1
3419d4fc:	4413      	add	r3, r2
3419d4fe:	009b      	lsls	r3, r3, #2
3419d500:	3370      	adds	r3, #112	@ 0x70
3419d502:	693a      	ldr	r2, [r7, #16]
3419d504:	4413      	add	r3, r2
3419d506:	61fb      	str	r3, [r7, #28]
3419d508:	e00a      	b.n	3419d520 <HAL_PCD_DataInStageCallback+0x50>
    else
#endif /* defined(UX_DEVICE_BIDIRECTIONAL_ENDPOINT_SUPPORT) */
    ed =  &dcd_stm32 -> ux_dcd_stm32_ed[epnum & 0xF];
3419d50a:	78fb      	ldrb	r3, [r7, #3]
3419d50c:	f003 020f 	and.w	r2, r3, #15
3419d510:	4613      	mov	r3, r2
3419d512:	005b      	lsls	r3, r3, #1
3419d514:	4413      	add	r3, r2
3419d516:	009b      	lsls	r3, r3, #2
3419d518:	693a      	ldr	r2, [r7, #16]
3419d51a:	4413      	add	r3, r2
3419d51c:	3304      	adds	r3, #4
3419d51e:	61fb      	str	r3, [r7, #28]

    /* Get the pointer to the transfer request.  */
    transfer_request =  &(ed -> ux_dcd_stm32_ed_endpoint -> ux_slave_endpoint_transfer_request);
3419d520:	69fb      	ldr	r3, [r7, #28]
3419d522:	681b      	ldr	r3, [r3, #0]
3419d524:	3320      	adds	r3, #32
3419d526:	60fb      	str	r3, [r7, #12]

    /* Endpoint 0 is different.  */
    if (epnum == 0U)
3419d528:	78fb      	ldrb	r3, [r7, #3]
3419d52a:	2b00      	cmp	r3, #0
3419d52c:	d15c      	bne.n	3419d5e8 <HAL_PCD_DataInStageCallback+0x118>
    {

        /* Get the pointer to the logical endpoint from the transfer request.  */
        endpoint =  transfer_request -> ux_slave_transfer_request_endpoint;
3419d52e:	68fb      	ldr	r3, [r7, #12]
3419d530:	689b      	ldr	r3, [r3, #8]
3419d532:	60bb      	str	r3, [r7, #8]

        /* Check if we need to send data again on control endpoint. */
        if (ed -> ux_dcd_stm32_ed_state == UX_DCD_STM32_ED_STATE_DATA_TX)
3419d534:	69fb      	ldr	r3, [r7, #28]
3419d536:	7a1b      	ldrb	r3, [r3, #8]
3419d538:	2b01      	cmp	r3, #1
3419d53a:	d179      	bne.n	3419d630 <HAL_PCD_DataInStageCallback+0x160>
        {

            /* Arm Status transfer.  */
            HAL_PCD_EP_Receive(hpcd, 0, 0, 0);
3419d53c:	2300      	movs	r3, #0
3419d53e:	2200      	movs	r2, #0
3419d540:	2100      	movs	r1, #0
3419d542:	6878      	ldr	r0, [r7, #4]
3419d544:	f7eb fd6f 	bl	34189026 <HAL_PCD_EP_Receive>

            /* Are we done with this transfer ? */
            if (transfer_request -> ux_slave_transfer_request_in_transfer_length <=
3419d548:	68fb      	ldr	r3, [r7, #12]
3419d54a:	69db      	ldr	r3, [r3, #28]
                endpoint -> ux_slave_endpoint_descriptor.wMaxPacketSize)
3419d54c:	68ba      	ldr	r2, [r7, #8]
3419d54e:	8a12      	ldrh	r2, [r2, #16]
            if (transfer_request -> ux_slave_transfer_request_in_transfer_length <=
3419d550:	4293      	cmp	r3, r2
3419d552:	d824      	bhi.n	3419d59e <HAL_PCD_DataInStageCallback+0xce>
            {

                /* There is no data to send but we may need to send a Zero Length Packet.  */
                if (transfer_request -> ux_slave_transfer_request_force_zlp ==  UX_TRUE)
3419d554:	68fb      	ldr	r3, [r7, #12]
3419d556:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
3419d558:	2b01      	cmp	r3, #1
3419d55a:	d10a      	bne.n	3419d572 <HAL_PCD_DataInStageCallback+0xa2>
                {

                    /* Arm a ZLP packet on IN.  */
                    HAL_PCD_EP_Transmit(hpcd,
3419d55c:	68bb      	ldr	r3, [r7, #8]
3419d55e:	7b99      	ldrb	r1, [r3, #14]
3419d560:	2300      	movs	r3, #0
3419d562:	2200      	movs	r2, #0
3419d564:	6878      	ldr	r0, [r7, #4]
3419d566:	f7eb fdb1 	bl	341890cc <HAL_PCD_EP_Transmit>
                            endpoint->ux_slave_endpoint_descriptor.bEndpointAddress, 0, 0);

                    /* Reset the ZLP condition.  */
                    transfer_request -> ux_slave_transfer_request_force_zlp =  UX_FALSE;
3419d56a:	68fb      	ldr	r3, [r7, #12]
3419d56c:	2200      	movs	r2, #0
3419d56e:	651a      	str	r2, [r3, #80]	@ 0x50
        /* Non control endpoint operation, use semaphore.  */
        _ux_utility_semaphore_put(&transfer_request -> ux_slave_transfer_request_semaphore);
#endif /* defined(UX_DEVICE_STANDALONE) */
        }
    }
}
3419d570:	e05e      	b.n	3419d630 <HAL_PCD_DataInStageCallback+0x160>
                    transfer_request -> ux_slave_transfer_request_completion_code =  UX_SUCCESS;
3419d572:	68fb      	ldr	r3, [r7, #12]
3419d574:	2200      	movs	r2, #0
3419d576:	625a      	str	r2, [r3, #36]	@ 0x24
                    transfer_request -> ux_slave_transfer_request_status =  UX_TRANSFER_STATUS_COMPLETED;
3419d578:	68fb      	ldr	r3, [r7, #12]
3419d57a:	2202      	movs	r2, #2
3419d57c:	601a      	str	r2, [r3, #0]
                        transfer_request -> ux_slave_transfer_request_requested_length;
3419d57e:	68fb      	ldr	r3, [r7, #12]
3419d580:	695a      	ldr	r2, [r3, #20]
                    transfer_request -> ux_slave_transfer_request_actual_length =
3419d582:	68fb      	ldr	r3, [r7, #12]
3419d584:	619a      	str	r2, [r3, #24]
                    if (transfer_request -> ux_slave_transfer_request_completion_function)
3419d586:	68fb      	ldr	r3, [r7, #12]
3419d588:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3419d58a:	2b00      	cmp	r3, #0
3419d58c:	d003      	beq.n	3419d596 <HAL_PCD_DataInStageCallback+0xc6>
                        transfer_request -> ux_slave_transfer_request_completion_function (transfer_request) ;
3419d58e:	68fb      	ldr	r3, [r7, #12]
3419d590:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3419d592:	68f8      	ldr	r0, [r7, #12]
3419d594:	4798      	blx	r3
                    ed -> ux_dcd_stm32_ed_state = UX_DCD_STM32_ED_STATE_STATUS_RX;
3419d596:	69fb      	ldr	r3, [r7, #28]
3419d598:	2204      	movs	r2, #4
3419d59a:	721a      	strb	r2, [r3, #8]
}
3419d59c:	e048      	b.n	3419d630 <HAL_PCD_DataInStageCallback+0x160>
                transfer_length = transfer_request -> ux_slave_transfer_request_in_transfer_length - endpoint -> ux_slave_endpoint_descriptor.wMaxPacketSize;
3419d59e:	68fb      	ldr	r3, [r7, #12]
3419d5a0:	69db      	ldr	r3, [r3, #28]
3419d5a2:	68ba      	ldr	r2, [r7, #8]
3419d5a4:	8a12      	ldrh	r2, [r2, #16]
3419d5a6:	1a9b      	subs	r3, r3, r2
3419d5a8:	61bb      	str	r3, [r7, #24]
                if (transfer_length > endpoint -> ux_slave_endpoint_descriptor.wMaxPacketSize)
3419d5aa:	68bb      	ldr	r3, [r7, #8]
3419d5ac:	8a1b      	ldrh	r3, [r3, #16]
3419d5ae:	461a      	mov	r2, r3
3419d5b0:	69bb      	ldr	r3, [r7, #24]
3419d5b2:	4293      	cmp	r3, r2
3419d5b4:	d902      	bls.n	3419d5bc <HAL_PCD_DataInStageCallback+0xec>
                    transfer_length =  endpoint -> ux_slave_endpoint_descriptor.wMaxPacketSize;
3419d5b6:	68bb      	ldr	r3, [r7, #8]
3419d5b8:	8a1b      	ldrh	r3, [r3, #16]
3419d5ba:	61bb      	str	r3, [r7, #24]
                transfer_request -> ux_slave_transfer_request_current_data_pointer += endpoint -> ux_slave_endpoint_descriptor.wMaxPacketSize;
3419d5bc:	68fb      	ldr	r3, [r7, #12]
3419d5be:	691b      	ldr	r3, [r3, #16]
3419d5c0:	68ba      	ldr	r2, [r7, #8]
3419d5c2:	8a12      	ldrh	r2, [r2, #16]
3419d5c4:	441a      	add	r2, r3
3419d5c6:	68fb      	ldr	r3, [r7, #12]
3419d5c8:	611a      	str	r2, [r3, #16]
                transfer_request -> ux_slave_transfer_request_in_transfer_length -= transfer_length;
3419d5ca:	68fb      	ldr	r3, [r7, #12]
3419d5cc:	69da      	ldr	r2, [r3, #28]
3419d5ce:	69bb      	ldr	r3, [r7, #24]
3419d5d0:	1ad2      	subs	r2, r2, r3
3419d5d2:	68fb      	ldr	r3, [r7, #12]
3419d5d4:	61da      	str	r2, [r3, #28]
                HAL_PCD_EP_Transmit(hpcd,
3419d5d6:	68bb      	ldr	r3, [r7, #8]
3419d5d8:	7b99      	ldrb	r1, [r3, #14]
                            transfer_request->ux_slave_transfer_request_current_data_pointer,
3419d5da:	68fb      	ldr	r3, [r7, #12]
3419d5dc:	691a      	ldr	r2, [r3, #16]
                HAL_PCD_EP_Transmit(hpcd,
3419d5de:	69bb      	ldr	r3, [r7, #24]
3419d5e0:	6878      	ldr	r0, [r7, #4]
3419d5e2:	f7eb fd73 	bl	341890cc <HAL_PCD_EP_Transmit>
}
3419d5e6:	e023      	b.n	3419d630 <HAL_PCD_DataInStageCallback+0x160>
        if (transfer_request -> ux_slave_transfer_request_force_zlp &&
3419d5e8:	68fb      	ldr	r3, [r7, #12]
3419d5ea:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
3419d5ec:	2b00      	cmp	r3, #0
3419d5ee:	d010      	beq.n	3419d612 <HAL_PCD_DataInStageCallback+0x142>
            transfer_request -> ux_slave_transfer_request_requested_length)
3419d5f0:	68fb      	ldr	r3, [r7, #12]
3419d5f2:	695b      	ldr	r3, [r3, #20]
        if (transfer_request -> ux_slave_transfer_request_force_zlp &&
3419d5f4:	2b00      	cmp	r3, #0
3419d5f6:	d00c      	beq.n	3419d612 <HAL_PCD_DataInStageCallback+0x142>
            transfer_request -> ux_slave_transfer_request_force_zlp =  UX_FALSE;
3419d5f8:	68fb      	ldr	r3, [r7, #12]
3419d5fa:	2200      	movs	r2, #0
3419d5fc:	651a      	str	r2, [r3, #80]	@ 0x50
            transfer_request -> ux_slave_transfer_request_in_transfer_length = 0;
3419d5fe:	68fb      	ldr	r3, [r7, #12]
3419d600:	2200      	movs	r2, #0
3419d602:	61da      	str	r2, [r3, #28]
            HAL_PCD_EP_Transmit(hpcd, epnum, 0, 0);
3419d604:	78f9      	ldrb	r1, [r7, #3]
3419d606:	2300      	movs	r3, #0
3419d608:	2200      	movs	r2, #0
3419d60a:	6878      	ldr	r0, [r7, #4]
3419d60c:	f7eb fd5e 	bl	341890cc <HAL_PCD_EP_Transmit>
}
3419d610:	e00e      	b.n	3419d630 <HAL_PCD_DataInStageCallback+0x160>
            transfer_request -> ux_slave_transfer_request_completion_code =  UX_SUCCESS;
3419d612:	68fb      	ldr	r3, [r7, #12]
3419d614:	2200      	movs	r2, #0
3419d616:	625a      	str	r2, [r3, #36]	@ 0x24
            transfer_request -> ux_slave_transfer_request_status =  UX_TRANSFER_STATUS_COMPLETED;
3419d618:	68fb      	ldr	r3, [r7, #12]
3419d61a:	2202      	movs	r2, #2
3419d61c:	601a      	str	r2, [r3, #0]
                transfer_request -> ux_slave_transfer_request_requested_length;
3419d61e:	68fb      	ldr	r3, [r7, #12]
3419d620:	695a      	ldr	r2, [r3, #20]
            transfer_request -> ux_slave_transfer_request_actual_length =
3419d622:	68fb      	ldr	r3, [r7, #12]
3419d624:	619a      	str	r2, [r3, #24]
        _ux_utility_semaphore_put(&transfer_request -> ux_slave_transfer_request_semaphore);
3419d626:	68fb      	ldr	r3, [r7, #12]
3419d628:	3330      	adds	r3, #48	@ 0x30
3419d62a:	4618      	mov	r0, r3
3419d62c:	f7fc fc90 	bl	34199f50 <_ux_utility_semaphore_put>
}
3419d630:	bf00      	nop
3419d632:	3720      	adds	r7, #32
3419d634:	46bd      	mov	sp, r7
3419d636:	bd80      	pop	{r7, pc}
3419d638:	341c33f8 	.word	0x341c33f8

3419d63c <HAL_PCD_DataOutStageCallback>:
/*                                            added standalone support,   */
/*                                            resulting in version 6.1.10 */
/*                                                                        */
/**************************************************************************/
void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
3419d63c:	b580      	push	{r7, lr}
3419d63e:	b088      	sub	sp, #32
3419d640:	af00      	add	r7, sp, #0
3419d642:	6078      	str	r0, [r7, #4]
3419d644:	460b      	mov	r3, r1
3419d646:	70fb      	strb	r3, [r7, #3]
ULONG                   transfer_length;
UX_SLAVE_ENDPOINT       *endpoint;


    /* Get the pointer to the DCD.  */
    dcd = &_ux_system_slave -> ux_system_slave_dcd;
3419d648:	4b3b      	ldr	r3, [pc, #236]	@ (3419d738 <HAL_PCD_DataOutStageCallback+0xfc>)
3419d64a:	681b      	ldr	r3, [r3, #0]
3419d64c:	61fb      	str	r3, [r7, #28]

    /* Get the pointer to the STM32 DCD.  */
    dcd_stm32 = (UX_DCD_STM32 *) dcd -> ux_slave_dcd_controller_hardware;
3419d64e:	69fb      	ldr	r3, [r7, #28]
3419d650:	69db      	ldr	r3, [r3, #28]
3419d652:	61bb      	str	r3, [r7, #24]

    /* Fetch the address of the physical endpoint.  */
    ed = &dcd_stm32 -> ux_dcd_stm32_ed[epnum & 0xF];
3419d654:	78fb      	ldrb	r3, [r7, #3]
3419d656:	f003 020f 	and.w	r2, r3, #15
3419d65a:	4613      	mov	r3, r2
3419d65c:	005b      	lsls	r3, r3, #1
3419d65e:	4413      	add	r3, r2
3419d660:	009b      	lsls	r3, r3, #2
3419d662:	69ba      	ldr	r2, [r7, #24]
3419d664:	4413      	add	r3, r2
3419d666:	3304      	adds	r3, #4
3419d668:	617b      	str	r3, [r7, #20]

    /* Get the pointer to the transfer request.  */
    transfer_request = &(ed -> ux_dcd_stm32_ed_endpoint -> ux_slave_endpoint_transfer_request);
3419d66a:	697b      	ldr	r3, [r7, #20]
3419d66c:	681b      	ldr	r3, [r3, #0]
3419d66e:	3320      	adds	r3, #32
3419d670:	613b      	str	r3, [r7, #16]

    /* Endpoint 0 is different.  */
    if (epnum == 0U)
3419d672:	78fb      	ldrb	r3, [r7, #3]
3419d674:	2b00      	cmp	r3, #0
3419d676:	d147      	bne.n	3419d708 <HAL_PCD_DataOutStageCallback+0xcc>
    {

        /* Check if we have received something on endpoint 0 during data phase .  */
        if (ed -> ux_dcd_stm32_ed_state == UX_DCD_STM32_ED_STATE_DATA_RX)
3419d678:	697b      	ldr	r3, [r7, #20]
3419d67a:	7a1b      	ldrb	r3, [r3, #8]
3419d67c:	2b02      	cmp	r3, #2
3419d67e:	d156      	bne.n	3419d72e <HAL_PCD_DataOutStageCallback+0xf2>
        {

            /* Get the pointer to the logical endpoint from the transfer request.  */
            endpoint = transfer_request -> ux_slave_transfer_request_endpoint;
3419d680:	693b      	ldr	r3, [r7, #16]
3419d682:	689b      	ldr	r3, [r3, #8]
3419d684:	60fb      	str	r3, [r7, #12]

            /* Read the received data length for the Control endpoint.  */
            transfer_length = HAL_PCD_EP_GetRxCount(hpcd, epnum);
3419d686:	78fb      	ldrb	r3, [r7, #3]
3419d688:	4619      	mov	r1, r3
3419d68a:	6878      	ldr	r0, [r7, #4]
3419d68c:	f7eb fd06 	bl	3418909c <HAL_PCD_EP_GetRxCount>
3419d690:	60b8      	str	r0, [r7, #8]

            /* Update the length of the data received.  */
            transfer_request -> ux_slave_transfer_request_actual_length += transfer_length;
3419d692:	693b      	ldr	r3, [r7, #16]
3419d694:	699a      	ldr	r2, [r3, #24]
3419d696:	68bb      	ldr	r3, [r7, #8]
3419d698:	441a      	add	r2, r3
3419d69a:	693b      	ldr	r3, [r7, #16]
3419d69c:	619a      	str	r2, [r3, #24]

            /* Can we accept this much?  */
            if (transfer_request -> ux_slave_transfer_request_actual_length <=
3419d69e:	693b      	ldr	r3, [r7, #16]
3419d6a0:	699a      	ldr	r2, [r3, #24]
                transfer_request -> ux_slave_transfer_request_requested_length)
3419d6a2:	693b      	ldr	r3, [r7, #16]
3419d6a4:	695b      	ldr	r3, [r3, #20]
            if (transfer_request -> ux_slave_transfer_request_actual_length <=
3419d6a6:	429a      	cmp	r2, r3
3419d6a8:	d822      	bhi.n	3419d6f0 <HAL_PCD_DataOutStageCallback+0xb4>
            {

                /* Are we done with this transfer ? */
                if ((transfer_request -> ux_slave_transfer_request_actual_length ==
3419d6aa:	693b      	ldr	r3, [r7, #16]
3419d6ac:	699a      	ldr	r2, [r3, #24]
                     transfer_request -> ux_slave_transfer_request_requested_length) ||
3419d6ae:	693b      	ldr	r3, [r7, #16]
3419d6b0:	695b      	ldr	r3, [r3, #20]
                if ((transfer_request -> ux_slave_transfer_request_actual_length ==
3419d6b2:	429a      	cmp	r2, r3
3419d6b4:	d005      	beq.n	3419d6c2 <HAL_PCD_DataOutStageCallback+0x86>
                    (transfer_length != endpoint -> ux_slave_endpoint_descriptor.wMaxPacketSize))
3419d6b6:	68fb      	ldr	r3, [r7, #12]
3419d6b8:	8a1b      	ldrh	r3, [r3, #16]
3419d6ba:	461a      	mov	r2, r3
                     transfer_request -> ux_slave_transfer_request_requested_length) ||
3419d6bc:	68bb      	ldr	r3, [r7, #8]
3419d6be:	4293      	cmp	r3, r2
3419d6c0:	d005      	beq.n	3419d6ce <HAL_PCD_DataOutStageCallback+0x92>
                {
#if defined(UX_DEVICE_STANDALONE)
                    ed -> ux_dcd_stm32_ed_status |= UX_DCD_STM32_ED_STATUS_SETUP_OUT;
#else
                    _ux_dcd_stm32_setup_out(ed, transfer_request, hpcd);
3419d6c2:	687a      	ldr	r2, [r7, #4]
3419d6c4:	6939      	ldr	r1, [r7, #16]
3419d6c6:	6978      	ldr	r0, [r7, #20]
3419d6c8:	f7ff fe4c 	bl	3419d364 <_ux_dcd_stm32_setup_out>
        /* Non control endpoint operation, use semaphore.  */
        _ux_utility_semaphore_put(&transfer_request -> ux_slave_transfer_request_semaphore);
#endif
    }

}
3419d6cc:	e02f      	b.n	3419d72e <HAL_PCD_DataOutStageCallback+0xf2>
                    transfer_request -> ux_slave_transfer_request_current_data_pointer += endpoint -> ux_slave_endpoint_descriptor.wMaxPacketSize;
3419d6ce:	693b      	ldr	r3, [r7, #16]
3419d6d0:	691b      	ldr	r3, [r3, #16]
3419d6d2:	68fa      	ldr	r2, [r7, #12]
3419d6d4:	8a12      	ldrh	r2, [r2, #16]
3419d6d6:	441a      	add	r2, r3
3419d6d8:	693b      	ldr	r3, [r7, #16]
3419d6da:	611a      	str	r2, [r3, #16]
                    HAL_PCD_EP_Receive(hpcd,
3419d6dc:	68fb      	ldr	r3, [r7, #12]
3419d6de:	7b99      	ldrb	r1, [r3, #14]
                                transfer_request -> ux_slave_transfer_request_current_data_pointer,
3419d6e0:	693b      	ldr	r3, [r7, #16]
3419d6e2:	691a      	ldr	r2, [r3, #16]
                                endpoint -> ux_slave_endpoint_descriptor.wMaxPacketSize);
3419d6e4:	68fb      	ldr	r3, [r7, #12]
3419d6e6:	8a1b      	ldrh	r3, [r3, #16]
                    HAL_PCD_EP_Receive(hpcd,
3419d6e8:	6878      	ldr	r0, [r7, #4]
3419d6ea:	f7eb fc9c 	bl	34189026 <HAL_PCD_EP_Receive>
}
3419d6ee:	e01e      	b.n	3419d72e <HAL_PCD_DataOutStageCallback+0xf2>
                transfer_request -> ux_slave_transfer_request_completion_code =  UX_TRANSFER_BUFFER_OVERFLOW;
3419d6f0:	693b      	ldr	r3, [r7, #16]
3419d6f2:	2227      	movs	r2, #39	@ 0x27
3419d6f4:	625a      	str	r2, [r3, #36]	@ 0x24
                if (transfer_request -> ux_slave_transfer_request_completion_function)
3419d6f6:	693b      	ldr	r3, [r7, #16]
3419d6f8:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3419d6fa:	2b00      	cmp	r3, #0
3419d6fc:	d017      	beq.n	3419d72e <HAL_PCD_DataOutStageCallback+0xf2>
                    transfer_request -> ux_slave_transfer_request_completion_function (transfer_request) ;
3419d6fe:	693b      	ldr	r3, [r7, #16]
3419d700:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3419d702:	6938      	ldr	r0, [r7, #16]
3419d704:	4798      	blx	r3
}
3419d706:	e012      	b.n	3419d72e <HAL_PCD_DataOutStageCallback+0xf2>
        transfer_request -> ux_slave_transfer_request_actual_length =  HAL_PCD_EP_GetRxCount(hpcd, epnum);
3419d708:	78fb      	ldrb	r3, [r7, #3]
3419d70a:	4619      	mov	r1, r3
3419d70c:	6878      	ldr	r0, [r7, #4]
3419d70e:	f7eb fcc5 	bl	3418909c <HAL_PCD_EP_GetRxCount>
3419d712:	4602      	mov	r2, r0
3419d714:	693b      	ldr	r3, [r7, #16]
3419d716:	619a      	str	r2, [r3, #24]
        transfer_request -> ux_slave_transfer_request_completion_code =  UX_SUCCESS;
3419d718:	693b      	ldr	r3, [r7, #16]
3419d71a:	2200      	movs	r2, #0
3419d71c:	625a      	str	r2, [r3, #36]	@ 0x24
        transfer_request -> ux_slave_transfer_request_status =  UX_TRANSFER_STATUS_COMPLETED;
3419d71e:	693b      	ldr	r3, [r7, #16]
3419d720:	2202      	movs	r2, #2
3419d722:	601a      	str	r2, [r3, #0]
        _ux_utility_semaphore_put(&transfer_request -> ux_slave_transfer_request_semaphore);
3419d724:	693b      	ldr	r3, [r7, #16]
3419d726:	3330      	adds	r3, #48	@ 0x30
3419d728:	4618      	mov	r0, r3
3419d72a:	f7fc fc11 	bl	34199f50 <_ux_utility_semaphore_put>
}
3419d72e:	bf00      	nop
3419d730:	3720      	adds	r7, #32
3419d732:	46bd      	mov	sp, r7
3419d734:	bd80      	pop	{r7, pc}
3419d736:	bf00      	nop
3419d738:	341c33f8 	.word	0x341c33f8

3419d73c <HAL_PCD_ResetCallback>:
/*  01-31-2022     Chaoqiong Xiao           Modified comment(s),          */
/*                                            resulting in version 6.1.10 */
/*                                                                        */
/**************************************************************************/
void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
{
3419d73c:	b580      	push	{r7, lr}
3419d73e:	b082      	sub	sp, #8
3419d740:	af00      	add	r7, sp, #0
3419d742:	6078      	str	r0, [r7, #4]

    /* If the device is attached or configured, we need to disconnect it.  */
    if (_ux_system_slave -> ux_system_slave_device.ux_slave_device_state !=  UX_DEVICE_RESET)
3419d744:	4b14      	ldr	r3, [pc, #80]	@ (3419d798 <HAL_PCD_ResetCallback+0x5c>)
3419d746:	681b      	ldr	r3, [r3, #0]
3419d748:	6a1b      	ldr	r3, [r3, #32]
3419d74a:	2b00      	cmp	r3, #0
3419d74c:	d001      	beq.n	3419d752 <HAL_PCD_ResetCallback+0x16>
    {

        /* Disconnect the device.  */
        _ux_device_stack_disconnect();
3419d74e:	f7fd fccd 	bl	3419b0ec <_ux_device_stack_disconnect>
    }

    /* Set USB Current Speed */
    switch(hpcd -> Init.speed)
3419d752:	687b      	ldr	r3, [r7, #4]
3419d754:	79db      	ldrb	r3, [r3, #7]
3419d756:	2b00      	cmp	r3, #0
3419d758:	d002      	beq.n	3419d760 <HAL_PCD_ResetCallback+0x24>
3419d75a:	2b02      	cmp	r3, #2
3419d75c:	d006      	beq.n	3419d76c <HAL_PCD_ResetCallback+0x30>
3419d75e:	e00b      	b.n	3419d778 <HAL_PCD_ResetCallback+0x3c>
    {
#ifdef PCD_SPEED_HIGH
    case PCD_SPEED_HIGH:

        /* We are connected at high speed.  */
        _ux_system_slave -> ux_system_slave_speed =  UX_HIGH_SPEED_DEVICE;
3419d760:	4b0d      	ldr	r3, [pc, #52]	@ (3419d798 <HAL_PCD_ResetCallback+0x5c>)
3419d762:	681b      	ldr	r3, [r3, #0]
3419d764:	2202      	movs	r2, #2
3419d766:	f8c3 2154 	str.w	r2, [r3, #340]	@ 0x154
        break;
3419d76a:	e00b      	b.n	3419d784 <HAL_PCD_ResetCallback+0x48>
#endif
    case PCD_SPEED_FULL:

        /* We are connected at full speed.  */
        _ux_system_slave -> ux_system_slave_speed =  UX_FULL_SPEED_DEVICE;
3419d76c:	4b0a      	ldr	r3, [pc, #40]	@ (3419d798 <HAL_PCD_ResetCallback+0x5c>)
3419d76e:	681b      	ldr	r3, [r3, #0]
3419d770:	2201      	movs	r2, #1
3419d772:	f8c3 2154 	str.w	r2, [r3, #340]	@ 0x154
        break;
3419d776:	e005      	b.n	3419d784 <HAL_PCD_ResetCallback+0x48>

    default:

        /* We are connected at full speed.  */
        _ux_system_slave -> ux_system_slave_speed =  UX_FULL_SPEED_DEVICE;
3419d778:	4b07      	ldr	r3, [pc, #28]	@ (3419d798 <HAL_PCD_ResetCallback+0x5c>)
3419d77a:	681b      	ldr	r3, [r3, #0]
3419d77c:	2201      	movs	r2, #1
3419d77e:	f8c3 2154 	str.w	r2, [r3, #340]	@ 0x154
        break;
3419d782:	bf00      	nop
    }

    /* Complete the device initialization.  */
    _ux_dcd_stm32_initialize_complete();
3419d784:	f000 fa94 	bl	3419dcb0 <_ux_dcd_stm32_initialize_complete>

    /* Mark the device as attached now.  */
    _ux_system_slave -> ux_system_slave_device.ux_slave_device_state =  UX_DEVICE_ATTACHED;
3419d788:	4b03      	ldr	r3, [pc, #12]	@ (3419d798 <HAL_PCD_ResetCallback+0x5c>)
3419d78a:	681b      	ldr	r3, [r3, #0]
3419d78c:	2201      	movs	r2, #1
3419d78e:	621a      	str	r2, [r3, #32]
}
3419d790:	bf00      	nop
3419d792:	3708      	adds	r7, #8
3419d794:	46bd      	mov	sp, r7
3419d796:	bd80      	pop	{r7, pc}
3419d798:	341c33f8 	.word	0x341c33f8

3419d79c <HAL_PCD_ConnectCallback>:
/*                                                                        */
/*  07-29-2022     Chaoqiong Xiao           Modified comment(s),          */
/*                                            resulting in version 6.1.12 */
/**************************************************************************/
void HAL_PCD_ConnectCallback(PCD_HandleTypeDef *hpcd)
{
3419d79c:	b580      	push	{r7, lr}
3419d79e:	b082      	sub	sp, #8
3419d7a0:	af00      	add	r7, sp, #0
3419d7a2:	6078      	str	r0, [r7, #4]

    /* Check the status change callback.  */
    if (_ux_system_slave -> ux_system_slave_change_function != UX_NULL)
3419d7a4:	4b07      	ldr	r3, [pc, #28]	@ (3419d7c4 <HAL_PCD_ConnectCallback+0x28>)
3419d7a6:	681b      	ldr	r3, [r3, #0]
3419d7a8:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
3419d7ac:	2b00      	cmp	r3, #0
3419d7ae:	d005      	beq.n	3419d7bc <HAL_PCD_ConnectCallback+0x20>
    {

       /* Inform the application if a callback function was programmed.  */
        _ux_system_slave -> ux_system_slave_change_function(UX_DCD_STM32_DEVICE_CONNECTED);
3419d7b0:	4b04      	ldr	r3, [pc, #16]	@ (3419d7c4 <HAL_PCD_ConnectCallback+0x28>)
3419d7b2:	681b      	ldr	r3, [r3, #0]
3419d7b4:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
3419d7b8:	20f1      	movs	r0, #241	@ 0xf1
3419d7ba:	4798      	blx	r3
    }
}
3419d7bc:	bf00      	nop
3419d7be:	3708      	adds	r7, #8
3419d7c0:	46bd      	mov	sp, r7
3419d7c2:	bd80      	pop	{r7, pc}
3419d7c4:	341c33f8 	.word	0x341c33f8

3419d7c8 <HAL_PCD_DisconnectCallback>:
/*  07-29-2022     Chaoqiong Xiao           Modified comment(s),          */
/*                                            resulting in version 6.1.12 */
/*                                                                        */
/**************************************************************************/
void HAL_PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd)
{
3419d7c8:	b580      	push	{r7, lr}
3419d7ca:	b082      	sub	sp, #8
3419d7cc:	af00      	add	r7, sp, #0
3419d7ce:	6078      	str	r0, [r7, #4]

    /* Check the status change callback.  */
    if (_ux_system_slave -> ux_system_slave_change_function != UX_NULL)
3419d7d0:	4b0b      	ldr	r3, [pc, #44]	@ (3419d800 <HAL_PCD_DisconnectCallback+0x38>)
3419d7d2:	681b      	ldr	r3, [r3, #0]
3419d7d4:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
3419d7d8:	2b00      	cmp	r3, #0
3419d7da:	d005      	beq.n	3419d7e8 <HAL_PCD_DisconnectCallback+0x20>
    {

       /* Inform the application if a callback function was programmed.  */
        _ux_system_slave -> ux_system_slave_change_function(UX_DCD_STM32_DEVICE_DISCONNECTED);
3419d7dc:	4b08      	ldr	r3, [pc, #32]	@ (3419d800 <HAL_PCD_DisconnectCallback+0x38>)
3419d7de:	681b      	ldr	r3, [r3, #0]
3419d7e0:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
3419d7e4:	20f2      	movs	r0, #242	@ 0xf2
3419d7e6:	4798      	blx	r3
    }

    /* Check if the device is attached or configured.  */
    if (_ux_system_slave -> ux_system_slave_device.ux_slave_device_state !=  UX_DEVICE_RESET)
3419d7e8:	4b05      	ldr	r3, [pc, #20]	@ (3419d800 <HAL_PCD_DisconnectCallback+0x38>)
3419d7ea:	681b      	ldr	r3, [r3, #0]
3419d7ec:	6a1b      	ldr	r3, [r3, #32]
3419d7ee:	2b00      	cmp	r3, #0
3419d7f0:	d001      	beq.n	3419d7f6 <HAL_PCD_DisconnectCallback+0x2e>
    {

        /* Disconnect the device.  */
        _ux_device_stack_disconnect();
3419d7f2:	f7fd fc7b 	bl	3419b0ec <_ux_device_stack_disconnect>
    }
}
3419d7f6:	bf00      	nop
3419d7f8:	3708      	adds	r7, #8
3419d7fa:	46bd      	mov	sp, r7
3419d7fc:	bd80      	pop	{r7, pc}
3419d7fe:	bf00      	nop
3419d800:	341c33f8 	.word	0x341c33f8

3419d804 <HAL_PCD_SuspendCallback>:
/*  07-29-2022     Chaoqiong Xiao           Modified comment(s),          */
/*                                            resulting in version 6.1.12 */
/*                                                                        */
/**************************************************************************/
void HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
{
3419d804:	b580      	push	{r7, lr}
3419d806:	b082      	sub	sp, #8
3419d808:	af00      	add	r7, sp, #0
3419d80a:	6078      	str	r0, [r7, #4]

    /* Check the status change callback.  */
    if (_ux_system_slave -> ux_system_slave_change_function != UX_NULL)
3419d80c:	4b07      	ldr	r3, [pc, #28]	@ (3419d82c <HAL_PCD_SuspendCallback+0x28>)
3419d80e:	681b      	ldr	r3, [r3, #0]
3419d810:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
3419d814:	2b00      	cmp	r3, #0
3419d816:	d005      	beq.n	3419d824 <HAL_PCD_SuspendCallback+0x20>
    {

       /* Inform the application if a callback function was programmed.  */
        _ux_system_slave -> ux_system_slave_change_function(UX_DCD_STM32_DEVICE_SUSPENDED);
3419d818:	4b04      	ldr	r3, [pc, #16]	@ (3419d82c <HAL_PCD_SuspendCallback+0x28>)
3419d81a:	681b      	ldr	r3, [r3, #0]
3419d81c:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
3419d820:	20f4      	movs	r0, #244	@ 0xf4
3419d822:	4798      	blx	r3
    }
}
3419d824:	bf00      	nop
3419d826:	3708      	adds	r7, #8
3419d828:	46bd      	mov	sp, r7
3419d82a:	bd80      	pop	{r7, pc}
3419d82c:	341c33f8 	.word	0x341c33f8

3419d830 <HAL_PCD_ResumeCallback>:
/*  07-29-2022     Chaoqiong Xiao           Modified comment(s),          */
/*                                            resulting in version 6.1.12 */
/*                                                                        */
/**************************************************************************/
void HAL_PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
{
3419d830:	b580      	push	{r7, lr}
3419d832:	b082      	sub	sp, #8
3419d834:	af00      	add	r7, sp, #0
3419d836:	6078      	str	r0, [r7, #4]

    /* Check the status change callback.  */
    if (_ux_system_slave -> ux_system_slave_change_function != UX_NULL)
3419d838:	4b07      	ldr	r3, [pc, #28]	@ (3419d858 <HAL_PCD_ResumeCallback+0x28>)
3419d83a:	681b      	ldr	r3, [r3, #0]
3419d83c:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
3419d840:	2b00      	cmp	r3, #0
3419d842:	d005      	beq.n	3419d850 <HAL_PCD_ResumeCallback+0x20>
    {

       /* Inform the application if a callback function was programmed.  */
        _ux_system_slave -> ux_system_slave_change_function(UX_DCD_STM32_DEVICE_RESUMED);
3419d844:	4b04      	ldr	r3, [pc, #16]	@ (3419d858 <HAL_PCD_ResumeCallback+0x28>)
3419d846:	681b      	ldr	r3, [r3, #0]
3419d848:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
3419d84c:	20f3      	movs	r0, #243	@ 0xf3
3419d84e:	4798      	blx	r3
    }
}
3419d850:	bf00      	nop
3419d852:	3708      	adds	r7, #8
3419d854:	46bd      	mov	sp, r7
3419d856:	bd80      	pop	{r7, pc}
3419d858:	341c33f8 	.word	0x341c33f8

3419d85c <HAL_PCD_SOFCallback>:
/*  07-29-2022     Chaoqiong Xiao           Modified comment(s),          */
/*                                            resulting in version 6.1.12 */
/*                                                                        */
/**************************************************************************/
void HAL_PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
{
3419d85c:	b580      	push	{r7, lr}
3419d85e:	b082      	sub	sp, #8
3419d860:	af00      	add	r7, sp, #0
3419d862:	6078      	str	r0, [r7, #4]

    /* Check the status change callback.  */
    if (_ux_system_slave -> ux_system_slave_change_function != UX_NULL)
3419d864:	4b07      	ldr	r3, [pc, #28]	@ (3419d884 <HAL_PCD_SOFCallback+0x28>)
3419d866:	681b      	ldr	r3, [r3, #0]
3419d868:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
3419d86c:	2b00      	cmp	r3, #0
3419d86e:	d005      	beq.n	3419d87c <HAL_PCD_SOFCallback+0x20>
    {

       /* Inform the application if a callback function was programmed.  */
        _ux_system_slave -> ux_system_slave_change_function(UX_DCD_STM32_SOF_RECEIVED);
3419d870:	4b04      	ldr	r3, [pc, #16]	@ (3419d884 <HAL_PCD_SOFCallback+0x28>)
3419d872:	681b      	ldr	r3, [r3, #0]
3419d874:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
3419d878:	20f0      	movs	r0, #240	@ 0xf0
3419d87a:	4798      	blx	r3
    }
}
3419d87c:	bf00      	nop
3419d87e:	3708      	adds	r7, #8
3419d880:	46bd      	mov	sp, r7
3419d882:	bd80      	pop	{r7, pc}
3419d884:	341c33f8 	.word	0x341c33f8

3419d888 <_stm32_ed_get>:
#endif /* defined(UX_DEVICE_BIDIRECTIONAL_ENDPOINT_SUPPORT) */
    PCD_HandleTypeDef   *pcd_handle;
} UX_DCD_STM32;

static inline struct UX_DCD_STM32_ED_STRUCT *_stm32_ed_get(UX_DCD_STM32 *dcd_stm32, ULONG ep_addr)
{
3419d888:	b480      	push	{r7}
3419d88a:	b085      	sub	sp, #20
3419d88c:	af00      	add	r7, sp, #0
3419d88e:	6078      	str	r0, [r7, #4]
3419d890:	6039      	str	r1, [r7, #0]
#if defined(UX_DEVICE_BIDIRECTIONAL_ENDPOINT_SUPPORT)
ULONG ep_dir = ep_addr & 0x80u;
3419d892:	683b      	ldr	r3, [r7, #0]
3419d894:	f003 0380 	and.w	r3, r3, #128	@ 0x80
3419d898:	60fb      	str	r3, [r7, #12]
#endif /* defined(UX_DEVICE_BIDIRECTIONAL_ENDPOINT_SUPPORT) */
ULONG ep_num = ep_addr & 0x7Fu;
3419d89a:	683b      	ldr	r3, [r7, #0]
3419d89c:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
3419d8a0:	60bb      	str	r3, [r7, #8]

    if (ep_num >= UX_DCD_STM32_MAX_ED ||
3419d8a2:	68bb      	ldr	r3, [r7, #8]
3419d8a4:	2b08      	cmp	r3, #8
3419d8a6:	d807      	bhi.n	3419d8b8 <_stm32_ed_get+0x30>
        ep_num >= dcd_stm32->pcd_handle->Init.dev_endpoints)
3419d8a8:	687b      	ldr	r3, [r7, #4]
3419d8aa:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
3419d8ae:	791b      	ldrb	r3, [r3, #4]
3419d8b0:	461a      	mov	r2, r3
    if (ep_num >= UX_DCD_STM32_MAX_ED ||
3419d8b2:	68bb      	ldr	r3, [r7, #8]
3419d8b4:	4293      	cmp	r3, r2
3419d8b6:	d301      	bcc.n	3419d8bc <_stm32_ed_get+0x34>
        return(UX_NULL);
3419d8b8:	2300      	movs	r3, #0
3419d8ba:	e013      	b.n	3419d8e4 <_stm32_ed_get+0x5c>

#if defined(UX_DEVICE_BIDIRECTIONAL_ENDPOINT_SUPPORT)
    if (ep_dir)
3419d8bc:	68fb      	ldr	r3, [r7, #12]
3419d8be:	2b00      	cmp	r3, #0
3419d8c0:	d008      	beq.n	3419d8d4 <_stm32_ed_get+0x4c>
        return(&dcd_stm32->ux_dcd_stm32_ed_in[ep_num]);
3419d8c2:	68ba      	ldr	r2, [r7, #8]
3419d8c4:	4613      	mov	r3, r2
3419d8c6:	005b      	lsls	r3, r3, #1
3419d8c8:	4413      	add	r3, r2
3419d8ca:	009b      	lsls	r3, r3, #2
3419d8cc:	3370      	adds	r3, #112	@ 0x70
3419d8ce:	687a      	ldr	r2, [r7, #4]
3419d8d0:	4413      	add	r3, r2
3419d8d2:	e007      	b.n	3419d8e4 <_stm32_ed_get+0x5c>
#endif /* defined(UX_DEVICE_BIDIRECTIONAL_ENDPOINT_SUPPORT) */

    return(&dcd_stm32->ux_dcd_stm32_ed[ep_num]);
3419d8d4:	68ba      	ldr	r2, [r7, #8]
3419d8d6:	4613      	mov	r3, r2
3419d8d8:	005b      	lsls	r3, r3, #1
3419d8da:	4413      	add	r3, r2
3419d8dc:	009b      	lsls	r3, r3, #2
3419d8de:	687a      	ldr	r2, [r7, #4]
3419d8e0:	4413      	add	r3, r2
3419d8e2:	3304      	adds	r3, #4
}
3419d8e4:	4618      	mov	r0, r3
3419d8e6:	3714      	adds	r7, #20
3419d8e8:	46bd      	mov	sp, r7
3419d8ea:	f85d 7b04 	ldr.w	r7, [sp], #4
3419d8ee:	4770      	bx	lr

3419d8f0 <_ux_dcd_stm32_endpoint_create>:
/*                                            controller,                 */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _ux_dcd_stm32_endpoint_create(UX_DCD_STM32 *dcd_stm32, UX_SLAVE_ENDPOINT *endpoint)
{
3419d8f0:	b580      	push	{r7, lr}
3419d8f2:	b084      	sub	sp, #16
3419d8f4:	af00      	add	r7, sp, #0
3419d8f6:	6078      	str	r0, [r7, #4]
3419d8f8:	6039      	str	r1, [r7, #0]
UX_DCD_STM32_ED     *ed;
ULONG               stm32_endpoint_index;


    /* The endpoint index in the array of the STM32 must match the endpoint number.  */
    stm32_endpoint_index =  endpoint -> ux_slave_endpoint_descriptor.bEndpointAddress & ~UX_ENDPOINT_DIRECTION;
3419d8fa:	683b      	ldr	r3, [r7, #0]
3419d8fc:	7b9b      	ldrb	r3, [r3, #14]
3419d8fe:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
3419d902:	60fb      	str	r3, [r7, #12]

    /* Get STM32 ED.  */
    ed = _stm32_ed_get(dcd_stm32, endpoint -> ux_slave_endpoint_descriptor.bEndpointAddress);
3419d904:	683b      	ldr	r3, [r7, #0]
3419d906:	7b9b      	ldrb	r3, [r3, #14]
3419d908:	4619      	mov	r1, r3
3419d90a:	6878      	ldr	r0, [r7, #4]
3419d90c:	f7ff ffbc 	bl	3419d888 <_stm32_ed_get>
3419d910:	60b8      	str	r0, [r7, #8]

    if (ed == UX_NULL)
3419d912:	68bb      	ldr	r3, [r7, #8]
3419d914:	2b00      	cmp	r3, #0
3419d916:	d101      	bne.n	3419d91c <_ux_dcd_stm32_endpoint_create+0x2c>
        return(UX_NO_ED_AVAILABLE);
3419d918:	2314      	movs	r3, #20
3419d91a:	e030      	b.n	3419d97e <_ux_dcd_stm32_endpoint_create+0x8e>

    /* Check the endpoint status, if it is free, reserve it. If not reject this endpoint.  */
    if ((ed -> ux_dcd_stm32_ed_status & UX_DCD_STM32_ED_STATUS_USED) == 0)
3419d91c:	68bb      	ldr	r3, [r7, #8]
3419d91e:	685b      	ldr	r3, [r3, #4]
3419d920:	f003 0301 	and.w	r3, r3, #1
3419d924:	2b00      	cmp	r3, #0
3419d926:	d129      	bne.n	3419d97c <_ux_dcd_stm32_endpoint_create+0x8c>
    {

        /* We can use this endpoint.  */
        ed -> ux_dcd_stm32_ed_status |=  UX_DCD_STM32_ED_STATUS_USED;
3419d928:	68bb      	ldr	r3, [r7, #8]
3419d92a:	685b      	ldr	r3, [r3, #4]
3419d92c:	f043 0201 	orr.w	r2, r3, #1
3419d930:	68bb      	ldr	r3, [r7, #8]
3419d932:	605a      	str	r2, [r3, #4]

        /* Keep the physical endpoint address in the endpoint container.  */
        endpoint -> ux_slave_endpoint_ed =  (VOID *) ed;
3419d934:	683b      	ldr	r3, [r7, #0]
3419d936:	68ba      	ldr	r2, [r7, #8]
3419d938:	609a      	str	r2, [r3, #8]

        /* Save the endpoint pointer.  */
        ed -> ux_dcd_stm32_ed_endpoint =  endpoint;
3419d93a:	68bb      	ldr	r3, [r7, #8]
3419d93c:	683a      	ldr	r2, [r7, #0]
3419d93e:	601a      	str	r2, [r3, #0]

        /* And its index.  */
        ed -> ux_dcd_stm32_ed_index =  stm32_endpoint_index;
3419d940:	68fb      	ldr	r3, [r7, #12]
3419d942:	b2da      	uxtb	r2, r3
3419d944:	68bb      	ldr	r3, [r7, #8]
3419d946:	725a      	strb	r2, [r3, #9]

        /* And its direction.  */
        ed -> ux_dcd_stm32_ed_direction =  endpoint -> ux_slave_endpoint_descriptor.bEndpointAddress & UX_ENDPOINT_DIRECTION;
3419d948:	683b      	ldr	r3, [r7, #0]
3419d94a:	7b9b      	ldrb	r3, [r3, #14]
3419d94c:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
3419d950:	b2da      	uxtb	r2, r3
3419d952:	68bb      	ldr	r3, [r7, #8]
3419d954:	729a      	strb	r2, [r3, #10]

        /* Check if it is non-control endpoint.  */
        if (stm32_endpoint_index != 0)
3419d956:	68fb      	ldr	r3, [r7, #12]
3419d958:	2b00      	cmp	r3, #0
3419d95a:	d00d      	beq.n	3419d978 <_ux_dcd_stm32_endpoint_create+0x88>
        {

            /* Open the endpoint.  */
            HAL_PCD_EP_Open(dcd_stm32 -> pcd_handle, endpoint -> ux_slave_endpoint_descriptor.bEndpointAddress,
3419d95c:	687b      	ldr	r3, [r7, #4]
3419d95e:	f8d3 00dc 	ldr.w	r0, [r3, #220]	@ 0xdc
3419d962:	683b      	ldr	r3, [r7, #0]
3419d964:	7b99      	ldrb	r1, [r3, #14]
3419d966:	683b      	ldr	r3, [r7, #0]
3419d968:	8a1a      	ldrh	r2, [r3, #16]
                            endpoint -> ux_slave_endpoint_descriptor.wMaxPacketSize,
                            endpoint -> ux_slave_endpoint_descriptor.bmAttributes & UX_MASK_ENDPOINT_TYPE);
3419d96a:	683b      	ldr	r3, [r7, #0]
3419d96c:	7bdb      	ldrb	r3, [r3, #15]
            HAL_PCD_EP_Open(dcd_stm32 -> pcd_handle, endpoint -> ux_slave_endpoint_descriptor.bEndpointAddress,
3419d96e:	f003 0303 	and.w	r3, r3, #3
3419d972:	b2db      	uxtb	r3, r3
3419d974:	f7eb faa3 	bl	34188ebe <HAL_PCD_EP_Open>
        }

        /* Return successful completion.  */
        return(UX_SUCCESS);
3419d978:	2300      	movs	r3, #0
3419d97a:	e000      	b.n	3419d97e <_ux_dcd_stm32_endpoint_create+0x8e>
    }

    /* Return an error.  */
    return(UX_NO_ED_AVAILABLE);
3419d97c:	2314      	movs	r3, #20
}
3419d97e:	4618      	mov	r0, r3
3419d980:	3710      	adds	r7, #16
3419d982:	46bd      	mov	sp, r7
3419d984:	bd80      	pop	{r7, pc}

3419d986 <_ux_dcd_stm32_endpoint_destroy>:
/*                                            controller,                 */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _ux_dcd_stm32_endpoint_destroy(UX_DCD_STM32 *dcd_stm32, UX_SLAVE_ENDPOINT *endpoint)
{
3419d986:	b580      	push	{r7, lr}
3419d988:	b084      	sub	sp, #16
3419d98a:	af00      	add	r7, sp, #0
3419d98c:	6078      	str	r0, [r7, #4]
3419d98e:	6039      	str	r1, [r7, #0]

UX_DCD_STM32_ED     *ed;


    /* Keep the physical endpoint address in the endpoint container.  */
    ed =  (UX_DCD_STM32_ED *) endpoint -> ux_slave_endpoint_ed;
3419d990:	683b      	ldr	r3, [r7, #0]
3419d992:	689b      	ldr	r3, [r3, #8]
3419d994:	60fb      	str	r3, [r7, #12]

    /* We can free this endpoint.  */
    ed -> ux_dcd_stm32_ed_status =  UX_DCD_STM32_ED_STATUS_UNUSED;
3419d996:	68fb      	ldr	r3, [r7, #12]
3419d998:	2200      	movs	r2, #0
3419d99a:	605a      	str	r2, [r3, #4]

    /* Deactivate the endpoint.  */
    HAL_PCD_EP_Close(dcd_stm32 -> pcd_handle, endpoint->ux_slave_endpoint_descriptor.bEndpointAddress);
3419d99c:	687b      	ldr	r3, [r7, #4]
3419d99e:	f8d3 20dc 	ldr.w	r2, [r3, #220]	@ 0xdc
3419d9a2:	683b      	ldr	r3, [r7, #0]
3419d9a4:	7b9b      	ldrb	r3, [r3, #14]
3419d9a6:	4619      	mov	r1, r3
3419d9a8:	4610      	mov	r0, r2
3419d9aa:	f7eb faf2 	bl	34188f92 <HAL_PCD_EP_Close>

    /* This function never fails.  */
    return(UX_SUCCESS);
3419d9ae:	2300      	movs	r3, #0
}
3419d9b0:	4618      	mov	r0, r3
3419d9b2:	3710      	adds	r7, #16
3419d9b4:	46bd      	mov	sp, r7
3419d9b6:	bd80      	pop	{r7, pc}

3419d9b8 <_ux_dcd_stm32_endpoint_reset>:
/*                                            added standalone support,   */
/*                                            resulting in version 6.1.10 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_dcd_stm32_endpoint_reset(UX_DCD_STM32 *dcd_stm32, UX_SLAVE_ENDPOINT *endpoint)
{
3419d9b8:	b580      	push	{r7, lr}
3419d9ba:	b088      	sub	sp, #32
3419d9bc:	af00      	add	r7, sp, #0
3419d9be:	6078      	str	r0, [r7, #4]
3419d9c0:	6039      	str	r1, [r7, #0]
UX_INTERRUPT_SAVE_AREA
UX_DCD_STM32_ED     *ed;


    /* Get the physical endpoint address in the endpoint container.  */
    ed =  (UX_DCD_STM32_ED *) endpoint -> ux_slave_endpoint_ed;
3419d9c2:	683b      	ldr	r3, [r7, #0]
3419d9c4:	689b      	ldr	r3, [r3, #8]
3419d9c6:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
3419d9c8:	f3ef 8310 	mrs	r3, PRIMASK
3419d9cc:	617b      	str	r3, [r7, #20]
    return(posture);
3419d9ce:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
3419d9d0:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
3419d9d2:	b672      	cpsid	i
    return(int_posture);
3419d9d4:	693b      	ldr	r3, [r7, #16]

    UX_DISABLE
3419d9d6:	61bb      	str	r3, [r7, #24]

    /* Set the status of the endpoint to not stalled.  */
    ed -> ux_dcd_stm32_ed_status &= ~(UX_DCD_STM32_ED_STATUS_STALLED |
3419d9d8:	69fb      	ldr	r3, [r7, #28]
3419d9da:	685b      	ldr	r3, [r3, #4]
3419d9dc:	f423 7243 	bic.w	r2, r3, #780	@ 0x30c
3419d9e0:	69fb      	ldr	r3, [r7, #28]
3419d9e2:	605a      	str	r2, [r3, #4]
                                      UX_DCD_STM32_ED_STATUS_DONE |
                                      UX_DCD_STM32_ED_STATUS_SETUP);

    /* Set the state of the endpoint to IDLE.  */
    ed -> ux_dcd_stm32_ed_state =  UX_DCD_STM32_ED_STATE_IDLE;
3419d9e4:	69fb      	ldr	r3, [r7, #28]
3419d9e6:	2200      	movs	r2, #0
3419d9e8:	721a      	strb	r2, [r3, #8]

    /* Clear STALL condition.  */
    HAL_PCD_EP_ClrStall(dcd_stm32 -> pcd_handle, endpoint -> ux_slave_endpoint_descriptor.bEndpointAddress);
3419d9ea:	687b      	ldr	r3, [r7, #4]
3419d9ec:	f8d3 20dc 	ldr.w	r2, [r3, #220]	@ 0xdc
3419d9f0:	683b      	ldr	r3, [r7, #0]
3419d9f2:	7b9b      	ldrb	r3, [r3, #14]
3419d9f4:	4619      	mov	r1, r3
3419d9f6:	4610      	mov	r0, r2
3419d9f8:	f7eb fc05 	bl	34189206 <HAL_PCD_EP_ClrStall>

    /* Flush buffer.  */
    HAL_PCD_EP_Flush(dcd_stm32 -> pcd_handle, endpoint->ux_slave_endpoint_descriptor.bEndpointAddress);
3419d9fc:	687b      	ldr	r3, [r7, #4]
3419d9fe:	f8d3 20dc 	ldr.w	r2, [r3, #220]	@ 0xdc
3419da02:	683b      	ldr	r3, [r7, #0]
3419da04:	7b9b      	ldrb	r3, [r3, #14]
3419da06:	4619      	mov	r1, r3
3419da08:	4610      	mov	r0, r2
3419da0a:	f7eb fc83 	bl	34189314 <HAL_PCD_EP_Flush>

#ifndef UX_DEVICE_STANDALONE

    /* Wakeup pending thread.  */
    if (endpoint -> ux_slave_endpoint_transfer_request.ux_slave_transfer_request_semaphore.tx_semaphore_suspended_count)
3419da0e:	683b      	ldr	r3, [r7, #0]
3419da10:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3419da12:	2b00      	cmp	r3, #0
3419da14:	d004      	beq.n	3419da20 <_ux_dcd_stm32_endpoint_reset+0x68>
        _ux_utility_semaphore_put(&endpoint -> ux_slave_endpoint_transfer_request.ux_slave_transfer_request_semaphore);
3419da16:	683b      	ldr	r3, [r7, #0]
3419da18:	3350      	adds	r3, #80	@ 0x50
3419da1a:	4618      	mov	r0, r3
3419da1c:	f7fc fa98 	bl	34199f50 <_ux_utility_semaphore_put>
3419da20:	69bb      	ldr	r3, [r7, #24]
3419da22:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
3419da24:	68fb      	ldr	r3, [r7, #12]
3419da26:	f383 8810 	msr	PRIMASK, r3
}
3419da2a:	bf00      	nop
#endif

    UX_RESTORE

    /* This function never fails.  */
    return(UX_SUCCESS);
3419da2c:	2300      	movs	r3, #0
}
3419da2e:	4618      	mov	r0, r3
3419da30:	3720      	adds	r7, #32
3419da32:	46bd      	mov	sp, r7
3419da34:	bd80      	pop	{r7, pc}

3419da36 <_ux_dcd_stm32_endpoint_stall>:
/*                                            controller,                 */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _ux_dcd_stm32_endpoint_stall(UX_DCD_STM32 *dcd_stm32, UX_SLAVE_ENDPOINT *endpoint)
{
3419da36:	b580      	push	{r7, lr}
3419da38:	b084      	sub	sp, #16
3419da3a:	af00      	add	r7, sp, #0
3419da3c:	6078      	str	r0, [r7, #4]
3419da3e:	6039      	str	r1, [r7, #0]

UX_DCD_STM32_ED     *ed;


    /* Get the physical endpoint address in the endpoint container.  */
    ed =  (UX_DCD_STM32_ED *) endpoint -> ux_slave_endpoint_ed;
3419da40:	683b      	ldr	r3, [r7, #0]
3419da42:	689b      	ldr	r3, [r3, #8]
3419da44:	60fb      	str	r3, [r7, #12]

    /* Set the endpoint to stall.  */
    ed -> ux_dcd_stm32_ed_status |=  UX_DCD_STM32_ED_STATUS_STALLED;
3419da46:	68fb      	ldr	r3, [r7, #12]
3419da48:	685b      	ldr	r3, [r3, #4]
3419da4a:	f043 0204 	orr.w	r2, r3, #4
3419da4e:	68fb      	ldr	r3, [r7, #12]
3419da50:	605a      	str	r2, [r3, #4]

    /* Stall the endpoint.  */
    HAL_PCD_EP_SetStall(dcd_stm32 -> pcd_handle, endpoint->ux_slave_endpoint_descriptor.bEndpointAddress | ed -> ux_dcd_stm32_ed_direction);
3419da52:	687b      	ldr	r3, [r7, #4]
3419da54:	f8d3 00dc 	ldr.w	r0, [r3, #220]	@ 0xdc
3419da58:	683b      	ldr	r3, [r7, #0]
3419da5a:	7b9a      	ldrb	r2, [r3, #14]
3419da5c:	68fb      	ldr	r3, [r7, #12]
3419da5e:	7a9b      	ldrb	r3, [r3, #10]
3419da60:	4313      	orrs	r3, r2
3419da62:	b2db      	uxtb	r3, r3
3419da64:	4619      	mov	r1, r3
3419da66:	f7eb fb6b 	bl	34189140 <HAL_PCD_EP_SetStall>

    /* This function never fails.  */
    return(UX_SUCCESS);
3419da6a:	2300      	movs	r3, #0
}
3419da6c:	4618      	mov	r0, r3
3419da6e:	3710      	adds	r7, #16
3419da70:	46bd      	mov	sp, r7
3419da72:	bd80      	pop	{r7, pc}

3419da74 <_stm32_ed_get>:
{
3419da74:	b480      	push	{r7}
3419da76:	b085      	sub	sp, #20
3419da78:	af00      	add	r7, sp, #0
3419da7a:	6078      	str	r0, [r7, #4]
3419da7c:	6039      	str	r1, [r7, #0]
ULONG ep_dir = ep_addr & 0x80u;
3419da7e:	683b      	ldr	r3, [r7, #0]
3419da80:	f003 0380 	and.w	r3, r3, #128	@ 0x80
3419da84:	60fb      	str	r3, [r7, #12]
ULONG ep_num = ep_addr & 0x7Fu;
3419da86:	683b      	ldr	r3, [r7, #0]
3419da88:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
3419da8c:	60bb      	str	r3, [r7, #8]
    if (ep_num >= UX_DCD_STM32_MAX_ED ||
3419da8e:	68bb      	ldr	r3, [r7, #8]
3419da90:	2b08      	cmp	r3, #8
3419da92:	d807      	bhi.n	3419daa4 <_stm32_ed_get+0x30>
        ep_num >= dcd_stm32->pcd_handle->Init.dev_endpoints)
3419da94:	687b      	ldr	r3, [r7, #4]
3419da96:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
3419da9a:	791b      	ldrb	r3, [r3, #4]
3419da9c:	461a      	mov	r2, r3
    if (ep_num >= UX_DCD_STM32_MAX_ED ||
3419da9e:	68bb      	ldr	r3, [r7, #8]
3419daa0:	4293      	cmp	r3, r2
3419daa2:	d301      	bcc.n	3419daa8 <_stm32_ed_get+0x34>
        return(UX_NULL);
3419daa4:	2300      	movs	r3, #0
3419daa6:	e013      	b.n	3419dad0 <_stm32_ed_get+0x5c>
    if (ep_dir)
3419daa8:	68fb      	ldr	r3, [r7, #12]
3419daaa:	2b00      	cmp	r3, #0
3419daac:	d008      	beq.n	3419dac0 <_stm32_ed_get+0x4c>
        return(&dcd_stm32->ux_dcd_stm32_ed_in[ep_num]);
3419daae:	68ba      	ldr	r2, [r7, #8]
3419dab0:	4613      	mov	r3, r2
3419dab2:	005b      	lsls	r3, r3, #1
3419dab4:	4413      	add	r3, r2
3419dab6:	009b      	lsls	r3, r3, #2
3419dab8:	3370      	adds	r3, #112	@ 0x70
3419daba:	687a      	ldr	r2, [r7, #4]
3419dabc:	4413      	add	r3, r2
3419dabe:	e007      	b.n	3419dad0 <_stm32_ed_get+0x5c>
    return(&dcd_stm32->ux_dcd_stm32_ed[ep_num]);
3419dac0:	68ba      	ldr	r2, [r7, #8]
3419dac2:	4613      	mov	r3, r2
3419dac4:	005b      	lsls	r3, r3, #1
3419dac6:	4413      	add	r3, r2
3419dac8:	009b      	lsls	r3, r3, #2
3419daca:	687a      	ldr	r2, [r7, #4]
3419dacc:	4413      	add	r3, r2
3419dace:	3304      	adds	r3, #4
}
3419dad0:	4618      	mov	r0, r3
3419dad2:	3714      	adds	r7, #20
3419dad4:	46bd      	mov	sp, r7
3419dad6:	f85d 7b04 	ldr.w	r7, [sp], #4
3419dada:	4770      	bx	lr

3419dadc <_ux_dcd_stm32_endpoint_status>:
/*                                            added bi-dir EP support,    */
/*                                            resulting in version 6.1.10 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_dcd_stm32_endpoint_status(UX_DCD_STM32 *dcd_stm32, ULONG endpoint_index)
{
3419dadc:	b580      	push	{r7, lr}
3419dade:	b084      	sub	sp, #16
3419dae0:	af00      	add	r7, sp, #0
3419dae2:	6078      	str	r0, [r7, #4]
3419dae4:	6039      	str	r1, [r7, #0]

UX_DCD_STM32_ED      *ed;


    /* Fetch the address of the physical endpoint.  */
    ed = _stm32_ed_get(dcd_stm32, endpoint_index);
3419dae6:	6839      	ldr	r1, [r7, #0]
3419dae8:	6878      	ldr	r0, [r7, #4]
3419daea:	f7ff ffc3 	bl	3419da74 <_stm32_ed_get>
3419daee:	60f8      	str	r0, [r7, #12]

    /* Check the endpoint status, if it is free, we have a illegal endpoint.  */
    if ((ed -> ux_dcd_stm32_ed_status & UX_DCD_STM32_ED_STATUS_USED) == 0)
3419daf0:	68fb      	ldr	r3, [r7, #12]
3419daf2:	685b      	ldr	r3, [r3, #4]
3419daf4:	f003 0301 	and.w	r3, r3, #1
3419daf8:	2b00      	cmp	r3, #0
3419dafa:	d101      	bne.n	3419db00 <_ux_dcd_stm32_endpoint_status+0x24>
        return(UX_ERROR);
3419dafc:	23ff      	movs	r3, #255	@ 0xff
3419dafe:	e008      	b.n	3419db12 <_ux_dcd_stm32_endpoint_status+0x36>

    /* Check if the endpoint is stalled.  */
    if ((ed -> ux_dcd_stm32_ed_status & UX_DCD_STM32_ED_STATUS_STALLED) == 0)
3419db00:	68fb      	ldr	r3, [r7, #12]
3419db02:	685b      	ldr	r3, [r3, #4]
3419db04:	f003 0304 	and.w	r3, r3, #4
3419db08:	2b00      	cmp	r3, #0
3419db0a:	d101      	bne.n	3419db10 <_ux_dcd_stm32_endpoint_status+0x34>
        return(UX_FALSE);
3419db0c:	2300      	movs	r3, #0
3419db0e:	e000      	b.n	3419db12 <_ux_dcd_stm32_endpoint_status+0x36>
    else
        return(UX_TRUE);
3419db10:	2301      	movs	r3, #1
}
3419db12:	4618      	mov	r0, r3
3419db14:	3710      	adds	r7, #16
3419db16:	46bd      	mov	sp, r7
3419db18:	bd80      	pop	{r7, pc}

3419db1a <_ux_dcd_stm32_frame_number_get>:
/*                                            controller,                 */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _ux_dcd_stm32_frame_number_get(UX_DCD_STM32 *dcd_stm32, ULONG *frame_number)
{
3419db1a:	b480      	push	{r7}
3419db1c:	b083      	sub	sp, #12
3419db1e:	af00      	add	r7, sp, #0
3419db20:	6078      	str	r0, [r7, #4]
3419db22:	6039      	str	r1, [r7, #0]

    /* This function never fails. */
    return(UX_SUCCESS);
3419db24:	2300      	movs	r3, #0
}
3419db26:	4618      	mov	r0, r3
3419db28:	370c      	adds	r7, #12
3419db2a:	46bd      	mov	sp, r7
3419db2c:	f85d 7b04 	ldr.w	r7, [sp], #4
3419db30:	4770      	bx	lr
	...

3419db34 <_ux_dcd_stm32_function>:
/*                                            added standalone support,   */
/*                                            resulting in version 6.1.10 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_dcd_stm32_function(UX_SLAVE_DCD *dcd, UINT function, VOID *parameter)
{
3419db34:	b580      	push	{r7, lr}
3419db36:	b086      	sub	sp, #24
3419db38:	af00      	add	r7, sp, #0
3419db3a:	60f8      	str	r0, [r7, #12]
3419db3c:	60b9      	str	r1, [r7, #8]
3419db3e:	607a      	str	r2, [r7, #4]
UINT             status;
UX_DCD_STM32     *dcd_stm32;


    /* Check the status of the controller.  */
    if (dcd -> ux_slave_dcd_status == UX_UNUSED)
3419db40:	68fb      	ldr	r3, [r7, #12]
3419db42:	681b      	ldr	r3, [r3, #0]
3419db44:	2b00      	cmp	r3, #0
3419db46:	d106      	bne.n	3419db56 <_ux_dcd_stm32_function+0x22>
    {

        /* Error trap. */
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_DCD, UX_CONTROLLER_UNKNOWN);
3419db48:	2255      	movs	r2, #85	@ 0x55
3419db4a:	2102      	movs	r1, #2
3419db4c:	2002      	movs	r0, #2
3419db4e:	f7fb fcb7 	bl	341994c0 <_ux_system_error_handler>

        /* If trace is enabled, insert this event into the trace buffer.  */
        UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_CONTROLLER_UNKNOWN, 0, 0, 0, UX_TRACE_ERRORS, 0, 0)

        return(UX_CONTROLLER_UNKNOWN);
3419db52:	2355      	movs	r3, #85	@ 0x55
3419db54:	e077      	b.n	3419dc46 <_ux_dcd_stm32_function+0x112>
    }

    /* Get the pointer to the STM32 DCD.  */
    dcd_stm32 =  (UX_DCD_STM32 *) dcd -> ux_slave_dcd_controller_hardware;
3419db56:	68fb      	ldr	r3, [r7, #12]
3419db58:	69db      	ldr	r3, [r3, #28]
3419db5a:	613b      	str	r3, [r7, #16]

    /* Look at the function and route it.  */
    switch(function)
3419db5c:	68bb      	ldr	r3, [r7, #8]
3419db5e:	3b0a      	subs	r3, #10
3419db60:	2b0b      	cmp	r3, #11
3419db62:	d867      	bhi.n	3419dc34 <_ux_dcd_stm32_function+0x100>
3419db64:	a201      	add	r2, pc, #4	@ (adr r2, 3419db6c <_ux_dcd_stm32_function+0x38>)
3419db66:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3419db6a:	bf00      	nop
3419db6c:	3419db9d 	.word	0x3419db9d
3419db70:	3419dc35 	.word	0x3419dc35
3419db74:	3419dba9 	.word	0x3419dba9
3419db78:	3419dbb5 	.word	0x3419dbb5
3419db7c:	3419dbc1 	.word	0x3419dbc1
3419db80:	3419dbcd 	.word	0x3419dbcd
3419db84:	3419dbd9 	.word	0x3419dbd9
3419db88:	3419dbf1 	.word	0x3419dbf1
3419db8c:	3419dc35 	.word	0x3419dc35
3419db90:	3419dc09 	.word	0x3419dc09
3419db94:	3419dbe5 	.word	0x3419dbe5
3419db98:	3419dc27 	.word	0x3419dc27
    {

    case UX_DCD_GET_FRAME_NUMBER:

        status =  _ux_dcd_stm32_frame_number_get(dcd_stm32, (ULONG *) parameter);
3419db9c:	6879      	ldr	r1, [r7, #4]
3419db9e:	6938      	ldr	r0, [r7, #16]
3419dba0:	f7ff ffbb 	bl	3419db1a <_ux_dcd_stm32_frame_number_get>
3419dba4:	6178      	str	r0, [r7, #20]
        break;
3419dba6:	e04d      	b.n	3419dc44 <_ux_dcd_stm32_function+0x110>
    case UX_DCD_TRANSFER_REQUEST:

#if defined(UX_DEVICE_STANDALONE)
        status =  _ux_dcd_stm32_transfer_run(dcd_stm32, (UX_SLAVE_TRANSFER *) parameter);
#else
        status =  _ux_dcd_stm32_transfer_request(dcd_stm32, (UX_SLAVE_TRANSFER *) parameter);
3419dba8:	6879      	ldr	r1, [r7, #4]
3419dbaa:	6938      	ldr	r0, [r7, #16]
3419dbac:	f000 f96b 	bl	3419de86 <_ux_dcd_stm32_transfer_request>
3419dbb0:	6178      	str	r0, [r7, #20]
#endif /* defined(UX_DEVICE_STANDALONE) */
        break;
3419dbb2:	e047      	b.n	3419dc44 <_ux_dcd_stm32_function+0x110>

    case UX_DCD_TRANSFER_ABORT:
        status = _ux_dcd_stm32_transfer_abort(dcd_stm32, parameter);
3419dbb4:	6879      	ldr	r1, [r7, #4]
3419dbb6:	6938      	ldr	r0, [r7, #16]
3419dbb8:	f000 f946 	bl	3419de48 <_ux_dcd_stm32_transfer_abort>
3419dbbc:	6178      	str	r0, [r7, #20]
        break;
3419dbbe:	e041      	b.n	3419dc44 <_ux_dcd_stm32_function+0x110>

    case UX_DCD_CREATE_ENDPOINT:

        status =  _ux_dcd_stm32_endpoint_create(dcd_stm32, parameter);
3419dbc0:	6879      	ldr	r1, [r7, #4]
3419dbc2:	6938      	ldr	r0, [r7, #16]
3419dbc4:	f7ff fe94 	bl	3419d8f0 <_ux_dcd_stm32_endpoint_create>
3419dbc8:	6178      	str	r0, [r7, #20]
        break;
3419dbca:	e03b      	b.n	3419dc44 <_ux_dcd_stm32_function+0x110>

    case UX_DCD_DESTROY_ENDPOINT:

        status =  _ux_dcd_stm32_endpoint_destroy(dcd_stm32, parameter);
3419dbcc:	6879      	ldr	r1, [r7, #4]
3419dbce:	6938      	ldr	r0, [r7, #16]
3419dbd0:	f7ff fed9 	bl	3419d986 <_ux_dcd_stm32_endpoint_destroy>
3419dbd4:	6178      	str	r0, [r7, #20]
        break;
3419dbd6:	e035      	b.n	3419dc44 <_ux_dcd_stm32_function+0x110>

    case UX_DCD_RESET_ENDPOINT:

        status =  _ux_dcd_stm32_endpoint_reset(dcd_stm32, parameter);
3419dbd8:	6879      	ldr	r1, [r7, #4]
3419dbda:	6938      	ldr	r0, [r7, #16]
3419dbdc:	f7ff feec 	bl	3419d9b8 <_ux_dcd_stm32_endpoint_reset>
3419dbe0:	6178      	str	r0, [r7, #20]
        break;
3419dbe2:	e02f      	b.n	3419dc44 <_ux_dcd_stm32_function+0x110>

    case UX_DCD_STALL_ENDPOINT:

        status =  _ux_dcd_stm32_endpoint_stall(dcd_stm32, parameter);
3419dbe4:	6879      	ldr	r1, [r7, #4]
3419dbe6:	6938      	ldr	r0, [r7, #16]
3419dbe8:	f7ff ff25 	bl	3419da36 <_ux_dcd_stm32_endpoint_stall>
3419dbec:	6178      	str	r0, [r7, #20]
        break;
3419dbee:	e029      	b.n	3419dc44 <_ux_dcd_stm32_function+0x110>

    case UX_DCD_SET_DEVICE_ADDRESS:

        status =  HAL_PCD_SetAddress(dcd_stm32 -> pcd_handle, (uint8_t)(ULONG) parameter);
3419dbf0:	693b      	ldr	r3, [r7, #16]
3419dbf2:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
3419dbf6:	687a      	ldr	r2, [r7, #4]
3419dbf8:	b2d2      	uxtb	r2, r2
3419dbfa:	4611      	mov	r1, r2
3419dbfc:	4618      	mov	r0, r3
3419dbfe:	f7eb f93a 	bl	34188e76 <HAL_PCD_SetAddress>
3419dc02:	4603      	mov	r3, r0
3419dc04:	617b      	str	r3, [r7, #20]
        break;
3419dc06:	e01d      	b.n	3419dc44 <_ux_dcd_stm32_function+0x110>

    case UX_DCD_CHANGE_STATE:

        if ((ULONG) parameter == UX_DEVICE_FORCE_DISCONNECT)
3419dc08:	687b      	ldr	r3, [r7, #4]
3419dc0a:	2b0b      	cmp	r3, #11
3419dc0c:	d108      	bne.n	3419dc20 <_ux_dcd_stm32_function+0xec>
        {
          /* Disconnect the USB device */
          status =  HAL_PCD_Stop(dcd_stm32 -> pcd_handle);
3419dc0e:	693b      	ldr	r3, [r7, #16]
3419dc10:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
3419dc14:	4618      	mov	r0, r3
3419dc16:	f7ea fc20 	bl	3418845a <HAL_PCD_Stop>
3419dc1a:	4603      	mov	r3, r0
3419dc1c:	617b      	str	r3, [r7, #20]
        else
        {
          status = UX_SUCCESS;
        }

        break;
3419dc1e:	e011      	b.n	3419dc44 <_ux_dcd_stm32_function+0x110>
          status = UX_SUCCESS;
3419dc20:	2300      	movs	r3, #0
3419dc22:	617b      	str	r3, [r7, #20]
        break;
3419dc24:	e00e      	b.n	3419dc44 <_ux_dcd_stm32_function+0x110>

    case UX_DCD_ENDPOINT_STATUS:

        status =  _ux_dcd_stm32_endpoint_status(dcd_stm32, (ULONG) parameter);
3419dc26:	687b      	ldr	r3, [r7, #4]
3419dc28:	4619      	mov	r1, r3
3419dc2a:	6938      	ldr	r0, [r7, #16]
3419dc2c:	f7ff ff56 	bl	3419dadc <_ux_dcd_stm32_endpoint_status>
3419dc30:	6178      	str	r0, [r7, #20]
        break;
3419dc32:	e007      	b.n	3419dc44 <_ux_dcd_stm32_function+0x110>
#endif /* defined(UX_DEVICE_STANDALONE) */

    default:

        /* Error trap. */
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_DCD, UX_FUNCTION_NOT_SUPPORTED);
3419dc34:	2254      	movs	r2, #84	@ 0x54
3419dc36:	2102      	movs	r1, #2
3419dc38:	2002      	movs	r0, #2
3419dc3a:	f7fb fc41 	bl	341994c0 <_ux_system_error_handler>

        /* If trace is enabled, insert this event into the trace buffer.  */
        UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_FUNCTION_NOT_SUPPORTED, 0, 0, 0, UX_TRACE_ERRORS, 0, 0)

        status =  UX_FUNCTION_NOT_SUPPORTED;
3419dc3e:	2354      	movs	r3, #84	@ 0x54
3419dc40:	617b      	str	r3, [r7, #20]
        break;
3419dc42:	bf00      	nop
    }

    /* Return completion status.  */
    return(status);
3419dc44:	697b      	ldr	r3, [r7, #20]
}
3419dc46:	4618      	mov	r0, r3
3419dc48:	3718      	adds	r7, #24
3419dc4a:	46bd      	mov	sp, r7
3419dc4c:	bd80      	pop	{r7, pc}
3419dc4e:	bf00      	nop

3419dc50 <_ux_dcd_stm32_initialize>:
/*                                            controller,                 */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _ux_dcd_stm32_initialize(ULONG dcd_io, ULONG parameter)
{
3419dc50:	b580      	push	{r7, lr}
3419dc52:	b084      	sub	sp, #16
3419dc54:	af00      	add	r7, sp, #0
3419dc56:	6078      	str	r0, [r7, #4]
3419dc58:	6039      	str	r1, [r7, #0]


    UX_PARAMETER_NOT_USED(dcd_io);

    /* Get the pointer to the DCD.  */
    dcd =  &_ux_system_slave -> ux_system_slave_dcd;
3419dc5a:	4b13      	ldr	r3, [pc, #76]	@ (3419dca8 <_ux_dcd_stm32_initialize+0x58>)
3419dc5c:	681b      	ldr	r3, [r3, #0]
3419dc5e:	60fb      	str	r3, [r7, #12]

    /* The controller initialized here is of STM32 type.  */
    dcd -> ux_slave_dcd_controller_type =  UX_DCD_STM32_SLAVE_CONTROLLER;
3419dc60:	68fb      	ldr	r3, [r7, #12]
3419dc62:	2280      	movs	r2, #128	@ 0x80
3419dc64:	605a      	str	r2, [r3, #4]

    /* Allocate memory for this STM32 DCD instance.  */
    dcd_stm32 =  _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, sizeof(UX_DCD_STM32));
3419dc66:	22e0      	movs	r2, #224	@ 0xe0
3419dc68:	2100      	movs	r1, #0
3419dc6a:	2000      	movs	r0, #0
3419dc6c:	f7fb fe14 	bl	34199898 <_ux_utility_memory_allocate>
3419dc70:	60b8      	str	r0, [r7, #8]

    /* Check if memory was properly allocated.  */
    if(dcd_stm32 == UX_NULL)
3419dc72:	68bb      	ldr	r3, [r7, #8]
3419dc74:	2b00      	cmp	r3, #0
3419dc76:	d101      	bne.n	3419dc7c <_ux_dcd_stm32_initialize+0x2c>
        return(UX_MEMORY_INSUFFICIENT);
3419dc78:	2312      	movs	r3, #18
3419dc7a:	e010      	b.n	3419dc9e <_ux_dcd_stm32_initialize+0x4e>

    /* Set the pointer to the STM32 DCD.  */
    dcd -> ux_slave_dcd_controller_hardware =  (VOID *) dcd_stm32;
3419dc7c:	68fb      	ldr	r3, [r7, #12]
3419dc7e:	68ba      	ldr	r2, [r7, #8]
3419dc80:	61da      	str	r2, [r3, #28]

    /* Set the generic DCD owner for the STM32 DCD.  */
    dcd_stm32 -> ux_dcd_stm32_dcd_owner =  dcd;
3419dc82:	68bb      	ldr	r3, [r7, #8]
3419dc84:	68fa      	ldr	r2, [r7, #12]
3419dc86:	601a      	str	r2, [r3, #0]

    /* Initialize the function collector for this DCD.  */
    dcd -> ux_slave_dcd_function =  _ux_dcd_stm32_function;
3419dc88:	68fb      	ldr	r3, [r7, #12]
3419dc8a:	4a08      	ldr	r2, [pc, #32]	@ (3419dcac <_ux_dcd_stm32_initialize+0x5c>)
3419dc8c:	619a      	str	r2, [r3, #24]

    dcd_stm32 -> pcd_handle = (PCD_HandleTypeDef *)parameter;
3419dc8e:	683a      	ldr	r2, [r7, #0]
3419dc90:	68bb      	ldr	r3, [r7, #8]
3419dc92:	f8c3 20dc 	str.w	r2, [r3, #220]	@ 0xdc

    /* Set the state of the controller to OPERATIONAL now.  */
    dcd -> ux_slave_dcd_status =  UX_DCD_STATUS_OPERATIONAL;
3419dc96:	68fb      	ldr	r3, [r7, #12]
3419dc98:	2201      	movs	r2, #1
3419dc9a:	601a      	str	r2, [r3, #0]

    /* Return successful completion.  */
    return(UX_SUCCESS);
3419dc9c:	2300      	movs	r3, #0
}
3419dc9e:	4618      	mov	r0, r3
3419dca0:	3710      	adds	r7, #16
3419dca2:	46bd      	mov	sp, r7
3419dca4:	bd80      	pop	{r7, pc}
3419dca6:	bf00      	nop
3419dca8:	341c33f8 	.word	0x341c33f8
3419dcac:	3419db35 	.word	0x3419db35

3419dcb0 <_ux_dcd_stm32_initialize_complete>:
/*                                            drive the controller,       */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _ux_dcd_stm32_initialize_complete(VOID)
{
3419dcb0:	b580      	push	{r7, lr}
3419dcb2:	b086      	sub	sp, #24
3419dcb4:	af00      	add	r7, sp, #0
UCHAR                     *device_framework;
UX_SLAVE_TRANSFER       *transfer_request;


    /* Get the pointer to the DCD.  */
    dcd =  &_ux_system_slave -> ux_system_slave_dcd;
3419dcb6:	4b62      	ldr	r3, [pc, #392]	@ (3419de40 <_ux_dcd_stm32_initialize_complete+0x190>)
3419dcb8:	681b      	ldr	r3, [r3, #0]
3419dcba:	617b      	str	r3, [r7, #20]

    /* Get the pointer to the STM32 DCD.  */
    dcd_stm32 = (UX_DCD_STM32 *) dcd -> ux_slave_dcd_controller_hardware;
3419dcbc:	697b      	ldr	r3, [r7, #20]
3419dcbe:	69db      	ldr	r3, [r3, #28]
3419dcc0:	613b      	str	r3, [r7, #16]

    /* Get the pointer to the device.  */
    device =  &_ux_system_slave -> ux_system_slave_device;
3419dcc2:	4b5f      	ldr	r3, [pc, #380]	@ (3419de40 <_ux_dcd_stm32_initialize_complete+0x190>)
3419dcc4:	681b      	ldr	r3, [r3, #0]
3419dcc6:	3320      	adds	r3, #32
3419dcc8:	60fb      	str	r3, [r7, #12]

    /* Are we in DFU mode ? If so, check if we are in a Reset mode.  */
    if (_ux_system_slave -> ux_system_slave_device_dfu_state_machine == UX_SYSTEM_DFU_STATE_APP_DETACH)
3419dcca:	4b5d      	ldr	r3, [pc, #372]	@ (3419de40 <_ux_dcd_stm32_initialize_complete+0x190>)
3419dccc:	681b      	ldr	r3, [r3, #0]
3419dcce:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
3419dcd2:	2b01      	cmp	r3, #1
3419dcd4:	d110      	bne.n	3419dcf8 <_ux_dcd_stm32_initialize_complete+0x48>
    {

        /* The device is now in DFU reset mode. Switch to the DFU device framework.  */
        _ux_system_slave -> ux_system_slave_device_framework =  _ux_system_slave -> ux_system_slave_dfu_framework;
3419dcd6:	4b5a      	ldr	r3, [pc, #360]	@ (3419de40 <_ux_dcd_stm32_initialize_complete+0x190>)
3419dcd8:	681a      	ldr	r2, [r3, #0]
3419dcda:	4b59      	ldr	r3, [pc, #356]	@ (3419de40 <_ux_dcd_stm32_initialize_complete+0x190>)
3419dcdc:	681b      	ldr	r3, [r3, #0]
3419dcde:	f8d2 2108 	ldr.w	r2, [r2, #264]	@ 0x108
3419dce2:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
        _ux_system_slave -> ux_system_slave_device_framework_length =  _ux_system_slave -> ux_system_slave_dfu_framework_length;
3419dce6:	4b56      	ldr	r3, [pc, #344]	@ (3419de40 <_ux_dcd_stm32_initialize_complete+0x190>)
3419dce8:	681a      	ldr	r2, [r3, #0]
3419dcea:	4b55      	ldr	r3, [pc, #340]	@ (3419de40 <_ux_dcd_stm32_initialize_complete+0x190>)
3419dcec:	681b      	ldr	r3, [r3, #0]
3419dcee:	f8d2 210c 	ldr.w	r2, [r2, #268]	@ 0x10c
3419dcf2:	f8c3 20e4 	str.w	r2, [r3, #228]	@ 0xe4
3419dcf6:	e02b      	b.n	3419dd50 <_ux_dcd_stm32_initialize_complete+0xa0>
    }
    else
    {

        /* Set State to App Idle. */
        _ux_system_slave -> ux_system_slave_device_dfu_state_machine = UX_SYSTEM_DFU_STATE_APP_IDLE;
3419dcf8:	4b51      	ldr	r3, [pc, #324]	@ (3419de40 <_ux_dcd_stm32_initialize_complete+0x190>)
3419dcfa:	681b      	ldr	r3, [r3, #0]
3419dcfc:	2200      	movs	r2, #0
3419dcfe:	f8c3 2170 	str.w	r2, [r3, #368]	@ 0x170

        /* Check the speed and set the correct descriptor.  */
        if (_ux_system_slave -> ux_system_slave_speed ==  UX_FULL_SPEED_DEVICE)
3419dd02:	4b4f      	ldr	r3, [pc, #316]	@ (3419de40 <_ux_dcd_stm32_initialize_complete+0x190>)
3419dd04:	681b      	ldr	r3, [r3, #0]
3419dd06:	f8d3 3154 	ldr.w	r3, [r3, #340]	@ 0x154
3419dd0a:	2b01      	cmp	r3, #1
3419dd0c:	d110      	bne.n	3419dd30 <_ux_dcd_stm32_initialize_complete+0x80>
        {

            /* The device is operating at full speed.  */
            _ux_system_slave -> ux_system_slave_device_framework =  _ux_system_slave -> ux_system_slave_device_framework_full_speed;
3419dd0e:	4b4c      	ldr	r3, [pc, #304]	@ (3419de40 <_ux_dcd_stm32_initialize_complete+0x190>)
3419dd10:	681a      	ldr	r2, [r3, #0]
3419dd12:	4b4b      	ldr	r3, [pc, #300]	@ (3419de40 <_ux_dcd_stm32_initialize_complete+0x190>)
3419dd14:	681b      	ldr	r3, [r3, #0]
3419dd16:	f8d2 20e8 	ldr.w	r2, [r2, #232]	@ 0xe8
3419dd1a:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
            _ux_system_slave -> ux_system_slave_device_framework_length =  _ux_system_slave -> ux_system_slave_device_framework_length_full_speed;
3419dd1e:	4b48      	ldr	r3, [pc, #288]	@ (3419de40 <_ux_dcd_stm32_initialize_complete+0x190>)
3419dd20:	681a      	ldr	r2, [r3, #0]
3419dd22:	4b47      	ldr	r3, [pc, #284]	@ (3419de40 <_ux_dcd_stm32_initialize_complete+0x190>)
3419dd24:	681b      	ldr	r3, [r3, #0]
3419dd26:	f8d2 20ec 	ldr.w	r2, [r2, #236]	@ 0xec
3419dd2a:	f8c3 20e4 	str.w	r2, [r3, #228]	@ 0xe4
3419dd2e:	e00f      	b.n	3419dd50 <_ux_dcd_stm32_initialize_complete+0xa0>
        }
        else
        {

            /* The device is operating at high speed.  */
            _ux_system_slave -> ux_system_slave_device_framework =  _ux_system_slave -> ux_system_slave_device_framework_high_speed;
3419dd30:	4b43      	ldr	r3, [pc, #268]	@ (3419de40 <_ux_dcd_stm32_initialize_complete+0x190>)
3419dd32:	681a      	ldr	r2, [r3, #0]
3419dd34:	4b42      	ldr	r3, [pc, #264]	@ (3419de40 <_ux_dcd_stm32_initialize_complete+0x190>)
3419dd36:	681b      	ldr	r3, [r3, #0]
3419dd38:	f8d2 20f0 	ldr.w	r2, [r2, #240]	@ 0xf0
3419dd3c:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
            _ux_system_slave -> ux_system_slave_device_framework_length =  _ux_system_slave -> ux_system_slave_device_framework_length_high_speed;
3419dd40:	4b3f      	ldr	r3, [pc, #252]	@ (3419de40 <_ux_dcd_stm32_initialize_complete+0x190>)
3419dd42:	681a      	ldr	r2, [r3, #0]
3419dd44:	4b3e      	ldr	r3, [pc, #248]	@ (3419de40 <_ux_dcd_stm32_initialize_complete+0x190>)
3419dd46:	681b      	ldr	r3, [r3, #0]
3419dd48:	f8d2 20f4 	ldr.w	r2, [r2, #244]	@ 0xf4
3419dd4c:	f8c3 20e4 	str.w	r2, [r3, #228]	@ 0xe4
        }
    }

    /* Get the device framework pointer.  */
    device_framework =  _ux_system_slave -> ux_system_slave_device_framework;
3419dd50:	4b3b      	ldr	r3, [pc, #236]	@ (3419de40 <_ux_dcd_stm32_initialize_complete+0x190>)
3419dd52:	681b      	ldr	r3, [r3, #0]
3419dd54:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3419dd58:	60bb      	str	r3, [r7, #8]

    /* And create the decompressed device descriptor structure.  */
    _ux_utility_descriptor_parse(device_framework,
                                _ux_system_device_descriptor_structure,
                                UX_DEVICE_DESCRIPTOR_ENTRIES,
                                (UCHAR *) &device -> ux_slave_device_descriptor);
3419dd5a:	68fb      	ldr	r3, [r7, #12]
3419dd5c:	3304      	adds	r3, #4
    _ux_utility_descriptor_parse(device_framework,
3419dd5e:	220e      	movs	r2, #14
3419dd60:	4938      	ldr	r1, [pc, #224]	@ (3419de44 <_ux_dcd_stm32_initialize_complete+0x194>)
3419dd62:	68b8      	ldr	r0, [r7, #8]
3419dd64:	f7fb fca6 	bl	341996b4 <_ux_utility_descriptor_parse>

    /* Now we create a transfer request to accept the first SETUP packet
       and get the ball running. First get the address of the endpoint
       transfer request container.  */
    transfer_request =  &device -> ux_slave_device_control_endpoint.ux_slave_endpoint_transfer_request;
3419dd68:	68fb      	ldr	r3, [r7, #12]
3419dd6a:	3338      	adds	r3, #56	@ 0x38
3419dd6c:	607b      	str	r3, [r7, #4]

    /* Set the timeout to be for Control Endpoint.  */
    transfer_request -> ux_slave_transfer_request_timeout =  UX_MS_TO_TICK(UX_CONTROL_TRANSFER_TIMEOUT);
3419dd6e:	687b      	ldr	r3, [r7, #4]
3419dd70:	f44f 727a 	mov.w	r2, #1000	@ 0x3e8
3419dd74:	64da      	str	r2, [r3, #76]	@ 0x4c

    /* Adjust the current data pointer as well.  */
    transfer_request -> ux_slave_transfer_request_current_data_pointer =
                            transfer_request -> ux_slave_transfer_request_data_pointer;
3419dd76:	687b      	ldr	r3, [r7, #4]
3419dd78:	68da      	ldr	r2, [r3, #12]
    transfer_request -> ux_slave_transfer_request_current_data_pointer =
3419dd7a:	687b      	ldr	r3, [r7, #4]
3419dd7c:	611a      	str	r2, [r3, #16]

    /* Update the transfer request endpoint pointer with the default endpoint.  */
    transfer_request -> ux_slave_transfer_request_endpoint =  &device -> ux_slave_device_control_endpoint;
3419dd7e:	68fb      	ldr	r3, [r7, #12]
3419dd80:	f103 0218 	add.w	r2, r3, #24
3419dd84:	687b      	ldr	r3, [r7, #4]
3419dd86:	609a      	str	r2, [r3, #8]

    /* The control endpoint max packet size needs to be filled manually in its descriptor.  */
    transfer_request -> ux_slave_transfer_request_endpoint -> ux_slave_endpoint_descriptor.wMaxPacketSize =
                                device -> ux_slave_device_descriptor.bMaxPacketSize0;
3419dd88:	68fb      	ldr	r3, [r7, #12]
3419dd8a:	7ada      	ldrb	r2, [r3, #11]
    transfer_request -> ux_slave_transfer_request_endpoint -> ux_slave_endpoint_descriptor.wMaxPacketSize =
3419dd8c:	687b      	ldr	r3, [r7, #4]
3419dd8e:	689b      	ldr	r3, [r3, #8]
3419dd90:	821a      	strh	r2, [r3, #16]

    /* On the control endpoint, always expect the maximum.  */
    transfer_request -> ux_slave_transfer_request_requested_length =
                                device -> ux_slave_device_descriptor.bMaxPacketSize0;
3419dd92:	68fb      	ldr	r3, [r7, #12]
3419dd94:	7adb      	ldrb	r3, [r3, #11]
3419dd96:	461a      	mov	r2, r3
    transfer_request -> ux_slave_transfer_request_requested_length =
3419dd98:	687b      	ldr	r3, [r7, #4]
3419dd9a:	615a      	str	r2, [r3, #20]

    /* Attach the control endpoint to the transfer request.  */
    transfer_request -> ux_slave_transfer_request_endpoint =  &device -> ux_slave_device_control_endpoint;
3419dd9c:	68fb      	ldr	r3, [r7, #12]
3419dd9e:	f103 0218 	add.w	r2, r3, #24
3419dda2:	687b      	ldr	r3, [r7, #4]
3419dda4:	609a      	str	r2, [r3, #8]

    /* Create the default control endpoint attached to the device.
       Once this endpoint is enabled, the host can then send a setup packet
       The device controller will receive it and will call the setup function
       module.  */
    dcd -> ux_slave_dcd_function(dcd, UX_DCD_CREATE_ENDPOINT,
3419dda6:	697b      	ldr	r3, [r7, #20]
3419dda8:	699b      	ldr	r3, [r3, #24]
                                    (VOID *) &device -> ux_slave_device_control_endpoint);
3419ddaa:	68fa      	ldr	r2, [r7, #12]
3419ddac:	3218      	adds	r2, #24
    dcd -> ux_slave_dcd_function(dcd, UX_DCD_CREATE_ENDPOINT,
3419ddae:	210e      	movs	r1, #14
3419ddb0:	6978      	ldr	r0, [r7, #20]
3419ddb2:	4798      	blx	r3

    /* Open Control OUT endpoint.  */
    HAL_PCD_EP_Flush(dcd_stm32 -> pcd_handle, 0x00U);
3419ddb4:	693b      	ldr	r3, [r7, #16]
3419ddb6:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
3419ddba:	2100      	movs	r1, #0
3419ddbc:	4618      	mov	r0, r3
3419ddbe:	f7eb faa9 	bl	34189314 <HAL_PCD_EP_Flush>
    HAL_PCD_EP_Open(dcd_stm32 -> pcd_handle, 0x00U, device -> ux_slave_device_descriptor.bMaxPacketSize0, UX_CONTROL_ENDPOINT);
3419ddc2:	693b      	ldr	r3, [r7, #16]
3419ddc4:	f8d3 00dc 	ldr.w	r0, [r3, #220]	@ 0xdc
3419ddc8:	68fb      	ldr	r3, [r7, #12]
3419ddca:	7adb      	ldrb	r3, [r3, #11]
3419ddcc:	461a      	mov	r2, r3
3419ddce:	2300      	movs	r3, #0
3419ddd0:	2100      	movs	r1, #0
3419ddd2:	f7eb f874 	bl	34188ebe <HAL_PCD_EP_Open>

    /* Open Control IN endpoint.  */
    HAL_PCD_EP_Flush(dcd_stm32 -> pcd_handle, 0x80U);
3419ddd6:	693b      	ldr	r3, [r7, #16]
3419ddd8:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
3419dddc:	2180      	movs	r1, #128	@ 0x80
3419ddde:	4618      	mov	r0, r3
3419dde0:	f7eb fa98 	bl	34189314 <HAL_PCD_EP_Flush>
    HAL_PCD_EP_Open(dcd_stm32 -> pcd_handle, 0x80U, device -> ux_slave_device_descriptor.bMaxPacketSize0, UX_CONTROL_ENDPOINT);
3419dde4:	693b      	ldr	r3, [r7, #16]
3419dde6:	f8d3 00dc 	ldr.w	r0, [r3, #220]	@ 0xdc
3419ddea:	68fb      	ldr	r3, [r7, #12]
3419ddec:	7adb      	ldrb	r3, [r3, #11]
3419ddee:	461a      	mov	r2, r3
3419ddf0:	2300      	movs	r3, #0
3419ddf2:	2180      	movs	r1, #128	@ 0x80
3419ddf4:	f7eb f863 	bl	34188ebe <HAL_PCD_EP_Open>

    /* Ensure the control endpoint is properly reset.  */
    device -> ux_slave_device_control_endpoint.ux_slave_endpoint_state = UX_ENDPOINT_RESET;
3419ddf8:	68fb      	ldr	r3, [r7, #12]
3419ddfa:	2200      	movs	r2, #0
3419ddfc:	61da      	str	r2, [r3, #28]

    /* Mark the phase as SETUP.  */
    transfer_request -> ux_slave_transfer_request_type =  UX_TRANSFER_PHASE_SETUP;
3419ddfe:	687b      	ldr	r3, [r7, #4]
3419de00:	2201      	movs	r2, #1
3419de02:	605a      	str	r2, [r3, #4]

    /* Mark this transfer request as pending.  */
    transfer_request -> ux_slave_transfer_request_status =  UX_TRANSFER_STATUS_PENDING;
3419de04:	687b      	ldr	r3, [r7, #4]
3419de06:	2201      	movs	r2, #1
3419de08:	601a      	str	r2, [r3, #0]

    /* Ask for 8 bytes of the SETUP packet.  */
    transfer_request -> ux_slave_transfer_request_requested_length =    UX_SETUP_SIZE;
3419de0a:	687b      	ldr	r3, [r7, #4]
3419de0c:	2208      	movs	r2, #8
3419de0e:	615a      	str	r2, [r3, #20]
    transfer_request -> ux_slave_transfer_request_in_transfer_length =  UX_SETUP_SIZE;
3419de10:	687b      	ldr	r3, [r7, #4]
3419de12:	2208      	movs	r2, #8
3419de14:	61da      	str	r2, [r3, #28]

    /* Reset the number of bytes sent/received.  */
    transfer_request -> ux_slave_transfer_request_actual_length =  0;
3419de16:	687b      	ldr	r3, [r7, #4]
3419de18:	2200      	movs	r2, #0
3419de1a:	619a      	str	r2, [r3, #24]

    /* Check the status change callback.  */
    if(_ux_system_slave -> ux_system_slave_change_function != UX_NULL)
3419de1c:	4b08      	ldr	r3, [pc, #32]	@ (3419de40 <_ux_dcd_stm32_initialize_complete+0x190>)
3419de1e:	681b      	ldr	r3, [r3, #0]
3419de20:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
3419de24:	2b00      	cmp	r3, #0
3419de26:	d005      	beq.n	3419de34 <_ux_dcd_stm32_initialize_complete+0x184>
    {

        /* Inform the application if a callback function was programmed.  */
        _ux_system_slave -> ux_system_slave_change_function(UX_DEVICE_ATTACHED);
3419de28:	4b05      	ldr	r3, [pc, #20]	@ (3419de40 <_ux_dcd_stm32_initialize_complete+0x190>)
3419de2a:	681b      	ldr	r3, [r3, #0]
3419de2c:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
3419de30:	2001      	movs	r0, #1
3419de32:	4798      	blx	r3

    /* If trace is enabled, register this object.  */
    UX_TRACE_OBJECT_REGISTER(UX_TRACE_DEVICE_OBJECT_TYPE_DEVICE, device, 0, 0, 0)

    /* We are now ready for the USB device to accept the first packet when connected.  */
    return(UX_SUCCESS);
3419de34:	2300      	movs	r3, #0
}
3419de36:	4618      	mov	r0, r3
3419de38:	3718      	adds	r7, #24
3419de3a:	46bd      	mov	sp, r7
3419de3c:	bd80      	pop	{r7, pc}
3419de3e:	bf00      	nop
3419de40:	341c33f8 	.word	0x341c33f8
3419de44:	341c00a8 	.word	0x341c00a8

3419de48 <_ux_dcd_stm32_transfer_abort>:
/*                                                                        */
/*  01-31-2022     Chaoqiong Xiao           Initial Version 6.1.10        */
/*                                                                        */
/**************************************************************************/
UINT  _ux_dcd_stm32_transfer_abort(UX_DCD_STM32 *dcd_stm32, UX_SLAVE_TRANSFER *transfer_request)
{
3419de48:	b580      	push	{r7, lr}
3419de4a:	b084      	sub	sp, #16
3419de4c:	af00      	add	r7, sp, #0
3419de4e:	6078      	str	r0, [r7, #4]
3419de50:	6039      	str	r1, [r7, #0]

   UX_SLAVE_ENDPOINT       *endpoint;


    /* Get the pointer to the logical endpoint from the transfer request.  */
    endpoint =  transfer_request -> ux_slave_transfer_request_endpoint;
3419de52:	683b      	ldr	r3, [r7, #0]
3419de54:	689b      	ldr	r3, [r3, #8]
3419de56:	60fb      	str	r3, [r7, #12]

    HAL_PCD_EP_Abort(dcd_stm32 -> pcd_handle, endpoint->ux_slave_endpoint_descriptor.bEndpointAddress);
3419de58:	687b      	ldr	r3, [r7, #4]
3419de5a:	f8d3 20dc 	ldr.w	r2, [r3, #220]	@ 0xdc
3419de5e:	68fb      	ldr	r3, [r7, #12]
3419de60:	7b9b      	ldrb	r3, [r3, #14]
3419de62:	4619      	mov	r1, r3
3419de64:	4610      	mov	r0, r2
3419de66:	f7eb fa24 	bl	341892b2 <HAL_PCD_EP_Abort>
    HAL_PCD_EP_Flush(dcd_stm32 -> pcd_handle, endpoint->ux_slave_endpoint_descriptor.bEndpointAddress);
3419de6a:	687b      	ldr	r3, [r7, #4]
3419de6c:	f8d3 20dc 	ldr.w	r2, [r3, #220]	@ 0xdc
3419de70:	68fb      	ldr	r3, [r7, #12]
3419de72:	7b9b      	ldrb	r3, [r3, #14]
3419de74:	4619      	mov	r1, r3
3419de76:	4610      	mov	r0, r2
3419de78:	f7eb fa4c 	bl	34189314 <HAL_PCD_EP_Flush>

    /* No semaphore put here since it's already done in stack.  */
#endif /* USBD_HAL_TRANSFER_ABORT_NOT_SUPPORTED */

    /* Return to caller with success.  */
    return(UX_SUCCESS);
3419de7c:	2300      	movs	r3, #0
}
3419de7e:	4618      	mov	r0, r3
3419de80:	3710      	adds	r7, #16
3419de82:	46bd      	mov	sp, r7
3419de84:	bd80      	pop	{r7, pc}

3419de86 <_ux_dcd_stm32_transfer_request>:
/*                                            controller,                 */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _ux_dcd_stm32_transfer_request(UX_DCD_STM32 *dcd_stm32, UX_SLAVE_TRANSFER *transfer_request)
{
3419de86:	b580      	push	{r7, lr}
3419de88:	b084      	sub	sp, #16
3419de8a:	af00      	add	r7, sp, #0
3419de8c:	6078      	str	r0, [r7, #4]
3419de8e:	6039      	str	r1, [r7, #0]
UX_SLAVE_ENDPOINT       *endpoint;
UINT                    status;


    /* Get the pointer to the logical endpoint from the transfer request.  */
    endpoint =  transfer_request -> ux_slave_transfer_request_endpoint;
3419de90:	683b      	ldr	r3, [r7, #0]
3419de92:	689b      	ldr	r3, [r3, #8]
3419de94:	60fb      	str	r3, [r7, #12]

    /* Check for transfer direction.  Is this a IN endpoint ? */
    if (transfer_request -> ux_slave_transfer_request_phase == UX_TRANSFER_PHASE_DATA_OUT)
3419de96:	683b      	ldr	r3, [r7, #0]
3419de98:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3419de9a:	2b03      	cmp	r3, #3
3419de9c:	d12c      	bne.n	3419def8 <_ux_dcd_stm32_transfer_request+0x72>
    {

        /* Transmit data.  */
        HAL_PCD_EP_Transmit(dcd_stm32 -> pcd_handle,
3419de9e:	687b      	ldr	r3, [r7, #4]
3419dea0:	f8d3 00dc 	ldr.w	r0, [r3, #220]	@ 0xdc
3419dea4:	68fb      	ldr	r3, [r7, #12]
3419dea6:	7b99      	ldrb	r1, [r3, #14]
                            endpoint->ux_slave_endpoint_descriptor.bEndpointAddress,
                            transfer_request->ux_slave_transfer_request_data_pointer,
3419dea8:	683b      	ldr	r3, [r7, #0]
3419deaa:	68da      	ldr	r2, [r3, #12]
        HAL_PCD_EP_Transmit(dcd_stm32 -> pcd_handle,
3419deac:	683b      	ldr	r3, [r7, #0]
3419deae:	695b      	ldr	r3, [r3, #20]
3419deb0:	f7eb f90c 	bl	341890cc <HAL_PCD_EP_Transmit>
                            transfer_request->ux_slave_transfer_request_requested_length);

        /* If the endpoint is a Control endpoint, all this is happening under Interrupt and there is no
           thread to suspend.  */
        if ((endpoint -> ux_slave_endpoint_descriptor.bEndpointAddress & (UINT)~UX_ENDPOINT_DIRECTION) != 0)
3419deb4:	68fb      	ldr	r3, [r7, #12]
3419deb6:	7b9b      	ldrb	r3, [r3, #14]
3419deb8:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
3419debc:	2b00      	cmp	r3, #0
3419debe:	d044      	beq.n	3419df4a <_ux_dcd_stm32_transfer_request+0xc4>
        {

            /* We should wait for the semaphore to wake us up.  */
            status =  _ux_utility_semaphore_get(&transfer_request -> ux_slave_transfer_request_semaphore,
3419dec0:	683b      	ldr	r3, [r7, #0]
3419dec2:	f103 0230 	add.w	r2, r3, #48	@ 0x30
                                                (ULONG)transfer_request -> ux_slave_transfer_request_timeout);
3419dec6:	683b      	ldr	r3, [r7, #0]
3419dec8:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
            status =  _ux_utility_semaphore_get(&transfer_request -> ux_slave_transfer_request_semaphore,
3419deca:	4619      	mov	r1, r3
3419decc:	4610      	mov	r0, r2
3419dece:	f7fc f807 	bl	34199ee0 <_ux_utility_semaphore_get>
3419ded2:	60b8      	str	r0, [r7, #8]

            /* Check the completion code. */
            if (status != UX_SUCCESS)
3419ded4:	68bb      	ldr	r3, [r7, #8]
3419ded6:	2b00      	cmp	r3, #0
3419ded8:	d001      	beq.n	3419dede <_ux_dcd_stm32_transfer_request+0x58>
                return(status);
3419deda:	68bb      	ldr	r3, [r7, #8]
3419dedc:	e036      	b.n	3419df4c <_ux_dcd_stm32_transfer_request+0xc6>

            transfer_request -> ux_slave_transfer_request_actual_length = transfer_request->ux_slave_transfer_request_requested_length;
3419dede:	683b      	ldr	r3, [r7, #0]
3419dee0:	695a      	ldr	r2, [r3, #20]
3419dee2:	683b      	ldr	r3, [r7, #0]
3419dee4:	619a      	str	r2, [r3, #24]

            /* Check the transfer request completion code. We may have had a BUS reset or
               a device disconnection.  */
            if (transfer_request -> ux_slave_transfer_request_completion_code != UX_SUCCESS)
3419dee6:	683b      	ldr	r3, [r7, #0]
3419dee8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3419deea:	2b00      	cmp	r3, #0
3419deec:	d002      	beq.n	3419def4 <_ux_dcd_stm32_transfer_request+0x6e>
                return(transfer_request -> ux_slave_transfer_request_completion_code);
3419deee:	683b      	ldr	r3, [r7, #0]
3419def0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3419def2:	e02b      	b.n	3419df4c <_ux_dcd_stm32_transfer_request+0xc6>

            /* Return to caller with success.  */
            return(UX_SUCCESS);
3419def4:	2300      	movs	r3, #0
3419def6:	e029      	b.n	3419df4c <_ux_dcd_stm32_transfer_request+0xc6>
    else
    {

        /* We have a request for a SETUP or OUT Endpoint.  */
        /* Receive data.  */
        HAL_PCD_EP_Receive(dcd_stm32 -> pcd_handle,
3419def8:	687b      	ldr	r3, [r7, #4]
3419defa:	f8d3 00dc 	ldr.w	r0, [r3, #220]	@ 0xdc
3419defe:	68fb      	ldr	r3, [r7, #12]
3419df00:	7b99      	ldrb	r1, [r3, #14]
                            endpoint->ux_slave_endpoint_descriptor.bEndpointAddress,
                            transfer_request->ux_slave_transfer_request_data_pointer,
3419df02:	683b      	ldr	r3, [r7, #0]
3419df04:	68da      	ldr	r2, [r3, #12]
        HAL_PCD_EP_Receive(dcd_stm32 -> pcd_handle,
3419df06:	683b      	ldr	r3, [r7, #0]
3419df08:	695b      	ldr	r3, [r3, #20]
3419df0a:	f7eb f88c 	bl	34189026 <HAL_PCD_EP_Receive>
                            transfer_request->ux_slave_transfer_request_requested_length);

        /* If the endpoint is a Control endpoint, all this is happening under Interrupt and there is no
           thread to suspend.  */
        if ((endpoint -> ux_slave_endpoint_descriptor.bEndpointAddress & (UINT)~UX_ENDPOINT_DIRECTION) != 0)
3419df0e:	68fb      	ldr	r3, [r7, #12]
3419df10:	7b9b      	ldrb	r3, [r3, #14]
3419df12:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
3419df16:	2b00      	cmp	r3, #0
3419df18:	d017      	beq.n	3419df4a <_ux_dcd_stm32_transfer_request+0xc4>
        {

            /* We should wait for the semaphore to wake us up.  */
            status =  _ux_utility_semaphore_get(&transfer_request -> ux_slave_transfer_request_semaphore,
3419df1a:	683b      	ldr	r3, [r7, #0]
3419df1c:	f103 0230 	add.w	r2, r3, #48	@ 0x30
                                                (ULONG)transfer_request -> ux_slave_transfer_request_timeout);
3419df20:	683b      	ldr	r3, [r7, #0]
3419df22:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
            status =  _ux_utility_semaphore_get(&transfer_request -> ux_slave_transfer_request_semaphore,
3419df24:	4619      	mov	r1, r3
3419df26:	4610      	mov	r0, r2
3419df28:	f7fb ffda 	bl	34199ee0 <_ux_utility_semaphore_get>
3419df2c:	60b8      	str	r0, [r7, #8]

            /* Check the completion code. */
            if (status != UX_SUCCESS)
3419df2e:	68bb      	ldr	r3, [r7, #8]
3419df30:	2b00      	cmp	r3, #0
3419df32:	d001      	beq.n	3419df38 <_ux_dcd_stm32_transfer_request+0xb2>
                return(status);
3419df34:	68bb      	ldr	r3, [r7, #8]
3419df36:	e009      	b.n	3419df4c <_ux_dcd_stm32_transfer_request+0xc6>

            /* Check the transfer request completion code. We may have had a BUS reset or
               a device disconnection.  */
            if (transfer_request -> ux_slave_transfer_request_completion_code != UX_SUCCESS)
3419df38:	683b      	ldr	r3, [r7, #0]
3419df3a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3419df3c:	2b00      	cmp	r3, #0
3419df3e:	d002      	beq.n	3419df46 <_ux_dcd_stm32_transfer_request+0xc0>
                return(transfer_request -> ux_slave_transfer_request_completion_code);
3419df40:	683b      	ldr	r3, [r7, #0]
3419df42:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3419df44:	e002      	b.n	3419df4c <_ux_dcd_stm32_transfer_request+0xc6>

            /* Return to caller with success.  */
            return(UX_SUCCESS);
3419df46:	2300      	movs	r3, #0
3419df48:	e000      	b.n	3419df4c <_ux_dcd_stm32_transfer_request+0xc6>
        }
    }

    /* Return to caller with success.  */
    return(UX_SUCCESS);
3419df4a:	2300      	movs	r3, #0
}
3419df4c:	4618      	mov	r0, r3
3419df4e:	3710      	adds	r7, #16
3419df50:	46bd      	mov	sp, r7
3419df52:	bd80      	pop	{r7, pc}

3419df54 <malloc>:
3419df54:	4b02      	ldr	r3, [pc, #8]	@ (3419df60 <malloc+0xc>)
3419df56:	4601      	mov	r1, r0
3419df58:	6818      	ldr	r0, [r3, #0]
3419df5a:	f000 b825 	b.w	3419dfa8 <_malloc_r>
3419df5e:	bf00      	nop
3419df60:	341c0128 	.word	0x341c0128

3419df64 <sbrk_aligned>:
3419df64:	b570      	push	{r4, r5, r6, lr}
3419df66:	4e0f      	ldr	r6, [pc, #60]	@ (3419dfa4 <sbrk_aligned+0x40>)
3419df68:	460c      	mov	r4, r1
3419df6a:	4605      	mov	r5, r0
3419df6c:	6831      	ldr	r1, [r6, #0]
3419df6e:	b911      	cbnz	r1, 3419df76 <sbrk_aligned+0x12>
3419df70:	f000 f8ae 	bl	3419e0d0 <_sbrk_r>
3419df74:	6030      	str	r0, [r6, #0]
3419df76:	4621      	mov	r1, r4
3419df78:	4628      	mov	r0, r5
3419df7a:	f000 f8a9 	bl	3419e0d0 <_sbrk_r>
3419df7e:	1c43      	adds	r3, r0, #1
3419df80:	d103      	bne.n	3419df8a <sbrk_aligned+0x26>
3419df82:	f04f 34ff 	mov.w	r4, #4294967295
3419df86:	4620      	mov	r0, r4
3419df88:	bd70      	pop	{r4, r5, r6, pc}
3419df8a:	1cc4      	adds	r4, r0, #3
3419df8c:	f024 0403 	bic.w	r4, r4, #3
3419df90:	42a0      	cmp	r0, r4
3419df92:	d0f8      	beq.n	3419df86 <sbrk_aligned+0x22>
3419df94:	1a21      	subs	r1, r4, r0
3419df96:	4628      	mov	r0, r5
3419df98:	f000 f89a 	bl	3419e0d0 <_sbrk_r>
3419df9c:	3001      	adds	r0, #1
3419df9e:	d1f2      	bne.n	3419df86 <sbrk_aligned+0x22>
3419dfa0:	e7ef      	b.n	3419df82 <sbrk_aligned+0x1e>
3419dfa2:	bf00      	nop
3419dfa4:	341c33fc 	.word	0x341c33fc

3419dfa8 <_malloc_r>:
3419dfa8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
3419dfac:	1ccd      	adds	r5, r1, #3
3419dfae:	4606      	mov	r6, r0
3419dfb0:	f025 0503 	bic.w	r5, r5, #3
3419dfb4:	3508      	adds	r5, #8
3419dfb6:	2d0c      	cmp	r5, #12
3419dfb8:	bf38      	it	cc
3419dfba:	250c      	movcc	r5, #12
3419dfbc:	2d00      	cmp	r5, #0
3419dfbe:	db01      	blt.n	3419dfc4 <_malloc_r+0x1c>
3419dfc0:	42a9      	cmp	r1, r5
3419dfc2:	d904      	bls.n	3419dfce <_malloc_r+0x26>
3419dfc4:	230c      	movs	r3, #12
3419dfc6:	6033      	str	r3, [r6, #0]
3419dfc8:	2000      	movs	r0, #0
3419dfca:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
3419dfce:	f8df 80d4 	ldr.w	r8, [pc, #212]	@ 3419e0a4 <_malloc_r+0xfc>
3419dfd2:	f000 f869 	bl	3419e0a8 <__malloc_lock>
3419dfd6:	f8d8 3000 	ldr.w	r3, [r8]
3419dfda:	461c      	mov	r4, r3
3419dfdc:	bb44      	cbnz	r4, 3419e030 <_malloc_r+0x88>
3419dfde:	4629      	mov	r1, r5
3419dfe0:	4630      	mov	r0, r6
3419dfe2:	f7ff ffbf 	bl	3419df64 <sbrk_aligned>
3419dfe6:	1c43      	adds	r3, r0, #1
3419dfe8:	4604      	mov	r4, r0
3419dfea:	d158      	bne.n	3419e09e <_malloc_r+0xf6>
3419dfec:	f8d8 4000 	ldr.w	r4, [r8]
3419dff0:	4627      	mov	r7, r4
3419dff2:	2f00      	cmp	r7, #0
3419dff4:	d143      	bne.n	3419e07e <_malloc_r+0xd6>
3419dff6:	2c00      	cmp	r4, #0
3419dff8:	d04b      	beq.n	3419e092 <_malloc_r+0xea>
3419dffa:	6823      	ldr	r3, [r4, #0]
3419dffc:	4639      	mov	r1, r7
3419dffe:	4630      	mov	r0, r6
3419e000:	eb04 0903 	add.w	r9, r4, r3
3419e004:	f000 f864 	bl	3419e0d0 <_sbrk_r>
3419e008:	4581      	cmp	r9, r0
3419e00a:	d142      	bne.n	3419e092 <_malloc_r+0xea>
3419e00c:	6821      	ldr	r1, [r4, #0]
3419e00e:	4630      	mov	r0, r6
3419e010:	1a6d      	subs	r5, r5, r1
3419e012:	4629      	mov	r1, r5
3419e014:	f7ff ffa6 	bl	3419df64 <sbrk_aligned>
3419e018:	3001      	adds	r0, #1
3419e01a:	d03a      	beq.n	3419e092 <_malloc_r+0xea>
3419e01c:	6823      	ldr	r3, [r4, #0]
3419e01e:	442b      	add	r3, r5
3419e020:	6023      	str	r3, [r4, #0]
3419e022:	f8d8 3000 	ldr.w	r3, [r8]
3419e026:	685a      	ldr	r2, [r3, #4]
3419e028:	bb62      	cbnz	r2, 3419e084 <_malloc_r+0xdc>
3419e02a:	f8c8 7000 	str.w	r7, [r8]
3419e02e:	e00f      	b.n	3419e050 <_malloc_r+0xa8>
3419e030:	6822      	ldr	r2, [r4, #0]
3419e032:	1b52      	subs	r2, r2, r5
3419e034:	d420      	bmi.n	3419e078 <_malloc_r+0xd0>
3419e036:	2a0b      	cmp	r2, #11
3419e038:	d917      	bls.n	3419e06a <_malloc_r+0xc2>
3419e03a:	1961      	adds	r1, r4, r5
3419e03c:	42a3      	cmp	r3, r4
3419e03e:	6025      	str	r5, [r4, #0]
3419e040:	bf18      	it	ne
3419e042:	6059      	strne	r1, [r3, #4]
3419e044:	6863      	ldr	r3, [r4, #4]
3419e046:	bf08      	it	eq
3419e048:	f8c8 1000 	streq.w	r1, [r8]
3419e04c:	5162      	str	r2, [r4, r5]
3419e04e:	604b      	str	r3, [r1, #4]
3419e050:	4630      	mov	r0, r6
3419e052:	f000 f82f 	bl	3419e0b4 <__malloc_unlock>
3419e056:	f104 000b 	add.w	r0, r4, #11
3419e05a:	1d23      	adds	r3, r4, #4
3419e05c:	f020 0007 	bic.w	r0, r0, #7
3419e060:	1ac2      	subs	r2, r0, r3
3419e062:	bf1c      	itt	ne
3419e064:	1a1b      	subne	r3, r3, r0
3419e066:	50a3      	strne	r3, [r4, r2]
3419e068:	e7af      	b.n	3419dfca <_malloc_r+0x22>
3419e06a:	6862      	ldr	r2, [r4, #4]
3419e06c:	42a3      	cmp	r3, r4
3419e06e:	bf0c      	ite	eq
3419e070:	f8c8 2000 	streq.w	r2, [r8]
3419e074:	605a      	strne	r2, [r3, #4]
3419e076:	e7eb      	b.n	3419e050 <_malloc_r+0xa8>
3419e078:	4623      	mov	r3, r4
3419e07a:	6864      	ldr	r4, [r4, #4]
3419e07c:	e7ae      	b.n	3419dfdc <_malloc_r+0x34>
3419e07e:	463c      	mov	r4, r7
3419e080:	687f      	ldr	r7, [r7, #4]
3419e082:	e7b6      	b.n	3419dff2 <_malloc_r+0x4a>
3419e084:	461a      	mov	r2, r3
3419e086:	685b      	ldr	r3, [r3, #4]
3419e088:	42a3      	cmp	r3, r4
3419e08a:	d1fb      	bne.n	3419e084 <_malloc_r+0xdc>
3419e08c:	2300      	movs	r3, #0
3419e08e:	6053      	str	r3, [r2, #4]
3419e090:	e7de      	b.n	3419e050 <_malloc_r+0xa8>
3419e092:	230c      	movs	r3, #12
3419e094:	4630      	mov	r0, r6
3419e096:	6033      	str	r3, [r6, #0]
3419e098:	f000 f80c 	bl	3419e0b4 <__malloc_unlock>
3419e09c:	e794      	b.n	3419dfc8 <_malloc_r+0x20>
3419e09e:	6005      	str	r5, [r0, #0]
3419e0a0:	e7d6      	b.n	3419e050 <_malloc_r+0xa8>
3419e0a2:	bf00      	nop
3419e0a4:	341c3400 	.word	0x341c3400

3419e0a8 <__malloc_lock>:
3419e0a8:	4801      	ldr	r0, [pc, #4]	@ (3419e0b0 <__malloc_lock+0x8>)
3419e0aa:	f000 b84b 	b.w	3419e144 <__retarget_lock_acquire_recursive>
3419e0ae:	bf00      	nop
3419e0b0:	341c3540 	.word	0x341c3540

3419e0b4 <__malloc_unlock>:
3419e0b4:	4801      	ldr	r0, [pc, #4]	@ (3419e0bc <__malloc_unlock+0x8>)
3419e0b6:	f000 b846 	b.w	3419e146 <__retarget_lock_release_recursive>
3419e0ba:	bf00      	nop
3419e0bc:	341c3540 	.word	0x341c3540

3419e0c0 <memset>:
3419e0c0:	4402      	add	r2, r0
3419e0c2:	4603      	mov	r3, r0
3419e0c4:	4293      	cmp	r3, r2
3419e0c6:	d100      	bne.n	3419e0ca <memset+0xa>
3419e0c8:	4770      	bx	lr
3419e0ca:	f803 1b01 	strb.w	r1, [r3], #1
3419e0ce:	e7f9      	b.n	3419e0c4 <memset+0x4>

3419e0d0 <_sbrk_r>:
3419e0d0:	b538      	push	{r3, r4, r5, lr}
3419e0d2:	2300      	movs	r3, #0
3419e0d4:	4d05      	ldr	r5, [pc, #20]	@ (3419e0ec <_sbrk_r+0x1c>)
3419e0d6:	4604      	mov	r4, r0
3419e0d8:	4608      	mov	r0, r1
3419e0da:	602b      	str	r3, [r5, #0]
3419e0dc:	f7e3 fce4 	bl	34181aa8 <_sbrk>
3419e0e0:	1c43      	adds	r3, r0, #1
3419e0e2:	d102      	bne.n	3419e0ea <_sbrk_r+0x1a>
3419e0e4:	682b      	ldr	r3, [r5, #0]
3419e0e6:	b103      	cbz	r3, 3419e0ea <_sbrk_r+0x1a>
3419e0e8:	6023      	str	r3, [r4, #0]
3419e0ea:	bd38      	pop	{r3, r4, r5, pc}
3419e0ec:	341c353c 	.word	0x341c353c

3419e0f0 <__errno>:
3419e0f0:	4b01      	ldr	r3, [pc, #4]	@ (3419e0f8 <__errno+0x8>)
3419e0f2:	6818      	ldr	r0, [r3, #0]
3419e0f4:	4770      	bx	lr
3419e0f6:	bf00      	nop
3419e0f8:	341c0128 	.word	0x341c0128

3419e0fc <__libc_init_array>:
3419e0fc:	b570      	push	{r4, r5, r6, lr}
3419e0fe:	4d0d      	ldr	r5, [pc, #52]	@ (3419e134 <__libc_init_array+0x38>)
3419e100:	2600      	movs	r6, #0
3419e102:	4c0d      	ldr	r4, [pc, #52]	@ (3419e138 <__libc_init_array+0x3c>)
3419e104:	1b64      	subs	r4, r4, r5
3419e106:	10a4      	asrs	r4, r4, #2
3419e108:	42a6      	cmp	r6, r4
3419e10a:	d109      	bne.n	3419e120 <__libc_init_array+0x24>
3419e10c:	4d0b      	ldr	r5, [pc, #44]	@ (3419e13c <__libc_init_array+0x40>)
3419e10e:	2600      	movs	r6, #0
3419e110:	4c0b      	ldr	r4, [pc, #44]	@ (3419e140 <__libc_init_array+0x44>)
3419e112:	f000 f81d 	bl	3419e150 <_init>
3419e116:	1b64      	subs	r4, r4, r5
3419e118:	10a4      	asrs	r4, r4, #2
3419e11a:	42a6      	cmp	r6, r4
3419e11c:	d105      	bne.n	3419e12a <__libc_init_array+0x2e>
3419e11e:	bd70      	pop	{r4, r5, r6, pc}
3419e120:	f855 3b04 	ldr.w	r3, [r5], #4
3419e124:	3601      	adds	r6, #1
3419e126:	4798      	blx	r3
3419e128:	e7ee      	b.n	3419e108 <__libc_init_array+0xc>
3419e12a:	f855 3b04 	ldr.w	r3, [r5], #4
3419e12e:	3601      	adds	r6, #1
3419e130:	4798      	blx	r3
3419e132:	e7f2      	b.n	3419e11a <__libc_init_array+0x1e>
3419e134:	3419e498 	.word	0x3419e498
3419e138:	3419e498 	.word	0x3419e498
3419e13c:	3419e498 	.word	0x3419e498
3419e140:	3419e49c 	.word	0x3419e49c

3419e144 <__retarget_lock_acquire_recursive>:
3419e144:	4770      	bx	lr

3419e146 <__retarget_lock_release_recursive>:
3419e146:	4770      	bx	lr

3419e148 <__aeabi_memclr>:
3419e148:	2200      	movs	r2, #0
3419e14a:	f7e2 bcfc 	b.w	34180b46 <__aeabi_memset>
	...

3419e150 <_init>:
3419e150:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
3419e152:	bf00      	nop
3419e154:	bcf8      	pop	{r3, r4, r5, r6, r7}
3419e156:	bc08      	pop	{r3}
3419e158:	469e      	mov	lr, r3
3419e15a:	4770      	bx	lr

3419e15c <_fini>:
3419e15c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
3419e15e:	bf00      	nop
3419e160:	bcf8      	pop	{r3, r4, r5, r6, r7}
3419e162:	bc08      	pop	{r3}
3419e164:	469e      	mov	lr, r3
3419e166:	4770      	bx	lr

Disassembly of section .gnu.sgstubs:

3419e620 <SECURE_SystemCoreClockUpdate>:
3419e620:	e97f e97f 	sg
3419e624:	f7e6 bf8a 	b.w	3418553c <__acle_se_SECURE_SystemCoreClockUpdate>
	...
